/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
@endpointMap = {
    ap-northeast-2-pop = 'mts.aliyuncs.com',
    ap-southeast-2 = 'mts.aliyuncs.com',
    ap-southeast-3 = 'mts.aliyuncs.com',
    cn-beijing-finance-1 = 'mts.aliyuncs.com',
    cn-beijing-finance-pop = 'mts.aliyuncs.com',
    cn-beijing-gov-1 = 'mts.aliyuncs.com',
    cn-beijing-nu16-b01 = 'mts.aliyuncs.com',
    cn-chengdu = 'mts.aliyuncs.com',
    cn-edge-1 = 'mts.aliyuncs.com',
    cn-fujian = 'mts.aliyuncs.com',
    cn-haidian-cm12-c01 = 'mts.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'mts.aliyuncs.com',
    cn-hangzhou-finance = 'mts.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'mts.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'mts.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'mts.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'mts.aliyuncs.com',
    cn-hangzhou-test-306 = 'mts.aliyuncs.com',
    cn-hongkong-finance-pop = 'mts.aliyuncs.com',
    cn-huhehaote-nebula-1 = 'mts.aliyuncs.com',
    cn-north-2-gov-1 = 'mts.aliyuncs.com',
    cn-qingdao-nebula = 'mts.aliyuncs.com',
    cn-shanghai-et15-b01 = 'mts.aliyuncs.com',
    cn-shanghai-et2-b01 = 'mts.aliyuncs.com',
    cn-shanghai-finance-1 = 'mts.aliyuncs.com',
    cn-shanghai-inner = 'mts.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'mts.aliyuncs.com',
    cn-shenzhen-finance-1 = 'mts.aliyuncs.com',
    cn-shenzhen-inner = 'mts.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'mts.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'mts.aliyuncs.com',
    cn-wuhan = 'mts.aliyuncs.com',
    cn-wulanchabu = 'mts.aliyuncs.com',
    cn-yushanfang = 'mts.aliyuncs.com',
    cn-zhangbei = 'mts.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'mts.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'mts.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'mts.aliyuncs.com',
    eu-west-1-oxs = 'mts.aliyuncs.com',
    me-east-1 = 'mts.aliyuncs.com',
    rus-west-1-pop = 'mts.aliyuncs.com',
    us-east-1 = 'mts.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('mts', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model ActivateMediaWorkflowRequest {
  mediaWorkflowId?: string(name='MediaWorkflowId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ActivateMediaWorkflowResponseBody = {
  mediaWorkflow?: {
    creationTime?: string(name='CreationTime'),
    mediaWorkflowId?: string(name='MediaWorkflowId'),
    name?: string(name='Name'),
    state?: string(name='State'),
    topology?: string(name='Topology'),
  }(name='MediaWorkflow'),
  requestId?: string(name='RequestId'),
}

model ActivateMediaWorkflowResponse = {
  headers: map[string]string(name='headers'),
  body: ActivateMediaWorkflowResponseBody(name='body'),
}

async function activateMediaWorkflowWithOptions(request: ActivateMediaWorkflowRequest, runtime: Util.RuntimeOptions): ActivateMediaWorkflowResponse {
  Util.validateModel(request);
  var query = {};
  query["MediaWorkflowId"] = request.mediaWorkflowId;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ActivateMediaWorkflow',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function activateMediaWorkflow(request: ActivateMediaWorkflowRequest): ActivateMediaWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  return activateMediaWorkflowWithOptions(request, runtime);
}

model AddAsrPipelineRequest {
  name?: string(name='Name'),
  notifyConfig?: string(name='NotifyConfig'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  priority?: int32(name='Priority'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model AddAsrPipelineResponseBody = {
  pipeline?: {
    id?: string(name='Id'),
    name?: string(name='Name'),
    notifyConfig?: {
      queue?: string(name='Queue'),
      topic?: string(name='Topic'),
    }(name='NotifyConfig'),
    priority?: int32(name='Priority'),
    state?: string(name='State'),
  }(name='Pipeline'),
  requestId?: string(name='RequestId'),
}

model AddAsrPipelineResponse = {
  headers: map[string]string(name='headers'),
  body: AddAsrPipelineResponseBody(name='body'),
}

async function addAsrPipelineWithOptions(request: AddAsrPipelineRequest, runtime: Util.RuntimeOptions): AddAsrPipelineResponse {
  Util.validateModel(request);
  var query = {};
  query["Name"] = request.name;
  query["NotifyConfig"] = request.notifyConfig;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["Priority"] = request.priority;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'AddAsrPipeline',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addAsrPipeline(request: AddAsrPipelineRequest): AddAsrPipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return addAsrPipelineWithOptions(request, runtime);
}

model AddCategoryRequest {
  cateName?: string(name='CateName'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  parentId?: long(name='ParentId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model AddCategoryResponseBody = {
  category?: {
    cateId?: string(name='CateId'),
    cateName?: string(name='CateName'),
    level?: string(name='Level'),
    parentId?: string(name='ParentId'),
  }(name='Category'),
  requestId?: string(name='RequestId'),
}

model AddCategoryResponse = {
  headers: map[string]string(name='headers'),
  body: AddCategoryResponseBody(name='body'),
}

async function addCategoryWithOptions(request: AddCategoryRequest, runtime: Util.RuntimeOptions): AddCategoryResponse {
  Util.validateModel(request);
  var query = {};
  query["CateName"] = request.cateName;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ParentId"] = request.parentId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'AddCategory',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addCategory(request: AddCategoryRequest): AddCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return addCategoryWithOptions(request, runtime);
}

model AddCensorPipelineRequest {
  name?: string(name='Name'),
  notifyConfig?: string(name='NotifyConfig'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  priority?: int32(name='Priority'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model AddCensorPipelineResponseBody = {
  pipeline?: {
    id?: string(name='Id'),
    name?: string(name='Name'),
    notifyConfig?: {
      queue?: string(name='Queue'),
      topic?: string(name='Topic'),
    }(name='NotifyConfig'),
    priority?: int32(name='Priority'),
    state?: string(name='State'),
  }(name='Pipeline'),
  requestId?: string(name='RequestId'),
}

model AddCensorPipelineResponse = {
  headers: map[string]string(name='headers'),
  body: AddCensorPipelineResponseBody(name='body'),
}

async function addCensorPipelineWithOptions(request: AddCensorPipelineRequest, runtime: Util.RuntimeOptions): AddCensorPipelineResponse {
  Util.validateModel(request);
  var query = {};
  query["Name"] = request.name;
  query["NotifyConfig"] = request.notifyConfig;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["Priority"] = request.priority;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'AddCensorPipeline',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addCensorPipeline(request: AddCensorPipelineRequest): AddCensorPipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return addCensorPipelineWithOptions(request, runtime);
}

model AddCoverPipelineRequest {
  name?: string(name='Name'),
  notifyConfig?: string(name='NotifyConfig'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  priority?: string(name='Priority'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  role?: string(name='Role'),
}

model AddCoverPipelineResponseBody = {
  pipeline?: {
    id?: string(name='Id'),
    name?: string(name='Name'),
    notifyConfig?: {
      queue?: string(name='Queue'),
      topic?: string(name='Topic'),
    }(name='NotifyConfig'),
    priority?: string(name='Priority'),
    role?: string(name='Role'),
    state?: string(name='State'),
  }(name='Pipeline'),
  requestId?: string(name='RequestId'),
}

model AddCoverPipelineResponse = {
  headers: map[string]string(name='headers'),
  body: AddCoverPipelineResponseBody(name='body'),
}

async function addCoverPipelineWithOptions(request: AddCoverPipelineRequest, runtime: Util.RuntimeOptions): AddCoverPipelineResponse {
  Util.validateModel(request);
  var query = {};
  query["Name"] = request.name;
  query["NotifyConfig"] = request.notifyConfig;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["Priority"] = request.priority;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["Role"] = request.role;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'AddCoverPipeline',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addCoverPipeline(request: AddCoverPipelineRequest): AddCoverPipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return addCoverPipelineWithOptions(request, runtime);
}

model AddMCTemplateRequest {
  abuse?: string(name='Abuse'),
  ad?: string(name='Ad'),
  contraband?: string(name='Contraband'),
  live?: string(name='Live'),
  logo?: string(name='Logo'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  politics?: string(name='Politics'),
  porn?: string(name='Porn'),
  qrcode?: string(name='Qrcode'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  terrorism?: string(name='Terrorism'),
  spam?: string(name='spam'),
}

model AddMCTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  template?: {
    abuse?: string(name='Abuse'),
    ad?: string(name='Ad'),
    contraband?: string(name='Contraband'),
    live?: string(name='Live'),
    logo?: string(name='Logo'),
    name?: string(name='Name'),
    politics?: string(name='Politics'),
    porn?: string(name='Porn'),
    qrcode?: string(name='Qrcode'),
    spam?: string(name='Spam'),
    templateId?: string(name='TemplateId'),
    terrorism?: string(name='Terrorism'),
  }(name='Template'),
}

model AddMCTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: AddMCTemplateResponseBody(name='body'),
}

async function addMCTemplateWithOptions(request: AddMCTemplateRequest, runtime: Util.RuntimeOptions): AddMCTemplateResponse {
  Util.validateModel(request);
  var query = {};
  query["Abuse"] = request.abuse;
  query["Ad"] = request.ad;
  query["Contraband"] = request.contraband;
  query["Live"] = request.live;
  query["Logo"] = request.logo;
  query["Name"] = request.name;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["Politics"] = request.politics;
  query["Porn"] = request.porn;
  query["Qrcode"] = request.qrcode;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["Terrorism"] = request.terrorism;
  query["spam"] = request.spam;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'AddMCTemplate',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addMCTemplate(request: AddMCTemplateRequest): AddMCTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return addMCTemplateWithOptions(request, runtime);
}

model AddMediaRequest {
  cateId?: long(name='CateId'),
  coverURL?: string(name='CoverURL'),
  description?: string(name='Description'),
  fileURL?: string(name='FileURL'),
  inputUnbind?: boolean(name='InputUnbind'),
  mediaWorkflowId?: string(name='MediaWorkflowId'),
  mediaWorkflowUserData?: string(name='MediaWorkflowUserData'),
  overrideParams?: string(name='OverrideParams'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  tags?: string(name='Tags'),
  title?: string(name='Title'),
}

model AddMediaResponseBody = {
  media?: {
    bitrate?: string(name='Bitrate'),
    cateId?: long(name='CateId'),
    censorState?: string(name='CensorState'),
    coverURL?: string(name='CoverURL'),
    creationTime?: string(name='CreationTime'),
    description?: string(name='Description'),
    duration?: string(name='Duration'),
    file?: {
      state?: string(name='State'),
      URL?: string(name='URL'),
    }(name='File'),
    format?: string(name='Format'),
    fps?: string(name='Fps'),
    height?: string(name='Height'),
    mediaId?: string(name='MediaId'),
    publishState?: string(name='PublishState'),
    runIdList?: {
      runId?: [ string ](name='RunId')
    }(name='RunIdList'),
    size?: string(name='Size'),
    tags?: {
      tag?: [ string ](name='Tag')
    }(name='Tags'),
    title?: string(name='Title'),
    width?: string(name='Width'),
  }(name='Media'),
  requestId?: string(name='RequestId'),
}

model AddMediaResponse = {
  headers: map[string]string(name='headers'),
  body: AddMediaResponseBody(name='body'),
}

async function addMediaWithOptions(request: AddMediaRequest, runtime: Util.RuntimeOptions): AddMediaResponse {
  Util.validateModel(request);
  var query = {};
  query["CateId"] = request.cateId;
  query["CoverURL"] = request.coverURL;
  query["Description"] = request.description;
  query["FileURL"] = request.fileURL;
  query["InputUnbind"] = request.inputUnbind;
  query["MediaWorkflowId"] = request.mediaWorkflowId;
  query["MediaWorkflowUserData"] = request.mediaWorkflowUserData;
  query["OverrideParams"] = request.overrideParams;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["Tags"] = request.tags;
  query["Title"] = request.title;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'AddMedia',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addMedia(request: AddMediaRequest): AddMediaResponse {
  var runtime = new Util.RuntimeOptions{};
  return addMediaWithOptions(request, runtime);
}

model AddMediaTagRequest {
  mediaId?: string(name='MediaId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  tag?: string(name='Tag'),
}

model AddMediaTagResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddMediaTagResponse = {
  headers: map[string]string(name='headers'),
  body: AddMediaTagResponseBody(name='body'),
}

async function addMediaTagWithOptions(request: AddMediaTagRequest, runtime: Util.RuntimeOptions): AddMediaTagResponse {
  Util.validateModel(request);
  var query = {};
  query["MediaId"] = request.mediaId;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["Tag"] = request.tag;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'AddMediaTag',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addMediaTag(request: AddMediaTagRequest): AddMediaTagResponse {
  var runtime = new Util.RuntimeOptions{};
  return addMediaTagWithOptions(request, runtime);
}

model AddMediaWorkflowRequest {
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  topology?: string(name='Topology'),
  triggerMode?: string(name='TriggerMode'),
}

model AddMediaWorkflowResponseBody = {
  mediaWorkflow?: {
    creationTime?: string(name='CreationTime'),
    mediaWorkflowId?: string(name='MediaWorkflowId'),
    name?: string(name='Name'),
    state?: string(name='State'),
    topology?: string(name='Topology'),
    triggerMode?: string(name='TriggerMode'),
  }(name='MediaWorkflow'),
  requestId?: string(name='RequestId'),
}

model AddMediaWorkflowResponse = {
  headers: map[string]string(name='headers'),
  body: AddMediaWorkflowResponseBody(name='body'),
}

async function addMediaWorkflowWithOptions(request: AddMediaWorkflowRequest, runtime: Util.RuntimeOptions): AddMediaWorkflowResponse {
  Util.validateModel(request);
  var query = {};
  query["Name"] = request.name;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["Topology"] = request.topology;
  query["TriggerMode"] = request.triggerMode;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'AddMediaWorkflow',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addMediaWorkflow(request: AddMediaWorkflowRequest): AddMediaWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  return addMediaWorkflowWithOptions(request, runtime);
}

model AddPipelineRequest {
  name?: string(name='Name'),
  notifyConfig?: string(name='NotifyConfig'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  role?: string(name='Role'),
  speed?: string(name='Speed'),
  speedLevel?: long(name='SpeedLevel'),
}

model AddPipelineResponseBody = {
  pipeline?: {
    id?: string(name='Id'),
    name?: string(name='Name'),
    notifyConfig?: {
      mqTag?: string(name='MqTag'),
      mqTopic?: string(name='MqTopic'),
      queueName?: string(name='QueueName'),
      topic?: string(name='Topic'),
    }(name='NotifyConfig'),
    quotaAllocate?: long(name='QuotaAllocate'),
    role?: string(name='Role'),
    speed?: string(name='Speed'),
    speedLevel?: long(name='SpeedLevel'),
    state?: string(name='State'),
  }(name='Pipeline'),
  requestId?: string(name='RequestId'),
}

model AddPipelineResponse = {
  headers: map[string]string(name='headers'),
  body: AddPipelineResponseBody(name='body'),
}

async function addPipelineWithOptions(request: AddPipelineRequest, runtime: Util.RuntimeOptions): AddPipelineResponse {
  Util.validateModel(request);
  var query = {};
  query["Name"] = request.name;
  query["NotifyConfig"] = request.notifyConfig;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["Role"] = request.role;
  query["Speed"] = request.speed;
  query["SpeedLevel"] = request.speedLevel;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'AddPipeline',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addPipeline(request: AddPipelineRequest): AddPipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return addPipelineWithOptions(request, runtime);
}

model AddPornPipelineRequest {
  name?: string(name='Name'),
  notifyConfig?: string(name='NotifyConfig'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  priority?: int32(name='Priority'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model AddPornPipelineResponseBody = {
  pipeline?: {
    id?: string(name='Id'),
    name?: string(name='Name'),
    notifyConfig?: {
      queue?: string(name='Queue'),
      topic?: string(name='Topic'),
    }(name='NotifyConfig'),
    priority?: int32(name='Priority'),
    state?: string(name='State'),
  }(name='Pipeline'),
  requestId?: string(name='RequestId'),
}

model AddPornPipelineResponse = {
  headers: map[string]string(name='headers'),
  body: AddPornPipelineResponseBody(name='body'),
}

async function addPornPipelineWithOptions(request: AddPornPipelineRequest, runtime: Util.RuntimeOptions): AddPornPipelineResponse {
  Util.validateModel(request);
  var query = {};
  query["Name"] = request.name;
  query["NotifyConfig"] = request.notifyConfig;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["Priority"] = request.priority;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'AddPornPipeline',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addPornPipeline(request: AddPornPipelineRequest): AddPornPipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return addPornPipelineWithOptions(request, runtime);
}

model AddSmarttagTemplateRequest {
  analyseTypes?: string(name='AnalyseTypes'),
  faceCategoryIds?: string(name='FaceCategoryIds'),
  industry?: string(name='Industry'),
  isDefault?: boolean(name='IsDefault'),
  keywordConfig?: string(name='KeywordConfig'),
  knowledgeConfig?: string(name='KnowledgeConfig'),
  labelType?: string(name='LabelType'),
  labelVersion?: string(name='LabelVersion'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  scene?: string(name='Scene'),
  templateName?: string(name='TemplateName'),
}

model AddSmarttagTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  templateId?: string(name='TemplateId'),
}

model AddSmarttagTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: AddSmarttagTemplateResponseBody(name='body'),
}

async function addSmarttagTemplateWithOptions(request: AddSmarttagTemplateRequest, runtime: Util.RuntimeOptions): AddSmarttagTemplateResponse {
  Util.validateModel(request);
  var query = {};
  query["AnalyseTypes"] = request.analyseTypes;
  query["FaceCategoryIds"] = request.faceCategoryIds;
  query["Industry"] = request.industry;
  query["IsDefault"] = request.isDefault;
  query["KeywordConfig"] = request.keywordConfig;
  query["KnowledgeConfig"] = request.knowledgeConfig;
  query["LabelType"] = request.labelType;
  query["LabelVersion"] = request.labelVersion;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["Scene"] = request.scene;
  query["TemplateName"] = request.templateName;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'AddSmarttagTemplate',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addSmarttagTemplate(request: AddSmarttagTemplateRequest): AddSmarttagTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return addSmarttagTemplateWithOptions(request, runtime);
}

model AddTemplateRequest {
  audio?: string(name='Audio'),
  container?: string(name='Container'),
  muxConfig?: string(name='MuxConfig'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  transConfig?: string(name='TransConfig'),
  video?: string(name='Video'),
}

model AddTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  template?: {
    audio?: {
      bitrate?: string(name='Bitrate'),
      channels?: string(name='Channels'),
      codec?: string(name='Codec'),
      profile?: string(name='Profile'),
      qscale?: string(name='Qscale'),
      remove?: string(name='Remove'),
      samplerate?: string(name='Samplerate'),
      volume?: {
        level?: string(name='Level'),
        method?: string(name='Method'),
      }(name='Volume'),
    }(name='Audio'),
    container?: {
      format?: string(name='Format'),
    }(name='Container'),
    id?: string(name='Id'),
    muxConfig?: {
      gif?: {
        ditherMode?: string(name='DitherMode'),
        finalDelay?: string(name='FinalDelay'),
        isCustomPalette?: string(name='IsCustomPalette'),
        loop?: string(name='Loop'),
      }(name='Gif'),
      segment?: {
        duration?: string(name='Duration'),
      }(name='Segment'),
      webp?: {
        loop?: string(name='Loop'),
      }(name='Webp'),
    }(name='MuxConfig'),
    name?: string(name='Name'),
    state?: string(name='State'),
    transConfig?: {
      adjDarMethod?: string(name='AdjDarMethod'),
      isCheckAudioBitrate?: string(name='IsCheckAudioBitrate'),
      isCheckAudioBitrateFail?: string(name='IsCheckAudioBitrateFail'),
      isCheckReso?: string(name='IsCheckReso'),
      isCheckResoFail?: string(name='IsCheckResoFail'),
      isCheckVideoBitrate?: string(name='IsCheckVideoBitrate'),
      isCheckVideoBitrateFail?: string(name='IsCheckVideoBitrateFail'),
      transMode?: string(name='TransMode'),
    }(name='TransConfig'),
    video?: {
      bitrate?: string(name='Bitrate'),
      bitrateBnd?: {
        max?: string(name='Max'),
        min?: string(name='Min'),
      }(name='BitrateBnd'),
      bufsize?: string(name='Bufsize'),
      codec?: string(name='Codec'),
      crf?: string(name='Crf'),
      crop?: string(name='Crop'),
      degrain?: string(name='Degrain'),
      fps?: string(name='Fps'),
      gop?: string(name='Gop'),
      height?: string(name='Height'),
      longShortMode?: string(name='LongShortMode'),
      maxFps?: string(name='MaxFps'),
      maxrate?: string(name='Maxrate'),
      pad?: string(name='Pad'),
      pixFmt?: string(name='PixFmt'),
      preset?: string(name='Preset'),
      profile?: string(name='Profile'),
      qscale?: string(name='Qscale'),
      remove?: string(name='Remove'),
      resoPriority?: string(name='ResoPriority'),
      scanMode?: string(name='ScanMode'),
      width?: string(name='Width'),
    }(name='Video'),
  }(name='Template'),
}

model AddTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: AddTemplateResponseBody(name='body'),
}

async function addTemplateWithOptions(request: AddTemplateRequest, runtime: Util.RuntimeOptions): AddTemplateResponse {
  Util.validateModel(request);
  var query = {};
  query["Audio"] = request.audio;
  query["Container"] = request.container;
  query["MuxConfig"] = request.muxConfig;
  query["Name"] = request.name;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["TransConfig"] = request.transConfig;
  query["Video"] = request.video;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'AddTemplate',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addTemplate(request: AddTemplateRequest): AddTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return addTemplateWithOptions(request, runtime);
}

model AddTerrorismPipelineRequest {
  name?: string(name='Name'),
  notifyConfig?: string(name='NotifyConfig'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  priority?: int32(name='Priority'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model AddTerrorismPipelineResponseBody = {
  pipeline?: {
    id?: string(name='Id'),
    name?: string(name='Name'),
    notifyConfig?: {
      queue?: string(name='Queue'),
      topic?: string(name='Topic'),
    }(name='NotifyConfig'),
    priority?: int32(name='Priority'),
    state?: string(name='State'),
  }(name='Pipeline'),
  requestId?: string(name='RequestId'),
}

model AddTerrorismPipelineResponse = {
  headers: map[string]string(name='headers'),
  body: AddTerrorismPipelineResponseBody(name='body'),
}

async function addTerrorismPipelineWithOptions(request: AddTerrorismPipelineRequest, runtime: Util.RuntimeOptions): AddTerrorismPipelineResponse {
  Util.validateModel(request);
  var query = {};
  query["Name"] = request.name;
  query["NotifyConfig"] = request.notifyConfig;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["Priority"] = request.priority;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'AddTerrorismPipeline',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addTerrorismPipeline(request: AddTerrorismPipelineRequest): AddTerrorismPipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return addTerrorismPipelineWithOptions(request, runtime);
}

model AddWaterMarkTemplateRequest {
  config?: string(name='Config'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model AddWaterMarkTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  waterMarkTemplate?: {
    dx?: string(name='Dx'),
    dy?: string(name='Dy'),
    height?: string(name='Height'),
    id?: string(name='Id'),
    name?: string(name='Name'),
    ratioRefer?: {
      dx?: string(name='Dx'),
      dy?: string(name='Dy'),
      height?: string(name='Height'),
      width?: string(name='Width'),
    }(name='RatioRefer'),
    referPos?: string(name='ReferPos'),
    state?: string(name='State'),
    timeline?: {
      duration?: string(name='Duration'),
      start?: string(name='Start'),
    }(name='Timeline'),
    type?: string(name='Type'),
    width?: string(name='Width'),
  }(name='WaterMarkTemplate'),
}

model AddWaterMarkTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: AddWaterMarkTemplateResponseBody(name='body'),
}

async function addWaterMarkTemplateWithOptions(request: AddWaterMarkTemplateRequest, runtime: Util.RuntimeOptions): AddWaterMarkTemplateResponse {
  Util.validateModel(request);
  var query = {};
  query["Config"] = request.config;
  query["Name"] = request.name;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'AddWaterMarkTemplate',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addWaterMarkTemplate(request: AddWaterMarkTemplateRequest): AddWaterMarkTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return addWaterMarkTemplateWithOptions(request, runtime);
}

model BindInputBucketRequest {
  bucket?: string(name='Bucket'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  roleArn?: string(name='RoleArn'),
}

model BindInputBucketResponseBody = {
  requestId?: string(name='RequestId'),
}

model BindInputBucketResponse = {
  headers: map[string]string(name='headers'),
  body: BindInputBucketResponseBody(name='body'),
}

async function bindInputBucketWithOptions(request: BindInputBucketRequest, runtime: Util.RuntimeOptions): BindInputBucketResponse {
  Util.validateModel(request);
  var query = {};
  query["Bucket"] = request.bucket;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RoleArn"] = request.roleArn;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'BindInputBucket',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function bindInputBucket(request: BindInputBucketRequest): BindInputBucketResponse {
  var runtime = new Util.RuntimeOptions{};
  return bindInputBucketWithOptions(request, runtime);
}

model BindOutputBucketRequest {
  bucket?: string(name='Bucket'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  roleArn?: string(name='RoleArn'),
}

model BindOutputBucketResponseBody = {
  requestId?: string(name='RequestId'),
}

model BindOutputBucketResponse = {
  headers: map[string]string(name='headers'),
  body: BindOutputBucketResponseBody(name='body'),
}

async function bindOutputBucketWithOptions(request: BindOutputBucketRequest, runtime: Util.RuntimeOptions): BindOutputBucketResponse {
  Util.validateModel(request);
  var query = {};
  query["Bucket"] = request.bucket;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RoleArn"] = request.roleArn;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'BindOutputBucket',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function bindOutputBucket(request: BindOutputBucketRequest): BindOutputBucketResponse {
  var runtime = new Util.RuntimeOptions{};
  return bindOutputBucketWithOptions(request, runtime);
}

model CancelJobRequest {
  jobId?: string(name='JobId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CancelJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model CancelJobResponse = {
  headers: map[string]string(name='headers'),
  body: CancelJobResponseBody(name='body'),
}

async function cancelJobWithOptions(request: CancelJobRequest, runtime: Util.RuntimeOptions): CancelJobResponse {
  Util.validateModel(request);
  var query = {};
  query["JobId"] = request.jobId;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CancelJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cancelJob(request: CancelJobRequest): CancelJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelJobWithOptions(request, runtime);
}

model CategoryTreeRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CategoryTreeResponseBody = {
  categoryTree?: string(name='CategoryTree'),
  requestId?: string(name='RequestId'),
}

model CategoryTreeResponse = {
  headers: map[string]string(name='headers'),
  body: CategoryTreeResponseBody(name='body'),
}

async function categoryTreeWithOptions(request: CategoryTreeRequest, runtime: Util.RuntimeOptions): CategoryTreeResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CategoryTree',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function categoryTree(request: CategoryTreeRequest): CategoryTreeResponse {
  var runtime = new Util.RuntimeOptions{};
  return categoryTreeWithOptions(request, runtime);
}

model CheckResourceRequest {
  bid?: string(name='Bid'),
  country?: string(name='Country'),
  gmtWakeup?: string(name='GmtWakeup'),
  hid?: long(name='Hid'),
  interrupt?: boolean(name='Interrupt'),
  invoker?: string(name='Invoker'),
  level?: long(name='Level'),
  message?: string(name='Message'),
  pk?: string(name='Pk'),
  prompt?: string(name='Prompt'),
  success?: boolean(name='Success'),
  taskExtraData?: string(name='TaskExtraData'),
  taskIdentifier?: string(name='TaskIdentifier'),
  url?: string(name='Url'),
}

model CheckResourceResponseBody = {
  bid?: string(name='Bid'),
  country?: string(name='Country'),
  gmtWakeup?: string(name='GmtWakeup'),
  hid?: long(name='Hid'),
  interrupt?: boolean(name='Interrupt'),
  invoker?: string(name='Invoker'),
  level?: long(name='Level'),
  message?: string(name='Message'),
  pk?: string(name='Pk'),
  prompt?: string(name='Prompt'),
  success?: boolean(name='Success'),
  taskExtraData?: string(name='TaskExtraData'),
  taskIdentifier?: string(name='TaskIdentifier'),
  url?: string(name='Url'),
}

model CheckResourceResponse = {
  headers: map[string]string(name='headers'),
  body: CheckResourceResponseBody(name='body'),
}

async function checkResourceWithOptions(request: CheckResourceRequest, runtime: Util.RuntimeOptions): CheckResourceResponse {
  Util.validateModel(request);
  var query = {};
  query["Bid"] = request.bid;
  query["Country"] = request.country;
  query["GmtWakeup"] = request.gmtWakeup;
  query["Hid"] = request.hid;
  query["Interrupt"] = request.interrupt;
  query["Invoker"] = request.invoker;
  query["Level"] = request.level;
  query["Message"] = request.message;
  query["Pk"] = request.pk;
  query["Prompt"] = request.prompt;
  query["Success"] = request.success;
  query["TaskExtraData"] = request.taskExtraData;
  query["TaskIdentifier"] = request.taskIdentifier;
  query["Url"] = request.url;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CheckResource',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkResource(request: CheckResourceRequest): CheckResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkResourceWithOptions(request, runtime);
}

model CreateFpShotDBRequest {
  config?: string(name='Config'),
  description?: string(name='Description'),
  modelId?: int32(name='ModelId'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateFpShotDBResponseBody = {
  fpShotDB?: {
    config?: string(name='Config'),
    description?: string(name='Description'),
    fpDBId?: string(name='FpDBId'),
    modelId?: int32(name='ModelId'),
    name?: string(name='Name'),
    state?: string(name='State'),
  }(name='FpShotDB'),
  requestId?: string(name='RequestId'),
}

model CreateFpShotDBResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFpShotDBResponseBody(name='body'),
}

async function createFpShotDBWithOptions(request: CreateFpShotDBRequest, runtime: Util.RuntimeOptions): CreateFpShotDBResponse {
  Util.validateModel(request);
  var query = {};
  query["Config"] = request.config;
  query["Description"] = request.description;
  query["ModelId"] = request.modelId;
  query["Name"] = request.name;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateFpShotDB',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createFpShotDB(request: CreateFpShotDBRequest): CreateFpShotDBResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFpShotDBWithOptions(request, runtime);
}

model CreateInferenceServerRequest {
  functionName?: string(name='FunctionName'),
  modelPath?: string(name='ModelPath'),
  modelType?: string(name='ModelType'),
  pipelineId?: string(name='PipelineId'),
  testId?: string(name='TestId'),
  userData?: string(name='UserData'),
}

model CreateInferenceServerResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model CreateInferenceServerResponse = {
  headers: map[string]string(name='headers'),
  body: CreateInferenceServerResponseBody(name='body'),
}

async function createInferenceServerWithOptions(request: CreateInferenceServerRequest, runtime: Util.RuntimeOptions): CreateInferenceServerResponse {
  Util.validateModel(request);
  var query = {};
  query["FunctionName"] = request.functionName;
  query["ModelPath"] = request.modelPath;
  query["ModelType"] = request.modelType;
  query["PipelineId"] = request.pipelineId;
  query["TestId"] = request.testId;
  query["UserData"] = request.userData;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateInferenceServer',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createInferenceServer(request: CreateInferenceServerRequest): CreateInferenceServerResponse {
  var runtime = new Util.RuntimeOptions{};
  return createInferenceServerWithOptions(request, runtime);
}

model CreateMcuTemplateRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  template?: string(name='Template'),
}

model CreateMcuTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  templateId?: string(name='TemplateId'),
}

model CreateMcuTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: CreateMcuTemplateResponseBody(name='body'),
}

async function createMcuTemplateWithOptions(request: CreateMcuTemplateRequest, runtime: Util.RuntimeOptions): CreateMcuTemplateResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["Template"] = request.template;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateMcuTemplate',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMcuTemplate(request: CreateMcuTemplateRequest): CreateMcuTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMcuTemplateWithOptions(request, runtime);
}

model CreateSessionRequest {
  endUserId?: string(name='EndUserId'),
  mediaId?: string(name='MediaId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: string(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: string(name='ResourceOwnerId'),
  sessionTime?: int32(name='SessionTime'),
}

model CreateSessionResponseBody = {
  requestId?: string(name='RequestId'),
  sessionId?: string(name='SessionId'),
  ticket?: string(name='Ticket'),
}

model CreateSessionResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSessionResponseBody(name='body'),
}

async function createSessionWithOptions(request: CreateSessionRequest, runtime: Util.RuntimeOptions): CreateSessionResponse {
  Util.validateModel(request);
  var query = {};
  query["EndUserId"] = request.endUserId;
  query["MediaId"] = request.mediaId;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["SessionTime"] = request.sessionTime;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateSession',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createSession(request: CreateSessionRequest): CreateSessionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSessionWithOptions(request, runtime);
}

model DeactivateMediaWorkflowRequest {
  mediaWorkflowId?: string(name='MediaWorkflowId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeactivateMediaWorkflowResponseBody = {
  mediaWorkflow?: {
    creationTime?: string(name='CreationTime'),
    mediaWorkflowId?: string(name='MediaWorkflowId'),
    name?: string(name='Name'),
    state?: string(name='State'),
    topology?: string(name='Topology'),
  }(name='MediaWorkflow'),
  requestId?: string(name='RequestId'),
}

model DeactivateMediaWorkflowResponse = {
  headers: map[string]string(name='headers'),
  body: DeactivateMediaWorkflowResponseBody(name='body'),
}

async function deactivateMediaWorkflowWithOptions(request: DeactivateMediaWorkflowRequest, runtime: Util.RuntimeOptions): DeactivateMediaWorkflowResponse {
  Util.validateModel(request);
  var query = {};
  query["MediaWorkflowId"] = request.mediaWorkflowId;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeactivateMediaWorkflow',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deactivateMediaWorkflow(request: DeactivateMediaWorkflowRequest): DeactivateMediaWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  return deactivateMediaWorkflowWithOptions(request, runtime);
}

model DecryptKeyRequest {
  ciphertextBlob?: string(name='CiphertextBlob'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: string(name='OwnerId'),
  rand?: string(name='Rand'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: string(name='ResourceOwnerId'),
}

model DecryptKeyResponseBody = {
  plaintext?: string(name='Plaintext'),
  rand?: string(name='Rand'),
  requestId?: string(name='RequestId'),
}

model DecryptKeyResponse = {
  headers: map[string]string(name='headers'),
  body: DecryptKeyResponseBody(name='body'),
}

async function decryptKeyWithOptions(request: DecryptKeyRequest, runtime: Util.RuntimeOptions): DecryptKeyResponse {
  Util.validateModel(request);
  var query = {};
  query["CiphertextBlob"] = request.ciphertextBlob;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["Rand"] = request.rand;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DecryptKey',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function decryptKey(request: DecryptKeyRequest): DecryptKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return decryptKeyWithOptions(request, runtime);
}

model DeleteCategoryRequest {
  cateId?: long(name='CateId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteCategoryResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteCategoryResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteCategoryResponseBody(name='body'),
}

async function deleteCategoryWithOptions(request: DeleteCategoryRequest, runtime: Util.RuntimeOptions): DeleteCategoryResponse {
  Util.validateModel(request);
  var query = {};
  query["CateId"] = request.cateId;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCategory',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteCategory(request: DeleteCategoryRequest): DeleteCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCategoryWithOptions(request, runtime);
}

model DeleteMCTemplateRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  templateId?: string(name='TemplateId'),
}

model DeleteMCTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  templateId?: string(name='TemplateId'),
}

model DeleteMCTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteMCTemplateResponseBody(name='body'),
}

async function deleteMCTemplateWithOptions(request: DeleteMCTemplateRequest, runtime: Util.RuntimeOptions): DeleteMCTemplateResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["TemplateId"] = request.templateId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMCTemplate',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteMCTemplate(request: DeleteMCTemplateRequest): DeleteMCTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMCTemplateWithOptions(request, runtime);
}

model DeleteMcuJobRequest {
  jobIds?: string(name='JobIds'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteMcuJobResponseBody = {
  deletedJobIds?: {
    string?: [ string ](name='String')
  }(name='DeletedJobIds'),
  nonExistJobIds?: {
    string?: [ string ](name='String')
  }(name='NonExistJobIds'),
  requestId?: string(name='RequestId'),
}

model DeleteMcuJobResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteMcuJobResponseBody(name='body'),
}

async function deleteMcuJobWithOptions(request: DeleteMcuJobRequest, runtime: Util.RuntimeOptions): DeleteMcuJobResponse {
  Util.validateModel(request);
  var query = {};
  query["JobIds"] = request.jobIds;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMcuJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteMcuJob(request: DeleteMcuJobRequest): DeleteMcuJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMcuJobWithOptions(request, runtime);
}

model DeleteMcuTemplateRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  templateId?: string(name='TemplateId'),
}

model DeleteMcuTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  templateId?: string(name='TemplateId'),
}

model DeleteMcuTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteMcuTemplateResponseBody(name='body'),
}

async function deleteMcuTemplateWithOptions(request: DeleteMcuTemplateRequest, runtime: Util.RuntimeOptions): DeleteMcuTemplateResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["TemplateId"] = request.templateId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMcuTemplate',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteMcuTemplate(request: DeleteMcuTemplateRequest): DeleteMcuTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMcuTemplateWithOptions(request, runtime);
}

model DeleteMediaRequest {
  mediaIds?: string(name='MediaIds'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteMediaResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteMediaResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteMediaResponseBody(name='body'),
}

async function deleteMediaWithOptions(request: DeleteMediaRequest, runtime: Util.RuntimeOptions): DeleteMediaResponse {
  Util.validateModel(request);
  var query = {};
  query["MediaIds"] = request.mediaIds;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMedia',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteMedia(request: DeleteMediaRequest): DeleteMediaResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMediaWithOptions(request, runtime);
}

model DeleteMediaTagRequest {
  mediaId?: string(name='MediaId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  tag?: string(name='Tag'),
}

model DeleteMediaTagResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteMediaTagResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteMediaTagResponseBody(name='body'),
}

async function deleteMediaTagWithOptions(request: DeleteMediaTagRequest, runtime: Util.RuntimeOptions): DeleteMediaTagResponse {
  Util.validateModel(request);
  var query = {};
  query["MediaId"] = request.mediaId;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["Tag"] = request.tag;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMediaTag',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteMediaTag(request: DeleteMediaTagRequest): DeleteMediaTagResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMediaTagWithOptions(request, runtime);
}

model DeleteMediaWorkflowRequest {
  mediaWorkflowId?: string(name='MediaWorkflowId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteMediaWorkflowResponseBody = {
  mediaWorkflow?: {
    creationTime?: string(name='CreationTime'),
    mediaWorkflowId?: string(name='MediaWorkflowId'),
    name?: string(name='Name'),
    state?: string(name='State'),
    topology?: string(name='Topology'),
  }(name='MediaWorkflow'),
  requestId?: string(name='RequestId'),
}

model DeleteMediaWorkflowResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteMediaWorkflowResponseBody(name='body'),
}

async function deleteMediaWorkflowWithOptions(request: DeleteMediaWorkflowRequest, runtime: Util.RuntimeOptions): DeleteMediaWorkflowResponse {
  Util.validateModel(request);
  var query = {};
  query["MediaWorkflowId"] = request.mediaWorkflowId;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMediaWorkflow',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteMediaWorkflow(request: DeleteMediaWorkflowRequest): DeleteMediaWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMediaWorkflowWithOptions(request, runtime);
}

model DeletePipelineRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeletePipelineResponseBody = {
  pipelineId?: string(name='PipelineId'),
  requestId?: string(name='RequestId'),
}

model DeletePipelineResponse = {
  headers: map[string]string(name='headers'),
  body: DeletePipelineResponseBody(name='body'),
}

async function deletePipelineWithOptions(request: DeletePipelineRequest, runtime: Util.RuntimeOptions): DeletePipelineResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PipelineId"] = request.pipelineId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeletePipeline',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deletePipeline(request: DeletePipelineRequest): DeletePipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return deletePipelineWithOptions(request, runtime);
}

model DeleteSmarttagTemplateRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  templateId?: string(name='TemplateId'),
}

model DeleteSmarttagTemplateResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteSmarttagTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSmarttagTemplateResponseBody(name='body'),
}

async function deleteSmarttagTemplateWithOptions(request: DeleteSmarttagTemplateRequest, runtime: Util.RuntimeOptions): DeleteSmarttagTemplateResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["TemplateId"] = request.templateId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSmarttagTemplate',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSmarttagTemplate(request: DeleteSmarttagTemplateRequest): DeleteSmarttagTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSmarttagTemplateWithOptions(request, runtime);
}

model DeleteTemplateRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  templateId?: string(name='TemplateId'),
}

model DeleteTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  templateId?: string(name='TemplateId'),
}

model DeleteTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteTemplateResponseBody(name='body'),
}

async function deleteTemplateWithOptions(request: DeleteTemplateRequest, runtime: Util.RuntimeOptions): DeleteTemplateResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["TemplateId"] = request.templateId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteTemplate',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteTemplate(request: DeleteTemplateRequest): DeleteTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTemplateWithOptions(request, runtime);
}

model DeleteWaterMarkTemplateRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  waterMarkTemplateId?: string(name='WaterMarkTemplateId'),
}

model DeleteWaterMarkTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  waterMarkTemplateId?: string(name='WaterMarkTemplateId'),
}

model DeleteWaterMarkTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteWaterMarkTemplateResponseBody(name='body'),
}

async function deleteWaterMarkTemplateWithOptions(request: DeleteWaterMarkTemplateRequest, runtime: Util.RuntimeOptions): DeleteWaterMarkTemplateResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["WaterMarkTemplateId"] = request.waterMarkTemplateId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteWaterMarkTemplate',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteWaterMarkTemplate(request: DeleteWaterMarkTemplateRequest): DeleteWaterMarkTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteWaterMarkTemplateWithOptions(request, runtime);
}

model DescribeMtsUserResourcePackageRequest {
  ownerId?: long(name='OwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeMtsUserResourcePackageResponseBody = {
  requestId?: string(name='RequestId'),
  resourcePackageInfos?: {
    resourcePackageInfo?: [ 
    {
      commodityCode?: string(name='CommodityCode'),
      currCapacity?: string(name='CurrCapacity'),
      displayName?: string(name='DisplayName'),
      initCapacity?: string(name='InitCapacity'),
      instanceId?: string(name='InstanceId'),
      status?: string(name='Status'),
    }
  ](name='ResourcePackageInfo')
  }(name='ResourcePackageInfos'),
}

model DescribeMtsUserResourcePackageResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeMtsUserResourcePackageResponseBody(name='body'),
}

async function describeMtsUserResourcePackageWithOptions(request: DescribeMtsUserResourcePackageRequest, runtime: Util.RuntimeOptions): DescribeMtsUserResourcePackageResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerId"] = request.ownerId;
  query["SecurityToken"] = request.securityToken;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMtsUserResourcePackage',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMtsUserResourcePackage(request: DescribeMtsUserResourcePackageRequest): DescribeMtsUserResourcePackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMtsUserResourcePackageWithOptions(request, runtime);
}

model DetectImageSyncRequest {
  image?: string(name='Image', description='url'),
}

model DetectImageSyncResponseBody = {
  message?: string(name='Message', description=''),
  requestId?: string(name='RequestId', description='Id of the request'),
  result?: string(name='Result', description=''),
  status?: string(name='Status', description=''),
}

model DetectImageSyncResponse = {
  headers: map[string]string(name='headers'),
  body: DetectImageSyncResponseBody(name='body'),
}

async function detectImageSyncWithOptions(request: DetectImageSyncRequest, runtime: Util.RuntimeOptions): DetectImageSyncResponse {
  Util.validateModel(request);
  var query = {};
  query["Image"] = request.image;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DetectImageSync',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detectImageSync(request: DetectImageSyncRequest): DetectImageSyncResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectImageSyncWithOptions(request, runtime);
}

model GetJobInfoRequest {
  jobId?: string(name='jobId'),
}

model GetJobInfoResponseBody = {
  mtsTransferJob?: {
    createTime?: string(name='CreateTime'),
    errorCode?: string(name='ErrorCode'),
    errorMessage?: string(name='ErrorMessage'),
    extend?: string(name='Extend'),
    finishedTime?: string(name='FinishedTime'),
    jobId?: string(name='JobId'),
    jobType?: string(name='JobType'),
    modifiedTime?: string(name='ModifiedTime'),
    requestJson?: string(name='RequestJson'),
    state?: string(name='State'),
    userData?: string(name='UserData'),
  }(name='MtsTransferJob'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model GetJobInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetJobInfoResponseBody(name='body'),
}

async function getJobInfoWithOptions(request: GetJobInfoRequest, runtime: Util.RuntimeOptions): GetJobInfoResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetJobInfo',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getJobInfo(request: GetJobInfoRequest): GetJobInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getJobInfoWithOptions(request, runtime);
}

model GetLicenseRequest {
  data?: string(name='Data'),
  header?: string(name='Header'),
  licenseUrl?: string(name='LicenseUrl'),
  mediaId?: string(name='MediaId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: string(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: string(name='ResourceOwnerId'),
  type?: string(name='Type'),
}

model GetLicenseResponseBody = {
  license?: string(name='License'),
  requestId?: string(name='RequestId'),
}

model GetLicenseResponse = {
  headers: map[string]string(name='headers'),
  body: GetLicenseResponseBody(name='body'),
}

async function getLicenseWithOptions(request: GetLicenseRequest, runtime: Util.RuntimeOptions): GetLicenseResponse {
  Util.validateModel(request);
  var query = {};
  query["Data"] = request.data;
  query["Header"] = request.header;
  query["LicenseUrl"] = request.licenseUrl;
  query["MediaId"] = request.mediaId;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["Type"] = request.type;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetLicense',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getLicense(request: GetLicenseRequest): GetLicenseResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLicenseWithOptions(request, runtime);
}

model GetPackageRequest {
  data?: string(name='Data'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: string(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: string(name='ResourceOwnerId'),
}

model GetPackageResponseBody = {
  certPackage?: string(name='CertPackage'),
  requestId?: string(name='RequestId'),
}

model GetPackageResponse = {
  headers: map[string]string(name='headers'),
  body: GetPackageResponseBody(name='body'),
}

async function getPackageWithOptions(request: GetPackageRequest, runtime: Util.RuntimeOptions): GetPackageResponse {
  Util.validateModel(request);
  var query = {};
  query["Data"] = request.data;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetPackage',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPackage(request: GetPackageRequest): GetPackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPackageWithOptions(request, runtime);
}

model ImAuditRequest {
  bizType?: string(name='BizType'),
  contents?: string(name='Contents'),
  images?: string(name='Images'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  scenes?: string(name='Scenes'),
}

model ImAuditResponseBody = {
  imageQuotaExceed?: boolean(name='ImageQuotaExceed'),
  imageResults?: {
    result?: [ 
      {
        code?: long(name='code'),
        dataId?: string(name='dataId'),
        extras?: map[string]any(name='extras'),
        msg?: string(name='msg'),
        results?: [ 
          {
            label?: string(name='Label'),
            rate?: double(name='Rate'),
            scene?: string(name='Scene'),
            suggestion?: string(name='Suggestion'),
          }
        ](name='results'),
        taskId?: string(name='taskId'),
        url?: string(name='url'),
      }
    ](name='result'),
  }(name='ImageResults'),
  requestId?: string(name='RequestId'),
  textQuotaExceed?: boolean(name='TextQuotaExceed'),
  textResults?: {
    result?: [ 
      {
        code?: long(name='code'),
        content?: string(name='content'),
        dataId?: string(name='dataId'),
        msg?: string(name='msg'),
        results?: [ 
          {
            details?: [ 
              {
                label?: string(name='Label'),
              }
            ](name='details'),
            label?: string(name='label'),
            rate?: double(name='rate'),
            scene?: string(name='scene'),
            suggestion?: string(name='suggestion'),
          }
        ](name='results'),
        taskId?: string(name='taskId'),
      }
    ](name='result'),
  }(name='TextResults'),
}

model ImAuditResponse = {
  headers: map[string]string(name='headers'),
  body: ImAuditResponseBody(name='body'),
}

async function imAuditWithOptions(request: ImAuditRequest, runtime: Util.RuntimeOptions): ImAuditResponse {
  Util.validateModel(request);
  var query = {};
  query["BizType"] = request.bizType;
  query["Contents"] = request.contents;
  query["Images"] = request.images;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["Scenes"] = request.scenes;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ImAudit',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function imAudit(request: ImAuditRequest): ImAuditResponse {
  var runtime = new Util.RuntimeOptions{};
  return imAuditWithOptions(request, runtime);
}

model ImportFpShotJobRequest {
  fpDBId?: string(name='FpDBId'),
  fpImportConfig?: string(name='FpImportConfig'),
  input?: string(name='Input'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  userData?: string(name='UserData'),
}

model ImportFpShotJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ImportFpShotJobResponse = {
  headers: map[string]string(name='headers'),
  body: ImportFpShotJobResponseBody(name='body'),
}

async function importFpShotJobWithOptions(request: ImportFpShotJobRequest, runtime: Util.RuntimeOptions): ImportFpShotJobResponse {
  Util.validateModel(request);
  var query = {};
  query["FpDBId"] = request.fpDBId;
  query["FpImportConfig"] = request.fpImportConfig;
  query["Input"] = request.input;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PipelineId"] = request.pipelineId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["UserData"] = request.userData;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ImportFpShotJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function importFpShotJob(request: ImportFpShotJobRequest): ImportFpShotJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return importFpShotJobWithOptions(request, runtime);
}

model ListAllCategoryRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ListAllCategoryResponseBody = {
  categoryList?: {
    category?: [ 
    {
      cateId?: string(name='CateId'),
      cateName?: string(name='CateName'),
      level?: string(name='Level'),
      parentId?: string(name='ParentId'),
    }
  ](name='Category')
  }(name='CategoryList'),
  requestId?: string(name='RequestId'),
}

model ListAllCategoryResponse = {
  headers: map[string]string(name='headers'),
  body: ListAllCategoryResponseBody(name='body'),
}

async function listAllCategoryWithOptions(request: ListAllCategoryRequest, runtime: Util.RuntimeOptions): ListAllCategoryResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListAllCategory',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAllCategory(request: ListAllCategoryRequest): ListAllCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAllCategoryWithOptions(request, runtime);
}

model ListAllMediaBucketRequest {
  maximumPageSize?: int32(name='MaximumPageSize'),
  nextPageToken?: string(name='NextPageToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ListAllMediaBucketResponseBody = {
  mediaBucketList?: {
    mediaBucket?: [ 
    {
      bucket?: string(name='Bucket'),
      type?: string(name='Type'),
    }
  ](name='MediaBucket')
  }(name='MediaBucketList'),
  nextPageToken?: string(name='NextPageToken'),
  requestId?: string(name='RequestId'),
}

model ListAllMediaBucketResponse = {
  headers: map[string]string(name='headers'),
  body: ListAllMediaBucketResponseBody(name='body'),
}

async function listAllMediaBucketWithOptions(request: ListAllMediaBucketRequest, runtime: Util.RuntimeOptions): ListAllMediaBucketResponse {
  Util.validateModel(request);
  var query = {};
  query["MaximumPageSize"] = request.maximumPageSize;
  query["NextPageToken"] = request.nextPageToken;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListAllMediaBucket',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAllMediaBucket(request: ListAllMediaBucketRequest): ListAllMediaBucketResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAllMediaBucketWithOptions(request, runtime);
}

model ListAsrPipelineRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  state?: string(name='State'),
}

model ListAsrPipelineResponseBody = {
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  pipelineList?: {
    pipeline?: [ 
    {
      id?: string(name='Id'),
      name?: string(name='Name'),
      notifyConfig?: {
        queueName?: string(name='QueueName'),
        topic?: string(name='Topic'),
      }(name='NotifyConfig'),
      priority?: string(name='Priority'),
      state?: string(name='State'),
    }
  ](name='Pipeline')
  }(name='PipelineList'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model ListAsrPipelineResponse = {
  headers: map[string]string(name='headers'),
  body: ListAsrPipelineResponseBody(name='body'),
}

async function listAsrPipelineWithOptions(request: ListAsrPipelineRequest, runtime: Util.RuntimeOptions): ListAsrPipelineResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["State"] = request.state;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListAsrPipeline',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAsrPipeline(request: ListAsrPipelineRequest): ListAsrPipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAsrPipelineWithOptions(request, runtime);
}

model ListCensorPipelineRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  state?: string(name='State'),
}

model ListCensorPipelineResponseBody = {
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  pipelineList?: {
    pipeline?: [ 
    {
      id?: string(name='Id'),
      name?: string(name='Name'),
      notifyConfig?: {
        queue?: string(name='Queue'),
        topic?: string(name='Topic'),
      }(name='NotifyConfig'),
      priority?: string(name='Priority'),
      state?: string(name='State'),
    }
  ](name='Pipeline')
  }(name='PipelineList'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model ListCensorPipelineResponse = {
  headers: map[string]string(name='headers'),
  body: ListCensorPipelineResponseBody(name='body'),
}

async function listCensorPipelineWithOptions(request: ListCensorPipelineRequest, runtime: Util.RuntimeOptions): ListCensorPipelineResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["State"] = request.state;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListCensorPipeline',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listCensorPipeline(request: ListCensorPipelineRequest): ListCensorPipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCensorPipelineWithOptions(request, runtime);
}

model ListCoverPipelineRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  state?: string(name='State'),
}

model ListCoverPipelineResponseBody = {
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  pipelineList?: {
    pipeline?: [ 
    {
      extendConfig?: string(name='ExtendConfig'),
      name?: string(name='Name'),
      notifyConfig?: string(name='NotifyConfig'),
      pipelineId?: string(name='PipelineId'),
      priority?: string(name='Priority'),
      role?: string(name='Role'),
      state?: string(name='State'),
      userId?: long(name='UserId'),
      quotaNum?: int32(name='quotaNum'),
      quotaUsed?: int32(name='quotaUsed'),
    }
  ](name='Pipeline')
  }(name='PipelineList'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model ListCoverPipelineResponse = {
  headers: map[string]string(name='headers'),
  body: ListCoverPipelineResponseBody(name='body'),
}

async function listCoverPipelineWithOptions(request: ListCoverPipelineRequest, runtime: Util.RuntimeOptions): ListCoverPipelineResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["State"] = request.state;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListCoverPipeline',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listCoverPipeline(request: ListCoverPipelineRequest): ListCoverPipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCoverPipelineWithOptions(request, runtime);
}

model ListCustomPersonsRequest {
  categoryId?: string(name='CategoryId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  personId?: string(name='PersonId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ListCustomPersonsResponseBody = {
  categories?: {
    category?: [ 
    {
      categoryDescription?: string(name='CategoryDescription'),
      categoryId?: string(name='CategoryId'),
      categoryName?: string(name='CategoryName'),
      persons?: {
        person?: [ 
        {
          faces?: {
            face?: [ 
            {
              faceId?: string(name='FaceId'),
              imageUrl?: string(name='ImageUrl'),
            }
          ](name='Face')
          }(name='Faces'),
          personDescription?: string(name='PersonDescription'),
          personId?: string(name='PersonId'),
          personName?: string(name='PersonName'),
        }
      ](name='Person')
      }(name='Persons'),
    }
  ](name='Category')
  }(name='Categories'),
  requestId?: string(name='RequestId'),
}

model ListCustomPersonsResponse = {
  headers: map[string]string(name='headers'),
  body: ListCustomPersonsResponseBody(name='body'),
}

async function listCustomPersonsWithOptions(request: ListCustomPersonsRequest, runtime: Util.RuntimeOptions): ListCustomPersonsResponse {
  Util.validateModel(request);
  var query = {};
  query["CategoryId"] = request.categoryId;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PersonId"] = request.personId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListCustomPersons',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listCustomPersons(request: ListCustomPersonsRequest): ListCustomPersonsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCustomPersonsWithOptions(request, runtime);
}

model ListFpShotDBRequest {
  fpDBIds?: string(name='FpDBIds'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ListFpShotDBResponseBody = {
  fpShotDBList?: {
    fpShotDB?: [ 
    {
      description?: string(name='Description'),
      fpDBId?: string(name='FpDBId'),
      modelId?: int32(name='ModelId'),
      name?: string(name='Name'),
      status?: string(name='Status'),
    }
  ](name='FpShotDB')
  }(name='FpShotDBList'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
  requestId?: string(name='RequestId'),
}

model ListFpShotDBResponse = {
  headers: map[string]string(name='headers'),
  body: ListFpShotDBResponseBody(name='body'),
}

async function listFpShotDBWithOptions(request: ListFpShotDBRequest, runtime: Util.RuntimeOptions): ListFpShotDBResponse {
  Util.validateModel(request);
  var query = {};
  query["FpDBIds"] = request.fpDBIds;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListFpShotDB',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFpShotDB(request: ListFpShotDBRequest): ListFpShotDBResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFpShotDBWithOptions(request, runtime);
}

model ListFpShotFilesRequest {
  fpDBId?: string(name='FpDBId'),
  nextPageToken?: string(name='NextPageToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageSize?: int32(name='PageSize'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ListFpShotFilesResponseBody = {
  fpShotFileList?: {
    fpShotFile?: [ 
    {
      fileId?: string(name='FileId'),
      inputFile?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='InputFile'),
      primaryKey?: string(name='PrimaryKey'),
    }
  ](name='FpShotFile')
  }(name='FpShotFileList'),
  nextPageToken?: string(name='NextPageToken'),
  requestId?: string(name='RequestId'),
}

model ListFpShotFilesResponse = {
  headers: map[string]string(name='headers'),
  body: ListFpShotFilesResponseBody(name='body'),
}

async function listFpShotFilesWithOptions(request: ListFpShotFilesRequest, runtime: Util.RuntimeOptions): ListFpShotFilesResponse {
  Util.validateModel(request);
  var query = {};
  query["FpDBId"] = request.fpDBId;
  query["NextPageToken"] = request.nextPageToken;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PageSize"] = request.pageSize;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListFpShotFiles',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFpShotFiles(request: ListFpShotFilesRequest): ListFpShotFilesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFpShotFilesWithOptions(request, runtime);
}

model ListFpShotImportJobRequest {
  jobIds?: string(name='JobIds'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ListFpShotImportJobResponseBody = {
  fpShotImportJobList?: [ 
    {
      code?: string(name='Code'),
      createTime?: string(name='CreateTime'),
      finishTime?: string(name='FinishTime'),
      fpDBId?: string(name='FpDBId'),
      fpImportConfig?: string(name='FpImportConfig'),
      id?: string(name='Id'),
      input?: string(name='Input'),
      message?: string(name='Message'),
      pipelineId?: string(name='PipelineId'),
      status?: string(name='Status'),
      userData?: string(name='UserData'),
    }
  ](name='FpShotImportJobList'),
  nonExistIds?: [ string ](name='NonExistIds'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ListFpShotImportJobResponse = {
  headers: map[string]string(name='headers'),
  body: ListFpShotImportJobResponseBody(name='body'),
}

async function listFpShotImportJobWithOptions(request: ListFpShotImportJobRequest, runtime: Util.RuntimeOptions): ListFpShotImportJobResponse {
  Util.validateModel(request);
  var query = {};
  query["JobIds"] = request.jobIds;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListFpShotImportJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFpShotImportJob(request: ListFpShotImportJobRequest): ListFpShotImportJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFpShotImportJobWithOptions(request, runtime);
}

model ListFpShotNotaryRequest {
  endOfCreatedTimeRange?: string(name='EndOfCreatedTimeRange'),
  fpDBId?: string(name='FpDBId'),
  maximumPageSize?: long(name='MaximumPageSize'),
  nextPageToken?: string(name='NextPageToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startOfCreatedTimeRange?: string(name='StartOfCreatedTimeRange'),
}

model ListFpShotNotaryResponseBody = {
  fpShotNotaryList?: {
    fpShotNotary?: [ 
    {
      creationTime?: string(name='CreationTime'),
      detail?: string(name='Detail'),
      finishTime?: string(name='FinishTime'),
      fpDBId?: string(name='FpDBId'),
      jobId?: string(name='JobId'),
      transactionId?: string(name='TransactionId'),
      txHash?: string(name='TxHash'),
    }
  ](name='FpShotNotary')
  }(name='FpShotNotaryList'),
  nextPageToken?: string(name='NextPageToken'),
  requestId?: string(name='RequestId'),
}

model ListFpShotNotaryResponse = {
  headers: map[string]string(name='headers'),
  body: ListFpShotNotaryResponseBody(name='body'),
}

async function listFpShotNotaryWithOptions(request: ListFpShotNotaryRequest, runtime: Util.RuntimeOptions): ListFpShotNotaryResponse {
  Util.validateModel(request);
  var query = {};
  query["EndOfCreatedTimeRange"] = request.endOfCreatedTimeRange;
  query["FpDBId"] = request.fpDBId;
  query["MaximumPageSize"] = request.maximumPageSize;
  query["NextPageToken"] = request.nextPageToken;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["StartOfCreatedTimeRange"] = request.startOfCreatedTimeRange;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListFpShotNotary',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFpShotNotary(request: ListFpShotNotaryRequest): ListFpShotNotaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFpShotNotaryWithOptions(request, runtime);
}

model ListInferenceJobRequest {
  maxPageSize?: long(name='MaxPageSize'),
  pageNumber?: long(name='PageNumber'),
  serverName?: string(name='ServerName'),
}

model ListInferenceJobResponseBody = {
  code?: string(name='Code'),
  jobs?: [ 
    {
      jobId?: string(name='JobId'),
      jobParams?: string(name='JobParams'),
      jobTime?: long(name='JobTime'),
      message?: string(name='Message'),
      result?: string(name='Result'),
      status?: string(name='Status'),
      userId?: long(name='UserId'),
    }
  ](name='Jobs'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  totalSize?: long(name='TotalSize'),
}

model ListInferenceJobResponse = {
  headers: map[string]string(name='headers'),
  body: ListInferenceJobResponseBody(name='body'),
}

async function listInferenceJobWithOptions(request: ListInferenceJobRequest, runtime: Util.RuntimeOptions): ListInferenceJobResponse {
  Util.validateModel(request);
  var query = {};
  query["MaxPageSize"] = request.maxPageSize;
  query["PageNumber"] = request.pageNumber;
  query["ServerName"] = request.serverName;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListInferenceJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listInferenceJob(request: ListInferenceJobRequest): ListInferenceJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInferenceJobWithOptions(request, runtime);
}

model ListJobRequest {
  endOfJobCreatedTimeRange?: string(name='EndOfJobCreatedTimeRange'),
  maximumPageSize?: long(name='MaximumPageSize'),
  nextPageToken?: string(name='NextPageToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startOfJobCreatedTimeRange?: string(name='StartOfJobCreatedTimeRange'),
  state?: string(name='State'),
}

model ListJobResponseBody = {
  jobList?: {
    job?: [ 
    {
      code?: string(name='Code'),
      creationTime?: string(name='CreationTime'),
      finishTime?: string(name='FinishTime'),
      input?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='Input'),
      jobId?: string(name='JobId'),
      MNSMessageResult?: {
        errorCode?: string(name='ErrorCode'),
        errorMessage?: string(name='ErrorMessage'),
        messageId?: string(name='MessageId'),
      }(name='MNSMessageResult'),
      message?: string(name='Message'),
      output?: {
        audio?: {
          bitrate?: string(name='Bitrate'),
          channels?: string(name='Channels'),
          codec?: string(name='Codec'),
          profile?: string(name='Profile'),
          qscale?: string(name='Qscale'),
          samplerate?: string(name='Samplerate'),
          volume?: {
            level?: string(name='Level'),
            method?: string(name='Method'),
          }(name='Volume'),
        }(name='Audio'),
        audioStreamMap?: string(name='AudioStreamMap'),
        clip?: {
          timeSpan?: {
            duration?: string(name='Duration'),
            seek?: string(name='Seek'),
          }(name='TimeSpan'),
        }(name='Clip'),
        container?: {
          format?: string(name='Format'),
        }(name='Container'),
        deWatermark?: string(name='DeWatermark'),
        encryption?: {
          id?: string(name='Id'),
          key?: string(name='Key'),
          keyType?: string(name='KeyType'),
          keyUri?: string(name='KeyUri'),
          skipCnt?: string(name='SkipCnt'),
          type?: string(name='Type'),
        }(name='Encryption'),
        m3U8NonStandardSupport?: {
          TS?: {
            md5Support?: boolean(name='Md5Support'),
            sizeSupport?: boolean(name='SizeSupport'),
          }(name='TS'),
        }(name='M3U8NonStandardSupport'),
        mergeConfigUrl?: string(name='MergeConfigUrl'),
        mergeList?: {
          merge?: [ 
          {
            duration?: string(name='Duration'),
            mergeURL?: string(name='MergeURL'),
            roleArn?: string(name='RoleArn'),
            start?: string(name='Start'),
          }
        ](name='Merge')
        }(name='MergeList'),
        muxConfig?: {
          gif?: {
            ditherMode?: string(name='DitherMode'),
            finalDelay?: string(name='FinalDelay'),
            isCustomPalette?: string(name='IsCustomPalette'),
            loop?: string(name='Loop'),
          }(name='Gif'),
          segment?: {
            duration?: string(name='Duration'),
          }(name='Segment'),
          webp?: {
            loop?: string(name='Loop'),
          }(name='Webp'),
        }(name='MuxConfig'),
        openingList?: {
          opening?: [ 
          {
            height?: string(name='Height'),
            start?: string(name='Start'),
            width?: string(name='Width'),
            openUrl?: string(name='openUrl'),
          }
        ](name='Opening')
        }(name='OpeningList'),
        outSubtitleList?: {
          outSubtitle?: [ 
          {
            map?: string(name='Map'),
            message?: string(name='Message'),
            outSubtitleFile?: {
              bucket?: string(name='Bucket'),
              location?: string(name='Location'),
              object?: string(name='Object'),
              roleArn?: string(name='RoleArn'),
            }(name='OutSubtitleFile'),
            success?: boolean(name='Success'),
          }
        ](name='OutSubtitle')
        }(name='OutSubtitleList'),
        outputFile?: {
          bucket?: string(name='Bucket'),
          location?: string(name='Location'),
          object?: string(name='Object'),
          roleArn?: string(name='RoleArn'),
        }(name='OutputFile'),
        priority?: string(name='Priority'),
        properties?: {
          bitrate?: string(name='Bitrate'),
          duration?: string(name='Duration'),
          fileFormat?: string(name='FileFormat'),
          fileSize?: string(name='FileSize'),
          format?: {
            bitrate?: string(name='Bitrate'),
            duration?: string(name='Duration'),
            formatLongName?: string(name='FormatLongName'),
            formatName?: string(name='FormatName'),
            numPrograms?: string(name='NumPrograms'),
            numStreams?: string(name='NumStreams'),
            size?: string(name='Size'),
            startTime?: string(name='StartTime'),
          }(name='Format'),
          fps?: string(name='Fps'),
          height?: string(name='Height'),
          streams?: {
            audioStreamList?: {
              audioStream?: [ 
              {
                bitrate?: string(name='Bitrate'),
                channelLayout?: string(name='ChannelLayout'),
                channels?: string(name='Channels'),
                codecLongName?: string(name='CodecLongName'),
                codecName?: string(name='CodecName'),
                codecTag?: string(name='CodecTag'),
                codecTagString?: string(name='CodecTagString'),
                codecTimeBase?: string(name='CodecTimeBase'),
                duration?: string(name='Duration'),
                index?: string(name='Index'),
                lang?: string(name='Lang'),
                numFrames?: string(name='NumFrames'),
                sampleFmt?: string(name='SampleFmt'),
                samplerate?: string(name='Samplerate'),
                startTime?: string(name='StartTime'),
                timebase?: string(name='Timebase'),
              }
            ](name='AudioStream')
            }(name='AudioStreamList'),
            subtitleStreamList?: {
              subtitleStream?: [ 
              {
                index?: string(name='Index'),
                lang?: string(name='Lang'),
              }
            ](name='SubtitleStream')
            }(name='SubtitleStreamList'),
            videoStreamList?: {
              videoStream?: [ 
              {
                avgFPS?: string(name='AvgFPS'),
                bitrate?: string(name='Bitrate'),
                codecLongName?: string(name='CodecLongName'),
                codecName?: string(name='CodecName'),
                codecTag?: string(name='CodecTag'),
                codecTagString?: string(name='CodecTagString'),
                codecTimeBase?: string(name='CodecTimeBase'),
                dar?: string(name='Dar'),
                duration?: string(name='Duration'),
                fps?: string(name='Fps'),
                hasBFrames?: string(name='HasBFrames'),
                height?: string(name='Height'),
                index?: string(name='Index'),
                lang?: string(name='Lang'),
                level?: string(name='Level'),
                networkCost?: {
                  avgBitrate?: string(name='AvgBitrate'),
                  costBandwidth?: string(name='CostBandwidth'),
                  preloadTime?: string(name='PreloadTime'),
                }(name='NetworkCost'),
                numFrames?: string(name='NumFrames'),
                pixFmt?: string(name='PixFmt'),
                profile?: string(name='Profile'),
                sar?: string(name='Sar'),
                startTime?: string(name='StartTime'),
                timebase?: string(name='Timebase'),
                width?: string(name='Width'),
              }
            ](name='VideoStream')
            }(name='VideoStreamList'),
          }(name='Streams'),
          width?: string(name='Width'),
        }(name='Properties'),
        rotate?: string(name='Rotate'),
        subtitleConfig?: {
          extSubtitleList?: {
            extSubtitle?: [ 
            {
              charEnc?: string(name='CharEnc'),
              fontName?: string(name='FontName'),
              input?: {
                bucket?: string(name='Bucket'),
                location?: string(name='Location'),
                object?: string(name='Object'),
              }(name='Input'),
            }
          ](name='ExtSubtitle')
          }(name='ExtSubtitleList'),
          subtitleList?: {
            subtitle?: [ 
            {
              map?: string(name='Map'),
            }
          ](name='Subtitle')
          }(name='SubtitleList'),
        }(name='SubtitleConfig'),
        superReso?: {
          isHalfSample?: string(name='IsHalfSample'),
        }(name='SuperReso'),
        tailSlateList?: {
          tailSlate?: [ 
          {
            bgColor?: string(name='BgColor'),
            blendDuration?: string(name='BlendDuration'),
            height?: string(name='Height'),
            isMergeAudio?: boolean(name='IsMergeAudio'),
            start?: string(name='Start'),
            tailUrl?: string(name='TailUrl'),
            width?: string(name='Width'),
          }
        ](name='TailSlate')
        }(name='TailSlateList'),
        templateId?: string(name='TemplateId'),
        transConfig?: {
          adjDarMethod?: string(name='AdjDarMethod'),
          isCheckAudioBitrate?: string(name='IsCheckAudioBitrate'),
          isCheckAudioBitrateFail?: string(name='IsCheckAudioBitrateFail'),
          isCheckReso?: string(name='IsCheckReso'),
          isCheckResoFail?: string(name='IsCheckResoFail'),
          isCheckVideoBitrate?: string(name='IsCheckVideoBitrate'),
          isCheckVideoBitrateFail?: string(name='IsCheckVideoBitrateFail'),
          transMode?: string(name='TransMode'),
        }(name='TransConfig'),
        userData?: string(name='UserData'),
        video?: {
          bitrate?: string(name='Bitrate'),
          bitrateBnd?: {
            max?: string(name='Max'),
            min?: string(name='Min'),
          }(name='BitrateBnd'),
          bufsize?: string(name='Bufsize'),
          codec?: string(name='Codec'),
          crf?: string(name='Crf'),
          crop?: string(name='Crop'),
          degrain?: string(name='Degrain'),
          fps?: string(name='Fps'),
          gop?: string(name='Gop'),
          height?: string(name='Height'),
          maxFps?: string(name='MaxFps'),
          maxrate?: string(name='Maxrate'),
          pad?: string(name='Pad'),
          pixFmt?: string(name='PixFmt'),
          preset?: string(name='Preset'),
          profile?: string(name='Profile'),
          qscale?: string(name='Qscale'),
          resoPriority?: string(name='ResoPriority'),
          scanMode?: string(name='ScanMode'),
          width?: string(name='Width'),
        }(name='Video'),
        videoStreamMap?: string(name='VideoStreamMap'),
        waterMarkConfigUrl?: string(name='WaterMarkConfigUrl'),
        waterMarkList?: {
          waterMark?: [ 
          {
            dx?: string(name='Dx'),
            dy?: string(name='Dy'),
            height?: string(name='Height'),
            inputFile?: {
              bucket?: string(name='Bucket'),
              location?: string(name='Location'),
              object?: string(name='Object'),
            }(name='InputFile'),
            referPos?: string(name='ReferPos'),
            type?: string(name='Type'),
            waterMarkTemplateId?: string(name='WaterMarkTemplateId'),
            width?: string(name='Width'),
          }
        ](name='WaterMark')
        }(name='WaterMarkList'),
      }(name='Output'),
      percent?: long(name='Percent'),
      pipelineId?: string(name='PipelineId'),
      state?: string(name='State'),
    }
  ](name='Job')
  }(name='JobList'),
  nextPageToken?: string(name='NextPageToken'),
  requestId?: string(name='RequestId'),
}

model ListJobResponse = {
  headers: map[string]string(name='headers'),
  body: ListJobResponseBody(name='body'),
}

async function listJobWithOptions(request: ListJobRequest, runtime: Util.RuntimeOptions): ListJobResponse {
  Util.validateModel(request);
  var query = {};
  query["EndOfJobCreatedTimeRange"] = request.endOfJobCreatedTimeRange;
  query["MaximumPageSize"] = request.maximumPageSize;
  query["NextPageToken"] = request.nextPageToken;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PipelineId"] = request.pipelineId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["StartOfJobCreatedTimeRange"] = request.startOfJobCreatedTimeRange;
  query["State"] = request.state;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listJob(request: ListJobRequest): ListJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return listJobWithOptions(request, runtime);
}

model ListMediaRequest {
  from?: string(name='From'),
  maximumPageSize?: long(name='MaximumPageSize'),
  nextPageToken?: string(name='NextPageToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  to?: string(name='To'),
}

model ListMediaResponseBody = {
  mediaList?: {
    media?: [ 
    {
      bitrate?: string(name='Bitrate'),
      cateId?: long(name='CateId'),
      censorState?: string(name='CensorState'),
      coverURL?: string(name='CoverURL'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      duration?: string(name='Duration'),
      file?: {
        state?: string(name='State'),
        URL?: string(name='URL'),
      }(name='File'),
      format?: string(name='Format'),
      fps?: string(name='Fps'),
      height?: string(name='Height'),
      mediaId?: string(name='MediaId'),
      publishState?: string(name='PublishState'),
      runIdList?: {
        runId?: [ string ](name='RunId')
      }(name='RunIdList'),
      size?: string(name='Size'),
      tags?: {
        tag?: [ string ](name='Tag')
      }(name='Tags'),
      title?: string(name='Title'),
      width?: string(name='Width'),
    }
  ](name='Media')
  }(name='MediaList'),
  nextPageToken?: string(name='NextPageToken'),
  requestId?: string(name='RequestId'),
}

model ListMediaResponse = {
  headers: map[string]string(name='headers'),
  body: ListMediaResponseBody(name='body'),
}

async function listMediaWithOptions(request: ListMediaRequest, runtime: Util.RuntimeOptions): ListMediaResponse {
  Util.validateModel(request);
  var query = {};
  query["From"] = request.from;
  query["MaximumPageSize"] = request.maximumPageSize;
  query["NextPageToken"] = request.nextPageToken;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["To"] = request.to;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListMedia',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listMedia(request: ListMediaRequest): ListMediaResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMediaWithOptions(request, runtime);
}

model ListMediaWorkflowExecutionsRequest {
  inputFileURL?: string(name='InputFileURL'),
  maximumPageSize?: long(name='MaximumPageSize'),
  mediaWorkflowId?: string(name='MediaWorkflowId'),
  mediaWorkflowName?: string(name='MediaWorkflowName'),
  nextPageToken?: string(name='NextPageToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ListMediaWorkflowExecutionsResponseBody = {
  mediaWorkflowExecutionList?: {
    mediaWorkflowExecution?: [ 
    {
      activityList?: {
        activity?: [ 
        {
          code?: string(name='Code'),
          endTime?: string(name='EndTime'),
          jobId?: string(name='JobId'),
          MNSMessageResult?: {
            errorCode?: string(name='ErrorCode'),
            errorMessage?: string(name='ErrorMessage'),
            messageId?: string(name='MessageId'),
          }(name='MNSMessageResult'),
          message?: string(name='Message'),
          name?: string(name='Name'),
          startTime?: string(name='StartTime'),
          state?: string(name='State'),
          type?: string(name='Type'),
        }
      ](name='Activity')
      }(name='ActivityList'),
      creationTime?: string(name='CreationTime'),
      input?: {
        inputFile?: {
          bucket?: string(name='Bucket'),
          location?: string(name='Location'),
          object?: string(name='Object'),
        }(name='InputFile'),
        userData?: string(name='UserData'),
      }(name='Input'),
      mediaId?: string(name='MediaId'),
      mediaWorkflowId?: string(name='MediaWorkflowId'),
      name?: string(name='Name'),
      runId?: string(name='RunId'),
      state?: string(name='State'),
    }
  ](name='MediaWorkflowExecution')
  }(name='MediaWorkflowExecutionList'),
  nextPageToken?: string(name='NextPageToken'),
  requestId?: string(name='RequestId'),
}

model ListMediaWorkflowExecutionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListMediaWorkflowExecutionsResponseBody(name='body'),
}

async function listMediaWorkflowExecutionsWithOptions(request: ListMediaWorkflowExecutionsRequest, runtime: Util.RuntimeOptions): ListMediaWorkflowExecutionsResponse {
  Util.validateModel(request);
  var query = {};
  query["InputFileURL"] = request.inputFileURL;
  query["MaximumPageSize"] = request.maximumPageSize;
  query["MediaWorkflowId"] = request.mediaWorkflowId;
  query["MediaWorkflowName"] = request.mediaWorkflowName;
  query["NextPageToken"] = request.nextPageToken;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListMediaWorkflowExecutions',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listMediaWorkflowExecutions(request: ListMediaWorkflowExecutionsRequest): ListMediaWorkflowExecutionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMediaWorkflowExecutionsWithOptions(request, runtime);
}

model ListPornPipelineRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  state?: string(name='State'),
}

model ListPornPipelineResponseBody = {
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  pipelineList?: {
    pipeline?: [ 
    {
      id?: string(name='Id'),
      name?: string(name='Name'),
      notifyConfig?: {
        queue?: string(name='Queue'),
        topic?: string(name='Topic'),
      }(name='NotifyConfig'),
      priority?: string(name='Priority'),
      state?: string(name='State'),
    }
  ](name='Pipeline')
  }(name='PipelineList'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model ListPornPipelineResponse = {
  headers: map[string]string(name='headers'),
  body: ListPornPipelineResponseBody(name='body'),
}

async function listPornPipelineWithOptions(request: ListPornPipelineRequest, runtime: Util.RuntimeOptions): ListPornPipelineResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["State"] = request.state;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListPornPipeline',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPornPipeline(request: ListPornPipelineRequest): ListPornPipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPornPipelineWithOptions(request, runtime);
}

model ListTerrorismPipelineRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  state?: string(name='State'),
}

model ListTerrorismPipelineResponseBody = {
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  pipelineList?: {
    pipeline?: [ 
    {
      id?: string(name='Id'),
      name?: string(name='Name'),
      notifyConfig?: {
        queue?: string(name='Queue'),
        topic?: string(name='Topic'),
      }(name='NotifyConfig'),
      priority?: string(name='Priority'),
      state?: string(name='State'),
    }
  ](name='Pipeline')
  }(name='PipelineList'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model ListTerrorismPipelineResponse = {
  headers: map[string]string(name='headers'),
  body: ListTerrorismPipelineResponseBody(name='body'),
}

async function listTerrorismPipelineWithOptions(request: ListTerrorismPipelineRequest, runtime: Util.RuntimeOptions): ListTerrorismPipelineResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["State"] = request.state;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListTerrorismPipeline',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTerrorismPipeline(request: ListTerrorismPipelineRequest): ListTerrorismPipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTerrorismPipelineWithOptions(request, runtime);
}

model LogicalDeleteResourceRequest {
  bid?: string(name='Bid'),
  country?: string(name='Country'),
  gmtWakeup?: string(name='GmtWakeup'),
  hid?: long(name='Hid'),
  interrupt?: boolean(name='Interrupt'),
  invoker?: string(name='Invoker'),
  message?: string(name='Message'),
  pk?: string(name='Pk'),
  success?: boolean(name='Success'),
  taskExtraData?: string(name='TaskExtraData'),
  taskIdentifier?: string(name='TaskIdentifier'),
}

model LogicalDeleteResourceResponseBody = {
  bid?: string(name='Bid'),
  country?: string(name='Country'),
  gmtWakeup?: string(name='GmtWakeup'),
  hid?: long(name='Hid'),
  interrupt?: boolean(name='Interrupt'),
  invoker?: string(name='Invoker'),
  message?: string(name='Message'),
  pk?: string(name='Pk'),
  success?: boolean(name='Success'),
  taskExtraData?: string(name='TaskExtraData'),
  taskIdentifier?: string(name='TaskIdentifier'),
}

model LogicalDeleteResourceResponse = {
  headers: map[string]string(name='headers'),
  body: LogicalDeleteResourceResponseBody(name='body'),
}

async function logicalDeleteResourceWithOptions(request: LogicalDeleteResourceRequest, runtime: Util.RuntimeOptions): LogicalDeleteResourceResponse {
  Util.validateModel(request);
  var query = {};
  query["Bid"] = request.bid;
  query["Country"] = request.country;
  query["GmtWakeup"] = request.gmtWakeup;
  query["Hid"] = request.hid;
  query["Interrupt"] = request.interrupt;
  query["Invoker"] = request.invoker;
  query["Message"] = request.message;
  query["Pk"] = request.pk;
  query["Success"] = request.success;
  query["TaskExtraData"] = request.taskExtraData;
  query["TaskIdentifier"] = request.taskIdentifier;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'LogicalDeleteResource',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function logicalDeleteResource(request: LogicalDeleteResourceRequest): LogicalDeleteResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return logicalDeleteResourceWithOptions(request, runtime);
}

model PhysicalDeleteResourceRequest {
  bid?: string(name='Bid'),
  country?: string(name='Country'),
  gmtWakeup?: string(name='GmtWakeup'),
  hid?: long(name='Hid'),
  interrupt?: boolean(name='Interrupt'),
  invoker?: string(name='Invoker'),
  message?: string(name='Message'),
  pk?: string(name='Pk'),
  success?: boolean(name='Success'),
  taskExtraData?: string(name='TaskExtraData'),
  taskIdentifier?: string(name='TaskIdentifier'),
}

model PhysicalDeleteResourceResponseBody = {
  bid?: string(name='Bid'),
  country?: string(name='Country'),
  gmtWakeup?: string(name='GmtWakeup'),
  hid?: long(name='Hid'),
  interrupt?: boolean(name='Interrupt'),
  invoker?: string(name='Invoker'),
  message?: string(name='Message'),
  pk?: string(name='Pk'),
  success?: boolean(name='Success'),
  taskExtraData?: string(name='TaskExtraData'),
  taskIdentifier?: string(name='TaskIdentifier'),
}

model PhysicalDeleteResourceResponse = {
  headers: map[string]string(name='headers'),
  body: PhysicalDeleteResourceResponseBody(name='body'),
}

async function physicalDeleteResourceWithOptions(request: PhysicalDeleteResourceRequest, runtime: Util.RuntimeOptions): PhysicalDeleteResourceResponse {
  Util.validateModel(request);
  var query = {};
  query["Bid"] = request.bid;
  query["Country"] = request.country;
  query["GmtWakeup"] = request.gmtWakeup;
  query["Hid"] = request.hid;
  query["Interrupt"] = request.interrupt;
  query["Invoker"] = request.invoker;
  query["Message"] = request.message;
  query["Pk"] = request.pk;
  query["Success"] = request.success;
  query["TaskExtraData"] = request.taskExtraData;
  query["TaskIdentifier"] = request.taskIdentifier;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'PhysicalDeleteResource',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function physicalDeleteResource(request: PhysicalDeleteResourceRequest): PhysicalDeleteResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return physicalDeleteResourceWithOptions(request, runtime);
}

model PlayInfoRequest {
  authInfo?: string(name='AuthInfo'),
  authTimeout?: long(name='AuthTimeout'),
  formats?: string(name='Formats'),
  hlsUriToken?: string(name='HlsUriToken'),
  mediaId?: string(name='MediaId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: string(name='OwnerId'),
  playDomain?: string(name='PlayDomain'),
  rand?: string(name='Rand'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: string(name='ResourceOwnerId'),
  terminal?: string(name='Terminal'),
}

model PlayInfoResponseBody = {
  notFoundCDNDomain?: {
    string?: [ string ](name='String')
  }(name='NotFoundCDNDomain'),
  playInfoList?: {
    playInfo?: [ 
    {
      url?: string(name='Url'),
      activityName?: string(name='activityName'),
      bitrate?: string(name='bitrate'),
      complexity?: string(name='complexity'),
      definition?: string(name='definition'),
      downloadType?: string(name='downloadType'),
      duration?: string(name='duration'),
      encryption?: string(name='encryption'),
      encryptionType?: string(name='encryptionType'),
      format?: string(name='format'),
      fps?: string(name='fps'),
      height?: string(name='height'),
      plaintext?: string(name='plaintext'),
      rand?: string(name='rand'),
      size?: string(name='size'),
      width?: string(name='width'),
    }
  ](name='PlayInfo')
  }(name='PlayInfoList'),
  requestId?: string(name='RequestId'),
}

model PlayInfoResponse = {
  headers: map[string]string(name='headers'),
  body: PlayInfoResponseBody(name='body'),
}

async function playInfoWithOptions(request: PlayInfoRequest, runtime: Util.RuntimeOptions): PlayInfoResponse {
  Util.validateModel(request);
  var query = {};
  query["AuthInfo"] = request.authInfo;
  query["AuthTimeout"] = request.authTimeout;
  query["Formats"] = request.formats;
  query["HlsUriToken"] = request.hlsUriToken;
  query["MediaId"] = request.mediaId;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PlayDomain"] = request.playDomain;
  query["Rand"] = request.rand;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["Terminal"] = request.terminal;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'PlayInfo',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function playInfo(request: PlayInfoRequest): PlayInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return playInfoWithOptions(request, runtime);
}

model PlayerAuthRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: string(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: string(name='ResourceOwnerId'),
}

model PlayerAuthResponseBody = {
  logURL?: string(name='LogURL'),
  requestId?: string(name='RequestId'),
  switchList?: {
    switch?: [ 
    {
      functionId?: string(name='FunctionId'),
      functionName?: string(name='FunctionName'),
      state?: string(name='State'),
      switchId?: string(name='SwitchId'),
    }
  ](name='Switch')
  }(name='SwitchList'),
}

model PlayerAuthResponse = {
  headers: map[string]string(name='headers'),
  body: PlayerAuthResponseBody(name='body'),
}

async function playerAuthWithOptions(request: PlayerAuthRequest, runtime: Util.RuntimeOptions): PlayerAuthResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'PlayerAuth',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function playerAuth(request: PlayerAuthRequest): PlayerAuthResponse {
  var runtime = new Util.RuntimeOptions{};
  return playerAuthWithOptions(request, runtime);
}

model QueryAnalysisJobListRequest {
  analysisJobIds?: string(name='AnalysisJobIds'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryAnalysisJobListResponseBody = {
  analysisJobList?: {
    analysisJob?: [ 
    {
      analysisConfig?: {
        propertiesControl?: {
          crop?: {
            height?: string(name='Height'),
            left?: string(name='Left'),
            mode?: string(name='Mode'),
            top?: string(name='Top'),
            width?: string(name='Width'),
          }(name='Crop'),
          deinterlace?: string(name='Deinterlace'),
        }(name='PropertiesControl'),
        qualityControl?: {
          methodStreaming?: string(name='MethodStreaming'),
          rateQuality?: string(name='RateQuality'),
        }(name='QualityControl'),
      }(name='AnalysisConfig'),
      code?: string(name='Code'),
      creationTime?: string(name='CreationTime'),
      id?: string(name='Id'),
      inputFile?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='InputFile'),
      MNSMessageResult?: {
        errorCode?: string(name='ErrorCode'),
        errorMessage?: string(name='ErrorMessage'),
        messageId?: string(name='MessageId'),
      }(name='MNSMessageResult'),
      message?: string(name='Message'),
      percent?: long(name='Percent'),
      pipelineId?: string(name='PipelineId'),
      priority?: string(name='Priority'),
      state?: string(name='State'),
      templateList?: {
        template?: [ 
        {
          audio?: {
            bitrate?: string(name='Bitrate'),
            channels?: string(name='Channels'),
            codec?: string(name='Codec'),
            profile?: string(name='Profile'),
            qscale?: string(name='Qscale'),
            samplerate?: string(name='Samplerate'),
          }(name='Audio'),
          container?: {
            format?: string(name='Format'),
          }(name='Container'),
          id?: string(name='Id'),
          muxConfig?: {
            gif?: {
              finalDelay?: string(name='FinalDelay'),
              loop?: string(name='Loop'),
            }(name='Gif'),
            segment?: {
              duration?: string(name='Duration'),
            }(name='Segment'),
          }(name='MuxConfig'),
          name?: string(name='Name'),
          state?: string(name='State'),
          transConfig?: {
            transMode?: string(name='TransMode'),
          }(name='TransConfig'),
          video?: {
            bitrate?: string(name='Bitrate'),
            bitrateBnd?: {
              max?: string(name='Max'),
              min?: string(name='Min'),
            }(name='BitrateBnd'),
            bufsize?: string(name='Bufsize'),
            codec?: string(name='Codec'),
            crf?: string(name='Crf'),
            degrain?: string(name='Degrain'),
            fps?: string(name='Fps'),
            gop?: string(name='Gop'),
            height?: string(name='Height'),
            maxrate?: string(name='Maxrate'),
            pixFmt?: string(name='PixFmt'),
            preset?: string(name='Preset'),
            profile?: string(name='Profile'),
            qscale?: string(name='Qscale'),
            scanMode?: string(name='ScanMode'),
            width?: string(name='Width'),
          }(name='Video'),
        }
      ](name='Template')
      }(name='TemplateList'),
      userData?: string(name='UserData'),
    }
  ](name='AnalysisJob')
  }(name='AnalysisJobList'),
  nonExistAnalysisJobIds?: {
    string?: [ string ](name='String')
  }(name='NonExistAnalysisJobIds'),
  requestId?: string(name='RequestId'),
}

model QueryAnalysisJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryAnalysisJobListResponseBody(name='body'),
}

async function queryAnalysisJobListWithOptions(request: QueryAnalysisJobListRequest, runtime: Util.RuntimeOptions): QueryAnalysisJobListResponse {
  Util.validateModel(request);
  var query = {};
  query["AnalysisJobIds"] = request.analysisJobIds;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryAnalysisJobList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryAnalysisJobList(request: QueryAnalysisJobListRequest): QueryAnalysisJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryAnalysisJobListWithOptions(request, runtime);
}

model QueryAnnotationJobListRequest {
  annotationJobIds?: string(name='AnnotationJobIds'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryAnnotationJobListResponseBody = {
  annotationJobList?: {
    annotationJob?: [ 
    {
      code?: string(name='Code'),
      creationTime?: string(name='CreationTime'),
      id?: string(name='Id'),
      input?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='Input'),
      message?: string(name='Message'),
      pipelineId?: string(name='PipelineId'),
      state?: string(name='State'),
      userData?: string(name='UserData'),
      videoAnnotationResult?: {
        annotations?: {
          annotation?: [ 
          {
            label?: string(name='Label'),
            score?: string(name='Score'),
          }
        ](name='Annotation')
        }(name='Annotations'),
        details?: string(name='Details'),
      }(name='VideoAnnotationResult'),
    }
  ](name='AnnotationJob')
  }(name='AnnotationJobList'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
  requestId?: string(name='RequestId'),
}

model QueryAnnotationJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryAnnotationJobListResponseBody(name='body'),
}

async function queryAnnotationJobListWithOptions(request: QueryAnnotationJobListRequest, runtime: Util.RuntimeOptions): QueryAnnotationJobListResponse {
  Util.validateModel(request);
  var query = {};
  query["AnnotationJobIds"] = request.annotationJobIds;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryAnnotationJobList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryAnnotationJobList(request: QueryAnnotationJobListRequest): QueryAnnotationJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryAnnotationJobListWithOptions(request, runtime);
}

model QueryAsrJobListRequest {
  jobIds?: string(name='JobIds'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryAsrJobListResponseBody = {
  jobList?: {
    job?: [ 
    {
      asrConfig?: {
        scene?: string(name='Scene'),
      }(name='AsrConfig'),
      asrResult?: {
        asrTextList?: {
          asrText?: [ 
          {
            channelId?: string(name='ChannelId'),
            endTime?: string(name='EndTime'),
            speechRate?: string(name='SpeechRate'),
            startTime?: int32(name='StartTime'),
            text?: string(name='Text'),
          }
        ](name='AsrText')
        }(name='AsrTextList'),
        duration?: string(name='Duration'),
      }(name='AsrResult'),
      code?: string(name='Code'),
      creationTime?: string(name='CreationTime'),
      id?: string(name='Id'),
      input?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='Input'),
      message?: string(name='Message'),
      pipelineId?: string(name='PipelineId'),
      state?: string(name='State'),
      userData?: string(name='UserData'),
    }
  ](name='Job')
  }(name='JobList'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
  requestId?: string(name='RequestId'),
}

model QueryAsrJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryAsrJobListResponseBody(name='body'),
}

async function queryAsrJobListWithOptions(request: QueryAsrJobListRequest, runtime: Util.RuntimeOptions): QueryAsrJobListResponse {
  Util.validateModel(request);
  var query = {};
  query["JobIds"] = request.jobIds;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryAsrJobList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryAsrJobList(request: QueryAsrJobListRequest): QueryAsrJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryAsrJobListWithOptions(request, runtime);
}

model QueryAsrPipelineListRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineIds?: string(name='PipelineIds'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryAsrPipelineListResponseBody = {
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
  pipelineList?: {
    pipeline?: [ 
    {
      id?: string(name='Id'),
      name?: string(name='Name'),
      notifyConfig?: {
        queueName?: string(name='QueueName'),
        topic?: string(name='Topic'),
      }(name='NotifyConfig'),
      priority?: string(name='Priority'),
      state?: string(name='State'),
    }
  ](name='Pipeline')
  }(name='PipelineList'),
  requestId?: string(name='RequestId'),
}

model QueryAsrPipelineListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryAsrPipelineListResponseBody(name='body'),
}

async function queryAsrPipelineListWithOptions(request: QueryAsrPipelineListRequest, runtime: Util.RuntimeOptions): QueryAsrPipelineListResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PipelineIds"] = request.pipelineIds;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryAsrPipelineList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryAsrPipelineList(request: QueryAsrPipelineListRequest): QueryAsrPipelineListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryAsrPipelineListWithOptions(request, runtime);
}

model QueryAuthConfigRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: string(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: string(name='ResourceOwnerId'),
}

model QueryAuthConfigResponseBody = {
  key1?: string(name='Key1'),
  key2?: string(name='Key2'),
  requestId?: string(name='RequestId'),
}

model QueryAuthConfigResponse = {
  headers: map[string]string(name='headers'),
  body: QueryAuthConfigResponseBody(name='body'),
}

async function queryAuthConfigWithOptions(request: QueryAuthConfigRequest, runtime: Util.RuntimeOptions): QueryAuthConfigResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryAuthConfig',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryAuthConfig(request: QueryAuthConfigRequest): QueryAuthConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryAuthConfigWithOptions(request, runtime);
}

model QueryCensorJobListRequest {
  jobIds?: string(name='JobIds'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryCensorJobListResponseBody = {
  censorJobList?: {
    censorJob?: [ 
    {
      barrageCensorResult?: string(name='BarrageCensorResult'),
      censorConfig?: {
        bizType?: string(name='BizType'),
        interval?: string(name='Interval'),
        outputFile?: {
          bucket?: string(name='Bucket'),
          location?: string(name='Location'),
          object?: string(name='Object'),
        }(name='OutputFile'),
        saveType?: string(name='SaveType'),
        scenes?: string(name='Scenes'),
      }(name='CensorConfig'),
      censorPornResult?: {
        averageScore?: string(name='AverageScore'),
        label?: string(name='Label'),
        maxScore?: string(name='MaxScore'),
        pornCounterList?: {
          counter?: [ 
          {
            count?: int32(name='Count'),
            label?: string(name='Label'),
          }
        ](name='Counter')
        }(name='PornCounterList'),
        pornTopList?: {
          top?: [ 
          {
            index?: string(name='Index'),
            label?: string(name='Label'),
            object?: string(name='Object'),
            score?: string(name='Score'),
            timestamp?: string(name='Timestamp'),
          }
        ](name='Top')
        }(name='PornTopList'),
        suggestion?: string(name='Suggestion'),
      }(name='CensorPornResult'),
      censorTerrorismResult?: {
        averageScore?: string(name='AverageScore'),
        label?: string(name='Label'),
        maxScore?: string(name='MaxScore'),
        suggestion?: string(name='Suggestion'),
        terrorismCounterList?: {
          counter?: [ 
          {
            count?: int32(name='Count'),
            label?: string(name='Label'),
          }
        ](name='Counter')
        }(name='TerrorismCounterList'),
        terrorismTopList?: {
          top?: [ 
          {
            index?: string(name='Index'),
            label?: string(name='Label'),
            object?: string(name='Object'),
            score?: string(name='Score'),
            timestamp?: string(name='Timestamp'),
          }
        ](name='Top')
        }(name='TerrorismTopList'),
      }(name='CensorTerrorismResult'),
      code?: string(name='Code'),
      creationTime?: string(name='CreationTime'),
      descCensorResult?: string(name='DescCensorResult'),
      id?: string(name='Id'),
      imageCensorResults?: {
        imageCensorResult?: [ 
        {
          imageBucket?: string(name='ImageBucket'),
          imageLocation?: string(name='ImageLocation'),
          imageObject?: string(name='ImageObject'),
          result?: string(name='Result'),
        }
      ](name='ImageCensorResult')
      }(name='ImageCensorResults'),
      input?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='Input'),
      message?: string(name='Message'),
      pipelineId?: string(name='PipelineId'),
      resultSaveObject?: string(name='ResultSaveObject'),
      state?: string(name='State'),
      titleCensorResult?: string(name='TitleCensorResult'),
      userData?: string(name='UserData'),
    }
  ](name='CensorJob')
  }(name='CensorJobList'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
  requestId?: string(name='RequestId'),
}

model QueryCensorJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryCensorJobListResponseBody(name='body'),
}

async function queryCensorJobListWithOptions(request: QueryCensorJobListRequest, runtime: Util.RuntimeOptions): QueryCensorJobListResponse {
  Util.validateModel(request);
  var query = {};
  query["JobIds"] = request.jobIds;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryCensorJobList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryCensorJobList(request: QueryCensorJobListRequest): QueryCensorJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryCensorJobListWithOptions(request, runtime);
}

model QueryCensorPipelineListRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineIds?: string(name='PipelineIds'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryCensorPipelineListResponseBody = {
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
  pipelineList?: {
    pipeline?: [ 
    {
      id?: string(name='Id'),
      name?: string(name='Name'),
      notifyConfig?: {
        queue?: string(name='Queue'),
        topic?: string(name='Topic'),
      }(name='NotifyConfig'),
      priority?: string(name='Priority'),
      state?: string(name='State'),
    }
  ](name='Pipeline')
  }(name='PipelineList'),
  requestId?: string(name='RequestId'),
}

model QueryCensorPipelineListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryCensorPipelineListResponseBody(name='body'),
}

async function queryCensorPipelineListWithOptions(request: QueryCensorPipelineListRequest, runtime: Util.RuntimeOptions): QueryCensorPipelineListResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PipelineIds"] = request.pipelineIds;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryCensorPipelineList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryCensorPipelineList(request: QueryCensorPipelineListRequest): QueryCensorPipelineListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryCensorPipelineListWithOptions(request, runtime);
}

model QueryComplexJobListRequest {
  jobIds?: string(name='JobIds'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryComplexJobListResponseBody = {
  jobList?: {
    job?: [ 
    {
      code?: string(name='Code'),
      complexEditingConfigs?: {
        complexEditingConfigs?: [ 
        {
          editing?: {
            clipList?: {
              clip?: [ 
              {
                effects?: {
                  effect?: [ 
                  {
                    effect?: string(name='Effect'),
                    effectConfig?: string(name='EffectConfig'),
                  }
                ](name='Effect')
                }(name='Effects'),
                id?: string(name='Id'),
                in?: string(name='In'),
                out?: string(name='Out'),
                sourceID?: string(name='SourceID'),
                sourceStrmMap?: string(name='SourceStrmMap'),
                sourceType?: string(name='SourceType'),
                type?: string(name='Type'),
              }
            ](name='Clip')
            }(name='ClipList'),
            timeline?: {
              timelineConfig?: {
                timelineConfigAudio?: {
                  channelLayout?: string(name='ChannelLayout'),
                  channels?: string(name='Channels'),
                  samplerate?: string(name='Samplerate'),
                }(name='TimelineConfigAudio'),
                timelineConfigVideo?: {
                  bgColor?: string(name='BgColor'),
                  fps?: string(name='Fps'),
                  height?: string(name='Height'),
                  isGpuData?: string(name='IsGpuData'),
                  isOneTrackData?: string(name='IsOneTrackData'),
                  reclosePrec?: string(name='ReclosePrec'),
                  renderRatio?: string(name='RenderRatio'),
                  width?: string(name='Width'),
                }(name='TimelineConfigVideo'),
              }(name='TimelineConfig'),
              trackList?: {
                track?: [ 
                {
                  clips?: {
                    clip?: [ 
                    {
                      clipsConfig?: {
                        clipsConfigVideo?: {
                          l?: string(name='L'),
                          t?: string(name='T'),
                        }(name='ClipsConfigVideo'),
                      }(name='ClipsConfig'),
                      in?: string(name='In'),
                      out?: string(name='Out'),
                      clipID?: string(name='clipID'),
                    }
                  ](name='Clip')
                  }(name='Clips'),
                  id?: string(name='Id'),
                  order?: string(name='Order'),
                  type?: string(name='Type'),
                }
              ](name='Track')
              }(name='TrackList'),
            }(name='Timeline'),
          }(name='Editing'),
        }
      ](name='ComplexEditingConfigs')
      }(name='ComplexEditingConfigs'),
      creationTime?: string(name='CreationTime'),
      finishTime?: string(name='FinishTime'),
      inputs?: {
        inputs?: [ 
        {
          editingInputs?: {
            editingInput?: [ 
            {
              id?: string(name='Id'),
              inputConfig?: {
                deinterlaceMethod?: string(name='DeinterlaceMethod'),
                isNormalSar?: string(name='IsNormalSar'),
              }(name='InputConfig'),
              inputFile?: {
                bucket?: string(name='Bucket'),
                location?: string(name='Location'),
                object?: string(name='Object'),
              }(name='InputFile'),
            }
          ](name='EditingInput')
          }(name='EditingInputs'),
        }
      ](name='Inputs')
      }(name='Inputs'),
      jobId?: string(name='JobId'),
      MNSMessageResult?: {
        errorCode?: string(name='ErrorCode'),
        errorMessage?: string(name='ErrorMessage'),
        messageId?: string(name='MessageId'),
      }(name='MNSMessageResult'),
      message?: string(name='Message'),
      percent?: long(name='Percent'),
      pipelineId?: string(name='PipelineId'),
      state?: string(name='State'),
      transcodeOutput?: {
        audio?: {
          bitrate?: string(name='Bitrate'),
          channels?: string(name='Channels'),
          codec?: string(name='Codec'),
          profile?: string(name='Profile'),
          qscale?: string(name='Qscale'),
          samplerate?: string(name='Samplerate'),
          volume?: {
            level?: string(name='Level'),
            method?: string(name='Method'),
          }(name='Volume'),
        }(name='Audio'),
        audioStreamMap?: string(name='AudioStreamMap'),
        clip?: {
          timeSpan?: {
            duration?: string(name='Duration'),
            seek?: string(name='Seek'),
          }(name='TimeSpan'),
        }(name='Clip'),
        container?: {
          format?: string(name='Format'),
        }(name='Container'),
        deWatermark?: string(name='DeWatermark'),
        digiWaterMark?: {
          alpha?: string(name='Alpha'),
          inputFile?: {
            bucket?: string(name='Bucket'),
            location?: string(name='Location'),
            object?: string(name='Object'),
          }(name='InputFile'),
          type?: string(name='Type'),
        }(name='DigiWaterMark'),
        encryption?: {
          id?: string(name='Id'),
          key?: string(name='Key'),
          keyType?: string(name='KeyType'),
          keyUri?: string(name='KeyUri'),
          skipCnt?: string(name='SkipCnt'),
          type?: string(name='Type'),
        }(name='Encryption'),
        m3U8NonStandardSupport?: {
          TS?: {
            md5Support?: boolean(name='Md5Support'),
            sizeSupport?: boolean(name='SizeSupport'),
          }(name='TS'),
        }(name='M3U8NonStandardSupport'),
        mergeConfigUrl?: string(name='MergeConfigUrl'),
        mergeList?: {
          merge?: [ 
          {
            duration?: string(name='Duration'),
            mergeURL?: string(name='MergeURL'),
            roleArn?: string(name='RoleArn'),
            start?: string(name='Start'),
          }
        ](name='Merge')
        }(name='MergeList'),
        muxConfig?: {
          gif?: {
            ditherMode?: string(name='DitherMode'),
            finalDelay?: string(name='FinalDelay'),
            isCustomPalette?: string(name='IsCustomPalette'),
            loop?: string(name='Loop'),
          }(name='Gif'),
          segment?: {
            duration?: string(name='Duration'),
          }(name='Segment'),
        }(name='MuxConfig'),
        outputFile?: {
          bucket?: string(name='Bucket'),
          location?: string(name='Location'),
          object?: string(name='Object'),
          roleArn?: string(name='RoleArn'),
        }(name='OutputFile'),
        priority?: string(name='Priority'),
        properties?: {
          bitrate?: string(name='Bitrate'),
          duration?: string(name='Duration'),
          fileFormat?: string(name='FileFormat'),
          fileSize?: string(name='FileSize'),
          format?: {
            bitrate?: string(name='Bitrate'),
            duration?: string(name='Duration'),
            formatLongName?: string(name='FormatLongName'),
            formatName?: string(name='FormatName'),
            numPrograms?: string(name='NumPrograms'),
            numStreams?: string(name='NumStreams'),
            size?: string(name='Size'),
            startTime?: string(name='StartTime'),
          }(name='Format'),
          fps?: string(name='Fps'),
          height?: string(name='Height'),
          streams?: {
            audioStreamList?: {
              audioStream?: [ 
              {
                bitrate?: string(name='Bitrate'),
                channelLayout?: string(name='ChannelLayout'),
                channels?: string(name='Channels'),
                codecLongName?: string(name='CodecLongName'),
                codecName?: string(name='CodecName'),
                codecTag?: string(name='CodecTag'),
                codecTagString?: string(name='CodecTagString'),
                codecTimeBase?: string(name='CodecTimeBase'),
                duration?: string(name='Duration'),
                index?: string(name='Index'),
                lang?: string(name='Lang'),
                numFrames?: string(name='NumFrames'),
                sampleFmt?: string(name='SampleFmt'),
                samplerate?: string(name='Samplerate'),
                startTime?: string(name='StartTime'),
                timebase?: string(name='Timebase'),
              }
            ](name='AudioStream')
            }(name='AudioStreamList'),
            subtitleStreamList?: {
              subtitleStream?: [ 
              {
                index?: string(name='Index'),
                lang?: string(name='Lang'),
              }
            ](name='SubtitleStream')
            }(name='SubtitleStreamList'),
            videoStreamList?: {
              videoStream?: [ 
              {
                avgFPS?: string(name='AvgFPS'),
                bitrate?: string(name='Bitrate'),
                codecLongName?: string(name='CodecLongName'),
                codecName?: string(name='CodecName'),
                codecTag?: string(name='CodecTag'),
                codecTagString?: string(name='CodecTagString'),
                codecTimeBase?: string(name='CodecTimeBase'),
                dar?: string(name='Dar'),
                duration?: string(name='Duration'),
                fps?: string(name='Fps'),
                hasBFrames?: string(name='HasBFrames'),
                height?: string(name='Height'),
                index?: string(name='Index'),
                lang?: string(name='Lang'),
                level?: string(name='Level'),
                networkCost?: {
                  avgBitrate?: string(name='AvgBitrate'),
                  costBandwidth?: string(name='CostBandwidth'),
                  preloadTime?: string(name='PreloadTime'),
                }(name='NetworkCost'),
                numFrames?: string(name='NumFrames'),
                pixFmt?: string(name='PixFmt'),
                profile?: string(name='Profile'),
                sar?: string(name='Sar'),
                startTime?: string(name='StartTime'),
                timebase?: string(name='Timebase'),
                width?: string(name='Width'),
              }
            ](name='VideoStream')
            }(name='VideoStreamList'),
          }(name='Streams'),
          width?: string(name='Width'),
        }(name='Properties'),
        rotate?: string(name='Rotate'),
        subtitleConfig?: {
          extSubtitleList?: {
            extSubtitle?: [ 
            {
              charEnc?: string(name='CharEnc'),
              fontName?: string(name='FontName'),
              input?: {
                bucket?: string(name='Bucket'),
                location?: string(name='Location'),
                object?: string(name='Object'),
              }(name='Input'),
            }
          ](name='ExtSubtitle')
          }(name='ExtSubtitleList'),
          subtitleList?: {
            subtitle?: [ 
            {
              map?: string(name='Map'),
            }
          ](name='Subtitle')
          }(name='SubtitleList'),
        }(name='SubtitleConfig'),
        superReso?: {
          isHalfSample?: string(name='IsHalfSample'),
        }(name='SuperReso'),
        templateId?: string(name='TemplateId'),
        transConfig?: {
          adjDarMethod?: string(name='AdjDarMethod'),
          duration?: string(name='Duration'),
          isCheckAudioBitrate?: string(name='IsCheckAudioBitrate'),
          isCheckAudioBitrateFail?: string(name='IsCheckAudioBitrateFail'),
          isCheckReso?: string(name='IsCheckReso'),
          isCheckResoFail?: string(name='IsCheckResoFail'),
          isCheckVideoBitrate?: string(name='IsCheckVideoBitrate'),
          isCheckVideoBitrateFail?: string(name='IsCheckVideoBitrateFail'),
          transMode?: string(name='TransMode'),
        }(name='TransConfig'),
        userData?: string(name='UserData'),
        video?: {
          bitrate?: string(name='Bitrate'),
          bitrateBnd?: {
            max?: string(name='Max'),
            min?: string(name='Min'),
          }(name='BitrateBnd'),
          bufsize?: string(name='Bufsize'),
          codec?: string(name='Codec'),
          crf?: string(name='Crf'),
          crop?: string(name='Crop'),
          degrain?: string(name='Degrain'),
          fps?: string(name='Fps'),
          gop?: string(name='Gop'),
          height?: string(name='Height'),
          maxFps?: string(name='MaxFps'),
          maxrate?: string(name='Maxrate'),
          pad?: string(name='Pad'),
          pixFmt?: string(name='PixFmt'),
          preset?: string(name='Preset'),
          profile?: string(name='Profile'),
          qscale?: string(name='Qscale'),
          scanMode?: string(name='ScanMode'),
          width?: string(name='Width'),
        }(name='Video'),
        videoStreamMap?: string(name='VideoStreamMap'),
        waterMarkConfigUrl?: string(name='WaterMarkConfigUrl'),
        waterMarkList?: {
          waterMark?: [ 
          {
            dx?: string(name='Dx'),
            dy?: string(name='Dy'),
            height?: string(name='Height'),
            inputFile?: {
              bucket?: string(name='Bucket'),
              location?: string(name='Location'),
              object?: string(name='Object'),
            }(name='InputFile'),
            referPos?: string(name='ReferPos'),
            type?: string(name='Type'),
            waterMarkTemplateId?: string(name='WaterMarkTemplateId'),
            width?: string(name='Width'),
          }
        ](name='WaterMark')
        }(name='WaterMarkList'),
      }(name='transcodeOutput'),
    }
  ](name='Job')
  }(name='JobList'),
  nonExistJobIds?: {
    string?: [ string ](name='String')
  }(name='NonExistJobIds'),
  requestId?: string(name='RequestId'),
}

model QueryComplexJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryComplexJobListResponseBody(name='body'),
}

async function queryComplexJobListWithOptions(request: QueryComplexJobListRequest, runtime: Util.RuntimeOptions): QueryComplexJobListResponse {
  Util.validateModel(request);
  var query = {};
  query["JobIds"] = request.jobIds;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryComplexJobList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryComplexJobList(request: QueryComplexJobListRequest): QueryComplexJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryComplexJobListWithOptions(request, runtime);
}

model QueryCoverJobListRequest {
  coverJobIds?: string(name='CoverJobIds'),
  endOfJobCreatedTimeRange?: string(name='EndOfJobCreatedTimeRange'),
  maximumPageSize?: long(name='MaximumPageSize'),
  nextPageToken?: string(name='NextPageToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startOfJobCreatedTimeRange?: string(name='StartOfJobCreatedTimeRange'),
  state?: string(name='State'),
}

model QueryCoverJobListResponseBody = {
  coverJobList?: {
    coverJob?: [ 
    {
      code?: string(name='Code'),
      coverConfig?: {
        outputFile?: {
          bucket?: string(name='Bucket'),
          location?: string(name='Location'),
          object?: string(name='Object'),
        }(name='OutputFile'),
      }(name='CoverConfig'),
      coverImageList?: {
        coverImage?: [ 
        {
          score?: string(name='Score'),
          time?: string(name='Time'),
          url?: string(name='Url'),
        }
      ](name='CoverImage')
      }(name='CoverImageList'),
      creationTime?: string(name='CreationTime'),
      id?: string(name='Id'),
      input?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='Input'),
      message?: string(name='Message'),
      pipelineId?: string(name='PipelineId'),
      state?: string(name='State'),
      userData?: string(name='UserData'),
    }
  ](name='CoverJob')
  }(name='CoverJobList'),
  nextPageToken?: string(name='NextPageToken'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
  requestId?: string(name='RequestId'),
}

model QueryCoverJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryCoverJobListResponseBody(name='body'),
}

async function queryCoverJobListWithOptions(request: QueryCoverJobListRequest, runtime: Util.RuntimeOptions): QueryCoverJobListResponse {
  Util.validateModel(request);
  var query = {};
  query["CoverJobIds"] = request.coverJobIds;
  query["EndOfJobCreatedTimeRange"] = request.endOfJobCreatedTimeRange;
  query["MaximumPageSize"] = request.maximumPageSize;
  query["NextPageToken"] = request.nextPageToken;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PipelineId"] = request.pipelineId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["StartOfJobCreatedTimeRange"] = request.startOfJobCreatedTimeRange;
  query["State"] = request.state;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryCoverJobList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryCoverJobList(request: QueryCoverJobListRequest): QueryCoverJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryCoverJobListWithOptions(request, runtime);
}

model QueryCoverPipelineListRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineIds?: string(name='PipelineIds'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryCoverPipelineListResponseBody = {
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
  pipelineList?: {
    pipeline?: [ 
    {
      id?: string(name='Id'),
      name?: string(name='Name'),
      notifyConfig?: {
        queue?: string(name='Queue'),
        topic?: string(name='Topic'),
      }(name='NotifyConfig'),
      priority?: string(name='Priority'),
      role?: string(name='Role'),
      state?: string(name='State'),
    }
  ](name='Pipeline')
  }(name='PipelineList'),
  requestId?: string(name='RequestId'),
}

model QueryCoverPipelineListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryCoverPipelineListResponseBody(name='body'),
}

async function queryCoverPipelineListWithOptions(request: QueryCoverPipelineListRequest, runtime: Util.RuntimeOptions): QueryCoverPipelineListResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PipelineIds"] = request.pipelineIds;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryCoverPipelineList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryCoverPipelineList(request: QueryCoverPipelineListRequest): QueryCoverPipelineListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryCoverPipelineListWithOptions(request, runtime);
}

model QueryEditingJobListRequest {
  jobIds?: string(name='JobIds'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryEditingJobListResponseBody = {
  jobList?: {
    job?: [ 
    {
      code?: string(name='Code'),
      creationTime?: string(name='CreationTime'),
      editingConfig?: {
        audio?: {
          bitrate?: string(name='Bitrate'),
          channels?: string(name='Channels'),
          codec?: string(name='Codec'),
          profile?: string(name='Profile'),
          qscale?: string(name='Qscale'),
          samplerate?: string(name='Samplerate'),
          volume?: {
            level?: string(name='Level'),
            method?: string(name='Method'),
          }(name='Volume'),
        }(name='Audio'),
        audioStreamMap?: string(name='AudioStreamMap'),
        clip?: {
          timeSpan?: {
            duration?: string(name='Duration'),
            seek?: string(name='Seek'),
          }(name='TimeSpan'),
        }(name='Clip'),
        container?: {
          format?: string(name='Format'),
        }(name='Container'),
        deWatermark?: string(name='DeWatermark'),
        digiWaterMark?: {
          alpha?: string(name='Alpha'),
          inputFile?: {
            bucket?: string(name='Bucket'),
            location?: string(name='Location'),
            object?: string(name='Object'),
          }(name='InputFile'),
          type?: string(name='Type'),
        }(name='DigiWaterMark'),
        editing?: {
          clipList?: {
            clip?: [ 
            {
              effects?: {
                effect?: [ 
                {
                  effect?: string(name='Effect'),
                  effectConfig?: string(name='EffectConfig'),
                }
              ](name='Effect')
              }(name='Effects'),
              id?: string(name='Id'),
              in?: string(name='In'),
              out?: string(name='Out'),
              sourceID?: string(name='SourceID'),
              sourceStrmMap?: string(name='SourceStrmMap'),
              sourceType?: string(name='SourceType'),
              type?: string(name='Type'),
            }
          ](name='Clip')
          }(name='ClipList'),
          timeline?: {
            timelineConfig?: {
              timelineConfigAudio?: {
                channelLayout?: string(name='ChannelLayout'),
                channels?: string(name='Channels'),
                samplerate?: string(name='Samplerate'),
              }(name='TimelineConfigAudio'),
              timelineConfigVideo?: {
                bgColor?: string(name='BgColor'),
                fps?: string(name='Fps'),
                height?: string(name='Height'),
                isGpuData?: string(name='IsGpuData'),
                isOneTrackData?: string(name='IsOneTrackData'),
                reclosePrec?: string(name='ReclosePrec'),
                renderRatio?: string(name='RenderRatio'),
                width?: string(name='Width'),
              }(name='TimelineConfigVideo'),
            }(name='TimelineConfig'),
            trackList?: {
              track?: [ 
              {
                clips?: {
                  clip?: [ 
                  {
                    clipsConfig?: {
                      clipsConfigVideo?: {
                        l?: string(name='L'),
                        t?: string(name='T'),
                      }(name='ClipsConfigVideo'),
                    }(name='ClipsConfig'),
                    in?: string(name='In'),
                    out?: string(name='Out'),
                    clipID?: string(name='clipID'),
                  }
                ](name='Clip')
                }(name='Clips'),
                id?: string(name='Id'),
                order?: string(name='Order'),
                type?: string(name='Type'),
              }
            ](name='Track')
            }(name='TrackList'),
          }(name='Timeline'),
        }(name='Editing'),
        encryption?: {
          id?: string(name='Id'),
          key?: string(name='Key'),
          keyType?: string(name='KeyType'),
          keyUri?: string(name='KeyUri'),
          skipCnt?: string(name='SkipCnt'),
          type?: string(name='Type'),
        }(name='Encryption'),
        m3U8NonStandardSupport?: {
          TS?: {
            md5Support?: boolean(name='Md5Support'),
            sizeSupport?: boolean(name='SizeSupport'),
          }(name='TS'),
        }(name='M3U8NonStandardSupport'),
        mergeConfigUrl?: string(name='MergeConfigUrl'),
        mergeList?: {
          merge?: [ 
          {
            duration?: string(name='Duration'),
            mergeURL?: string(name='MergeURL'),
            roleArn?: string(name='RoleArn'),
            start?: string(name='Start'),
          }
        ](name='Merge')
        }(name='MergeList'),
        muxConfig?: {
          gif?: {
            ditherMode?: string(name='DitherMode'),
            finalDelay?: string(name='FinalDelay'),
            isCustomPalette?: string(name='IsCustomPalette'),
            loop?: string(name='Loop'),
          }(name='Gif'),
          segment?: {
            duration?: string(name='Duration'),
          }(name='Segment'),
        }(name='MuxConfig'),
        outputFile?: {
          bucket?: string(name='Bucket'),
          location?: string(name='Location'),
          object?: string(name='Object'),
          roleArn?: string(name='RoleArn'),
        }(name='OutputFile'),
        priority?: string(name='Priority'),
        properties?: {
          bitrate?: string(name='Bitrate'),
          duration?: string(name='Duration'),
          fileFormat?: string(name='FileFormat'),
          fileSize?: string(name='FileSize'),
          format?: {
            bitrate?: string(name='Bitrate'),
            duration?: string(name='Duration'),
            formatLongName?: string(name='FormatLongName'),
            formatName?: string(name='FormatName'),
            numPrograms?: string(name='NumPrograms'),
            numStreams?: string(name='NumStreams'),
            size?: string(name='Size'),
            startTime?: string(name='StartTime'),
          }(name='Format'),
          fps?: string(name='Fps'),
          height?: string(name='Height'),
          streams?: {
            audioStreamList?: {
              audioStream?: [ 
              {
                bitrate?: string(name='Bitrate'),
                channelLayout?: string(name='ChannelLayout'),
                channels?: string(name='Channels'),
                codecLongName?: string(name='CodecLongName'),
                codecName?: string(name='CodecName'),
                codecTag?: string(name='CodecTag'),
                codecTagString?: string(name='CodecTagString'),
                codecTimeBase?: string(name='CodecTimeBase'),
                duration?: string(name='Duration'),
                index?: string(name='Index'),
                lang?: string(name='Lang'),
                numFrames?: string(name='NumFrames'),
                sampleFmt?: string(name='SampleFmt'),
                samplerate?: string(name='Samplerate'),
                startTime?: string(name='StartTime'),
                timebase?: string(name='Timebase'),
              }
            ](name='AudioStream')
            }(name='AudioStreamList'),
            subtitleStreamList?: {
              subtitleStream?: [ 
              {
                index?: string(name='Index'),
                lang?: string(name='Lang'),
              }
            ](name='SubtitleStream')
            }(name='SubtitleStreamList'),
            videoStreamList?: {
              videoStream?: [ 
              {
                avgFPS?: string(name='AvgFPS'),
                bitrate?: string(name='Bitrate'),
                codecLongName?: string(name='CodecLongName'),
                codecName?: string(name='CodecName'),
                codecTag?: string(name='CodecTag'),
                codecTagString?: string(name='CodecTagString'),
                codecTimeBase?: string(name='CodecTimeBase'),
                dar?: string(name='Dar'),
                duration?: string(name='Duration'),
                fps?: string(name='Fps'),
                hasBFrames?: string(name='HasBFrames'),
                height?: string(name='Height'),
                index?: string(name='Index'),
                lang?: string(name='Lang'),
                level?: string(name='Level'),
                networkCost?: {
                  avgBitrate?: string(name='AvgBitrate'),
                  costBandwidth?: string(name='CostBandwidth'),
                  preloadTime?: string(name='PreloadTime'),
                }(name='NetworkCost'),
                numFrames?: string(name='NumFrames'),
                pixFmt?: string(name='PixFmt'),
                profile?: string(name='Profile'),
                sar?: string(name='Sar'),
                startTime?: string(name='StartTime'),
                timebase?: string(name='Timebase'),
                width?: string(name='Width'),
              }
            ](name='VideoStream')
            }(name='VideoStreamList'),
          }(name='Streams'),
          width?: string(name='Width'),
        }(name='Properties'),
        rotate?: string(name='Rotate'),
        subtitleConfig?: {
          extSubtitleList?: {
            extSubtitle?: [ 
            {
              charEnc?: string(name='CharEnc'),
              fontName?: string(name='FontName'),
              input?: {
                bucket?: string(name='Bucket'),
                location?: string(name='Location'),
                object?: string(name='Object'),
              }(name='Input'),
            }
          ](name='ExtSubtitle')
          }(name='ExtSubtitleList'),
          subtitleList?: {
            subtitle?: [ 
            {
              map?: string(name='Map'),
            }
          ](name='Subtitle')
          }(name='SubtitleList'),
        }(name='SubtitleConfig'),
        superReso?: {
          isHalfSample?: string(name='IsHalfSample'),
        }(name='SuperReso'),
        templateId?: string(name='TemplateId'),
        transConfig?: {
          adjDarMethod?: string(name='AdjDarMethod'),
          duration?: string(name='Duration'),
          isCheckAudioBitrate?: string(name='IsCheckAudioBitrate'),
          isCheckAudioBitrateFail?: string(name='IsCheckAudioBitrateFail'),
          isCheckReso?: string(name='IsCheckReso'),
          isCheckResoFail?: string(name='IsCheckResoFail'),
          isCheckVideoBitrate?: string(name='IsCheckVideoBitrate'),
          isCheckVideoBitrateFail?: string(name='IsCheckVideoBitrateFail'),
          transMode?: string(name='TransMode'),
        }(name='TransConfig'),
        userData?: string(name='UserData'),
        video?: {
          bitrate?: string(name='Bitrate'),
          bitrateBnd?: {
            max?: string(name='Max'),
            min?: string(name='Min'),
          }(name='BitrateBnd'),
          bufsize?: string(name='Bufsize'),
          codec?: string(name='Codec'),
          crf?: string(name='Crf'),
          crop?: string(name='Crop'),
          degrain?: string(name='Degrain'),
          fps?: string(name='Fps'),
          gop?: string(name='Gop'),
          height?: string(name='Height'),
          maxFps?: string(name='MaxFps'),
          maxrate?: string(name='Maxrate'),
          pad?: string(name='Pad'),
          pixFmt?: string(name='PixFmt'),
          preset?: string(name='Preset'),
          profile?: string(name='Profile'),
          qscale?: string(name='Qscale'),
          scanMode?: string(name='ScanMode'),
          width?: string(name='Width'),
        }(name='Video'),
        videoStreamMap?: string(name='VideoStreamMap'),
        waterMarkConfigUrl?: string(name='WaterMarkConfigUrl'),
        waterMarkList?: {
          waterMark?: [ 
          {
            dx?: string(name='Dx'),
            dy?: string(name='Dy'),
            height?: string(name='Height'),
            inputFile?: {
              bucket?: string(name='Bucket'),
              location?: string(name='Location'),
              object?: string(name='Object'),
            }(name='InputFile'),
            referPos?: string(name='ReferPos'),
            type?: string(name='Type'),
            waterMarkTemplateId?: string(name='WaterMarkTemplateId'),
            width?: string(name='Width'),
          }
        ](name='WaterMark')
        }(name='WaterMarkList'),
      }(name='EditingConfig'),
      editingInputs?: {
        editingInput?: [ 
        {
          id?: string(name='Id'),
          inputConfig?: {
            deinterlaceMethod?: string(name='DeinterlaceMethod'),
            isNormalSar?: string(name='IsNormalSar'),
          }(name='InputConfig'),
          inputFile?: {
            bucket?: string(name='Bucket'),
            location?: string(name='Location'),
            object?: string(name='Object'),
          }(name='InputFile'),
        }
      ](name='EditingInput')
      }(name='EditingInputs'),
      finishTime?: string(name='FinishTime'),
      jobId?: string(name='JobId'),
      MNSMessageResult?: {
        errorCode?: string(name='ErrorCode'),
        errorMessage?: string(name='ErrorMessage'),
        messageId?: string(name='MessageId'),
      }(name='MNSMessageResult'),
      message?: string(name='Message'),
      percent?: long(name='Percent'),
      pipelineId?: string(name='PipelineId'),
      state?: string(name='State'),
    }
  ](name='Job')
  }(name='JobList'),
  nonExistJobIds?: {
    string?: [ string ](name='String')
  }(name='NonExistJobIds'),
  requestId?: string(name='RequestId'),
}

model QueryEditingJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryEditingJobListResponseBody(name='body'),
}

async function queryEditingJobListWithOptions(request: QueryEditingJobListRequest, runtime: Util.RuntimeOptions): QueryEditingJobListResponse {
  Util.validateModel(request);
  var query = {};
  query["JobIds"] = request.jobIds;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryEditingJobList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryEditingJobList(request: QueryEditingJobListRequest): QueryEditingJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryEditingJobListWithOptions(request, runtime);
}

model QueryFacerecogJobListRequest {
  facerecogJobIds?: string(name='FacerecogJobIds'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryFacerecogJobListResponseBody = {
  facerecogJobList?: {
    facerecogJob?: [ 
    {
      code?: string(name='Code'),
      creationTime?: string(name='CreationTime'),
      id?: string(name='Id'),
      input?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='Input'),
      message?: string(name='Message'),
      pipelineId?: string(name='PipelineId'),
      state?: string(name='State'),
      userData?: string(name='UserData'),
      videoFacerecogResult?: {
        facerecogs?: {
          facerecog?: [ 
          {
            faces?: {
              face?: [ 
              {
                name?: string(name='Name'),
                score?: string(name='Score'),
                target?: string(name='Target'),
              }
            ](name='Face')
            }(name='Faces'),
            time?: string(name='Time'),
          }
        ](name='Facerecog')
        }(name='Facerecogs'),
      }(name='VideoFacerecogResult'),
    }
  ](name='FacerecogJob')
  }(name='FacerecogJobList'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
  requestId?: string(name='RequestId'),
}

model QueryFacerecogJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryFacerecogJobListResponseBody(name='body'),
}

async function queryFacerecogJobListWithOptions(request: QueryFacerecogJobListRequest, runtime: Util.RuntimeOptions): QueryFacerecogJobListResponse {
  Util.validateModel(request);
  var query = {};
  query["FacerecogJobIds"] = request.facerecogJobIds;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryFacerecogJobList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryFacerecogJobList(request: QueryFacerecogJobListRequest): QueryFacerecogJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryFacerecogJobListWithOptions(request, runtime);
}

model QueryFpCompareJobListRequest {
  jobIds?: string(name='JobIds'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryFpCompareJobListResponseBody = {
  fpCompareJobList?: {
    fpCompareJob?: [ 
    {
      code?: string(name='Code'),
      creationTime?: string(name='CreationTime'),
      finishTime?: string(name='FinishTime'),
      fpCompareResult?: {
        masterMediaInfo?: {
          audioBitRate?: string(name='AudioBitRate'),
          audioChannels?: string(name='AudioChannels'),
          audioSampleRate?: string(name='AudioSampleRate'),
          duration?: string(name='Duration'),
          fpNum?: string(name='FpNum'),
          fps?: string(name='Fps'),
          height?: string(name='Height'),
          totalVideoFrame?: string(name='TotalVideoFrame'),
          width?: string(name='Width'),
        }(name='MasterMediaInfo'),
        mediaMatchSegments?: {
          mediaMatchSegment?: [ 
          {
            masterEndFrame?: string(name='MasterEndFrame'),
            masterEndTime?: string(name='MasterEndTime'),
            masterStartFrame?: string(name='MasterStartFrame'),
            masterStartTime?: string(name='MasterStartTime'),
            queryEndFrame?: string(name='QueryEndFrame'),
            queryEndTime?: string(name='QueryEndTime'),
            queryStartFrame?: string(name='QueryStartFrame'),
            queryStartTime?: string(name='QueryStartTime'),
            score?: string(name='Score'),
            totalMatchFrameNum?: string(name='TotalMatchFrameNum'),
          }
        ](name='MediaMatchSegment')
        }(name='MediaMatchSegments'),
        queryMediaInfo?: {
          audioBitRate?: string(name='AudioBitRate'),
          audioChannels?: string(name='AudioChannels'),
          audioSampleRate?: string(name='AudioSampleRate'),
          duration?: string(name='Duration'),
          fpNum?: string(name='FpNum'),
          fps?: string(name='Fps'),
          height?: string(name='Height'),
          totalVideoFrame?: string(name='TotalVideoFrame'),
          width?: string(name='Width'),
        }(name='QueryMediaInfo'),
      }(name='FpCompareResult'),
      fpDBId?: string(name='FpDBId'),
      id?: string(name='Id'),
      masterFile?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='MasterFile'),
      matchFrameStorage?: {
        masterMediaFrames?: {
          bucket?: string(name='Bucket'),
          location?: string(name='Location'),
          object?: string(name='Object'),
        }(name='MasterMediaFrames'),
        matchedFramesDescFile?: {
          bucket?: string(name='Bucket'),
          location?: string(name='Location'),
          object?: string(name='Object'),
        }(name='MatchedFramesDescFile'),
        queryMediaFrames?: {
          bucket?: string(name='Bucket'),
          location?: string(name='Location'),
          object?: string(name='Object'),
        }(name='QueryMediaFrames'),
      }(name='MatchFrameStorage'),
      message?: string(name='Message'),
      pipelineId?: string(name='PipelineId'),
      queryFile?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='QueryFile'),
      state?: string(name='State'),
      userData?: string(name='UserData'),
    }
  ](name='FpCompareJob')
  }(name='FpCompareJobList'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
  requestId?: string(name='RequestId'),
}

model QueryFpCompareJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryFpCompareJobListResponseBody(name='body'),
}

async function queryFpCompareJobListWithOptions(request: QueryFpCompareJobListRequest, runtime: Util.RuntimeOptions): QueryFpCompareJobListResponse {
  Util.validateModel(request);
  var query = {};
  query["JobIds"] = request.jobIds;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryFpCompareJobList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryFpCompareJobList(request: QueryFpCompareJobListRequest): QueryFpCompareJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryFpCompareJobListWithOptions(request, runtime);
}

model QueryFpDBDeleteJobListRequest {
  jobIds?: string(name='JobIds'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryFpDBDeleteJobListResponseBody = {
  fpDBDeleteJobList?: {
    fpDBDeleteJob?: [ 
    {
      code?: string(name='Code'),
      creationTime?: string(name='CreationTime'),
      delType?: string(name='DelType'),
      finishTime?: string(name='FinishTime'),
      fpDBId?: string(name='FpDBId'),
      id?: string(name='Id'),
      message?: string(name='Message'),
      pipelineId?: string(name='PipelineId'),
      status?: string(name='Status'),
      userData?: string(name='UserData'),
    }
  ](name='FpDBDeleteJob')
  }(name='FpDBDeleteJobList'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
  requestId?: string(name='RequestId'),
}

model QueryFpDBDeleteJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryFpDBDeleteJobListResponseBody(name='body'),
}

async function queryFpDBDeleteJobListWithOptions(request: QueryFpDBDeleteJobListRequest, runtime: Util.RuntimeOptions): QueryFpDBDeleteJobListResponse {
  Util.validateModel(request);
  var query = {};
  query["JobIds"] = request.jobIds;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryFpDBDeleteJobList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryFpDBDeleteJobList(request: QueryFpDBDeleteJobListRequest): QueryFpDBDeleteJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryFpDBDeleteJobListWithOptions(request, runtime);
}

model QueryFpFileDeleteJobListRequest {
  jobIds?: string(name='JobIds'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryFpFileDeleteJobListResponseBody = {
  fpFileDeleteJobList?: {
    fpFileDeleteJob?: [ 
    {
      code?: string(name='Code'),
      creationTime?: string(name='CreationTime'),
      fileIds?: string(name='FileIds'),
      finishTime?: string(name='FinishTime'),
      fpDBId?: string(name='FpDBId'),
      id?: string(name='Id'),
      message?: string(name='Message'),
      pipelineId?: string(name='PipelineId'),
      status?: string(name='Status'),
      userData?: string(name='UserData'),
    }
  ](name='FpFileDeleteJob')
  }(name='FpFileDeleteJobList'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
  requestId?: string(name='RequestId'),
}

model QueryFpFileDeleteJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryFpFileDeleteJobListResponseBody(name='body'),
}

async function queryFpFileDeleteJobListWithOptions(request: QueryFpFileDeleteJobListRequest, runtime: Util.RuntimeOptions): QueryFpFileDeleteJobListResponse {
  Util.validateModel(request);
  var query = {};
  query["JobIds"] = request.jobIds;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryFpFileDeleteJobList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryFpFileDeleteJobList(request: QueryFpFileDeleteJobListRequest): QueryFpFileDeleteJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryFpFileDeleteJobListWithOptions(request, runtime);
}

model QueryFpImportResultRequest {
  endTime?: long(name='EndTime'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageIndex?: long(name='PageIndex'),
  pageSize?: long(name='PageSize'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startTime?: long(name='StartTime'),
}

model QueryFpImportResultResponseBody = {
  fpResultLogInfoList?: {
    fpResultLogInfo?: [ 
    {
      createTime?: long(name='CreateTime'),
      logEndTime?: long(name='LogEndTime'),
      logName?: string(name='LogName'),
      logPath?: string(name='LogPath'),
      logSize?: long(name='LogSize'),
      logStartTime?: long(name='LogStartTime'),
    }
  ](name='FpResultLogInfo')
  }(name='FpResultLogInfoList'),
  logCount?: long(name='LogCount'),
  pageInfo?: {
    pageIndex?: long(name='PageIndex'),
    pageSize?: long(name='PageSize'),
    total?: long(name='Total'),
  }(name='PageInfo'),
  requestId?: string(name='RequestId'),
}

model QueryFpImportResultResponse = {
  headers: map[string]string(name='headers'),
  body: QueryFpImportResultResponseBody(name='body'),
}

async function queryFpImportResultWithOptions(request: QueryFpImportResultRequest, runtime: Util.RuntimeOptions): QueryFpImportResultResponse {
  Util.validateModel(request);
  var query = {};
  query["EndTime"] = request.endTime;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PageIndex"] = request.pageIndex;
  query["PageSize"] = request.pageSize;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["StartTime"] = request.startTime;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryFpImportResult',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryFpImportResult(request: QueryFpImportResultRequest): QueryFpImportResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryFpImportResultWithOptions(request, runtime);
}

model QueryFpShotJobListRequest {
  endOfJobCreatedTimeRange?: string(name='EndOfJobCreatedTimeRange'),
  jobIds?: string(name='JobIds'),
  maximumPageSize?: long(name='MaximumPageSize'),
  nextPageToken?: string(name='NextPageToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  primaryKeyList?: string(name='PrimaryKeyList'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startOfJobCreatedTimeRange?: string(name='StartOfJobCreatedTimeRange'),
  state?: string(name='State'),
  userData?: string(name='UserData'),
}

model QueryFpShotJobListResponseBody = {
  fpShotJobList?: {
    fpShotJob?: [ 
    {
      code?: string(name='Code'),
      creationTime?: string(name='CreationTime'),
      fileId?: string(name='FileId'),
      finishTime?: string(name='FinishTime'),
      fpShotConfig?: {
        fpDBId?: string(name='FpDBId'),
        notary?: string(name='Notary'),
        primaryKey?: string(name='PrimaryKey'),
        saveType?: string(name='SaveType'),
      }(name='FpShotConfig'),
      fpShotResult?: {
        audioFpShots?: {
          fpShot?: [ 
          {
            fpShotSlices?: {
              fpShotSlice?: [ 
              {
                duplication?: {
                  duration?: string(name='Duration'),
                  start?: string(name='Start'),
                }(name='Duplication'),
                input?: {
                  duration?: string(name='Duration'),
                  start?: string(name='Start'),
                }(name='Input'),
                similarity?: string(name='Similarity'),
              }
            ](name='FpShotSlice')
            }(name='FpShotSlices'),
            primaryKey?: string(name='PrimaryKey'),
            similarity?: string(name='Similarity'),
          }
        ](name='FpShot')
        }(name='AudioFpShots'),
        fpShots?: {
          fpShot?: [ 
          {
            fpShotSlices?: {
              fpShotSlice?: [ 
              {
                duplication?: {
                  duration?: string(name='Duration'),
                  start?: string(name='Start'),
                }(name='Duplication'),
                input?: {
                  duration?: string(name='Duration'),
                  start?: string(name='Start'),
                }(name='Input'),
                similarity?: string(name='Similarity'),
              }
            ](name='FpShotSlice')
            }(name='FpShotSlices'),
            primaryKey?: string(name='PrimaryKey'),
            similarity?: string(name='Similarity'),
          }
        ](name='FpShot')
        }(name='FpShots'),
        textFpShots?: {
          textFpShot?: [ 
          {
            primaryKey?: string(name='PrimaryKey'),
            similarity?: string(name='Similarity'),
            textFpShotSlices?: {
              textFpShotSlice?: [ 
              {
                duplicationText?: string(name='DuplicationText'),
                inputFragment?: {
                  duration?: string(name='Duration'),
                  start?: string(name='Start'),
                }(name='InputFragment'),
                inputText?: string(name='InputText'),
                similarity?: string(name='Similarity'),
              }
            ](name='TextFpShotSlice')
            }(name='TextFpShotSlices'),
          }
        ](name='TextFpShot')
        }(name='TextFpShots'),
      }(name='FpShotResult'),
      id?: string(name='Id'),
      input?: string(name='Input'),
      inputFile?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='InputFile'),
      message?: string(name='Message'),
      pipelineId?: string(name='PipelineId'),
      state?: string(name='State'),
      transactionId?: string(name='TransactionId'),
      txHash?: string(name='TxHash'),
      userData?: string(name='UserData'),
    }
  ](name='FpShotJob')
  }(name='FpShotJobList'),
  nextPageToken?: string(name='NextPageToken'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
  nonExistPrimaryKeys?: {
    string?: [ string ](name='String')
  }(name='NonExistPrimaryKeys'),
  requestId?: string(name='RequestId'),
}

model QueryFpShotJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryFpShotJobListResponseBody(name='body'),
}

async function queryFpShotJobListWithOptions(request: QueryFpShotJobListRequest, runtime: Util.RuntimeOptions): QueryFpShotJobListResponse {
  Util.validateModel(request);
  var query = {};
  query["EndOfJobCreatedTimeRange"] = request.endOfJobCreatedTimeRange;
  query["JobIds"] = request.jobIds;
  query["MaximumPageSize"] = request.maximumPageSize;
  query["NextPageToken"] = request.nextPageToken;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PipelineId"] = request.pipelineId;
  query["PrimaryKeyList"] = request.primaryKeyList;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["StartOfJobCreatedTimeRange"] = request.startOfJobCreatedTimeRange;
  query["State"] = request.state;
  query["UserData"] = request.userData;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryFpShotJobList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryFpShotJobList(request: QueryFpShotJobListRequest): QueryFpShotJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryFpShotJobListWithOptions(request, runtime);
}

model QueryIProductionJobRequest {
  jobId?: string(name='JobId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryIProductionJobResponseBody = {
  functionName?: string(name='FunctionName'),
  input?: string(name='Input'),
  jobId?: string(name='JobId'),
  jobParams?: string(name='JobParams'),
  output?: string(name='Output'),
  pipelineId?: string(name='PipelineId'),
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
  state?: string(name='State'),
  userData?: string(name='UserData'),
}

model QueryIProductionJobResponse = {
  headers: map[string]string(name='headers'),
  body: QueryIProductionJobResponseBody(name='body'),
}

async function queryIProductionJobWithOptions(request: QueryIProductionJobRequest, runtime: Util.RuntimeOptions): QueryIProductionJobResponse {
  Util.validateModel(request);
  var query = {};
  query["JobId"] = request.jobId;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryIProductionJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryIProductionJob(request: QueryIProductionJobRequest): QueryIProductionJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryIProductionJobWithOptions(request, runtime);
}

model QueryIProductionJobListRequest {
  IProductionJobIds?: string(name='IProductionJobIds'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryIProductionJobListResponseBody = {
  jobs?: {
    string?: [ string ](name='String')
  }(name='Jobs'),
  nextPageToken?: string(name='NextPageToken'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
  requestId?: string(name='RequestId'),
}

model QueryIProductionJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryIProductionJobListResponseBody(name='body'),
}

async function queryIProductionJobListWithOptions(request: QueryIProductionJobListRequest, runtime: Util.RuntimeOptions): QueryIProductionJobListResponse {
  Util.validateModel(request);
  var query = {};
  query["IProductionJobIds"] = request.IProductionJobIds;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryIProductionJobList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryIProductionJobList(request: QueryIProductionJobListRequest): QueryIProductionJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryIProductionJobListWithOptions(request, runtime);
}

model QueryImageSearchJobListRequest {
  jobIds?: string(name='JobIds'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryImageSearchJobListResponseBody = {
  imageSearchJobList?: {
    imageSearchJob?: [ 
    {
      code?: string(name='Code'),
      creationTime?: string(name='CreationTime'),
      finishTime?: string(name='FinishTime'),
      id?: string(name='Id'),
      inputVideo?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='InputVideo'),
      message?: string(name='Message'),
      pipelineId?: string(name='PipelineId'),
      result?: {
        imageSearchShots?: {
          imageSearchShots?: [ 
          {
            matchedFrame?: string(name='MatchedFrame'),
            matchedTimestamp?: string(name='MatchedTimestamp'),
            similarity?: string(name='Similarity'),
          }
        ](name='ImageSearchShots')
        }(name='ImageSearchShots'),
      }(name='Result'),
      state?: string(name='State'),
      userData?: string(name='UserData'),
      inputImage?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='inputImage'),
    }
  ](name='ImageSearchJob')
  }(name='ImageSearchJobList'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
  requestId?: string(name='RequestId'),
}

model QueryImageSearchJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryImageSearchJobListResponseBody(name='body'),
}

async function queryImageSearchJobListWithOptions(request: QueryImageSearchJobListRequest, runtime: Util.RuntimeOptions): QueryImageSearchJobListResponse {
  Util.validateModel(request);
  var query = {};
  query["JobIds"] = request.jobIds;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryImageSearchJobList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryImageSearchJobList(request: QueryImageSearchJobListRequest): QueryImageSearchJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryImageSearchJobListWithOptions(request, runtime);
}

model QueryInferenceJobRequest {
  jobId?: string(name='JobId'),
}

model QueryInferenceJobResponseBody = {
  code?: string(name='Code'),
  job?: {
    jobId?: string(name='JobId'),
    jobParams?: string(name='JobParams'),
    jobTime?: long(name='JobTime'),
    message?: string(name='Message'),
    result?: string(name='Result'),
    status?: string(name='Status'),
    userId?: long(name='UserId'),
  }(name='Job'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model QueryInferenceJobResponse = {
  headers: map[string]string(name='headers'),
  body: QueryInferenceJobResponseBody(name='body'),
}

async function queryInferenceJobWithOptions(request: QueryInferenceJobRequest, runtime: Util.RuntimeOptions): QueryInferenceJobResponse {
  Util.validateModel(request);
  var query = {};
  query["JobId"] = request.jobId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryInferenceJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryInferenceJob(request: QueryInferenceJobRequest): QueryInferenceJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryInferenceJobWithOptions(request, runtime);
}

model QueryInferenceServerRequest {
  createTime?: long(name='CreateTime'),
  maxPageSize?: long(name='MaxPageSize'),
  modelType?: string(name='ModelType'),
  pageNumber?: long(name='PageNumber'),
}

model QueryInferenceServerResponseBody = {
  code?: string(name='Code'),
  functions?: [ 
    {
      createTime?: long(name='CreateTime'),
      functionName?: string(name='FunctionName'),
      modelPath?: string(name='ModelPath'),
      modelType?: string(name='ModelType'),
      pipelineId?: string(name='PipelineId'),
      testId?: string(name='TestId'),
      userId?: long(name='UserId'),
    }
  ](name='Functions'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  totalSize?: long(name='TotalSize'),
}

model QueryInferenceServerResponse = {
  headers: map[string]string(name='headers'),
  body: QueryInferenceServerResponseBody(name='body'),
}

async function queryInferenceServerWithOptions(request: QueryInferenceServerRequest, runtime: Util.RuntimeOptions): QueryInferenceServerResponse {
  Util.validateModel(request);
  var query = {};
  query["CreateTime"] = request.createTime;
  query["MaxPageSize"] = request.maxPageSize;
  query["ModelType"] = request.modelType;
  query["PageNumber"] = request.pageNumber;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryInferenceServer',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryInferenceServer(request: QueryInferenceServerRequest): QueryInferenceServerResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryInferenceServerWithOptions(request, runtime);
}

model QueryInnerJobRequest {
  jobId?: string(name='JobId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryInnerJobResponseBody = {
  image?: {
    result?: [ 
    {
      code?: string(name='Code'),
      index?: int32(name='Index'),
      result?: int32(name='Result'),
    }
  ](name='Result')
  }(name='Image'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
  suggestion?: string(name='Suggestion'),
  video?: {
    code?: string(name='Code'),
    index?: int32(name='Index'),
    result?: int32(name='Result'),
  }(name='Video'),
}

model QueryInnerJobResponse = {
  headers: map[string]string(name='headers'),
  body: QueryInnerJobResponseBody(name='body'),
}

async function queryInnerJobWithOptions(request: QueryInnerJobRequest, runtime: Util.RuntimeOptions): QueryInnerJobResponse {
  Util.validateModel(request);
  var query = {};
  query["JobId"] = request.jobId;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryInnerJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryInnerJob(request: QueryInnerJobRequest): QueryInnerJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryInnerJobWithOptions(request, runtime);
}

model QueryJobListRequest {
  jobIds?: string(name='JobIds'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryJobListResponseBody = {
  jobList?: {
    job?: [ 
    {
      code?: string(name='Code'),
      creationTime?: string(name='CreationTime'),
      finishTime?: string(name='FinishTime'),
      input?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='Input'),
      jobId?: string(name='JobId'),
      MNSMessageResult?: {
        errorCode?: string(name='ErrorCode'),
        errorMessage?: string(name='ErrorMessage'),
        messageId?: string(name='MessageId'),
      }(name='MNSMessageResult'),
      message?: string(name='Message'),
      output?: {
        audio?: {
          bitrate?: string(name='Bitrate'),
          channels?: string(name='Channels'),
          codec?: string(name='Codec'),
          profile?: string(name='Profile'),
          qscale?: string(name='Qscale'),
          samplerate?: string(name='Samplerate'),
          volume?: {
            level?: string(name='Level'),
            method?: string(name='Method'),
          }(name='Volume'),
        }(name='Audio'),
        audioStreamMap?: string(name='AudioStreamMap'),
        clip?: {
          timeSpan?: {
            duration?: string(name='Duration'),
            seek?: string(name='Seek'),
          }(name='TimeSpan'),
        }(name='Clip'),
        container?: {
          format?: string(name='Format'),
        }(name='Container'),
        deWatermark?: string(name='DeWatermark'),
        encryption?: {
          id?: string(name='Id'),
          key?: string(name='Key'),
          keyType?: string(name='KeyType'),
          keyUri?: string(name='KeyUri'),
          skipCnt?: string(name='SkipCnt'),
          type?: string(name='Type'),
        }(name='Encryption'),
        extendData?: string(name='ExtendData', description=''),
        m3U8NonStandardSupport?: {
          TS?: {
            md5Support?: boolean(name='Md5Support'),
            sizeSupport?: boolean(name='SizeSupport'),
          }(name='TS'),
        }(name='M3U8NonStandardSupport'),
        mergeConfigUrl?: string(name='MergeConfigUrl'),
        mergeList?: {
          merge?: [ 
          {
            duration?: string(name='Duration'),
            mergeURL?: string(name='MergeURL'),
            roleArn?: string(name='RoleArn'),
            start?: string(name='Start'),
          }
        ](name='Merge')
        }(name='MergeList'),
        muxConfig?: {
          gif?: {
            ditherMode?: string(name='DitherMode'),
            finalDelay?: string(name='FinalDelay'),
            isCustomPalette?: string(name='IsCustomPalette'),
            loop?: string(name='Loop'),
          }(name='Gif'),
          segment?: {
            duration?: string(name='Duration'),
          }(name='Segment'),
          webp?: {
            loop?: string(name='Loop'),
          }(name='Webp'),
        }(name='MuxConfig'),
        openingList?: {
          opening?: [ 
          {
            height?: string(name='Height'),
            start?: string(name='Start'),
            width?: string(name='Width'),
            openUrl?: string(name='openUrl'),
          }
        ](name='Opening')
        }(name='OpeningList'),
        outSubtitleList?: {
          outSubtitle?: [ 
          {
            map?: string(name='Map'),
            message?: string(name='Message'),
            outSubtitleFile?: {
              bucket?: string(name='Bucket'),
              location?: string(name='Location'),
              object?: string(name='Object'),
              roleArn?: string(name='RoleArn'),
            }(name='OutSubtitleFile'),
            success?: boolean(name='Success'),
          }
        ](name='OutSubtitle')
        }(name='OutSubtitleList'),
        outputFile?: {
          bucket?: string(name='Bucket'),
          location?: string(name='Location'),
          object?: string(name='Object'),
          roleArn?: string(name='RoleArn'),
        }(name='OutputFile'),
        priority?: string(name='Priority'),
        properties?: {
          bitrate?: string(name='Bitrate'),
          duration?: string(name='Duration'),
          fileFormat?: string(name='FileFormat'),
          fileSize?: string(name='FileSize'),
          format?: {
            bitrate?: string(name='Bitrate'),
            duration?: string(name='Duration'),
            formatLongName?: string(name='FormatLongName'),
            formatName?: string(name='FormatName'),
            numPrograms?: string(name='NumPrograms'),
            numStreams?: string(name='NumStreams'),
            size?: string(name='Size'),
            startTime?: string(name='StartTime'),
          }(name='Format'),
          fps?: string(name='Fps'),
          height?: string(name='Height'),
          sourceLogos?: {
            sourceLogo?: [ 
            {
              source?: string(name='Source'),
            }
          ](name='SourceLogo')
          }(name='SourceLogos'),
          streams?: {
            audioStreamList?: {
              audioStream?: [ 
              {
                bitrate?: string(name='Bitrate'),
                channelLayout?: string(name='ChannelLayout'),
                channels?: string(name='Channels'),
                codecLongName?: string(name='CodecLongName'),
                codecName?: string(name='CodecName'),
                codecTag?: string(name='CodecTag'),
                codecTagString?: string(name='CodecTagString'),
                codecTimeBase?: string(name='CodecTimeBase'),
                duration?: string(name='Duration'),
                index?: string(name='Index'),
                lang?: string(name='Lang'),
                numFrames?: string(name='NumFrames'),
                sampleFmt?: string(name='SampleFmt'),
                samplerate?: string(name='Samplerate'),
                startTime?: string(name='StartTime'),
                timebase?: string(name='Timebase'),
              }
            ](name='AudioStream')
            }(name='AudioStreamList'),
            subtitleStreamList?: {
              subtitleStream?: [ 
              {
                index?: string(name='Index'),
                lang?: string(name='Lang'),
              }
            ](name='SubtitleStream')
            }(name='SubtitleStreamList'),
            videoStreamList?: {
              videoStream?: [ 
              {
                avgFPS?: string(name='AvgFPS'),
                bitrate?: string(name='Bitrate'),
                codecLongName?: string(name='CodecLongName'),
                codecName?: string(name='CodecName'),
                codecTag?: string(name='CodecTag'),
                codecTagString?: string(name='CodecTagString'),
                codecTimeBase?: string(name='CodecTimeBase'),
                dar?: string(name='Dar'),
                duration?: string(name='Duration'),
                fps?: string(name='Fps'),
                hasBFrames?: string(name='HasBFrames'),
                height?: string(name='Height'),
                index?: string(name='Index'),
                lang?: string(name='Lang'),
                level?: string(name='Level'),
                networkCost?: {
                  avgBitrate?: string(name='AvgBitrate'),
                  costBandwidth?: string(name='CostBandwidth'),
                  preloadTime?: string(name='PreloadTime'),
                }(name='NetworkCost'),
                numFrames?: string(name='NumFrames'),
                pixFmt?: string(name='PixFmt'),
                profile?: string(name='Profile'),
                sar?: string(name='Sar'),
                startTime?: string(name='StartTime'),
                timebase?: string(name='Timebase'),
                width?: string(name='Width'),
              }
            ](name='VideoStream')
            }(name='VideoStreamList'),
          }(name='Streams'),
          width?: string(name='Width'),
        }(name='Properties'),
        rotate?: string(name='Rotate'),
        subtitleConfig?: {
          extSubtitleList?: {
            extSubtitle?: [ 
            {
              charEnc?: string(name='CharEnc'),
              fontName?: string(name='FontName'),
              input?: {
                bucket?: string(name='Bucket'),
                location?: string(name='Location'),
                object?: string(name='Object'),
              }(name='Input'),
            }
          ](name='ExtSubtitle')
          }(name='ExtSubtitleList'),
          subtitleList?: {
            subtitle?: [ 
            {
              map?: string(name='Map'),
            }
          ](name='Subtitle')
          }(name='SubtitleList'),
        }(name='SubtitleConfig'),
        superReso?: {
          isHalfSample?: string(name='IsHalfSample'),
        }(name='SuperReso'),
        tailSlateList?: {
          tailSlate?: [ 
          {
            bgColor?: string(name='BgColor'),
            blendDuration?: string(name='BlendDuration'),
            height?: string(name='Height'),
            isMergeAudio?: boolean(name='IsMergeAudio'),
            start?: string(name='Start'),
            tailUrl?: string(name='TailUrl'),
            width?: string(name='Width'),
          }
        ](name='TailSlate')
        }(name='TailSlateList'),
        templateId?: string(name='TemplateId'),
        transConfig?: {
          adjDarMethod?: string(name='AdjDarMethod'),
          isCheckAudioBitrate?: string(name='IsCheckAudioBitrate'),
          isCheckAudioBitrateFail?: string(name='IsCheckAudioBitrateFail'),
          isCheckReso?: string(name='IsCheckReso'),
          isCheckResoFail?: string(name='IsCheckResoFail'),
          isCheckVideoBitrate?: string(name='IsCheckVideoBitrate'),
          isCheckVideoBitrateFail?: string(name='IsCheckVideoBitrateFail'),
          transMode?: string(name='TransMode'),
        }(name='TransConfig'),
        userData?: string(name='UserData'),
        video?: {
          bitrate?: string(name='Bitrate'),
          bitrateBnd?: {
            max?: string(name='Max'),
            min?: string(name='Min'),
          }(name='BitrateBnd'),
          bufsize?: string(name='Bufsize'),
          codec?: string(name='Codec'),
          crf?: string(name='Crf'),
          crop?: string(name='Crop'),
          degrain?: string(name='Degrain'),
          fps?: string(name='Fps'),
          gop?: string(name='Gop'),
          height?: string(name='Height'),
          maxFps?: string(name='MaxFps'),
          maxrate?: string(name='Maxrate'),
          pad?: string(name='Pad'),
          pixFmt?: string(name='PixFmt'),
          preset?: string(name='Preset'),
          profile?: string(name='Profile'),
          qscale?: string(name='Qscale'),
          resoPriority?: string(name='ResoPriority'),
          scanMode?: string(name='ScanMode'),
          width?: string(name='Width'),
        }(name='Video'),
        videoStreamMap?: string(name='VideoStreamMap'),
        waterMarkConfigUrl?: string(name='WaterMarkConfigUrl'),
        waterMarkList?: {
          waterMark?: [ 
          {
            dx?: string(name='Dx'),
            dy?: string(name='Dy'),
            height?: string(name='Height'),
            inputFile?: {
              bucket?: string(name='Bucket'),
              location?: string(name='Location'),
              object?: string(name='Object'),
            }(name='InputFile'),
            referPos?: string(name='ReferPos'),
            type?: string(name='Type'),
            waterMarkTemplateId?: string(name='WaterMarkTemplateId'),
            width?: string(name='Width'),
          }
        ](name='WaterMark')
        }(name='WaterMarkList'),
      }(name='Output'),
      percent?: long(name='Percent'),
      pipelineId?: string(name='PipelineId'),
      state?: string(name='State'),
    }
  ](name='Job')
  }(name='JobList'),
  nonExistJobIds?: {
    string?: [ string ](name='String')
  }(name='NonExistJobIds'),
  requestId?: string(name='RequestId'),
}

model QueryJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryJobListResponseBody(name='body'),
}

async function queryJobListWithOptions(request: QueryJobListRequest, runtime: Util.RuntimeOptions): QueryJobListResponse {
  Util.validateModel(request);
  var query = {};
  query["JobIds"] = request.jobIds;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryJobList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryJobList(request: QueryJobListRequest): QueryJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryJobListWithOptions(request, runtime);
}

model QueryMCJobListRequest {
  endOfJobCreatedTimeRange?: string(name='EndOfJobCreatedTimeRange'),
  jobIds?: string(name='JobIds'),
  maximumPageSize?: long(name='MaximumPageSize'),
  nextPageToken?: string(name='NextPageToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startOfJobCreatedTimeRange?: string(name='StartOfJobCreatedTimeRange'),
  state?: string(name='State'),
}

model QueryMCJobListResponseBody = {
  jobList?: {
    job?: [ 
    {
      code?: string(name='Code'),
      creationTime?: string(name='CreationTime'),
      jobId?: string(name='JobId'),
      message?: string(name='Message'),
      pipelineId?: string(name='PipelineId'),
      result?: {
        abuseResult?: {
          abuseAudios?: {
            abuseAudio?: [ 
            {
              endTime?: string(name='EndTime'),
              object?: string(name='Object'),
              score?: string(name='Score'),
              startTime?: string(name='StartTime'),
              suggestion?: string(name='Suggestion'),
              text?: string(name='Text'),
            }
          ](name='AbuseAudio')
          }(name='AbuseAudios'),
          abuseOcrs?: {
            abuseOcr?: [ 
            {
              object?: string(name='Object'),
              score?: string(name='Score'),
              suggestion?: string(name='Suggestion'),
              text?: string(name='Text'),
              time?: string(name='Time'),
            }
          ](name='AbuseOcr')
          }(name='AbuseOcrs'),
          abuseTexts?: {
            abuseText?: [ 
            {
              score?: string(name='Score'),
              suggestion?: string(name='Suggestion'),
              text?: string(name='Text'),
            }
          ](name='AbuseText')
          }(name='AbuseTexts'),
        }(name='AbuseResult'),
        adResult?: {
          adAudios?: {
            adAudio?: [ 
            {
              endTime?: string(name='EndTime'),
              object?: string(name='Object'),
              score?: string(name='Score'),
              startTime?: string(name='StartTime'),
              suggestion?: string(name='Suggestion'),
              text?: string(name='Text'),
            }
          ](name='AdAudio')
          }(name='AdAudios'),
          adImages?: {
            adImage?: [ 
            {
              score?: string(name='Score'),
              suggestion?: string(name='Suggestion'),
              text?: string(name='Text'),
              url?: string(name='Url'),
            }
          ](name='AdImage')
          }(name='AdImages'),
          adOcrs?: {
            adOcr?: [ 
            {
              object?: string(name='Object'),
              score?: string(name='Score'),
              suggestion?: string(name='Suggestion'),
              text?: string(name='Text'),
              time?: string(name='Time'),
            }
          ](name='AdOcr')
          }(name='AdOcrs'),
          adTexts?: {
            adText?: [ 
            {
              score?: string(name='Score'),
              suggestion?: string(name='Suggestion'),
              text?: string(name='Text'),
            }
          ](name='AdText')
          }(name='AdTexts'),
          adVideos?: {
            adVideo?: [ 
            {
              object?: string(name='Object'),
              score?: string(name='Score'),
              suggestion?: string(name='Suggestion'),
              time?: string(name='Time'),
            }
          ](name='AdVideo')
          }(name='AdVideos'),
        }(name='AdResult'),
        contrabandResult?: {
          contrabandAudios?: {
            contrabandAudio?: [ 
            {
              endTime?: string(name='EndTime'),
              object?: string(name='Object'),
              score?: string(name='Score'),
              startTime?: string(name='StartTime'),
              suggestion?: string(name='Suggestion'),
              text?: string(name='Text'),
            }
          ](name='ContrabandAudio')
          }(name='ContrabandAudios'),
          contrabandOcrs?: {
            contrabandOcr?: [ 
            {
              object?: string(name='Object'),
              score?: string(name='Score'),
              suggestion?: string(name='Suggestion'),
              text?: string(name='Text'),
              time?: string(name='Time'),
            }
          ](name='ContrabandOcr')
          }(name='ContrabandOcrs'),
          contrabandTexts?: {
            contrabandText?: [ 
            {
              score?: string(name='Score'),
              suggestion?: string(name='Suggestion'),
              text?: string(name='Text'),
            }
          ](name='ContrabandText')
          }(name='ContrabandTexts'),
        }(name='ContrabandResult'),
        liveResult?: {
          liveImages?: {
            liveImage?: [ 
            {
              score?: string(name='Score'),
              suggestion?: string(name='Suggestion'),
              text?: string(name='Text'),
              url?: string(name='Url'),
            }
          ](name='LiveImage')
          }(name='LiveImages'),
          liveVideos?: {
            liveVideo?: [ 
            {
              object?: string(name='Object'),
              score?: string(name='Score'),
              suggestion?: string(name='Suggestion'),
              time?: string(name='Time'),
            }
          ](name='LiveVideo')
          }(name='LiveVideos'),
        }(name='LiveResult'),
        logoResult?: {
          logoImages?: {
            logoImage?: [ 
            {
              score?: string(name='Score'),
              suggestion?: string(name='Suggestion'),
              text?: string(name='Text'),
              url?: string(name='Url'),
            }
          ](name='LogoImage')
          }(name='LogoImages'),
          logoVideos?: {
            logoVideo?: [ 
            {
              object?: string(name='Object'),
              score?: string(name='Score'),
              suggestion?: string(name='Suggestion'),
              time?: string(name='Time'),
            }
          ](name='LogoVideo')
          }(name='LogoVideos'),
        }(name='LogoResult'),
        politicsResult?: {
          politicsAudios?: {
            politicsAudio?: [ 
            {
              endTime?: string(name='EndTime'),
              object?: string(name='Object'),
              score?: string(name='Score'),
              startTime?: string(name='StartTime'),
              suggestion?: string(name='Suggestion'),
              text?: string(name='Text'),
            }
          ](name='PoliticsAudio')
          }(name='PoliticsAudios'),
          politicsImages?: {
            politicsImage?: [ 
            {
              score?: string(name='Score'),
              suggestion?: string(name='Suggestion'),
              text?: string(name='Text'),
              url?: string(name='Url'),
            }
          ](name='PoliticsImage')
          }(name='PoliticsImages'),
          politicsOcrs?: {
            politicsOcr?: [ 
            {
              object?: string(name='Object'),
              score?: string(name='Score'),
              suggestion?: string(name='Suggestion'),
              text?: string(name='Text'),
              time?: string(name='Time'),
            }
          ](name='PoliticsOcr')
          }(name='PoliticsOcrs'),
          politicsTexts?: {
            politicsText?: [ 
            {
              score?: string(name='Score'),
              suggestion?: string(name='Suggestion'),
              text?: string(name='Text'),
            }
          ](name='PoliticsText')
          }(name='PoliticsTexts'),
          politicsVideos?: {
            politicsVideo?: [ 
            {
              object?: string(name='Object'),
              score?: string(name='Score'),
              suggestion?: string(name='Suggestion'),
              time?: string(name='Time'),
            }
          ](name='PoliticsVideo')
          }(name='PoliticsVideos'),
        }(name='PoliticsResult'),
        pornResult?: {
          pornAudios?: {
            pornAudio?: [ 
            {
              endTime?: string(name='EndTime'),
              object?: string(name='Object'),
              score?: string(name='Score'),
              startTime?: string(name='StartTime'),
              suggestion?: string(name='Suggestion'),
              text?: string(name='Text'),
            }
          ](name='PornAudio')
          }(name='PornAudios'),
          pornImages?: {
            pornImage?: [ 
            {
              score?: string(name='Score'),
              suggestion?: string(name='Suggestion'),
              text?: string(name='Text'),
              url?: string(name='Url'),
            }
          ](name='PornImage')
          }(name='PornImages'),
          pornOcrs?: {
            pornOcr?: [ 
            {
              object?: string(name='Object'),
              score?: string(name='Score'),
              suggestion?: string(name='Suggestion'),
              text?: string(name='Text'),
              time?: string(name='Time'),
            }
          ](name='PornOcr')
          }(name='PornOcrs'),
          pornTexts?: {
            pornText?: [ 
            {
              score?: string(name='Score'),
              suggestion?: string(name='Suggestion'),
              text?: string(name='Text'),
            }
          ](name='PornText')
          }(name='PornTexts'),
          pornVideos?: {
            pornVideo?: [ 
            {
              object?: string(name='Object'),
              score?: string(name='Score'),
              suggestion?: string(name='Suggestion'),
              time?: string(name='Time'),
            }
          ](name='PornVideo')
          }(name='PornVideos'),
        }(name='PornResult'),
        qrcodeResult?: {
          qrcodeImages?: {
            qrcodeImage?: [ 
            {
              score?: string(name='Score'),
              suggestion?: string(name='Suggestion'),
              text?: string(name='Text'),
              url?: string(name='Url'),
            }
          ](name='QrcodeImage')
          }(name='QrcodeImages'),
          qrcodeVideos?: {
            qrcodeVideo?: [ 
            {
              object?: string(name='Object'),
              score?: string(name='Score'),
              suggestion?: string(name='Suggestion'),
              time?: string(name='Time'),
            }
          ](name='QrcodeVideo')
          }(name='QrcodeVideos'),
        }(name='QrcodeResult'),
        score?: string(name='Score'),
        spamResult?: {
          spamAudios?: {
            spamAudio?: [ 
            {
              endTime?: string(name='EndTime'),
              object?: string(name='Object'),
              score?: string(name='Score'),
              startTime?: string(name='StartTime'),
              suggestion?: string(name='Suggestion'),
              text?: string(name='Text'),
            }
          ](name='SpamAudio')
          }(name='SpamAudios'),
          spamOcrs?: {
            spamOcr?: [ 
            {
              object?: string(name='Object'),
              score?: string(name='Score'),
              suggestion?: string(name='Suggestion'),
              text?: string(name='Text'),
              time?: string(name='Time'),
            }
          ](name='SpamOcr')
          }(name='SpamOcrs'),
          spamTexts?: {
            spamText?: [ 
            {
              score?: string(name='Score'),
              suggestion?: string(name='Suggestion'),
              text?: string(name='Text'),
            }
          ](name='SpamText')
          }(name='SpamTexts'),
        }(name='SpamResult'),
        suggestion?: string(name='Suggestion'),
        terrorismResult?: {
          terrorismAudios?: {
            terrorismAudio?: [ 
            {
              endTime?: string(name='EndTime'),
              object?: string(name='Object'),
              score?: string(name='Score'),
              startTime?: string(name='StartTime'),
              suggestion?: string(name='Suggestion'),
              text?: string(name='Text'),
            }
          ](name='TerrorismAudio')
          }(name='TerrorismAudios'),
          terrorismImages?: {
            terrorismImage?: [ 
            {
              score?: string(name='Score'),
              suggestion?: string(name='Suggestion'),
              text?: string(name='Text'),
              url?: string(name='Url'),
            }
          ](name='TerrorismImage')
          }(name='TerrorismImages'),
          terrorismOcrs?: {
            terrorismOcr?: [ 
            {
              object?: string(name='Object'),
              score?: string(name='Score'),
              suggestion?: string(name='Suggestion'),
              text?: string(name='Text'),
              time?: string(name='Time'),
            }
          ](name='TerrorismOcr')
          }(name='TerrorismOcrs'),
          terrorismTexts?: {
            terrorismText?: [ 
            {
              score?: string(name='Score'),
              suggestion?: string(name='Suggestion'),
              text?: string(name='Text'),
            }
          ](name='TerrorismText')
          }(name='TerrorismTexts'),
          terrorismVideos?: {
            terrorismVideo?: [ 
            {
              object?: string(name='Object'),
              score?: string(name='Score'),
              suggestion?: string(name='Suggestion'),
              time?: string(name='Time'),
            }
          ](name='TerrorismVideo')
          }(name='TerrorismVideos'),
        }(name='TerrorismResult'),
      }(name='Result'),
      resultOutputFile?: string(name='ResultOutputFile'),
      state?: string(name='State'),
      userData?: string(name='UserData'),
    }
  ](name='Job')
  }(name='JobList'),
  nextPageToken?: string(name='NextPageToken'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
  requestId?: string(name='RequestId'),
}

model QueryMCJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMCJobListResponseBody(name='body'),
}

async function queryMCJobListWithOptions(request: QueryMCJobListRequest, runtime: Util.RuntimeOptions): QueryMCJobListResponse {
  Util.validateModel(request);
  var query = {};
  query["EndOfJobCreatedTimeRange"] = request.endOfJobCreatedTimeRange;
  query["JobIds"] = request.jobIds;
  query["MaximumPageSize"] = request.maximumPageSize;
  query["NextPageToken"] = request.nextPageToken;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PipelineId"] = request.pipelineId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["StartOfJobCreatedTimeRange"] = request.startOfJobCreatedTimeRange;
  query["State"] = request.state;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryMCJobList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryMCJobList(request: QueryMCJobListRequest): QueryMCJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMCJobListWithOptions(request, runtime);
}

model QueryMCTemplateListRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  templateIds?: string(name='TemplateIds'),
}

model QueryMCTemplateListResponseBody = {
  nonExistTids?: {
    string?: [ string ](name='String')
  }(name='NonExistTids'),
  requestId?: string(name='RequestId'),
  templateList?: {
    template?: [ 
    {
      abuse?: string(name='Abuse'),
      ad?: string(name='Ad'),
      contraband?: string(name='Contraband'),
      live?: string(name='Live'),
      logo?: string(name='Logo'),
      name?: string(name='Name'),
      politics?: string(name='Politics'),
      porn?: string(name='Porn'),
      qrcode?: string(name='Qrcode'),
      spam?: string(name='Spam'),
      state?: string(name='State'),
      templateId?: string(name='TemplateId'),
      terrorism?: string(name='Terrorism'),
    }
  ](name='Template')
  }(name='TemplateList'),
}

model QueryMCTemplateListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMCTemplateListResponseBody(name='body'),
}

async function queryMCTemplateListWithOptions(request: QueryMCTemplateListRequest, runtime: Util.RuntimeOptions): QueryMCTemplateListResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["TemplateIds"] = request.templateIds;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryMCTemplateList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryMCTemplateList(request: QueryMCTemplateListRequest): QueryMCTemplateListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMCTemplateListWithOptions(request, runtime);
}

model QueryMcuJobRequest {
  jobIds?: string(name='JobIds'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryMcuJobResponseBody = {
  jobResult?: {
    job?: [ 
    {
      asrResult?: {
        asrTextList?: {
          asrText?: [ 
          {
            channelId?: string(name='ChannelId'),
            endTime?: string(name='EndTime'),
            speechRate?: string(name='SpeechRate'),
            startTime?: int32(name='StartTime'),
            text?: string(name='Text'),
          }
        ](name='AsrText')
        }(name='AsrTextList'),
        duration?: string(name='Duration'),
      }(name='AsrResult'),
      categoryResult?: {
        categories?: {
          category?: [ 
          {
            label?: string(name='Label'),
            score?: string(name='Score'),
          }
        ](name='Category')
        }(name='Categories'),
        details?: string(name='Details'),
      }(name='CategoryResult'),
      faceResult?: {
        face?: [ 
        {
          celebrities?: {
            celebrity?: [ 
            {
              name?: string(name='Name'),
              score?: string(name='Score'),
              target?: string(name='Target'),
            }
          ](name='Celebrity')
          }(name='Celebrities'),
          imageId?: string(name='ImageId'),
          imageUrl?: string(name='ImageUrl'),
          time?: string(name='Time'),
        }
      ](name='Face')
      }(name='FaceResult'),
      input?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='Input'),
      jobId?: string(name='JobId'),
      ocrResult?: {
        ocr?: [ 
        {
          imageId?: string(name='ImageId'),
          imageUrl?: string(name='ImageUrl'),
          ocrText?: string(name='OcrText'),
          time?: string(name='Time'),
        }
      ](name='Ocr')
      }(name='OcrResult'),
      subTaskInfo?: {
        subTask?: [ 
        {
          code?: string(name='Code'),
          message?: string(name='Message'),
          type?: string(name='Type'),
        }
      ](name='SubTask')
      }(name='SubTaskInfo'),
      tagResult?: {
        tag?: [ 
        {
          frameTagInfos?: {
            frameTagInfo?: [ 
            {
              category?: string(name='Category'),
              score?: string(name='Score'),
              tag?: string(name='Tag'),
            }
          ](name='FrameTagInfo')
          }(name='FrameTagInfos'),
          imageId?: string(name='ImageId'),
          imageUrl?: string(name='ImageUrl'),
          time?: string(name='Time'),
        }
      ](name='Tag')
      }(name='TagResult'),
      template?: string(name='Template'),
      templateId?: string(name='TemplateId'),
      userData?: string(name='UserData'),
    }
  ](name='Job')
  }(name='JobResult'),
  nonExistJobIds?: {
    string?: [ string ](name='String')
  }(name='NonExistJobIds'),
  requestId?: string(name='RequestId'),
}

model QueryMcuJobResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMcuJobResponseBody(name='body'),
}

async function queryMcuJobWithOptions(request: QueryMcuJobRequest, runtime: Util.RuntimeOptions): QueryMcuJobResponse {
  Util.validateModel(request);
  var query = {};
  query["JobIds"] = request.jobIds;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryMcuJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryMcuJob(request: QueryMcuJobRequest): QueryMcuJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMcuJobWithOptions(request, runtime);
}

model QueryMcuTemplateRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  templateId?: string(name='TemplateId'),
}

model QueryMcuTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  templates?: {
    job?: [ 
    {
      template?: string(name='Template'),
      templateId?: string(name='TemplateId'),
    }
  ](name='Job')
  }(name='Templates'),
}

model QueryMcuTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMcuTemplateResponseBody(name='body'),
}

async function queryMcuTemplateWithOptions(request: QueryMcuTemplateRequest, runtime: Util.RuntimeOptions): QueryMcuTemplateResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["TemplateId"] = request.templateId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryMcuTemplate',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryMcuTemplate(request: QueryMcuTemplateRequest): QueryMcuTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMcuTemplateWithOptions(request, runtime);
}

model QueryMediaCensorJobDetailRequest {
  jobId?: string(name='JobId'),
  maximumPageSize?: long(name='MaximumPageSize'),
  nextPageToken?: string(name='NextPageToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryMediaCensorJobDetailResponseBody = {
  mediaCensorJobDetail?: {
    barrageCensorResult?: {
      label?: string(name='Label'),
      rate?: string(name='Rate'),
      scene?: string(name='Scene'),
      suggestion?: string(name='Suggestion'),
    }(name='BarrageCensorResult'),
    code?: string(name='Code'),
    coverImageCensorResults?: {
      coverImageCensorResult?: [ 
      {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
        results?: {
          result?: [ 
          {
            label?: string(name='Label'),
            rate?: string(name='Rate'),
            scene?: string(name='Scene'),
            suggestion?: string(name='Suggestion'),
          }
        ](name='Result')
        }(name='Results'),
      }
    ](name='CoverImageCensorResult')
    }(name='CoverImageCensorResults'),
    creationTime?: string(name='CreationTime'),
    descCensorResult?: {
      label?: string(name='Label'),
      rate?: string(name='Rate'),
      scene?: string(name='Scene'),
      suggestion?: string(name='Suggestion'),
    }(name='DescCensorResult'),
    finishTime?: string(name='FinishTime'),
    input?: {
      bucket?: string(name='Bucket'),
      location?: string(name='Location'),
      object?: string(name='Object'),
    }(name='Input'),
    jobId?: string(name='JobId'),
    message?: string(name='Message'),
    pipelineId?: string(name='PipelineId'),
    state?: string(name='State'),
    suggestion?: string(name='Suggestion'),
    titleCensorResult?: {
      label?: string(name='Label'),
      rate?: string(name='Rate'),
      scene?: string(name='Scene'),
      suggestion?: string(name='Suggestion'),
    }(name='TitleCensorResult'),
    userData?: string(name='UserData'),
    vensorCensorResult?: {
      censorResults?: {
        censorResult?: [ 
        {
          label?: string(name='Label'),
          rate?: string(name='Rate'),
          scene?: string(name='Scene'),
          suggestion?: string(name='Suggestion'),
        }
      ](name='CensorResult')
      }(name='CensorResults'),
      nextPageToken?: string(name='NextPageToken'),
      videoTimelines?: {
        videoTimeline?: [ 
        {
          censorResults?: {
            censorResult?: [ 
            {
              label?: string(name='Label'),
              rate?: string(name='Rate'),
              scene?: string(name='Scene'),
              suggestion?: string(name='Suggestion'),
            }
          ](name='CensorResult')
          }(name='CensorResults'),
          object?: string(name='Object'),
          timestamp?: string(name='Timestamp'),
        }
      ](name='VideoTimeline')
      }(name='VideoTimelines'),
    }(name='VensorCensorResult'),
    videoCensorConfig?: {
      bizType?: string(name='BizType'),
      outputFile?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='OutputFile'),
      videoCensor?: string(name='VideoCensor'),
    }(name='VideoCensorConfig'),
  }(name='MediaCensorJobDetail'),
  requestId?: string(name='RequestId'),
}

model QueryMediaCensorJobDetailResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMediaCensorJobDetailResponseBody(name='body'),
}

async function queryMediaCensorJobDetailWithOptions(request: QueryMediaCensorJobDetailRequest, runtime: Util.RuntimeOptions): QueryMediaCensorJobDetailResponse {
  Util.validateModel(request);
  var query = {};
  query["JobId"] = request.jobId;
  query["MaximumPageSize"] = request.maximumPageSize;
  query["NextPageToken"] = request.nextPageToken;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryMediaCensorJobDetail',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryMediaCensorJobDetail(request: QueryMediaCensorJobDetailRequest): QueryMediaCensorJobDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMediaCensorJobDetailWithOptions(request, runtime);
}

model QueryMediaCensorJobListRequest {
  endOfJobCreatedTimeRange?: string(name='EndOfJobCreatedTimeRange'),
  jobId?: string(name='JobId'),
  maximumPageSize?: long(name='MaximumPageSize'),
  nextPageToken?: string(name='NextPageToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startOfJobCreatedTimeRange?: string(name='StartOfJobCreatedTimeRange'),
  state?: string(name='State'),
}

model QueryMediaCensorJobListResponseBody = {
  mediaCensorJobList?: {
    mediaCensorJob?: [ 
    {
      barrageCensorResult?: {
        label?: string(name='Label'),
        rate?: string(name='Rate'),
        scene?: string(name='Scene'),
        suggestion?: string(name='Suggestion'),
      }(name='BarrageCensorResult'),
      code?: string(name='Code'),
      coverImageCensorResults?: {
        coverImageCensorResult?: [ 
        {
          bucket?: string(name='Bucket'),
          location?: string(name='Location'),
          object?: string(name='Object'),
          results?: {
            result?: [ 
            {
              label?: string(name='Label'),
              rate?: string(name='Rate'),
              scene?: string(name='Scene'),
              suggestion?: string(name='Suggestion'),
            }
          ](name='Result')
          }(name='Results'),
        }
      ](name='CoverImageCensorResult')
      }(name='CoverImageCensorResults'),
      creationTime?: string(name='CreationTime'),
      descCensorResult?: {
        label?: string(name='Label'),
        rate?: string(name='Rate'),
        scene?: string(name='Scene'),
        suggestion?: string(name='Suggestion'),
      }(name='DescCensorResult'),
      finishTime?: string(name='FinishTime'),
      input?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='Input'),
      jobId?: string(name='JobId'),
      message?: string(name='Message'),
      pipelineId?: string(name='PipelineId'),
      state?: string(name='State'),
      suggestion?: string(name='Suggestion'),
      titleCensorResult?: {
        label?: string(name='Label'),
        rate?: string(name='Rate'),
        scene?: string(name='Scene'),
        suggestion?: string(name='Suggestion'),
      }(name='TitleCensorResult'),
      userData?: string(name='UserData'),
      vensorCensorResult?: {
        censorResults?: {
          censorResult?: [ 
          {
            label?: string(name='Label'),
            rate?: string(name='Rate'),
            scene?: string(name='Scene'),
            suggestion?: string(name='Suggestion'),
          }
        ](name='CensorResult')
        }(name='CensorResults'),
        nextPageToken?: string(name='NextPageToken'),
        videoTimelines?: {
          videoTimeline?: [ 
          {
            censorResults?: {
              censorResult?: [ 
              {
                label?: string(name='Label'),
                rate?: string(name='Rate'),
                scene?: string(name='Scene'),
                suggestion?: string(name='Suggestion'),
              }
            ](name='CensorResult')
            }(name='CensorResults'),
            object?: string(name='Object'),
            timestamp?: string(name='Timestamp'),
          }
        ](name='VideoTimeline')
        }(name='VideoTimelines'),
      }(name='VensorCensorResult'),
      videoCensorConfig?: {
        bizType?: string(name='BizType'),
        outputFile?: {
          bucket?: string(name='Bucket'),
          location?: string(name='Location'),
          object?: string(name='Object'),
        }(name='OutputFile'),
        videoCensor?: string(name='VideoCensor'),
      }(name='VideoCensorConfig'),
    }
  ](name='MediaCensorJob')
  }(name='MediaCensorJobList'),
  nextPageToken?: string(name='NextPageToken'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
  requestId?: string(name='RequestId'),
}

model QueryMediaCensorJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMediaCensorJobListResponseBody(name='body'),
}

async function queryMediaCensorJobListWithOptions(request: QueryMediaCensorJobListRequest, runtime: Util.RuntimeOptions): QueryMediaCensorJobListResponse {
  Util.validateModel(request);
  var query = {};
  query["EndOfJobCreatedTimeRange"] = request.endOfJobCreatedTimeRange;
  query["JobId"] = request.jobId;
  query["MaximumPageSize"] = request.maximumPageSize;
  query["NextPageToken"] = request.nextPageToken;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PipelineId"] = request.pipelineId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["StartOfJobCreatedTimeRange"] = request.startOfJobCreatedTimeRange;
  query["State"] = request.state;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryMediaCensorJobList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryMediaCensorJobList(request: QueryMediaCensorJobListRequest): QueryMediaCensorJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMediaCensorJobListWithOptions(request, runtime);
}

model QueryMediaDetailJobListRequest {
  jobIds?: string(name='JobIds'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryMediaDetailJobListResponseBody = {
  jobList?: {
    job?: [ 
    {
      code?: string(name='Code'),
      creationTime?: string(name='CreationTime'),
      id?: string(name='Id'),
      input?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='Input'),
      mediaDetailConfig?: {
        detailType?: string(name='DetailType'),
        outputFile?: {
          bucket?: string(name='Bucket'),
          location?: string(name='Location'),
          object?: string(name='Object'),
        }(name='OutputFile'),
        scenario?: string(name='Scenario'),
      }(name='MediaDetailConfig'),
      mediaDetailResult?: {
        mediaDetailRecgResults?: {
          mediaDetailRecgResult?: [ 
          {
            celebrities?: {
              celebrity?: [ 
              {
                name?: string(name='Name'),
                score?: string(name='Score'),
                target?: string(name='Target'),
              }
            ](name='Celebrity')
            }(name='Celebrities'),
            customs?: {
              custom?: [ 
              {
                clips?: {
                  clip?: [ 
                  {
                    avgScore?: string(name='AvgScore'),
                    endTarget?: string(name='EndTarget'),
                    endTime?: string(name='EndTime'),
                    maxScore?: string(name='MaxScore'),
                    minScore?: string(name='MinScore'),
                    startTarget?: string(name='StartTarget'),
                    startTime?: string(name='StartTime'),
                  }
                ](name='Clip')
                }(name='Clips'),
                name?: string(name='Name'),
              }
            ](name='Custom')
            }(name='Customs'),
            frameTagInfos?: {
              frameTagInfo?: [ 
              {
                category?: string(name='Category'),
                score?: string(name='Score'),
                tag?: string(name='Tag'),
              }
            ](name='FrameTagInfo')
            }(name='FrameTagInfos'),
            frameTags?: {
              string?: [ string ](name='String')
            }(name='FrameTags'),
            imageUrl?: string(name='ImageUrl'),
            ocrText?: string(name='OcrText'),
            politicians?: {
              politician?: [ 
              {
                name?: string(name='Name'),
                score?: string(name='Score'),
                target?: string(name='Target'),
              }
            ](name='Politician')
            }(name='Politicians'),
            sensitives?: {
              sensitive?: [ 
              {
                name?: string(name='Name'),
                score?: string(name='Score'),
                target?: string(name='Target'),
              }
            ](name='Sensitive')
            }(name='Sensitives'),
            time?: string(name='Time'),
          }
        ](name='MediaDetailRecgResult')
        }(name='MediaDetailRecgResults'),
        status?: string(name='Status'),
        tags?: {
          string?: [ string ](name='String')
        }(name='Tags'),
      }(name='MediaDetailResult'),
      message?: string(name='Message'),
      pipelineId?: string(name='PipelineId'),
      state?: string(name='State'),
      userData?: string(name='UserData'),
    }
  ](name='Job')
  }(name='JobList'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
  requestId?: string(name='RequestId'),
}

model QueryMediaDetailJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMediaDetailJobListResponseBody(name='body'),
}

async function queryMediaDetailJobListWithOptions(request: QueryMediaDetailJobListRequest, runtime: Util.RuntimeOptions): QueryMediaDetailJobListResponse {
  Util.validateModel(request);
  var query = {};
  query["JobIds"] = request.jobIds;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryMediaDetailJobList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryMediaDetailJobList(request: QueryMediaDetailJobListRequest): QueryMediaDetailJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMediaDetailJobListWithOptions(request, runtime);
}

model QueryMediaFpDeleteJobListRequest {
  jobIds?: string(name='JobIds'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryMediaFpDeleteJobListResponseBody = {
  mediaFpDeleteJobList?: {
    mediaFpDeleteJob?: [ 
    {
      code?: string(name='Code'),
      creationTime?: string(name='CreationTime'),
      finishTime?: string(name='FinishTime'),
      fpDBId?: string(name='FpDBId'),
      id?: string(name='Id'),
      message?: string(name='Message'),
      pipelineId?: string(name='PipelineId'),
      primaryKey?: string(name='PrimaryKey'),
      state?: string(name='State'),
      userData?: string(name='UserData'),
    }
  ](name='MediaFpDeleteJob')
  }(name='MediaFpDeleteJobList'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
  requestId?: string(name='RequestId'),
}

model QueryMediaFpDeleteJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMediaFpDeleteJobListResponseBody(name='body'),
}

async function queryMediaFpDeleteJobListWithOptions(request: QueryMediaFpDeleteJobListRequest, runtime: Util.RuntimeOptions): QueryMediaFpDeleteJobListResponse {
  Util.validateModel(request);
  var query = {};
  query["JobIds"] = request.jobIds;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryMediaFpDeleteJobList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryMediaFpDeleteJobList(request: QueryMediaFpDeleteJobListRequest): QueryMediaFpDeleteJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMediaFpDeleteJobListWithOptions(request, runtime);
}

model QueryMediaInfoJobListRequest {
  mediaInfoJobIds?: string(name='MediaInfoJobIds'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryMediaInfoJobListResponseBody = {
  mediaInfoJobList?: {
    mediaInfoJob?: [ 
    {
      async?: boolean(name='Async'),
      code?: string(name='Code'),
      creationTime?: string(name='CreationTime'),
      input?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='Input'),
      jobId?: string(name='JobId'),
      MNSMessageResult?: {
        errorCode?: string(name='ErrorCode'),
        errorMessage?: string(name='ErrorMessage'),
        messageId?: string(name='MessageId'),
      }(name='MNSMessageResult'),
      message?: string(name='Message'),
      pipelineId?: string(name='PipelineId'),
      properties?: {
        bitrate?: string(name='Bitrate'),
        duration?: string(name='Duration'),
        fileFormat?: string(name='FileFormat'),
        fileSize?: string(name='FileSize'),
        format?: {
          bitrate?: string(name='Bitrate'),
          duration?: string(name='Duration'),
          formatLongName?: string(name='FormatLongName'),
          formatName?: string(name='FormatName'),
          numPrograms?: string(name='NumPrograms'),
          numStreams?: string(name='NumStreams'),
          size?: string(name='Size'),
          startTime?: string(name='StartTime'),
        }(name='Format'),
        fps?: string(name='Fps'),
        height?: string(name='Height'),
        streams?: {
          audioStreamList?: {
            audioStream?: [ 
            {
              bitrate?: string(name='Bitrate'),
              channelLayout?: string(name='ChannelLayout'),
              channels?: string(name='Channels'),
              codecLongName?: string(name='CodecLongName'),
              codecName?: string(name='CodecName'),
              codecTag?: string(name='CodecTag'),
              codecTagString?: string(name='CodecTagString'),
              codecTimeBase?: string(name='CodecTimeBase'),
              duration?: string(name='Duration'),
              index?: string(name='Index'),
              lang?: string(name='Lang'),
              numFrames?: string(name='NumFrames'),
              sampleFmt?: string(name='SampleFmt'),
              samplerate?: string(name='Samplerate'),
              startTime?: string(name='StartTime'),
              timebase?: string(name='Timebase'),
            }
          ](name='AudioStream')
          }(name='AudioStreamList'),
          subtitleStreamList?: {
            subtitleStream?: [ 
            {
              codecLongName?: string(name='CodecLongName'),
              codecName?: string(name='CodecName'),
              codecTag?: string(name='CodecTag'),
              codecTagString?: string(name='CodecTagString'),
              codecTimeBase?: string(name='CodecTimeBase'),
              duration?: string(name='Duration'),
              index?: string(name='Index'),
              lang?: string(name='Lang'),
              startTime?: string(name='StartTime'),
              timebase?: string(name='Timebase'),
            }
          ](name='SubtitleStream')
          }(name='SubtitleStreamList'),
          videoStreamList?: {
            videoStream?: [ 
            {
              avgFPS?: string(name='AvgFPS'),
              bitrate?: string(name='Bitrate'),
              codecLongName?: string(name='CodecLongName'),
              codecName?: string(name='CodecName'),
              codecTag?: string(name='CodecTag'),
              codecTagString?: string(name='CodecTagString'),
              codecTimeBase?: string(name='CodecTimeBase'),
              colorPrimaries?: string(name='ColorPrimaries'),
              colorRange?: string(name='ColorRange'),
              colorTransfer?: string(name='ColorTransfer'),
              dar?: string(name='Dar'),
              duration?: string(name='Duration'),
              fps?: string(name='Fps'),
              hasBFrames?: string(name='HasBFrames'),
              height?: string(name='Height'),
              index?: string(name='Index'),
              lang?: string(name='Lang'),
              level?: string(name='Level'),
              networkCost?: {
                avgBitrate?: string(name='AvgBitrate'),
                costBandwidth?: string(name='CostBandwidth'),
                preloadTime?: string(name='PreloadTime'),
              }(name='NetworkCost'),
              numFrames?: string(name='NumFrames'),
              pixFmt?: string(name='PixFmt'),
              profile?: string(name='Profile'),
              rotate?: string(name='Rotate'),
              sar?: string(name='Sar'),
              startTime?: string(name='StartTime'),
              timebase?: string(name='Timebase'),
              width?: string(name='Width'),
            }
          ](name='VideoStream')
          }(name='VideoStreamList'),
        }(name='Streams'),
        width?: string(name='Width'),
      }(name='Properties'),
      state?: string(name='State'),
      userData?: string(name='UserData'),
    }
  ](name='MediaInfoJob')
  }(name='MediaInfoJobList'),
  nonExistMediaInfoJobIds?: {
    string?: [ string ](name='String')
  }(name='NonExistMediaInfoJobIds'),
  requestId?: string(name='RequestId'),
}

model QueryMediaInfoJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMediaInfoJobListResponseBody(name='body'),
}

async function queryMediaInfoJobListWithOptions(request: QueryMediaInfoJobListRequest, runtime: Util.RuntimeOptions): QueryMediaInfoJobListResponse {
  Util.validateModel(request);
  var query = {};
  query["MediaInfoJobIds"] = request.mediaInfoJobIds;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryMediaInfoJobList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryMediaInfoJobList(request: QueryMediaInfoJobListRequest): QueryMediaInfoJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMediaInfoJobListWithOptions(request, runtime);
}

model QueryMediaListRequest {
  includeMediaInfo?: boolean(name='IncludeMediaInfo'),
  includePlayList?: boolean(name='IncludePlayList'),
  includeSnapshotList?: boolean(name='IncludeSnapshotList'),
  includeSummaryList?: boolean(name='IncludeSummaryList'),
  mediaIds?: string(name='MediaIds'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryMediaListResponseBody = {
  mediaList?: {
    media?: [ 
    {
      bitrate?: string(name='Bitrate'),
      cateId?: long(name='CateId'),
      censorState?: string(name='CensorState'),
      coverURL?: string(name='CoverURL'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      duration?: string(name='Duration'),
      file?: {
        state?: string(name='State'),
        URL?: string(name='URL'),
      }(name='File'),
      format?: string(name='Format'),
      fps?: string(name='Fps'),
      height?: string(name='Height'),
      mediaId?: string(name='MediaId'),
      mediaInfo?: {
        format?: {
          bitrate?: string(name='Bitrate'),
          duration?: string(name='Duration'),
          formatLongName?: string(name='FormatLongName'),
          formatName?: string(name='FormatName'),
          numPrograms?: string(name='NumPrograms'),
          numStreams?: string(name='NumStreams'),
          size?: string(name='Size'),
          startTime?: string(name='StartTime'),
        }(name='Format'),
        streams?: {
          audioStreamList?: {
            audioStream?: [ 
            {
              bitrate?: string(name='Bitrate'),
              channelLayout?: string(name='ChannelLayout'),
              channels?: string(name='Channels'),
              codecLongName?: string(name='CodecLongName'),
              codecName?: string(name='CodecName'),
              codecTag?: string(name='CodecTag'),
              codecTagString?: string(name='CodecTagString'),
              codecTimeBase?: string(name='CodecTimeBase'),
              duration?: string(name='Duration'),
              index?: string(name='Index'),
              lang?: string(name='Lang'),
              numFrames?: string(name='NumFrames'),
              sampleFmt?: string(name='SampleFmt'),
              samplerate?: string(name='Samplerate'),
              startTime?: string(name='StartTime'),
              timebase?: string(name='Timebase'),
            }
          ](name='AudioStream')
          }(name='AudioStreamList'),
          subtitleStreamList?: {
            subtitleStream?: [ 
            {
              index?: string(name='Index'),
              lang?: string(name='Lang'),
            }
          ](name='SubtitleStream')
          }(name='SubtitleStreamList'),
          videoStreamList?: {
            videoStream?: [ 
            {
              avgFPS?: string(name='AvgFPS'),
              bitrate?: string(name='Bitrate'),
              codecLongName?: string(name='CodecLongName'),
              codecName?: string(name='CodecName'),
              codecTag?: string(name='CodecTag'),
              codecTagString?: string(name='CodecTagString'),
              codecTimeBase?: string(name='CodecTimeBase'),
              dar?: string(name='Dar'),
              duration?: string(name='Duration'),
              fps?: string(name='Fps'),
              hasBFrames?: string(name='HasBFrames'),
              height?: string(name='Height'),
              index?: string(name='Index'),
              lang?: string(name='Lang'),
              level?: string(name='Level'),
              networkCost?: {
                avgBitrate?: string(name='AvgBitrate'),
                costBandwidth?: string(name='CostBandwidth'),
                preloadTime?: string(name='PreloadTime'),
              }(name='NetworkCost'),
              numFrames?: string(name='NumFrames'),
              pixFmt?: string(name='PixFmt'),
              profile?: string(name='Profile'),
              rotate?: string(name='Rotate'),
              sar?: string(name='Sar'),
              startTime?: string(name='StartTime'),
              timebase?: string(name='Timebase'),
              width?: string(name='Width'),
            }
          ](name='VideoStream')
          }(name='VideoStreamList'),
        }(name='Streams'),
      }(name='MediaInfo'),
      playList?: {
        play?: [ 
        {
          activityName?: string(name='ActivityName'),
          bitrate?: string(name='Bitrate'),
          duration?: string(name='Duration'),
          encryption?: string(name='Encryption'),
          file?: {
            state?: string(name='State'),
            URL?: string(name='URL'),
          }(name='File'),
          format?: string(name='Format'),
          fps?: string(name='Fps'),
          height?: string(name='Height'),
          mediaWorkflowId?: string(name='MediaWorkflowId'),
          mediaWorkflowName?: string(name='MediaWorkflowName'),
          size?: string(name='Size'),
          width?: string(name='Width'),
        }
      ](name='Play')
      }(name='PlayList'),
      publishState?: string(name='PublishState'),
      runIdList?: {
        runId?: [ string ](name='RunId')
      }(name='RunIdList'),
      size?: string(name='Size'),
      snapshotList?: {
        snapshot?: [ 
        {
          activityName?: string(name='ActivityName'),
          count?: string(name='Count'),
          file?: {
            state?: string(name='State'),
            URL?: string(name='URL'),
          }(name='File'),
          mediaWorkflowId?: string(name='MediaWorkflowId'),
          mediaWorkflowName?: string(name='MediaWorkflowName'),
          type?: string(name='Type'),
        }
      ](name='Snapshot')
      }(name='SnapshotList'),
      summaryList?: {
        summary?: [ 
        {
          activityName?: string(name='ActivityName'),
          file?: {
            state?: string(name='State'),
            URL?: string(name='URL'),
          }(name='File'),
          mediaWorkflowId?: string(name='MediaWorkflowId'),
          mediaWorkflowName?: string(name='MediaWorkflowName'),
          type?: string(name='Type'),
        }
      ](name='Summary')
      }(name='SummaryList'),
      tags?: {
        tag?: [ string ](name='Tag')
      }(name='Tags'),
      title?: string(name='Title'),
      width?: string(name='Width'),
    }
  ](name='Media')
  }(name='MediaList'),
  nonExistMediaIds?: {
    mediaId?: [ string ](name='MediaId')
  }(name='NonExistMediaIds'),
  requestId?: string(name='RequestId'),
}

model QueryMediaListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMediaListResponseBody(name='body'),
}

async function queryMediaListWithOptions(request: QueryMediaListRequest, runtime: Util.RuntimeOptions): QueryMediaListResponse {
  Util.validateModel(request);
  var query = {};
  query["IncludeMediaInfo"] = request.includeMediaInfo;
  query["IncludePlayList"] = request.includePlayList;
  query["IncludeSnapshotList"] = request.includeSnapshotList;
  query["IncludeSummaryList"] = request.includeSummaryList;
  query["MediaIds"] = request.mediaIds;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryMediaList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryMediaList(request: QueryMediaListRequest): QueryMediaListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMediaListWithOptions(request, runtime);
}

model QueryMediaListByURLRequest {
  fileURLs?: string(name='FileURLs'),
  includeMediaInfo?: boolean(name='IncludeMediaInfo'),
  includePlayList?: boolean(name='IncludePlayList'),
  includeSnapshotList?: boolean(name='IncludeSnapshotList'),
  includeSummaryList?: boolean(name='IncludeSummaryList'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryMediaListByURLResponseBody = {
  mediaList?: {
    media?: [ 
    {
      bitrate?: string(name='Bitrate'),
      cateId?: long(name='CateId'),
      censorState?: string(name='CensorState'),
      coverURL?: string(name='CoverURL'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      duration?: string(name='Duration'),
      file?: {
        state?: string(name='State'),
        URL?: string(name='URL'),
      }(name='File'),
      format?: string(name='Format'),
      fps?: string(name='Fps'),
      height?: string(name='Height'),
      mediaId?: string(name='MediaId'),
      mediaInfo?: {
        format?: {
          bitrate?: string(name='Bitrate'),
          duration?: string(name='Duration'),
          formatLongName?: string(name='FormatLongName'),
          formatName?: string(name='FormatName'),
          numPrograms?: string(name='NumPrograms'),
          numStreams?: string(name='NumStreams'),
          size?: string(name='Size'),
          startTime?: string(name='StartTime'),
        }(name='Format'),
        streams?: {
          audioStreamList?: {
            audioStream?: [ 
            {
              bitrate?: string(name='Bitrate'),
              channelLayout?: string(name='ChannelLayout'),
              channels?: string(name='Channels'),
              codecLongName?: string(name='CodecLongName'),
              codecName?: string(name='CodecName'),
              codecTag?: string(name='CodecTag'),
              codecTagString?: string(name='CodecTagString'),
              codecTimeBase?: string(name='CodecTimeBase'),
              duration?: string(name='Duration'),
              index?: string(name='Index'),
              lang?: string(name='Lang'),
              numFrames?: string(name='NumFrames'),
              sampleFmt?: string(name='SampleFmt'),
              samplerate?: string(name='Samplerate'),
              startTime?: string(name='StartTime'),
              timebase?: string(name='Timebase'),
            }
          ](name='AudioStream')
          }(name='AudioStreamList'),
          subtitleStreamList?: {
            subtitleStream?: [ 
            {
              index?: string(name='Index'),
              lang?: string(name='Lang'),
            }
          ](name='SubtitleStream')
          }(name='SubtitleStreamList'),
          videoStreamList?: {
            videoStream?: [ 
            {
              avgFPS?: string(name='AvgFPS'),
              bitrate?: string(name='Bitrate'),
              codecLongName?: string(name='CodecLongName'),
              codecName?: string(name='CodecName'),
              codecTag?: string(name='CodecTag'),
              codecTagString?: string(name='CodecTagString'),
              codecTimeBase?: string(name='CodecTimeBase'),
              dar?: string(name='Dar'),
              duration?: string(name='Duration'),
              fps?: string(name='Fps'),
              hasBFrames?: string(name='HasBFrames'),
              height?: string(name='Height'),
              index?: string(name='Index'),
              lang?: string(name='Lang'),
              level?: string(name='Level'),
              networkCost?: {
                avgBitrate?: string(name='AvgBitrate'),
                costBandwidth?: string(name='CostBandwidth'),
                preloadTime?: string(name='PreloadTime'),
              }(name='NetworkCost'),
              numFrames?: string(name='NumFrames'),
              pixFmt?: string(name='PixFmt'),
              profile?: string(name='Profile'),
              rotate?: string(name='Rotate'),
              sar?: string(name='Sar'),
              startTime?: string(name='StartTime'),
              timebase?: string(name='Timebase'),
              width?: string(name='Width'),
            }
          ](name='VideoStream')
          }(name='VideoStreamList'),
        }(name='Streams'),
      }(name='MediaInfo'),
      playList?: {
        play?: [ 
        {
          activityName?: string(name='ActivityName'),
          bitrate?: string(name='Bitrate'),
          duration?: string(name='Duration'),
          encryption?: string(name='Encryption'),
          file?: {
            state?: string(name='State'),
            URL?: string(name='URL'),
          }(name='File'),
          format?: string(name='Format'),
          fps?: string(name='Fps'),
          height?: string(name='Height'),
          mediaWorkflowId?: string(name='MediaWorkflowId'),
          mediaWorkflowName?: string(name='MediaWorkflowName'),
          size?: string(name='Size'),
          width?: string(name='Width'),
        }
      ](name='Play')
      }(name='PlayList'),
      publishState?: string(name='PublishState'),
      runIdList?: {
        runId?: [ string ](name='RunId')
      }(name='RunIdList'),
      size?: string(name='Size'),
      snapshotList?: {
        snapshot?: [ 
        {
          activityName?: string(name='ActivityName'),
          count?: string(name='Count'),
          file?: {
            state?: string(name='State'),
            URL?: string(name='URL'),
          }(name='File'),
          mediaWorkflowId?: string(name='MediaWorkflowId'),
          mediaWorkflowName?: string(name='MediaWorkflowName'),
          type?: string(name='Type'),
        }
      ](name='Snapshot')
      }(name='SnapshotList'),
      summaryList?: {
        summary?: [ 
        {
          activityName?: string(name='ActivityName'),
          file?: {
            state?: string(name='State'),
            URL?: string(name='URL'),
          }(name='File'),
          mediaWorkflowId?: string(name='MediaWorkflowId'),
          mediaWorkflowName?: string(name='MediaWorkflowName'),
          type?: string(name='Type'),
        }
      ](name='Summary')
      }(name='SummaryList'),
      tags?: {
        tag?: [ string ](name='Tag')
      }(name='Tags'),
      title?: string(name='Title'),
      width?: string(name='Width'),
    }
  ](name='Media')
  }(name='MediaList'),
  nonExistFileURLs?: {
    fileURL?: [ string ](name='FileURL')
  }(name='NonExistFileURLs'),
  requestId?: string(name='RequestId'),
}

model QueryMediaListByURLResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMediaListByURLResponseBody(name='body'),
}

async function queryMediaListByURLWithOptions(request: QueryMediaListByURLRequest, runtime: Util.RuntimeOptions): QueryMediaListByURLResponse {
  Util.validateModel(request);
  var query = {};
  query["FileURLs"] = request.fileURLs;
  query["IncludeMediaInfo"] = request.includeMediaInfo;
  query["IncludePlayList"] = request.includePlayList;
  query["IncludeSnapshotList"] = request.includeSnapshotList;
  query["IncludeSummaryList"] = request.includeSummaryList;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryMediaListByURL',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryMediaListByURL(request: QueryMediaListByURLRequest): QueryMediaListByURLResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMediaListByURLWithOptions(request, runtime);
}

model QueryMediaWorkflowExecutionListRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  runIds?: string(name='RunIds'),
}

model QueryMediaWorkflowExecutionListResponseBody = {
  mediaWorkflowExecutionList?: {
    mediaWorkflowExecution?: [ 
    {
      activityList?: {
        activity?: [ 
        {
          code?: string(name='Code'),
          endTime?: string(name='EndTime'),
          jobId?: string(name='JobId'),
          MNSMessageResult?: {
            errorCode?: string(name='ErrorCode'),
            errorMessage?: string(name='ErrorMessage'),
            messageId?: string(name='MessageId'),
          }(name='MNSMessageResult'),
          message?: string(name='Message'),
          name?: string(name='Name'),
          startTime?: string(name='StartTime'),
          state?: string(name='State'),
          type?: string(name='Type'),
        }
      ](name='Activity')
      }(name='ActivityList'),
      creationTime?: string(name='CreationTime'),
      input?: {
        inputFile?: {
          bucket?: string(name='Bucket'),
          location?: string(name='Location'),
          object?: string(name='Object'),
        }(name='InputFile'),
        userData?: string(name='UserData'),
      }(name='Input'),
      mediaId?: string(name='MediaId'),
      mediaWorkflowId?: string(name='MediaWorkflowId'),
      name?: string(name='Name'),
      runId?: string(name='RunId'),
      state?: string(name='State'),
    }
  ](name='MediaWorkflowExecution')
  }(name='MediaWorkflowExecutionList'),
  nonExistRunIds?: {
    runId?: [ string ](name='RunId')
  }(name='NonExistRunIds'),
  requestId?: string(name='RequestId'),
}

model QueryMediaWorkflowExecutionListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMediaWorkflowExecutionListResponseBody(name='body'),
}

async function queryMediaWorkflowExecutionListWithOptions(request: QueryMediaWorkflowExecutionListRequest, runtime: Util.RuntimeOptions): QueryMediaWorkflowExecutionListResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RunIds"] = request.runIds;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryMediaWorkflowExecutionList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryMediaWorkflowExecutionList(request: QueryMediaWorkflowExecutionListRequest): QueryMediaWorkflowExecutionListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMediaWorkflowExecutionListWithOptions(request, runtime);
}

model QueryMediaWorkflowListRequest {
  mediaWorkflowIds?: string(name='MediaWorkflowIds'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryMediaWorkflowListResponseBody = {
  mediaWorkflowList?: {
    mediaWorkflow?: [ 
    {
      creationTime?: string(name='CreationTime'),
      mediaWorkflowId?: string(name='MediaWorkflowId'),
      name?: string(name='Name'),
      state?: string(name='State'),
      topology?: string(name='Topology'),
      triggerMode?: string(name='TriggerMode'),
    }
  ](name='MediaWorkflow')
  }(name='MediaWorkflowList'),
  nonExistMediaWorkflowIds?: {
    mediaWorkflowId?: [ string ](name='MediaWorkflowId')
  }(name='NonExistMediaWorkflowIds'),
  requestId?: string(name='RequestId'),
}

model QueryMediaWorkflowListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMediaWorkflowListResponseBody(name='body'),
}

async function queryMediaWorkflowListWithOptions(request: QueryMediaWorkflowListRequest, runtime: Util.RuntimeOptions): QueryMediaWorkflowListResponse {
  Util.validateModel(request);
  var query = {};
  query["MediaWorkflowIds"] = request.mediaWorkflowIds;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryMediaWorkflowList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryMediaWorkflowList(request: QueryMediaWorkflowListRequest): QueryMediaWorkflowListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMediaWorkflowListWithOptions(request, runtime);
}

model QueryPipelineListRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineIds?: string(name='PipelineIds'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryPipelineListResponseBody = {
  nonExistPids?: {
    string?: [ string ](name='String')
  }(name='NonExistPids'),
  pipelineList?: {
    pipeline?: [ 
    {
      id?: string(name='Id'),
      name?: string(name='Name'),
      notifyConfig?: {
        mqTag?: string(name='MqTag'),
        mqTopic?: string(name='MqTopic'),
        queueName?: string(name='QueueName'),
        topic?: string(name='Topic'),
      }(name='NotifyConfig'),
      quotaAllocate?: long(name='QuotaAllocate'),
      role?: string(name='Role'),
      speed?: string(name='Speed'),
      speedLevel?: long(name='SpeedLevel'),
      state?: string(name='State'),
    }
  ](name='Pipeline')
  }(name='PipelineList'),
  requestId?: string(name='RequestId'),
}

model QueryPipelineListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryPipelineListResponseBody(name='body'),
}

async function queryPipelineListWithOptions(request: QueryPipelineListRequest, runtime: Util.RuntimeOptions): QueryPipelineListResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PipelineIds"] = request.pipelineIds;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryPipelineList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryPipelineList(request: QueryPipelineListRequest): QueryPipelineListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryPipelineListWithOptions(request, runtime);
}

model QueryPornJobListRequest {
  jobIds?: string(name='JobIds'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryPornJobListResponseBody = {
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
  pornJobList?: {
    pornJob?: [ 
    {
      censorPornResult?: {
        averageScore?: string(name='AverageScore'),
        label?: string(name='Label'),
        maxScore?: string(name='MaxScore'),
        pornCounterList?: {
          counter?: [ 
          {
            count?: int32(name='Count'),
            label?: string(name='Label'),
          }
        ](name='Counter')
        }(name='PornCounterList'),
        pornTopList?: {
          top?: [ 
          {
            index?: string(name='Index'),
            label?: string(name='Label'),
            object?: string(name='Object'),
            score?: string(name='Score'),
            timestamp?: string(name='Timestamp'),
          }
        ](name='Top')
        }(name='PornTopList'),
        suggestion?: string(name='Suggestion'),
      }(name='CensorPornResult'),
      code?: string(name='Code'),
      creationTime?: string(name='CreationTime'),
      id?: string(name='Id'),
      input?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='Input'),
      message?: string(name='Message'),
      pipelineId?: string(name='PipelineId'),
      pornConfig?: {
        bizType?: string(name='BizType'),
        interval?: string(name='Interval'),
        outputFile?: {
          bucket?: string(name='Bucket'),
          location?: string(name='Location'),
          object?: string(name='Object'),
        }(name='OutputFile'),
      }(name='PornConfig'),
      state?: string(name='State'),
      userData?: string(name='UserData'),
    }
  ](name='PornJob')
  }(name='PornJobList'),
  requestId?: string(name='RequestId'),
}

model QueryPornJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryPornJobListResponseBody(name='body'),
}

async function queryPornJobListWithOptions(request: QueryPornJobListRequest, runtime: Util.RuntimeOptions): QueryPornJobListResponse {
  Util.validateModel(request);
  var query = {};
  query["JobIds"] = request.jobIds;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryPornJobList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryPornJobList(request: QueryPornJobListRequest): QueryPornJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryPornJobListWithOptions(request, runtime);
}

model QueryPornPipelineListRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineIds?: string(name='PipelineIds'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryPornPipelineListResponseBody = {
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
  pipelineList?: {
    pipeline?: [ 
    {
      id?: string(name='Id'),
      name?: string(name='Name'),
      notifyConfig?: {
        queue?: string(name='Queue'),
        topic?: string(name='Topic'),
      }(name='NotifyConfig'),
      priority?: string(name='Priority'),
      state?: string(name='State'),
    }
  ](name='Pipeline')
  }(name='PipelineList'),
  requestId?: string(name='RequestId'),
}

model QueryPornPipelineListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryPornPipelineListResponseBody(name='body'),
}

async function queryPornPipelineListWithOptions(request: QueryPornPipelineListRequest, runtime: Util.RuntimeOptions): QueryPornPipelineListResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PipelineIds"] = request.pipelineIds;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryPornPipelineList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryPornPipelineList(request: QueryPornPipelineListRequest): QueryPornPipelineListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryPornPipelineListWithOptions(request, runtime);
}

model QuerySmarttagJobRequest {
  jobId?: string(name='JobId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  params?: string(name='Params'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QuerySmarttagJobResponseBody = {
  jobStatus?: string(name='JobStatus'),
  requestId?: string(name='RequestId'),
  results?: {
    result?: [ 
    {
      data?: string(name='Data'),
      type?: string(name='Type'),
    }
  ](name='Result')
  }(name='Results'),
  userData?: string(name='UserData'),
}

model QuerySmarttagJobResponse = {
  headers: map[string]string(name='headers'),
  body: QuerySmarttagJobResponseBody(name='body'),
}

async function querySmarttagJobWithOptions(request: QuerySmarttagJobRequest, runtime: Util.RuntimeOptions): QuerySmarttagJobResponse {
  Util.validateModel(request);
  var query = {};
  query["JobId"] = request.jobId;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["Params"] = request.params;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QuerySmarttagJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function querySmarttagJob(request: QuerySmarttagJobRequest): QuerySmarttagJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySmarttagJobWithOptions(request, runtime);
}

model QuerySmarttagJobListRequest {
  endOfJobCreatedTimeRange?: string(name='EndOfJobCreatedTimeRange'),
  jobIds?: string(name='JobIds'),
  maximumPageSize?: long(name='MaximumPageSize'),
  nextPageToken?: string(name='NextPageToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startOfJobCreatedTimeRange?: string(name='StartOfJobCreatedTimeRange'),
}

model QuerySmarttagJobListResponseBody = {
  nextPageToken?: string(name='NextPageToken'),
  nonExistJobIds?: {
    string?: [ string ](name='String')
  }(name='NonExistJobIds'),
  requestId?: string(name='RequestId'),
  smarttagJobs?: {
    smarttagJob?: [ 
    {
      creationTime?: string(name='CreationTime'),
      finishTime?: string(name='FinishTime'),
      input?: string(name='Input'),
      jobId?: string(name='JobId'),
      pipelineId?: string(name='PipelineId'),
      status?: string(name='Status'),
      templateId?: string(name='TemplateId'),
    }
  ](name='SmarttagJob')
  }(name='SmarttagJobs'),
}

model QuerySmarttagJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QuerySmarttagJobListResponseBody(name='body'),
}

async function querySmarttagJobListWithOptions(request: QuerySmarttagJobListRequest, runtime: Util.RuntimeOptions): QuerySmarttagJobListResponse {
  Util.validateModel(request);
  var query = {};
  query["EndOfJobCreatedTimeRange"] = request.endOfJobCreatedTimeRange;
  query["JobIds"] = request.jobIds;
  query["MaximumPageSize"] = request.maximumPageSize;
  query["NextPageToken"] = request.nextPageToken;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PipelineId"] = request.pipelineId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["StartOfJobCreatedTimeRange"] = request.startOfJobCreatedTimeRange;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QuerySmarttagJobList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function querySmarttagJobList(request: QuerySmarttagJobListRequest): QuerySmarttagJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySmarttagJobListWithOptions(request, runtime);
}

model QuerySmarttagTemplateListRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  templateId?: string(name='TemplateId'),
}

model QuerySmarttagTemplateListResponseBody = {
  requestId?: string(name='RequestId'),
  templates?: {
    template?: [ 
    {
      analyseTypes?: string(name='AnalyseTypes'),
      faceCategoryIds?: string(name='FaceCategoryIds'),
      industry?: string(name='Industry'),
      isDefault?: boolean(name='IsDefault'),
      keywordConfig?: string(name='KeywordConfig'),
      knowledgeConfig?: string(name='KnowledgeConfig'),
      labelType?: string(name='LabelType'),
      labelVersion?: string(name='LabelVersion'),
      scene?: string(name='Scene'),
      templateId?: string(name='TemplateId'),
      templateName?: string(name='TemplateName'),
    }
  ](name='Template')
  }(name='Templates'),
}

model QuerySmarttagTemplateListResponse = {
  headers: map[string]string(name='headers'),
  body: QuerySmarttagTemplateListResponseBody(name='body'),
}

async function querySmarttagTemplateListWithOptions(request: QuerySmarttagTemplateListRequest, runtime: Util.RuntimeOptions): QuerySmarttagTemplateListResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["TemplateId"] = request.templateId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QuerySmarttagTemplateList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function querySmarttagTemplateList(request: QuerySmarttagTemplateListRequest): QuerySmarttagTemplateListResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySmarttagTemplateListWithOptions(request, runtime);
}

model QuerySnapshotJobListRequest {
  endOfJobCreatedTimeRange?: string(name='EndOfJobCreatedTimeRange'),
  maximumPageSize?: long(name='MaximumPageSize'),
  nextPageToken?: string(name='NextPageToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  snapshotJobIds?: string(name='SnapshotJobIds'),
  startOfJobCreatedTimeRange?: string(name='StartOfJobCreatedTimeRange'),
  state?: string(name='State'),
}

model QuerySnapshotJobListResponseBody = {
  nextPageToken?: string(name='NextPageToken'),
  nonExistSnapshotJobIds?: {
    string?: [ string ](name='String')
  }(name='NonExistSnapshotJobIds'),
  requestId?: string(name='RequestId'),
  snapshotJobList?: {
    snapshotJob?: [ 
    {
      code?: string(name='Code'),
      count?: string(name='Count'),
      creationTime?: string(name='CreationTime'),
      id?: string(name='Id'),
      input?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
        roleArn?: string(name='RoleArn'),
      }(name='Input'),
      MNSMessageResult?: {
        errorCode?: string(name='ErrorCode'),
        errorMessage?: string(name='ErrorMessage'),
        messageId?: string(name='MessageId'),
      }(name='MNSMessageResult'),
      message?: string(name='Message'),
      pipelineId?: string(name='PipelineId'),
      snapshotConfig?: {
        frameType?: string(name='FrameType'),
        height?: string(name='Height'),
        interval?: string(name='Interval'),
        num?: string(name='Num'),
        outputFile?: {
          bucket?: string(name='Bucket'),
          location?: string(name='Location'),
          object?: string(name='Object'),
          roleArn?: string(name='RoleArn'),
        }(name='OutputFile'),
        tileOut?: {
          cellHeight?: string(name='CellHeight'),
          cellSelStep?: string(name='CellSelStep'),
          cellWidth?: string(name='CellWidth'),
          color?: string(name='Color'),
          columns?: string(name='Columns'),
          isKeepCellPic?: string(name='IsKeepCellPic'),
          lines?: string(name='Lines'),
          margin?: string(name='Margin'),
          padding?: string(name='Padding'),
        }(name='TileOut'),
        tileOutputFile?: {
          bucket?: string(name='Bucket'),
          location?: string(name='Location'),
          object?: string(name='Object'),
          roleArn?: string(name='RoleArn'),
        }(name='TileOutputFile'),
        time?: string(name='Time'),
        width?: string(name='Width'),
      }(name='SnapshotConfig'),
      state?: string(name='State'),
      tileCount?: string(name='TileCount'),
      userData?: string(name='UserData'),
    }
  ](name='SnapshotJob')
  }(name='SnapshotJobList'),
}

model QuerySnapshotJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QuerySnapshotJobListResponseBody(name='body'),
}

async function querySnapshotJobListWithOptions(request: QuerySnapshotJobListRequest, runtime: Util.RuntimeOptions): QuerySnapshotJobListResponse {
  Util.validateModel(request);
  var query = {};
  query["EndOfJobCreatedTimeRange"] = request.endOfJobCreatedTimeRange;
  query["MaximumPageSize"] = request.maximumPageSize;
  query["NextPageToken"] = request.nextPageToken;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PipelineId"] = request.pipelineId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["SnapshotJobIds"] = request.snapshotJobIds;
  query["StartOfJobCreatedTimeRange"] = request.startOfJobCreatedTimeRange;
  query["State"] = request.state;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QuerySnapshotJobList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function querySnapshotJobList(request: QuerySnapshotJobListRequest): QuerySnapshotJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySnapshotJobListWithOptions(request, runtime);
}

model QuerySubtitleJobListRequest {
  jobIds?: string(name='JobIds'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QuerySubtitleJobListResponseBody = {
  jobList?: {
    job?: [ 
    {
      inputConfig?: string(name='InputConfig'),
      jobId?: string(name='JobId'),
      MNSMessageResult?: {
        errorCode?: string(name='ErrorCode'),
        errorMessage?: string(name='ErrorMessage'),
        messageId?: string(name='MessageId'),
      }(name='MNSMessageResult'),
      outputConfig?: string(name='OutputConfig'),
      state?: string(name='State'),
      userData?: string(name='UserData'),
    }
  ](name='Job')
  }(name='JobList'),
  nonExistJobIds?: {
    string?: [ string ](name='String')
  }(name='NonExistJobIds'),
  requestId?: string(name='RequestId'),
}

model QuerySubtitleJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QuerySubtitleJobListResponseBody(name='body'),
}

async function querySubtitleJobListWithOptions(request: QuerySubtitleJobListRequest, runtime: Util.RuntimeOptions): QuerySubtitleJobListResponse {
  Util.validateModel(request);
  var query = {};
  query["JobIds"] = request.jobIds;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QuerySubtitleJobList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function querySubtitleJobList(request: QuerySubtitleJobListRequest): QuerySubtitleJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySubtitleJobListWithOptions(request, runtime);
}

model QueryTagJobListRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  tagJobIds?: string(name='TagJobIds'),
}

model QueryTagJobListResponseBody = {
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
  requestId?: string(name='RequestId'),
  tagJobList?: {
    tagJob?: [ 
    {
      code?: string(name='Code'),
      creationTime?: string(name='CreationTime'),
      id?: string(name='Id'),
      input?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='Input'),
      message?: string(name='Message'),
      pipelineId?: string(name='PipelineId'),
      state?: string(name='State'),
      userData?: string(name='UserData'),
      videoTagResult?: {
        details?: string(name='Details'),
        tagAnResults?: {
          tagAnResult?: [ 
          {
            label?: string(name='Label'),
            score?: string(name='Score'),
          }
        ](name='TagAnResult')
        }(name='TagAnResults'),
        tagFrResults?: {
          tagFrResult?: [ 
          {
            tagFaces?: {
              tagFace?: [ 
              {
                name?: string(name='Name'),
                score?: string(name='Score'),
                target?: string(name='Target'),
              }
            ](name='TagFace')
            }(name='TagFaces'),
            time?: string(name='Time'),
          }
        ](name='TagFrResult')
        }(name='TagFrResults'),
      }(name='VideoTagResult'),
    }
  ](name='TagJob')
  }(name='TagJobList'),
}

model QueryTagJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryTagJobListResponseBody(name='body'),
}

async function queryTagJobListWithOptions(request: QueryTagJobListRequest, runtime: Util.RuntimeOptions): QueryTagJobListResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["TagJobIds"] = request.tagJobIds;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryTagJobList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTagJobList(request: QueryTagJobListRequest): QueryTagJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTagJobListWithOptions(request, runtime);
}

model QueryTemplateListRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  templateIds?: string(name='TemplateIds'),
}

model QueryTemplateListResponseBody = {
  nonExistTids?: {
    string?: [ string ](name='String')
  }(name='NonExistTids'),
  requestId?: string(name='RequestId'),
  templateList?: {
    template?: [ 
    {
      audio?: {
        bitrate?: string(name='Bitrate'),
        channels?: string(name='Channels'),
        codec?: string(name='Codec'),
        profile?: string(name='Profile'),
        qscale?: string(name='Qscale'),
        remove?: string(name='Remove'),
        samplerate?: string(name='Samplerate'),
      }(name='Audio'),
      container?: {
        format?: string(name='Format'),
      }(name='Container'),
      id?: string(name='Id'),
      muxConfig?: {
        gif?: {
          ditherMode?: string(name='DitherMode'),
          finalDelay?: string(name='FinalDelay'),
          isCustomPalette?: string(name='IsCustomPalette'),
          loop?: string(name='Loop'),
        }(name='Gif'),
        segment?: {
          duration?: string(name='Duration'),
        }(name='Segment'),
        webp?: {
          loop?: string(name='Loop'),
        }(name='Webp'),
      }(name='MuxConfig'),
      name?: string(name='Name'),
      state?: string(name='State'),
      transConfig?: {
        adjDarMethod?: string(name='AdjDarMethod'),
        isCheckAudioBitrate?: string(name='IsCheckAudioBitrate'),
        isCheckAudioBitrateFail?: string(name='IsCheckAudioBitrateFail'),
        isCheckReso?: string(name='IsCheckReso'),
        isCheckResoFail?: string(name='IsCheckResoFail'),
        isCheckVideoBitrate?: string(name='IsCheckVideoBitrate'),
        isCheckVideoBitrateFail?: string(name='IsCheckVideoBitrateFail'),
        transMode?: string(name='TransMode'),
      }(name='TransConfig'),
      video?: {
        bitrate?: string(name='Bitrate'),
        bitrateBnd?: {
          max?: string(name='Max'),
          min?: string(name='Min'),
        }(name='BitrateBnd'),
        bufsize?: string(name='Bufsize'),
        codec?: string(name='Codec'),
        crf?: string(name='Crf'),
        crop?: string(name='Crop'),
        degrain?: string(name='Degrain'),
        fps?: string(name='Fps'),
        gop?: string(name='Gop'),
        height?: string(name='Height'),
        longShortMode?: string(name='LongShortMode'),
        maxFps?: string(name='MaxFps'),
        maxrate?: string(name='Maxrate'),
        pad?: string(name='Pad'),
        pixFmt?: string(name='PixFmt'),
        preset?: string(name='Preset'),
        profile?: string(name='Profile'),
        qscale?: string(name='Qscale'),
        remove?: string(name='Remove'),
        resoPriority?: string(name='ResoPriority'),
        scanMode?: string(name='ScanMode'),
        width?: string(name='Width'),
      }(name='Video'),
    }
  ](name='Template')
  }(name='TemplateList'),
}

model QueryTemplateListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryTemplateListResponseBody(name='body'),
}

async function queryTemplateListWithOptions(request: QueryTemplateListRequest, runtime: Util.RuntimeOptions): QueryTemplateListResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["TemplateIds"] = request.templateIds;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryTemplateList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTemplateList(request: QueryTemplateListRequest): QueryTemplateListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTemplateListWithOptions(request, runtime);
}

model QueryTerrorismJobListRequest {
  jobIds?: string(name='JobIds'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryTerrorismJobListResponseBody = {
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
  requestId?: string(name='RequestId'),
  terrorismJobList?: {
    terrorismJob?: [ 
    {
      censorTerrorismResult?: {
        averageScore?: string(name='AverageScore'),
        label?: string(name='Label'),
        maxScore?: string(name='MaxScore'),
        suggestion?: string(name='Suggestion'),
        terrorismCounterList?: {
          counter?: [ 
          {
            count?: int32(name='Count'),
            label?: string(name='Label'),
          }
        ](name='Counter')
        }(name='TerrorismCounterList'),
        terrorismTopList?: {
          top?: [ 
          {
            index?: string(name='Index'),
            label?: string(name='Label'),
            object?: string(name='Object'),
            score?: string(name='Score'),
            timestamp?: string(name='Timestamp'),
          }
        ](name='Top')
        }(name='TerrorismTopList'),
      }(name='CensorTerrorismResult'),
      code?: string(name='Code'),
      creationTime?: string(name='CreationTime'),
      id?: string(name='Id'),
      input?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='Input'),
      message?: string(name='Message'),
      pipelineId?: string(name='PipelineId'),
      state?: string(name='State'),
      terrorismConfig?: {
        bizType?: string(name='BizType'),
        interval?: string(name='Interval'),
        outputFile?: {
          bucket?: string(name='Bucket'),
          location?: string(name='Location'),
          object?: string(name='Object'),
        }(name='OutputFile'),
      }(name='TerrorismConfig'),
      userData?: string(name='UserData'),
    }
  ](name='TerrorismJob')
  }(name='TerrorismJobList'),
}

model QueryTerrorismJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryTerrorismJobListResponseBody(name='body'),
}

async function queryTerrorismJobListWithOptions(request: QueryTerrorismJobListRequest, runtime: Util.RuntimeOptions): QueryTerrorismJobListResponse {
  Util.validateModel(request);
  var query = {};
  query["JobIds"] = request.jobIds;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryTerrorismJobList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTerrorismJobList(request: QueryTerrorismJobListRequest): QueryTerrorismJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTerrorismJobListWithOptions(request, runtime);
}

model QueryTerrorismPipelineListRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineIds?: string(name='PipelineIds'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryTerrorismPipelineListResponseBody = {
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
  pipelineList?: {
    pipeline?: [ 
    {
      id?: string(name='Id'),
      name?: string(name='Name'),
      notifyConfig?: {
        queue?: string(name='Queue'),
        topic?: string(name='Topic'),
      }(name='NotifyConfig'),
      priority?: string(name='Priority'),
      state?: string(name='State'),
    }
  ](name='Pipeline')
  }(name='PipelineList'),
  requestId?: string(name='RequestId'),
}

model QueryTerrorismPipelineListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryTerrorismPipelineListResponseBody(name='body'),
}

async function queryTerrorismPipelineListWithOptions(request: QueryTerrorismPipelineListRequest, runtime: Util.RuntimeOptions): QueryTerrorismPipelineListResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PipelineIds"] = request.pipelineIds;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryTerrorismPipelineList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTerrorismPipelineList(request: QueryTerrorismPipelineListRequest): QueryTerrorismPipelineListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTerrorismPipelineListWithOptions(request, runtime);
}

model QueryVideoGifJobListRequest {
  jobIds?: string(name='JobIds'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryVideoGifJobListResponseBody = {
  jobList?: {
    job?: [ 
    {
      code?: string(name='Code'),
      creationTime?: string(name='CreationTime'),
      id?: string(name='Id'),
      input?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='Input'),
      message?: string(name='Message'),
      pipelineId?: string(name='PipelineId'),
      state?: string(name='State'),
      userData?: string(name='UserData'),
      videoGifResult?: {
        outputFile?: {
          bucket?: string(name='Bucket'),
          location?: string(name='Location'),
          object?: string(name='Object'),
        }(name='OutputFile'),
      }(name='VideoGifResult'),
    }
  ](name='Job')
  }(name='JobList'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
  requestId?: string(name='RequestId'),
}

model QueryVideoGifJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryVideoGifJobListResponseBody(name='body'),
}

async function queryVideoGifJobListWithOptions(request: QueryVideoGifJobListRequest, runtime: Util.RuntimeOptions): QueryVideoGifJobListResponse {
  Util.validateModel(request);
  var query = {};
  query["JobIds"] = request.jobIds;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryVideoGifJobList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryVideoGifJobList(request: QueryVideoGifJobListRequest): QueryVideoGifJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryVideoGifJobListWithOptions(request, runtime);
}

model QueryVideoPoseJobListRequest {
  jobIds?: string(name='JobIds'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryVideoPoseJobListResponseBody = {
  jobList?: {
    job?: [ 
    {
      input?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
        roleArn?: string(name='RoleArn'),
      }(name='Input'),
      jobId?: string(name='JobId'),
      MNSMessageResult?: {
        errorCode?: string(name='ErrorCode'),
        errorMessage?: string(name='ErrorMessage'),
        messageId?: string(name='MessageId'),
      }(name='MNSMessageResult'),
      outputConfig?: {
        dataFile?: {
          bucket?: string(name='Bucket'),
          location?: string(name='Location'),
          object?: string(name='Object'),
          roleArn?: string(name='RoleArn'),
        }(name='DataFile'),
        videoFile?: {
          bucket?: string(name='Bucket'),
          location?: string(name='Location'),
          object?: string(name='Object'),
          roleArn?: string(name='RoleArn'),
        }(name='VideoFile'),
      }(name='OutputConfig'),
      pipelineId?: string(name='PipelineId'),
      properties?: {
        bitrate?: string(name='Bitrate'),
        duration?: string(name='Duration'),
        fileFormat?: string(name='FileFormat'),
        fileSize?: string(name='FileSize'),
        format?: {
          bitrate?: string(name='Bitrate'),
          duration?: string(name='Duration'),
          formatLongName?: string(name='FormatLongName'),
          formatName?: string(name='FormatName'),
          numPrograms?: string(name='NumPrograms'),
          numStreams?: string(name='NumStreams'),
          size?: string(name='Size'),
          startTime?: string(name='StartTime'),
        }(name='Format'),
        fps?: string(name='Fps'),
        height?: string(name='Height'),
        streams?: {
          audioStreamList?: {
            audioStream?: [ 
            {
              bitrate?: string(name='Bitrate'),
              channelLayout?: string(name='ChannelLayout'),
              channels?: string(name='Channels'),
              codecLongName?: string(name='CodecLongName'),
              codecName?: string(name='CodecName'),
              codecTag?: string(name='CodecTag'),
              codecTagString?: string(name='CodecTagString'),
              codecTimeBase?: string(name='CodecTimeBase'),
              duration?: string(name='Duration'),
              index?: string(name='Index'),
              lang?: string(name='Lang'),
              numFrames?: string(name='NumFrames'),
              sampleFmt?: string(name='SampleFmt'),
              samplerate?: string(name='Samplerate'),
              startTime?: string(name='StartTime'),
              timebase?: string(name='Timebase'),
            }
          ](name='AudioStream')
          }(name='AudioStreamList'),
          subtitleStreamList?: {
            subtitleStream?: [ 
            {
              codecLongName?: string(name='CodecLongName'),
              codecName?: string(name='CodecName'),
              codecTag?: string(name='CodecTag'),
              codecTagString?: string(name='CodecTagString'),
              codecTimeBase?: string(name='CodecTimeBase'),
              duration?: string(name='Duration'),
              index?: string(name='Index'),
              lang?: string(name='Lang'),
              startTime?: string(name='StartTime'),
              timebase?: string(name='Timebase'),
            }
          ](name='SubtitleStream')
          }(name='SubtitleStreamList'),
          videoStreamList?: {
            videoStream?: [ 
            {
              avgFPS?: string(name='AvgFPS'),
              bitrate?: string(name='Bitrate'),
              codecLongName?: string(name='CodecLongName'),
              codecName?: string(name='CodecName'),
              codecTag?: string(name='CodecTag'),
              codecTagString?: string(name='CodecTagString'),
              codecTimeBase?: string(name='CodecTimeBase'),
              dar?: string(name='Dar'),
              duration?: string(name='Duration'),
              fps?: string(name='Fps'),
              hasBFrames?: string(name='HasBFrames'),
              height?: string(name='Height'),
              index?: string(name='Index'),
              lang?: string(name='Lang'),
              level?: string(name='Level'),
              networkCost?: {
                avgBitrate?: string(name='AvgBitrate'),
                costBandwidth?: string(name='CostBandwidth'),
                preloadTime?: string(name='PreloadTime'),
              }(name='NetworkCost'),
              numFrames?: string(name='NumFrames'),
              pixFmt?: string(name='PixFmt'),
              profile?: string(name='Profile'),
              rotate?: string(name='Rotate'),
              sar?: string(name='Sar'),
              startTime?: string(name='StartTime'),
              timebase?: string(name='Timebase'),
              width?: string(name='Width'),
            }
          ](name='VideoStream')
          }(name='VideoStreamList'),
        }(name='Streams'),
        width?: string(name='Width'),
      }(name='Properties'),
      state?: string(name='State'),
      userData?: string(name='UserData'),
    }
  ](name='Job')
  }(name='JobList'),
  nonExistJobIds?: {
    string?: [ string ](name='String')
  }(name='NonExistJobIds'),
  requestId?: string(name='RequestId'),
}

model QueryVideoPoseJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryVideoPoseJobListResponseBody(name='body'),
}

async function queryVideoPoseJobListWithOptions(request: QueryVideoPoseJobListRequest, runtime: Util.RuntimeOptions): QueryVideoPoseJobListResponse {
  Util.validateModel(request);
  var query = {};
  query["JobIds"] = request.jobIds;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryVideoPoseJobList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryVideoPoseJobList(request: QueryVideoPoseJobListRequest): QueryVideoPoseJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryVideoPoseJobListWithOptions(request, runtime);
}

model QueryVideoQualityJobRequest {
  jobId?: string(name='JobId'),
  userId?: long(name='UserId'),
}

model QueryVideoQualityJobResponseBody = {
  code?: string(name='Code'),
  job?: {
    jobId?: string(name='JobId'),
    message?: string(name='Message'),
    output?: string(name='Output'),
    status?: string(name='Status'),
    userId?: long(name='UserId'),
    videoQualityResults?: string(name='VideoQualityResults'),
  }(name='Job'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model QueryVideoQualityJobResponse = {
  headers: map[string]string(name='headers'),
  body: QueryVideoQualityJobResponseBody(name='body'),
}

async function queryVideoQualityJobWithOptions(request: QueryVideoQualityJobRequest, runtime: Util.RuntimeOptions): QueryVideoQualityJobResponse {
  Util.validateModel(request);
  var query = {};
  query["JobId"] = request.jobId;
  query["UserId"] = request.userId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryVideoQualityJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryVideoQualityJob(request: QueryVideoQualityJobRequest): QueryVideoQualityJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryVideoQualityJobWithOptions(request, runtime);
}

model QueryVideoSplitJobListRequest {
  jobIds?: string(name='JobIds'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryVideoSplitJobListResponseBody = {
  jobList?: {
    job?: [ 
    {
      code?: string(name='Code'),
      creationTime?: string(name='CreationTime'),
      id?: string(name='Id'),
      input?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='Input'),
      message?: string(name='Message'),
      pipelineId?: string(name='PipelineId'),
      state?: string(name='State'),
      userData?: string(name='UserData'),
      videoSplitResult?: {
        videoSplitList?: {
          videoSplit?: [ 
          {
            endTime?: string(name='EndTime'),
            path?: string(name='Path'),
            startTime?: string(name='StartTime'),
          }
        ](name='VideoSplit')
        }(name='VideoSplitList'),
      }(name='VideoSplitResult'),
    }
  ](name='Job')
  }(name='JobList'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
  requestId?: string(name='RequestId'),
}

model QueryVideoSplitJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryVideoSplitJobListResponseBody(name='body'),
}

async function queryVideoSplitJobListWithOptions(request: QueryVideoSplitJobListRequest, runtime: Util.RuntimeOptions): QueryVideoSplitJobListResponse {
  Util.validateModel(request);
  var query = {};
  query["JobIds"] = request.jobIds;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryVideoSplitJobList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryVideoSplitJobList(request: QueryVideoSplitJobListRequest): QueryVideoSplitJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryVideoSplitJobListWithOptions(request, runtime);
}

model QueryVideoSummaryJobListRequest {
  jobIds?: string(name='JobIds'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryVideoSummaryJobListResponseBody = {
  jobList?: {
    job?: [ 
    {
      code?: string(name='Code'),
      creationTime?: string(name='CreationTime'),
      id?: string(name='Id'),
      input?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='Input'),
      message?: string(name='Message'),
      pipelineId?: string(name='PipelineId'),
      state?: string(name='State'),
      userData?: string(name='UserData'),
      videoSummaryResult?: {
        outputFile?: {
          bucket?: string(name='Bucket'),
          location?: string(name='Location'),
          object?: string(name='Object'),
        }(name='OutputFile'),
        videoSummaryList?: {
          videoSummary?: [ 
          {
            endTime?: string(name='EndTime'),
            startTime?: string(name='StartTime'),
          }
        ](name='VideoSummary')
        }(name='VideoSummaryList'),
      }(name='VideoSummaryResult'),
    }
  ](name='Job')
  }(name='JobList'),
  nonExistIds?: {
    string?: [ string ](name='String')
  }(name='NonExistIds'),
  requestId?: string(name='RequestId'),
}

model QueryVideoSummaryJobListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryVideoSummaryJobListResponseBody(name='body'),
}

async function queryVideoSummaryJobListWithOptions(request: QueryVideoSummaryJobListRequest, runtime: Util.RuntimeOptions): QueryVideoSummaryJobListResponse {
  Util.validateModel(request);
  var query = {};
  query["JobIds"] = request.jobIds;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryVideoSummaryJobList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryVideoSummaryJobList(request: QueryVideoSummaryJobListRequest): QueryVideoSummaryJobListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryVideoSummaryJobListWithOptions(request, runtime);
}

model QueryWaterMarkTemplateListRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  waterMarkTemplateIds?: string(name='WaterMarkTemplateIds'),
}

model QueryWaterMarkTemplateListResponseBody = {
  nonExistWids?: {
    string?: [ string ](name='String')
  }(name='NonExistWids'),
  requestId?: string(name='RequestId'),
  waterMarkTemplateList?: {
    waterMarkTemplate?: [ 
    {
      dx?: string(name='Dx'),
      dy?: string(name='Dy'),
      height?: string(name='Height'),
      id?: string(name='Id'),
      name?: string(name='Name'),
      ratioRefer?: {
        dx?: string(name='Dx'),
        dy?: string(name='Dy'),
        height?: string(name='Height'),
        width?: string(name='Width'),
      }(name='RatioRefer'),
      referPos?: string(name='ReferPos'),
      state?: string(name='State'),
      timeline?: {
        duration?: string(name='Duration'),
        start?: string(name='Start'),
      }(name='Timeline'),
      type?: string(name='Type'),
      width?: string(name='Width'),
    }
  ](name='WaterMarkTemplate')
  }(name='WaterMarkTemplateList'),
}

model QueryWaterMarkTemplateListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryWaterMarkTemplateListResponseBody(name='body'),
}

async function queryWaterMarkTemplateListWithOptions(request: QueryWaterMarkTemplateListRequest, runtime: Util.RuntimeOptions): QueryWaterMarkTemplateListResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["WaterMarkTemplateIds"] = request.waterMarkTemplateIds;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'QueryWaterMarkTemplateList',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryWaterMarkTemplateList(request: QueryWaterMarkTemplateListRequest): QueryWaterMarkTemplateListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryWaterMarkTemplateListWithOptions(request, runtime);
}

model RefreshCdnDomainConfigsCacheRequest {
  domains?: string(name='Domains'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: string(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: string(name='ResourceOwnerId'),
}

model RefreshCdnDomainConfigsCacheResponseBody = {
  failedDomains?: {
    string?: [ string ](name='String')
  }(name='FailedDomains'),
  requestId?: string(name='RequestId'),
  sucessDomains?: {
    string?: [ string ](name='String')
  }(name='SucessDomains'),
}

model RefreshCdnDomainConfigsCacheResponse = {
  headers: map[string]string(name='headers'),
  body: RefreshCdnDomainConfigsCacheResponseBody(name='body'),
}

async function refreshCdnDomainConfigsCacheWithOptions(request: RefreshCdnDomainConfigsCacheRequest, runtime: Util.RuntimeOptions): RefreshCdnDomainConfigsCacheResponse {
  Util.validateModel(request);
  var query = {};
  query["Domains"] = request.domains;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'RefreshCdnDomainConfigsCache',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function refreshCdnDomainConfigsCache(request: RefreshCdnDomainConfigsCacheRequest): RefreshCdnDomainConfigsCacheResponse {
  var runtime = new Util.RuntimeOptions{};
  return refreshCdnDomainConfigsCacheWithOptions(request, runtime);
}

model RegisterCustomFaceRequest {
  categoryId?: string(name='CategoryId'),
  imageUrl?: string(name='ImageUrl'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  personId?: string(name='PersonId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model RegisterCustomFaceResponseBody = {
  faceId?: string(name='FaceId'),
  requestId?: string(name='RequestId'),
}

model RegisterCustomFaceResponse = {
  headers: map[string]string(name='headers'),
  body: RegisterCustomFaceResponseBody(name='body'),
}

async function registerCustomFaceWithOptions(request: RegisterCustomFaceRequest, runtime: Util.RuntimeOptions): RegisterCustomFaceResponse {
  Util.validateModel(request);
  var query = {};
  query["CategoryId"] = request.categoryId;
  query["ImageUrl"] = request.imageUrl;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PersonId"] = request.personId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'RegisterCustomFace',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function registerCustomFace(request: RegisterCustomFaceRequest): RegisterCustomFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return registerCustomFaceWithOptions(request, runtime);
}

model RegisterMediaDetailPersonRequest {
  category?: string(name='Category'),
  images?: string(name='Images'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  personLib?: string(name='PersonLib'),
  personName?: string(name='PersonName'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model RegisterMediaDetailPersonResponseBody = {
  failedImages?: {
    failedImage?: [ 
    {
      code?: string(name='Code'),
      imageFile?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='ImageFile'),
      success?: string(name='Success'),
    }
  ](name='FailedImage')
  }(name='FailedImages'),
  registeredPersonages?: {
    registeredPersonage?: [ 
    {
      faceId?: string(name='FaceId'),
      gender?: string(name='Gender'),
      imageFile?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
      }(name='ImageFile'),
      imageId?: string(name='ImageId'),
      personName?: string(name='PersonName'),
      quality?: string(name='Quality'),
      target?: string(name='Target'),
    }
  ](name='RegisteredPersonage')
  }(name='RegisteredPersonages'),
  requestId?: string(name='RequestId'),
}

model RegisterMediaDetailPersonResponse = {
  headers: map[string]string(name='headers'),
  body: RegisterMediaDetailPersonResponseBody(name='body'),
}

async function registerMediaDetailPersonWithOptions(request: RegisterMediaDetailPersonRequest, runtime: Util.RuntimeOptions): RegisterMediaDetailPersonResponse {
  Util.validateModel(request);
  var query = {};
  query["Category"] = request.category;
  query["Images"] = request.images;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PersonLib"] = request.personLib;
  query["PersonName"] = request.personName;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'RegisterMediaDetailPerson',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function registerMediaDetailPerson(request: RegisterMediaDetailPersonRequest): RegisterMediaDetailPersonResponse {
  var runtime = new Util.RuntimeOptions{};
  return registerMediaDetailPersonWithOptions(request, runtime);
}

model RegisterMediaDetailScenarioRequest {
  description?: string(name='Description'),
  jobId?: string(name='JobId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  scenario?: string(name='Scenario'),
}

model RegisterMediaDetailScenarioResponseBody = {
  requestId?: string(name='RequestId'),
  scenarioId?: string(name='ScenarioId'),
}

model RegisterMediaDetailScenarioResponse = {
  headers: map[string]string(name='headers'),
  body: RegisterMediaDetailScenarioResponseBody(name='body'),
}

async function registerMediaDetailScenarioWithOptions(request: RegisterMediaDetailScenarioRequest, runtime: Util.RuntimeOptions): RegisterMediaDetailScenarioResponse {
  Util.validateModel(request);
  var query = {};
  query["Description"] = request.description;
  query["JobId"] = request.jobId;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["Scenario"] = request.scenario;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'RegisterMediaDetailScenario',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function registerMediaDetailScenario(request: RegisterMediaDetailScenarioRequest): RegisterMediaDetailScenarioResponse {
  var runtime = new Util.RuntimeOptions{};
  return registerMediaDetailScenarioWithOptions(request, runtime);
}

model ReportAnnotationJobResultRequest {
  annotation?: string(name='Annotation'),
  details?: string(name='Details'),
  jobId?: string(name='JobId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ReportAnnotationJobResultResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model ReportAnnotationJobResultResponse = {
  headers: map[string]string(name='headers'),
  body: ReportAnnotationJobResultResponseBody(name='body'),
}

async function reportAnnotationJobResultWithOptions(request: ReportAnnotationJobResultRequest, runtime: Util.RuntimeOptions): ReportAnnotationJobResultResponse {
  Util.validateModel(request);
  var query = {};
  query["Annotation"] = request.annotation;
  query["Details"] = request.details;
  query["JobId"] = request.jobId;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ReportAnnotationJobResult',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function reportAnnotationJobResult(request: ReportAnnotationJobResultRequest): ReportAnnotationJobResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return reportAnnotationJobResultWithOptions(request, runtime);
}

model ReportCensorJobResultRequest {
  detail?: string(name='Detail'),
  jobId?: string(name='JobId'),
  label?: string(name='Label'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ReportCensorJobResultResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model ReportCensorJobResultResponse = {
  headers: map[string]string(name='headers'),
  body: ReportCensorJobResultResponseBody(name='body'),
}

async function reportCensorJobResultWithOptions(request: ReportCensorJobResultRequest, runtime: Util.RuntimeOptions): ReportCensorJobResultResponse {
  Util.validateModel(request);
  var query = {};
  query["Detail"] = request.detail;
  query["JobId"] = request.jobId;
  query["Label"] = request.label;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ReportCensorJobResult',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function reportCensorJobResult(request: ReportCensorJobResultRequest): ReportCensorJobResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return reportCensorJobResultWithOptions(request, runtime);
}

model ReportCoverJobResultRequest {
  jobId?: string(name='JobId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  result?: string(name='Result'),
}

model ReportCoverJobResultResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model ReportCoverJobResultResponse = {
  headers: map[string]string(name='headers'),
  body: ReportCoverJobResultResponseBody(name='body'),
}

async function reportCoverJobResultWithOptions(request: ReportCoverJobResultRequest, runtime: Util.RuntimeOptions): ReportCoverJobResultResponse {
  Util.validateModel(request);
  var query = {};
  query["JobId"] = request.jobId;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["Result"] = request.result;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ReportCoverJobResult',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function reportCoverJobResult(request: ReportCoverJobResultRequest): ReportCoverJobResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return reportCoverJobResultWithOptions(request, runtime);
}

model ReportFacerecogJobResultRequest {
  details?: string(name='Details'),
  facerecog?: string(name='Facerecog'),
  jobId?: string(name='JobId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ReportFacerecogJobResultResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model ReportFacerecogJobResultResponse = {
  headers: map[string]string(name='headers'),
  body: ReportFacerecogJobResultResponseBody(name='body'),
}

async function reportFacerecogJobResultWithOptions(request: ReportFacerecogJobResultRequest, runtime: Util.RuntimeOptions): ReportFacerecogJobResultResponse {
  Util.validateModel(request);
  var query = {};
  query["Details"] = request.details;
  query["Facerecog"] = request.facerecog;
  query["JobId"] = request.jobId;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ReportFacerecogJobResult',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function reportFacerecogJobResult(request: ReportFacerecogJobResultRequest): ReportFacerecogJobResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return reportFacerecogJobResultWithOptions(request, runtime);
}

model ReportFpShotJobResultRequest {
  details?: string(name='Details'),
  jobId?: string(name='JobId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  result?: string(name='Result'),
}

model ReportFpShotJobResultResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model ReportFpShotJobResultResponse = {
  headers: map[string]string(name='headers'),
  body: ReportFpShotJobResultResponseBody(name='body'),
}

async function reportFpShotJobResultWithOptions(request: ReportFpShotJobResultRequest, runtime: Util.RuntimeOptions): ReportFpShotJobResultResponse {
  Util.validateModel(request);
  var query = {};
  query["Details"] = request.details;
  query["JobId"] = request.jobId;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["Result"] = request.result;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ReportFpShotJobResult',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function reportFpShotJobResult(request: ReportFpShotJobResultRequest): ReportFpShotJobResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return reportFpShotJobResultWithOptions(request, runtime);
}

model ReportMediaDetailJobResultRequest {
  jobId?: string(name='JobId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  results?: string(name='Results'),
  tag?: string(name='Tag'),
}

model ReportMediaDetailJobResultResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model ReportMediaDetailJobResultResponse = {
  headers: map[string]string(name='headers'),
  body: ReportMediaDetailJobResultResponseBody(name='body'),
}

async function reportMediaDetailJobResultWithOptions(request: ReportMediaDetailJobResultRequest, runtime: Util.RuntimeOptions): ReportMediaDetailJobResultResponse {
  Util.validateModel(request);
  var query = {};
  query["JobId"] = request.jobId;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["Results"] = request.results;
  query["Tag"] = request.tag;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ReportMediaDetailJobResult',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function reportMediaDetailJobResult(request: ReportMediaDetailJobResultRequest): ReportMediaDetailJobResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return reportMediaDetailJobResultWithOptions(request, runtime);
}

model ReportPornJobResultRequest {
  detail?: string(name='Detail'),
  jobId?: string(name='JobId'),
  label?: string(name='Label'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ReportPornJobResultResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model ReportPornJobResultResponse = {
  headers: map[string]string(name='headers'),
  body: ReportPornJobResultResponseBody(name='body'),
}

async function reportPornJobResultWithOptions(request: ReportPornJobResultRequest, runtime: Util.RuntimeOptions): ReportPornJobResultResponse {
  Util.validateModel(request);
  var query = {};
  query["Detail"] = request.detail;
  query["JobId"] = request.jobId;
  query["Label"] = request.label;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ReportPornJobResult',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function reportPornJobResult(request: ReportPornJobResultRequest): ReportPornJobResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return reportPornJobResultWithOptions(request, runtime);
}

model ReportTagJobResultRequest {
  jobId?: string(name='JobId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  result?: string(name='Result'),
  tag?: string(name='Tag'),
}

model ReportTagJobResultResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model ReportTagJobResultResponse = {
  headers: map[string]string(name='headers'),
  body: ReportTagJobResultResponseBody(name='body'),
}

async function reportTagJobResultWithOptions(request: ReportTagJobResultRequest, runtime: Util.RuntimeOptions): ReportTagJobResultResponse {
  Util.validateModel(request);
  var query = {};
  query["JobId"] = request.jobId;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["Result"] = request.result;
  query["Tag"] = request.tag;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ReportTagJobResult',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function reportTagJobResult(request: ReportTagJobResultRequest): ReportTagJobResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return reportTagJobResultWithOptions(request, runtime);
}

model ReportTerrorismJobResultRequest {
  detail?: string(name='Detail'),
  jobId?: string(name='JobId'),
  label?: string(name='Label'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ReportTerrorismJobResultResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model ReportTerrorismJobResultResponse = {
  headers: map[string]string(name='headers'),
  body: ReportTerrorismJobResultResponseBody(name='body'),
}

async function reportTerrorismJobResultWithOptions(request: ReportTerrorismJobResultRequest, runtime: Util.RuntimeOptions): ReportTerrorismJobResultResponse {
  Util.validateModel(request);
  var query = {};
  query["Detail"] = request.detail;
  query["JobId"] = request.jobId;
  query["Label"] = request.label;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ReportTerrorismJobResult',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function reportTerrorismJobResult(request: ReportTerrorismJobResultRequest): ReportTerrorismJobResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return reportTerrorismJobResultWithOptions(request, runtime);
}

model ReportVideoSplitJobResultRequest {
  details?: string(name='Details'),
  jobId?: string(name='JobId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  result?: string(name='Result'),
}

model ReportVideoSplitJobResultResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model ReportVideoSplitJobResultResponse = {
  headers: map[string]string(name='headers'),
  body: ReportVideoSplitJobResultResponseBody(name='body'),
}

async function reportVideoSplitJobResultWithOptions(request: ReportVideoSplitJobResultRequest, runtime: Util.RuntimeOptions): ReportVideoSplitJobResultResponse {
  Util.validateModel(request);
  var query = {};
  query["Details"] = request.details;
  query["JobId"] = request.jobId;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["Result"] = request.result;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ReportVideoSplitJobResult',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function reportVideoSplitJobResult(request: ReportVideoSplitJobResultRequest): ReportVideoSplitJobResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return reportVideoSplitJobResultWithOptions(request, runtime);
}

model SearchMediaRequest {
  cateId?: string(name='CateId'),
  description?: string(name='Description'),
  from?: string(name='From'),
  keyWord?: string(name='KeyWord'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sortBy?: string(name='SortBy'),
  tag?: string(name='Tag'),
  title?: string(name='Title'),
  to?: string(name='To'),
}

model SearchMediaResponseBody = {
  mediaList?: {
    media?: [ 
    {
      bitrate?: string(name='Bitrate'),
      cateId?: long(name='CateId'),
      coverURL?: string(name='CoverURL'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      duration?: string(name='Duration'),
      file?: {
        state?: string(name='State'),
        URL?: string(name='URL'),
      }(name='File'),
      format?: string(name='Format'),
      fps?: string(name='Fps'),
      height?: string(name='Height'),
      mediaId?: string(name='MediaId'),
      publishState?: string(name='PublishState'),
      runIdList?: {
        runId?: [ string ](name='RunId')
      }(name='RunIdList'),
      size?: string(name='Size'),
      tags?: {
        tag?: [ string ](name='Tag')
      }(name='Tags'),
      title?: string(name='Title'),
      width?: string(name='Width'),
    }
  ](name='Media')
  }(name='MediaList'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalNum?: long(name='TotalNum'),
}

model SearchMediaResponse = {
  headers: map[string]string(name='headers'),
  body: SearchMediaResponseBody(name='body'),
}

async function searchMediaWithOptions(request: SearchMediaRequest, runtime: Util.RuntimeOptions): SearchMediaResponse {
  Util.validateModel(request);
  var query = {};
  query["CateId"] = request.cateId;
  query["Description"] = request.description;
  query["From"] = request.from;
  query["KeyWord"] = request.keyWord;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["SortBy"] = request.sortBy;
  query["Tag"] = request.tag;
  query["Title"] = request.title;
  query["To"] = request.to;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SearchMedia',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchMedia(request: SearchMediaRequest): SearchMediaResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchMediaWithOptions(request, runtime);
}

model SearchMediaWorkflowRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  stateList?: string(name='StateList'),
}

model SearchMediaWorkflowResponseBody = {
  mediaWorkflowList?: {
    mediaWorkflow?: [ 
    {
      creationTime?: string(name='CreationTime'),
      mediaWorkflowId?: string(name='MediaWorkflowId'),
      name?: string(name='Name'),
      state?: string(name='State'),
      topology?: string(name='Topology'),
      triggerMode?: string(name='TriggerMode'),
    }
  ](name='MediaWorkflow')
  }(name='MediaWorkflowList'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model SearchMediaWorkflowResponse = {
  headers: map[string]string(name='headers'),
  body: SearchMediaWorkflowResponseBody(name='body'),
}

async function searchMediaWorkflowWithOptions(request: SearchMediaWorkflowRequest, runtime: Util.RuntimeOptions): SearchMediaWorkflowResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["StateList"] = request.stateList;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SearchMediaWorkflow',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchMediaWorkflow(request: SearchMediaWorkflowRequest): SearchMediaWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchMediaWorkflowWithOptions(request, runtime);
}

model SearchPipelineRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  state?: string(name='State'),
}

model SearchPipelineResponseBody = {
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  pipelineList?: {
    pipeline?: [ 
    {
      id?: string(name='Id'),
      name?: string(name='Name'),
      notifyConfig?: {
        mqTag?: string(name='MqTag'),
        mqTopic?: string(name='MqTopic'),
        queueName?: string(name='QueueName'),
        topic?: string(name='Topic'),
      }(name='NotifyConfig'),
      quotaAllocate?: long(name='QuotaAllocate'),
      role?: string(name='Role'),
      speed?: string(name='Speed'),
      speedLevel?: long(name='SpeedLevel'),
      state?: string(name='State'),
    }
  ](name='Pipeline')
  }(name='PipelineList'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model SearchPipelineResponse = {
  headers: map[string]string(name='headers'),
  body: SearchPipelineResponseBody(name='body'),
}

async function searchPipelineWithOptions(request: SearchPipelineRequest, runtime: Util.RuntimeOptions): SearchPipelineResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["State"] = request.state;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SearchPipeline',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchPipeline(request: SearchPipelineRequest): SearchPipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchPipelineWithOptions(request, runtime);
}

model SearchTemplateRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  state?: string(name='State'),
}

model SearchTemplateResponseBody = {
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  templateList?: {
    template?: [ 
    {
      audio?: {
        bitrate?: string(name='Bitrate'),
        channels?: string(name='Channels'),
        codec?: string(name='Codec'),
        profile?: string(name='Profile'),
        qscale?: string(name='Qscale'),
        remove?: string(name='Remove'),
        samplerate?: string(name='Samplerate'),
      }(name='Audio'),
      container?: {
        format?: string(name='Format'),
      }(name='Container'),
      id?: string(name='Id'),
      muxConfig?: {
        gif?: {
          ditherMode?: string(name='DitherMode'),
          finalDelay?: string(name='FinalDelay'),
          isCustomPalette?: string(name='IsCustomPalette'),
          loop?: string(name='Loop'),
        }(name='Gif'),
        segment?: {
          duration?: string(name='Duration'),
        }(name='Segment'),
      }(name='MuxConfig'),
      name?: string(name='Name'),
      state?: string(name='State'),
      transConfig?: {
        adjDarMethod?: string(name='AdjDarMethod'),
        isCheckAudioBitrate?: string(name='IsCheckAudioBitrate'),
        isCheckAudioBitrateFail?: string(name='IsCheckAudioBitrateFail'),
        isCheckReso?: string(name='IsCheckReso'),
        isCheckResoFail?: string(name='IsCheckResoFail'),
        isCheckVideoBitrate?: string(name='IsCheckVideoBitrate'),
        isCheckVideoBitrateFail?: string(name='IsCheckVideoBitrateFail'),
        transMode?: string(name='TransMode'),
      }(name='TransConfig'),
      video?: {
        bitrate?: string(name='Bitrate'),
        bitrateBnd?: {
          max?: string(name='Max'),
          min?: string(name='Min'),
        }(name='BitrateBnd'),
        bufsize?: string(name='Bufsize'),
        codec?: string(name='Codec'),
        crf?: string(name='Crf'),
        crop?: string(name='Crop'),
        degrain?: string(name='Degrain'),
        fps?: string(name='Fps'),
        gop?: string(name='Gop'),
        height?: string(name='Height'),
        longShortMode?: string(name='LongShortMode'),
        maxFps?: string(name='MaxFps'),
        maxrate?: string(name='Maxrate'),
        pad?: string(name='Pad'),
        pixFmt?: string(name='PixFmt'),
        preset?: string(name='Preset'),
        profile?: string(name='Profile'),
        qscale?: string(name='Qscale'),
        remove?: string(name='Remove'),
        scanMode?: string(name='ScanMode'),
        width?: string(name='Width'),
      }(name='Video'),
    }
  ](name='Template')
  }(name='TemplateList'),
  totalCount?: long(name='TotalCount'),
}

model SearchTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: SearchTemplateResponseBody(name='body'),
}

async function searchTemplateWithOptions(request: SearchTemplateRequest, runtime: Util.RuntimeOptions): SearchTemplateResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["State"] = request.state;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SearchTemplate',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchTemplate(request: SearchTemplateRequest): SearchTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchTemplateWithOptions(request, runtime);
}

model SearchWaterMarkTemplateRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  state?: string(name='State'),
}

model SearchWaterMarkTemplateResponseBody = {
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
  waterMarkTemplateList?: {
    waterMarkTemplate?: [ 
    {
      dx?: string(name='Dx'),
      dy?: string(name='Dy'),
      height?: string(name='Height'),
      id?: string(name='Id'),
      name?: string(name='Name'),
      ratioRefer?: {
        dx?: string(name='Dx'),
        dy?: string(name='Dy'),
        height?: string(name='Height'),
        width?: string(name='Width'),
      }(name='RatioRefer'),
      referPos?: string(name='ReferPos'),
      state?: string(name='State'),
      timeline?: {
        duration?: string(name='Duration'),
        start?: string(name='Start'),
      }(name='Timeline'),
      type?: string(name='Type'),
      width?: string(name='Width'),
    }
  ](name='WaterMarkTemplate')
  }(name='WaterMarkTemplateList'),
}

model SearchWaterMarkTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: SearchWaterMarkTemplateResponseBody(name='body'),
}

async function searchWaterMarkTemplateWithOptions(request: SearchWaterMarkTemplateRequest, runtime: Util.RuntimeOptions): SearchWaterMarkTemplateResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["State"] = request.state;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SearchWaterMarkTemplate',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchWaterMarkTemplate(request: SearchWaterMarkTemplateRequest): SearchWaterMarkTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchWaterMarkTemplateWithOptions(request, runtime);
}

model SetAuthConfigRequest {
  key1?: string(name='Key1'),
  key2?: string(name='Key2'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: string(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: string(name='ResourceOwnerId'),
}

model SetAuthConfigResponseBody = {
  key1?: string(name='Key1'),
  key2?: string(name='Key2'),
  requestId?: string(name='RequestId'),
}

model SetAuthConfigResponse = {
  headers: map[string]string(name='headers'),
  body: SetAuthConfigResponseBody(name='body'),
}

async function setAuthConfigWithOptions(request: SetAuthConfigRequest, runtime: Util.RuntimeOptions): SetAuthConfigResponse {
  Util.validateModel(request);
  var query = {};
  query["Key1"] = request.key1;
  query["Key2"] = request.key2;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SetAuthConfig',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setAuthConfig(request: SetAuthConfigRequest): SetAuthConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return setAuthConfigWithOptions(request, runtime);
}

model StopIProductionJobRequest {
  jobId?: string(name='JobId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model StopIProductionJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model StopIProductionJobResponse = {
  headers: map[string]string(name='headers'),
  body: StopIProductionJobResponseBody(name='body'),
}

async function stopIProductionJobWithOptions(request: StopIProductionJobRequest, runtime: Util.RuntimeOptions): StopIProductionJobResponse {
  Util.validateModel(request);
  var query = {};
  query["JobId"] = request.jobId;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'StopIProductionJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopIProductionJob(request: StopIProductionJobRequest): StopIProductionJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopIProductionJobWithOptions(request, runtime);
}

model SubmitAnalysisJobRequest {
  analysisConfig?: string(name='AnalysisConfig'),
  input?: string(name='Input'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  priority?: string(name='Priority'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  userData?: string(name='UserData'),
}

model SubmitAnalysisJobResponseBody = {
  analysisJob?: {
    analysisConfig?: {
      propertiesControl?: {
        crop?: {
          height?: string(name='Height'),
          left?: string(name='Left'),
          mode?: string(name='Mode'),
          top?: string(name='Top'),
          width?: string(name='Width'),
        }(name='Crop'),
        deinterlace?: string(name='Deinterlace'),
      }(name='PropertiesControl'),
      qualityControl?: {
        methodStreaming?: string(name='MethodStreaming'),
        rateQuality?: string(name='RateQuality'),
      }(name='QualityControl'),
    }(name='AnalysisConfig'),
    code?: string(name='Code'),
    creationTime?: string(name='CreationTime'),
    id?: string(name='Id'),
    inputFile?: {
      bucket?: string(name='Bucket'),
      location?: string(name='Location'),
      object?: string(name='Object'),
    }(name='InputFile'),
    MNSMessageResult?: {
      errorCode?: string(name='ErrorCode'),
      errorMessage?: string(name='ErrorMessage'),
      messageId?: string(name='MessageId'),
    }(name='MNSMessageResult'),
    message?: string(name='Message'),
    percent?: long(name='Percent'),
    pipelineId?: string(name='PipelineId'),
    priority?: string(name='Priority'),
    state?: string(name='State'),
    templateList?: {
      template?: [ 
      {
        audio?: {
          bitrate?: string(name='Bitrate'),
          channels?: string(name='Channels'),
          codec?: string(name='Codec'),
          profile?: string(name='Profile'),
          qscale?: string(name='Qscale'),
          samplerate?: string(name='Samplerate'),
        }(name='Audio'),
        container?: {
          format?: string(name='Format'),
        }(name='Container'),
        id?: string(name='Id'),
        muxConfig?: {
          gif?: {
            finalDelay?: string(name='FinalDelay'),
            loop?: string(name='Loop'),
          }(name='Gif'),
          segment?: {
            duration?: string(name='Duration'),
          }(name='Segment'),
        }(name='MuxConfig'),
        name?: string(name='Name'),
        state?: string(name='State'),
        transConfig?: {
          transMode?: string(name='TransMode'),
        }(name='TransConfig'),
        video?: {
          bitrate?: string(name='Bitrate'),
          bitrateBnd?: {
            max?: string(name='Max'),
            min?: string(name='Min'),
          }(name='BitrateBnd'),
          bufsize?: string(name='Bufsize'),
          codec?: string(name='Codec'),
          crf?: string(name='Crf'),
          degrain?: string(name='Degrain'),
          fps?: string(name='Fps'),
          gop?: string(name='Gop'),
          height?: string(name='Height'),
          maxrate?: string(name='Maxrate'),
          pixFmt?: string(name='PixFmt'),
          preset?: string(name='Preset'),
          profile?: string(name='Profile'),
          qscale?: string(name='Qscale'),
          scanMode?: string(name='ScanMode'),
          width?: string(name='Width'),
        }(name='Video'),
      }
    ](name='Template')
    }(name='TemplateList'),
    userData?: string(name='UserData'),
  }(name='AnalysisJob'),
  requestId?: string(name='RequestId'),
}

model SubmitAnalysisJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitAnalysisJobResponseBody(name='body'),
}

async function submitAnalysisJobWithOptions(request: SubmitAnalysisJobRequest, runtime: Util.RuntimeOptions): SubmitAnalysisJobResponse {
  Util.validateModel(request);
  var query = {};
  query["AnalysisConfig"] = request.analysisConfig;
  query["Input"] = request.input;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PipelineId"] = request.pipelineId;
  query["Priority"] = request.priority;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["UserData"] = request.userData;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SubmitAnalysisJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitAnalysisJob(request: SubmitAnalysisJobRequest): SubmitAnalysisJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitAnalysisJobWithOptions(request, runtime);
}

model SubmitAnnotationJobRequest {
  annotationConfig?: string(name='AnnotationConfig'),
  input?: string(name='Input'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  userData?: string(name='UserData'),
}

model SubmitAnnotationJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model SubmitAnnotationJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitAnnotationJobResponseBody(name='body'),
}

async function submitAnnotationJobWithOptions(request: SubmitAnnotationJobRequest, runtime: Util.RuntimeOptions): SubmitAnnotationJobResponse {
  Util.validateModel(request);
  var query = {};
  query["AnnotationConfig"] = request.annotationConfig;
  query["Input"] = request.input;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PipelineId"] = request.pipelineId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["UserData"] = request.userData;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SubmitAnnotationJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitAnnotationJob(request: SubmitAnnotationJobRequest): SubmitAnnotationJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitAnnotationJobWithOptions(request, runtime);
}

model SubmitAsrJobRequest {
  asrConfig?: string(name='AsrConfig'),
  input?: string(name='Input'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  userData?: string(name='UserData'),
}

model SubmitAsrJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model SubmitAsrJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitAsrJobResponseBody(name='body'),
}

async function submitAsrJobWithOptions(request: SubmitAsrJobRequest, runtime: Util.RuntimeOptions): SubmitAsrJobResponse {
  Util.validateModel(request);
  var query = {};
  query["AsrConfig"] = request.asrConfig;
  query["Input"] = request.input;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PipelineId"] = request.pipelineId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["UserData"] = request.userData;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SubmitAsrJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitAsrJob(request: SubmitAsrJobRequest): SubmitAsrJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitAsrJobWithOptions(request, runtime);
}

model SubmitBeautifyJobsRequest {
  async?: boolean(name='Async'),
  beautifyConfig?: string(name='BeautifyConfig'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  userData?: string(name='UserData'),
}

model SubmitBeautifyJobsResponseBody = {
  jobList?: {
    job?: [ 
    {
      beautifyConfig?: {
        outputFile?: {
          bucket?: string(name='Bucket'),
          location?: string(name='Location'),
          object?: string(name='Object'),
          roleArn?: string(name='RoleArn'),
        }(name='OutputFile'),
      }(name='BeautifyConfig'),
      code?: string(name='Code'),
      creationTime?: string(name='CreationTime'),
      id?: string(name='Id'),
      input?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
        roleArn?: string(name='RoleArn'),
      }(name='Input'),
      MNSMessageResult?: {
        errorCode?: string(name='ErrorCode'),
        errorMessage?: string(name='ErrorMessage'),
        messageId?: string(name='MessageId'),
      }(name='MNSMessageResult'),
      message?: string(name='Message'),
      pipelineId?: string(name='PipelineId'),
      state?: string(name='State'),
      userData?: string(name='UserData'),
    }
  ](name='Job')
  }(name='JobList'),
  requestId?: string(name='RequestId'),
}

model SubmitBeautifyJobsResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitBeautifyJobsResponseBody(name='body'),
}

async function submitBeautifyJobsWithOptions(request: SubmitBeautifyJobsRequest, runtime: Util.RuntimeOptions): SubmitBeautifyJobsResponse {
  Util.validateModel(request);
  var query = {};
  query["Async"] = request.async;
  query["BeautifyConfig"] = request.beautifyConfig;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PipelineId"] = request.pipelineId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["UserData"] = request.userData;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SubmitBeautifyJobs',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitBeautifyJobs(request: SubmitBeautifyJobsRequest): SubmitBeautifyJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitBeautifyJobsWithOptions(request, runtime);
}

model SubmitComplexJobRequest {
  complexConfigs?: string(name='ComplexConfigs'),
  inputs?: string(name='Inputs'),
  outputBucket?: string(name='OutputBucket'),
  outputLocation?: string(name='OutputLocation'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  transcodeOutput?: string(name='TranscodeOutput'),
  userData?: string(name='UserData'),
}

model SubmitComplexJobResponseBody = {
  complexJob?: {
    code?: string(name='Code'),
    complexEditingConfigs?: {
      complexEditingConfigs?: [ 
      {
        editing?: {
          clipList?: {
            clip?: [ 
            {
              effects?: {
                effect?: [ 
                {
                  effect?: string(name='Effect'),
                  effectConfig?: string(name='EffectConfig'),
                }
              ](name='Effect')
              }(name='Effects'),
              id?: string(name='Id'),
              in?: string(name='In'),
              out?: string(name='Out'),
              sourceID?: string(name='SourceID'),
              sourceStrmMap?: string(name='SourceStrmMap'),
              sourceType?: string(name='SourceType'),
              type?: string(name='Type'),
            }
          ](name='Clip')
          }(name='ClipList'),
          timeline?: {
            timelineConfig?: {
              timelineConfigAudio?: {
                channelLayout?: string(name='ChannelLayout'),
                channels?: string(name='Channels'),
                samplerate?: string(name='Samplerate'),
              }(name='TimelineConfigAudio'),
              timelineConfigVideo?: {
                bgColor?: string(name='BgColor'),
                fps?: string(name='Fps'),
                height?: string(name='Height'),
                isGpuData?: string(name='IsGpuData'),
                isOneTrackData?: string(name='IsOneTrackData'),
                reclosePrec?: string(name='ReclosePrec'),
                renderRatio?: string(name='RenderRatio'),
                width?: string(name='Width'),
              }(name='TimelineConfigVideo'),
            }(name='TimelineConfig'),
            trackList?: {
              track?: [ 
              {
                clips?: {
                  clip?: [ 
                  {
                    clipsConfig?: {
                      clipsConfigVideo?: {
                        l?: string(name='L'),
                        t?: string(name='T'),
                      }(name='ClipsConfigVideo'),
                    }(name='ClipsConfig'),
                    in?: string(name='In'),
                    out?: string(name='Out'),
                    clipID?: string(name='clipID'),
                  }
                ](name='Clip')
                }(name='Clips'),
                id?: string(name='Id'),
                order?: string(name='Order'),
                type?: string(name='Type'),
              }
            ](name='Track')
            }(name='TrackList'),
          }(name='Timeline'),
        }(name='Editing'),
      }
    ](name='ComplexEditingConfigs')
    }(name='ComplexEditingConfigs'),
    creationTime?: string(name='CreationTime'),
    finishTime?: string(name='FinishTime'),
    inputs?: {
      inputs?: [ 
      {
        editingInputs?: {
          editingInput?: [ 
          {
            id?: string(name='Id'),
            inputConfig?: {
              deinterlaceMethod?: string(name='DeinterlaceMethod'),
              isNormalSar?: string(name='IsNormalSar'),
            }(name='InputConfig'),
            inputFile?: {
              bucket?: string(name='Bucket'),
              location?: string(name='Location'),
              object?: string(name='Object'),
            }(name='InputFile'),
          }
        ](name='EditingInput')
        }(name='EditingInputs'),
      }
    ](name='Inputs')
    }(name='Inputs'),
    jobId?: string(name='JobId'),
    MNSMessageResult?: {
      errorCode?: string(name='ErrorCode'),
      errorMessage?: string(name='ErrorMessage'),
      messageId?: string(name='MessageId'),
    }(name='MNSMessageResult'),
    message?: string(name='Message'),
    percent?: long(name='Percent'),
    pipelineId?: string(name='PipelineId'),
    state?: string(name='State'),
    transcodeOutput?: {
      audio?: {
        bitrate?: string(name='Bitrate'),
        channels?: string(name='Channels'),
        codec?: string(name='Codec'),
        profile?: string(name='Profile'),
        qscale?: string(name='Qscale'),
        samplerate?: string(name='Samplerate'),
        volume?: {
          level?: string(name='Level'),
          method?: string(name='Method'),
        }(name='Volume'),
      }(name='Audio'),
      audioStreamMap?: string(name='AudioStreamMap'),
      clip?: {
        timeSpan?: {
          duration?: string(name='Duration'),
          seek?: string(name='Seek'),
        }(name='TimeSpan'),
      }(name='Clip'),
      container?: {
        format?: string(name='Format'),
      }(name='Container'),
      deWatermark?: string(name='DeWatermark'),
      digiWaterMark?: {
        alpha?: string(name='Alpha'),
        inputFile?: {
          bucket?: string(name='Bucket'),
          location?: string(name='Location'),
          object?: string(name='Object'),
        }(name='InputFile'),
        type?: string(name='Type'),
      }(name='DigiWaterMark'),
      encryption?: {
        id?: string(name='Id'),
        key?: string(name='Key'),
        keyType?: string(name='KeyType'),
        keyUri?: string(name='KeyUri'),
        skipCnt?: string(name='SkipCnt'),
        type?: string(name='Type'),
      }(name='Encryption'),
      m3U8NonStandardSupport?: {
        TS?: {
          md5Support?: boolean(name='Md5Support'),
          sizeSupport?: boolean(name='SizeSupport'),
        }(name='TS'),
      }(name='M3U8NonStandardSupport'),
      mergeConfigUrl?: string(name='MergeConfigUrl'),
      mergeList?: {
        merge?: [ 
        {
          duration?: string(name='Duration'),
          mergeURL?: string(name='MergeURL'),
          roleArn?: string(name='RoleArn'),
          start?: string(name='Start'),
        }
      ](name='Merge')
      }(name='MergeList'),
      muxConfig?: {
        gif?: {
          ditherMode?: string(name='DitherMode'),
          finalDelay?: string(name='FinalDelay'),
          isCustomPalette?: string(name='IsCustomPalette'),
          loop?: string(name='Loop'),
        }(name='Gif'),
        segment?: {
          duration?: string(name='Duration'),
        }(name='Segment'),
      }(name='MuxConfig'),
      outputFile?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
        roleArn?: string(name='RoleArn'),
      }(name='OutputFile'),
      priority?: string(name='Priority'),
      properties?: {
        bitrate?: string(name='Bitrate'),
        duration?: string(name='Duration'),
        fileFormat?: string(name='FileFormat'),
        fileSize?: string(name='FileSize'),
        format?: {
          bitrate?: string(name='Bitrate'),
          duration?: string(name='Duration'),
          formatLongName?: string(name='FormatLongName'),
          formatName?: string(name='FormatName'),
          numPrograms?: string(name='NumPrograms'),
          numStreams?: string(name='NumStreams'),
          size?: string(name='Size'),
          startTime?: string(name='StartTime'),
        }(name='Format'),
        fps?: string(name='Fps'),
        height?: string(name='Height'),
        streams?: {
          audioStreamList?: {
            audioStream?: [ 
            {
              bitrate?: string(name='Bitrate'),
              channelLayout?: string(name='ChannelLayout'),
              channels?: string(name='Channels'),
              codecLongName?: string(name='CodecLongName'),
              codecName?: string(name='CodecName'),
              codecTag?: string(name='CodecTag'),
              codecTagString?: string(name='CodecTagString'),
              codecTimeBase?: string(name='CodecTimeBase'),
              duration?: string(name='Duration'),
              index?: string(name='Index'),
              lang?: string(name='Lang'),
              numFrames?: string(name='NumFrames'),
              sampleFmt?: string(name='SampleFmt'),
              samplerate?: string(name='Samplerate'),
              startTime?: string(name='StartTime'),
              timebase?: string(name='Timebase'),
            }
          ](name='AudioStream')
          }(name='AudioStreamList'),
          subtitleStreamList?: {
            subtitleStream?: [ 
            {
              index?: string(name='Index'),
              lang?: string(name='Lang'),
            }
          ](name='SubtitleStream')
          }(name='SubtitleStreamList'),
          videoStreamList?: {
            videoStream?: [ 
            {
              avgFPS?: string(name='AvgFPS'),
              bitrate?: string(name='Bitrate'),
              codecLongName?: string(name='CodecLongName'),
              codecName?: string(name='CodecName'),
              codecTag?: string(name='CodecTag'),
              codecTagString?: string(name='CodecTagString'),
              codecTimeBase?: string(name='CodecTimeBase'),
              dar?: string(name='Dar'),
              duration?: string(name='Duration'),
              fps?: string(name='Fps'),
              hasBFrames?: string(name='HasBFrames'),
              height?: string(name='Height'),
              index?: string(name='Index'),
              lang?: string(name='Lang'),
              level?: string(name='Level'),
              networkCost?: {
                avgBitrate?: string(name='AvgBitrate'),
                costBandwidth?: string(name='CostBandwidth'),
                preloadTime?: string(name='PreloadTime'),
              }(name='NetworkCost'),
              numFrames?: string(name='NumFrames'),
              pixFmt?: string(name='PixFmt'),
              profile?: string(name='Profile'),
              sar?: string(name='Sar'),
              startTime?: string(name='StartTime'),
              timebase?: string(name='Timebase'),
              width?: string(name='Width'),
            }
          ](name='VideoStream')
          }(name='VideoStreamList'),
        }(name='Streams'),
        width?: string(name='Width'),
      }(name='Properties'),
      rotate?: string(name='Rotate'),
      subtitleConfig?: {
        extSubtitleList?: {
          extSubtitle?: [ 
          {
            charEnc?: string(name='CharEnc'),
            fontName?: string(name='FontName'),
            input?: {
              bucket?: string(name='Bucket'),
              location?: string(name='Location'),
              object?: string(name='Object'),
            }(name='Input'),
          }
        ](name='ExtSubtitle')
        }(name='ExtSubtitleList'),
        subtitleList?: {
          subtitle?: [ 
          {
            map?: string(name='Map'),
          }
        ](name='Subtitle')
        }(name='SubtitleList'),
      }(name='SubtitleConfig'),
      superReso?: {
        isHalfSample?: string(name='IsHalfSample'),
      }(name='SuperReso'),
      templateId?: string(name='TemplateId'),
      transConfig?: {
        adjDarMethod?: string(name='AdjDarMethod'),
        duration?: string(name='Duration'),
        isCheckAudioBitrate?: string(name='IsCheckAudioBitrate'),
        isCheckAudioBitrateFail?: string(name='IsCheckAudioBitrateFail'),
        isCheckReso?: string(name='IsCheckReso'),
        isCheckResoFail?: string(name='IsCheckResoFail'),
        isCheckVideoBitrate?: string(name='IsCheckVideoBitrate'),
        isCheckVideoBitrateFail?: string(name='IsCheckVideoBitrateFail'),
        transMode?: string(name='TransMode'),
      }(name='TransConfig'),
      userData?: string(name='UserData'),
      video?: {
        bitrate?: string(name='Bitrate'),
        bitrateBnd?: {
          max?: string(name='Max'),
          min?: string(name='Min'),
        }(name='BitrateBnd'),
        bufsize?: string(name='Bufsize'),
        codec?: string(name='Codec'),
        crf?: string(name='Crf'),
        crop?: string(name='Crop'),
        degrain?: string(name='Degrain'),
        fps?: string(name='Fps'),
        gop?: string(name='Gop'),
        height?: string(name='Height'),
        maxFps?: string(name='MaxFps'),
        maxrate?: string(name='Maxrate'),
        pad?: string(name='Pad'),
        pixFmt?: string(name='PixFmt'),
        preset?: string(name='Preset'),
        profile?: string(name='Profile'),
        qscale?: string(name='Qscale'),
        scanMode?: string(name='ScanMode'),
        width?: string(name='Width'),
      }(name='Video'),
      videoStreamMap?: string(name='VideoStreamMap'),
      waterMarkConfigUrl?: string(name='WaterMarkConfigUrl'),
      waterMarkList?: {
        waterMark?: [ 
        {
          dx?: string(name='Dx'),
          dy?: string(name='Dy'),
          height?: string(name='Height'),
          inputFile?: {
            bucket?: string(name='Bucket'),
            location?: string(name='Location'),
            object?: string(name='Object'),
          }(name='InputFile'),
          referPos?: string(name='ReferPos'),
          type?: string(name='Type'),
          waterMarkTemplateId?: string(name='WaterMarkTemplateId'),
          width?: string(name='Width'),
        }
      ](name='WaterMark')
      }(name='WaterMarkList'),
    }(name='transcodeOutput'),
  }(name='ComplexJob'),
  requestId?: string(name='RequestId'),
}

model SubmitComplexJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitComplexJobResponseBody(name='body'),
}

async function submitComplexJobWithOptions(request: SubmitComplexJobRequest, runtime: Util.RuntimeOptions): SubmitComplexJobResponse {
  Util.validateModel(request);
  var query = {};
  query["ComplexConfigs"] = request.complexConfigs;
  query["Inputs"] = request.inputs;
  query["OutputBucket"] = request.outputBucket;
  query["OutputLocation"] = request.outputLocation;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PipelineId"] = request.pipelineId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["TranscodeOutput"] = request.transcodeOutput;
  query["UserData"] = request.userData;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SubmitComplexJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitComplexJob(request: SubmitComplexJobRequest): SubmitComplexJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitComplexJobWithOptions(request, runtime);
}

model SubmitCoverJobRequest {
  coverConfig?: string(name='CoverConfig'),
  input?: string(name='Input'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  userData?: string(name='UserData'),
}

model SubmitCoverJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model SubmitCoverJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitCoverJobResponseBody(name='body'),
}

async function submitCoverJobWithOptions(request: SubmitCoverJobRequest, runtime: Util.RuntimeOptions): SubmitCoverJobResponse {
  Util.validateModel(request);
  var query = {};
  query["CoverConfig"] = request.coverConfig;
  query["Input"] = request.input;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PipelineId"] = request.pipelineId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["UserData"] = request.userData;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SubmitCoverJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitCoverJob(request: SubmitCoverJobRequest): SubmitCoverJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitCoverJobWithOptions(request, runtime);
}

model SubmitEditingJobsRequest {
  editingInputs?: string(name='EditingInputs'),
  editingJobOssFileRoleArn?: string(name='EditingJobOssFileRoleArn'),
  editingJobOssFileUid?: long(name='EditingJobOssFileUid'),
  editingJobOutputs?: string(name='EditingJobOutputs'),
  editingJobURL?: string(name='EditingJobURL'),
  outputBucket?: string(name='OutputBucket'),
  outputLocation?: string(name='OutputLocation'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model SubmitEditingJobsResponseBody = {
  jobResultList?: {
    jobResult?: [ 
    {
      code?: string(name='Code'),
      job?: {
        code?: string(name='Code'),
        creationTime?: string(name='CreationTime'),
        editingConfig?: {
          audio?: {
            bitrate?: string(name='Bitrate'),
            channels?: string(name='Channels'),
            codec?: string(name='Codec'),
            profile?: string(name='Profile'),
            qscale?: string(name='Qscale'),
            samplerate?: string(name='Samplerate'),
            volume?: {
              level?: string(name='Level'),
              method?: string(name='Method'),
            }(name='Volume'),
          }(name='Audio'),
          audioStreamMap?: string(name='AudioStreamMap'),
          clip?: {
            timeSpan?: {
              duration?: string(name='Duration'),
              seek?: string(name='Seek'),
            }(name='TimeSpan'),
          }(name='Clip'),
          container?: {
            format?: string(name='Format'),
          }(name='Container'),
          deWatermark?: string(name='DeWatermark'),
          digiWaterMark?: {
            alpha?: string(name='Alpha'),
            inputFile?: {
              bucket?: string(name='Bucket'),
              location?: string(name='Location'),
              object?: string(name='Object'),
            }(name='InputFile'),
            type?: string(name='Type'),
          }(name='DigiWaterMark'),
          editing?: {
            clipList?: {
              clip?: [ 
              {
                effects?: {
                  effect?: [ 
                  {
                    effect?: string(name='Effect'),
                    effectConfig?: string(name='EffectConfig'),
                  }
                ](name='Effect')
                }(name='Effects'),
                id?: string(name='Id'),
                in?: string(name='In'),
                out?: string(name='Out'),
                sourceID?: string(name='SourceID'),
                sourceStrmMap?: string(name='SourceStrmMap'),
                sourceType?: string(name='SourceType'),
                type?: string(name='Type'),
              }
            ](name='Clip')
            }(name='ClipList'),
            timeline?: {
              timelineConfig?: {
                timelineConfigAudio?: {
                  channelLayout?: string(name='ChannelLayout'),
                  channels?: string(name='Channels'),
                  samplerate?: string(name='Samplerate'),
                }(name='TimelineConfigAudio'),
                timelineConfigVideo?: {
                  bgColor?: string(name='BgColor'),
                  fps?: string(name='Fps'),
                  height?: string(name='Height'),
                  isGpuData?: string(name='IsGpuData'),
                  isOneTrackData?: string(name='IsOneTrackData'),
                  reclosePrec?: string(name='ReclosePrec'),
                  renderRatio?: string(name='RenderRatio'),
                  width?: string(name='Width'),
                }(name='TimelineConfigVideo'),
              }(name='TimelineConfig'),
              trackList?: {
                track?: [ 
                {
                  clips?: {
                    clip?: [ 
                    {
                      clipsConfig?: {
                        clipsConfigVideo?: {
                          l?: string(name='L'),
                          t?: string(name='T'),
                        }(name='ClipsConfigVideo'),
                      }(name='ClipsConfig'),
                      in?: string(name='In'),
                      out?: string(name='Out'),
                      clipID?: string(name='clipID'),
                    }
                  ](name='Clip')
                  }(name='Clips'),
                  id?: string(name='Id'),
                  order?: string(name='Order'),
                  type?: string(name='Type'),
                }
              ](name='Track')
              }(name='TrackList'),
            }(name='Timeline'),
          }(name='Editing'),
          encryption?: {
            id?: string(name='Id'),
            key?: string(name='Key'),
            keyType?: string(name='KeyType'),
            keyUri?: string(name='KeyUri'),
            skipCnt?: string(name='SkipCnt'),
            type?: string(name='Type'),
          }(name='Encryption'),
          m3U8NonStandardSupport?: {
            TS?: {
              md5Support?: boolean(name='Md5Support'),
              sizeSupport?: boolean(name='SizeSupport'),
            }(name='TS'),
          }(name='M3U8NonStandardSupport'),
          mergeConfigUrl?: string(name='MergeConfigUrl'),
          mergeList?: {
            merge?: [ 
            {
              duration?: string(name='Duration'),
              mergeURL?: string(name='MergeURL'),
              roleArn?: string(name='RoleArn'),
              start?: string(name='Start'),
            }
          ](name='Merge')
          }(name='MergeList'),
          muxConfig?: {
            gif?: {
              ditherMode?: string(name='DitherMode'),
              finalDelay?: string(name='FinalDelay'),
              isCustomPalette?: string(name='IsCustomPalette'),
              loop?: string(name='Loop'),
            }(name='Gif'),
            segment?: {
              duration?: string(name='Duration'),
            }(name='Segment'),
          }(name='MuxConfig'),
          outputFile?: {
            bucket?: string(name='Bucket'),
            location?: string(name='Location'),
            object?: string(name='Object'),
            roleArn?: string(name='RoleArn'),
          }(name='OutputFile'),
          priority?: string(name='Priority'),
          properties?: {
            bitrate?: string(name='Bitrate'),
            duration?: string(name='Duration'),
            fileFormat?: string(name='FileFormat'),
            fileSize?: string(name='FileSize'),
            format?: {
              bitrate?: string(name='Bitrate'),
              duration?: string(name='Duration'),
              formatLongName?: string(name='FormatLongName'),
              formatName?: string(name='FormatName'),
              numPrograms?: string(name='NumPrograms'),
              numStreams?: string(name='NumStreams'),
              size?: string(name='Size'),
              startTime?: string(name='StartTime'),
            }(name='Format'),
            fps?: string(name='Fps'),
            height?: string(name='Height'),
            streams?: {
              audioStreamList?: {
                audioStream?: [ 
                {
                  bitrate?: string(name='Bitrate'),
                  channelLayout?: string(name='ChannelLayout'),
                  channels?: string(name='Channels'),
                  codecLongName?: string(name='CodecLongName'),
                  codecName?: string(name='CodecName'),
                  codecTag?: string(name='CodecTag'),
                  codecTagString?: string(name='CodecTagString'),
                  codecTimeBase?: string(name='CodecTimeBase'),
                  duration?: string(name='Duration'),
                  index?: string(name='Index'),
                  lang?: string(name='Lang'),
                  numFrames?: string(name='NumFrames'),
                  sampleFmt?: string(name='SampleFmt'),
                  samplerate?: string(name='Samplerate'),
                  startTime?: string(name='StartTime'),
                  timebase?: string(name='Timebase'),
                }
              ](name='AudioStream')
              }(name='AudioStreamList'),
              subtitleStreamList?: {
                subtitleStream?: [ 
                {
                  index?: string(name='Index'),
                  lang?: string(name='Lang'),
                }
              ](name='SubtitleStream')
              }(name='SubtitleStreamList'),
              videoStreamList?: {
                videoStream?: [ 
                {
                  avgFPS?: string(name='AvgFPS'),
                  bitrate?: string(name='Bitrate'),
                  codecLongName?: string(name='CodecLongName'),
                  codecName?: string(name='CodecName'),
                  codecTag?: string(name='CodecTag'),
                  codecTagString?: string(name='CodecTagString'),
                  codecTimeBase?: string(name='CodecTimeBase'),
                  dar?: string(name='Dar'),
                  duration?: string(name='Duration'),
                  fps?: string(name='Fps'),
                  hasBFrames?: string(name='HasBFrames'),
                  height?: string(name='Height'),
                  index?: string(name='Index'),
                  lang?: string(name='Lang'),
                  level?: string(name='Level'),
                  networkCost?: {
                    avgBitrate?: string(name='AvgBitrate'),
                    costBandwidth?: string(name='CostBandwidth'),
                    preloadTime?: string(name='PreloadTime'),
                  }(name='NetworkCost'),
                  numFrames?: string(name='NumFrames'),
                  pixFmt?: string(name='PixFmt'),
                  profile?: string(name='Profile'),
                  sar?: string(name='Sar'),
                  startTime?: string(name='StartTime'),
                  timebase?: string(name='Timebase'),
                  width?: string(name='Width'),
                }
              ](name='VideoStream')
              }(name='VideoStreamList'),
            }(name='Streams'),
            width?: string(name='Width'),
          }(name='Properties'),
          rotate?: string(name='Rotate'),
          subtitleConfig?: {
            extSubtitleList?: {
              extSubtitle?: [ 
              {
                charEnc?: string(name='CharEnc'),
                fontName?: string(name='FontName'),
                input?: {
                  bucket?: string(name='Bucket'),
                  location?: string(name='Location'),
                  object?: string(name='Object'),
                }(name='Input'),
              }
            ](name='ExtSubtitle')
            }(name='ExtSubtitleList'),
            subtitleList?: {
              subtitle?: [ 
              {
                map?: string(name='Map'),
              }
            ](name='Subtitle')
            }(name='SubtitleList'),
          }(name='SubtitleConfig'),
          superReso?: {
            isHalfSample?: string(name='IsHalfSample'),
          }(name='SuperReso'),
          templateId?: string(name='TemplateId'),
          transConfig?: {
            adjDarMethod?: string(name='AdjDarMethod'),
            duration?: string(name='Duration'),
            isCheckAudioBitrate?: string(name='IsCheckAudioBitrate'),
            isCheckAudioBitrateFail?: string(name='IsCheckAudioBitrateFail'),
            isCheckReso?: string(name='IsCheckReso'),
            isCheckResoFail?: string(name='IsCheckResoFail'),
            isCheckVideoBitrate?: string(name='IsCheckVideoBitrate'),
            isCheckVideoBitrateFail?: string(name='IsCheckVideoBitrateFail'),
            transMode?: string(name='TransMode'),
          }(name='TransConfig'),
          userData?: string(name='UserData'),
          video?: {
            bitrate?: string(name='Bitrate'),
            bitrateBnd?: {
              max?: string(name='Max'),
              min?: string(name='Min'),
            }(name='BitrateBnd'),
            bufsize?: string(name='Bufsize'),
            codec?: string(name='Codec'),
            crf?: string(name='Crf'),
            crop?: string(name='Crop'),
            degrain?: string(name='Degrain'),
            fps?: string(name='Fps'),
            gop?: string(name='Gop'),
            height?: string(name='Height'),
            maxFps?: string(name='MaxFps'),
            maxrate?: string(name='Maxrate'),
            pad?: string(name='Pad'),
            pixFmt?: string(name='PixFmt'),
            preset?: string(name='Preset'),
            profile?: string(name='Profile'),
            qscale?: string(name='Qscale'),
            scanMode?: string(name='ScanMode'),
            width?: string(name='Width'),
          }(name='Video'),
          videoStreamMap?: string(name='VideoStreamMap'),
          waterMarkConfigUrl?: string(name='WaterMarkConfigUrl'),
          waterMarkList?: {
            waterMark?: [ 
            {
              dx?: string(name='Dx'),
              dy?: string(name='Dy'),
              height?: string(name='Height'),
              inputFile?: {
                bucket?: string(name='Bucket'),
                location?: string(name='Location'),
                object?: string(name='Object'),
              }(name='InputFile'),
              referPos?: string(name='ReferPos'),
              type?: string(name='Type'),
              waterMarkTemplateId?: string(name='WaterMarkTemplateId'),
              width?: string(name='Width'),
            }
          ](name='WaterMark')
          }(name='WaterMarkList'),
        }(name='EditingConfig'),
        editingInputs?: {
          editingInput?: [ 
          {
            id?: string(name='Id'),
            inputConfig?: {
              deinterlaceMethod?: string(name='DeinterlaceMethod'),
              isNormalSar?: string(name='IsNormalSar'),
            }(name='InputConfig'),
            inputFile?: {
              bucket?: string(name='Bucket'),
              location?: string(name='Location'),
              object?: string(name='Object'),
            }(name='InputFile'),
          }
        ](name='EditingInput')
        }(name='EditingInputs'),
        finishTime?: string(name='FinishTime'),
        jobId?: string(name='JobId'),
        MNSMessageResult?: {
          errorCode?: string(name='ErrorCode'),
          errorMessage?: string(name='ErrorMessage'),
          messageId?: string(name='MessageId'),
        }(name='MNSMessageResult'),
        message?: string(name='Message'),
        percent?: long(name='Percent'),
        pipelineId?: string(name='PipelineId'),
        state?: string(name='State'),
      }(name='Job'),
      message?: string(name='Message'),
      success?: boolean(name='Success'),
    }
  ](name='JobResult')
  }(name='JobResultList'),
  requestId?: string(name='RequestId'),
}

model SubmitEditingJobsResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitEditingJobsResponseBody(name='body'),
}

async function submitEditingJobsWithOptions(request: SubmitEditingJobsRequest, runtime: Util.RuntimeOptions): SubmitEditingJobsResponse {
  Util.validateModel(request);
  var query = {};
  query["EditingInputs"] = request.editingInputs;
  query["EditingJobOssFileRoleArn"] = request.editingJobOssFileRoleArn;
  query["EditingJobOssFileUid"] = request.editingJobOssFileUid;
  query["EditingJobOutputs"] = request.editingJobOutputs;
  query["EditingJobURL"] = request.editingJobURL;
  query["OutputBucket"] = request.outputBucket;
  query["OutputLocation"] = request.outputLocation;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PipelineId"] = request.pipelineId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SubmitEditingJobs',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitEditingJobs(request: SubmitEditingJobsRequest): SubmitEditingJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitEditingJobsWithOptions(request, runtime);
}

model SubmitFacerecogJobRequest {
  facerecogConfig?: string(name='FacerecogConfig'),
  input?: string(name='Input'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  userData?: string(name='UserData'),
}

model SubmitFacerecogJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model SubmitFacerecogJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitFacerecogJobResponseBody(name='body'),
}

async function submitFacerecogJobWithOptions(request: SubmitFacerecogJobRequest, runtime: Util.RuntimeOptions): SubmitFacerecogJobResponse {
  Util.validateModel(request);
  var query = {};
  query["FacerecogConfig"] = request.facerecogConfig;
  query["Input"] = request.input;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PipelineId"] = request.pipelineId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["UserData"] = request.userData;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SubmitFacerecogJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitFacerecogJob(request: SubmitFacerecogJobRequest): SubmitFacerecogJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitFacerecogJobWithOptions(request, runtime);
}

model SubmitFpCompareJobRequest {
  fpDBId?: string(name='FpDBId'),
  masterMedia?: string(name='MasterMedia'),
  matchedFrameStorage?: string(name='MatchedFrameStorage'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  queryMedia?: string(name='QueryMedia'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  userData?: string(name='UserData'),
}

model SubmitFpCompareJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model SubmitFpCompareJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitFpCompareJobResponseBody(name='body'),
}

async function submitFpCompareJobWithOptions(request: SubmitFpCompareJobRequest, runtime: Util.RuntimeOptions): SubmitFpCompareJobResponse {
  Util.validateModel(request);
  var query = {};
  query["FpDBId"] = request.fpDBId;
  query["MasterMedia"] = request.masterMedia;
  query["MatchedFrameStorage"] = request.matchedFrameStorage;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PipelineId"] = request.pipelineId;
  query["QueryMedia"] = request.queryMedia;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["UserData"] = request.userData;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SubmitFpCompareJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitFpCompareJob(request: SubmitFpCompareJobRequest): SubmitFpCompareJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitFpCompareJobWithOptions(request, runtime);
}

model SubmitFpDBDeleteJobRequest {
  delType?: string(name='DelType'),
  fpDBId?: string(name='FpDBId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  userData?: string(name='UserData'),
}

model SubmitFpDBDeleteJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model SubmitFpDBDeleteJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitFpDBDeleteJobResponseBody(name='body'),
}

async function submitFpDBDeleteJobWithOptions(request: SubmitFpDBDeleteJobRequest, runtime: Util.RuntimeOptions): SubmitFpDBDeleteJobResponse {
  Util.validateModel(request);
  var query = {};
  query["DelType"] = request.delType;
  query["FpDBId"] = request.fpDBId;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PipelineId"] = request.pipelineId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["UserData"] = request.userData;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SubmitFpDBDeleteJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitFpDBDeleteJob(request: SubmitFpDBDeleteJobRequest): SubmitFpDBDeleteJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitFpDBDeleteJobWithOptions(request, runtime);
}

model SubmitFpFileDeleteJobRequest {
  fileIds?: string(name='FileIds'),
  fpDBId?: string(name='FpDBId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  userData?: string(name='UserData'),
}

model SubmitFpFileDeleteJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model SubmitFpFileDeleteJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitFpFileDeleteJobResponseBody(name='body'),
}

async function submitFpFileDeleteJobWithOptions(request: SubmitFpFileDeleteJobRequest, runtime: Util.RuntimeOptions): SubmitFpFileDeleteJobResponse {
  Util.validateModel(request);
  var query = {};
  query["FileIds"] = request.fileIds;
  query["FpDBId"] = request.fpDBId;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PipelineId"] = request.pipelineId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["UserData"] = request.userData;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SubmitFpFileDeleteJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitFpFileDeleteJob(request: SubmitFpFileDeleteJobRequest): SubmitFpFileDeleteJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitFpFileDeleteJobWithOptions(request, runtime);
}

model SubmitFpShotJobRequest {
  fpShotConfig?: string(name='FpShotConfig'),
  input?: string(name='Input'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  userData?: string(name='UserData'),
}

model SubmitFpShotJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model SubmitFpShotJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitFpShotJobResponseBody(name='body'),
}

async function submitFpShotJobWithOptions(request: SubmitFpShotJobRequest, runtime: Util.RuntimeOptions): SubmitFpShotJobResponse {
  Util.validateModel(request);
  var query = {};
  query["FpShotConfig"] = request.fpShotConfig;
  query["Input"] = request.input;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PipelineId"] = request.pipelineId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["UserData"] = request.userData;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SubmitFpShotJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitFpShotJob(request: SubmitFpShotJobRequest): SubmitFpShotJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitFpShotJobWithOptions(request, runtime);
}

model SubmitIProductionJobRequest {
  functionName?: string(name='FunctionName'),
  input?: string(name='Input'),
  jobParams?: string(name='JobParams'),
  modelId?: string(name='ModelId'),
  notifyUrl?: string(name='NotifyUrl'),
  output?: string(name='Output'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  scheduleParams?: string(name='ScheduleParams'),
  userData?: string(name='UserData'),
}

model SubmitIProductionJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model SubmitIProductionJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitIProductionJobResponseBody(name='body'),
}

async function submitIProductionJobWithOptions(request: SubmitIProductionJobRequest, runtime: Util.RuntimeOptions): SubmitIProductionJobResponse {
  Util.validateModel(request);
  var query = {};
  query["FunctionName"] = request.functionName;
  query["Input"] = request.input;
  query["JobParams"] = request.jobParams;
  query["ModelId"] = request.modelId;
  query["NotifyUrl"] = request.notifyUrl;
  query["Output"] = request.output;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PipelineId"] = request.pipelineId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["ScheduleParams"] = request.scheduleParams;
  query["UserData"] = request.userData;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SubmitIProductionJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitIProductionJob(request: SubmitIProductionJobRequest): SubmitIProductionJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitIProductionJobWithOptions(request, runtime);
}

model SubmitImageQualityJobRequest {
  input?: string(name='Input'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  userData?: string(name='UserData'),
}

model SubmitImageQualityJobResponseBody = {
  imageQualityJob?: {
    creationTime?: string(name='CreationTime'),
    input?: {
      bucket?: string(name='Bucket'),
      location?: string(name='Location'),
      object?: string(name='Object'),
      url?: string(name='Url'),
    }(name='Input'),
    jobId?: string(name='JobId'),
    pipelineId?: string(name='PipelineId'),
    result?: {
      code?: string(name='Code'),
      message?: string(name='Message'),
      score?: string(name='Score'),
    }(name='Result'),
    state?: string(name='State'),
    userData?: string(name='UserData'),
  }(name='ImageQualityJob'),
  requestId?: string(name='RequestId'),
}

model SubmitImageQualityJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitImageQualityJobResponseBody(name='body'),
}

async function submitImageQualityJobWithOptions(request: SubmitImageQualityJobRequest, runtime: Util.RuntimeOptions): SubmitImageQualityJobResponse {
  Util.validateModel(request);
  var query = {};
  query["Input"] = request.input;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PipelineId"] = request.pipelineId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["UserData"] = request.userData;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SubmitImageQualityJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitImageQualityJob(request: SubmitImageQualityJobRequest): SubmitImageQualityJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitImageQualityJobWithOptions(request, runtime);
}

model SubmitImageSearchJobRequest {
  config?: string(name='Config'),
  fpDBId?: string(name='FpDBId'),
  inputImage?: string(name='InputImage'),
  inputVideo?: string(name='InputVideo'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  userData?: string(name='UserData'),
}

model SubmitImageSearchJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model SubmitImageSearchJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitImageSearchJobResponseBody(name='body'),
}

async function submitImageSearchJobWithOptions(request: SubmitImageSearchJobRequest, runtime: Util.RuntimeOptions): SubmitImageSearchJobResponse {
  Util.validateModel(request);
  var query = {};
  query["Config"] = request.config;
  query["FpDBId"] = request.fpDBId;
  query["InputImage"] = request.inputImage;
  query["InputVideo"] = request.inputVideo;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PipelineId"] = request.pipelineId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["UserData"] = request.userData;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SubmitImageSearchJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitImageSearchJob(request: SubmitImageSearchJobRequest): SubmitImageSearchJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitImageSearchJobWithOptions(request, runtime);
}

model SubmitInferenceJobRequest {
  input?: string(name='Input'),
  modelType?: string(name='ModelType'),
  serverName?: string(name='ServerName'),
}

model SubmitInferenceJobResponseBody = {
  code?: string(name='Code'),
  jobId?: string(name='JobId'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  testId?: string(name='TestId'),
}

model SubmitInferenceJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitInferenceJobResponseBody(name='body'),
}

async function submitInferenceJobWithOptions(request: SubmitInferenceJobRequest, runtime: Util.RuntimeOptions): SubmitInferenceJobResponse {
  Util.validateModel(request);
  var query = {};
  query["Input"] = request.input;
  query["ModelType"] = request.modelType;
  query["ServerName"] = request.serverName;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SubmitInferenceJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitInferenceJob(request: SubmitInferenceJobRequest): SubmitInferenceJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitInferenceJobWithOptions(request, runtime);
}

model SubmitInnerJobRequest {
  config?: string(name='Config'),
  images?: string(name='Images'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  uid?: long(name='Uid'),
  video?: string(name='Video'),
}

model SubmitInnerJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model SubmitInnerJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitInnerJobResponseBody(name='body'),
}

async function submitInnerJobWithOptions(request: SubmitInnerJobRequest, runtime: Util.RuntimeOptions): SubmitInnerJobResponse {
  Util.validateModel(request);
  var query = {};
  query["Config"] = request.config;
  query["Images"] = request.images;
  query["OwnerId"] = request.ownerId;
  query["PipelineId"] = request.pipelineId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["Uid"] = request.uid;
  query["Video"] = request.video;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SubmitInnerJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitInnerJob(request: SubmitInnerJobRequest): SubmitInnerJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitInnerJobWithOptions(request, runtime);
}

model SubmitJobsRequest {
  input?: string(name='Input'),
  outputBucket?: string(name='OutputBucket'),
  outputLocation?: string(name='OutputLocation'),
  outputs?: string(name='Outputs'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model SubmitJobsResponseBody = {
  jobResultList?: {
    jobResult?: [ 
    {
      code?: string(name='Code'),
      job?: {
        code?: string(name='Code'),
        creationTime?: string(name='CreationTime'),
        finishTime?: string(name='FinishTime'),
        input?: {
          bucket?: string(name='Bucket'),
          location?: string(name='Location'),
          object?: string(name='Object'),
        }(name='Input'),
        jobId?: string(name='JobId'),
        MNSMessageResult?: {
          errorCode?: string(name='ErrorCode'),
          errorMessage?: string(name='ErrorMessage'),
          messageId?: string(name='MessageId'),
        }(name='MNSMessageResult'),
        message?: string(name='Message'),
        output?: {
          amixList?: {
            amix?: [ 
            {
              amixURL?: string(name='AmixURL'),
              duration?: string(name='Duration'),
              map?: string(name='Map'),
              mixDurMode?: string(name='MixDurMode'),
              start?: string(name='Start'),
            }
          ](name='Amix')
          }(name='AmixList'),
          audio?: {
            bitrate?: string(name='Bitrate'),
            channels?: string(name='Channels'),
            codec?: string(name='Codec'),
            profile?: string(name='Profile'),
            qscale?: string(name='Qscale'),
            samplerate?: string(name='Samplerate'),
            volume?: {
              level?: string(name='Level'),
              method?: string(name='Method'),
            }(name='Volume'),
          }(name='Audio'),
          audioStreamMap?: string(name='AudioStreamMap'),
          clip?: {
            timeSpan?: {
              duration?: string(name='Duration'),
              seek?: string(name='Seek'),
            }(name='TimeSpan'),
          }(name='Clip'),
          container?: {
            format?: string(name='Format'),
          }(name='Container'),
          deWatermark?: string(name='DeWatermark'),
          digiWaterMark?: {
            alpha?: string(name='Alpha'),
            inputFile?: {
              bucket?: string(name='Bucket'),
              location?: string(name='Location'),
              object?: string(name='Object'),
            }(name='InputFile'),
            type?: string(name='Type'),
          }(name='DigiWaterMark'),
          encryption?: {
            id?: string(name='Id'),
            key?: string(name='Key'),
            keyType?: string(name='KeyType'),
            keyUri?: string(name='KeyUri'),
            skipCnt?: string(name='SkipCnt'),
            type?: string(name='Type'),
          }(name='Encryption'),
          m3U8NonStandardSupport?: {
            TS?: {
              md5Support?: boolean(name='Md5Support'),
              sizeSupport?: boolean(name='SizeSupport'),
            }(name='TS'),
          }(name='M3U8NonStandardSupport'),
          mergeConfigUrl?: string(name='MergeConfigUrl'),
          mergeList?: {
            merge?: [ 
            {
              duration?: string(name='Duration'),
              mergeURL?: string(name='MergeURL'),
              roleArn?: string(name='RoleArn'),
              start?: string(name='Start'),
            }
          ](name='Merge')
          }(name='MergeList'),
          muxConfig?: {
            gif?: {
              ditherMode?: string(name='DitherMode'),
              finalDelay?: string(name='FinalDelay'),
              isCustomPalette?: string(name='IsCustomPalette'),
              loop?: string(name='Loop'),
            }(name='Gif'),
            segment?: {
              duration?: string(name='Duration'),
            }(name='Segment'),
            webp?: {
              loop?: string(name='Loop'),
            }(name='Webp'),
          }(name='MuxConfig'),
          openingList?: {
            opening?: [ 
            {
              height?: string(name='Height'),
              start?: string(name='Start'),
              width?: string(name='Width'),
              openUrl?: string(name='openUrl'),
            }
          ](name='Opening')
          }(name='OpeningList'),
          outSubtitleList?: {
            outSubtitle?: [ 
            {
              map?: string(name='Map'),
              message?: string(name='Message'),
              outSubtitleFile?: {
                bucket?: string(name='Bucket'),
                location?: string(name='Location'),
                object?: string(name='Object'),
                roleArn?: string(name='RoleArn'),
              }(name='OutSubtitleFile'),
              success?: boolean(name='Success'),
            }
          ](name='OutSubtitle')
          }(name='OutSubtitleList'),
          outputFile?: {
            bucket?: string(name='Bucket'),
            location?: string(name='Location'),
            object?: string(name='Object'),
            roleArn?: string(name='RoleArn'),
          }(name='OutputFile'),
          priority?: string(name='Priority'),
          properties?: {
            bitrate?: string(name='Bitrate'),
            duration?: string(name='Duration'),
            fileFormat?: string(name='FileFormat'),
            fileSize?: string(name='FileSize'),
            format?: {
              bitrate?: string(name='Bitrate'),
              duration?: string(name='Duration'),
              formatLongName?: string(name='FormatLongName'),
              formatName?: string(name='FormatName'),
              numPrograms?: string(name='NumPrograms'),
              numStreams?: string(name='NumStreams'),
              size?: string(name='Size'),
              startTime?: string(name='StartTime'),
            }(name='Format'),
            fps?: string(name='Fps'),
            height?: string(name='Height'),
            streams?: {
              audioStreamList?: {
                audioStream?: [ 
                {
                  bitrate?: string(name='Bitrate'),
                  channelLayout?: string(name='ChannelLayout'),
                  channels?: string(name='Channels'),
                  codecLongName?: string(name='CodecLongName'),
                  codecName?: string(name='CodecName'),
                  codecTag?: string(name='CodecTag'),
                  codecTagString?: string(name='CodecTagString'),
                  codecTimeBase?: string(name='CodecTimeBase'),
                  duration?: string(name='Duration'),
                  index?: string(name='Index'),
                  lang?: string(name='Lang'),
                  numFrames?: string(name='NumFrames'),
                  sampleFmt?: string(name='SampleFmt'),
                  samplerate?: string(name='Samplerate'),
                  startTime?: string(name='StartTime'),
                  timebase?: string(name='Timebase'),
                }
              ](name='AudioStream')
              }(name='AudioStreamList'),
              subtitleStreamList?: {
                subtitleStream?: [ 
                {
                  index?: string(name='Index'),
                  lang?: string(name='Lang'),
                }
              ](name='SubtitleStream')
              }(name='SubtitleStreamList'),
              videoStreamList?: {
                videoStream?: [ 
                {
                  avgFPS?: string(name='AvgFPS'),
                  bitrate?: string(name='Bitrate'),
                  codecLongName?: string(name='CodecLongName'),
                  codecName?: string(name='CodecName'),
                  codecTag?: string(name='CodecTag'),
                  codecTagString?: string(name='CodecTagString'),
                  codecTimeBase?: string(name='CodecTimeBase'),
                  dar?: string(name='Dar'),
                  duration?: string(name='Duration'),
                  fps?: string(name='Fps'),
                  hasBFrames?: string(name='HasBFrames'),
                  height?: string(name='Height'),
                  index?: string(name='Index'),
                  lang?: string(name='Lang'),
                  level?: string(name='Level'),
                  networkCost?: {
                    avgBitrate?: string(name='AvgBitrate'),
                    costBandwidth?: string(name='CostBandwidth'),
                    preloadTime?: string(name='PreloadTime'),
                  }(name='NetworkCost'),
                  numFrames?: string(name='NumFrames'),
                  pixFmt?: string(name='PixFmt'),
                  profile?: string(name='Profile'),
                  sar?: string(name='Sar'),
                  startTime?: string(name='StartTime'),
                  timebase?: string(name='Timebase'),
                  width?: string(name='Width'),
                }
              ](name='VideoStream')
              }(name='VideoStreamList'),
            }(name='Streams'),
            width?: string(name='Width'),
          }(name='Properties'),
          rotate?: string(name='Rotate'),
          subtitleConfig?: {
            extSubtitleList?: {
              extSubtitle?: [ 
              {
                charEnc?: string(name='CharEnc'),
                fontName?: string(name='FontName'),
                input?: {
                  bucket?: string(name='Bucket'),
                  location?: string(name='Location'),
                  object?: string(name='Object'),
                }(name='Input'),
              }
            ](name='ExtSubtitle')
            }(name='ExtSubtitleList'),
            subtitleList?: {
              subtitle?: [ 
              {
                map?: string(name='Map'),
              }
            ](name='Subtitle')
            }(name='SubtitleList'),
          }(name='SubtitleConfig'),
          superReso?: {
            isHalfSample?: string(name='IsHalfSample'),
          }(name='SuperReso'),
          tailSlateList?: {
            tailSlate?: [ 
            {
              bgColor?: string(name='BgColor'),
              blendDuration?: string(name='BlendDuration'),
              height?: string(name='Height'),
              isMergeAudio?: boolean(name='IsMergeAudio'),
              start?: string(name='Start'),
              tailUrl?: string(name='TailUrl'),
              width?: string(name='Width'),
            }
          ](name='TailSlate')
          }(name='TailSlateList'),
          templateId?: string(name='TemplateId'),
          transConfig?: {
            adjDarMethod?: string(name='AdjDarMethod'),
            isCheckAudioBitrate?: string(name='IsCheckAudioBitrate'),
            isCheckAudioBitrateFail?: string(name='IsCheckAudioBitrateFail'),
            isCheckReso?: string(name='IsCheckReso'),
            isCheckResoFail?: string(name='IsCheckResoFail'),
            isCheckVideoBitrate?: string(name='IsCheckVideoBitrate'),
            isCheckVideoBitrateFail?: string(name='IsCheckVideoBitrateFail'),
            transMode?: string(name='TransMode'),
          }(name='TransConfig'),
          userData?: string(name='UserData'),
          video?: {
            bitrate?: string(name='Bitrate'),
            bitrateBnd?: {
              max?: string(name='Max'),
              min?: string(name='Min'),
            }(name='BitrateBnd'),
            bufsize?: string(name='Bufsize'),
            codec?: string(name='Codec'),
            crf?: string(name='Crf'),
            crop?: string(name='Crop'),
            degrain?: string(name='Degrain'),
            fps?: string(name='Fps'),
            gop?: string(name='Gop'),
            height?: string(name='Height'),
            maxFps?: string(name='MaxFps'),
            maxrate?: string(name='Maxrate'),
            pad?: string(name='Pad'),
            pixFmt?: string(name='PixFmt'),
            preset?: string(name='Preset'),
            profile?: string(name='Profile'),
            qscale?: string(name='Qscale'),
            resoPriority?: string(name='ResoPriority'),
            scanMode?: string(name='ScanMode'),
            width?: string(name='Width'),
          }(name='Video'),
          videoStreamMap?: string(name='VideoStreamMap'),
          waterMarkConfigUrl?: string(name='WaterMarkConfigUrl'),
          waterMarkList?: {
            waterMark?: [ 
            {
              dx?: string(name='Dx'),
              dy?: string(name='Dy'),
              height?: string(name='Height'),
              inputFile?: {
                bucket?: string(name='Bucket'),
                location?: string(name='Location'),
                object?: string(name='Object'),
              }(name='InputFile'),
              referPos?: string(name='ReferPos'),
              type?: string(name='Type'),
              waterMarkTemplateId?: string(name='WaterMarkTemplateId'),
              width?: string(name='Width'),
            }
          ](name='WaterMark')
          }(name='WaterMarkList'),
        }(name='Output'),
        percent?: long(name='Percent'),
        pipelineId?: string(name='PipelineId'),
        state?: string(name='State'),
      }(name='Job'),
      message?: string(name='Message'),
      success?: boolean(name='Success'),
    }
  ](name='JobResult')
  }(name='JobResultList'),
  requestId?: string(name='RequestId'),
}

model SubmitJobsResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitJobsResponseBody(name='body'),
}

async function submitJobsWithOptions(request: SubmitJobsRequest, runtime: Util.RuntimeOptions): SubmitJobsResponse {
  Util.validateModel(request);
  var query = {};
  query["Input"] = request.input;
  query["OutputBucket"] = request.outputBucket;
  query["OutputLocation"] = request.outputLocation;
  query["Outputs"] = request.outputs;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PipelineId"] = request.pipelineId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SubmitJobs',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitJobs(request: SubmitJobsRequest): SubmitJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitJobsWithOptions(request, runtime);
}

model SubmitMCJobRequest {
  censorConfig?: string(name='CensorConfig'),
  images?: string(name='Images'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  texts?: string(name='Texts'),
  userData?: string(name='UserData'),
  video?: string(name='Video'),
}

model SubmitMCJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model SubmitMCJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitMCJobResponseBody(name='body'),
}

async function submitMCJobWithOptions(request: SubmitMCJobRequest, runtime: Util.RuntimeOptions): SubmitMCJobResponse {
  Util.validateModel(request);
  var query = {};
  query["CensorConfig"] = request.censorConfig;
  query["Images"] = request.images;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PipelineId"] = request.pipelineId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["Texts"] = request.texts;
  query["UserData"] = request.userData;
  query["Video"] = request.video;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SubmitMCJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitMCJob(request: SubmitMCJobRequest): SubmitMCJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitMCJobWithOptions(request, runtime);
}

model SubmitMcuJobRequest {
  input?: string(name='Input'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  template?: string(name='Template'),
  templateId?: string(name='TemplateId'),
  userData?: string(name='UserData'),
}

model SubmitMcuJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model SubmitMcuJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitMcuJobResponseBody(name='body'),
}

async function submitMcuJobWithOptions(request: SubmitMcuJobRequest, runtime: Util.RuntimeOptions): SubmitMcuJobResponse {
  Util.validateModel(request);
  var query = {};
  query["Input"] = request.input;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PipelineId"] = request.pipelineId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["Template"] = request.template;
  query["TemplateId"] = request.templateId;
  query["UserData"] = request.userData;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SubmitMcuJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitMcuJob(request: SubmitMcuJobRequest): SubmitMcuJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitMcuJobWithOptions(request, runtime);
}

model SubmitMediaCensorJobRequest {
  barrages?: string(name='Barrages'),
  coverImages?: string(name='CoverImages'),
  description?: string(name='Description'),
  externalUrl?: string(name='ExternalUrl'),
  input?: string(name='Input'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  title?: string(name='Title'),
  userData?: string(name='UserData'),
  videoCensorConfig?: string(name='VideoCensorConfig'),
}

model SubmitMediaCensorJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model SubmitMediaCensorJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitMediaCensorJobResponseBody(name='body'),
}

async function submitMediaCensorJobWithOptions(request: SubmitMediaCensorJobRequest, runtime: Util.RuntimeOptions): SubmitMediaCensorJobResponse {
  Util.validateModel(request);
  var query = {};
  query["Barrages"] = request.barrages;
  query["CoverImages"] = request.coverImages;
  query["Description"] = request.description;
  query["ExternalUrl"] = request.externalUrl;
  query["Input"] = request.input;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PipelineId"] = request.pipelineId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["Title"] = request.title;
  query["UserData"] = request.userData;
  query["VideoCensorConfig"] = request.videoCensorConfig;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SubmitMediaCensorJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitMediaCensorJob(request: SubmitMediaCensorJobRequest): SubmitMediaCensorJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitMediaCensorJobWithOptions(request, runtime);
}

model SubmitMediaDetailJobRequest {
  input?: string(name='Input'),
  mediaDetailConfig?: string(name='MediaDetailConfig'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  userData?: string(name='UserData'),
}

model SubmitMediaDetailJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model SubmitMediaDetailJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitMediaDetailJobResponseBody(name='body'),
}

async function submitMediaDetailJobWithOptions(request: SubmitMediaDetailJobRequest, runtime: Util.RuntimeOptions): SubmitMediaDetailJobResponse {
  Util.validateModel(request);
  var query = {};
  query["Input"] = request.input;
  query["MediaDetailConfig"] = request.mediaDetailConfig;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PipelineId"] = request.pipelineId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["UserData"] = request.userData;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SubmitMediaDetailJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitMediaDetailJob(request: SubmitMediaDetailJobRequest): SubmitMediaDetailJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitMediaDetailJobWithOptions(request, runtime);
}

model SubmitMediaFpDeleteJobRequest {
  fpDBId?: string(name='FpDBId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  primaryKey?: string(name='PrimaryKey'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  userData?: string(name='UserData'),
}

model SubmitMediaFpDeleteJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model SubmitMediaFpDeleteJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitMediaFpDeleteJobResponseBody(name='body'),
}

async function submitMediaFpDeleteJobWithOptions(request: SubmitMediaFpDeleteJobRequest, runtime: Util.RuntimeOptions): SubmitMediaFpDeleteJobResponse {
  Util.validateModel(request);
  var query = {};
  query["FpDBId"] = request.fpDBId;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PipelineId"] = request.pipelineId;
  query["PrimaryKey"] = request.primaryKey;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["UserData"] = request.userData;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SubmitMediaFpDeleteJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitMediaFpDeleteJob(request: SubmitMediaFpDeleteJobRequest): SubmitMediaFpDeleteJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitMediaFpDeleteJobWithOptions(request, runtime);
}

model SubmitMediaInfoJobRequest {
  async?: boolean(name='Async'),
  input?: string(name='Input'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  userData?: string(name='UserData'),
}

model SubmitMediaInfoJobResponseBody = {
  mediaInfoJob?: {
    async?: boolean(name='Async'),
    code?: string(name='Code'),
    creationTime?: string(name='CreationTime'),
    input?: {
      bucket?: string(name='Bucket'),
      location?: string(name='Location'),
      object?: string(name='Object'),
    }(name='Input'),
    jobId?: string(name='JobId'),
    MNSMessageResult?: {
      errorCode?: string(name='ErrorCode'),
      errorMessage?: string(name='ErrorMessage'),
      messageId?: string(name='MessageId'),
    }(name='MNSMessageResult'),
    message?: string(name='Message'),
    pipelineId?: string(name='PipelineId'),
    properties?: {
      bitrate?: string(name='Bitrate'),
      duration?: string(name='Duration'),
      fileFormat?: string(name='FileFormat'),
      fileSize?: string(name='FileSize'),
      format?: {
        bitrate?: string(name='Bitrate'),
        duration?: string(name='Duration'),
        formatLongName?: string(name='FormatLongName'),
        formatName?: string(name='FormatName'),
        numPrograms?: string(name='NumPrograms'),
        numStreams?: string(name='NumStreams'),
        size?: string(name='Size'),
        startTime?: string(name='StartTime'),
      }(name='Format'),
      fps?: string(name='Fps'),
      height?: string(name='Height'),
      streams?: {
        audioStreamList?: {
          audioStream?: [ 
          {
            bitrate?: string(name='Bitrate'),
            channelLayout?: string(name='ChannelLayout'),
            channels?: string(name='Channels'),
            codecLongName?: string(name='CodecLongName'),
            codecName?: string(name='CodecName'),
            codecTag?: string(name='CodecTag'),
            codecTagString?: string(name='CodecTagString'),
            codecTimeBase?: string(name='CodecTimeBase'),
            duration?: string(name='Duration'),
            index?: string(name='Index'),
            lang?: string(name='Lang'),
            numFrames?: string(name='NumFrames'),
            sampleFmt?: string(name='SampleFmt'),
            samplerate?: string(name='Samplerate'),
            startTime?: string(name='StartTime'),
            timebase?: string(name='Timebase'),
          }
        ](name='AudioStream')
        }(name='AudioStreamList'),
        subtitleStreamList?: {
          subtitleStream?: [ 
          {
            codecLongName?: string(name='CodecLongName'),
            codecName?: string(name='CodecName'),
            codecTag?: string(name='CodecTag'),
            codecTagString?: string(name='CodecTagString'),
            codecTimeBase?: string(name='CodecTimeBase'),
            duration?: string(name='Duration'),
            index?: string(name='Index'),
            lang?: string(name='Lang'),
            startTime?: string(name='StartTime'),
            timebase?: string(name='Timebase'),
          }
        ](name='SubtitleStream')
        }(name='SubtitleStreamList'),
        videoStreamList?: {
          videoStream?: [ 
          {
            avgFPS?: string(name='AvgFPS'),
            bitrate?: string(name='Bitrate'),
            codecLongName?: string(name='CodecLongName'),
            codecName?: string(name='CodecName'),
            codecTag?: string(name='CodecTag'),
            codecTagString?: string(name='CodecTagString'),
            codecTimeBase?: string(name='CodecTimeBase'),
            colorPrimaries?: string(name='ColorPrimaries'),
            colorRange?: string(name='ColorRange'),
            colorTransfer?: string(name='ColorTransfer'),
            dar?: string(name='Dar'),
            duration?: string(name='Duration'),
            fps?: string(name='Fps'),
            hasBFrames?: string(name='HasBFrames'),
            height?: string(name='Height'),
            index?: string(name='Index'),
            lang?: string(name='Lang'),
            level?: string(name='Level'),
            networkCost?: {
              avgBitrate?: string(name='AvgBitrate'),
              costBandwidth?: string(name='CostBandwidth'),
              preloadTime?: string(name='PreloadTime'),
            }(name='NetworkCost'),
            numFrames?: string(name='NumFrames'),
            pixFmt?: string(name='PixFmt'),
            profile?: string(name='Profile'),
            rotate?: string(name='Rotate'),
            sar?: string(name='Sar'),
            startTime?: string(name='StartTime'),
            timebase?: string(name='Timebase'),
            width?: string(name='Width'),
          }
        ](name='VideoStream')
        }(name='VideoStreamList'),
      }(name='Streams'),
      width?: string(name='Width'),
    }(name='Properties'),
    state?: string(name='State'),
    userData?: string(name='UserData'),
  }(name='MediaInfoJob'),
  requestId?: string(name='RequestId'),
}

model SubmitMediaInfoJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitMediaInfoJobResponseBody(name='body'),
}

async function submitMediaInfoJobWithOptions(request: SubmitMediaInfoJobRequest, runtime: Util.RuntimeOptions): SubmitMediaInfoJobResponse {
  Util.validateModel(request);
  var query = {};
  query["Async"] = request.async;
  query["Input"] = request.input;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PipelineId"] = request.pipelineId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["UserData"] = request.userData;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SubmitMediaInfoJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitMediaInfoJob(request: SubmitMediaInfoJobRequest): SubmitMediaInfoJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitMediaInfoJobWithOptions(request, runtime);
}

model SubmitOssFileCopyJobRequest {
  notify?: string(name='Notify'),
  region?: string(name='Region'),
  sourceStorage?: {
    bucket?: string(name='Bucket'),
    bucketOwnerId?: long(name='BucketOwnerId'),
    fileNames?: string(name='FileNames'),
    objectPrefix?: string(name='ObjectPrefix'),
    objectRoleName?: string(name='ObjectRoleName'),
    s3AccessKey?: string(name='S3AccessKey'),
    s3Endpoint?: string(name='S3Endpoint'),
    s3Provider?: string(name='S3Provider'),
    s3SecretKey?: string(name='S3SecretKey'),
    s3SessionToken?: string(name='S3SessionToken'),
  }(name='SourceStorage'),
  targetStorage?: {
    bucket?: string(name='Bucket'),
    bucketOwnerId?: long(name='BucketOwnerId'),
    objectPrefix?: string(name='ObjectPrefix'),
    objectRoleName?: string(name='ObjectRoleName'),
    s3AccessKey?: string(name='S3AccessKey'),
    s3Endpoint?: string(name='S3Endpoint'),
    s3Provider?: string(name='S3Provider'),
    s3SecretKey?: string(name='S3SecretKey'),
    s3SessionToken?: string(name='S3SessionToken'),
  }(name='TargetStorage'),
  userData?: string(name='UserData'),
}

model SubmitOssFileCopyJobShrinkRequest {
  notify?: string(name='Notify'),
  region?: string(name='Region'),
  sourceStorageShrink?: string(name='SourceStorage'),
  targetStorageShrink?: string(name='TargetStorage'),
  userData?: string(name='UserData'),
}

model SubmitOssFileCopyJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model SubmitOssFileCopyJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitOssFileCopyJobResponseBody(name='body'),
}

async function submitOssFileCopyJobWithOptions(tmpReq: SubmitOssFileCopyJobRequest, runtime: Util.RuntimeOptions): SubmitOssFileCopyJobResponse {
  Util.validateModel(tmpReq);
  var request = new SubmitOssFileCopyJobShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.sourceStorage)) {
    request.sourceStorageShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sourceStorage, 'SourceStorage', 'json');
  }
  if (!Util.isUnset(tmpReq.targetStorage)) {
    request.targetStorageShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.targetStorage, 'TargetStorage', 'json');
  }
  var query = {};
  query["Notify"] = request.notify;
  query["Region"] = request.region;
  query["SourceStorage"] = request.sourceStorageShrink;
  query["TargetStorage"] = request.targetStorageShrink;
  query["UserData"] = request.userData;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SubmitOssFileCopyJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitOssFileCopyJob(request: SubmitOssFileCopyJobRequest): SubmitOssFileCopyJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitOssFileCopyJobWithOptions(request, runtime);
}

model SubmitPornJobRequest {
  input?: string(name='Input'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  pornConfig?: string(name='PornConfig'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  userData?: string(name='UserData'),
}

model SubmitPornJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model SubmitPornJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitPornJobResponseBody(name='body'),
}

async function submitPornJobWithOptions(request: SubmitPornJobRequest, runtime: Util.RuntimeOptions): SubmitPornJobResponse {
  Util.validateModel(request);
  var query = {};
  query["Input"] = request.input;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PipelineId"] = request.pipelineId;
  query["PornConfig"] = request.pornConfig;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["UserData"] = request.userData;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SubmitPornJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitPornJob(request: SubmitPornJobRequest): SubmitPornJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitPornJobWithOptions(request, runtime);
}

model SubmitSmarttagJobRequest {
  content?: string(name='Content'),
  contentAddr?: string(name='ContentAddr'),
  contentType?: string(name='ContentType'),
  input?: string(name='Input'),
  notifyUrl?: string(name='NotifyUrl'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  params?: string(name='Params'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  templateId?: string(name='TemplateId'),
  title?: string(name='Title'),
  userData?: string(name='UserData'),
}

model SubmitSmarttagJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model SubmitSmarttagJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitSmarttagJobResponseBody(name='body'),
}

async function submitSmarttagJobWithOptions(request: SubmitSmarttagJobRequest, runtime: Util.RuntimeOptions): SubmitSmarttagJobResponse {
  Util.validateModel(request);
  var query = {};
  query["Content"] = request.content;
  query["ContentAddr"] = request.contentAddr;
  query["ContentType"] = request.contentType;
  query["Input"] = request.input;
  query["NotifyUrl"] = request.notifyUrl;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["Params"] = request.params;
  query["PipelineId"] = request.pipelineId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["TemplateId"] = request.templateId;
  query["Title"] = request.title;
  query["UserData"] = request.userData;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SubmitSmarttagJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitSmarttagJob(request: SubmitSmarttagJobRequest): SubmitSmarttagJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitSmarttagJobWithOptions(request, runtime);
}

model SubmitSnapshotJobRequest {
  input?: string(name='Input'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  snapshotConfig?: string(name='SnapshotConfig'),
  userData?: string(name='UserData'),
}

model SubmitSnapshotJobResponseBody = {
  requestId?: string(name='RequestId'),
  snapshotJob?: {
    code?: string(name='Code'),
    count?: string(name='Count'),
    creationTime?: string(name='CreationTime'),
    id?: string(name='Id'),
    input?: {
      bucket?: string(name='Bucket'),
      location?: string(name='Location'),
      object?: string(name='Object'),
      roleArn?: string(name='RoleArn'),
    }(name='Input'),
    MNSMessageResult?: {
      errorCode?: string(name='ErrorCode'),
      errorMessage?: string(name='ErrorMessage'),
      messageId?: string(name='MessageId'),
    }(name='MNSMessageResult'),
    message?: string(name='Message'),
    pipelineId?: string(name='PipelineId'),
    snapshotConfig?: {
      frameType?: string(name='FrameType'),
      height?: string(name='Height'),
      interval?: string(name='Interval'),
      num?: string(name='Num'),
      outputFile?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
        roleArn?: string(name='RoleArn'),
      }(name='OutputFile'),
      tileOut?: {
        cellHeight?: string(name='CellHeight'),
        cellSelStep?: string(name='CellSelStep'),
        cellWidth?: string(name='CellWidth'),
        color?: string(name='Color'),
        columns?: string(name='Columns'),
        isKeepCellPic?: string(name='IsKeepCellPic'),
        lines?: string(name='Lines'),
        margin?: string(name='Margin'),
        padding?: string(name='Padding'),
      }(name='TileOut'),
      tileOutputFile?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
        roleArn?: string(name='RoleArn'),
      }(name='TileOutputFile'),
      time?: string(name='Time'),
      width?: string(name='Width'),
    }(name='SnapshotConfig'),
    state?: string(name='State'),
    tileCount?: string(name='TileCount'),
    userData?: string(name='UserData'),
  }(name='SnapshotJob'),
}

model SubmitSnapshotJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitSnapshotJobResponseBody(name='body'),
}

async function submitSnapshotJobWithOptions(request: SubmitSnapshotJobRequest, runtime: Util.RuntimeOptions): SubmitSnapshotJobResponse {
  Util.validateModel(request);
  var query = {};
  query["Input"] = request.input;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PipelineId"] = request.pipelineId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["SnapshotConfig"] = request.snapshotConfig;
  query["UserData"] = request.userData;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SubmitSnapshotJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitSnapshotJob(request: SubmitSnapshotJobRequest): SubmitSnapshotJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitSnapshotJobWithOptions(request, runtime);
}

model SubmitSubtitleJobRequest {
  inputConfig?: string(name='InputConfig'),
  outputConfig?: string(name='OutputConfig'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  userData?: string(name='UserData'),
}

model SubmitSubtitleJobResponseBody = {
  requestId?: string(name='RequestId'),
  subtitleJob?: {
    inputConfig?: string(name='InputConfig'),
    jobId?: string(name='JobId'),
    outputConfig?: string(name='OutputConfig'),
    state?: string(name='State'),
    userData?: string(name='UserData'),
  }(name='SubtitleJob'),
}

model SubmitSubtitleJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitSubtitleJobResponseBody(name='body'),
}

async function submitSubtitleJobWithOptions(request: SubmitSubtitleJobRequest, runtime: Util.RuntimeOptions): SubmitSubtitleJobResponse {
  Util.validateModel(request);
  var query = {};
  query["InputConfig"] = request.inputConfig;
  query["OutputConfig"] = request.outputConfig;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PipelineId"] = request.pipelineId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["UserData"] = request.userData;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SubmitSubtitleJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitSubtitleJob(request: SubmitSubtitleJobRequest): SubmitSubtitleJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitSubtitleJobWithOptions(request, runtime);
}

model SubmitTagJobRequest {
  input?: string(name='Input'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  tagConfig?: string(name='TagConfig'),
  userData?: string(name='UserData'),
}

model SubmitTagJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model SubmitTagJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitTagJobResponseBody(name='body'),
}

async function submitTagJobWithOptions(request: SubmitTagJobRequest, runtime: Util.RuntimeOptions): SubmitTagJobResponse {
  Util.validateModel(request);
  var query = {};
  query["Input"] = request.input;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PipelineId"] = request.pipelineId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["TagConfig"] = request.tagConfig;
  query["UserData"] = request.userData;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SubmitTagJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitTagJob(request: SubmitTagJobRequest): SubmitTagJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitTagJobWithOptions(request, runtime);
}

model SubmitTerrorismJobRequest {
  input?: string(name='Input'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  terrorismConfig?: string(name='TerrorismConfig'),
  userData?: string(name='UserData'),
}

model SubmitTerrorismJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model SubmitTerrorismJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitTerrorismJobResponseBody(name='body'),
}

async function submitTerrorismJobWithOptions(request: SubmitTerrorismJobRequest, runtime: Util.RuntimeOptions): SubmitTerrorismJobResponse {
  Util.validateModel(request);
  var query = {};
  query["Input"] = request.input;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PipelineId"] = request.pipelineId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["TerrorismConfig"] = request.terrorismConfig;
  query["UserData"] = request.userData;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SubmitTerrorismJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitTerrorismJob(request: SubmitTerrorismJobRequest): SubmitTerrorismJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitTerrorismJobWithOptions(request, runtime);
}

model SubmitURLUploadJobRequest {
  notify?: string(name='Notify'),
  region?: string(name='Region'),
  sourceFileURL?: string(name='SourceFileURL'),
  targetStorage?: {
    bucket?: string(name='Bucket'),
    bucketOwnerId?: string(name='BucketOwnerId'),
    objectKey?: string(name='ObjectKey'),
    objectRoleName?: string(name='ObjectRoleName'),
    s3AccessKey?: string(name='S3AccessKey'),
    s3Endpoint?: string(name='S3Endpoint'),
    s3Provider?: string(name='S3Provider'),
    s3SecretKey?: string(name='S3SecretKey'),
    s3SessionToken?: string(name='S3SessionToken'),
  }(name='TargetStorage'),
  userData?: string(name='UserData'),
}

model SubmitURLUploadJobShrinkRequest {
  notify?: string(name='Notify'),
  region?: string(name='Region'),
  sourceFileURL?: string(name='SourceFileURL'),
  targetStorageShrink?: string(name='TargetStorage'),
  userData?: string(name='UserData'),
}

model SubmitURLUploadJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model SubmitURLUploadJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitURLUploadJobResponseBody(name='body'),
}

async function submitURLUploadJobWithOptions(tmpReq: SubmitURLUploadJobRequest, runtime: Util.RuntimeOptions): SubmitURLUploadJobResponse {
  Util.validateModel(tmpReq);
  var request = new SubmitURLUploadJobShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.targetStorage)) {
    request.targetStorageShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.targetStorage, 'TargetStorage', 'json');
  }
  var query = {};
  query["Notify"] = request.notify;
  query["Region"] = request.region;
  query["SourceFileURL"] = request.sourceFileURL;
  query["TargetStorage"] = request.targetStorageShrink;
  query["UserData"] = request.userData;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SubmitURLUploadJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitURLUploadJob(request: SubmitURLUploadJobRequest): SubmitURLUploadJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitURLUploadJobWithOptions(request, runtime);
}

model SubmitVideoGifJobRequest {
  input?: string(name='Input'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  userData?: string(name='UserData'),
  videoGifConfig?: string(name='VideoGifConfig'),
}

model SubmitVideoGifJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model SubmitVideoGifJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitVideoGifJobResponseBody(name='body'),
}

async function submitVideoGifJobWithOptions(request: SubmitVideoGifJobRequest, runtime: Util.RuntimeOptions): SubmitVideoGifJobResponse {
  Util.validateModel(request);
  var query = {};
  query["Input"] = request.input;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PipelineId"] = request.pipelineId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["UserData"] = request.userData;
  query["VideoGifConfig"] = request.videoGifConfig;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SubmitVideoGifJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitVideoGifJob(request: SubmitVideoGifJobRequest): SubmitVideoGifJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitVideoGifJobWithOptions(request, runtime);
}

model SubmitVideoPoseJobRequest {
  input?: string(name='Input'),
  outputConfig?: string(name='OutputConfig'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  userData?: string(name='UserData'),
}

model SubmitVideoPoseJobResponseBody = {
  requestId?: string(name='RequestId'),
  videoPoseJob?: {
    input?: {
      bucket?: string(name='Bucket'),
      location?: string(name='Location'),
      object?: string(name='Object'),
      roleArn?: string(name='RoleArn'),
    }(name='Input'),
    jobId?: string(name='JobId'),
    MNSMessageResult?: {
      errorCode?: string(name='ErrorCode'),
      errorMessage?: string(name='ErrorMessage'),
      messageId?: string(name='MessageId'),
    }(name='MNSMessageResult'),
    outputConfig?: {
      dataFile?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
        roleArn?: string(name='RoleArn'),
      }(name='DataFile'),
      videoFile?: {
        bucket?: string(name='Bucket'),
        location?: string(name='Location'),
        object?: string(name='Object'),
        roleArn?: string(name='RoleArn'),
      }(name='VideoFile'),
    }(name='OutputConfig'),
    pipelineId?: string(name='PipelineId'),
    properties?: {
      bitrate?: string(name='Bitrate'),
      duration?: string(name='Duration'),
      fileFormat?: string(name='FileFormat'),
      fileSize?: string(name='FileSize'),
      format?: {
        bitrate?: string(name='Bitrate'),
        duration?: string(name='Duration'),
        formatLongName?: string(name='FormatLongName'),
        formatName?: string(name='FormatName'),
        numPrograms?: string(name='NumPrograms'),
        numStreams?: string(name='NumStreams'),
        size?: string(name='Size'),
        startTime?: string(name='StartTime'),
      }(name='Format'),
      fps?: string(name='Fps'),
      height?: string(name='Height'),
      streams?: {
        audioStreamList?: {
          audioStream?: [ 
          {
            bitrate?: string(name='Bitrate'),
            channelLayout?: string(name='ChannelLayout'),
            channels?: string(name='Channels'),
            codecLongName?: string(name='CodecLongName'),
            codecName?: string(name='CodecName'),
            codecTag?: string(name='CodecTag'),
            codecTagString?: string(name='CodecTagString'),
            codecTimeBase?: string(name='CodecTimeBase'),
            duration?: string(name='Duration'),
            index?: string(name='Index'),
            lang?: string(name='Lang'),
            numFrames?: string(name='NumFrames'),
            sampleFmt?: string(name='SampleFmt'),
            samplerate?: string(name='Samplerate'),
            startTime?: string(name='StartTime'),
            timebase?: string(name='Timebase'),
          }
        ](name='AudioStream')
        }(name='AudioStreamList'),
        subtitleStreamList?: {
          subtitleStream?: [ 
          {
            codecLongName?: string(name='CodecLongName'),
            codecName?: string(name='CodecName'),
            codecTag?: string(name='CodecTag'),
            codecTagString?: string(name='CodecTagString'),
            codecTimeBase?: string(name='CodecTimeBase'),
            duration?: string(name='Duration'),
            index?: string(name='Index'),
            lang?: string(name='Lang'),
            startTime?: string(name='StartTime'),
            timebase?: string(name='Timebase'),
          }
        ](name='SubtitleStream')
        }(name='SubtitleStreamList'),
        videoStreamList?: {
          videoStream?: [ 
          {
            avgFPS?: string(name='AvgFPS'),
            bitrate?: string(name='Bitrate'),
            codecLongName?: string(name='CodecLongName'),
            codecName?: string(name='CodecName'),
            codecTag?: string(name='CodecTag'),
            codecTagString?: string(name='CodecTagString'),
            codecTimeBase?: string(name='CodecTimeBase'),
            dar?: string(name='Dar'),
            duration?: string(name='Duration'),
            fps?: string(name='Fps'),
            hasBFrames?: string(name='HasBFrames'),
            height?: string(name='Height'),
            index?: string(name='Index'),
            lang?: string(name='Lang'),
            level?: string(name='Level'),
            networkCost?: {
              avgBitrate?: string(name='AvgBitrate'),
              costBandwidth?: string(name='CostBandwidth'),
              preloadTime?: string(name='PreloadTime'),
            }(name='NetworkCost'),
            numFrames?: string(name='NumFrames'),
            pixFmt?: string(name='PixFmt'),
            profile?: string(name='Profile'),
            rotate?: string(name='Rotate'),
            sar?: string(name='Sar'),
            startTime?: string(name='StartTime'),
            timebase?: string(name='Timebase'),
            width?: string(name='Width'),
          }
        ](name='VideoStream')
        }(name='VideoStreamList'),
      }(name='Streams'),
      width?: string(name='Width'),
    }(name='Properties'),
    state?: string(name='State'),
    userData?: string(name='UserData'),
  }(name='VideoPoseJob'),
}

model SubmitVideoPoseJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitVideoPoseJobResponseBody(name='body'),
}

async function submitVideoPoseJobWithOptions(request: SubmitVideoPoseJobRequest, runtime: Util.RuntimeOptions): SubmitVideoPoseJobResponse {
  Util.validateModel(request);
  var query = {};
  query["Input"] = request.input;
  query["OutputConfig"] = request.outputConfig;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PipelineId"] = request.pipelineId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["UserData"] = request.userData;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SubmitVideoPoseJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitVideoPoseJob(request: SubmitVideoPoseJobRequest): SubmitVideoPoseJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitVideoPoseJobWithOptions(request, runtime);
}

model SubmitVideoQualityJobRequest {
  input?: string(name='Input'),
  jobParams?: string(name='JobParams'),
  modelId?: string(name='ModelId'),
  notifyUrl?: string(name='NotifyUrl'),
  output?: string(name='Output'),
  pipelineId?: string(name='PipelineId'),
  scheduleParams?: string(name='ScheduleParams'),
  sourceType?: string(name='SourceType'),
  userData?: string(name='UserData'),
  userId?: long(name='UserId'),
}

model SubmitVideoQualityJobResponseBody = {
  code?: string(name='Code'),
  jobId?: string(name='JobId'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model SubmitVideoQualityJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitVideoQualityJobResponseBody(name='body'),
}

async function submitVideoQualityJobWithOptions(request: SubmitVideoQualityJobRequest, runtime: Util.RuntimeOptions): SubmitVideoQualityJobResponse {
  Util.validateModel(request);
  var query = {};
  query["Input"] = request.input;
  query["JobParams"] = request.jobParams;
  query["ModelId"] = request.modelId;
  query["NotifyUrl"] = request.notifyUrl;
  query["Output"] = request.output;
  query["PipelineId"] = request.pipelineId;
  query["ScheduleParams"] = request.scheduleParams;
  query["SourceType"] = request.sourceType;
  query["UserData"] = request.userData;
  query["UserId"] = request.userId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SubmitVideoQualityJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitVideoQualityJob(request: SubmitVideoQualityJobRequest): SubmitVideoQualityJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitVideoQualityJobWithOptions(request, runtime);
}

model SubmitVideoSplitJobRequest {
  input?: string(name='Input'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  userData?: string(name='UserData'),
  videoSplitConfig?: string(name='VideoSplitConfig'),
}

model SubmitVideoSplitJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model SubmitVideoSplitJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitVideoSplitJobResponseBody(name='body'),
}

async function submitVideoSplitJobWithOptions(request: SubmitVideoSplitJobRequest, runtime: Util.RuntimeOptions): SubmitVideoSplitJobResponse {
  Util.validateModel(request);
  var query = {};
  query["Input"] = request.input;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PipelineId"] = request.pipelineId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["UserData"] = request.userData;
  query["VideoSplitConfig"] = request.videoSplitConfig;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SubmitVideoSplitJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitVideoSplitJob(request: SubmitVideoSplitJobRequest): SubmitVideoSplitJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitVideoSplitJobWithOptions(request, runtime);
}

model SubmitVideoSummaryJobRequest {
  input?: string(name='Input'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  userData?: string(name='UserData'),
  videoSummaryConfig?: string(name='VideoSummaryConfig'),
}

model SubmitVideoSummaryJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model SubmitVideoSummaryJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitVideoSummaryJobResponseBody(name='body'),
}

async function submitVideoSummaryJobWithOptions(request: SubmitVideoSummaryJobRequest, runtime: Util.RuntimeOptions): SubmitVideoSummaryJobResponse {
  Util.validateModel(request);
  var query = {};
  query["Input"] = request.input;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PipelineId"] = request.pipelineId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["UserData"] = request.userData;
  query["VideoSummaryConfig"] = request.videoSummaryConfig;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SubmitVideoSummaryJob',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitVideoSummaryJob(request: SubmitVideoSummaryJobRequest): SubmitVideoSummaryJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitVideoSummaryJobWithOptions(request, runtime);
}

model TagCustomPersonRequest {
  categoryDescription?: string(name='CategoryDescription'),
  categoryId?: string(name='CategoryId'),
  categoryName?: string(name='CategoryName'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  personDescription?: string(name='PersonDescription'),
  personId?: string(name='PersonId'),
  personName?: string(name='PersonName'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model TagCustomPersonResponseBody = {
  requestId?: string(name='RequestId'),
}

model TagCustomPersonResponse = {
  headers: map[string]string(name='headers'),
  body: TagCustomPersonResponseBody(name='body'),
}

async function tagCustomPersonWithOptions(request: TagCustomPersonRequest, runtime: Util.RuntimeOptions): TagCustomPersonResponse {
  Util.validateModel(request);
  var query = {};
  query["CategoryDescription"] = request.categoryDescription;
  query["CategoryId"] = request.categoryId;
  query["CategoryName"] = request.categoryName;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PersonDescription"] = request.personDescription;
  query["PersonId"] = request.personId;
  query["PersonName"] = request.personName;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'TagCustomPerson',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function tagCustomPerson(request: TagCustomPersonRequest): TagCustomPersonResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagCustomPersonWithOptions(request, runtime);
}

model UnbindInputBucketRequest {
  bucket?: string(name='Bucket'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  roleArn?: string(name='RoleArn'),
}

model UnbindInputBucketResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnbindInputBucketResponse = {
  headers: map[string]string(name='headers'),
  body: UnbindInputBucketResponseBody(name='body'),
}

async function unbindInputBucketWithOptions(request: UnbindInputBucketRequest, runtime: Util.RuntimeOptions): UnbindInputBucketResponse {
  Util.validateModel(request);
  var query = {};
  query["Bucket"] = request.bucket;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["RoleArn"] = request.roleArn;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UnbindInputBucket',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function unbindInputBucket(request: UnbindInputBucketRequest): UnbindInputBucketResponse {
  var runtime = new Util.RuntimeOptions{};
  return unbindInputBucketWithOptions(request, runtime);
}

model UnbindOutputBucketRequest {
  bucket?: string(name='Bucket'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model UnbindOutputBucketResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnbindOutputBucketResponse = {
  headers: map[string]string(name='headers'),
  body: UnbindOutputBucketResponseBody(name='body'),
}

async function unbindOutputBucketWithOptions(request: UnbindOutputBucketRequest, runtime: Util.RuntimeOptions): UnbindOutputBucketResponse {
  Util.validateModel(request);
  var query = {};
  query["Bucket"] = request.bucket;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UnbindOutputBucket',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function unbindOutputBucket(request: UnbindOutputBucketRequest): UnbindOutputBucketResponse {
  var runtime = new Util.RuntimeOptions{};
  return unbindOutputBucketWithOptions(request, runtime);
}

model UnregisterCustomFaceRequest {
  categoryId?: string(name='CategoryId'),
  faceId?: string(name='FaceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  personId?: string(name='PersonId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model UnregisterCustomFaceResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnregisterCustomFaceResponse = {
  headers: map[string]string(name='headers'),
  body: UnregisterCustomFaceResponseBody(name='body'),
}

async function unregisterCustomFaceWithOptions(request: UnregisterCustomFaceRequest, runtime: Util.RuntimeOptions): UnregisterCustomFaceResponse {
  Util.validateModel(request);
  var query = {};
  query["CategoryId"] = request.categoryId;
  query["FaceId"] = request.faceId;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PersonId"] = request.personId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UnregisterCustomFace',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function unregisterCustomFace(request: UnregisterCustomFaceRequest): UnregisterCustomFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return unregisterCustomFaceWithOptions(request, runtime);
}

model UpdateAsrPipelineRequest {
  name?: string(name='Name'),
  notifyConfig?: string(name='NotifyConfig'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  priority?: int32(name='Priority'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  state?: string(name='State'),
}

model UpdateAsrPipelineResponseBody = {
  pipeline?: {
    id?: string(name='Id'),
    name?: string(name='Name'),
    notifyConfig?: {
      queueName?: string(name='QueueName'),
      topic?: string(name='Topic'),
    }(name='NotifyConfig'),
    priority?: int32(name='Priority'),
    state?: string(name='State'),
  }(name='Pipeline'),
  requestId?: string(name='RequestId'),
}

model UpdateAsrPipelineResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAsrPipelineResponseBody(name='body'),
}

async function updateAsrPipelineWithOptions(request: UpdateAsrPipelineRequest, runtime: Util.RuntimeOptions): UpdateAsrPipelineResponse {
  Util.validateModel(request);
  var query = {};
  query["Name"] = request.name;
  query["NotifyConfig"] = request.notifyConfig;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PipelineId"] = request.pipelineId;
  query["Priority"] = request.priority;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["State"] = request.state;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAsrPipeline',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAsrPipeline(request: UpdateAsrPipelineRequest): UpdateAsrPipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAsrPipelineWithOptions(request, runtime);
}

model UpdateCategoryNameRequest {
  cateId?: string(name='CateId'),
  cateName?: string(name='CateName'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model UpdateCategoryNameResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateCategoryNameResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateCategoryNameResponseBody(name='body'),
}

async function updateCategoryNameWithOptions(request: UpdateCategoryNameRequest, runtime: Util.RuntimeOptions): UpdateCategoryNameResponse {
  Util.validateModel(request);
  var query = {};
  query["CateId"] = request.cateId;
  query["CateName"] = request.cateName;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateCategoryName',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateCategoryName(request: UpdateCategoryNameRequest): UpdateCategoryNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateCategoryNameWithOptions(request, runtime);
}

model UpdateCensorPipelineRequest {
  name?: string(name='Name'),
  notifyConfig?: string(name='NotifyConfig'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  priority?: int32(name='Priority'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  state?: string(name='State'),
}

model UpdateCensorPipelineResponseBody = {
  pipeline?: {
    id?: string(name='Id'),
    name?: string(name='Name'),
    notifyConfig?: {
      queue?: string(name='Queue'),
      topic?: string(name='Topic'),
    }(name='NotifyConfig'),
    priority?: int32(name='Priority'),
    state?: string(name='State'),
  }(name='Pipeline'),
  requestId?: string(name='RequestId'),
}

model UpdateCensorPipelineResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateCensorPipelineResponseBody(name='body'),
}

async function updateCensorPipelineWithOptions(request: UpdateCensorPipelineRequest, runtime: Util.RuntimeOptions): UpdateCensorPipelineResponse {
  Util.validateModel(request);
  var query = {};
  query["Name"] = request.name;
  query["NotifyConfig"] = request.notifyConfig;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PipelineId"] = request.pipelineId;
  query["Priority"] = request.priority;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["State"] = request.state;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateCensorPipeline',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateCensorPipeline(request: UpdateCensorPipelineRequest): UpdateCensorPipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateCensorPipelineWithOptions(request, runtime);
}

model UpdateCoverPipelineRequest {
  name?: string(name='Name'),
  notifyConfig?: string(name='NotifyConfig'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  priority?: int32(name='Priority'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  role?: string(name='Role'),
  state?: string(name='State'),
}

model UpdateCoverPipelineResponseBody = {
  pipeline?: {
    id?: string(name='Id'),
    name?: string(name='Name'),
    notifyConfig?: {
      queue?: string(name='Queue'),
      topic?: string(name='Topic'),
    }(name='NotifyConfig'),
    priority?: int32(name='Priority'),
    role?: string(name='Role'),
    state?: string(name='State'),
  }(name='Pipeline'),
  requestId?: string(name='RequestId'),
}

model UpdateCoverPipelineResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateCoverPipelineResponseBody(name='body'),
}

async function updateCoverPipelineWithOptions(request: UpdateCoverPipelineRequest, runtime: Util.RuntimeOptions): UpdateCoverPipelineResponse {
  Util.validateModel(request);
  var query = {};
  query["Name"] = request.name;
  query["NotifyConfig"] = request.notifyConfig;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PipelineId"] = request.pipelineId;
  query["Priority"] = request.priority;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["Role"] = request.role;
  query["State"] = request.state;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateCoverPipeline',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateCoverPipeline(request: UpdateCoverPipelineRequest): UpdateCoverPipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateCoverPipelineWithOptions(request, runtime);
}

model UpdateMCTemplateRequest {
  abuse?: string(name='Abuse'),
  ad?: string(name='Ad'),
  contraband?: string(name='Contraband'),
  live?: string(name='Live'),
  logo?: string(name='Logo'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  politics?: string(name='Politics'),
  porn?: string(name='Porn'),
  qrcode?: string(name='Qrcode'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  templateId?: string(name='TemplateId'),
  terrorism?: string(name='Terrorism'),
  spam?: string(name='spam'),
}

model UpdateMCTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  template?: {
    abuse?: string(name='Abuse'),
    ad?: string(name='Ad'),
    contraband?: string(name='Contraband'),
    live?: string(name='Live'),
    logo?: string(name='Logo'),
    name?: string(name='Name'),
    politics?: string(name='Politics'),
    porn?: string(name='Porn'),
    qrcode?: string(name='Qrcode'),
    spam?: string(name='Spam'),
    state?: string(name='State'),
    templateId?: string(name='TemplateId'),
    terrorism?: string(name='Terrorism'),
  }(name='Template'),
}

model UpdateMCTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateMCTemplateResponseBody(name='body'),
}

async function updateMCTemplateWithOptions(request: UpdateMCTemplateRequest, runtime: Util.RuntimeOptions): UpdateMCTemplateResponse {
  Util.validateModel(request);
  var query = {};
  query["Abuse"] = request.abuse;
  query["Ad"] = request.ad;
  query["Contraband"] = request.contraband;
  query["Live"] = request.live;
  query["Logo"] = request.logo;
  query["Name"] = request.name;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["Politics"] = request.politics;
  query["Porn"] = request.porn;
  query["Qrcode"] = request.qrcode;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["TemplateId"] = request.templateId;
  query["Terrorism"] = request.terrorism;
  query["spam"] = request.spam;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMCTemplate',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateMCTemplate(request: UpdateMCTemplateRequest): UpdateMCTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMCTemplateWithOptions(request, runtime);
}

model UpdateMcuTemplateRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  template?: string(name='Template'),
  templateId?: string(name='TemplateId'),
}

model UpdateMcuTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  templateId?: string(name='TemplateId'),
}

model UpdateMcuTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateMcuTemplateResponseBody(name='body'),
}

async function updateMcuTemplateWithOptions(request: UpdateMcuTemplateRequest, runtime: Util.RuntimeOptions): UpdateMcuTemplateResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["Template"] = request.template;
  query["TemplateId"] = request.templateId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMcuTemplate',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateMcuTemplate(request: UpdateMcuTemplateRequest): UpdateMcuTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMcuTemplateWithOptions(request, runtime);
}

model UpdateMediaRequest {
  cateId?: long(name='CateId'),
  coverURL?: string(name='CoverURL'),
  description?: string(name='Description'),
  mediaId?: string(name='MediaId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  tags?: string(name='Tags'),
  title?: string(name='Title'),
}

model UpdateMediaResponseBody = {
  media?: {
    bitrate?: string(name='Bitrate'),
    cateId?: long(name='CateId'),
    censorState?: string(name='CensorState'),
    coverURL?: string(name='CoverURL'),
    creationTime?: string(name='CreationTime'),
    description?: string(name='Description'),
    duration?: string(name='Duration'),
    file?: {
      state?: string(name='State'),
      URL?: string(name='URL'),
    }(name='File'),
    format?: string(name='Format'),
    fps?: string(name='Fps'),
    height?: string(name='Height'),
    mediaId?: string(name='MediaId'),
    publishState?: string(name='PublishState'),
    runIdList?: {
      runId?: [ string ](name='RunId')
    }(name='RunIdList'),
    size?: string(name='Size'),
    tags?: {
      tag?: [ string ](name='Tag')
    }(name='Tags'),
    title?: string(name='Title'),
    width?: string(name='Width'),
  }(name='Media'),
  requestId?: string(name='RequestId'),
}

model UpdateMediaResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateMediaResponseBody(name='body'),
}

async function updateMediaWithOptions(request: UpdateMediaRequest, runtime: Util.RuntimeOptions): UpdateMediaResponse {
  Util.validateModel(request);
  var query = {};
  query["CateId"] = request.cateId;
  query["CoverURL"] = request.coverURL;
  query["Description"] = request.description;
  query["MediaId"] = request.mediaId;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["Tags"] = request.tags;
  query["Title"] = request.title;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMedia',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateMedia(request: UpdateMediaRequest): UpdateMediaResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMediaWithOptions(request, runtime);
}

model UpdateMediaCategoryRequest {
  cateId?: long(name='CateId'),
  mediaId?: string(name='MediaId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model UpdateMediaCategoryResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateMediaCategoryResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateMediaCategoryResponseBody(name='body'),
}

async function updateMediaCategoryWithOptions(request: UpdateMediaCategoryRequest, runtime: Util.RuntimeOptions): UpdateMediaCategoryResponse {
  Util.validateModel(request);
  var query = {};
  query["CateId"] = request.cateId;
  query["MediaId"] = request.mediaId;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMediaCategory',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateMediaCategory(request: UpdateMediaCategoryRequest): UpdateMediaCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMediaCategoryWithOptions(request, runtime);
}

model UpdateMediaCoverRequest {
  coverURL?: string(name='CoverURL'),
  mediaId?: string(name='MediaId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model UpdateMediaCoverResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateMediaCoverResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateMediaCoverResponseBody(name='body'),
}

async function updateMediaCoverWithOptions(request: UpdateMediaCoverRequest, runtime: Util.RuntimeOptions): UpdateMediaCoverResponse {
  Util.validateModel(request);
  var query = {};
  query["CoverURL"] = request.coverURL;
  query["MediaId"] = request.mediaId;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMediaCover',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateMediaCover(request: UpdateMediaCoverRequest): UpdateMediaCoverResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMediaCoverWithOptions(request, runtime);
}

model UpdateMediaPublishStateRequest {
  mediaId?: string(name='MediaId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  publish?: boolean(name='Publish'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model UpdateMediaPublishStateResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateMediaPublishStateResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateMediaPublishStateResponseBody(name='body'),
}

async function updateMediaPublishStateWithOptions(request: UpdateMediaPublishStateRequest, runtime: Util.RuntimeOptions): UpdateMediaPublishStateResponse {
  Util.validateModel(request);
  var query = {};
  query["MediaId"] = request.mediaId;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["Publish"] = request.publish;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMediaPublishState',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateMediaPublishState(request: UpdateMediaPublishStateRequest): UpdateMediaPublishStateResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMediaPublishStateWithOptions(request, runtime);
}

model UpdateMediaWorkflowRequest {
  mediaWorkflowId?: string(name='MediaWorkflowId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  topology?: string(name='Topology'),
}

model UpdateMediaWorkflowResponseBody = {
  mediaWorkflow?: {
    creationTime?: string(name='CreationTime'),
    mediaWorkflowId?: string(name='MediaWorkflowId'),
    name?: string(name='Name'),
    state?: string(name='State'),
    topology?: string(name='Topology'),
    triggerMode?: string(name='TriggerMode'),
  }(name='MediaWorkflow'),
  requestId?: string(name='RequestId'),
}

model UpdateMediaWorkflowResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateMediaWorkflowResponseBody(name='body'),
}

async function updateMediaWorkflowWithOptions(request: UpdateMediaWorkflowRequest, runtime: Util.RuntimeOptions): UpdateMediaWorkflowResponse {
  Util.validateModel(request);
  var query = {};
  query["MediaWorkflowId"] = request.mediaWorkflowId;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["Topology"] = request.topology;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMediaWorkflow',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateMediaWorkflow(request: UpdateMediaWorkflowRequest): UpdateMediaWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMediaWorkflowWithOptions(request, runtime);
}

model UpdateMediaWorkflowTriggerModeRequest {
  mediaWorkflowId?: string(name='MediaWorkflowId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  triggerMode?: string(name='TriggerMode'),
}

model UpdateMediaWorkflowTriggerModeResponseBody = {
  mediaWorkflow?: {
    creationTime?: string(name='CreationTime'),
    mediaWorkflowId?: string(name='MediaWorkflowId'),
    name?: string(name='Name'),
    state?: string(name='State'),
    topology?: string(name='Topology'),
    triggerMode?: string(name='TriggerMode'),
  }(name='MediaWorkflow'),
  requestId?: string(name='RequestId'),
}

model UpdateMediaWorkflowTriggerModeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateMediaWorkflowTriggerModeResponseBody(name='body'),
}

async function updateMediaWorkflowTriggerModeWithOptions(request: UpdateMediaWorkflowTriggerModeRequest, runtime: Util.RuntimeOptions): UpdateMediaWorkflowTriggerModeResponse {
  Util.validateModel(request);
  var query = {};
  query["MediaWorkflowId"] = request.mediaWorkflowId;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["TriggerMode"] = request.triggerMode;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMediaWorkflowTriggerMode',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateMediaWorkflowTriggerMode(request: UpdateMediaWorkflowTriggerModeRequest): UpdateMediaWorkflowTriggerModeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMediaWorkflowTriggerModeWithOptions(request, runtime);
}

model UpdatePipelineRequest {
  name?: string(name='Name'),
  notifyConfig?: string(name='NotifyConfig'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  role?: string(name='Role'),
  state?: string(name='State'),
}

model UpdatePipelineResponseBody = {
  pipeline?: {
    id?: string(name='Id'),
    name?: string(name='Name'),
    notifyConfig?: {
      mqTag?: string(name='MqTag'),
      mqTopic?: string(name='MqTopic'),
      queueName?: string(name='QueueName'),
      topic?: string(name='Topic'),
    }(name='NotifyConfig'),
    quotaAllocate?: long(name='QuotaAllocate'),
    role?: string(name='Role'),
    speed?: string(name='Speed'),
    state?: string(name='State'),
  }(name='Pipeline'),
  requestId?: string(name='RequestId'),
}

model UpdatePipelineResponse = {
  headers: map[string]string(name='headers'),
  body: UpdatePipelineResponseBody(name='body'),
}

async function updatePipelineWithOptions(request: UpdatePipelineRequest, runtime: Util.RuntimeOptions): UpdatePipelineResponse {
  Util.validateModel(request);
  var query = {};
  query["Name"] = request.name;
  query["NotifyConfig"] = request.notifyConfig;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PipelineId"] = request.pipelineId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["Role"] = request.role;
  query["State"] = request.state;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdatePipeline',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updatePipeline(request: UpdatePipelineRequest): UpdatePipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return updatePipelineWithOptions(request, runtime);
}

model UpdatePornPipelineRequest {
  name?: string(name='Name'),
  notifyConfig?: string(name='NotifyConfig'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  priority?: int32(name='Priority'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  state?: string(name='State'),
}

model UpdatePornPipelineResponseBody = {
  pipeline?: {
    id?: string(name='Id'),
    name?: string(name='Name'),
    notifyConfig?: {
      queue?: string(name='Queue'),
      topic?: string(name='Topic'),
    }(name='NotifyConfig'),
    priority?: int32(name='Priority'),
    state?: string(name='State'),
  }(name='Pipeline'),
  requestId?: string(name='RequestId'),
}

model UpdatePornPipelineResponse = {
  headers: map[string]string(name='headers'),
  body: UpdatePornPipelineResponseBody(name='body'),
}

async function updatePornPipelineWithOptions(request: UpdatePornPipelineRequest, runtime: Util.RuntimeOptions): UpdatePornPipelineResponse {
  Util.validateModel(request);
  var query = {};
  query["Name"] = request.name;
  query["NotifyConfig"] = request.notifyConfig;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PipelineId"] = request.pipelineId;
  query["Priority"] = request.priority;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["State"] = request.state;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdatePornPipeline',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updatePornPipeline(request: UpdatePornPipelineRequest): UpdatePornPipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return updatePornPipelineWithOptions(request, runtime);
}

model UpdateSmarttagTemplateRequest {
  analyseTypes?: string(name='AnalyseTypes'),
  faceCategoryIds?: string(name='FaceCategoryIds'),
  industry?: string(name='Industry'),
  isDefault?: boolean(name='IsDefault'),
  keywordConfig?: string(name='KeywordConfig'),
  knowledgeConfig?: string(name='KnowledgeConfig'),
  labelType?: string(name='LabelType'),
  labelVersion?: string(name='LabelVersion'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  scene?: string(name='Scene'),
  templateId?: string(name='TemplateId'),
  templateName?: string(name='TemplateName'),
}

model UpdateSmarttagTemplateResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateSmarttagTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateSmarttagTemplateResponseBody(name='body'),
}

async function updateSmarttagTemplateWithOptions(request: UpdateSmarttagTemplateRequest, runtime: Util.RuntimeOptions): UpdateSmarttagTemplateResponse {
  Util.validateModel(request);
  var query = {};
  query["AnalyseTypes"] = request.analyseTypes;
  query["FaceCategoryIds"] = request.faceCategoryIds;
  query["Industry"] = request.industry;
  query["IsDefault"] = request.isDefault;
  query["KeywordConfig"] = request.keywordConfig;
  query["KnowledgeConfig"] = request.knowledgeConfig;
  query["LabelType"] = request.labelType;
  query["LabelVersion"] = request.labelVersion;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["Scene"] = request.scene;
  query["TemplateId"] = request.templateId;
  query["TemplateName"] = request.templateName;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSmarttagTemplate',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateSmarttagTemplate(request: UpdateSmarttagTemplateRequest): UpdateSmarttagTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSmarttagTemplateWithOptions(request, runtime);
}

model UpdateTemplateRequest {
  audio?: string(name='Audio'),
  container?: string(name='Container'),
  muxConfig?: string(name='MuxConfig'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  templateId?: string(name='TemplateId'),
  transConfig?: string(name='TransConfig'),
  video?: string(name='Video'),
}

model UpdateTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  template?: {
    audio?: {
      bitrate?: string(name='Bitrate'),
      channels?: string(name='Channels'),
      codec?: string(name='Codec'),
      profile?: string(name='Profile'),
      qscale?: string(name='Qscale'),
      remove?: string(name='Remove'),
      samplerate?: string(name='Samplerate'),
    }(name='Audio'),
    container?: {
      format?: string(name='Format'),
    }(name='Container'),
    id?: string(name='Id'),
    muxConfig?: {
      gif?: {
        ditherMode?: string(name='DitherMode'),
        finalDelay?: string(name='FinalDelay'),
        isCustomPalette?: string(name='IsCustomPalette'),
        loop?: string(name='Loop'),
      }(name='Gif'),
      segment?: {
        duration?: string(name='Duration'),
      }(name='Segment'),
      webp?: {
        loop?: string(name='Loop'),
      }(name='Webp'),
    }(name='MuxConfig'),
    name?: string(name='Name'),
    state?: string(name='State'),
    transConfig?: {
      adjDarMethod?: string(name='AdjDarMethod'),
      isCheckAudioBitrate?: string(name='IsCheckAudioBitrate'),
      isCheckAudioBitrateFail?: string(name='IsCheckAudioBitrateFail'),
      isCheckReso?: string(name='IsCheckReso'),
      isCheckResoFail?: string(name='IsCheckResoFail'),
      isCheckVideoBitrate?: string(name='IsCheckVideoBitrate'),
      isCheckVideoBitrateFail?: string(name='IsCheckVideoBitrateFail'),
      transMode?: string(name='TransMode'),
    }(name='TransConfig'),
    video?: {
      bitrate?: string(name='Bitrate'),
      bitrateBnd?: {
        max?: string(name='Max'),
        min?: string(name='Min'),
      }(name='BitrateBnd'),
      bufsize?: string(name='Bufsize'),
      codec?: string(name='Codec'),
      crf?: string(name='Crf'),
      crop?: string(name='Crop'),
      degrain?: string(name='Degrain'),
      fps?: string(name='Fps'),
      gop?: string(name='Gop'),
      height?: string(name='Height'),
      longShortMode?: string(name='LongShortMode'),
      maxFps?: string(name='MaxFps'),
      maxrate?: string(name='Maxrate'),
      pad?: string(name='Pad'),
      pixFmt?: string(name='PixFmt'),
      preset?: string(name='Preset'),
      profile?: string(name='Profile'),
      qscale?: string(name='Qscale'),
      remove?: string(name='Remove'),
      resoPriority?: string(name='ResoPriority'),
      scanMode?: string(name='ScanMode'),
      width?: string(name='Width'),
    }(name='Video'),
  }(name='Template'),
}

model UpdateTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateTemplateResponseBody(name='body'),
}

async function updateTemplateWithOptions(request: UpdateTemplateRequest, runtime: Util.RuntimeOptions): UpdateTemplateResponse {
  Util.validateModel(request);
  var query = {};
  query["Audio"] = request.audio;
  query["Container"] = request.container;
  query["MuxConfig"] = request.muxConfig;
  query["Name"] = request.name;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["TemplateId"] = request.templateId;
  query["TransConfig"] = request.transConfig;
  query["Video"] = request.video;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTemplate',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateTemplate(request: UpdateTemplateRequest): UpdateTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateTemplateWithOptions(request, runtime);
}

model UpdateTerrorismPipelineRequest {
  name?: string(name='Name'),
  notifyConfig?: string(name='NotifyConfig'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pipelineId?: string(name='PipelineId'),
  priority?: int32(name='Priority'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  state?: string(name='State'),
}

model UpdateTerrorismPipelineResponseBody = {
  pipeline?: {
    id?: string(name='Id'),
    name?: string(name='Name'),
    notifyConfig?: {
      queue?: string(name='Queue'),
      topic?: string(name='Topic'),
    }(name='NotifyConfig'),
    priority?: int32(name='Priority'),
    state?: string(name='State'),
  }(name='Pipeline'),
  requestId?: string(name='RequestId'),
}

model UpdateTerrorismPipelineResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateTerrorismPipelineResponseBody(name='body'),
}

async function updateTerrorismPipelineWithOptions(request: UpdateTerrorismPipelineRequest, runtime: Util.RuntimeOptions): UpdateTerrorismPipelineResponse {
  Util.validateModel(request);
  var query = {};
  query["Name"] = request.name;
  query["NotifyConfig"] = request.notifyConfig;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["PipelineId"] = request.pipelineId;
  query["Priority"] = request.priority;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["State"] = request.state;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTerrorismPipeline',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateTerrorismPipeline(request: UpdateTerrorismPipelineRequest): UpdateTerrorismPipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateTerrorismPipelineWithOptions(request, runtime);
}

model UpdateWaterMarkTemplateRequest {
  config?: string(name='Config'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  waterMarkTemplateId?: string(name='WaterMarkTemplateId'),
}

model UpdateWaterMarkTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  waterMarkTemplate?: {
    dx?: string(name='Dx'),
    dy?: string(name='Dy'),
    height?: string(name='Height'),
    id?: string(name='Id'),
    name?: string(name='Name'),
    ratioRefer?: {
      dx?: string(name='Dx'),
      dy?: string(name='Dy'),
      height?: string(name='Height'),
      width?: string(name='Width'),
    }(name='RatioRefer'),
    referPos?: string(name='ReferPos'),
    state?: string(name='State'),
    timeline?: {
      duration?: string(name='Duration'),
      start?: string(name='Start'),
    }(name='Timeline'),
    type?: string(name='Type'),
    width?: string(name='Width'),
  }(name='WaterMarkTemplate'),
}

model UpdateWaterMarkTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateWaterMarkTemplateResponseBody(name='body'),
}

async function updateWaterMarkTemplateWithOptions(request: UpdateWaterMarkTemplateRequest, runtime: Util.RuntimeOptions): UpdateWaterMarkTemplateResponse {
  Util.validateModel(request);
  var query = {};
  query["Config"] = request.config;
  query["Name"] = request.name;
  query["OwnerAccount"] = request.ownerAccount;
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["WaterMarkTemplateId"] = request.waterMarkTemplateId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateWaterMarkTemplate',
    version = '2014-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateWaterMarkTemplate(request: UpdateWaterMarkTemplateRequest): UpdateWaterMarkTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateWaterMarkTemplateWithOptions(request, runtime);
}

