/**
  *
  */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'oosops';
  @version = '2019-06-01';
  @endpointRule = '';
  @endpointMap = {
  };
}

function close(): void {
  @handler.close();
}

model AuditPublicTemplateRegistrationRequest {
  auditAction?: string(name='AuditAction', position='Query'),
  comment?: string(name='Comment', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  registrationId?: string(name='RegistrationId', position='Query'),
}

model AuditPublicTemplateRegistrationResponseBody = {
  comment?: string(name='Comment'),
  detail?: string(name='Detail'),
  registrationId?: string(name='RegistrationId'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
  templateId?: string(name='TemplateId'),
  templateName?: string(name='TemplateName'),
  templateVersion?: string(name='TemplateVersion'),
}

model AuditPublicTemplateRegistrationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AuditPublicTemplateRegistrationResponseBody(name='body'),
}

/**
  * @param request  the request parameters of AuditPublicTemplateRegistration  AuditPublicTemplateRegistrationRequest
  * @return AuditPublicTemplateRegistrationResponse
 */
async function auditPublicTemplateRegistration(request: AuditPublicTemplateRegistrationRequest): AuditPublicTemplateRegistrationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AuditPublicTemplateRegistration', 'POST', '/', 'json', false, 'json', request);
}

model CreateActionRequest {
  actionName: string(name='ActionName', description='This parameter is required.', position='Query'),
  actionType: string(name='ActionType', description='This parameter is required.', position='Query'),
  content: string(name='Content', description='This parameter is required.', position='Query'),
  popularity?: int32(name='Popularity', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model CreateActionResponseBody = {
  actionName?: string(name='ActionName'),
  actionType?: string(name='ActionType'),
  createdDate?: string(name='CreatedDate'),
  description?: string(name='Description'),
  popularity?: int32(name='Popularity'),
  properties?: string(name='Properties'),
  requestId?: string(name='RequestId'),
  templateVersion?: string(name='TemplateVersion'),
}

model CreateActionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateActionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateAction  CreateActionRequest
  * @return CreateActionResponse
 */
async function createAction(request: CreateActionRequest): CreateActionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateAction', 'POST', '/', 'json', false, 'json', request);
}

model CreatePublicParameterRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  constraints?: string(name='Constraints', position='Query'),
  description?: string(name='Description', position='Query'),
  name: string(name='Name', description='This parameter is required.', position='Query'),
  parameterType: string(name='ParameterType', description='This parameter is required.', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  value: string(name='Value', description='This parameter is required.', position='Query'),
}

model CreatePublicParameterResponseBody = {
  parameter?: {
    constraints?: string(name='Constraints'),
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    name?: string(name='Name'),
    parameterVersion?: int32(name='ParameterVersion'),
    regionId?: string(name='RegionId'),
    shareType?: string(name='ShareType'),
    type?: string(name='Type'),
    updatedBy?: string(name='UpdatedBy'),
    updatedDate?: string(name='UpdatedDate'),
  }(name='Parameter'),
  requestId?: string(name='RequestId'),
}

model CreatePublicParameterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreatePublicParameterResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreatePublicParameter  CreatePublicParameterRequest
  * @return CreatePublicParameterResponse
 */
async function createPublicParameter(request: CreatePublicParameterRequest): CreatePublicParameterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreatePublicParameter', 'POST', '/', 'json', false, 'json', request);
}

model CreatePublicPatchBaselineRequest {
  approvalRules: string(name='ApprovalRules', description='This parameter is required.', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  name: string(name='Name', description='This parameter is required.', position='Query'),
  operationSystem: string(name='OperationSystem', description='This parameter is required.', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model CreatePublicPatchBaselineResponseBody = {
  patchBaseline?: {
    approvalRules?: string(name='ApprovalRules'),
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    name?: string(name='Name'),
    operationSystem?: string(name='OperationSystem'),
    shareType?: string(name='ShareType'),
    updatedBy?: string(name='UpdatedBy'),
    updatedDate?: string(name='UpdatedDate'),
  }(name='PatchBaseline'),
  requestId?: string(name='RequestId'),
}

model CreatePublicPatchBaselineResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreatePublicPatchBaselineResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreatePublicPatchBaseline  CreatePublicPatchBaselineRequest
  * @return CreatePublicPatchBaselineResponse
 */
async function createPublicPatchBaseline(request: CreatePublicPatchBaselineRequest): CreatePublicPatchBaselineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreatePublicPatchBaseline', 'POST', '/', 'json', false, 'json', request);
}

model CreatePublicTemplateRequest {
  category?: string(name='Category', position='Query'),
  content: string(name='Content', description='This parameter is required.', position='Query'),
  isExample?: boolean(name='IsExample', position='Query'),
  popularity?: int32(name='Popularity', position='Query'),
  publisher?: string(name='Publisher', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  templateName: string(name='TemplateName', description='This parameter is required.', position='Query'),
  versionName?: string(name='VersionName', position='Query'),
}

model CreatePublicTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  template?: {
    category?: string(name='Category'),
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    description?: string(name='Description'),
    hash?: string(name='Hash'),
    popularity?: int32(name='Popularity'),
    shareType?: string(name='ShareType'),
    templateFormat?: string(name='TemplateFormat'),
    templateId?: string(name='TemplateId'),
    templateName?: string(name='TemplateName'),
    templateVersion?: string(name='TemplateVersion'),
    updatedBy?: string(name='UpdatedBy'),
    updatedDate?: string(name='UpdatedDate'),
  }(name='Template'),
}

model CreatePublicTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreatePublicTemplateResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreatePublicTemplate  CreatePublicTemplateRequest
  * @return CreatePublicTemplateResponse
 */
async function createPublicTemplate(request: CreatePublicTemplateRequest): CreatePublicTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreatePublicTemplate', 'POST', '/', 'json', false, 'json', request);
}

model DeleteFailureMsgRequest {
  operation: string(name='Operation', description='This parameter is required.', position='Query'),
  requestFingerprint: string(name='RequestFingerprint', description='This parameter is required.', position='Query'),
}

model DeleteFailureMsgResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteFailureMsgResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteFailureMsgResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteFailureMsg  DeleteFailureMsgRequest
  * @return DeleteFailureMsgResponse
 */
async function deleteFailureMsg(request: DeleteFailureMsgRequest): DeleteFailureMsgResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteFailureMsg', 'POST', '/', 'json', false, 'json', request);
}

model DeletePublicParameterRequest {
  name: string(name='Name', description='This parameter is required.', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DeletePublicParameterResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeletePublicParameterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeletePublicParameterResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeletePublicParameter  DeletePublicParameterRequest
  * @return DeletePublicParameterResponse
 */
async function deletePublicParameter(request: DeletePublicParameterRequest): DeletePublicParameterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeletePublicParameter', 'POST', '/', 'json', false, 'json', request);
}

model DeletePublicPatchBaselineRequest {
  name: string(name='Name', description='This parameter is required.', position='Query'),
}

model DeletePublicPatchBaselineResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeletePublicPatchBaselineResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeletePublicPatchBaselineResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeletePublicPatchBaseline  DeletePublicPatchBaselineRequest
  * @return DeletePublicPatchBaselineResponse
 */
async function deletePublicPatchBaseline(request: DeletePublicPatchBaselineRequest): DeletePublicPatchBaselineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeletePublicPatchBaseline', 'POST', '/', 'json', false, 'json', request);
}

model DeletePublicTemplateRequest {
  regionId?: string(name='RegionId', position='Query'),
  templateName: string(name='TemplateName', description='This parameter is required.', position='Query'),
}

model DeletePublicTemplateResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeletePublicTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeletePublicTemplateResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeletePublicTemplate  DeletePublicTemplateRequest
  * @return DeletePublicTemplateResponse
 */
async function deletePublicTemplate(request: DeletePublicTemplateRequest): DeletePublicTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeletePublicTemplate', 'POST', '/', 'json', false, 'json', request);
}

model DoCheckResourceRequest {
  bid?: string(name='bid', position='Query'),
  country?: string(name='country', position='Query'),
  gmtWakeup?: string(name='gmtWakeup', position='Query'),
  hid?: int32(name='hid', position='Query'),
  interrupt?: boolean(name='interrupt', position='Query'),
  invoker?: string(name='invoker', position='Query'),
  level?: int32(name='level', position='Query'),
  message?: string(name='message', position='Query'),
  pk?: string(name='pk', position='Query'),
  prompt?: string(name='prompt', position='Query'),
  success?: boolean(name='success', position='Query'),
  taskExtraData?: string(name='taskExtraData', position='Query'),
  taskIdentifier?: string(name='taskIdentifier', position='Query'),
  url?: string(name='url', position='Query'),
}

model DoCheckResourceResponseBody = {
  requestId?: string(name='RequestId'),
  bid?: string(name='bid'),
  country?: string(name='country'),
  gmtWakeup?: string(name='gmtWakeup'),
  hid?: int32(name='hid'),
  interrupt?: boolean(name='interrupt'),
  invoker?: string(name='invoker'),
  level?: int32(name='level'),
  message?: string(name='message'),
  pk?: string(name='pk'),
  prompt?: string(name='prompt'),
  success?: boolean(name='success'),
  taskExtraData?: string(name='taskExtraData'),
  taskIdentifier?: string(name='taskIdentifier'),
  url?: string(name='url'),
}

model DoCheckResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DoCheckResourceResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DoCheckResource  DoCheckResourceRequest
  * @return DoCheckResourceResponse
 */
async function doCheckResource(request: DoCheckResourceRequest): DoCheckResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DoCheckResource', 'POST', '/', 'json', false, 'json', request);
}

model GetActionRequest {
  actionName?: string(name='ActionName', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model GetActionResponseBody = {
  actionName?: string(name='ActionName'),
  actionType?: string(name='ActionType'),
  content?: bytes(name='Content'),
  createTime?: string(name='CreateTime'),
  modifiedTime?: string(name='ModifiedTime'),
  popularity?: string(name='Popularity'),
  requestId?: string(name='RequestId'),
}

model GetActionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetActionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetAction  GetActionRequest
  * @return GetActionResponse
 */
async function getAction(request: GetActionRequest): GetActionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetAction', 'POST', '/', 'json', false, 'json', request);
}

model GetFlowControlRequest {
  api?: string(name='Api', position='Query'),
  service?: string(name='Service', position='Query'),
  type: int32(name='Type', description='This parameter is required.', position='Query'),
  uid?: string(name='Uid', position='Query'),
}

model GetFlowControlResponseBody = {
  requestId?: string(name='RequestId'),
  value?: int32(name='Value'),
}

model GetFlowControlResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetFlowControlResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetFlowControl  GetFlowControlRequest
  * @return GetFlowControlResponse
 */
async function getFlowControl(request: GetFlowControlRequest): GetFlowControlResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetFlowControl', 'POST', '/', 'json', false, 'json', request);
}

model GetPublicParameterRequest {
  name: string(name='Name', description='This parameter is required.', position='Query'),
  parameterVersion?: int32(name='ParameterVersion', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model GetPublicParameterResponseBody = {
  parameter?: {
    constraints?: string(name='Constraints'),
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    name?: string(name='Name'),
    parameterVersion?: int32(name='ParameterVersion'),
    regionId?: string(name='RegionId'),
    shareType?: string(name='ShareType'),
    type?: string(name='Type'),
    updatedBy?: string(name='UpdatedBy'),
    updatedDate?: string(name='UpdatedDate'),
    value?: string(name='Value'),
  }(name='Parameter'),
  requestId?: string(name='RequestId'),
}

model GetPublicParameterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetPublicParameterResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetPublicParameter  GetPublicParameterRequest
  * @return GetPublicParameterResponse
 */
async function getPublicParameter(request: GetPublicParameterRequest): GetPublicParameterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetPublicParameter', 'POST', '/', 'json', false, 'json', request);
}

model GetPublicPatchBaselineRequest {
  name: string(name='Name', description='This parameter is required.', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model GetPublicPatchBaselineResponseBody = {
  patchBaseline?: {
    approvalRules?: string(name='ApprovalRules'),
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    name?: string(name='Name'),
    operationSystem?: string(name='OperationSystem'),
    shareType?: string(name='ShareType'),
    updatedBy?: string(name='UpdatedBy'),
    updatedDate?: string(name='UpdatedDate'),
  }(name='PatchBaseline'),
  requestId?: string(name='RequestId'),
}

model GetPublicPatchBaselineResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetPublicPatchBaselineResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetPublicPatchBaseline  GetPublicPatchBaselineRequest
  * @return GetPublicPatchBaselineResponse
 */
async function getPublicPatchBaseline(request: GetPublicPatchBaselineRequest): GetPublicPatchBaselineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetPublicPatchBaseline', 'POST', '/', 'json', false, 'json', request);
}

model GetPublicTemplateRequest {
  regionId?: string(name='RegionId', position='Query'),
  templateName: string(name='TemplateName', description='This parameter is required.', position='Query'),
  templateVersion?: string(name='TemplateVersion', position='Query'),
}

model GetPublicTemplateResponseBody = {
  content?: string(name='Content'),
  requestId?: string(name='RequestId'),
  template?: {
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    description?: string(name='Description'),
    hash?: string(name='Hash'),
    popularity?: int32(name='Popularity'),
    shareType?: string(name='ShareType'),
    templateFormat?: string(name='TemplateFormat'),
    templateId?: string(name='TemplateId'),
    templateName?: string(name='TemplateName'),
    templateVersion?: string(name='TemplateVersion'),
    updatedBy?: string(name='UpdatedBy'),
    updatedDate?: string(name='UpdatedDate'),
  }(name='Template'),
}

model GetPublicTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetPublicTemplateResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetPublicTemplate  GetPublicTemplateRequest
  * @return GetPublicTemplateResponse
 */
async function getPublicTemplate(request: GetPublicTemplateRequest): GetPublicTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetPublicTemplate', 'POST', '/', 'json', false, 'json', request);
}

model GetQuotaRequest {
  quotaName: string(name='QuotaName', description='This parameter is required.', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  uid: string(name='Uid', description='This parameter is required.', position='Query'),
}

model GetQuotaResponseBody = {
  quota?: {
    concurrentExecution?: int32(name='ConcurrentExecution'),
    dailyTasks?: int32(name='DailyTasks'),
    totalTemplate?: int32(name='TotalTemplate'),
  }(name='Quota'),
  requestId?: string(name='RequestId'),
  uid?: string(name='Uid'),
}

model GetQuotaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetQuotaResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetQuota  GetQuotaRequest
  * @return GetQuotaResponse
 */
async function getQuota(request: GetQuotaRequest): GetQuotaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetQuota', 'POST', '/', 'json', false, 'json', request);
}

model GetUserExecutionTemplateRequest {
  aliUid: string(name='AliUid', description='This parameter is required.', position='Query'),
  executionId: string(name='ExecutionId', description='This parameter is required.', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model GetUserExecutionTemplateResponseBody = {
  content?: string(name='Content'),
  requestId?: string(name='RequestId'),
  template?: {
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    description?: string(name='Description'),
    hash?: string(name='Hash'),
    shareType?: string(name='ShareType'),
    templateFormat?: string(name='TemplateFormat'),
    templateId?: string(name='TemplateId'),
    templateName?: string(name='TemplateName'),
    templateVersion?: string(name='TemplateVersion'),
    updatedBy?: string(name='UpdatedBy'),
    updatedDate?: string(name='UpdatedDate'),
  }(name='Template'),
}

model GetUserExecutionTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetUserExecutionTemplateResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetUserExecutionTemplate  GetUserExecutionTemplateRequest
  * @return GetUserExecutionTemplateResponse
 */
async function getUserExecutionTemplate(request: GetUserExecutionTemplateRequest): GetUserExecutionTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetUserExecutionTemplate', 'POST', '/', 'json', false, 'json', request);
}

model GetUserTemplateRequest {
  aliUid: string(name='AliUid', description='This parameter is required.', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  templateName: string(name='TemplateName', description='This parameter is required.', position='Query'),
  templateVersion?: string(name='TemplateVersion', position='Query'),
}

model GetUserTemplateResponseBody = {
  content?: string(name='Content'),
  requestId?: string(name='RequestId'),
  template?: {
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    description?: string(name='Description'),
    hash?: string(name='Hash'),
    shareType?: string(name='ShareType'),
    templateFormat?: string(name='TemplateFormat'),
    templateId?: string(name='TemplateId'),
    templateName?: string(name='TemplateName'),
    templateVersion?: string(name='TemplateVersion'),
    updatedBy?: string(name='UpdatedBy'),
    updatedDate?: string(name='UpdatedDate'),
  }(name='Template'),
}

model GetUserTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetUserTemplateResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetUserTemplate  GetUserTemplateRequest
  * @return GetUserTemplateResponse
 */
async function getUserTemplate(request: GetUserTemplateRequest): GetUserTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetUserTemplate', 'POST', '/', 'json', false, 'json', request);
}

model ListActionsRequest {
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  OOSActionName?: string(name='OOSActionName', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model ListActionsResponseBody = {
  actions?: [ 
    {
      actionType?: string(name='ActionType'),
      createdDate?: string(name='CreatedDate'),
      description?: string(name='Description'),
      OOSActionName?: string(name='OOSActionName'),
      popularity?: int32(name='Popularity'),
      properties?: string(name='Properties'),
      templateVersion?: string(name='TemplateVersion'),
      updateDate?: string(name='UpdateDate'),
    }
  ](name='Actions'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model ListActionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListActionsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListActions  ListActionsRequest
  * @return ListActionsResponse
 */
async function listActions(request: ListActionsRequest): ListActionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListActions', 'POST', '/', 'json', false, 'json', request);
}

model ListDefaultQuotaRequest {
}

model ListDefaultQuotaResponseBody = {
  quotas?: [ 
    {
      concurrentExecution?: int32(name='ConcurrentExecution'),
      dailyTasks?: int32(name='DailyTasks'),
      totalTemplate?: int32(name='TotalTemplate'),
    }
  ](name='Quotas'),
  requestId?: string(name='RequestId'),
}

model ListDefaultQuotaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDefaultQuotaResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListDefaultQuota  ListDefaultQuotaRequest
  * @return ListDefaultQuotaResponse
 */
async function listDefaultQuota(request: ListDefaultQuotaRequest): ListDefaultQuotaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListDefaultQuota', 'POST', '/', 'json', false, 'json', request);
}

model ListFailureMsgsRequest {
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  requestFingerprint?: string(name='RequestFingerprint', position='Query'),
}

model ListFailureMsgsResponseBody = {
  failureMsgs?: [ 
    {
      aliUid?: string(name='AliUid'),
      executionId?: string(name='ExecutionId'),
      messageBody?: string(name='MessageBody'),
      reason?: string(name='Reason'),
      taskExecutionId?: string(name='TaskExecutionId'),
    }
  ](name='FailureMsgs'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model ListFailureMsgsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListFailureMsgsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListFailureMsgs  ListFailureMsgsRequest
  * @return ListFailureMsgsResponse
 */
async function listFailureMsgs(request: ListFailureMsgsRequest): ListFailureMsgsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListFailureMsgs', 'POST', '/', 'json', false, 'json', request);
}

model ListOOSLogsRequest {
  endTime: string(name='EndTime', description='This parameter is required.', position='Query'),
  executionId?: string(name='ExecutionId', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  requestFingerprint?: string(name='RequestFingerprint', position='Query'),
  startTime: string(name='StartTime', description='This parameter is required.', position='Query'),
}

model ListOOSLogsResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  OOSLogs?: string(name='OOSLogs'),
  requestId?: string(name='RequestId'),
}

model ListOOSLogsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListOOSLogsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListOOSLogs  ListOOSLogsRequest
  * @return ListOOSLogsResponse
 */
async function listOOSLogs(request: ListOOSLogsRequest): ListOOSLogsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListOOSLogs', 'POST', '/', 'json', false, 'json', request);
}

model ListPublicParametersRequest {
  maxResults?: int32(name='MaxResults', position='Query'),
  name?: string(name='Name', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  parameterType?: string(name='ParameterType', position='Query'),
  path?: string(name='Path', position='Query'),
  recursive?: boolean(name='Recursive', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  sortField?: string(name='SortField', position='Query'),
  sortOrder?: string(name='SortOrder', position='Query'),
}

model ListPublicParametersResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  parameters?: [ 
    {
      createdBy?: string(name='CreatedBy'),
      createdDate?: string(name='CreatedDate'),
      description?: string(name='Description'),
      id?: string(name='Id'),
      name?: string(name='Name'),
      parameterVersion?: string(name='ParameterVersion'),
      regionId?: string(name='RegionId'),
      shareType?: string(name='ShareType'),
      type?: string(name='Type'),
      updatedBy?: string(name='UpdatedBy'),
      updatedDate?: string(name='UpdatedDate'),
    }
  ](name='Parameters'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListPublicParametersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListPublicParametersResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListPublicParameters  ListPublicParametersRequest
  * @return ListPublicParametersResponse
 */
async function listPublicParameters(request: ListPublicParametersRequest): ListPublicParametersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListPublicParameters', 'POST', '/', 'json', false, 'json', request);
}

model ListPublicPatchBaselinesRequest {
  maxResults?: int32(name='MaxResults', position='Query'),
  name?: string(name='Name', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  operationSystem?: string(name='OperationSystem', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  shareType?: string(name='ShareType', position='Query'),
}

model ListPublicPatchBaselinesResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  patchBaselines?: [ 
    {
      createdBy?: string(name='CreatedBy'),
      createdDate?: string(name='CreatedDate'),
      description?: string(name='Description'),
      id?: string(name='Id'),
      isDefault?: boolean(name='IsDefault'),
      name?: string(name='Name'),
      operationSystem?: string(name='OperationSystem'),
      shareType?: string(name='ShareType'),
      updatedBy?: string(name='UpdatedBy'),
      updatedDate?: string(name='UpdatedDate'),
    }
  ](name='PatchBaselines'),
  requestId?: string(name='RequestId'),
}

model ListPublicPatchBaselinesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListPublicPatchBaselinesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListPublicPatchBaselines  ListPublicPatchBaselinesRequest
  * @return ListPublicPatchBaselinesResponse
 */
async function listPublicPatchBaselines(request: ListPublicPatchBaselinesRequest): ListPublicPatchBaselinesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListPublicPatchBaselines', 'POST', '/', 'json', false, 'json', request);
}

model ListPublicTemplateRegistrationsRequest {
  maxResults?: long(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  registrationId?: string(name='RegistrationId', position='Query'),
  status?: string(name='Status', position='Query'),
  templateName?: string(name='TemplateName', position='Query'),
}

model ListPublicTemplateRegistrationsResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  registrations?: [ 
    {
      comment?: string(name='Comment'),
      createdDate?: string(name='CreatedDate'),
      detail?: string(name='Detail'),
      registrationId?: string(name='RegistrationId'),
      showPages?: string(name='ShowPages'),
      status?: string(name='Status'),
      templateId?: string(name='TemplateId'),
      templateName?: string(name='TemplateName'),
      templateVersion?: string(name='TemplateVersion'),
      updatedDate?: string(name='UpdatedDate'),
    }
  ](name='Registrations'),
  requestId?: string(name='RequestId'),
}

model ListPublicTemplateRegistrationsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListPublicTemplateRegistrationsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListPublicTemplateRegistrations  ListPublicTemplateRegistrationsRequest
  * @return ListPublicTemplateRegistrationsResponse
 */
async function listPublicTemplateRegistrations(request: ListPublicTemplateRegistrationsRequest): ListPublicTemplateRegistrationsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListPublicTemplateRegistrations', 'POST', '/', 'json', false, 'json', request);
}

model ListPublicTemplatesRequest {
  createdBy?: string(name='CreatedBy', position='Query'),
  createdDateAfter?: string(name='CreatedDateAfter', position='Query'),
  createdDateBefore?: string(name='CreatedDateBefore', position='Query'),
  isExample?: boolean(name='IsExample', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  popularity?: int32(name='Popularity', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  shareType?: string(name='ShareType', position='Query'),
  sortField?: string(name='SortField', position='Query'),
  sortOrder?: string(name='SortOrder', position='Query'),
  templateFormat?: string(name='TemplateFormat', position='Query'),
  templateName?: string(name='TemplateName', position='Query'),
}

model ListPublicTemplatesResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  templates?: [ 
    {
      createdBy?: string(name='CreatedBy'),
      createdDate?: string(name='CreatedDate'),
      description?: string(name='Description'),
      hash?: string(name='Hash'),
      popularity?: int32(name='Popularity'),
      shareType?: string(name='ShareType'),
      templateFormat?: string(name='TemplateFormat'),
      templateId?: string(name='TemplateId'),
      templateName?: string(name='TemplateName'),
      templateVersion?: string(name='TemplateVersion'),
      totalExecutionCount?: int32(name='TotalExecutionCount'),
      updatedBy?: string(name='UpdatedBy'),
      updatedDate?: string(name='UpdatedDate'),
    }
  ](name='Templates'),
}

model ListPublicTemplatesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListPublicTemplatesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListPublicTemplates  ListPublicTemplatesRequest
  * @return ListPublicTemplatesResponse
 */
async function listPublicTemplates(request: ListPublicTemplatesRequest): ListPublicTemplatesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListPublicTemplates', 'POST', '/', 'json', false, 'json', request);
}

model ListUserExecutionLogsRequest {
  aliUid: string(name='AliUid', description='This parameter is required.', position='Query'),
  executionId: string(name='ExecutionId', description='This parameter is required.', position='Query'),
  logType?: string(name='LogType', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  taskExecutionId?: string(name='TaskExecutionId', position='Query'),
}

model ListUserExecutionLogsResponseBody = {
  executionLogs?: [ 
    {
      logType?: string(name='LogType'),
      message?: string(name='Message'),
      taskExecutionId?: string(name='TaskExecutionId'),
      timestamp?: string(name='Timestamp'),
    }
  ](name='ExecutionLogs'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model ListUserExecutionLogsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListUserExecutionLogsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListUserExecutionLogs  ListUserExecutionLogsRequest
  * @return ListUserExecutionLogsResponse
 */
async function listUserExecutionLogs(request: ListUserExecutionLogsRequest): ListUserExecutionLogsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListUserExecutionLogs', 'POST', '/', 'json', false, 'json', request);
}

model ListUserExecutionsRequest {
  aliUid: string(name='AliUid', description='This parameter is required.', position='Query'),
  endDateAfter?: string(name='EndDateAfter', position='Query'),
  endDateBefore?: string(name='EndDateBefore', position='Query'),
  executedBy?: string(name='ExecutedBy', position='Query'),
  executionId?: string(name='ExecutionId', position='Query'),
  includeChildExecution?: boolean(name='IncludeChildExecution', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  mode?: string(name='Mode', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  parentExecutionId?: string(name='ParentExecutionId', position='Query'),
  ramRole?: string(name='RamRole', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  sortField?: string(name='SortField', position='Query'),
  sortOrder?: string(name='SortOrder', position='Query'),
  startDateAfter?: string(name='StartDateAfter', position='Query'),
  startDateBefore?: string(name='StartDateBefore', position='Query'),
  status?: string(name='Status', position='Query'),
  templateName?: string(name='TemplateName', position='Query'),
}

model ListUserExecutionsResponseBody = {
  executions?: [ 
    {
      counters?: string(name='Counters'),
      createDate?: string(name='CreateDate'),
      currentTasks?: [ 
        {
          taskAction?: string(name='TaskAction'),
          taskExecutionId?: string(name='TaskExecutionId'),
          taskName?: string(name='TaskName'),
        }
      ](name='CurrentTasks'),
      endDate?: string(name='EndDate'),
      executedBy?: string(name='ExecutedBy'),
      executionId?: string(name='ExecutionId'),
      isParent?: boolean(name='IsParent'),
      mode?: string(name='Mode'),
      outputs?: string(name='Outputs'),
      parameters?: string(name='Parameters'),
      parentExecutionId?: string(name='ParentExecutionId'),
      ramRole?: string(name='RamRole'),
      safetyCheck?: string(name='SafetyCheck'),
      startDate?: string(name='StartDate'),
      status?: string(name='Status'),
      statusMessage?: string(name='StatusMessage'),
      templateId?: string(name='TemplateId'),
      templateName?: string(name='TemplateName'),
      templateVersion?: string(name='TemplateVersion'),
      updateDate?: string(name='UpdateDate'),
      waitingStatus?: string(name='WaitingStatus'),
    }
  ](name='Executions'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model ListUserExecutionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListUserExecutionsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListUserExecutions  ListUserExecutionsRequest
  * @return ListUserExecutionsResponse
 */
async function listUserExecutions(request: ListUserExecutionsRequest): ListUserExecutionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListUserExecutions', 'POST', '/', 'json', false, 'json', request);
}

model ListUserInstancePatchStatesRequest {
  aliUid: string(name='AliUid', description='This parameter is required.', position='Query'),
  instanceIds: string(name='InstanceIds', description='This parameter is required.', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model ListUserInstancePatchStatesResponseBody = {
  instancePatchStates?: [ 
    {
      baselineId?: string(name='BaselineId'),
      failedCount?: string(name='FailedCount'),
      installedCount?: string(name='InstalledCount'),
      installedOtherCount?: string(name='InstalledOtherCount'),
      installedPendingRebootCount?: string(name='InstalledPendingRebootCount'),
      installedRejectedCount?: string(name='InstalledRejectedCount'),
      instanceId?: string(name='InstanceId'),
      missingCount?: string(name='MissingCount'),
      operationEndTime?: string(name='OperationEndTime'),
      operationStartTime?: string(name='OperationStartTime'),
      operationType?: string(name='OperationType'),
      ownerInformation?: string(name='OwnerInformation'),
      patchGroup?: string(name='PatchGroup'),
    }
  ](name='InstancePatchStates'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model ListUserInstancePatchStatesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListUserInstancePatchStatesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListUserInstancePatchStates  ListUserInstancePatchStatesRequest
  * @return ListUserInstancePatchStatesResponse
 */
async function listUserInstancePatchStates(request: ListUserInstancePatchStatesRequest): ListUserInstancePatchStatesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListUserInstancePatchStates', 'POST', '/', 'json', false, 'json', request);
}

model ListUserInstancePatchesRequest {
  aliUid: string(name='AliUid', description='This parameter is required.', position='Query'),
  instanceId: string(name='InstanceId', description='This parameter is required.', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model ListUserInstancePatchesResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  patches?: [ 
    {
      classification?: string(name='Classification'),
      installedTime?: string(name='InstalledTime'),
      KBId?: string(name='KBId'),
      severity?: string(name='Severity'),
      status?: string(name='Status'),
      title?: string(name='Title'),
    }
  ](name='Patches'),
  requestId?: string(name='RequestId'),
}

model ListUserInstancePatchesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListUserInstancePatchesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListUserInstancePatches  ListUserInstancePatchesRequest
  * @return ListUserInstancePatchesResponse
 */
async function listUserInstancePatches(request: ListUserInstancePatchesRequest): ListUserInstancePatchesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListUserInstancePatches', 'POST', '/', 'json', false, 'json', request);
}

model ListUserInventoryEntriesRequest {
  aliUid: string(name='AliUid', description='This parameter is required.', position='Query'),
  filter?: [ 
    {
      name?: string(name='Name'),
      operator?: string(name='Operator'),
      value?: [ string ](name='Value'),
    }
  ](name='Filter', position='Query'),
  instanceId: string(name='InstanceId', description='This parameter is required.', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=1, maximum=100, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  typeName: string(name='TypeName', description='This parameter is required.', position='Query'),
}

model ListUserInventoryEntriesResponseBody = {
  captureTime?: string(name='CaptureTime'),
  entries?: [  map[string]any ](name='Entries'),
  instanceId?: string(name='InstanceId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  schemaVersion?: string(name='SchemaVersion'),
  typeName?: string(name='TypeName'),
}

model ListUserInventoryEntriesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListUserInventoryEntriesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListUserInventoryEntries  ListUserInventoryEntriesRequest
  * @return ListUserInventoryEntriesResponse
 */
async function listUserInventoryEntries(request: ListUserInventoryEntriesRequest): ListUserInventoryEntriesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListUserInventoryEntries', 'POST', '/', 'json', false, 'json', request);
}

model ListUserTaskExecutionsRequest {
  aliUid: string(name='AliUid', description='This parameter is required.', position='Query'),
  endDateAfter?: string(name='EndDateAfter', position='Query'),
  endDateBefore?: string(name='EndDateBefore', position='Query'),
  executionId?: string(name='ExecutionId', position='Query'),
  includeChildTaskExecution?: boolean(name='IncludeChildTaskExecution', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  parentTaskExecutionId?: string(name='ParentTaskExecutionId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  sortField?: string(name='SortField', position='Query'),
  sortOrder?: string(name='SortOrder', position='Query'),
  startDateAfter?: string(name='StartDateAfter', position='Query'),
  startDateBefore?: string(name='StartDateBefore', position='Query'),
  status?: string(name='Status', position='Query'),
  taskAction?: string(name='TaskAction', position='Query'),
  taskExecutionId?: string(name='TaskExecutionId', position='Query'),
  taskName?: string(name='TaskName', position='Query'),
}

model ListUserTaskExecutionsResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  taskExecutions?: [ 
    {
      childExecutionId?: string(name='ChildExecutionId'),
      createDate?: string(name='CreateDate'),
      endDate?: string(name='EndDate'),
      executionId?: string(name='ExecutionId'),
      extraData?: string(name='ExtraData'),
      loop?: string(name='Loop'),
      loopBatchNumber?: int32(name='LoopBatchNumber'),
      loopItem?: string(name='LoopItem'),
      outputs?: string(name='Outputs'),
      parentTaskExecutionId?: string(name='ParentTaskExecutionId'),
      properties?: string(name='Properties'),
      startDate?: string(name='StartDate'),
      status?: string(name='Status'),
      statusMessage?: string(name='StatusMessage'),
      taskAction?: string(name='TaskAction'),
      taskExecutionId?: string(name='TaskExecutionId'),
      taskName?: string(name='TaskName'),
      templateId?: string(name='TemplateId'),
      updateDate?: string(name='UpdateDate'),
    }
  ](name='TaskExecutions'),
}

model ListUserTaskExecutionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListUserTaskExecutionsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListUserTaskExecutions  ListUserTaskExecutionsRequest
  * @return ListUserTaskExecutionsResponse
 */
async function listUserTaskExecutions(request: ListUserTaskExecutionsRequest): ListUserTaskExecutionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListUserTaskExecutions', 'POST', '/', 'json', false, 'json', request);
}

model ListUserTemplatesRequest {
  aliUid: string(name='AliUid', description='This parameter is required.', position='Query'),
  category?: string(name='Category', position='Query'),
  createdBy?: string(name='CreatedBy', position='Query'),
  createdDateAfter?: string(name='CreatedDateAfter', position='Query'),
  createdDateBefore?: string(name='CreatedDateBefore', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  popularity?: int32(name='Popularity', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  shareType?: string(name='ShareType', position='Query'),
  sortField?: string(name='SortField', position='Query'),
  sortOrder?: string(name='SortOrder', position='Query'),
  templateFormat?: string(name='TemplateFormat', position='Query'),
  templateName?: string(name='TemplateName', position='Query'),
  templateType?: string(name='TemplateType', position='Query'),
}

model ListUserTemplatesResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  templates?: [ 
    {
      createdBy?: string(name='CreatedBy'),
      createdDate?: string(name='CreatedDate'),
      description?: string(name='Description'),
      hash?: string(name='Hash'),
      popularity?: int32(name='Popularity'),
      shareType?: string(name='ShareType'),
      templateFormat?: string(name='TemplateFormat'),
      templateId?: string(name='TemplateId'),
      templateName?: string(name='TemplateName'),
      templateVersion?: string(name='TemplateVersion'),
      totalExecutionCount?: int32(name='TotalExecutionCount'),
      updatedBy?: string(name='UpdatedBy'),
      updatedDate?: string(name='UpdatedDate'),
    }
  ](name='Templates'),
}

model ListUserTemplatesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListUserTemplatesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListUserTemplates  ListUserTemplatesRequest
  * @return ListUserTemplatesResponse
 */
async function listUserTemplates(request: ListUserTemplatesRequest): ListUserTemplatesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListUserTemplates', 'POST', '/', 'json', false, 'json', request);
}

model ResetTimerTriggerExecutionRequest {
  aliUid: string(name='AliUid', description='This parameter is required.', position='Query'),
  executionId: string(name='ExecutionId', description='This parameter is required.', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model ResetTimerTriggerExecutionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ResetTimerTriggerExecutionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ResetTimerTriggerExecutionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ResetTimerTriggerExecution  ResetTimerTriggerExecutionRequest
  * @return ResetTimerTriggerExecutionResponse
 */
async function resetTimerTriggerExecution(request: ResetTimerTriggerExecutionRequest): ResetTimerTriggerExecutionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ResetTimerTriggerExecution', 'POST', '/', 'json', false, 'json', request);
}

model ResetUserExecutionRequest {
  aliUid: string(name='AliUid', description='This parameter is required.', position='Query'),
  executionId: string(name='ExecutionId', description='This parameter is required.', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  status?: string(name='Status', position='Query'),
}

model ResetUserExecutionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ResetUserExecutionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ResetUserExecutionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ResetUserExecution  ResetUserExecutionRequest
  * @return ResetUserExecutionResponse
 */
async function resetUserExecution(request: ResetUserExecutionRequest): ResetUserExecutionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ResetUserExecution', 'POST', '/', 'json', false, 'json', request);
}

model SetFlowControlRequest {
  api?: string(name='Api', position='Query'),
  service?: string(name='Service', position='Query'),
  type: int32(name='Type', description='This parameter is required.', position='Query'),
  uid?: string(name='Uid', position='Query'),
  value: int32(name='Value', description='This parameter is required.', position='Query'),
}

model SetFlowControlResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetFlowControlResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetFlowControlResponseBody(name='body'),
}

/**
  * @param request  the request parameters of SetFlowControl  SetFlowControlRequest
  * @return SetFlowControlResponse
 */
async function setFlowControl(request: SetFlowControlRequest): SetFlowControlResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetFlowControl', 'POST', '/', 'json', false, 'json', request);
}

model SetQuotaRequest {
  quotaName: string(name='QuotaName', description='This parameter is required.', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  uid: string(name='Uid', description='This parameter is required.', position='Query'),
  value: string(name='Value', description='This parameter is required.', position='Query'),
}

model SetQuotaResponseBody = {
  quota?: int32(name='Quota'),
  requestId?: string(name='RequestId'),
  uid?: string(name='Uid'),
}

model SetQuotaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetQuotaResponseBody(name='body'),
}

/**
  * @param request  the request parameters of SetQuota  SetQuotaRequest
  * @return SetQuotaResponse
 */
async function setQuota(request: SetQuotaRequest): SetQuotaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetQuota', 'POST', '/', 'json', false, 'json', request);
}

model TerminateUserExecutionRequest {
  aliUid: string(name='AliUid', description='This parameter is required.', position='Query'),
  executionId: string(name='ExecutionId', description='This parameter is required.', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model TerminateUserExecutionResponseBody = {
  requestId?: string(name='RequestId'),
}

model TerminateUserExecutionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: TerminateUserExecutionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of TerminateUserExecution  TerminateUserExecutionRequest
  * @return TerminateUserExecutionResponse
 */
async function terminateUserExecution(request: TerminateUserExecutionRequest): TerminateUserExecutionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'TerminateUserExecution', 'POST', '/', 'json', false, 'json', request);
}

model UpdateActionRequest {
  actionName: string(name='ActionName', description='This parameter is required.', position='Query'),
  actionType: string(name='ActionType', description='This parameter is required.', position='Query'),
  content: string(name='Content', description='This parameter is required.', position='Query'),
  popularity?: int32(name='Popularity', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model UpdateActionResponseBody = {
  actionName?: string(name='ActionName'),
  actionType?: string(name='ActionType'),
  createdDate?: string(name='CreatedDate'),
  description?: string(name='Description'),
  popularity?: int32(name='Popularity'),
  properties?: string(name='Properties'),
  requestId?: string(name='RequestId'),
  templateVersion?: string(name='TemplateVersion'),
}

model UpdateActionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateActionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateAction  UpdateActionRequest
  * @return UpdateActionResponse
 */
async function updateAction(request: UpdateActionRequest): UpdateActionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateAction', 'POST', '/', 'json', false, 'json', request);
}

model UpdatePublicParameterRequest {
  description?: string(name='Description', position='Query'),
  name: string(name='Name', description='This parameter is required.', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  value: string(name='Value', description='This parameter is required.', position='Query'),
}

model UpdatePublicParameterResponseBody = {
  parameter?: {
    constraints?: string(name='Constraints'),
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    name?: string(name='Name'),
    parameterVersion?: int32(name='ParameterVersion'),
    regionId?: string(name='RegionId'),
    shareType?: string(name='ShareType'),
    type?: string(name='Type'),
    updatedBy?: string(name='UpdatedBy'),
    updatedDate?: string(name='UpdatedDate'),
  }(name='Parameter'),
  requestId?: string(name='RequestId'),
}

model UpdatePublicParameterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdatePublicParameterResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdatePublicParameter  UpdatePublicParameterRequest
  * @return UpdatePublicParameterResponse
 */
async function updatePublicParameter(request: UpdatePublicParameterRequest): UpdatePublicParameterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdatePublicParameter', 'POST', '/', 'json', false, 'json', request);
}

model UpdatePublicPatchBaselineRequest {
  approvalRules?: string(name='ApprovalRules', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  name: string(name='Name', description='This parameter is required.', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model UpdatePublicPatchBaselineResponseBody = {
  patchBaseline?: {
    approvalRules?: string(name='ApprovalRules'),
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    name?: string(name='Name'),
    operationSystem?: string(name='OperationSystem'),
    shareType?: string(name='ShareType'),
    updatedBy?: string(name='UpdatedBy'),
    updatedDate?: string(name='UpdatedDate'),
  }(name='PatchBaseline'),
  requestId?: string(name='RequestId'),
}

model UpdatePublicPatchBaselineResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdatePublicPatchBaselineResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdatePublicPatchBaseline  UpdatePublicPatchBaselineRequest
  * @return UpdatePublicPatchBaselineResponse
 */
async function updatePublicPatchBaseline(request: UpdatePublicPatchBaselineRequest): UpdatePublicPatchBaselineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdatePublicPatchBaseline', 'POST', '/', 'json', false, 'json', request);
}

model UpdatePublicTemplateRequest {
  category?: string(name='Category', position='Query'),
  content: string(name='Content', description='This parameter is required.', position='Query'),
  popularity?: int32(name='Popularity', position='Query'),
  publisher?: string(name='Publisher', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  templateName: string(name='TemplateName', description='This parameter is required.', position='Query'),
  versionName?: string(name='VersionName', position='Query'),
}

model UpdatePublicTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  template?: {
    category?: string(name='Category'),
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    description?: string(name='Description'),
    hash?: string(name='Hash'),
    popularity?: int32(name='Popularity'),
    shareType?: string(name='ShareType'),
    templateFormat?: string(name='TemplateFormat'),
    templateId?: string(name='TemplateId'),
    templateName?: string(name='TemplateName'),
    templateVersion?: string(name='TemplateVersion'),
    updatedBy?: string(name='UpdatedBy'),
    updatedDate?: string(name='UpdatedDate'),
  }(name='Template'),
}

model UpdatePublicTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdatePublicTemplateResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdatePublicTemplate  UpdatePublicTemplateRequest
  * @return UpdatePublicTemplateResponse
 */
async function updatePublicTemplate(request: UpdatePublicTemplateRequest): UpdatePublicTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdatePublicTemplate', 'POST', '/', 'json', false, 'json', request);
}

model ValidatePublicTemplateContentRequest {
  content: string(name='Content', description='This parameter is required.', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  templateName?: string(name='TemplateName', position='Query'),
  type: string(name='Type', description='This parameter is required.', position='Query'),
}

model ValidatePublicTemplateContentResponseBody = {
  description?: string(name='Description'),
  outputs?: string(name='Outputs'),
  parameters?: string(name='Parameters'),
  ramRole?: string(name='RamRole'),
  requestId?: string(name='RequestId'),
  tasks?: [ 
    {
      description?: string(name='Description'),
      name?: string(name='Name'),
      outputs?: string(name='Outputs'),
      properties?: string(name='Properties'),
      type?: string(name='Type'),
    }
  ](name='Tasks'),
}

model ValidatePublicTemplateContentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ValidatePublicTemplateContentResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ValidatePublicTemplateContent  ValidatePublicTemplateContentRequest
  * @return ValidatePublicTemplateContentResponse
 */
async function validatePublicTemplateContent(request: ValidatePublicTemplateContentRequest): ValidatePublicTemplateContentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ValidatePublicTemplateContent', 'POST', '/', 'json', false, 'json', request);
}

