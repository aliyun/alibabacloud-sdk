/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('oosops', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AuditPublicTemplateRegistrationRequest {
  auditAction?: string(name='AuditAction'),
  comment?: string(name='Comment'),
  regionId?: string(name='RegionId'),
  registrationId?: string(name='RegistrationId'),
}

model AuditPublicTemplateRegistrationResponseBody = {
  comment?: string(name='Comment'),
  detail?: string(name='Detail'),
  registrationId?: string(name='RegistrationId'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
  templateId?: string(name='TemplateId'),
  templateName?: string(name='TemplateName'),
  templateVersion?: string(name='TemplateVersion'),
}

model AuditPublicTemplateRegistrationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AuditPublicTemplateRegistrationResponseBody(name='body'),
}

async function auditPublicTemplateRegistrationWithOptions(request: AuditPublicTemplateRegistrationRequest, runtime: Util.RuntimeOptions): AuditPublicTemplateRegistrationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.auditAction)) {
    query['AuditAction'] = request.auditAction;
  }
  if (!Util.isUnset(request.comment)) {
    query['Comment'] = request.comment;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.registrationId)) {
    query['RegistrationId'] = request.registrationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AuditPublicTemplateRegistration',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function auditPublicTemplateRegistration(request: AuditPublicTemplateRegistrationRequest): AuditPublicTemplateRegistrationResponse {
  var runtime = new Util.RuntimeOptions{};
  return auditPublicTemplateRegistrationWithOptions(request, runtime);
}

model CreateActionRequest {
  actionName?: string(name='ActionName'),
  actionType?: string(name='ActionType'),
  content?: string(name='Content'),
  popularity?: int32(name='Popularity'),
  regionId?: string(name='RegionId'),
}

model CreateActionResponseBody = {
  actionName?: string(name='ActionName'),
  actionType?: string(name='ActionType'),
  createdDate?: string(name='CreatedDate'),
  description?: string(name='Description'),
  popularity?: int32(name='Popularity'),
  properties?: string(name='Properties'),
  requestId?: string(name='RequestId'),
  templateVersion?: string(name='TemplateVersion'),
}

model CreateActionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateActionResponseBody(name='body'),
}

async function createActionWithOptions(request: CreateActionRequest, runtime: Util.RuntimeOptions): CreateActionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.actionName)) {
    query['ActionName'] = request.actionName;
  }
  if (!Util.isUnset(request.actionType)) {
    query['ActionType'] = request.actionType;
  }
  if (!Util.isUnset(request.content)) {
    query['Content'] = request.content;
  }
  if (!Util.isUnset(request.popularity)) {
    query['Popularity'] = request.popularity;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateAction',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createAction(request: CreateActionRequest): CreateActionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createActionWithOptions(request, runtime);
}

model CreatePublicParameterRequest {
  clientToken?: string(name='ClientToken'),
  constraints?: string(name='Constraints'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  parameterType?: string(name='ParameterType'),
  regionId?: string(name='RegionId'),
  value?: string(name='Value'),
}

model CreatePublicParameterResponseBody = {
  parameter?: {
    constraints?: string(name='Constraints'),
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    name?: string(name='Name'),
    parameterVersion?: int32(name='ParameterVersion'),
    regionId?: string(name='RegionId'),
    shareType?: string(name='ShareType'),
    type?: string(name='Type'),
    updatedBy?: string(name='UpdatedBy'),
    updatedDate?: string(name='UpdatedDate'),
  }(name='Parameter'),
  requestId?: string(name='RequestId'),
}

model CreatePublicParameterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreatePublicParameterResponseBody(name='body'),
}

async function createPublicParameterWithOptions(request: CreatePublicParameterRequest, runtime: Util.RuntimeOptions): CreatePublicParameterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.constraints)) {
    query['Constraints'] = request.constraints;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.parameterType)) {
    query['ParameterType'] = request.parameterType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.value)) {
    query['Value'] = request.value;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreatePublicParameter',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createPublicParameter(request: CreatePublicParameterRequest): CreatePublicParameterResponse {
  var runtime = new Util.RuntimeOptions{};
  return createPublicParameterWithOptions(request, runtime);
}

model CreatePublicPatchBaselineRequest {
  approvalRules?: string(name='ApprovalRules'),
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  operationSystem?: string(name='OperationSystem'),
  regionId?: string(name='RegionId'),
}

model CreatePublicPatchBaselineResponseBody = {
  patchBaseline?: {
    approvalRules?: string(name='ApprovalRules'),
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    name?: string(name='Name'),
    operationSystem?: string(name='OperationSystem'),
    shareType?: string(name='ShareType'),
    updatedBy?: string(name='UpdatedBy'),
    updatedDate?: string(name='UpdatedDate'),
  }(name='PatchBaseline'),
  requestId?: string(name='RequestId'),
}

model CreatePublicPatchBaselineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreatePublicPatchBaselineResponseBody(name='body'),
}

async function createPublicPatchBaselineWithOptions(request: CreatePublicPatchBaselineRequest, runtime: Util.RuntimeOptions): CreatePublicPatchBaselineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.approvalRules)) {
    query['ApprovalRules'] = request.approvalRules;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.operationSystem)) {
    query['OperationSystem'] = request.operationSystem;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreatePublicPatchBaseline',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createPublicPatchBaseline(request: CreatePublicPatchBaselineRequest): CreatePublicPatchBaselineResponse {
  var runtime = new Util.RuntimeOptions{};
  return createPublicPatchBaselineWithOptions(request, runtime);
}

model CreatePublicTemplateRequest {
  category?: string(name='Category'),
  content?: string(name='Content'),
  popularity?: int32(name='Popularity'),
  publisher?: string(name='Publisher'),
  regionId?: string(name='RegionId'),
  templateName?: string(name='TemplateName'),
}

model CreatePublicTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  template?: {
    category?: string(name='Category'),
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    description?: string(name='Description'),
    hash?: string(name='Hash'),
    popularity?: int32(name='Popularity'),
    shareType?: string(name='ShareType'),
    templateFormat?: string(name='TemplateFormat'),
    templateId?: string(name='TemplateId'),
    templateName?: string(name='TemplateName'),
    templateVersion?: string(name='TemplateVersion'),
    updatedBy?: string(name='UpdatedBy'),
    updatedDate?: string(name='UpdatedDate'),
  }(name='Template'),
}

model CreatePublicTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreatePublicTemplateResponseBody(name='body'),
}

async function createPublicTemplateWithOptions(request: CreatePublicTemplateRequest, runtime: Util.RuntimeOptions): CreatePublicTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.category)) {
    query['Category'] = request.category;
  }
  if (!Util.isUnset(request.content)) {
    query['Content'] = request.content;
  }
  if (!Util.isUnset(request.popularity)) {
    query['Popularity'] = request.popularity;
  }
  if (!Util.isUnset(request.publisher)) {
    query['Publisher'] = request.publisher;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.templateName)) {
    query['TemplateName'] = request.templateName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreatePublicTemplate',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createPublicTemplate(request: CreatePublicTemplateRequest): CreatePublicTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return createPublicTemplateWithOptions(request, runtime);
}

model DeleteFailureMsgRequest {
  operation?: string(name='Operation'),
  requestFingerprint?: string(name='RequestFingerprint'),
}

model DeleteFailureMsgResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteFailureMsgResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteFailureMsgResponseBody(name='body'),
}

async function deleteFailureMsgWithOptions(request: DeleteFailureMsgRequest, runtime: Util.RuntimeOptions): DeleteFailureMsgResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.operation)) {
    query['Operation'] = request.operation;
  }
  if (!Util.isUnset(request.requestFingerprint)) {
    query['RequestFingerprint'] = request.requestFingerprint;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFailureMsg',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteFailureMsg(request: DeleteFailureMsgRequest): DeleteFailureMsgResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFailureMsgWithOptions(request, runtime);
}

model DeletePublicParameterRequest {
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
}

model DeletePublicParameterResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeletePublicParameterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeletePublicParameterResponseBody(name='body'),
}

async function deletePublicParameterWithOptions(request: DeletePublicParameterRequest, runtime: Util.RuntimeOptions): DeletePublicParameterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeletePublicParameter',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deletePublicParameter(request: DeletePublicParameterRequest): DeletePublicParameterResponse {
  var runtime = new Util.RuntimeOptions{};
  return deletePublicParameterWithOptions(request, runtime);
}

model DeletePublicPatchBaselineRequest {
  name?: string(name='Name'),
}

model DeletePublicPatchBaselineResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeletePublicPatchBaselineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeletePublicPatchBaselineResponseBody(name='body'),
}

async function deletePublicPatchBaselineWithOptions(request: DeletePublicPatchBaselineRequest, runtime: Util.RuntimeOptions): DeletePublicPatchBaselineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeletePublicPatchBaseline',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deletePublicPatchBaseline(request: DeletePublicPatchBaselineRequest): DeletePublicPatchBaselineResponse {
  var runtime = new Util.RuntimeOptions{};
  return deletePublicPatchBaselineWithOptions(request, runtime);
}

model DeletePublicTemplateRequest {
  regionId?: string(name='RegionId'),
  templateName?: string(name='TemplateName'),
}

model DeletePublicTemplateResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeletePublicTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeletePublicTemplateResponseBody(name='body'),
}

async function deletePublicTemplateWithOptions(request: DeletePublicTemplateRequest, runtime: Util.RuntimeOptions): DeletePublicTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.templateName)) {
    query['TemplateName'] = request.templateName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeletePublicTemplate',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deletePublicTemplate(request: DeletePublicTemplateRequest): DeletePublicTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deletePublicTemplateWithOptions(request, runtime);
}

model DoCheckResourceRequest {
  bid?: string(name='bid'),
  country?: string(name='country'),
  gmtWakeup?: string(name='gmtWakeup'),
  hid?: int32(name='hid'),
  interrupt?: boolean(name='interrupt'),
  invoker?: string(name='invoker'),
  level?: int32(name='level'),
  message?: string(name='message'),
  pk?: string(name='pk'),
  prompt?: string(name='prompt'),
  success?: boolean(name='success'),
  taskExtraData?: string(name='taskExtraData'),
  taskIdentifier?: string(name='taskIdentifier'),
  url?: string(name='url'),
}

model DoCheckResourceResponseBody = {
  requestId?: string(name='RequestId'),
  bid?: string(name='bid'),
  country?: string(name='country'),
  gmtWakeup?: string(name='gmtWakeup'),
  hid?: int32(name='hid'),
  interrupt?: boolean(name='interrupt'),
  invoker?: string(name='invoker'),
  level?: int32(name='level'),
  message?: string(name='message'),
  pk?: string(name='pk'),
  prompt?: string(name='prompt'),
  success?: boolean(name='success'),
  taskExtraData?: string(name='taskExtraData'),
  taskIdentifier?: string(name='taskIdentifier'),
  url?: string(name='url'),
}

model DoCheckResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DoCheckResourceResponseBody(name='body'),
}

async function doCheckResourceWithOptions(request: DoCheckResourceRequest, runtime: Util.RuntimeOptions): DoCheckResourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bid)) {
    query['bid'] = request.bid;
  }
  if (!Util.isUnset(request.country)) {
    query['country'] = request.country;
  }
  if (!Util.isUnset(request.gmtWakeup)) {
    query['gmtWakeup'] = request.gmtWakeup;
  }
  if (!Util.isUnset(request.hid)) {
    query['hid'] = request.hid;
  }
  if (!Util.isUnset(request.interrupt)) {
    query['interrupt'] = request.interrupt;
  }
  if (!Util.isUnset(request.invoker)) {
    query['invoker'] = request.invoker;
  }
  if (!Util.isUnset(request.level)) {
    query['level'] = request.level;
  }
  if (!Util.isUnset(request.message)) {
    query['message'] = request.message;
  }
  if (!Util.isUnset(request.pk)) {
    query['pk'] = request.pk;
  }
  if (!Util.isUnset(request.prompt)) {
    query['prompt'] = request.prompt;
  }
  if (!Util.isUnset(request.success)) {
    query['success'] = request.success;
  }
  if (!Util.isUnset(request.taskExtraData)) {
    query['taskExtraData'] = request.taskExtraData;
  }
  if (!Util.isUnset(request.taskIdentifier)) {
    query['taskIdentifier'] = request.taskIdentifier;
  }
  if (!Util.isUnset(request.url)) {
    query['url'] = request.url;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DoCheckResource',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function doCheckResource(request: DoCheckResourceRequest): DoCheckResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return doCheckResourceWithOptions(request, runtime);
}

model GetActionRequest {
  actionName?: string(name='ActionName'),
  regionId?: string(name='RegionId'),
}

model GetActionResponseBody = {
  actionName?: string(name='ActionName'),
  actionType?: string(name='ActionType'),
  content?: bytes(name='Content'),
  createTime?: string(name='CreateTime'),
  modifiedTime?: string(name='ModifiedTime'),
  popularity?: string(name='Popularity'),
  requestId?: string(name='RequestId'),
}

model GetActionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetActionResponseBody(name='body'),
}

async function getActionWithOptions(request: GetActionRequest, runtime: Util.RuntimeOptions): GetActionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.actionName)) {
    query['ActionName'] = request.actionName;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAction',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAction(request: GetActionRequest): GetActionResponse {
  var runtime = new Util.RuntimeOptions{};
  return getActionWithOptions(request, runtime);
}

model GetFlowControlRequest {
  api?: string(name='Api'),
  service?: string(name='Service'),
  type?: int32(name='Type'),
  uid?: string(name='Uid'),
}

model GetFlowControlResponseBody = {
  requestId?: string(name='RequestId'),
  value?: int32(name='Value'),
}

model GetFlowControlResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetFlowControlResponseBody(name='body'),
}

async function getFlowControlWithOptions(request: GetFlowControlRequest, runtime: Util.RuntimeOptions): GetFlowControlResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.api)) {
    query['Api'] = request.api;
  }
  if (!Util.isUnset(request.service)) {
    query['Service'] = request.service;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.uid)) {
    query['Uid'] = request.uid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetFlowControl',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getFlowControl(request: GetFlowControlRequest): GetFlowControlResponse {
  var runtime = new Util.RuntimeOptions{};
  return getFlowControlWithOptions(request, runtime);
}

model GetPublicParameterRequest {
  name?: string(name='Name'),
  parameterVersion?: int32(name='ParameterVersion'),
  regionId?: string(name='RegionId'),
}

model GetPublicParameterResponseBody = {
  parameter?: {
    constraints?: string(name='Constraints'),
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    name?: string(name='Name'),
    parameterVersion?: int32(name='ParameterVersion'),
    regionId?: string(name='RegionId'),
    shareType?: string(name='ShareType'),
    type?: string(name='Type'),
    updatedBy?: string(name='UpdatedBy'),
    updatedDate?: string(name='UpdatedDate'),
    value?: string(name='Value'),
  }(name='Parameter'),
  requestId?: string(name='RequestId'),
}

model GetPublicParameterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPublicParameterResponseBody(name='body'),
}

async function getPublicParameterWithOptions(request: GetPublicParameterRequest, runtime: Util.RuntimeOptions): GetPublicParameterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.parameterVersion)) {
    query['ParameterVersion'] = request.parameterVersion;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetPublicParameter',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPublicParameter(request: GetPublicParameterRequest): GetPublicParameterResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPublicParameterWithOptions(request, runtime);
}

model GetPublicPatchBaselineRequest {
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
}

model GetPublicPatchBaselineResponseBody = {
  patchBaseline?: {
    approvalRules?: string(name='ApprovalRules'),
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    name?: string(name='Name'),
    operationSystem?: string(name='OperationSystem'),
    shareType?: string(name='ShareType'),
    updatedBy?: string(name='UpdatedBy'),
    updatedDate?: string(name='UpdatedDate'),
  }(name='PatchBaseline'),
  requestId?: string(name='RequestId'),
}

model GetPublicPatchBaselineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPublicPatchBaselineResponseBody(name='body'),
}

async function getPublicPatchBaselineWithOptions(request: GetPublicPatchBaselineRequest, runtime: Util.RuntimeOptions): GetPublicPatchBaselineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetPublicPatchBaseline',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPublicPatchBaseline(request: GetPublicPatchBaselineRequest): GetPublicPatchBaselineResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPublicPatchBaselineWithOptions(request, runtime);
}

model GetPublicTemplateRequest {
  regionId?: string(name='RegionId'),
  templateName?: string(name='TemplateName'),
  templateVersion?: string(name='TemplateVersion'),
}

model GetPublicTemplateResponseBody = {
  content?: string(name='Content'),
  requestId?: string(name='RequestId'),
  template?: {
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    description?: string(name='Description'),
    hash?: string(name='Hash'),
    popularity?: int32(name='Popularity'),
    shareType?: string(name='ShareType'),
    templateFormat?: string(name='TemplateFormat'),
    templateId?: string(name='TemplateId'),
    templateName?: string(name='TemplateName'),
    templateVersion?: string(name='TemplateVersion'),
    updatedBy?: string(name='UpdatedBy'),
    updatedDate?: string(name='UpdatedDate'),
  }(name='Template'),
}

model GetPublicTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPublicTemplateResponseBody(name='body'),
}

async function getPublicTemplateWithOptions(request: GetPublicTemplateRequest, runtime: Util.RuntimeOptions): GetPublicTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.templateName)) {
    query['TemplateName'] = request.templateName;
  }
  if (!Util.isUnset(request.templateVersion)) {
    query['TemplateVersion'] = request.templateVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetPublicTemplate',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPublicTemplate(request: GetPublicTemplateRequest): GetPublicTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPublicTemplateWithOptions(request, runtime);
}

model GetQuotaRequest {
  quotaName?: string(name='QuotaName'),
  regionId?: string(name='RegionId'),
  uid?: string(name='Uid'),
}

model GetQuotaResponseBody = {
  quota?: {
    concurrentExecution?: int32(name='ConcurrentExecution'),
    dailyTasks?: int32(name='DailyTasks'),
    totalTemplate?: int32(name='TotalTemplate'),
  }(name='Quota'),
  requestId?: string(name='RequestId'),
  uid?: string(name='Uid'),
}

model GetQuotaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetQuotaResponseBody(name='body'),
}

async function getQuotaWithOptions(request: GetQuotaRequest, runtime: Util.RuntimeOptions): GetQuotaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.quotaName)) {
    query['QuotaName'] = request.quotaName;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.uid)) {
    query['Uid'] = request.uid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetQuota',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getQuota(request: GetQuotaRequest): GetQuotaResponse {
  var runtime = new Util.RuntimeOptions{};
  return getQuotaWithOptions(request, runtime);
}

model GetUserExecutionTemplateRequest {
  aliUid?: string(name='AliUid'),
  executionId?: string(name='ExecutionId'),
  regionId?: string(name='RegionId'),
}

model GetUserExecutionTemplateResponseBody = {
  content?: string(name='Content'),
  requestId?: string(name='RequestId'),
  template?: {
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    description?: string(name='Description'),
    hash?: string(name='Hash'),
    shareType?: string(name='ShareType'),
    templateFormat?: string(name='TemplateFormat'),
    templateId?: string(name='TemplateId'),
    templateName?: string(name='TemplateName'),
    templateVersion?: string(name='TemplateVersion'),
    updatedBy?: string(name='UpdatedBy'),
    updatedDate?: string(name='UpdatedDate'),
  }(name='Template'),
}

model GetUserExecutionTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetUserExecutionTemplateResponseBody(name='body'),
}

async function getUserExecutionTemplateWithOptions(request: GetUserExecutionTemplateRequest, runtime: Util.RuntimeOptions): GetUserExecutionTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliUid)) {
    query['AliUid'] = request.aliUid;
  }
  if (!Util.isUnset(request.executionId)) {
    query['ExecutionId'] = request.executionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetUserExecutionTemplate',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getUserExecutionTemplate(request: GetUserExecutionTemplateRequest): GetUserExecutionTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return getUserExecutionTemplateWithOptions(request, runtime);
}

model GetUserTemplateRequest {
  aliUid?: string(name='AliUid'),
  regionId?: string(name='RegionId'),
  templateName?: string(name='TemplateName'),
  templateVersion?: string(name='TemplateVersion'),
}

model GetUserTemplateResponseBody = {
  content?: string(name='Content'),
  requestId?: string(name='RequestId'),
  template?: {
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    description?: string(name='Description'),
    hash?: string(name='Hash'),
    shareType?: string(name='ShareType'),
    templateFormat?: string(name='TemplateFormat'),
    templateId?: string(name='TemplateId'),
    templateName?: string(name='TemplateName'),
    templateVersion?: string(name='TemplateVersion'),
    updatedBy?: string(name='UpdatedBy'),
    updatedDate?: string(name='UpdatedDate'),
  }(name='Template'),
}

model GetUserTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetUserTemplateResponseBody(name='body'),
}

async function getUserTemplateWithOptions(request: GetUserTemplateRequest, runtime: Util.RuntimeOptions): GetUserTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliUid)) {
    query['AliUid'] = request.aliUid;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.templateName)) {
    query['TemplateName'] = request.templateName;
  }
  if (!Util.isUnset(request.templateVersion)) {
    query['TemplateVersion'] = request.templateVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetUserTemplate',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getUserTemplate(request: GetUserTemplateRequest): GetUserTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return getUserTemplateWithOptions(request, runtime);
}

model ListActionsRequest {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  OOSActionName?: string(name='OOSActionName'),
  regionId?: string(name='RegionId'),
}

model ListActionsResponseBody = {
  actions?: [ 
    {
      actionType?: string(name='ActionType'),
      createdDate?: string(name='CreatedDate'),
      description?: string(name='Description'),
      OOSActionName?: string(name='OOSActionName'),
      popularity?: int32(name='Popularity'),
      properties?: string(name='Properties'),
      templateVersion?: string(name='TemplateVersion'),
      updateDate?: string(name='UpdateDate'),
    }
  ](name='Actions'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model ListActionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListActionsResponseBody(name='body'),
}

async function listActionsWithOptions(request: ListActionsRequest, runtime: Util.RuntimeOptions): ListActionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.OOSActionName)) {
    query['OOSActionName'] = request.OOSActionName;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListActions',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listActions(request: ListActionsRequest): ListActionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listActionsWithOptions(request, runtime);
}

model ListDefaultQuotaResponseBody = {
  quotas?: [ 
    {
      concurrentExecution?: int32(name='ConcurrentExecution'),
      dailyTasks?: int32(name='DailyTasks'),
      totalTemplate?: int32(name='TotalTemplate'),
    }
  ](name='Quotas'),
  requestId?: string(name='RequestId'),
}

model ListDefaultQuotaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDefaultQuotaResponseBody(name='body'),
}

async function listDefaultQuotaWithOptions(runtime: Util.RuntimeOptions): ListDefaultQuotaResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'ListDefaultQuota',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDefaultQuota(): ListDefaultQuotaResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDefaultQuotaWithOptions(runtime);
}

model ListFailureMsgsRequest {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestFingerprint?: string(name='RequestFingerprint'),
}

model ListFailureMsgsResponseBody = {
  failureMsgs?: [ 
    {
      aliUid?: string(name='AliUid'),
      executionId?: string(name='ExecutionId'),
      messageBody?: string(name='MessageBody'),
      reason?: string(name='Reason'),
      taskExecutionId?: string(name='TaskExecutionId'),
    }
  ](name='FailureMsgs'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model ListFailureMsgsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListFailureMsgsResponseBody(name='body'),
}

async function listFailureMsgsWithOptions(request: ListFailureMsgsRequest, runtime: Util.RuntimeOptions): ListFailureMsgsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.requestFingerprint)) {
    query['RequestFingerprint'] = request.requestFingerprint;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFailureMsgs',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFailureMsgs(request: ListFailureMsgsRequest): ListFailureMsgsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFailureMsgsWithOptions(request, runtime);
}

model ListOOSLogsRequest {
  endTime?: string(name='EndTime'),
  executionId?: string(name='ExecutionId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  requestFingerprint?: string(name='RequestFingerprint'),
  startTime?: string(name='StartTime'),
}

model ListOOSLogsResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  OOSLogs?: string(name='OOSLogs'),
  requestId?: string(name='RequestId'),
}

model ListOOSLogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListOOSLogsResponseBody(name='body'),
}

async function listOOSLogsWithOptions(request: ListOOSLogsRequest, runtime: Util.RuntimeOptions): ListOOSLogsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.executionId)) {
    query['ExecutionId'] = request.executionId;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.requestFingerprint)) {
    query['RequestFingerprint'] = request.requestFingerprint;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListOOSLogs',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listOOSLogs(request: ListOOSLogsRequest): ListOOSLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listOOSLogsWithOptions(request, runtime);
}

model ListPublicParametersRequest {
  maxResults?: int32(name='MaxResults'),
  name?: string(name='Name'),
  nextToken?: string(name='NextToken'),
  parameterType?: string(name='ParameterType'),
  path?: string(name='Path'),
  recursive?: boolean(name='Recursive'),
  regionId?: string(name='RegionId'),
  sortField?: string(name='SortField'),
  sortOrder?: string(name='SortOrder'),
}

model ListPublicParametersResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  parameters?: [ 
    {
      createdBy?: string(name='CreatedBy'),
      createdDate?: string(name='CreatedDate'),
      description?: string(name='Description'),
      id?: string(name='Id'),
      name?: string(name='Name'),
      parameterVersion?: string(name='ParameterVersion'),
      regionId?: string(name='RegionId'),
      shareType?: string(name='ShareType'),
      type?: string(name='Type'),
      updatedBy?: string(name='UpdatedBy'),
      updatedDate?: string(name='UpdatedDate'),
    }
  ](name='Parameters'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListPublicParametersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPublicParametersResponseBody(name='body'),
}

async function listPublicParametersWithOptions(request: ListPublicParametersRequest, runtime: Util.RuntimeOptions): ListPublicParametersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.parameterType)) {
    query['ParameterType'] = request.parameterType;
  }
  if (!Util.isUnset(request.path)) {
    query['Path'] = request.path;
  }
  if (!Util.isUnset(request.recursive)) {
    query['Recursive'] = request.recursive;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.sortField)) {
    query['SortField'] = request.sortField;
  }
  if (!Util.isUnset(request.sortOrder)) {
    query['SortOrder'] = request.sortOrder;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPublicParameters',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPublicParameters(request: ListPublicParametersRequest): ListPublicParametersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPublicParametersWithOptions(request, runtime);
}

model ListPublicPatchBaselinesRequest {
  maxResults?: int32(name='MaxResults'),
  name?: string(name='Name'),
  nextToken?: string(name='NextToken'),
  operationSystem?: string(name='OperationSystem'),
  regionId?: string(name='RegionId'),
  shareType?: string(name='ShareType'),
}

model ListPublicPatchBaselinesResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  patchBaselines?: [ 
    {
      createdBy?: string(name='CreatedBy'),
      createdDate?: string(name='CreatedDate'),
      description?: string(name='Description'),
      id?: string(name='Id'),
      isDefault?: boolean(name='IsDefault'),
      name?: string(name='Name'),
      operationSystem?: string(name='OperationSystem'),
      shareType?: string(name='ShareType'),
      updatedBy?: string(name='UpdatedBy'),
      updatedDate?: string(name='UpdatedDate'),
    }
  ](name='PatchBaselines'),
  requestId?: string(name='RequestId'),
}

model ListPublicPatchBaselinesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPublicPatchBaselinesResponseBody(name='body'),
}

async function listPublicPatchBaselinesWithOptions(request: ListPublicPatchBaselinesRequest, runtime: Util.RuntimeOptions): ListPublicPatchBaselinesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.operationSystem)) {
    query['OperationSystem'] = request.operationSystem;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.shareType)) {
    query['ShareType'] = request.shareType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPublicPatchBaselines',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPublicPatchBaselines(request: ListPublicPatchBaselinesRequest): ListPublicPatchBaselinesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPublicPatchBaselinesWithOptions(request, runtime);
}

model ListPublicTemplateRegistrationsRequest {
  maxResults?: long(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  registrationId?: string(name='RegistrationId'),
  status?: string(name='Status'),
  templateName?: string(name='TemplateName'),
}

model ListPublicTemplateRegistrationsResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  registrations?: [ 
    {
      comment?: string(name='Comment'),
      detail?: string(name='Detail'),
      registrationId?: string(name='RegistrationId'),
      status?: string(name='Status'),
      templateId?: string(name='TemplateId'),
      templateName?: string(name='TemplateName'),
      templateVersion?: string(name='TemplateVersion'),
    }
  ](name='Registrations'),
  requestId?: string(name='RequestId'),
}

model ListPublicTemplateRegistrationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPublicTemplateRegistrationsResponseBody(name='body'),
}

async function listPublicTemplateRegistrationsWithOptions(request: ListPublicTemplateRegistrationsRequest, runtime: Util.RuntimeOptions): ListPublicTemplateRegistrationsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.registrationId)) {
    query['RegistrationId'] = request.registrationId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.templateName)) {
    query['TemplateName'] = request.templateName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPublicTemplateRegistrations',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPublicTemplateRegistrations(request: ListPublicTemplateRegistrationsRequest): ListPublicTemplateRegistrationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPublicTemplateRegistrationsWithOptions(request, runtime);
}

model ListPublicTemplatesRequest {
  createdBy?: string(name='CreatedBy'),
  createdDateAfter?: string(name='CreatedDateAfter'),
  createdDateBefore?: string(name='CreatedDateBefore'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  popularity?: int32(name='Popularity'),
  regionId?: string(name='RegionId'),
  shareType?: string(name='ShareType'),
  sortField?: string(name='SortField'),
  sortOrder?: string(name='SortOrder'),
  templateFormat?: string(name='TemplateFormat'),
  templateName?: string(name='TemplateName'),
}

model ListPublicTemplatesResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  templates?: [ 
    {
      createdBy?: string(name='CreatedBy'),
      createdDate?: string(name='CreatedDate'),
      description?: string(name='Description'),
      hash?: string(name='Hash'),
      popularity?: int32(name='Popularity'),
      shareType?: string(name='ShareType'),
      templateFormat?: string(name='TemplateFormat'),
      templateId?: string(name='TemplateId'),
      templateName?: string(name='TemplateName'),
      templateVersion?: string(name='TemplateVersion'),
      totalExecutionCount?: int32(name='TotalExecutionCount'),
      updatedBy?: string(name='UpdatedBy'),
      updatedDate?: string(name='UpdatedDate'),
    }
  ](name='Templates'),
}

model ListPublicTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPublicTemplatesResponseBody(name='body'),
}

async function listPublicTemplatesWithOptions(request: ListPublicTemplatesRequest, runtime: Util.RuntimeOptions): ListPublicTemplatesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.createdBy)) {
    query['CreatedBy'] = request.createdBy;
  }
  if (!Util.isUnset(request.createdDateAfter)) {
    query['CreatedDateAfter'] = request.createdDateAfter;
  }
  if (!Util.isUnset(request.createdDateBefore)) {
    query['CreatedDateBefore'] = request.createdDateBefore;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.popularity)) {
    query['Popularity'] = request.popularity;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.shareType)) {
    query['ShareType'] = request.shareType;
  }
  if (!Util.isUnset(request.sortField)) {
    query['SortField'] = request.sortField;
  }
  if (!Util.isUnset(request.sortOrder)) {
    query['SortOrder'] = request.sortOrder;
  }
  if (!Util.isUnset(request.templateFormat)) {
    query['TemplateFormat'] = request.templateFormat;
  }
  if (!Util.isUnset(request.templateName)) {
    query['TemplateName'] = request.templateName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPublicTemplates',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPublicTemplates(request: ListPublicTemplatesRequest): ListPublicTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPublicTemplatesWithOptions(request, runtime);
}

model ListUserExecutionLogsRequest {
  aliUid?: string(name='AliUid'),
  executionId?: string(name='ExecutionId'),
  logType?: string(name='LogType'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  taskExecutionId?: string(name='TaskExecutionId'),
}

model ListUserExecutionLogsResponseBody = {
  executionLogs?: [ 
    {
      logType?: string(name='LogType'),
      message?: string(name='Message'),
      taskExecutionId?: string(name='TaskExecutionId'),
      timestamp?: string(name='Timestamp'),
    }
  ](name='ExecutionLogs'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model ListUserExecutionLogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListUserExecutionLogsResponseBody(name='body'),
}

async function listUserExecutionLogsWithOptions(request: ListUserExecutionLogsRequest, runtime: Util.RuntimeOptions): ListUserExecutionLogsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliUid)) {
    query['AliUid'] = request.aliUid;
  }
  if (!Util.isUnset(request.executionId)) {
    query['ExecutionId'] = request.executionId;
  }
  if (!Util.isUnset(request.logType)) {
    query['LogType'] = request.logType;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.taskExecutionId)) {
    query['TaskExecutionId'] = request.taskExecutionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUserExecutionLogs',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listUserExecutionLogs(request: ListUserExecutionLogsRequest): ListUserExecutionLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUserExecutionLogsWithOptions(request, runtime);
}

model ListUserExecutionsRequest {
  aliUid?: string(name='AliUid'),
  endDateAfter?: string(name='EndDateAfter'),
  endDateBefore?: string(name='EndDateBefore'),
  executedBy?: string(name='ExecutedBy'),
  executionId?: string(name='ExecutionId'),
  includeChildExecution?: boolean(name='IncludeChildExecution'),
  maxResults?: int32(name='MaxResults'),
  mode?: string(name='Mode'),
  nextToken?: string(name='NextToken'),
  parentExecutionId?: string(name='ParentExecutionId'),
  ramRole?: string(name='RamRole'),
  regionId?: string(name='RegionId'),
  sortField?: string(name='SortField'),
  sortOrder?: string(name='SortOrder'),
  startDateAfter?: string(name='StartDateAfter'),
  startDateBefore?: string(name='StartDateBefore'),
  status?: string(name='Status'),
  templateName?: string(name='TemplateName'),
}

model ListUserExecutionsResponseBody = {
  executions?: [ 
    {
      counters?: string(name='Counters'),
      createDate?: string(name='CreateDate'),
      currentTasks?: [ 
        {
          taskAction?: string(name='TaskAction'),
          taskExecutionId?: string(name='TaskExecutionId'),
          taskName?: string(name='TaskName'),
        }
      ](name='CurrentTasks'),
      endDate?: string(name='EndDate'),
      executedBy?: string(name='ExecutedBy'),
      executionId?: string(name='ExecutionId'),
      isParent?: boolean(name='IsParent'),
      mode?: string(name='Mode'),
      outputs?: string(name='Outputs'),
      parameters?: string(name='Parameters'),
      parentExecutionId?: string(name='ParentExecutionId'),
      ramRole?: string(name='RamRole'),
      safetyCheck?: string(name='SafetyCheck'),
      startDate?: string(name='StartDate'),
      status?: string(name='Status'),
      statusMessage?: string(name='StatusMessage'),
      templateId?: string(name='TemplateId'),
      templateName?: string(name='TemplateName'),
      templateVersion?: string(name='TemplateVersion'),
      updateDate?: string(name='UpdateDate'),
      waitingStatus?: string(name='WaitingStatus'),
    }
  ](name='Executions'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model ListUserExecutionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListUserExecutionsResponseBody(name='body'),
}

async function listUserExecutionsWithOptions(request: ListUserExecutionsRequest, runtime: Util.RuntimeOptions): ListUserExecutionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliUid)) {
    query['AliUid'] = request.aliUid;
  }
  if (!Util.isUnset(request.endDateAfter)) {
    query['EndDateAfter'] = request.endDateAfter;
  }
  if (!Util.isUnset(request.endDateBefore)) {
    query['EndDateBefore'] = request.endDateBefore;
  }
  if (!Util.isUnset(request.executedBy)) {
    query['ExecutedBy'] = request.executedBy;
  }
  if (!Util.isUnset(request.executionId)) {
    query['ExecutionId'] = request.executionId;
  }
  if (!Util.isUnset(request.includeChildExecution)) {
    query['IncludeChildExecution'] = request.includeChildExecution;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.mode)) {
    query['Mode'] = request.mode;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.parentExecutionId)) {
    query['ParentExecutionId'] = request.parentExecutionId;
  }
  if (!Util.isUnset(request.ramRole)) {
    query['RamRole'] = request.ramRole;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.sortField)) {
    query['SortField'] = request.sortField;
  }
  if (!Util.isUnset(request.sortOrder)) {
    query['SortOrder'] = request.sortOrder;
  }
  if (!Util.isUnset(request.startDateAfter)) {
    query['StartDateAfter'] = request.startDateAfter;
  }
  if (!Util.isUnset(request.startDateBefore)) {
    query['StartDateBefore'] = request.startDateBefore;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.templateName)) {
    query['TemplateName'] = request.templateName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUserExecutions',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listUserExecutions(request: ListUserExecutionsRequest): ListUserExecutionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUserExecutionsWithOptions(request, runtime);
}

model ListUserInstancePatchStatesRequest {
  aliUid?: string(name='AliUid'),
  instanceIds?: string(name='InstanceIds'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
}

model ListUserInstancePatchStatesResponseBody = {
  instancePatchStates?: [ 
    {
      baselineId?: string(name='BaselineId'),
      failedCount?: string(name='FailedCount'),
      installedCount?: string(name='InstalledCount'),
      installedOtherCount?: string(name='InstalledOtherCount'),
      installedPendingRebootCount?: string(name='InstalledPendingRebootCount'),
      installedRejectedCount?: string(name='InstalledRejectedCount'),
      instanceId?: string(name='InstanceId'),
      missingCount?: string(name='MissingCount'),
      operationEndTime?: string(name='OperationEndTime'),
      operationStartTime?: string(name='OperationStartTime'),
      operationType?: string(name='OperationType'),
      ownerInformation?: string(name='OwnerInformation'),
      patchGroup?: string(name='PatchGroup'),
    }
  ](name='InstancePatchStates'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model ListUserInstancePatchStatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListUserInstancePatchStatesResponseBody(name='body'),
}

async function listUserInstancePatchStatesWithOptions(request: ListUserInstancePatchStatesRequest, runtime: Util.RuntimeOptions): ListUserInstancePatchStatesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliUid)) {
    query['AliUid'] = request.aliUid;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUserInstancePatchStates',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listUserInstancePatchStates(request: ListUserInstancePatchStatesRequest): ListUserInstancePatchStatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUserInstancePatchStatesWithOptions(request, runtime);
}

model ListUserInstancePatchesRequest {
  aliUid?: string(name='AliUid'),
  instanceId?: string(name='InstanceId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
}

model ListUserInstancePatchesResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  patches?: [ 
    {
      classification?: string(name='Classification'),
      installedTime?: string(name='InstalledTime'),
      KBId?: string(name='KBId'),
      severity?: string(name='Severity'),
      status?: string(name='Status'),
      title?: string(name='Title'),
    }
  ](name='Patches'),
  requestId?: string(name='RequestId'),
}

model ListUserInstancePatchesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListUserInstancePatchesResponseBody(name='body'),
}

async function listUserInstancePatchesWithOptions(request: ListUserInstancePatchesRequest, runtime: Util.RuntimeOptions): ListUserInstancePatchesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliUid)) {
    query['AliUid'] = request.aliUid;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUserInstancePatches',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listUserInstancePatches(request: ListUserInstancePatchesRequest): ListUserInstancePatchesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUserInstancePatchesWithOptions(request, runtime);
}

model ListUserInventoryEntriesRequest {
  aliUid?: string(name='AliUid'),
  filter?: [ 
    {
      name?: string(name='Name'),
      operator?: string(name='Operator'),
      value?: [ string ](name='Value'),
    }
  ](name='Filter'),
  instanceId?: string(name='InstanceId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  typeName?: string(name='TypeName'),
}

model ListUserInventoryEntriesResponseBody = {
  captureTime?: string(name='CaptureTime'),
  entries?: [  map[string]any ](name='Entries'),
  instanceId?: string(name='InstanceId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  schemaVersion?: string(name='SchemaVersion'),
  typeName?: string(name='TypeName'),
}

model ListUserInventoryEntriesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListUserInventoryEntriesResponseBody(name='body'),
}

async function listUserInventoryEntriesWithOptions(request: ListUserInventoryEntriesRequest, runtime: Util.RuntimeOptions): ListUserInventoryEntriesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliUid)) {
    query['AliUid'] = request.aliUid;
  }
  if (!Util.isUnset(request.filter)) {
    query['Filter'] = request.filter;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.typeName)) {
    query['TypeName'] = request.typeName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUserInventoryEntries',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listUserInventoryEntries(request: ListUserInventoryEntriesRequest): ListUserInventoryEntriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUserInventoryEntriesWithOptions(request, runtime);
}

model ListUserTaskExecutionsRequest {
  aliUid?: string(name='AliUid'),
  endDateAfter?: string(name='EndDateAfter'),
  endDateBefore?: string(name='EndDateBefore'),
  executionId?: string(name='ExecutionId'),
  includeChildTaskExecution?: boolean(name='IncludeChildTaskExecution'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  parentTaskExecutionId?: string(name='ParentTaskExecutionId'),
  regionId?: string(name='RegionId'),
  sortField?: string(name='SortField'),
  sortOrder?: string(name='SortOrder'),
  startDateAfter?: string(name='StartDateAfter'),
  startDateBefore?: string(name='StartDateBefore'),
  status?: string(name='Status'),
  taskAction?: string(name='TaskAction'),
  taskExecutionId?: string(name='TaskExecutionId'),
  taskName?: string(name='TaskName'),
}

model ListUserTaskExecutionsResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  taskExecutions?: [ 
    {
      childExecutionId?: string(name='ChildExecutionId'),
      createDate?: string(name='CreateDate'),
      endDate?: string(name='EndDate'),
      executionId?: string(name='ExecutionId'),
      extraData?: string(name='ExtraData'),
      loop?: string(name='Loop'),
      loopBatchNumber?: int32(name='LoopBatchNumber'),
      loopItem?: string(name='LoopItem'),
      outputs?: string(name='Outputs'),
      parentTaskExecutionId?: string(name='ParentTaskExecutionId'),
      properties?: string(name='Properties'),
      startDate?: string(name='StartDate'),
      status?: string(name='Status'),
      statusMessage?: string(name='StatusMessage'),
      taskAction?: string(name='TaskAction'),
      taskExecutionId?: string(name='TaskExecutionId'),
      taskName?: string(name='TaskName'),
      templateId?: string(name='TemplateId'),
      updateDate?: string(name='UpdateDate'),
    }
  ](name='TaskExecutions'),
}

model ListUserTaskExecutionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListUserTaskExecutionsResponseBody(name='body'),
}

async function listUserTaskExecutionsWithOptions(request: ListUserTaskExecutionsRequest, runtime: Util.RuntimeOptions): ListUserTaskExecutionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliUid)) {
    query['AliUid'] = request.aliUid;
  }
  if (!Util.isUnset(request.endDateAfter)) {
    query['EndDateAfter'] = request.endDateAfter;
  }
  if (!Util.isUnset(request.endDateBefore)) {
    query['EndDateBefore'] = request.endDateBefore;
  }
  if (!Util.isUnset(request.executionId)) {
    query['ExecutionId'] = request.executionId;
  }
  if (!Util.isUnset(request.includeChildTaskExecution)) {
    query['IncludeChildTaskExecution'] = request.includeChildTaskExecution;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.parentTaskExecutionId)) {
    query['ParentTaskExecutionId'] = request.parentTaskExecutionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.sortField)) {
    query['SortField'] = request.sortField;
  }
  if (!Util.isUnset(request.sortOrder)) {
    query['SortOrder'] = request.sortOrder;
  }
  if (!Util.isUnset(request.startDateAfter)) {
    query['StartDateAfter'] = request.startDateAfter;
  }
  if (!Util.isUnset(request.startDateBefore)) {
    query['StartDateBefore'] = request.startDateBefore;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.taskAction)) {
    query['TaskAction'] = request.taskAction;
  }
  if (!Util.isUnset(request.taskExecutionId)) {
    query['TaskExecutionId'] = request.taskExecutionId;
  }
  if (!Util.isUnset(request.taskName)) {
    query['TaskName'] = request.taskName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUserTaskExecutions',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listUserTaskExecutions(request: ListUserTaskExecutionsRequest): ListUserTaskExecutionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUserTaskExecutionsWithOptions(request, runtime);
}

model ListUserTemplatesRequest {
  aliUid?: string(name='AliUid'),
  category?: string(name='Category'),
  createdBy?: string(name='CreatedBy'),
  createdDateAfter?: string(name='CreatedDateAfter'),
  createdDateBefore?: string(name='CreatedDateBefore'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  popularity?: int32(name='Popularity'),
  regionId?: string(name='RegionId'),
  shareType?: string(name='ShareType'),
  sortField?: string(name='SortField'),
  sortOrder?: string(name='SortOrder'),
  templateFormat?: string(name='TemplateFormat'),
  templateName?: string(name='TemplateName'),
  templateType?: string(name='TemplateType'),
}

model ListUserTemplatesResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  templates?: [ 
    {
      createdBy?: string(name='CreatedBy'),
      createdDate?: string(name='CreatedDate'),
      description?: string(name='Description'),
      hash?: string(name='Hash'),
      popularity?: int32(name='Popularity'),
      shareType?: string(name='ShareType'),
      templateFormat?: string(name='TemplateFormat'),
      templateId?: string(name='TemplateId'),
      templateName?: string(name='TemplateName'),
      templateVersion?: string(name='TemplateVersion'),
      totalExecutionCount?: int32(name='TotalExecutionCount'),
      updatedBy?: string(name='UpdatedBy'),
      updatedDate?: string(name='UpdatedDate'),
    }
  ](name='Templates'),
}

model ListUserTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListUserTemplatesResponseBody(name='body'),
}

async function listUserTemplatesWithOptions(request: ListUserTemplatesRequest, runtime: Util.RuntimeOptions): ListUserTemplatesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliUid)) {
    query['AliUid'] = request.aliUid;
  }
  if (!Util.isUnset(request.category)) {
    query['Category'] = request.category;
  }
  if (!Util.isUnset(request.createdBy)) {
    query['CreatedBy'] = request.createdBy;
  }
  if (!Util.isUnset(request.createdDateAfter)) {
    query['CreatedDateAfter'] = request.createdDateAfter;
  }
  if (!Util.isUnset(request.createdDateBefore)) {
    query['CreatedDateBefore'] = request.createdDateBefore;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.popularity)) {
    query['Popularity'] = request.popularity;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.shareType)) {
    query['ShareType'] = request.shareType;
  }
  if (!Util.isUnset(request.sortField)) {
    query['SortField'] = request.sortField;
  }
  if (!Util.isUnset(request.sortOrder)) {
    query['SortOrder'] = request.sortOrder;
  }
  if (!Util.isUnset(request.templateFormat)) {
    query['TemplateFormat'] = request.templateFormat;
  }
  if (!Util.isUnset(request.templateName)) {
    query['TemplateName'] = request.templateName;
  }
  if (!Util.isUnset(request.templateType)) {
    query['TemplateType'] = request.templateType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUserTemplates',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listUserTemplates(request: ListUserTemplatesRequest): ListUserTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUserTemplatesWithOptions(request, runtime);
}

model ResetTimerTriggerExecutionRequest {
  aliUid?: string(name='AliUid'),
  executionId?: string(name='ExecutionId'),
  regionId?: string(name='RegionId'),
}

model ResetTimerTriggerExecutionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ResetTimerTriggerExecutionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ResetTimerTriggerExecutionResponseBody(name='body'),
}

async function resetTimerTriggerExecutionWithOptions(request: ResetTimerTriggerExecutionRequest, runtime: Util.RuntimeOptions): ResetTimerTriggerExecutionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliUid)) {
    query['AliUid'] = request.aliUid;
  }
  if (!Util.isUnset(request.executionId)) {
    query['ExecutionId'] = request.executionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResetTimerTriggerExecution',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function resetTimerTriggerExecution(request: ResetTimerTriggerExecutionRequest): ResetTimerTriggerExecutionResponse {
  var runtime = new Util.RuntimeOptions{};
  return resetTimerTriggerExecutionWithOptions(request, runtime);
}

model ResetUserExecutionRequest {
  aliUid?: string(name='AliUid'),
  executionId?: string(name='ExecutionId'),
  regionId?: string(name='RegionId'),
  status?: string(name='Status'),
}

model ResetUserExecutionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ResetUserExecutionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ResetUserExecutionResponseBody(name='body'),
}

async function resetUserExecutionWithOptions(request: ResetUserExecutionRequest, runtime: Util.RuntimeOptions): ResetUserExecutionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliUid)) {
    query['AliUid'] = request.aliUid;
  }
  if (!Util.isUnset(request.executionId)) {
    query['ExecutionId'] = request.executionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResetUserExecution',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function resetUserExecution(request: ResetUserExecutionRequest): ResetUserExecutionResponse {
  var runtime = new Util.RuntimeOptions{};
  return resetUserExecutionWithOptions(request, runtime);
}

model SetFlowControlRequest {
  api?: string(name='Api'),
  service?: string(name='Service'),
  type?: int32(name='Type'),
  uid?: string(name='Uid'),
  value?: int32(name='Value'),
}

model SetFlowControlResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetFlowControlResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetFlowControlResponseBody(name='body'),
}

async function setFlowControlWithOptions(request: SetFlowControlRequest, runtime: Util.RuntimeOptions): SetFlowControlResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.api)) {
    query['Api'] = request.api;
  }
  if (!Util.isUnset(request.service)) {
    query['Service'] = request.service;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.uid)) {
    query['Uid'] = request.uid;
  }
  if (!Util.isUnset(request.value)) {
    query['Value'] = request.value;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetFlowControl',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setFlowControl(request: SetFlowControlRequest): SetFlowControlResponse {
  var runtime = new Util.RuntimeOptions{};
  return setFlowControlWithOptions(request, runtime);
}

model SetQuotaRequest {
  quotaName?: string(name='QuotaName'),
  regionId?: string(name='RegionId'),
  uid?: string(name='Uid'),
  value?: string(name='Value'),
}

model SetQuotaResponseBody = {
  quota?: int32(name='Quota'),
  requestId?: string(name='RequestId'),
  uid?: string(name='Uid'),
}

model SetQuotaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetQuotaResponseBody(name='body'),
}

async function setQuotaWithOptions(request: SetQuotaRequest, runtime: Util.RuntimeOptions): SetQuotaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.quotaName)) {
    query['QuotaName'] = request.quotaName;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.uid)) {
    query['Uid'] = request.uid;
  }
  if (!Util.isUnset(request.value)) {
    query['Value'] = request.value;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetQuota',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setQuota(request: SetQuotaRequest): SetQuotaResponse {
  var runtime = new Util.RuntimeOptions{};
  return setQuotaWithOptions(request, runtime);
}

model TerminateUserExecutionRequest {
  aliUid?: string(name='AliUid'),
  executionId?: string(name='ExecutionId'),
  regionId?: string(name='RegionId'),
}

model TerminateUserExecutionResponseBody = {
  requestId?: string(name='RequestId'),
}

model TerminateUserExecutionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TerminateUserExecutionResponseBody(name='body'),
}

async function terminateUserExecutionWithOptions(request: TerminateUserExecutionRequest, runtime: Util.RuntimeOptions): TerminateUserExecutionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliUid)) {
    query['AliUid'] = request.aliUid;
  }
  if (!Util.isUnset(request.executionId)) {
    query['ExecutionId'] = request.executionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TerminateUserExecution',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function terminateUserExecution(request: TerminateUserExecutionRequest): TerminateUserExecutionResponse {
  var runtime = new Util.RuntimeOptions{};
  return terminateUserExecutionWithOptions(request, runtime);
}

model UpdateActionRequest {
  actionName?: string(name='ActionName'),
  actionType?: string(name='ActionType'),
  content?: string(name='Content'),
  popularity?: int32(name='Popularity'),
  regionId?: string(name='RegionId'),
}

model UpdateActionResponseBody = {
  actionName?: string(name='ActionName'),
  actionType?: string(name='ActionType'),
  createdDate?: string(name='CreatedDate'),
  description?: string(name='Description'),
  popularity?: int32(name='Popularity'),
  properties?: string(name='Properties'),
  requestId?: string(name='RequestId'),
  templateVersion?: string(name='TemplateVersion'),
}

model UpdateActionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateActionResponseBody(name='body'),
}

async function updateActionWithOptions(request: UpdateActionRequest, runtime: Util.RuntimeOptions): UpdateActionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.actionName)) {
    query['ActionName'] = request.actionName;
  }
  if (!Util.isUnset(request.actionType)) {
    query['ActionType'] = request.actionType;
  }
  if (!Util.isUnset(request.content)) {
    query['Content'] = request.content;
  }
  if (!Util.isUnset(request.popularity)) {
    query['Popularity'] = request.popularity;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAction',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAction(request: UpdateActionRequest): UpdateActionResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateActionWithOptions(request, runtime);
}

model UpdatePublicParameterRequest {
  description?: string(name='Description'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
  value?: string(name='Value'),
}

model UpdatePublicParameterResponseBody = {
  parameter?: {
    constraints?: string(name='Constraints'),
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    name?: string(name='Name'),
    parameterVersion?: int32(name='ParameterVersion'),
    regionId?: string(name='RegionId'),
    shareType?: string(name='ShareType'),
    type?: string(name='Type'),
    updatedBy?: string(name='UpdatedBy'),
    updatedDate?: string(name='UpdatedDate'),
  }(name='Parameter'),
  requestId?: string(name='RequestId'),
}

model UpdatePublicParameterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdatePublicParameterResponseBody(name='body'),
}

async function updatePublicParameterWithOptions(request: UpdatePublicParameterRequest, runtime: Util.RuntimeOptions): UpdatePublicParameterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.value)) {
    query['Value'] = request.value;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdatePublicParameter',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updatePublicParameter(request: UpdatePublicParameterRequest): UpdatePublicParameterResponse {
  var runtime = new Util.RuntimeOptions{};
  return updatePublicParameterWithOptions(request, runtime);
}

model UpdatePublicPatchBaselineRequest {
  approvalRules?: string(name='ApprovalRules'),
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
}

model UpdatePublicPatchBaselineResponseBody = {
  patchBaseline?: {
    approvalRules?: string(name='ApprovalRules'),
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    name?: string(name='Name'),
    operationSystem?: string(name='OperationSystem'),
    shareType?: string(name='ShareType'),
    updatedBy?: string(name='UpdatedBy'),
    updatedDate?: string(name='UpdatedDate'),
  }(name='PatchBaseline'),
  requestId?: string(name='RequestId'),
}

model UpdatePublicPatchBaselineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdatePublicPatchBaselineResponseBody(name='body'),
}

async function updatePublicPatchBaselineWithOptions(request: UpdatePublicPatchBaselineRequest, runtime: Util.RuntimeOptions): UpdatePublicPatchBaselineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.approvalRules)) {
    query['ApprovalRules'] = request.approvalRules;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdatePublicPatchBaseline',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updatePublicPatchBaseline(request: UpdatePublicPatchBaselineRequest): UpdatePublicPatchBaselineResponse {
  var runtime = new Util.RuntimeOptions{};
  return updatePublicPatchBaselineWithOptions(request, runtime);
}

model UpdatePublicTemplateRequest {
  content?: string(name='Content'),
  popularity?: int32(name='Popularity'),
  publisher?: string(name='Publisher'),
  regionId?: string(name='RegionId'),
  templateName?: string(name='TemplateName'),
}

model UpdatePublicTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  template?: {
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    description?: string(name='Description'),
    hash?: string(name='Hash'),
    popularity?: int32(name='Popularity'),
    shareType?: string(name='ShareType'),
    templateFormat?: string(name='TemplateFormat'),
    templateId?: string(name='TemplateId'),
    templateName?: string(name='TemplateName'),
    templateVersion?: string(name='TemplateVersion'),
    updatedBy?: string(name='UpdatedBy'),
    updatedDate?: string(name='UpdatedDate'),
  }(name='Template'),
}

model UpdatePublicTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdatePublicTemplateResponseBody(name='body'),
}

async function updatePublicTemplateWithOptions(request: UpdatePublicTemplateRequest, runtime: Util.RuntimeOptions): UpdatePublicTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.content)) {
    query['Content'] = request.content;
  }
  if (!Util.isUnset(request.popularity)) {
    query['Popularity'] = request.popularity;
  }
  if (!Util.isUnset(request.publisher)) {
    query['Publisher'] = request.publisher;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.templateName)) {
    query['TemplateName'] = request.templateName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdatePublicTemplate',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updatePublicTemplate(request: UpdatePublicTemplateRequest): UpdatePublicTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return updatePublicTemplateWithOptions(request, runtime);
}

model ValidatePublicTemplateContentRequest {
  content?: string(name='Content'),
  regionId?: string(name='RegionId'),
  templateName?: string(name='TemplateName'),
  type?: string(name='Type'),
}

model ValidatePublicTemplateContentResponseBody = {
  description?: string(name='Description'),
  outputs?: string(name='Outputs'),
  parameters?: string(name='Parameters'),
  ramRole?: string(name='RamRole'),
  requestId?: string(name='RequestId'),
  tasks?: [ 
    {
      description?: string(name='Description'),
      name?: string(name='Name'),
      outputs?: string(name='Outputs'),
      properties?: string(name='Properties'),
      type?: string(name='Type'),
    }
  ](name='Tasks'),
}

model ValidatePublicTemplateContentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ValidatePublicTemplateContentResponseBody(name='body'),
}

async function validatePublicTemplateContentWithOptions(request: ValidatePublicTemplateContentRequest, runtime: Util.RuntimeOptions): ValidatePublicTemplateContentResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.content)) {
    query['Content'] = request.content;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.templateName)) {
    query['TemplateName'] = request.templateName;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ValidatePublicTemplateContent',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function validatePublicTemplateContent(request: ValidatePublicTemplateContentRequest): ValidatePublicTemplateContentResponse {
  var runtime = new Util.RuntimeOptions{};
  return validatePublicTemplateContentWithOptions(request, runtime);
}

