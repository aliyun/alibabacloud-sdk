/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'oos';
  @version = '2019-06-01';
  @endpointRule = 'regional';
  @endpointMap = {
  };
}

function close(): void {
  @handler.close();
}

model CancelExecutionRequest {
  executionId: string(name='ExecutionId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model CancelExecutionResponseBody = {
  requestId?: string(name='RequestId'),
}

model CancelExecutionResponse = {
  headers: map[string]string(name='headers'),
  body: CancelExecutionResponseBody(name='body'),
}

async function cancelExecution(request: CancelExecutionRequest): CancelExecutionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CancelExecution', 'POST', '/CancelExecution', 'json', false, 'json', request);
}

model ChangeResourceGroupRequest {
  newResourceGroupId: string(name='NewResourceGroupId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceId: string(name='ResourceId', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
}

model ChangeResourceGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model ChangeResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ChangeResourceGroupResponseBody(name='body'),
}

async function changeResourceGroup(request: ChangeResourceGroupRequest): ChangeResourceGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ChangeResourceGroup', 'POST', '/', 'json', false, 'json', request);
}

model ContinueDeployApplicationGroupRequest {
  applicationName: string(name='ApplicationName', position='Query'),
  deployParameters: string(name='DeployParameters', position='Query'),
  name: string(name='Name', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model ContinueDeployApplicationGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model ContinueDeployApplicationGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ContinueDeployApplicationGroupResponseBody(name='body'),
}

async function continueDeployApplicationGroup(request: ContinueDeployApplicationGroupRequest): ContinueDeployApplicationGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ContinueDeployApplicationGroup', 'POST', '/', 'json', false, 'json', request);
}

model CreateApplicationRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  name: string(name='Name', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  tags?: map[string]any(name='Tags', shrink='json', position='Query'),
}

model CreateApplicationResponseBody = {
  application?: {
    createDate?: string(name='CreateDate'),
    description?: string(name='Description'),
    name?: string(name='Name'),
    tags?: map[string]string(name='Tags'),
    updateDate?: string(name='UpdateDate'),
  }(name='Application'),
  requestId?: string(name='RequestId'),
}

model CreateApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: CreateApplicationResponseBody(name='body'),
}

async function createApplication(request: CreateApplicationRequest): CreateApplicationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateApplication', 'POST', '/', 'json', false, 'json', request);
}

model CreateApplicationGroupRequest {
  applicationName: string(name='ApplicationName', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  cmsGroupId?: string(name='CmsGroupId', position='Query'),
  deployRegionId: string(name='DeployRegionId', position='Query'),
  description?: string(name='Description', position='Query'),
  importTagKey?: string(name='ImportTagKey', position='Query'),
  importTagValue?: string(name='ImportTagValue', position='Query'),
  name: string(name='Name', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model CreateApplicationGroupResponseBody = {
  applicationGroup?: {
    applicationName?: string(name='ApplicationName'),
    cmsGroupId?: string(name='CmsGroupId'),
    createDate?: string(name='CreateDate'),
    deployRegionId?: string(name='DeployRegionId'),
    description?: string(name='Description'),
    importTagKey?: string(name='ImportTagKey'),
    importTagValue?: string(name='ImportTagValue'),
    name?: string(name='Name'),
    updateDate?: string(name='UpdateDate'),
  }(name='ApplicationGroup'),
  requestId?: string(name='RequestId'),
}

model CreateApplicationGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateApplicationGroupResponseBody(name='body'),
}

async function createApplicationGroup(request: CreateApplicationGroupRequest): CreateApplicationGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateApplicationGroup', 'POST', '/', 'json', false, 'json', request);
}

model CreateParameterRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  constraints?: string(name='Constraints', position='Query'),
  description?: string(name='Description', position='Query'),
  name: string(name='Name', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  tags?: map[string]any(name='Tags', shrink='json', position='Query'),
  type: string(name='Type', position='Query'),
  value: string(name='Value', position='Query'),
}

model CreateParameterResponseBody = {
  parameter?: {
    constraints?: string(name='Constraints'),
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    name?: string(name='Name'),
    parameterVersion?: int32(name='ParameterVersion'),
    resourceGroupId?: string(name='ResourceGroupId'),
    shareType?: string(name='ShareType'),
    tags?: map[string]any(name='Tags'),
    type?: string(name='Type'),
    updatedBy?: string(name='UpdatedBy'),
    updatedDate?: string(name='UpdatedDate'),
  }(name='Parameter'),
  requestId?: string(name='RequestId'),
}

model CreateParameterResponse = {
  headers: map[string]string(name='headers'),
  body: CreateParameterResponseBody(name='body'),
}

async function createParameter(request: CreateParameterRequest): CreateParameterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateParameter', 'POST', '/', 'json', false, 'json', request);
}

model CreatePatchBaselineRequest {
  approvalRules: string(name='ApprovalRules', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  name: string(name='Name', position='Query'),
  operationSystem: string(name='OperationSystem', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model CreatePatchBaselineResponseBody = {
  patchBaseline?: {
    approvalRules?: string(name='ApprovalRules'),
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    name?: string(name='Name'),
    operationSystem?: string(name='OperationSystem'),
    shareType?: string(name='ShareType'),
    updatedBy?: string(name='UpdatedBy'),
    updatedDate?: string(name='UpdatedDate'),
  }(name='PatchBaseline'),
  requestId?: string(name='RequestId'),
}

model CreatePatchBaselineResponse = {
  headers: map[string]string(name='headers'),
  body: CreatePatchBaselineResponseBody(name='body'),
}

async function createPatchBaseline(request: CreatePatchBaselineRequest): CreatePatchBaselineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreatePatchBaseline', 'POST', '/', 'json', false, 'json', request);
}

model CreateSecretParameterRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  constraints?: string(name='Constraints', position='Query'),
  description?: string(name='Description', position='Query'),
  keyId?: string(name='KeyId', position='Query'),
  name: string(name='Name', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  tags?: string(name='Tags', position='Query'),
  type?: string(name='Type', position='Query'),
  value: string(name='Value', position='Query'),
}

model CreateSecretParameterResponseBody = {
  parameter?: {
    constraints?: string(name='Constraints'),
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    keyId?: string(name='KeyId'),
    name?: string(name='Name'),
    parameterVersion?: int32(name='ParameterVersion'),
    resourceGroupId?: string(name='ResourceGroupId'),
    shareType?: string(name='ShareType'),
    tags?: string(name='Tags'),
    type?: string(name='Type'),
    updatedBy?: string(name='UpdatedBy'),
    updatedDate?: string(name='UpdatedDate'),
  }(name='Parameter'),
  requestId?: string(name='RequestId'),
}

model CreateSecretParameterResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSecretParameterResponseBody(name='body'),
}

async function createSecretParameter(request: CreateSecretParameterRequest): CreateSecretParameterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateSecretParameter', 'POST', '/', 'json', false, 'json', request);
}

model CreateStateConfigurationRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  configureMode?: string(name='ConfigureMode', position='Query'),
  description?: string(name='Description', position='Query'),
  parameters?: string(name='Parameters', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  scheduleExpression: string(name='ScheduleExpression', position='Query'),
  scheduleType: string(name='ScheduleType', position='Query'),
  tags?: map[string]any(name='Tags', shrink='json', position='Query'),
  targets: string(name='Targets', position='Query'),
  templateName: string(name='TemplateName', position='Query'),
  templateVersion?: string(name='TemplateVersion', position='Query'),
}

model CreateStateConfigurationResponseBody = {
  requestId?: string(name='RequestId'),
  stateConfiguration?: {
    configureMode?: string(name='ConfigureMode'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    parameters?: map[string]any(name='Parameters'),
    resourceGroupId?: string(name='ResourceGroupId'),
    scheduleExpression?: string(name='ScheduleExpression'),
    scheduleType?: string(name='ScheduleType'),
    stateConfigurationId?: string(name='StateConfigurationId'),
    tags?: map[string]any(name='Tags'),
    targets?: string(name='Targets'),
    templateId?: string(name='TemplateId'),
    templateName?: string(name='TemplateName'),
    templateVersion?: string(name='TemplateVersion'),
  }(name='StateConfiguration'),
}

model CreateStateConfigurationResponse = {
  headers: map[string]string(name='headers'),
  body: CreateStateConfigurationResponseBody(name='body'),
}

async function createStateConfiguration(request: CreateStateConfigurationRequest): CreateStateConfigurationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateStateConfiguration', 'POST', '/', 'json', false, 'json', request);
}

model CreateTemplateRequest {
  content: string(name='Content', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  tags?: map[string]any(name='Tags', shrink='json', position='Query'),
  templateName: string(name='TemplateName', position='Query'),
  versionName?: string(name='VersionName', position='Query'),
}

model CreateTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  template?: {
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    description?: string(name='Description'),
    hasTrigger?: boolean(name='HasTrigger'),
    hash?: string(name='Hash'),
    resourceGroupId?: string(name='ResourceGroupId'),
    shareType?: string(name='ShareType'),
    tags?: map[string]any(name='Tags'),
    templateFormat?: string(name='TemplateFormat'),
    templateId?: string(name='TemplateId'),
    templateName?: string(name='TemplateName'),
    templateVersion?: string(name='TemplateVersion'),
    updatedBy?: string(name='UpdatedBy'),
    updatedDate?: string(name='UpdatedDate'),
  }(name='Template'),
  templateType?: string(name='TemplateType'),
}

model CreateTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: CreateTemplateResponseBody(name='body'),
}

async function createTemplate(request: CreateTemplateRequest): CreateTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateTemplate', 'POST', '/CreateTemplate', 'json', false, 'json', request);
}

model DeleteApplicationRequest {
  name: string(name='Name', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DeleteApplicationResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteApplicationResponseBody(name='body'),
}

async function deleteApplication(request: DeleteApplicationRequest): DeleteApplicationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteApplication', 'POST', '/', 'json', false, 'json', request);
}

model DeleteApplicationGroupRequest {
  applicationName: string(name='ApplicationName', position='Query'),
  name: string(name='Name', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DeleteApplicationGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteApplicationGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteApplicationGroupResponseBody(name='body'),
}

async function deleteApplicationGroup(request: DeleteApplicationGroupRequest): DeleteApplicationGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteApplicationGroup', 'POST', '/', 'json', false, 'json', request);
}

model DeleteExecutionsRequest {
  executionIds: string(name='ExecutionIds', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DeleteExecutionsResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteExecutionsResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteExecutionsResponseBody(name='body'),
}

async function deleteExecutions(request: DeleteExecutionsRequest): DeleteExecutionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteExecutions', 'POST', '/DeleteExecutions', 'json', false, 'json', request);
}

model DeleteParameterRequest {
  name: string(name='Name', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DeleteParameterResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteParameterResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteParameterResponseBody(name='body'),
}

async function deleteParameter(request: DeleteParameterRequest): DeleteParameterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteParameter', 'POST', '/', 'json', false, 'json', request);
}

model DeletePatchBaselineRequest {
  name: string(name='Name', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DeletePatchBaselineResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeletePatchBaselineResponse = {
  headers: map[string]string(name='headers'),
  body: DeletePatchBaselineResponseBody(name='body'),
}

async function deletePatchBaseline(request: DeletePatchBaselineRequest): DeletePatchBaselineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeletePatchBaseline', 'POST', '/', 'json', false, 'json', request);
}

model DeleteSecretParameterRequest {
  name: string(name='Name', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DeleteSecretParameterResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteSecretParameterResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSecretParameterResponseBody(name='body'),
}

async function deleteSecretParameter(request: DeleteSecretParameterRequest): DeleteSecretParameterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteSecretParameter', 'POST', '/', 'json', false, 'json', request);
}

model DeleteStateConfigurationsRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  stateConfigurationIds: string(name='StateConfigurationIds', position='Query'),
}

model DeleteStateConfigurationsResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteStateConfigurationsResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteStateConfigurationsResponseBody(name='body'),
}

async function deleteStateConfigurations(request: DeleteStateConfigurationsRequest): DeleteStateConfigurationsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteStateConfigurations', 'POST', '/', 'json', false, 'json', request);
}

model DeleteTemplateRequest {
  autoDeleteExecutions?: boolean(name='AutoDeleteExecutions', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  templateName: string(name='TemplateName', position='Query'),
}

model DeleteTemplateResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteTemplateResponseBody(name='body'),
}

async function deleteTemplate(request: DeleteTemplateRequest): DeleteTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteTemplate', 'POST', '/DeleteTemplate', 'json', false, 'json', request);
}

model DeleteTemplatesRequest {
  autoDeleteExecutions?: boolean(name='AutoDeleteExecutions', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  templateNames: string(name='TemplateNames', position='Query'),
}

model DeleteTemplatesResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteTemplatesResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteTemplatesResponseBody(name='body'),
}

async function deleteTemplates(request: DeleteTemplatesRequest): DeleteTemplatesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteTemplates', 'POST', '/DeleteTemplates', 'json', false, 'json', request);
}

model DeployApplicationGroupRequest {
  applicationName: string(name='ApplicationName', position='Query'),
  deployParameters: string(name='DeployParameters', position='Query'),
  name: string(name='Name', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DeployApplicationGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeployApplicationGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeployApplicationGroupResponseBody(name='body'),
}

async function deployApplicationGroup(request: DeployApplicationGroupRequest): DeployApplicationGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeployApplicationGroup', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRegionsRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DescribeRegionsResponseBody = {
  regions?: [ 
    {
      localName?: string(name='LocalName'),
      regionEndpoint?: string(name='RegionEndpoint'),
      regionId?: string(name='RegionId'),
    }
  ](name='Regions'),
  requestId?: string(name='RequestId'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRegions', 'POST', '/DescribeRegions', 'json', false, 'json', request);
}

model GenerateExecutionPolicyRequest {
  regionId?: string(name='RegionId', position='Query'),
  templateName: string(name='TemplateName', position='Query'),
  templateVersion?: string(name='TemplateVersion', position='Query'),
}

model GenerateExecutionPolicyResponseBody = {
  policy?: string(name='Policy'),
  requestId?: string(name='RequestId'),
}

model GenerateExecutionPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: GenerateExecutionPolicyResponseBody(name='body'),
}

async function generateExecutionPolicy(request: GenerateExecutionPolicyRequest): GenerateExecutionPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GenerateExecutionPolicy', 'POST', '/GenerateExecutionPolicy', 'json', false, 'json', request);
}

model GetApplicationRequest {
  name: string(name='Name', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model GetApplicationResponseBody = {
  application?: {
    createDate?: string(name='CreateDate'),
    description?: string(name='Description'),
    name?: string(name='Name'),
    resourceGroupId?: string(name='ResourceGroupId'),
    tags?: map[string]any(name='Tags'),
    updateDate?: string(name='UpdateDate'),
  }(name='Application'),
  requestId?: string(name='RequestId'),
}

model GetApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: GetApplicationResponseBody(name='body'),
}

async function getApplication(request: GetApplicationRequest): GetApplicationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetApplication', 'POST', '/', 'json', false, 'json', request);
}

model GetApplicationGroupRequest {
  applicationName: string(name='ApplicationName', position='Query'),
  name: string(name='Name', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model GetApplicationGroupResponseBody = {
  applicationGroup?: {
    applicationName?: string(name='ApplicationName'),
    cmsGroupId?: string(name='CmsGroupId'),
    createDate?: string(name='CreateDate'),
    deployOutputs?: string(name='DeployOutputs'),
    deployParameters?: string(name='DeployParameters'),
    deployRegionId?: string(name='DeployRegionId'),
    description?: string(name='Description'),
    importTagKey?: string(name='ImportTagKey'),
    importTagValue?: string(name='ImportTagValue'),
    name?: string(name='Name'),
    status?: string(name='Status'),
    statusReason?: string(name='StatusReason'),
    updateDate?: string(name='UpdateDate'),
  }(name='ApplicationGroup'),
  requestId?: string(name='RequestId'),
}

model GetApplicationGroupResponse = {
  headers: map[string]string(name='headers'),
  body: GetApplicationGroupResponseBody(name='body'),
}

async function getApplicationGroup(request: GetApplicationGroupRequest): GetApplicationGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetApplicationGroup', 'POST', '/', 'json', false, 'json', request);
}

model GetExecutionTemplateRequest {
  executionId: string(name='ExecutionId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model GetExecutionTemplateResponseBody = {
  content?: string(name='Content'),
  requestId?: string(name='RequestId'),
  template?: {
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    description?: string(name='Description'),
    hash?: string(name='Hash'),
    shareType?: string(name='ShareType'),
    tags?: map[string]any(name='Tags'),
    templateFormat?: string(name='TemplateFormat'),
    templateId?: string(name='TemplateId'),
    templateName?: string(name='TemplateName'),
    templateVersion?: string(name='TemplateVersion'),
    updatedBy?: string(name='UpdatedBy'),
    updatedDate?: string(name='UpdatedDate'),
  }(name='Template'),
}

model GetExecutionTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: GetExecutionTemplateResponseBody(name='body'),
}

async function getExecutionTemplate(request: GetExecutionTemplateRequest): GetExecutionTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetExecutionTemplate', 'POST', '/', 'json', false, 'json', request);
}

model GetInventorySchemaRequest {
  aggregator?: boolean(name='Aggregator', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=1, maximum=100, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  typeName?: string(name='TypeName', position='Query'),
}

model GetInventorySchemaResponseBody = {
  maxResults?: string(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  schemas?: [ 
    {
      attributes?: [ 
        {
          dataType?: string(name='DataType'),
          name?: string(name='Name'),
        }
      ](name='Attributes'),
      typeName?: string(name='TypeName'),
      version?: string(name='Version'),
    }
  ](name='Schemas'),
}

model GetInventorySchemaResponse = {
  headers: map[string]string(name='headers'),
  body: GetInventorySchemaResponseBody(name='body'),
}

async function getInventorySchema(request: GetInventorySchemaRequest): GetInventorySchemaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetInventorySchema', 'POST', '/', 'json', false, 'json', request);
}

model GetParameterRequest {
  name: string(name='Name', position='Query'),
  parameterVersion?: int32(name='ParameterVersion', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
}

model GetParameterResponseBody = {
  parameter?: {
    constraints?: string(name='Constraints'),
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    name?: string(name='Name'),
    parameterVersion?: int32(name='ParameterVersion'),
    resourceGroupId?: string(name='ResourceGroupId'),
    shareType?: string(name='ShareType'),
    tags?: map[string]any(name='Tags'),
    type?: string(name='Type'),
    updatedBy?: string(name='UpdatedBy'),
    updatedDate?: string(name='UpdatedDate'),
    value?: string(name='Value'),
  }(name='Parameter'),
  requestId?: string(name='RequestId'),
}

model GetParameterResponse = {
  headers: map[string]string(name='headers'),
  body: GetParameterResponseBody(name='body'),
}

async function getParameter(request: GetParameterRequest): GetParameterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetParameter', 'POST', '/', 'json', false, 'json', request);
}

model GetParametersRequest {
  names: string(name='Names', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model GetParametersResponseBody = {
  invalidParameters?: [ string ](name='InvalidParameters'),
  parameters?: [ 
    {
      constraints?: string(name='Constraints'),
      createdBy?: string(name='CreatedBy'),
      createdDate?: string(name='CreatedDate'),
      description?: string(name='Description'),
      id?: string(name='Id'),
      name?: string(name='Name'),
      parameterVersion?: int32(name='ParameterVersion'),
      resourceGroupId?: string(name='ResourceGroupId'),
      shareType?: string(name='ShareType'),
      tags?: map[string]any(name='Tags'),
      type?: string(name='Type'),
      updatedBy?: string(name='UpdatedBy'),
      updatedDate?: string(name='UpdatedDate'),
      value?: string(name='Value'),
    }
  ](name='Parameters'),
  requestId?: string(name='RequestId'),
}

model GetParametersResponse = {
  headers: map[string]string(name='headers'),
  body: GetParametersResponseBody(name='body'),
}

async function getParameters(request: GetParametersRequest): GetParametersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetParameters', 'POST', '/', 'json', false, 'json', request);
}

model GetParametersByPathRequest {
  maxResults?: int32(name='MaxResults', minimum=1, maximum=100, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  path: string(name='Path', position='Query'),
  recursive?: boolean(name='Recursive', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model GetParametersByPathResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  parameters?: [ 
    {
      constraints?: string(name='Constraints'),
      createdBy?: string(name='CreatedBy'),
      createdDate?: string(name='CreatedDate'),
      description?: string(name='Description'),
      id?: string(name='Id'),
      name?: string(name='Name'),
      parameterVersion?: int32(name='ParameterVersion'),
      shareType?: string(name='ShareType'),
      type?: string(name='Type'),
      updatedBy?: string(name='UpdatedBy'),
      updatedDate?: string(name='UpdatedDate'),
      value?: string(name='Value'),
    }
  ](name='Parameters'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model GetParametersByPathResponse = {
  headers: map[string]string(name='headers'),
  body: GetParametersByPathResponseBody(name='body'),
}

async function getParametersByPath(request: GetParametersByPathRequest): GetParametersByPathResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetParametersByPath', 'POST', '/', 'json', false, 'json', request);
}

model GetPatchBaselineRequest {
  name: string(name='Name', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model GetPatchBaselineResponseBody = {
  patchBaseline?: {
    approvalRules?: string(name='ApprovalRules'),
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    isDefault?: boolean(name='IsDefault'),
    name?: string(name='Name'),
    operationSystem?: string(name='OperationSystem'),
    shareType?: string(name='ShareType'),
    updatedBy?: string(name='UpdatedBy'),
    updatedDate?: string(name='UpdatedDate'),
  }(name='PatchBaseline'),
  requestId?: string(name='RequestId'),
}

model GetPatchBaselineResponse = {
  headers: map[string]string(name='headers'),
  body: GetPatchBaselineResponseBody(name='body'),
}

async function getPatchBaseline(request: GetPatchBaselineRequest): GetPatchBaselineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetPatchBaseline', 'POST', '/', 'json', false, 'json', request);
}

model GetSecretParameterRequest {
  name: string(name='Name', position='Query'),
  parameterVersion?: int32(name='ParameterVersion', minimum=1, maximum=200, position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  withDecryption?: boolean(name='WithDecryption', position='Query'),
}

model GetSecretParameterResponseBody = {
  parameter?: {
    constraints?: string(name='Constraints'),
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    keyId?: string(name='KeyId'),
    name?: string(name='Name'),
    parameterVersion?: int32(name='ParameterVersion'),
    resourceGroupId?: string(name='ResourceGroupId'),
    shareType?: string(name='ShareType'),
    tags?: map[string]any(name='Tags'),
    type?: string(name='Type'),
    updatedBy?: string(name='UpdatedBy'),
    updatedDate?: string(name='UpdatedDate'),
    value?: string(name='Value'),
  }(name='Parameter'),
  requestId?: string(name='RequestId'),
}

model GetSecretParameterResponse = {
  headers: map[string]string(name='headers'),
  body: GetSecretParameterResponseBody(name='body'),
}

async function getSecretParameter(request: GetSecretParameterRequest): GetSecretParameterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetSecretParameter', 'POST', '/', 'json', false, 'json', request);
}

model GetSecretParametersRequest {
  names: string(name='Names', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  withDecryption?: boolean(name='WithDecryption', position='Query'),
}

model GetSecretParametersResponseBody = {
  invalidParameters?: [ string ](name='InvalidParameters'),
  parameters?: [ 
    {
      constraints?: string(name='Constraints'),
      createdBy?: string(name='CreatedBy'),
      createdDate?: string(name='CreatedDate'),
      description?: string(name='Description'),
      id?: string(name='Id'),
      keyId?: string(name='KeyId'),
      name?: string(name='Name'),
      parameterVersion?: int32(name='ParameterVersion'),
      resourceGroupId?: string(name='ResourceGroupId'),
      shareType?: string(name='ShareType'),
      tags?: map[string]any(name='Tags'),
      type?: string(name='Type'),
      updatedBy?: string(name='UpdatedBy'),
      updatedDate?: string(name='UpdatedDate'),
      value?: string(name='Value'),
    }
  ](name='Parameters'),
  requestId?: string(name='RequestId'),
}

model GetSecretParametersResponse = {
  headers: map[string]string(name='headers'),
  body: GetSecretParametersResponseBody(name='body'),
}

async function getSecretParameters(request: GetSecretParametersRequest): GetSecretParametersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetSecretParameters', 'POST', '/', 'json', false, 'json', request);
}

model GetSecretParametersByPathRequest {
  maxResults?: int32(name='MaxResults', minimum=1, maximum=100, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  path: string(name='Path', position='Query'),
  recursive?: boolean(name='Recursive', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  withDecryption?: boolean(name='WithDecryption', position='Query'),
}

model GetSecretParametersByPathResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  parameters?: [ 
    {
      constraints?: string(name='Constraints'),
      createdBy?: string(name='CreatedBy'),
      createdDate?: string(name='CreatedDate'),
      description?: string(name='Description'),
      id?: string(name='Id'),
      keyId?: string(name='KeyId'),
      name?: string(name='Name'),
      parameterVersion?: int32(name='ParameterVersion'),
      shareType?: string(name='ShareType'),
      type?: string(name='Type'),
      updatedBy?: string(name='UpdatedBy'),
      updatedDate?: string(name='UpdatedDate'),
      value?: string(name='Value'),
    }
  ](name='Parameters'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model GetSecretParametersByPathResponse = {
  headers: map[string]string(name='headers'),
  body: GetSecretParametersByPathResponseBody(name='body'),
}

async function getSecretParametersByPath(request: GetSecretParametersByPathRequest): GetSecretParametersByPathResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetSecretParametersByPath', 'POST', '/', 'json', false, 'json', request);
}

model GetServiceSettingsRequest {
  regionId?: string(name='RegionId', position='Query'),
}

model GetServiceSettingsResponseBody = {
  requestId?: string(name='RequestId'),
  serviceSettings?: [ 
    {
      deliveryOssBucketName?: string(name='DeliveryOssBucketName'),
      deliveryOssEnabled?: boolean(name='DeliveryOssEnabled'),
      deliveryOssKeyPrefix?: string(name='DeliveryOssKeyPrefix'),
      deliverySlsEnabled?: boolean(name='DeliverySlsEnabled'),
      deliverySlsProjectName?: string(name='DeliverySlsProjectName'),
      rdcEnterpriseId?: string(name='RdcEnterpriseId'),
    }
  ](name='ServiceSettings'),
}

model GetServiceSettingsResponse = {
  headers: map[string]string(name='headers'),
  body: GetServiceSettingsResponseBody(name='body'),
}

async function getServiceSettings(request: GetServiceSettingsRequest): GetServiceSettingsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetServiceSettings', 'POST', '/', 'json', false, 'json', request);
}

model GetTemplateRequest {
  regionId?: string(name='RegionId', position='Query'),
  templateName: string(name='TemplateName', position='Query'),
  templateVersion?: string(name='TemplateVersion', position='Query'),
}

model GetTemplateResponseBody = {
  content?: string(name='Content'),
  requestId?: string(name='RequestId'),
  template?: {
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    description?: string(name='Description'),
    hasTrigger?: boolean(name='HasTrigger'),
    hash?: string(name='Hash'),
    resourceGroupId?: string(name='ResourceGroupId'),
    shareType?: string(name='ShareType'),
    tags?: map[string]any(name='Tags'),
    templateFormat?: string(name='TemplateFormat'),
    templateId?: string(name='TemplateId'),
    templateName?: string(name='TemplateName'),
    templateType?: string(name='TemplateType'),
    templateVersion?: string(name='TemplateVersion'),
    updatedBy?: string(name='UpdatedBy'),
    updatedDate?: string(name='UpdatedDate'),
    versionName?: string(name='VersionName'),
  }(name='Template'),
}

model GetTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: GetTemplateResponseBody(name='body'),
}

async function getTemplate(request: GetTemplateRequest): GetTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetTemplate', 'POST', '/GetTemplate', 'json', false, 'json', request);
}

model ListActionsRequest {
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  OOSActionName?: string(name='OOSActionName', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model ListActionsResponseBody = {
  actions?: [ 
    {
      actionType?: string(name='ActionType'),
      createdDate?: string(name='CreatedDate'),
      description?: string(name='Description'),
      OOSActionName?: string(name='OOSActionName'),
      popularity?: int32(name='Popularity'),
      properties?: string(name='Properties'),
      templateVersion?: string(name='TemplateVersion'),
    }
  ](name='Actions'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model ListActionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListActionsResponseBody(name='body'),
}

async function listActions(request: ListActionsRequest): ListActionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListActions', 'POST', '/ListActions', 'json', false, 'json', request);
}

model ListApplicationGroupsRequest {
  applicationName: string(name='ApplicationName', position='Query'),
  deployRegionId?: string(name='DeployRegionId', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model ListApplicationGroupsResponseBody = {
  applicationGroups?: [ 
    {
      applicationName?: string(name='ApplicationName'),
      cmsGroupId?: string(name='CmsGroupId'),
      createDate?: string(name='CreateDate'),
      deployParameters?: string(name='DeployParameters'),
      deployRegionId?: string(name='DeployRegionId'),
      description?: string(name='Description'),
      importTagKey?: string(name='ImportTagKey'),
      importTagValue?: string(name='ImportTagValue'),
      name?: string(name='Name'),
      status?: string(name='Status'),
      statusReason?: string(name='StatusReason'),
      updateDate?: string(name='UpdateDate'),
    }
  ](name='ApplicationGroups'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model ListApplicationGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: ListApplicationGroupsResponseBody(name='body'),
}

async function listApplicationGroups(request: ListApplicationGroupsRequest): ListApplicationGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListApplicationGroups', 'POST', '/', 'json', false, 'json', request);
}

model ListApplicationsRequest {
  maxResults?: int32(name='MaxResults', position='Query'),
  name?: string(name='Name', position='Query'),
  names?: string(name='Names', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  tags?: map[string]any(name='Tags', shrink='json', position='Query'),
}

model ListApplicationsResponseBody = {
  applications?: [ 
    {
      createDate?: string(name='CreateDate'),
      description?: string(name='Description'),
      name?: string(name='Name'),
      resourceGroupId?: string(name='ResourceGroupId'),
      tags?: map[string]any(name='Tags'),
      updateDate?: string(name='UpdateDate'),
    }
  ](name='Applications'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model ListApplicationsResponse = {
  headers: map[string]string(name='headers'),
  body: ListApplicationsResponseBody(name='body'),
}

async function listApplications(request: ListApplicationsRequest): ListApplicationsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListApplications', 'POST', '/', 'json', false, 'json', request);
}

model ListExecutionLogsRequest {
  executionId: string(name='ExecutionId', position='Query'),
  logType?: string(name='LogType', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  taskExecutionId?: string(name='TaskExecutionId', position='Query'),
}

model ListExecutionLogsResponseBody = {
  executionLogs?: [ 
    {
      logType?: string(name='LogType'),
      message?: string(name='Message'),
      taskExecutionId?: string(name='TaskExecutionId'),
      timestamp?: string(name='Timestamp'),
    }
  ](name='ExecutionLogs'),
  isTruncated?: boolean(name='IsTruncated'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model ListExecutionLogsResponse = {
  headers: map[string]string(name='headers'),
  body: ListExecutionLogsResponseBody(name='body'),
}

async function listExecutionLogs(request: ListExecutionLogsRequest): ListExecutionLogsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListExecutionLogs', 'POST', '/', 'json', false, 'json', request);
}

model ListExecutionRiskyTasksRequest {
  regionId?: string(name='RegionId', position='Query'),
  templateName: string(name='TemplateName', position='Query'),
}

model ListExecutionRiskyTasksResponseBody = {
  requestId?: string(name='RequestId'),
  riskyTasks?: [ 
    {
      API?: string(name='API'),
      service?: string(name='Service'),
      task?: [ string ](name='Task'),
      template?: [ string ](name='Template'),
    }
  ](name='RiskyTasks'),
}

model ListExecutionRiskyTasksResponse = {
  headers: map[string]string(name='headers'),
  body: ListExecutionRiskyTasksResponseBody(name='body'),
}

async function listExecutionRiskyTasks(request: ListExecutionRiskyTasksRequest): ListExecutionRiskyTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListExecutionRiskyTasks', 'POST', '/ListExecutionRiskyTasks', 'json', false, 'json', request);
}

model ListExecutionsRequest {
  category?: string(name='Category', position='Query'),
  endDateAfter?: string(name='EndDateAfter', position='Query'),
  endDateBefore?: string(name='EndDateBefore', position='Query'),
  executedBy?: string(name='ExecutedBy', position='Query'),
  executionId?: string(name='ExecutionId', position='Query'),
  includeChildExecution?: boolean(name='IncludeChildExecution', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  mode?: string(name='Mode', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  parentExecutionId?: string(name='ParentExecutionId', position='Query'),
  ramRole?: string(name='RamRole', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceId?: string(name='ResourceId', position='Query'),
  resourceTemplateName?: string(name='ResourceTemplateName', position='Query'),
  sortField?: string(name='SortField', position='Query'),
  sortOrder?: string(name='SortOrder', position='Query'),
  startDateAfter?: string(name='StartDateAfter', position='Query'),
  startDateBefore?: string(name='StartDateBefore', position='Query'),
  status?: string(name='Status', position='Query'),
  tags?: map[string]any(name='Tags', shrink='json', position='Query'),
  templateName?: string(name='TemplateName', position='Query'),
}

model ListExecutionsResponseBody = {
  executions?: [ 
    {
      category?: string(name='Category'),
      counters?: map[string]any(name='Counters'),
      createDate?: string(name='CreateDate'),
      currentTasks?: [ 
        {
          taskAction?: string(name='TaskAction'),
          taskExecutionId?: string(name='TaskExecutionId'),
          taskName?: string(name='TaskName'),
        }
      ](name='CurrentTasks'),
      description?: string(name='Description'),
      endDate?: string(name='EndDate'),
      executedBy?: string(name='ExecutedBy'),
      executionId?: string(name='ExecutionId'),
      isParent?: boolean(name='IsParent'),
      lastSuccessfulTriggerTime?: string(name='LastSuccessfulTriggerTime'),
      lastTriggerStatus?: string(name='LastTriggerStatus'),
      lastTriggerTime?: string(name='LastTriggerTime'),
      mode?: string(name='Mode'),
      outputs?: string(name='Outputs'),
      parameters?: map[string]any(name='Parameters'),
      parentExecutionId?: string(name='ParentExecutionId'),
      ramRole?: string(name='RamRole'),
      resourceGroupId?: string(name='ResourceGroupId'),
      resourceStatus?: string(name='ResourceStatus'),
      safetyCheck?: string(name='SafetyCheck'),
      startDate?: string(name='StartDate'),
      status?: string(name='Status'),
      statusMessage?: string(name='StatusMessage'),
      statusReason?: string(name='StatusReason'),
      tags?: map[string]any(name='Tags'),
      targets?: string(name='Targets'),
      templateId?: string(name='TemplateId'),
      templateName?: string(name='TemplateName'),
      templateVersion?: string(name='TemplateVersion'),
      updateDate?: string(name='UpdateDate'),
      waitingStatus?: string(name='WaitingStatus'),
    }
  ](name='Executions'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model ListExecutionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListExecutionsResponseBody(name='body'),
}

async function listExecutions(request: ListExecutionsRequest): ListExecutionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListExecutions', 'POST', '/ListExecutions', 'json', false, 'json', request);
}

model ListInstancePatchStatesRequest {
  instanceIds?: string(name='InstanceIds', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model ListInstancePatchStatesResponseBody = {
  instancePatchStates?: [ 
    {
      baselineId?: string(name='BaselineId'),
      failedCount?: string(name='FailedCount'),
      installedCount?: string(name='InstalledCount'),
      installedOtherCount?: string(name='InstalledOtherCount'),
      installedPendingRebootCount?: string(name='InstalledPendingRebootCount'),
      installedRejectedCount?: string(name='InstalledRejectedCount'),
      instanceId?: string(name='InstanceId'),
      missingCount?: string(name='MissingCount'),
      operationEndTime?: string(name='OperationEndTime'),
      operationStartTime?: string(name='OperationStartTime'),
      operationType?: string(name='OperationType'),
      ownerInformation?: string(name='OwnerInformation'),
      patchGroup?: string(name='PatchGroup'),
    }
  ](name='InstancePatchStates'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model ListInstancePatchStatesResponse = {
  headers: map[string]string(name='headers'),
  body: ListInstancePatchStatesResponseBody(name='body'),
}

async function listInstancePatchStates(request: ListInstancePatchStatesRequest): ListInstancePatchStatesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListInstancePatchStates', 'POST', '/', 'json', false, 'json', request);
}

model ListInstancePatchesRequest {
  instanceId?: string(name='InstanceId', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  patchStatuses?: string(name='PatchStatuses', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model ListInstancePatchesResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  patches?: [ 
    {
      classification?: string(name='Classification'),
      installedTime?: string(name='InstalledTime'),
      KBId?: string(name='KBId'),
      severity?: string(name='Severity'),
      status?: string(name='Status'),
      title?: string(name='Title'),
    }
  ](name='Patches'),
  requestId?: string(name='RequestId'),
}

model ListInstancePatchesResponse = {
  headers: map[string]string(name='headers'),
  body: ListInstancePatchesResponseBody(name='body'),
}

async function listInstancePatches(request: ListInstancePatchesRequest): ListInstancePatchesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListInstancePatches', 'POST', '/', 'json', false, 'json', request);
}

model ListInventoryEntriesRequest {
  filter?: [ 
    {
      name?: string(name='Name'),
      operator?: string(name='Operator'),
      value?: [ string ](name='Value'),
    }
  ](name='Filter', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=1, maximum=100, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  typeName: string(name='TypeName', position='Query'),
}

model ListInventoryEntriesResponseBody = {
  captureTime?: string(name='CaptureTime'),
  entries?: [  map[string]any ](name='Entries'),
  instanceId?: string(name='InstanceId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  schemaVersion?: string(name='SchemaVersion'),
  typeName?: string(name='TypeName'),
}

model ListInventoryEntriesResponse = {
  headers: map[string]string(name='headers'),
  body: ListInventoryEntriesResponseBody(name='body'),
}

async function listInventoryEntries(request: ListInventoryEntriesRequest): ListInventoryEntriesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListInventoryEntries', 'POST', '/', 'json', false, 'json', request);
}

model ListParameterVersionsRequest {
  maxResults?: int32(name='MaxResults', minimum=10, maximum=100, position='Query'),
  name: string(name='Name', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  shareType?: string(name='ShareType', position='Query'),
}

model ListParameterVersionsResponseBody = {
  createdBy?: string(name='CreatedBy'),
  createdDate?: string(name='CreatedDate'),
  description?: string(name='Description'),
  id?: string(name='Id'),
  maxResults?: int32(name='MaxResults'),
  name?: string(name='Name'),
  nextToken?: string(name='NextToken'),
  parameterVersions?: [ 
    {
      parameterVersion?: int32(name='ParameterVersion'),
      updatedBy?: string(name='UpdatedBy'),
      updatedDate?: string(name='UpdatedDate'),
      value?: string(name='Value'),
    }
  ](name='ParameterVersions'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  type?: string(name='Type'),
}

model ListParameterVersionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListParameterVersionsResponseBody(name='body'),
}

async function listParameterVersions(request: ListParameterVersionsRequest): ListParameterVersionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListParameterVersions', 'POST', '/', 'json', false, 'json', request);
}

model ListParametersRequest {
  maxResults?: int32(name='MaxResults', minimum=10, maximum=100, position='Query'),
  name?: string(name='Name', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  path?: string(name='Path', position='Query'),
  recursive?: boolean(name='Recursive', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  sortField?: string(name='SortField', position='Query'),
  sortOrder?: string(name='SortOrder', position='Query'),
  tags?: map[string]any(name='Tags', shrink='json', position='Query'),
  type?: string(name='Type', position='Query'),
}

model ListParametersResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  parameters?: [ 
    {
      createdBy?: string(name='CreatedBy'),
      createdDate?: string(name='CreatedDate'),
      description?: string(name='Description'),
      id?: string(name='Id'),
      name?: string(name='Name'),
      parameterVersion?: string(name='ParameterVersion'),
      resourceGroupId?: string(name='ResourceGroupId'),
      shareType?: string(name='ShareType'),
      tags?: map[string]any(name='Tags'),
      type?: string(name='Type'),
      updatedBy?: string(name='UpdatedBy'),
      updatedDate?: string(name='UpdatedDate'),
    }
  ](name='Parameters'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListParametersResponse = {
  headers: map[string]string(name='headers'),
  body: ListParametersResponseBody(name='body'),
}

async function listParameters(request: ListParametersRequest): ListParametersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListParameters', 'POST', '/', 'json', false, 'json', request);
}

model ListPatchBaselinesRequest {
  maxResults?: int32(name='MaxResults', position='Query'),
  name?: string(name='Name', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  operationSystem?: string(name='OperationSystem', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  shareType?: string(name='ShareType', position='Query'),
}

model ListPatchBaselinesResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  patchBaselines?: [ 
    {
      createdBy?: string(name='CreatedBy'),
      createdDate?: string(name='CreatedDate'),
      description?: string(name='Description'),
      id?: string(name='Id'),
      isDefault?: boolean(name='IsDefault'),
      name?: string(name='Name'),
      operationSystem?: string(name='OperationSystem'),
      shareType?: string(name='ShareType'),
      updatedBy?: string(name='UpdatedBy'),
      updatedDate?: string(name='UpdatedDate'),
    }
  ](name='PatchBaselines'),
  requestId?: string(name='RequestId'),
}

model ListPatchBaselinesResponse = {
  headers: map[string]string(name='headers'),
  body: ListPatchBaselinesResponseBody(name='body'),
}

async function listPatchBaselines(request: ListPatchBaselinesRequest): ListPatchBaselinesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListPatchBaselines', 'POST', '/', 'json', false, 'json', request);
}

model ListResourceExecutionStatusRequest {
  executionId: string(name='ExecutionId', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=10, maximum=100, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model ListResourceExecutionStatusResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  resourceExecutionStatus?: [ 
    {
      executionId?: string(name='ExecutionId'),
      executionTime?: string(name='ExecutionTime'),
      outputs?: string(name='Outputs'),
      resourceId?: string(name='ResourceId'),
      status?: string(name='Status'),
    }
  ](name='ResourceExecutionStatus'),
}

model ListResourceExecutionStatusResponse = {
  headers: map[string]string(name='headers'),
  body: ListResourceExecutionStatusResponseBody(name='body'),
}

async function listResourceExecutionStatus(request: ListResourceExecutionStatusRequest): ListResourceExecutionStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListResourceExecutionStatus', 'POST', '/ListResourceExecutionStatus', 'json', false, 'json', request);
}

model ListSecretParameterVersionsRequest {
  maxResults?: int32(name='MaxResults', minimum=10, maximum=100, position='Query'),
  name: string(name='Name', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  shareType?: string(name='ShareType', position='Query'),
  withDecryption?: boolean(name='WithDecryption', position='Query'),
}

model ListSecretParameterVersionsResponseBody = {
  createdBy?: string(name='CreatedBy'),
  createdDate?: string(name='CreatedDate'),
  description?: string(name='Description'),
  id?: string(name='Id'),
  maxResults?: int32(name='MaxResults'),
  name?: string(name='Name'),
  nextToken?: string(name='NextToken'),
  parameterVersions?: [ 
    {
      parameterVersion?: int32(name='ParameterVersion'),
      updatedBy?: string(name='UpdatedBy'),
      updatedDate?: string(name='UpdatedDate'),
      value?: string(name='Value'),
    }
  ](name='ParameterVersions'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  type?: string(name='Type'),
}

model ListSecretParameterVersionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListSecretParameterVersionsResponseBody(name='body'),
}

async function listSecretParameterVersions(request: ListSecretParameterVersionsRequest): ListSecretParameterVersionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListSecretParameterVersions', 'POST', '/', 'json', false, 'json', request);
}

model ListSecretParametersRequest {
  maxResults?: int32(name='MaxResults', minimum=10, maximum=100, position='Query'),
  name?: string(name='Name', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  path?: string(name='Path', position='Query'),
  recursive?: boolean(name='Recursive', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  sortField?: string(name='SortField', position='Query'),
  sortOrder?: string(name='SortOrder', position='Query'),
  tags?: map[string]any(name='Tags', shrink='json', position='Query'),
}

model ListSecretParametersResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  parameters?: [ 
    {
      createdBy?: string(name='CreatedBy'),
      createdDate?: string(name='CreatedDate'),
      description?: string(name='Description'),
      id?: string(name='Id'),
      keyId?: string(name='KeyId'),
      name?: string(name='Name'),
      parameterVersion?: string(name='ParameterVersion'),
      resourceGroupId?: string(name='ResourceGroupId'),
      shareType?: string(name='ShareType'),
      tags?: map[string]any(name='Tags'),
      type?: string(name='Type'),
      updatedBy?: string(name='UpdatedBy'),
      updatedDate?: string(name='UpdatedDate'),
    }
  ](name='Parameters'),
  requestId?: string(name='RequestId'),
}

model ListSecretParametersResponse = {
  headers: map[string]string(name='headers'),
  body: ListSecretParametersResponseBody(name='body'),
}

async function listSecretParameters(request: ListSecretParametersRequest): ListSecretParametersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListSecretParameters', 'POST', '/', 'json', false, 'json', request);
}

model ListStateConfigurationsRequest {
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  stateConfigurationIds?: string(name='StateConfigurationIds', position='Query'),
  tags?: map[string]any(name='Tags', shrink='json', position='Query'),
  templateName?: string(name='TemplateName', position='Query'),
  templateVersion?: string(name='TemplateVersion', position='Query'),
}

model ListStateConfigurationsResponseBody = {
  requestId?: string(name='RequestId'),
  stateConfigurations?: [ 
    {
      configureMode?: string(name='ConfigureMode'),
      createTime?: string(name='CreateTime'),
      description?: string(name='Description'),
      parameters?: string(name='Parameters'),
      resourceGroupId?: string(name='ResourceGroupId'),
      scheduleExpression?: string(name='ScheduleExpression'),
      scheduleType?: string(name='ScheduleType'),
      stateConfigurationId?: string(name='StateConfigurationId'),
      tags?: map[string]any(name='Tags'),
      targets?: string(name='Targets'),
      templateId?: string(name='TemplateId'),
      templateName?: string(name='TemplateName'),
      templateVersion?: string(name='TemplateVersion'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='StateConfigurations'),
}

model ListStateConfigurationsResponse = {
  headers: map[string]string(name='headers'),
  body: ListStateConfigurationsResponseBody(name='body'),
}

async function listStateConfigurations(request: ListStateConfigurationsRequest): ListStateConfigurationsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListStateConfigurations', 'POST', '/', 'json', false, 'json', request);
}

model ListTagKeysRequest {
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceType?: string(name='ResourceType', position='Query'),
}

model ListTagKeysResponseBody = {
  keys?: [ string ](name='Keys'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model ListTagKeysResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagKeysResponseBody(name='body'),
}

async function listTagKeys(request: ListTagKeysRequest): ListTagKeysResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTagKeys', 'POST', '/ListTagKeys', 'json', false, 'json', request);
}

model ListTagResourcesRequest {
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceIds?: map[string]any(name='ResourceIds', shrink='json', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
  tags?: map[string]any(name='Tags', shrink='json', position='Query'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  tagResources?: {
    tagResource?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='TagResource')
  }(name='TagResources'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTagResources', 'POST', '/ListTagResources', 'json', false, 'json', request);
}

model ListTagValuesRequest {
  key?: string(name='Key', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceType?: string(name='ResourceType', position='Query'),
}

model ListTagValuesResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  values?: [ string ](name='Values'),
}

model ListTagValuesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagValuesResponseBody(name='body'),
}

async function listTagValues(request: ListTagValuesRequest): ListTagValuesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTagValues', 'POST', '/ListTagValues', 'json', false, 'json', request);
}

model ListTaskExecutionsRequest {
  endDateAfter?: string(name='EndDateAfter', position='Query'),
  endDateBefore?: string(name='EndDateBefore', position='Query'),
  executionId?: string(name='ExecutionId', position='Query'),
  includeChildTaskExecution?: boolean(name='IncludeChildTaskExecution', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  parentTaskExecutionId?: string(name='ParentTaskExecutionId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  sortField?: string(name='SortField', position='Query'),
  sortOrder?: string(name='SortOrder', position='Query'),
  startDateAfter?: string(name='StartDateAfter', position='Query'),
  startDateBefore?: string(name='StartDateBefore', position='Query'),
  status?: string(name='Status', position='Query'),
  taskAction?: string(name='TaskAction', position='Query'),
  taskExecutionId?: string(name='TaskExecutionId', position='Query'),
  taskName?: string(name='TaskName', position='Query'),
}

model ListTaskExecutionsResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  taskExecutions?: [ 
    {
      childExecutionId?: string(name='ChildExecutionId'),
      createDate?: string(name='CreateDate'),
      endDate?: string(name='EndDate'),
      executionId?: string(name='ExecutionId'),
      extraData?: map[string]any(name='ExtraData'),
      loop?: map[string]any(name='Loop'),
      loopBatchNumber?: int32(name='LoopBatchNumber'),
      loopItem?: string(name='LoopItem'),
      outputs?: string(name='Outputs'),
      parentTaskExecutionId?: string(name='ParentTaskExecutionId'),
      properties?: string(name='Properties'),
      startDate?: string(name='StartDate'),
      status?: string(name='Status'),
      statusMessage?: string(name='StatusMessage'),
      taskAction?: string(name='TaskAction'),
      taskExecutionId?: string(name='TaskExecutionId'),
      taskName?: string(name='TaskName'),
      templateId?: string(name='TemplateId'),
      updateDate?: string(name='UpdateDate'),
    }
  ](name='TaskExecutions'),
}

model ListTaskExecutionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListTaskExecutionsResponseBody(name='body'),
}

async function listTaskExecutions(request: ListTaskExecutionsRequest): ListTaskExecutionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTaskExecutions', 'POST', '/ListTaskExecutions', 'json', false, 'json', request);
}

model ListTemplateVersionsRequest {
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  shareType?: string(name='ShareType', position='Query'),
  templateName: string(name='TemplateName', position='Query'),
}

model ListTemplateVersionsResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  templateVersions?: [ 
    {
      description?: string(name='Description'),
      templateFormat?: string(name='TemplateFormat'),
      templateVersion?: string(name='TemplateVersion'),
      updatedBy?: string(name='UpdatedBy'),
      updatedDate?: string(name='UpdatedDate'),
      versionName?: string(name='VersionName'),
    }
  ](name='TemplateVersions'),
}

model ListTemplateVersionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListTemplateVersionsResponseBody(name='body'),
}

async function listTemplateVersions(request: ListTemplateVersionsRequest): ListTemplateVersionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTemplateVersions', 'POST', '/', 'json', false, 'json', request);
}

model ListTemplatesRequest {
  category?: string(name='Category', position='Query'),
  createdBy?: string(name='CreatedBy', position='Query'),
  createdDateAfter?: string(name='CreatedDateAfter', position='Query'),
  createdDateBefore?: string(name='CreatedDateBefore', position='Query'),
  hasTrigger?: boolean(name='HasTrigger', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  shareType?: string(name='ShareType', position='Query'),
  sortField?: string(name='SortField', position='Query'),
  sortOrder?: string(name='SortOrder', position='Query'),
  tags?: map[string]any(name='Tags', shrink='json', position='Query'),
  templateFormat?: string(name='TemplateFormat', position='Query'),
  templateName?: string(name='TemplateName', position='Query'),
  templateType?: string(name='TemplateType', position='Query'),
}

model ListTemplatesResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  templates?: [ 
    {
      category?: string(name='Category'),
      createdBy?: string(name='CreatedBy'),
      createdDate?: string(name='CreatedDate'),
      description?: string(name='Description'),
      hasTrigger?: boolean(name='HasTrigger'),
      hash?: string(name='Hash'),
      popularity?: int32(name='Popularity'),
      resourceGroupId?: string(name='ResourceGroupId'),
      shareType?: string(name='ShareType'),
      tags?: map[string]any(name='Tags'),
      templateFormat?: string(name='TemplateFormat'),
      templateId?: string(name='TemplateId'),
      templateName?: string(name='TemplateName'),
      templateType?: string(name='TemplateType'),
      templateVersion?: string(name='TemplateVersion'),
      totalExecutionCount?: int32(name='TotalExecutionCount'),
      updatedBy?: string(name='UpdatedBy'),
      updatedDate?: string(name='UpdatedDate'),
    }
  ](name='Templates'),
}

model ListTemplatesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTemplatesResponseBody(name='body'),
}

async function listTemplates(request: ListTemplatesRequest): ListTemplatesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTemplates', 'POST', '/ListTemplates', 'json', false, 'json', request);
}

model NotifyExecutionRequest {
  executionId: string(name='ExecutionId', position='Query'),
  executionStatus?: string(name='ExecutionStatus', position='Query'),
  loopItem?: string(name='LoopItem', position='Query'),
  notifyNote?: string(name='NotifyNote', position='Query'),
  notifyType: string(name='NotifyType', position='Query'),
  parameters?: string(name='Parameters', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  taskExecutionId?: string(name='TaskExecutionId', position='Query'),
  taskExecutionIds?: string(name='TaskExecutionIds', position='Query'),
  taskName?: string(name='TaskName', position='Query'),
}

model NotifyExecutionResponseBody = {
  requestId?: string(name='RequestId'),
}

model NotifyExecutionResponse = {
  headers: map[string]string(name='headers'),
  body: NotifyExecutionResponseBody(name='body'),
}

async function notifyExecution(request: NotifyExecutionRequest): NotifyExecutionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'NotifyExecution', 'POST', '/NotifyExecution', 'json', false, 'json', request);
}

model RegisterDefaultPatchBaselineRequest {
  name: string(name='Name', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model RegisterDefaultPatchBaselineResponseBody = {
  patchBaseline?: {
    approvalRules?: string(name='ApprovalRules'),
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    name?: string(name='Name'),
    operationSystem?: string(name='OperationSystem'),
    shareType?: string(name='ShareType'),
    updatedBy?: string(name='UpdatedBy'),
    updatedDate?: string(name='UpdatedDate'),
  }(name='PatchBaseline'),
  requestId?: string(name='RequestId'),
}

model RegisterDefaultPatchBaselineResponse = {
  headers: map[string]string(name='headers'),
  body: RegisterDefaultPatchBaselineResponseBody(name='body'),
}

async function registerDefaultPatchBaseline(request: RegisterDefaultPatchBaselineRequest): RegisterDefaultPatchBaselineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RegisterDefaultPatchBaseline', 'POST', '/', 'json', false, 'json', request);
}

model SearchInventoryRequest {
  aggregator?: [ string ](name='Aggregator', position='Query'),
  filter?: [ 
    {
      name?: string(name='Name'),
      operator?: string(name='Operator'),
      value?: [ string ](name='Value'),
    }
  ](name='Filter', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=1, maximum=100, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model SearchInventoryResponseBody = {
  entities?: [  map[string]any ](name='Entities'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model SearchInventoryResponse = {
  headers: map[string]string(name='headers'),
  body: SearchInventoryResponseBody(name='body'),
}

async function searchInventory(request: SearchInventoryRequest): SearchInventoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SearchInventory', 'POST', '/SearchInventory', 'json', false, 'json', request);
}

model SetServiceSettingsRequest {
  deliveryOssBucketName?: string(name='DeliveryOssBucketName', position='Query'),
  deliveryOssEnabled?: boolean(name='DeliveryOssEnabled', position='Query'),
  deliveryOssKeyPrefix?: string(name='DeliveryOssKeyPrefix', position='Query'),
  deliverySlsEnabled?: boolean(name='DeliverySlsEnabled', position='Query'),
  deliverySlsProjectName?: string(name='DeliverySlsProjectName', position='Query'),
  rdcEnterpriseId?: string(name='RdcEnterpriseId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model SetServiceSettingsResponseBody = {
  requestId?: string(name='RequestId'),
  serviceSettings?: [ 
    {
      deliveryOssBucketName?: string(name='DeliveryOssBucketName'),
      deliveryOssEnabled?: boolean(name='DeliveryOssEnabled'),
      deliveryOssKeyPrefix?: string(name='DeliveryOssKeyPrefix'),
      deliverySlsEnabled?: boolean(name='DeliverySlsEnabled'),
      deliverySlsProjectName?: string(name='DeliverySlsProjectName'),
      rdcEnterpriseId?: string(name='RdcEnterpriseId'),
    }
  ](name='ServiceSettings'),
}

model SetServiceSettingsResponse = {
  headers: map[string]string(name='headers'),
  body: SetServiceSettingsResponseBody(name='body'),
}

async function setServiceSettings(request: SetServiceSettingsRequest): SetServiceSettingsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetServiceSettings', 'POST', '/', 'json', false, 'json', request);
}

model StartExecutionRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  loopMode?: string(name='LoopMode', position='Query'),
  mode?: string(name='Mode', position='Query'),
  parameters?: string(name='Parameters', position='Query'),
  parentExecutionId?: string(name='ParentExecutionId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  safetyCheck?: string(name='SafetyCheck', position='Query'),
  tags?: map[string]any(name='Tags', shrink='json', position='Query'),
  templateContent?: string(name='TemplateContent', position='Query'),
  templateName: string(name='TemplateName', position='Query'),
  templateVersion?: string(name='TemplateVersion', position='Query'),
}

model StartExecutionResponseBody = {
  execution?: {
    counters?: map[string]any(name='Counters'),
    createDate?: string(name='CreateDate'),
    currentTasks?: [ 
      {
        taskAction?: string(name='TaskAction'),
        taskExecutionId?: string(name='TaskExecutionId'),
        taskName?: string(name='TaskName'),
      }
    ](name='CurrentTasks'),
    description?: string(name='Description'),
    endDate?: string(name='EndDate'),
    executedBy?: string(name='ExecutedBy'),
    executionId?: string(name='ExecutionId'),
    isParent?: boolean(name='IsParent'),
    loopMode?: string(name='LoopMode'),
    mode?: string(name='Mode'),
    outputs?: string(name='Outputs'),
    parameters?: string(name='Parameters'),
    parentExecutionId?: string(name='ParentExecutionId'),
    ramRole?: string(name='RamRole'),
    resourceGroupId?: string(name='ResourceGroupId'),
    safetyCheck?: string(name='SafetyCheck'),
    startDate?: string(name='StartDate'),
    status?: string(name='Status'),
    statusMessage?: string(name='StatusMessage'),
    tags?: map[string]any(name='Tags'),
    templateId?: string(name='TemplateId'),
    templateName?: string(name='TemplateName'),
    templateVersion?: string(name='TemplateVersion'),
    updateDate?: string(name='UpdateDate'),
  }(name='Execution'),
  requestId?: string(name='RequestId'),
}

model StartExecutionResponse = {
  headers: map[string]string(name='headers'),
  body: StartExecutionResponseBody(name='body'),
}

async function startExecution(request: StartExecutionRequest): StartExecutionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StartExecution', 'POST', '/StartExecution', 'json', false, 'json', request);
}

model TagResourcesRequest {
  regionId: string(name='RegionId', position='Query'),
  resourceIds: map[string]any(name='ResourceIds', shrink='json', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
  tags: map[string]any(name='Tags', shrink='json', position='Query'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'TagResources', 'POST', '/TagResources', 'json', false, 'json', request);
}

model TriggerExecutionRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  content?: string(name='Content', position='Query'),
  executionId: string(name='ExecutionId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  type: string(name='Type', position='Query'),
}

model TriggerExecutionResponseBody = {
  requestId?: string(name='RequestId'),
}

model TriggerExecutionResponse = {
  headers: map[string]string(name='headers'),
  body: TriggerExecutionResponseBody(name='body'),
}

async function triggerExecution(request: TriggerExecutionRequest): TriggerExecutionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'TriggerExecution', 'POST', '/TriggerExecution', 'json', false, 'json', request);
}

model UntagResourcesRequest {
  all?: boolean(name='All', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceIds: map[string]any(name='ResourceIds', shrink='json', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
  tagKeys?: map[string]any(name='TagKeys', shrink='json', position='Query'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UntagResources', 'POST', '/UntagResources', 'json', false, 'json', request);
}

model UpdateApplicationRequest {
  description?: string(name='Description', position='Query'),
  name: string(name='Name', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  tags?: map[string]any(name='Tags', shrink='json', position='Query'),
}

model UpdateApplicationResponseBody = {
  application?: {
    createdDate?: string(name='CreatedDate'),
    description?: string(name='Description'),
    name?: string(name='Name'),
    resourceGroupId?: string(name='ResourceGroupId'),
    tags?: map[string]any(name='Tags'),
    updatedDate?: string(name='UpdatedDate'),
  }(name='Application'),
  requestId?: string(name='RequestId'),
}

model UpdateApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateApplicationResponseBody(name='body'),
}

async function updateApplication(request: UpdateApplicationRequest): UpdateApplicationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateApplication', 'POST', '/', 'json', false, 'json', request);
}

model UpdateApplicationGroupRequest {
  applicationName: string(name='ApplicationName', position='Query'),
  name: string(name='Name', position='Query'),
  newName?: string(name='NewName', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model UpdateApplicationGroupResponseBody = {
  applicationGroup?: {
    applicationName?: string(name='ApplicationName'),
    createdDate?: string(name='CreatedDate'),
    deployRegionId?: string(name='DeployRegionId'),
    description?: string(name='Description'),
    importTagKey?: string(name='ImportTagKey'),
    importTagValue?: string(name='ImportTagValue'),
    name?: string(name='Name'),
    updatedDate?: string(name='UpdatedDate'),
  }(name='ApplicationGroup'),
  requestId?: string(name='RequestId'),
}

model UpdateApplicationGroupResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateApplicationGroupResponseBody(name='body'),
}

async function updateApplicationGroup(request: UpdateApplicationGroupRequest): UpdateApplicationGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateApplicationGroup', 'POST', '/', 'json', false, 'json', request);
}

model UpdateExecutionRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  executionId: string(name='ExecutionId', position='Query'),
  parameters?: string(name='Parameters', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model UpdateExecutionResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateExecutionResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateExecutionResponseBody(name='body'),
}

async function updateExecution(request: UpdateExecutionRequest): UpdateExecutionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateExecution', 'POST', '/', 'json', false, 'json', request);
}

model UpdateParameterRequest {
  description?: string(name='Description', position='Query'),
  name: string(name='Name', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  tags?: string(name='Tags', position='Query'),
  value: string(name='Value', position='Query'),
}

model UpdateParameterResponseBody = {
  parameter?: {
    constraints?: string(name='Constraints'),
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    name?: string(name='Name'),
    parameterVersion?: int32(name='ParameterVersion'),
    resourceGroupId?: string(name='ResourceGroupId'),
    shareType?: string(name='ShareType'),
    tags?: string(name='Tags'),
    type?: string(name='Type'),
    updatedBy?: string(name='UpdatedBy'),
    updatedDate?: string(name='UpdatedDate'),
  }(name='Parameter'),
  requestId?: string(name='RequestId'),
}

model UpdateParameterResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateParameterResponseBody(name='body'),
}

async function updateParameter(request: UpdateParameterRequest): UpdateParameterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateParameter', 'POST', '/', 'json', false, 'json', request);
}

model UpdatePatchBaselineRequest {
  approvalRules?: string(name='ApprovalRules', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  name: string(name='Name', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model UpdatePatchBaselineResponseBody = {
  patchBaseline?: {
    approvalRules?: string(name='ApprovalRules'),
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    name?: string(name='Name'),
    operationSystem?: string(name='OperationSystem'),
    shareType?: string(name='ShareType'),
    updatedBy?: string(name='UpdatedBy'),
    updatedDate?: string(name='UpdatedDate'),
  }(name='PatchBaseline'),
  requestId?: string(name='RequestId'),
}

model UpdatePatchBaselineResponse = {
  headers: map[string]string(name='headers'),
  body: UpdatePatchBaselineResponseBody(name='body'),
}

async function updatePatchBaseline(request: UpdatePatchBaselineRequest): UpdatePatchBaselineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdatePatchBaseline', 'POST', '/', 'json', false, 'json', request);
}

model UpdateSecretParameterRequest {
  description?: string(name='Description', position='Query'),
  name: string(name='Name', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  tags?: map[string]any(name='Tags', shrink='json', position='Query'),
  value: string(name='Value', position='Query'),
}

model UpdateSecretParameterResponseBody = {
  parameter?: {
    constraints?: string(name='Constraints'),
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    keyId?: string(name='KeyId'),
    name?: string(name='Name'),
    parameterVersion?: int32(name='ParameterVersion'),
    resourceGroupId?: string(name='ResourceGroupId'),
    shareType?: string(name='ShareType'),
    tags?: string(name='Tags'),
    type?: string(name='Type'),
    updatedBy?: string(name='UpdatedBy'),
    updatedDate?: string(name='UpdatedDate'),
  }(name='Parameter'),
  requestId?: string(name='RequestId'),
}

model UpdateSecretParameterResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateSecretParameterResponseBody(name='body'),
}

async function updateSecretParameter(request: UpdateSecretParameterRequest): UpdateSecretParameterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateSecretParameter', 'POST', '/', 'json', false, 'json', request);
}

model UpdateStateConfigurationRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  configureMode?: string(name='ConfigureMode', position='Query'),
  description?: string(name='Description', position='Query'),
  parameters?: map[string]any(name='Parameters', shrink='json', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  scheduleExpression?: string(name='ScheduleExpression', position='Query'),
  scheduleType?: string(name='ScheduleType', position='Query'),
  stateConfigurationId: string(name='StateConfigurationId', position='Query'),
  tags?: map[string]any(name='Tags', shrink='json', position='Query'),
  targets?: string(name='Targets', position='Query'),
}

model UpdateStateConfigurationResponseBody = {
  requestId?: string(name='RequestId'),
  stateConfiguration?: [ 
    {
      configureMode?: string(name='ConfigureMode'),
      createTime?: string(name='CreateTime'),
      description?: string(name='Description'),
      parameters?: string(name='Parameters'),
      resourceGroupId?: string(name='ResourceGroupId'),
      scheduleExpression?: string(name='ScheduleExpression'),
      scheduleType?: string(name='ScheduleType'),
      stateConfigurationId?: string(name='StateConfigurationId'),
      tags?: map[string]any(name='Tags'),
      targets?: string(name='Targets'),
      templateId?: string(name='TemplateId'),
      templateName?: string(name='TemplateName'),
      templateVersion?: string(name='TemplateVersion'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='StateConfiguration'),
}

model UpdateStateConfigurationResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateStateConfigurationResponseBody(name='body'),
}

async function updateStateConfiguration(request: UpdateStateConfigurationRequest): UpdateStateConfigurationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateStateConfiguration', 'POST', '/', 'json', false, 'json', request);
}

model UpdateTemplateRequest {
  content: string(name='Content', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  tags?: map[string]any(name='Tags', shrink='json', position='Query'),
  templateName: string(name='TemplateName', position='Query'),
  versionName?: string(name='VersionName', position='Query'),
}

model UpdateTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  template?: {
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    description?: string(name='Description'),
    hasTrigger?: boolean(name='HasTrigger'),
    hash?: string(name='Hash'),
    resourceGroupId?: string(name='ResourceGroupId'),
    shareType?: string(name='ShareType'),
    tags?: map[string]any(name='Tags'),
    templateFormat?: string(name='TemplateFormat'),
    templateId?: string(name='TemplateId'),
    templateName?: string(name='TemplateName'),
    templateVersion?: string(name='TemplateVersion'),
    updatedBy?: string(name='UpdatedBy'),
    updatedDate?: string(name='UpdatedDate'),
  }(name='Template'),
}

model UpdateTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateTemplateResponseBody(name='body'),
}

async function updateTemplate(request: UpdateTemplateRequest): UpdateTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateTemplate', 'POST', '/UpdateTemplate', 'json', false, 'json', request);
}

model ValidateTemplateContentRequest {
  content: string(name='Content', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model ValidateTemplateContentResponseBody = {
  outputs?: string(name='Outputs'),
  parameters?: string(name='Parameters'),
  ramRole?: string(name='RamRole'),
  requestId?: string(name='RequestId'),
  tasks?: [ 
    {
      description?: string(name='Description'),
      name?: string(name='Name'),
      outputs?: string(name='Outputs'),
      properties?: string(name='Properties'),
      type?: string(name='Type'),
    }
  ](name='Tasks'),
}

model ValidateTemplateContentResponse = {
  headers: map[string]string(name='headers'),
  body: ValidateTemplateContentResponseBody(name='body'),
}

async function validateTemplateContent(request: ValidateTemplateContentRequest): ValidateTemplateContentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ValidateTemplateContent', 'POST', '/ValidateTemplateContent', 'json', false, 'json', request);
}

