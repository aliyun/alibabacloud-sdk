/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  

  checkConfig(config);
  @endpoint = getEndpoint('oos', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model CancelExecutionRequest {
  regionId?: string(name='RegionId'),
  executionId?: string(name='ExecutionId'),
}

model CancelExecutionResponseBody = {
  requestId?: string(name='RequestId'),
}

model CancelExecutionResponse = {
  headers: map[string]string(name='headers'),
  body: CancelExecutionResponseBody(name='body'),
}

async function cancelExecutionWithOptions(request: CancelExecutionRequest, runtime: Util.RuntimeOptions): CancelExecutionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CancelExecution', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function cancelExecution(request: CancelExecutionRequest): CancelExecutionResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelExecutionWithOptions(request, runtime);
}

model CreateParameterRequest {
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
  type?: string(name='Type'),
  value?: string(name='Value'),
  description?: string(name='Description'),
  clientToken?: string(name='ClientToken'),
  constraints?: string(name='Constraints'),
}

model CreateParameterResponseBody = {
  requestId?: string(name='RequestId'),
  parameter?: {
    type?: string(name='Type'),
    constraints?: string(name='Constraints'),
    description?: string(name='Description'),
    updatedDate?: string(name='UpdatedDate'),
    updatedBy?: string(name='UpdatedBy'),
    createdBy?: string(name='CreatedBy'),
    parameterVersion?: int32(name='ParameterVersion'),
    createdDate?: string(name='CreatedDate'),
    name?: string(name='Name'),
    id?: string(name='Id'),
    shareType?: string(name='ShareType'),
  }(name='Parameter'),
}

model CreateParameterResponse = {
  headers: map[string]string(name='headers'),
  body: CreateParameterResponseBody(name='body'),
}

async function createParameterWithOptions(request: CreateParameterRequest, runtime: Util.RuntimeOptions): CreateParameterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateParameter', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createParameter(request: CreateParameterRequest): CreateParameterResponse {
  var runtime = new Util.RuntimeOptions{};
  return createParameterWithOptions(request, runtime);
}

model CreateSecretParameterRequest {
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
  type?: string(name='Type'),
  value?: string(name='Value'),
  description?: string(name='Description'),
  keyId?: string(name='KeyId'),
  clientToken?: string(name='ClientToken'),
  constraints?: string(name='Constraints'),
}

model CreateSecretParameterResponseBody = {
  requestId?: string(name='RequestId'),
  parameter?: {
    type?: string(name='Type'),
    updatedDate?: string(name='UpdatedDate'),
    updatedBy?: string(name='UpdatedBy'),
    keyId?: string(name='KeyId'),
    constraints?: string(name='Constraints'),
    description?: string(name='Description'),
    createdBy?: string(name='CreatedBy'),
    parameterVersion?: int32(name='ParameterVersion'),
    createdDate?: string(name='CreatedDate'),
    name?: string(name='Name'),
    id?: string(name='Id'),
    shareType?: string(name='ShareType'),
  }(name='Parameter'),
}

model CreateSecretParameterResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSecretParameterResponseBody(name='body'),
}

async function createSecretParameterWithOptions(request: CreateSecretParameterRequest, runtime: Util.RuntimeOptions): CreateSecretParameterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateSecretParameter', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createSecretParameter(request: CreateSecretParameterRequest): CreateSecretParameterResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSecretParameterWithOptions(request, runtime);
}

model CreateTemplateRequest {
  regionId?: string(name='RegionId'),
  templateName?: string(name='TemplateName'),
  content?: string(name='Content'),
  tags?: map[string]any(name='Tags'),
  versionName?: string(name='VersionName'),
}

model CreateTemplateShrinkRequest {
  regionId?: string(name='RegionId'),
  templateName?: string(name='TemplateName'),
  content?: string(name='Content'),
  tagsShrink?: string(name='Tags'),
  versionName?: string(name='VersionName'),
}

model CreateTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  templateType?: string(name='TemplateType'),
  template?: {
    hash?: string(name='Hash'),
    updatedDate?: string(name='UpdatedDate'),
    updatedBy?: string(name='UpdatedBy'),
    tags?: map[string]any(name='Tags'),
    templateName?: string(name='TemplateName'),
    templateVersion?: string(name='TemplateVersion'),
    templateFormat?: string(name='TemplateFormat'),
    description?: string(name='Description'),
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    hasTrigger?: boolean(name='HasTrigger'),
    templateId?: string(name='TemplateId'),
    shareType?: string(name='ShareType'),
  }(name='Template'),
}

model CreateTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: CreateTemplateResponseBody(name='body'),
}

async function createTemplateWithOptions(tmpReq: CreateTemplateRequest, runtime: Util.RuntimeOptions): CreateTemplateResponse {
  Util.validateModel(tmpReq);
  var request = new CreateTemplateShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateTemplate', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createTemplate(request: CreateTemplateRequest): CreateTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTemplateWithOptions(request, runtime);
}

model DeleteExecutionsRequest {
  regionId?: string(name='RegionId'),
  executionIds?: string(name='ExecutionIds'),
}

model DeleteExecutionsResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteExecutionsResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteExecutionsResponseBody(name='body'),
}

async function deleteExecutionsWithOptions(request: DeleteExecutionsRequest, runtime: Util.RuntimeOptions): DeleteExecutionsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteExecutions', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteExecutions(request: DeleteExecutionsRequest): DeleteExecutionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteExecutionsWithOptions(request, runtime);
}

model DeleteParameterRequest {
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
}

model DeleteParameterResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteParameterResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteParameterResponseBody(name='body'),
}

async function deleteParameterWithOptions(request: DeleteParameterRequest, runtime: Util.RuntimeOptions): DeleteParameterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteParameter', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteParameter(request: DeleteParameterRequest): DeleteParameterResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteParameterWithOptions(request, runtime);
}

model DeleteSecretParameterRequest {
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
}

model DeleteSecretParameterResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteSecretParameterResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSecretParameterResponseBody(name='body'),
}

async function deleteSecretParameterWithOptions(request: DeleteSecretParameterRequest, runtime: Util.RuntimeOptions): DeleteSecretParameterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteSecretParameter', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteSecretParameter(request: DeleteSecretParameterRequest): DeleteSecretParameterResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSecretParameterWithOptions(request, runtime);
}

model DeleteTemplateRequest {
  regionId?: string(name='RegionId'),
  templateName?: string(name='TemplateName'),
  autoDeleteExecutions?: boolean(name='AutoDeleteExecutions'),
}

model DeleteTemplateResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteTemplateResponseBody(name='body'),
}

async function deleteTemplateWithOptions(request: DeleteTemplateRequest, runtime: Util.RuntimeOptions): DeleteTemplateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteTemplate', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteTemplate(request: DeleteTemplateRequest): DeleteTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTemplateWithOptions(request, runtime);
}

model DeleteTemplatesRequest {
  regionId?: string(name='RegionId'),
  templateNames?: string(name='TemplateNames'),
  autoDeleteExecutions?: boolean(name='AutoDeleteExecutions'),
}

model DeleteTemplatesResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteTemplatesResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteTemplatesResponseBody(name='body'),
}

async function deleteTemplatesWithOptions(request: DeleteTemplatesRequest, runtime: Util.RuntimeOptions): DeleteTemplatesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteTemplates', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteTemplates(request: DeleteTemplatesRequest): DeleteTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTemplatesWithOptions(request, runtime);
}

model DescribeRegionsRequest {
  regionId?: string(name='RegionId'),
  acceptLanguage?: string(name='AcceptLanguage'),
}

model DescribeRegionsResponseBody = {
  requestId?: string(name='RequestId'),
  regions?: [ 
    {
      localName?: string(name='LocalName'),
      regionEndpoint?: string(name='RegionEndpoint'),
      regionId?: string(name='RegionId'),
    }
  ](name='Regions'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeRegions', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(request, runtime);
}

model GenerateExecutionPolicyRequest {
  regionId?: string(name='RegionId'),
  templateName?: string(name='TemplateName'),
  templateVersion?: string(name='TemplateVersion'),
}

model GenerateExecutionPolicyResponseBody = {
  policy?: string(name='Policy'),
  requestId?: string(name='RequestId'),
}

model GenerateExecutionPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: GenerateExecutionPolicyResponseBody(name='body'),
}

async function generateExecutionPolicyWithOptions(request: GenerateExecutionPolicyRequest, runtime: Util.RuntimeOptions): GenerateExecutionPolicyResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GenerateExecutionPolicy', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function generateExecutionPolicy(request: GenerateExecutionPolicyRequest): GenerateExecutionPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateExecutionPolicyWithOptions(request, runtime);
}

model GetExecutionTemplateRequest {
  regionId?: string(name='RegionId'),
  executionId?: string(name='ExecutionId'),
}

model GetExecutionTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  content?: string(name='Content'),
  template?: {
    hash?: string(name='Hash'),
    updatedDate?: string(name='UpdatedDate'),
    updatedBy?: string(name='UpdatedBy'),
    tags?: map[string]any(name='Tags'),
    templateName?: string(name='TemplateName'),
    templateVersion?: string(name='TemplateVersion'),
    templateFormat?: string(name='TemplateFormat'),
    description?: string(name='Description'),
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    templateId?: string(name='TemplateId'),
    shareType?: string(name='ShareType'),
  }(name='Template'),
}

model GetExecutionTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: GetExecutionTemplateResponseBody(name='body'),
}

async function getExecutionTemplateWithOptions(request: GetExecutionTemplateRequest, runtime: Util.RuntimeOptions): GetExecutionTemplateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetExecutionTemplate', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getExecutionTemplate(request: GetExecutionTemplateRequest): GetExecutionTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return getExecutionTemplateWithOptions(request, runtime);
}

model GetInventorySchemaRequest {
  regionId?: string(name='RegionId'),
  aggregator?: boolean(name='Aggregator'),
  typeName?: string(name='TypeName'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
}

model GetInventorySchemaResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  schemas?: [ 
    {
      version?: string(name='Version'),
      attributes?: [ 
        {
          dataType?: string(name='DataType'),
          name?: string(name='Name'),
        }
      ](name='Attributes'),
      typeName?: string(name='TypeName'),
    }
  ](name='Schemas'),
}

model GetInventorySchemaResponse = {
  headers: map[string]string(name='headers'),
  body: GetInventorySchemaResponseBody(name='body'),
}

async function getInventorySchemaWithOptions(request: GetInventorySchemaRequest, runtime: Util.RuntimeOptions): GetInventorySchemaResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetInventorySchema', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getInventorySchema(request: GetInventorySchemaRequest): GetInventorySchemaResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInventorySchemaWithOptions(request, runtime);
}

model GetParameterRequest {
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
  parameterVersion?: int32(name='ParameterVersion'),
}

model GetParameterResponseBody = {
  requestId?: string(name='RequestId'),
  parameter?: {
    type?: string(name='Type'),
    updatedDate?: string(name='UpdatedDate'),
    updatedBy?: string(name='UpdatedBy'),
    value?: string(name='Value'),
    constraints?: string(name='Constraints'),
    description?: string(name='Description'),
    createdBy?: string(name='CreatedBy'),
    parameterVersion?: int32(name='ParameterVersion'),
    createdDate?: string(name='CreatedDate'),
    name?: string(name='Name'),
    id?: string(name='Id'),
    shareType?: string(name='ShareType'),
  }(name='Parameter'),
}

model GetParameterResponse = {
  headers: map[string]string(name='headers'),
  body: GetParameterResponseBody(name='body'),
}

async function getParameterWithOptions(request: GetParameterRequest, runtime: Util.RuntimeOptions): GetParameterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetParameter', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getParameter(request: GetParameterRequest): GetParameterResponse {
  var runtime = new Util.RuntimeOptions{};
  return getParameterWithOptions(request, runtime);
}

model GetParametersRequest {
  regionId?: string(name='RegionId'),
  names?: string(name='Names'),
}

model GetParametersResponseBody = {
  parameters?: [ 
    {
      type?: string(name='Type'),
      updatedDate?: string(name='UpdatedDate'),
      updatedBy?: string(name='UpdatedBy'),
      value?: string(name='Value'),
      constraints?: string(name='Constraints'),
      description?: string(name='Description'),
      createdBy?: string(name='CreatedBy'),
      parameterVersion?: int32(name='ParameterVersion'),
      createdDate?: string(name='CreatedDate'),
      name?: string(name='Name'),
      id?: string(name='Id'),
      shareType?: string(name='ShareType'),
    }
  ](name='Parameters'),
  requestId?: string(name='RequestId'),
  invalidParameters?: [ string ](name='InvalidParameters'),
}

model GetParametersResponse = {
  headers: map[string]string(name='headers'),
  body: GetParametersResponseBody(name='body'),
}

async function getParametersWithOptions(request: GetParametersRequest, runtime: Util.RuntimeOptions): GetParametersResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetParameters', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getParameters(request: GetParametersRequest): GetParametersResponse {
  var runtime = new Util.RuntimeOptions{};
  return getParametersWithOptions(request, runtime);
}

model GetParametersByPathRequest {
  regionId?: string(name='RegionId'),
  path?: string(name='Path'),
  recursive?: boolean(name='Recursive'),
  nextToken?: string(name='NextToken'),
  maxResults?: int32(name='MaxResults'),
}

model GetParametersByPathResponseBody = {
  totalCount?: int32(name='TotalCount'),
  parameters?: [ 
    {
      type?: string(name='Type'),
      updatedDate?: string(name='UpdatedDate'),
      updatedBy?: string(name='UpdatedBy'),
      value?: string(name='Value'),
      constraints?: string(name='Constraints'),
      description?: string(name='Description'),
      createdBy?: string(name='CreatedBy'),
      parameterVersion?: int32(name='ParameterVersion'),
      createdDate?: string(name='CreatedDate'),
      name?: string(name='Name'),
      id?: string(name='Id'),
      shareType?: string(name='ShareType'),
    }
  ](name='Parameters'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  maxResults?: int32(name='MaxResults'),
}

model GetParametersByPathResponse = {
  headers: map[string]string(name='headers'),
  body: GetParametersByPathResponseBody(name='body'),
}

async function getParametersByPathWithOptions(request: GetParametersByPathRequest, runtime: Util.RuntimeOptions): GetParametersByPathResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetParametersByPath', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getParametersByPath(request: GetParametersByPathRequest): GetParametersByPathResponse {
  var runtime = new Util.RuntimeOptions{};
  return getParametersByPathWithOptions(request, runtime);
}

model GetSecretParameterRequest {
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
  parameterVersion?: int32(name='ParameterVersion'),
  withDecryption?: boolean(name='WithDecryption'),
}

model GetSecretParameterResponseBody = {
  requestId?: string(name='RequestId'),
  parameter?: {
    type?: string(name='Type'),
    updatedDate?: string(name='UpdatedDate'),
    updatedBy?: string(name='UpdatedBy'),
    keyId?: string(name='KeyId'),
    value?: string(name='Value'),
    constraints?: string(name='Constraints'),
    description?: string(name='Description'),
    createdBy?: string(name='CreatedBy'),
    parameterVersion?: int32(name='ParameterVersion'),
    createdDate?: string(name='CreatedDate'),
    name?: string(name='Name'),
    id?: string(name='Id'),
    shareType?: string(name='ShareType'),
  }(name='Parameter'),
}

model GetSecretParameterResponse = {
  headers: map[string]string(name='headers'),
  body: GetSecretParameterResponseBody(name='body'),
}

async function getSecretParameterWithOptions(request: GetSecretParameterRequest, runtime: Util.RuntimeOptions): GetSecretParameterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetSecretParameter', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getSecretParameter(request: GetSecretParameterRequest): GetSecretParameterResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSecretParameterWithOptions(request, runtime);
}

model GetSecretParametersRequest {
  regionId?: string(name='RegionId'),
  names?: string(name='Names'),
  withDecryption?: boolean(name='WithDecryption'),
}

model GetSecretParametersResponseBody = {
  parameters?: [ 
    {
      type?: string(name='Type'),
      updatedDate?: string(name='UpdatedDate'),
      updatedBy?: string(name='UpdatedBy'),
      keyId?: string(name='KeyId'),
      value?: string(name='Value'),
      constraints?: string(name='Constraints'),
      description?: string(name='Description'),
      createdBy?: string(name='CreatedBy'),
      parameterVersion?: int32(name='ParameterVersion'),
      createdDate?: string(name='CreatedDate'),
      name?: string(name='Name'),
      id?: string(name='Id'),
      shareType?: string(name='ShareType'),
    }
  ](name='Parameters'),
  requestId?: string(name='RequestId'),
  invalidParameters?: [ string ](name='InvalidParameters'),
}

model GetSecretParametersResponse = {
  headers: map[string]string(name='headers'),
  body: GetSecretParametersResponseBody(name='body'),
}

async function getSecretParametersWithOptions(request: GetSecretParametersRequest, runtime: Util.RuntimeOptions): GetSecretParametersResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetSecretParameters', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getSecretParameters(request: GetSecretParametersRequest): GetSecretParametersResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSecretParametersWithOptions(request, runtime);
}

model GetSecretParametersByPathRequest {
  regionId?: string(name='RegionId'),
  path?: string(name='Path'),
  recursive?: boolean(name='Recursive'),
  nextToken?: string(name='NextToken'),
  maxResults?: int32(name='MaxResults'),
  withDecryption?: boolean(name='WithDecryption'),
}

model GetSecretParametersByPathResponseBody = {
  totalCount?: int32(name='TotalCount'),
  parameters?: [ 
    {
      type?: string(name='Type'),
      updatedDate?: string(name='UpdatedDate'),
      updatedBy?: string(name='UpdatedBy'),
      keyId?: string(name='KeyId'),
      value?: string(name='Value'),
      constraints?: string(name='Constraints'),
      description?: string(name='Description'),
      createdBy?: string(name='CreatedBy'),
      parameterVersion?: int32(name='ParameterVersion'),
      createdDate?: string(name='CreatedDate'),
      name?: string(name='Name'),
      id?: string(name='Id'),
      shareType?: string(name='ShareType'),
    }
  ](name='Parameters'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  maxResults?: int32(name='MaxResults'),
}

model GetSecretParametersByPathResponse = {
  headers: map[string]string(name='headers'),
  body: GetSecretParametersByPathResponseBody(name='body'),
}

async function getSecretParametersByPathWithOptions(request: GetSecretParametersByPathRequest, runtime: Util.RuntimeOptions): GetSecretParametersByPathResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetSecretParametersByPath', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getSecretParametersByPath(request: GetSecretParametersByPathRequest): GetSecretParametersByPathResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSecretParametersByPathWithOptions(request, runtime);
}

model GetServiceSettingsRequest {
  regionId?: string(name='RegionId'),
}

model GetServiceSettingsResponseBody = {
  requestId?: string(name='RequestId'),
  serviceSettings?: [ 
    {
      deliveryOssBucketName?: string(name='DeliveryOssBucketName'),
      deliveryOssKeyPrefix?: string(name='DeliveryOssKeyPrefix'),
      deliverySlsEnabled?: boolean(name='DeliverySlsEnabled'),
      deliveryOssEnabled?: boolean(name='DeliveryOssEnabled'),
      deliverySlsProjectName?: string(name='DeliverySlsProjectName'),
    }
  ](name='ServiceSettings'),
}

model GetServiceSettingsResponse = {
  headers: map[string]string(name='headers'),
  body: GetServiceSettingsResponseBody(name='body'),
}

async function getServiceSettingsWithOptions(request: GetServiceSettingsRequest, runtime: Util.RuntimeOptions): GetServiceSettingsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetServiceSettings', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getServiceSettings(request: GetServiceSettingsRequest): GetServiceSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getServiceSettingsWithOptions(request, runtime);
}

model GetTemplateRequest {
  regionId?: string(name='RegionId'),
  templateName?: string(name='TemplateName'),
  templateVersion?: string(name='TemplateVersion'),
}

model GetTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  content?: string(name='Content'),
  template?: {
    hash?: string(name='Hash'),
    updatedDate?: string(name='UpdatedDate'),
    updatedBy?: string(name='UpdatedBy'),
    tags?: map[string]any(name='Tags'),
    templateType?: string(name='TemplateType'),
    templateName?: string(name='TemplateName'),
    templateVersion?: string(name='TemplateVersion'),
    templateFormat?: string(name='TemplateFormat'),
    description?: string(name='Description'),
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    versionName?: string(name='VersionName'),
    templateId?: string(name='TemplateId'),
    hasTrigger?: boolean(name='HasTrigger'),
    shareType?: string(name='ShareType'),
  }(name='Template'),
}

model GetTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: GetTemplateResponseBody(name='body'),
}

async function getTemplateWithOptions(request: GetTemplateRequest, runtime: Util.RuntimeOptions): GetTemplateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetTemplate', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getTemplate(request: GetTemplateRequest): GetTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTemplateWithOptions(request, runtime);
}

model ListActionsRequest {
  regionId?: string(name='RegionId'),
  OOSActionName?: string(name='OOSActionName'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
}

model ListActionsResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  actions?: [ 
    {
      actionType?: string(name='ActionType'),
      description?: string(name='Description'),
      createdDate?: string(name='CreatedDate'),
      templateVersion?: string(name='TemplateVersion'),
      OOSActionName?: string(name='OOSActionName'),
      properties?: string(name='Properties'),
    }
  ](name='Actions'),
  maxResults?: int32(name='MaxResults'),
}

model ListActionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListActionsResponseBody(name='body'),
}

async function listActionsWithOptions(request: ListActionsRequest, runtime: Util.RuntimeOptions): ListActionsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListActions', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listActions(request: ListActionsRequest): ListActionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listActionsWithOptions(request, runtime);
}

model ListExecutionLogsRequest {
  regionId?: string(name='RegionId'),
  executionId?: string(name='ExecutionId'),
  taskExecutionId?: string(name='TaskExecutionId'),
  logType?: string(name='LogType'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
}

model ListExecutionLogsResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  executionLogs?: [ 
    {
      taskExecutionId?: string(name='TaskExecutionId'),
      message?: string(name='Message'),
      logType?: string(name='LogType'),
      timestamp?: string(name='Timestamp'),
    }
  ](name='ExecutionLogs'),
  maxResults?: int32(name='MaxResults'),
  isTruncated?: boolean(name='IsTruncated'),
}

model ListExecutionLogsResponse = {
  headers: map[string]string(name='headers'),
  body: ListExecutionLogsResponseBody(name='body'),
}

async function listExecutionLogsWithOptions(request: ListExecutionLogsRequest, runtime: Util.RuntimeOptions): ListExecutionLogsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListExecutionLogs', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listExecutionLogs(request: ListExecutionLogsRequest): ListExecutionLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listExecutionLogsWithOptions(request, runtime);
}

model ListExecutionRiskyTasksRequest {
  regionId?: string(name='RegionId'),
  templateName?: string(name='TemplateName'),
}

model ListExecutionRiskyTasksResponseBody = {
  requestId?: string(name='RequestId'),
  riskyTasks?: [ 
    {
      service?: string(name='Service'),
      task?: [ string ](name='Task'),
      API?: string(name='API'),
      template?: [ string ](name='Template'),
    }
  ](name='RiskyTasks'),
}

model ListExecutionRiskyTasksResponse = {
  headers: map[string]string(name='headers'),
  body: ListExecutionRiskyTasksResponseBody(name='body'),
}

async function listExecutionRiskyTasksWithOptions(request: ListExecutionRiskyTasksRequest, runtime: Util.RuntimeOptions): ListExecutionRiskyTasksResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListExecutionRiskyTasks', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listExecutionRiskyTasks(request: ListExecutionRiskyTasksRequest): ListExecutionRiskyTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return listExecutionRiskyTasksWithOptions(request, runtime);
}

model ListExecutionsRequest {
  regionId?: string(name='RegionId'),
  templateName?: string(name='TemplateName'),
  status?: string(name='Status'),
  executionId?: string(name='ExecutionId'),
  startDateBefore?: string(name='StartDateBefore'),
  startDateAfter?: string(name='StartDateAfter'),
  endDateBefore?: string(name='EndDateBefore'),
  endDateAfter?: string(name='EndDateAfter'),
  mode?: string(name='Mode'),
  executedBy?: string(name='ExecutedBy'),
  parentExecutionId?: string(name='ParentExecutionId'),
  ramRole?: string(name='RamRole'),
  includeChildExecution?: boolean(name='IncludeChildExecution'),
  category?: string(name='Category'),
  tags?: map[string]any(name='Tags'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  sortField?: string(name='SortField'),
  sortOrder?: string(name='SortOrder'),
  resourceId?: string(name='ResourceId'),
  resourceTemplateName?: string(name='ResourceTemplateName'),
}

model ListExecutionsShrinkRequest {
  regionId?: string(name='RegionId'),
  templateName?: string(name='TemplateName'),
  status?: string(name='Status'),
  executionId?: string(name='ExecutionId'),
  startDateBefore?: string(name='StartDateBefore'),
  startDateAfter?: string(name='StartDateAfter'),
  endDateBefore?: string(name='EndDateBefore'),
  endDateAfter?: string(name='EndDateAfter'),
  mode?: string(name='Mode'),
  executedBy?: string(name='ExecutedBy'),
  parentExecutionId?: string(name='ParentExecutionId'),
  ramRole?: string(name='RamRole'),
  includeChildExecution?: boolean(name='IncludeChildExecution'),
  category?: string(name='Category'),
  tagsShrink?: string(name='Tags'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  sortField?: string(name='SortField'),
  sortOrder?: string(name='SortOrder'),
  resourceId?: string(name='ResourceId'),
  resourceTemplateName?: string(name='ResourceTemplateName'),
}

model ListExecutionsResponseBody = {
  executions?: [ 
    {
      status?: string(name='Status'),
      waitingStatus?: string(name='WaitingStatus'),
      targets?: string(name='Targets'),
      statusReason?: string(name='StatusReason'),
      tags?: map[string]any(name='Tags'),
      lastSuccessfulTriggerTime?: string(name='LastSuccessfulTriggerTime'),
      mode?: string(name='Mode'),
      safetyCheck?: string(name='SafetyCheck'),
      templateName?: string(name='TemplateName'),
      templateVersion?: string(name='TemplateVersion'),
      createDate?: string(name='CreateDate'),
      currentTasks?: [ 
        {
          taskExecutionId?: string(name='TaskExecutionId'),
          taskName?: string(name='TaskName'),
          taskAction?: string(name='TaskAction'),
        }
      ](name='CurrentTasks'),
      description?: string(name='Description'),
      updateDate?: string(name='UpdateDate'),
      parentExecutionId?: string(name='ParentExecutionId'),
      lastTriggerTime?: string(name='LastTriggerTime'),
      lastTriggerStatus?: string(name='LastTriggerStatus'),
      statusMessage?: string(name='StatusMessage'),
      outputs?: string(name='Outputs'),
      endDate?: string(name='EndDate'),
      executedBy?: string(name='ExecutedBy'),
      isParent?: boolean(name='IsParent'),
      startDate?: string(name='StartDate'),
      executionId?: string(name='ExecutionId'),
      parameters?: map[string]any(name='Parameters'),
      counters?: map[string]any(name='Counters'),
      category?: string(name='Category'),
      templateId?: string(name='TemplateId'),
      ramRole?: string(name='RamRole'),
      resourceStatus?: string(name='ResourceStatus'),
    }
  ](name='Executions'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  maxResults?: int32(name='MaxResults'),
}

model ListExecutionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListExecutionsResponseBody(name='body'),
}

async function listExecutionsWithOptions(tmpReq: ListExecutionsRequest, runtime: Util.RuntimeOptions): ListExecutionsResponse {
  Util.validateModel(tmpReq);
  var request = new ListExecutionsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListExecutions', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listExecutions(request: ListExecutionsRequest): ListExecutionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listExecutionsWithOptions(request, runtime);
}

model ListInventoryEntriesRequest {
  instanceId?: string(name='InstanceId'),
  typeName?: string(name='TypeName'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  filter?: [ 
    {
      value?: [ string ](name='Value'),
      operator?: string(name='Operator'),
      name?: string(name='Name'),
    }
  ](name='Filter'),
}

model ListInventoryEntriesResponseBody = {
  typeName?: string(name='TypeName'),
  captureTime?: string(name='CaptureTime'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  schemaVersion?: string(name='SchemaVersion'),
  instanceId?: string(name='InstanceId'),
  maxResults?: int32(name='MaxResults'),
  entries?: [  map[string]any ](name='Entries'),
}

model ListInventoryEntriesResponse = {
  headers: map[string]string(name='headers'),
  body: ListInventoryEntriesResponseBody(name='body'),
}

async function listInventoryEntriesWithOptions(request: ListInventoryEntriesRequest, runtime: Util.RuntimeOptions): ListInventoryEntriesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListInventoryEntries', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listInventoryEntries(request: ListInventoryEntriesRequest): ListInventoryEntriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInventoryEntriesWithOptions(request, runtime);
}

model ListParametersRequest {
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  sortField?: string(name='SortField'),
  sortOrder?: string(name='SortOrder'),
  type?: string(name='Type'),
  path?: string(name='Path'),
  recursive?: boolean(name='Recursive'),
}

model ListParametersResponseBody = {
  totalCount?: int32(name='TotalCount'),
  parameters?: [ 
    {
      type?: string(name='Type'),
      description?: string(name='Description'),
      updatedDate?: string(name='UpdatedDate'),
      updatedBy?: string(name='UpdatedBy'),
      createdBy?: string(name='CreatedBy'),
      parameterVersion?: string(name='ParameterVersion'),
      createdDate?: string(name='CreatedDate'),
      name?: string(name='Name'),
      id?: string(name='Id'),
      shareType?: string(name='ShareType'),
    }
  ](name='Parameters'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  maxResults?: int32(name='MaxResults'),
}

model ListParametersResponse = {
  headers: map[string]string(name='headers'),
  body: ListParametersResponseBody(name='body'),
}

async function listParametersWithOptions(request: ListParametersRequest, runtime: Util.RuntimeOptions): ListParametersResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListParameters', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listParameters(request: ListParametersRequest): ListParametersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listParametersWithOptions(request, runtime);
}

model ListParameterVersionsRequest {
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  shareType?: string(name='ShareType'),
}

model ListParameterVersionsResponseBody = {
  type?: string(name='Type'),
  totalCount?: int32(name='TotalCount'),
  parameterVersions?: [ 
    {
      value?: string(name='Value'),
      updatedDate?: string(name='UpdatedDate'),
      updatedBy?: string(name='UpdatedBy'),
      parameterVersion?: int32(name='ParameterVersion'),
    }
  ](name='ParameterVersions'),
  description?: string(name='Description'),
  createdBy?: string(name='CreatedBy'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  maxResults?: int32(name='MaxResults'),
  createdDate?: string(name='CreatedDate'),
  id?: string(name='Id'),
  name?: string(name='Name'),
}

model ListParameterVersionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListParameterVersionsResponseBody(name='body'),
}

async function listParameterVersionsWithOptions(request: ListParameterVersionsRequest, runtime: Util.RuntimeOptions): ListParameterVersionsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListParameterVersions', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listParameterVersions(request: ListParameterVersionsRequest): ListParameterVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listParameterVersionsWithOptions(request, runtime);
}

model ListResourceExecutionStatusRequest {
  regionId?: string(name='RegionId'),
  executionId?: string(name='ExecutionId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
}

model ListResourceExecutionStatusResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  resourceExecutionStatus?: [ 
    {
      outputs?: string(name='Outputs'),
      status?: string(name='Status'),
      executionTime?: string(name='ExecutionTime'),
      resourceId?: string(name='ResourceId'),
      executionId?: string(name='ExecutionId'),
    }
  ](name='ResourceExecutionStatus'),
  maxResults?: int32(name='MaxResults'),
}

model ListResourceExecutionStatusResponse = {
  headers: map[string]string(name='headers'),
  body: ListResourceExecutionStatusResponseBody(name='body'),
}

async function listResourceExecutionStatusWithOptions(request: ListResourceExecutionStatusRequest, runtime: Util.RuntimeOptions): ListResourceExecutionStatusResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListResourceExecutionStatus', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listResourceExecutionStatus(request: ListResourceExecutionStatusRequest): ListResourceExecutionStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return listResourceExecutionStatusWithOptions(request, runtime);
}

model ListSecretParametersRequest {
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  sortField?: string(name='SortField'),
  sortOrder?: string(name='SortOrder'),
  path?: string(name='Path'),
  recursive?: boolean(name='Recursive'),
}

model ListSecretParametersResponseBody = {
  parameters?: [ 
    {
      type?: string(name='Type'),
      description?: string(name='Description'),
      updatedDate?: string(name='UpdatedDate'),
      updatedBy?: string(name='UpdatedBy'),
      createdBy?: string(name='CreatedBy'),
      keyId?: string(name='KeyId'),
      parameterVersion?: string(name='ParameterVersion'),
      createdDate?: string(name='CreatedDate'),
      name?: string(name='Name'),
      id?: string(name='Id'),
      shareType?: string(name='ShareType'),
    }
  ](name='Parameters'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  maxResults?: int32(name='MaxResults'),
}

model ListSecretParametersResponse = {
  headers: map[string]string(name='headers'),
  body: ListSecretParametersResponseBody(name='body'),
}

async function listSecretParametersWithOptions(request: ListSecretParametersRequest, runtime: Util.RuntimeOptions): ListSecretParametersResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListSecretParameters', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listSecretParameters(request: ListSecretParametersRequest): ListSecretParametersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSecretParametersWithOptions(request, runtime);
}

model ListSecretParameterVersionsRequest {
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  shareType?: string(name='ShareType'),
  withDecryption?: boolean(name='WithDecryption'),
}

model ListSecretParameterVersionsResponseBody = {
  type?: string(name='Type'),
  totalCount?: int32(name='TotalCount'),
  parameterVersions?: [ 
    {
      value?: string(name='Value'),
      updatedDate?: string(name='UpdatedDate'),
      updatedBy?: string(name='UpdatedBy'),
      parameterVersion?: int32(name='ParameterVersion'),
    }
  ](name='ParameterVersions'),
  description?: string(name='Description'),
  createdBy?: string(name='CreatedBy'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  maxResults?: int32(name='MaxResults'),
  createdDate?: string(name='CreatedDate'),
  id?: string(name='Id'),
  name?: string(name='Name'),
}

model ListSecretParameterVersionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListSecretParameterVersionsResponseBody(name='body'),
}

async function listSecretParameterVersionsWithOptions(request: ListSecretParameterVersionsRequest, runtime: Util.RuntimeOptions): ListSecretParameterVersionsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListSecretParameterVersions', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listSecretParameterVersions(request: ListSecretParameterVersionsRequest): ListSecretParameterVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSecretParameterVersionsWithOptions(request, runtime);
}

model ListTagKeysRequest {
  regionId?: string(name='RegionId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  resourceType?: string(name='ResourceType'),
}

model ListTagKeysResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  maxResults?: int32(name='MaxResults'),
  keys?: [ string ](name='Keys'),
}

model ListTagKeysResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagKeysResponseBody(name='body'),
}

async function listTagKeysWithOptions(request: ListTagKeysRequest, runtime: Util.RuntimeOptions): ListTagKeysResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListTagKeys', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listTagKeys(request: ListTagKeysRequest): ListTagKeysResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagKeysWithOptions(request, runtime);
}

model ListTagResourcesRequest {
  regionId?: string(name='RegionId'),
  resourceIds?: map[string]any(name='ResourceIds'),
  resourceType?: string(name='ResourceType'),
  tags?: map[string]any(name='Tags'),
  nextToken?: string(name='NextToken'),
}

model ListTagResourcesShrinkRequest {
  regionId?: string(name='RegionId'),
  resourceIdsShrink?: string(name='ResourceIds'),
  resourceType?: string(name='ResourceType'),
  tagsShrink?: string(name='Tags'),
  nextToken?: string(name='NextToken'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  tagResources?: {
    tagResource?: [ 
    {
      resourceType?: string(name='ResourceType'),
      tagValue?: string(name='TagValue'),
      resourceId?: string(name='ResourceId'),
      tagKey?: string(name='TagKey'),
    }
  ](name='TagResource')
  }(name='TagResources'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResourcesWithOptions(tmpReq: ListTagResourcesRequest, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(tmpReq);
  var request = new ListTagResourcesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.resourceIds)) {
    request.resourceIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.resourceIds, 'ResourceIds', 'json');
  }
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListTagResources', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagResourcesWithOptions(request, runtime);
}

model ListTagValuesRequest {
  regionId?: string(name='RegionId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  resourceType?: string(name='ResourceType'),
  key?: string(name='Key'),
}

model ListTagValuesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  maxResults?: int32(name='MaxResults'),
  values?: [ string ](name='Values'),
}

model ListTagValuesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagValuesResponseBody(name='body'),
}

async function listTagValuesWithOptions(request: ListTagValuesRequest, runtime: Util.RuntimeOptions): ListTagValuesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListTagValues', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listTagValues(request: ListTagValuesRequest): ListTagValuesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagValuesWithOptions(request, runtime);
}

model ListTaskExecutionsRequest {
  regionId?: string(name='RegionId'),
  executionId?: string(name='ExecutionId'),
  status?: string(name='Status'),
  startDateBefore?: string(name='StartDateBefore'),
  startDateAfter?: string(name='StartDateAfter'),
  endDateBefore?: string(name='EndDateBefore'),
  endDateAfter?: string(name='EndDateAfter'),
  taskExecutionId?: string(name='TaskExecutionId'),
  taskName?: string(name='TaskName'),
  taskAction?: string(name='TaskAction'),
  parentTaskExecutionId?: string(name='ParentTaskExecutionId'),
  includeChildTaskExecution?: boolean(name='IncludeChildTaskExecution'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  sortField?: string(name='SortField'),
  sortOrder?: string(name='SortOrder'),
}

model ListTaskExecutionsResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  maxResults?: int32(name='MaxResults'),
  taskExecutions?: [ 
    {
      status?: string(name='Status'),
      outputs?: string(name='Outputs'),
      childExecutionId?: string(name='ChildExecutionId'),
      endDate?: string(name='EndDate'),
      parentTaskExecutionId?: string(name='ParentTaskExecutionId'),
      taskName?: string(name='TaskName'),
      startDate?: string(name='StartDate'),
      loopItem?: string(name='LoopItem'),
      createDate?: string(name='CreateDate'),
      executionId?: string(name='ExecutionId'),
      taskAction?: string(name='TaskAction'),
      taskExecutionId?: string(name='TaskExecutionId'),
      updateDate?: string(name='UpdateDate'),
      loop?: map[string]any(name='Loop'),
      templateId?: string(name='TemplateId'),
      loopBatchNumber?: int32(name='LoopBatchNumber'),
      statusMessage?: string(name='StatusMessage'),
      extraData?: map[string]any(name='ExtraData'),
      properties?: string(name='Properties'),
    }
  ](name='TaskExecutions'),
}

model ListTaskExecutionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListTaskExecutionsResponseBody(name='body'),
}

async function listTaskExecutionsWithOptions(request: ListTaskExecutionsRequest, runtime: Util.RuntimeOptions): ListTaskExecutionsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListTaskExecutions', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listTaskExecutions(request: ListTaskExecutionsRequest): ListTaskExecutionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTaskExecutionsWithOptions(request, runtime);
}

model ListTemplatesRequest {
  regionId?: string(name='RegionId'),
  templateName?: string(name='TemplateName'),
  templateFormat?: string(name='TemplateFormat'),
  shareType?: string(name='ShareType'),
  createdBy?: string(name='CreatedBy'),
  createdDateBefore?: string(name='CreatedDateBefore'),
  createdDateAfter?: string(name='CreatedDateAfter'),
  tags?: map[string]any(name='Tags'),
  category?: string(name='Category'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  sortField?: string(name='SortField'),
  sortOrder?: string(name='SortOrder'),
  hasTrigger?: boolean(name='HasTrigger'),
  templateType?: string(name='TemplateType'),
}

model ListTemplatesShrinkRequest {
  regionId?: string(name='RegionId'),
  templateName?: string(name='TemplateName'),
  templateFormat?: string(name='TemplateFormat'),
  shareType?: string(name='ShareType'),
  createdBy?: string(name='CreatedBy'),
  createdDateBefore?: string(name='CreatedDateBefore'),
  createdDateAfter?: string(name='CreatedDateAfter'),
  tagsShrink?: string(name='Tags'),
  category?: string(name='Category'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  sortField?: string(name='SortField'),
  sortOrder?: string(name='SortOrder'),
  hasTrigger?: boolean(name='HasTrigger'),
  templateType?: string(name='TemplateType'),
}

model ListTemplatesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  maxResults?: int32(name='MaxResults'),
  templates?: [ 
    {
      hash?: string(name='Hash'),
      updatedDate?: string(name='UpdatedDate'),
      updatedBy?: string(name='UpdatedBy'),
      tags?: map[string]any(name='Tags'),
      templateType?: string(name='TemplateType'),
      templateName?: string(name='TemplateName'),
      templateVersion?: string(name='TemplateVersion'),
      templateFormat?: string(name='TemplateFormat'),
      popularity?: int32(name='Popularity'),
      description?: string(name='Description'),
      totalExecutionCount?: int32(name='TotalExecutionCount'),
      createdBy?: string(name='CreatedBy'),
      createdDate?: string(name='CreatedDate'),
      category?: string(name='Category'),
      hasTrigger?: boolean(name='HasTrigger'),
      templateId?: string(name='TemplateId'),
      shareType?: string(name='ShareType'),
    }
  ](name='Templates'),
}

model ListTemplatesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTemplatesResponseBody(name='body'),
}

async function listTemplatesWithOptions(tmpReq: ListTemplatesRequest, runtime: Util.RuntimeOptions): ListTemplatesResponse {
  Util.validateModel(tmpReq);
  var request = new ListTemplatesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListTemplates', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listTemplates(request: ListTemplatesRequest): ListTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTemplatesWithOptions(request, runtime);
}

model ListTemplateVersionsRequest {
  regionId?: string(name='RegionId'),
  templateName?: string(name='TemplateName'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  shareType?: string(name='ShareType'),
}

model ListTemplateVersionsResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  maxResults?: int32(name='MaxResults'),
  templateVersions?: [ 
    {
      description?: string(name='Description'),
      updatedDate?: string(name='UpdatedDate'),
      updatedBy?: string(name='UpdatedBy'),
      versionName?: string(name='VersionName'),
      templateVersion?: string(name='TemplateVersion'),
      templateFormat?: string(name='TemplateFormat'),
    }
  ](name='TemplateVersions'),
}

model ListTemplateVersionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListTemplateVersionsResponseBody(name='body'),
}

async function listTemplateVersionsWithOptions(request: ListTemplateVersionsRequest, runtime: Util.RuntimeOptions): ListTemplateVersionsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListTemplateVersions', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listTemplateVersions(request: ListTemplateVersionsRequest): ListTemplateVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTemplateVersionsWithOptions(request, runtime);
}

model NotifyExecutionRequest {
  regionId?: string(name='RegionId'),
  executionId?: string(name='ExecutionId'),
  notifyType?: string(name='NotifyType'),
  notifyNote?: string(name='NotifyNote'),
  taskName?: string(name='TaskName'),
  taskExecutionId?: string(name='TaskExecutionId'),
  executionStatus?: string(name='ExecutionStatus'),
  parameters?: string(name='Parameters'),
  loopItem?: string(name='LoopItem'),
  taskExecutionIds?: string(name='TaskExecutionIds'),
}

model NotifyExecutionResponseBody = {
  requestId?: string(name='RequestId'),
}

model NotifyExecutionResponse = {
  headers: map[string]string(name='headers'),
  body: NotifyExecutionResponseBody(name='body'),
}

async function notifyExecutionWithOptions(request: NotifyExecutionRequest, runtime: Util.RuntimeOptions): NotifyExecutionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('NotifyExecution', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function notifyExecution(request: NotifyExecutionRequest): NotifyExecutionResponse {
  var runtime = new Util.RuntimeOptions{};
  return notifyExecutionWithOptions(request, runtime);
}

model SearchInventoryRequest {
  regionId?: string(name='RegionId'),
  nextToken?: string(name='NextToken'),
  maxResults?: int32(name='MaxResults'),
  filter?: [ 
    {
      value?: [ string ](name='Value'),
      operator?: string(name='Operator'),
      name?: string(name='Name'),
    }
  ](name='Filter'),
  aggregator?: [ string ](name='Aggregator'),
}

model SearchInventoryResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  maxResults?: int32(name='MaxResults'),
  entities?: [  map[string]any ](name='Entities'),
}

model SearchInventoryResponse = {
  headers: map[string]string(name='headers'),
  body: SearchInventoryResponseBody(name='body'),
}

async function searchInventoryWithOptions(request: SearchInventoryRequest, runtime: Util.RuntimeOptions): SearchInventoryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SearchInventory', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function searchInventory(request: SearchInventoryRequest): SearchInventoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchInventoryWithOptions(request, runtime);
}

model SetServiceSettingsRequest {
  deliveryOssEnabled?: boolean(name='DeliveryOssEnabled'),
  deliveryOssBucketName?: string(name='DeliveryOssBucketName'),
  deliveryOssKeyPrefix?: string(name='DeliveryOssKeyPrefix'),
  deliverySlsProjectName?: string(name='DeliverySlsProjectName'),
  deliverySlsEnabled?: boolean(name='DeliverySlsEnabled'),
  regionId?: string(name='RegionId'),
}

model SetServiceSettingsResponseBody = {
  requestId?: string(name='RequestId'),
  serviceSettings?: [ 
    {
      deliveryOssBucketName?: string(name='DeliveryOssBucketName'),
      deliveryOssKeyPrefix?: string(name='DeliveryOssKeyPrefix'),
      deliverySlsEnabled?: boolean(name='DeliverySlsEnabled'),
      deliveryOssEnabled?: boolean(name='DeliveryOssEnabled'),
      deliverySlsProjectName?: string(name='DeliverySlsProjectName'),
    }
  ](name='ServiceSettings'),
}

model SetServiceSettingsResponse = {
  headers: map[string]string(name='headers'),
  body: SetServiceSettingsResponseBody(name='body'),
}

async function setServiceSettingsWithOptions(request: SetServiceSettingsRequest, runtime: Util.RuntimeOptions): SetServiceSettingsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SetServiceSettings', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function setServiceSettings(request: SetServiceSettingsRequest): SetServiceSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  return setServiceSettingsWithOptions(request, runtime);
}

model StartExecutionRequest {
  regionId?: string(name='RegionId'),
  templateName?: string(name='TemplateName'),
  templateVersion?: string(name='TemplateVersion'),
  mode?: string(name='Mode'),
  loopMode?: string(name='LoopMode'),
  parentExecutionId?: string(name='ParentExecutionId'),
  safetyCheck?: string(name='SafetyCheck'),
  parameters?: string(name='Parameters'),
  clientToken?: string(name='ClientToken'),
  tags?: map[string]any(name='Tags'),
  description?: string(name='Description'),
  templateContent?: string(name='TemplateContent'),
}

model StartExecutionShrinkRequest {
  regionId?: string(name='RegionId'),
  templateName?: string(name='TemplateName'),
  templateVersion?: string(name='TemplateVersion'),
  mode?: string(name='Mode'),
  loopMode?: string(name='LoopMode'),
  parentExecutionId?: string(name='ParentExecutionId'),
  safetyCheck?: string(name='SafetyCheck'),
  parameters?: string(name='Parameters'),
  clientToken?: string(name='ClientToken'),
  tagsShrink?: string(name='Tags'),
  description?: string(name='Description'),
  templateContent?: string(name='TemplateContent'),
}

model StartExecutionResponseBody = {
  execution?: {
    status?: string(name='Status'),
    outputs?: string(name='Outputs'),
    executedBy?: string(name='ExecutedBy'),
    endDate?: string(name='EndDate'),
    isParent?: boolean(name='IsParent'),
    startDate?: string(name='StartDate'),
    tags?: map[string]any(name='Tags'),
    mode?: string(name='Mode'),
    safetyCheck?: string(name='SafetyCheck'),
    templateName?: string(name='TemplateName'),
    templateVersion?: string(name='TemplateVersion'),
    createDate?: string(name='CreateDate'),
    executionId?: string(name='ExecutionId'),
    currentTasks?: [ 
      {
        taskExecutionId?: string(name='TaskExecutionId'),
        taskName?: string(name='TaskName'),
        taskAction?: string(name='TaskAction'),
      }
    ](name='CurrentTasks'),
    parameters?: string(name='Parameters'),
    description?: string(name='Description'),
    counters?: map[string]any(name='Counters'),
    updateDate?: string(name='UpdateDate'),
    parentExecutionId?: string(name='ParentExecutionId'),
    ramRole?: string(name='RamRole'),
    templateId?: string(name='TemplateId'),
    statusMessage?: string(name='StatusMessage'),
    loopMode?: string(name='LoopMode'),
  }(name='Execution'),
  requestId?: string(name='RequestId'),
}

model StartExecutionResponse = {
  headers: map[string]string(name='headers'),
  body: StartExecutionResponseBody(name='body'),
}

async function startExecutionWithOptions(tmpReq: StartExecutionRequest, runtime: Util.RuntimeOptions): StartExecutionResponse {
  Util.validateModel(tmpReq);
  var request = new StartExecutionShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('StartExecution', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function startExecution(request: StartExecutionRequest): StartExecutionResponse {
  var runtime = new Util.RuntimeOptions{};
  return startExecutionWithOptions(request, runtime);
}

model TagResourcesRequest {
  regionId?: string(name='RegionId'),
  resourceIds?: map[string]any(name='ResourceIds'),
  resourceType?: string(name='ResourceType'),
  tags?: map[string]any(name='Tags'),
}

model TagResourcesShrinkRequest {
  regionId?: string(name='RegionId'),
  resourceIdsShrink?: string(name='ResourceIds'),
  resourceType?: string(name='ResourceType'),
  tagsShrink?: string(name='Tags'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResourcesWithOptions(tmpReq: TagResourcesRequest, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(tmpReq);
  var request = new TagResourcesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.resourceIds)) {
    request.resourceIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.resourceIds, 'ResourceIds', 'json');
  }
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('TagResources', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagResourcesWithOptions(request, runtime);
}

model TriggerExecutionRequest {
  regionId?: string(name='RegionId'),
  executionId?: string(name='ExecutionId'),
  type?: string(name='Type'),
  content?: string(name='Content'),
  clientToken?: string(name='ClientToken'),
}

model TriggerExecutionResponseBody = {
  requestId?: string(name='RequestId'),
}

model TriggerExecutionResponse = {
  headers: map[string]string(name='headers'),
  body: TriggerExecutionResponseBody(name='body'),
}

async function triggerExecutionWithOptions(request: TriggerExecutionRequest, runtime: Util.RuntimeOptions): TriggerExecutionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('TriggerExecution', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function triggerExecution(request: TriggerExecutionRequest): TriggerExecutionResponse {
  var runtime = new Util.RuntimeOptions{};
  return triggerExecutionWithOptions(request, runtime);
}

model UntagResourcesRequest {
  regionId?: string(name='RegionId'),
  resourceIds?: map[string]any(name='ResourceIds'),
  resourceType?: string(name='ResourceType'),
  tagKeys?: map[string]any(name='TagKeys'),
  all?: boolean(name='All'),
}

model UntagResourcesShrinkRequest {
  regionId?: string(name='RegionId'),
  resourceIdsShrink?: string(name='ResourceIds'),
  resourceType?: string(name='ResourceType'),
  tagKeysShrink?: string(name='TagKeys'),
  all?: boolean(name='All'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResourcesWithOptions(tmpReq: UntagResourcesRequest, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(tmpReq);
  var request = new UntagResourcesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.resourceIds)) {
    request.resourceIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.resourceIds, 'ResourceIds', 'json');
  }
  if (!Util.isUnset(tmpReq.tagKeys)) {
    request.tagKeysShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tagKeys, 'TagKeys', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UntagResources', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return untagResourcesWithOptions(request, runtime);
}

model UpdateExecutionRequest {
  regionId?: string(name='RegionId'),
  executionId?: string(name='ExecutionId'),
  parameters?: string(name='Parameters'),
  clientToken?: string(name='ClientToken'),
}

model UpdateExecutionResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateExecutionResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateExecutionResponseBody(name='body'),
}

async function updateExecutionWithOptions(request: UpdateExecutionRequest, runtime: Util.RuntimeOptions): UpdateExecutionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateExecution', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateExecution(request: UpdateExecutionRequest): UpdateExecutionResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateExecutionWithOptions(request, runtime);
}

model UpdateInstanceInformationRequest {
  regionId?: string(name='RegionId'),
  instanceId?: string(name='InstanceId'),
  agentVersion?: string(name='AgentVersion'),
  platformType?: string(name='PlatformType'),
  platformName?: string(name='PlatformName'),
  platformVersion?: string(name='PlatformVersion'),
  ipAddress?: string(name='IpAddress'),
  computerName?: string(name='ComputerName'),
  agentName?: string(name='AgentName'),
}

model UpdateInstanceInformationResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateInstanceInformationResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateInstanceInformationResponseBody(name='body'),
}

async function updateInstanceInformationWithOptions(request: UpdateInstanceInformationRequest, runtime: Util.RuntimeOptions): UpdateInstanceInformationResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateInstanceInformation', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateInstanceInformation(request: UpdateInstanceInformationRequest): UpdateInstanceInformationResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateInstanceInformationWithOptions(request, runtime);
}

model UpdateParameterRequest {
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
  value?: string(name='Value'),
  description?: string(name='Description'),
}

model UpdateParameterResponseBody = {
  requestId?: string(name='RequestId'),
  parameter?: {
    type?: string(name='Type'),
    constraints?: string(name='Constraints'),
    description?: string(name='Description'),
    updatedDate?: string(name='UpdatedDate'),
    updatedBy?: string(name='UpdatedBy'),
    createdBy?: string(name='CreatedBy'),
    parameterVersion?: int32(name='ParameterVersion'),
    createdDate?: string(name='CreatedDate'),
    name?: string(name='Name'),
    id?: string(name='Id'),
    shareType?: string(name='ShareType'),
  }(name='Parameter'),
}

model UpdateParameterResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateParameterResponseBody(name='body'),
}

async function updateParameterWithOptions(request: UpdateParameterRequest, runtime: Util.RuntimeOptions): UpdateParameterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateParameter', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateParameter(request: UpdateParameterRequest): UpdateParameterResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateParameterWithOptions(request, runtime);
}

model UpdateSecretParameterRequest {
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
  value?: string(name='Value'),
  description?: string(name='Description'),
}

model UpdateSecretParameterResponseBody = {
  requestId?: string(name='RequestId'),
  parameter?: {
    type?: string(name='Type'),
    updatedDate?: string(name='UpdatedDate'),
    updatedBy?: string(name='UpdatedBy'),
    keyId?: string(name='KeyId'),
    constraints?: string(name='Constraints'),
    description?: string(name='Description'),
    createdBy?: string(name='CreatedBy'),
    parameterVersion?: int32(name='ParameterVersion'),
    createdDate?: string(name='CreatedDate'),
    name?: string(name='Name'),
    id?: string(name='Id'),
    shareType?: string(name='ShareType'),
  }(name='Parameter'),
}

model UpdateSecretParameterResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateSecretParameterResponseBody(name='body'),
}

async function updateSecretParameterWithOptions(request: UpdateSecretParameterRequest, runtime: Util.RuntimeOptions): UpdateSecretParameterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateSecretParameter', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateSecretParameter(request: UpdateSecretParameterRequest): UpdateSecretParameterResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSecretParameterWithOptions(request, runtime);
}

model UpdateTemplateRequest {
  regionId?: string(name='RegionId'),
  templateName?: string(name='TemplateName'),
  content?: string(name='Content'),
  tags?: map[string]any(name='Tags'),
  versionName?: string(name='VersionName'),
}

model UpdateTemplateShrinkRequest {
  regionId?: string(name='RegionId'),
  templateName?: string(name='TemplateName'),
  content?: string(name='Content'),
  tagsShrink?: string(name='Tags'),
  versionName?: string(name='VersionName'),
}

model UpdateTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  template?: {
    hash?: string(name='Hash'),
    updatedDate?: string(name='UpdatedDate'),
    updatedBy?: string(name='UpdatedBy'),
    tags?: map[string]any(name='Tags'),
    templateName?: string(name='TemplateName'),
    templateVersion?: string(name='TemplateVersion'),
    templateFormat?: string(name='TemplateFormat'),
    description?: string(name='Description'),
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    hasTrigger?: boolean(name='HasTrigger'),
    templateId?: string(name='TemplateId'),
    shareType?: string(name='ShareType'),
  }(name='Template'),
}

model UpdateTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateTemplateResponseBody(name='body'),
}

async function updateTemplateWithOptions(tmpReq: UpdateTemplateRequest, runtime: Util.RuntimeOptions): UpdateTemplateResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateTemplateShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateTemplate', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateTemplate(request: UpdateTemplateRequest): UpdateTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateTemplateWithOptions(request, runtime);
}

model ValidateTemplateContentRequest {
  regionId?: string(name='RegionId'),
  content?: string(name='Content'),
}

model ValidateTemplateContentResponseBody = {
  parameters?: string(name='Parameters'),
  tasks?: [ 
    {
      outputs?: string(name='Outputs'),
      type?: string(name='Type'),
      description?: string(name='Description'),
      name?: string(name='Name'),
      properties?: string(name='Properties'),
    }
  ](name='Tasks'),
  requestId?: string(name='RequestId'),
  outputs?: string(name='Outputs'),
  ramRole?: string(name='RamRole'),
}

model ValidateTemplateContentResponse = {
  headers: map[string]string(name='headers'),
  body: ValidateTemplateContentResponseBody(name='body'),
}

async function validateTemplateContentWithOptions(request: ValidateTemplateContentRequest, runtime: Util.RuntimeOptions): ValidateTemplateContentResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ValidateTemplateContent', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function validateTemplateContent(request: ValidateTemplateContentRequest): ValidateTemplateContentResponse {
  var runtime = new Util.RuntimeOptions{};
  return validateTemplateContentWithOptions(request, runtime);
}

