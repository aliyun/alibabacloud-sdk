/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('oos', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model CancelExecutionRequest {
  executionId?: string(name='ExecutionId'),
  regionId?: string(name='RegionId'),
}

model CancelExecutionResponseBody = {
  requestId?: string(name='RequestId'),
}

model CancelExecutionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelExecutionResponseBody(name='body'),
}

async function cancelExecutionWithOptions(request: CancelExecutionRequest, runtime: Util.RuntimeOptions): CancelExecutionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.executionId)) {
    query['ExecutionId'] = request.executionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelExecution',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cancelExecution(request: CancelExecutionRequest): CancelExecutionResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelExecutionWithOptions(request, runtime);
}

model ChangeResourceGroupRequest {
  newResourceGroupId?: string(name='NewResourceGroupId'),
  regionId?: string(name='RegionId'),
  resourceId?: string(name='ResourceId'),
  resourceType?: string(name='ResourceType'),
}

model ChangeResourceGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model ChangeResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ChangeResourceGroupResponseBody(name='body'),
}

async function changeResourceGroupWithOptions(request: ChangeResourceGroupRequest, runtime: Util.RuntimeOptions): ChangeResourceGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.newResourceGroupId)) {
    query['NewResourceGroupId'] = request.newResourceGroupId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ChangeResourceGroup',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function changeResourceGroup(request: ChangeResourceGroupRequest): ChangeResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return changeResourceGroupWithOptions(request, runtime);
}

model ContinueDeployApplicationGroupRequest {
  applicationName?: string(name='ApplicationName'),
  deployParameters?: string(name='DeployParameters'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
}

model ContinueDeployApplicationGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model ContinueDeployApplicationGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ContinueDeployApplicationGroupResponseBody(name='body'),
}

async function continueDeployApplicationGroupWithOptions(request: ContinueDeployApplicationGroupRequest, runtime: Util.RuntimeOptions): ContinueDeployApplicationGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.applicationName)) {
    query['ApplicationName'] = request.applicationName;
  }
  if (!Util.isUnset(request.deployParameters)) {
    query['DeployParameters'] = request.deployParameters;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ContinueDeployApplicationGroup',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function continueDeployApplicationGroup(request: ContinueDeployApplicationGroupRequest): ContinueDeployApplicationGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return continueDeployApplicationGroupWithOptions(request, runtime);
}

model CreateApplicationRequest {
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  tags?: map[string]any(name='Tags'),
}

model CreateApplicationShrinkRequest {
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  tagsShrink?: string(name='Tags'),
}

model CreateApplicationResponseBody = {
  application?: {
    createDate?: string(name='CreateDate'),
    description?: string(name='Description'),
    name?: string(name='Name'),
    tags?: map[string]string(name='Tags'),
    updateDate?: string(name='UpdateDate'),
  }(name='Application'),
  requestId?: string(name='RequestId'),
}

model CreateApplicationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateApplicationResponseBody(name='body'),
}

async function createApplicationWithOptions(tmpReq: CreateApplicationRequest, runtime: Util.RuntimeOptions): CreateApplicationResponse {
  Util.validateModel(tmpReq);
  var request = new CreateApplicationShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.tagsShrink)) {
    query['Tags'] = request.tagsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateApplication',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createApplication(request: CreateApplicationRequest): CreateApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return createApplicationWithOptions(request, runtime);
}

model CreateApplicationGroupRequest {
  applicationName?: string(name='ApplicationName'),
  clientToken?: string(name='ClientToken'),
  cmsGroupId?: string(name='CmsGroupId'),
  deployRegionId?: string(name='DeployRegionId'),
  description?: string(name='Description'),
  importTagKey?: string(name='ImportTagKey'),
  importTagValue?: string(name='ImportTagValue'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
}

model CreateApplicationGroupResponseBody = {
  applicationGroup?: {
    applicationName?: string(name='ApplicationName'),
    cmsGroupId?: string(name='CmsGroupId'),
    createDate?: string(name='CreateDate'),
    deployRegionId?: string(name='DeployRegionId'),
    description?: string(name='Description'),
    importTagKey?: string(name='ImportTagKey'),
    importTagValue?: string(name='ImportTagValue'),
    name?: string(name='Name'),
    updateDate?: string(name='UpdateDate'),
  }(name='ApplicationGroup'),
  requestId?: string(name='RequestId'),
}

model CreateApplicationGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateApplicationGroupResponseBody(name='body'),
}

async function createApplicationGroupWithOptions(request: CreateApplicationGroupRequest, runtime: Util.RuntimeOptions): CreateApplicationGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.applicationName)) {
    query['ApplicationName'] = request.applicationName;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.cmsGroupId)) {
    query['CmsGroupId'] = request.cmsGroupId;
  }
  if (!Util.isUnset(request.deployRegionId)) {
    query['DeployRegionId'] = request.deployRegionId;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.importTagKey)) {
    query['ImportTagKey'] = request.importTagKey;
  }
  if (!Util.isUnset(request.importTagValue)) {
    query['ImportTagValue'] = request.importTagValue;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateApplicationGroup',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createApplicationGroup(request: CreateApplicationGroupRequest): CreateApplicationGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createApplicationGroupWithOptions(request, runtime);
}

model CreateOpsItemRequest {
  category?: string(name='Category'),
  clientToken?: string(name='ClientToken'),
  dedupString?: string(name='DedupString'),
  description?: string(name='Description'),
  priority?: int32(name='Priority'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resources?: string(name='Resources'),
  severity?: string(name='Severity'),
  solutions?: string(name='Solutions'),
  source?: string(name='Source'),
  tags?: map[string]any(name='Tags'),
  title?: string(name='Title'),
}

model CreateOpsItemShrinkRequest {
  category?: string(name='Category'),
  clientToken?: string(name='ClientToken'),
  dedupString?: string(name='DedupString'),
  description?: string(name='Description'),
  priority?: int32(name='Priority'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resources?: string(name='Resources'),
  severity?: string(name='Severity'),
  solutions?: string(name='Solutions'),
  source?: string(name='Source'),
  tagsShrink?: string(name='Tags'),
  title?: string(name='Title'),
}

model CreateOpsItemResponseBody = {
  opsItem?: {
    attributes?: string(name='Attributes'),
    category?: string(name='Category'),
    createDate?: string(name='CreateDate'),
    createdBy?: string(name='CreatedBy'),
    description?: string(name='Description'),
    lastModifiedBy?: string(name='LastModifiedBy'),
    opsItemId?: string(name='OpsItemId'),
    priority?: int32(name='Priority'),
    resourceGroupId?: string(name='ResourceGroupId'),
    resources?: string(name='Resources'),
    severity?: string(name='Severity'),
    solutions?: string(name='Solutions'),
    source?: string(name='Source'),
    status?: string(name='Status'),
    tags?: map[string]any(name='Tags'),
    title?: string(name='Title'),
    updateDate?: string(name='UpdateDate'),
  }(name='OpsItem'),
  requestId?: string(name='RequestId'),
}

model CreateOpsItemResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateOpsItemResponseBody(name='body'),
}

async function createOpsItemWithOptions(tmpReq: CreateOpsItemRequest, runtime: Util.RuntimeOptions): CreateOpsItemResponse {
  Util.validateModel(tmpReq);
  var request = new CreateOpsItemShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.category)) {
    query['Category'] = request.category;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dedupString)) {
    query['DedupString'] = request.dedupString;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.priority)) {
    query['Priority'] = request.priority;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resources)) {
    query['Resources'] = request.resources;
  }
  if (!Util.isUnset(request.severity)) {
    query['Severity'] = request.severity;
  }
  if (!Util.isUnset(request.solutions)) {
    query['Solutions'] = request.solutions;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.tagsShrink)) {
    query['Tags'] = request.tagsShrink;
  }
  if (!Util.isUnset(request.title)) {
    query['Title'] = request.title;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateOpsItem',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createOpsItem(request: CreateOpsItemRequest): CreateOpsItemResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOpsItemWithOptions(request, runtime);
}

model CreateParameterRequest {
  clientToken?: string(name='ClientToken'),
  constraints?: string(name='Constraints'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  tags?: map[string]any(name='Tags'),
  type?: string(name='Type'),
  value?: string(name='Value'),
}

model CreateParameterShrinkRequest {
  clientToken?: string(name='ClientToken'),
  constraints?: string(name='Constraints'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  tagsShrink?: string(name='Tags'),
  type?: string(name='Type'),
  value?: string(name='Value'),
}

model CreateParameterResponseBody = {
  parameter?: {
    constraints?: string(name='Constraints'),
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    name?: string(name='Name'),
    parameterVersion?: int32(name='ParameterVersion'),
    resourceGroupId?: string(name='ResourceGroupId'),
    shareType?: string(name='ShareType'),
    tags?: map[string]any(name='Tags'),
    type?: string(name='Type'),
    updatedBy?: string(name='UpdatedBy'),
    updatedDate?: string(name='UpdatedDate'),
  }(name='Parameter'),
  requestId?: string(name='RequestId'),
}

model CreateParameterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateParameterResponseBody(name='body'),
}

async function createParameterWithOptions(tmpReq: CreateParameterRequest, runtime: Util.RuntimeOptions): CreateParameterResponse {
  Util.validateModel(tmpReq);
  var request = new CreateParameterShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.constraints)) {
    query['Constraints'] = request.constraints;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.tagsShrink)) {
    query['Tags'] = request.tagsShrink;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.value)) {
    query['Value'] = request.value;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateParameter',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createParameter(request: CreateParameterRequest): CreateParameterResponse {
  var runtime = new Util.RuntimeOptions{};
  return createParameterWithOptions(request, runtime);
}

model CreatePatchBaselineRequest {
  approvalRules?: string(name='ApprovalRules'),
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  operationSystem?: string(name='OperationSystem'),
  regionId?: string(name='RegionId'),
}

model CreatePatchBaselineResponseBody = {
  patchBaseline?: {
    approvalRules?: string(name='ApprovalRules'),
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    name?: string(name='Name'),
    operationSystem?: string(name='OperationSystem'),
    shareType?: string(name='ShareType'),
    updatedBy?: string(name='UpdatedBy'),
    updatedDate?: string(name='UpdatedDate'),
  }(name='PatchBaseline'),
  requestId?: string(name='RequestId'),
}

model CreatePatchBaselineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreatePatchBaselineResponseBody(name='body'),
}

async function createPatchBaselineWithOptions(request: CreatePatchBaselineRequest, runtime: Util.RuntimeOptions): CreatePatchBaselineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.approvalRules)) {
    query['ApprovalRules'] = request.approvalRules;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.operationSystem)) {
    query['OperationSystem'] = request.operationSystem;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreatePatchBaseline',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createPatchBaseline(request: CreatePatchBaselineRequest): CreatePatchBaselineResponse {
  var runtime = new Util.RuntimeOptions{};
  return createPatchBaselineWithOptions(request, runtime);
}

model CreateSecretParameterRequest {
  clientToken?: string(name='ClientToken'),
  constraints?: string(name='Constraints'),
  description?: string(name='Description'),
  keyId?: string(name='KeyId'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  tags?: map[string]any(name='Tags'),
  type?: string(name='Type'),
  value?: string(name='Value'),
}

model CreateSecretParameterShrinkRequest {
  clientToken?: string(name='ClientToken'),
  constraints?: string(name='Constraints'),
  description?: string(name='Description'),
  keyId?: string(name='KeyId'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  tagsShrink?: string(name='Tags'),
  type?: string(name='Type'),
  value?: string(name='Value'),
}

model CreateSecretParameterResponseBody = {
  parameter?: {
    constraints?: string(name='Constraints'),
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    keyId?: string(name='KeyId'),
    name?: string(name='Name'),
    parameterVersion?: int32(name='ParameterVersion'),
    resourceGroupId?: string(name='ResourceGroupId'),
    shareType?: string(name='ShareType'),
    tags?: map[string]any(name='Tags'),
    type?: string(name='Type'),
    updatedBy?: string(name='UpdatedBy'),
    updatedDate?: string(name='UpdatedDate'),
  }(name='Parameter'),
  requestId?: string(name='RequestId'),
}

model CreateSecretParameterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSecretParameterResponseBody(name='body'),
}

async function createSecretParameterWithOptions(tmpReq: CreateSecretParameterRequest, runtime: Util.RuntimeOptions): CreateSecretParameterResponse {
  Util.validateModel(tmpReq);
  var request = new CreateSecretParameterShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.constraints)) {
    query['Constraints'] = request.constraints;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.tagsShrink)) {
    query['Tags'] = request.tagsShrink;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.value)) {
    query['Value'] = request.value;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateSecretParameter',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createSecretParameter(request: CreateSecretParameterRequest): CreateSecretParameterResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSecretParameterWithOptions(request, runtime);
}

model CreateStateConfigurationRequest {
  clientToken?: string(name='ClientToken'),
  configureMode?: string(name='ConfigureMode'),
  description?: string(name='Description'),
  parameters?: string(name='Parameters'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  scheduleExpression?: string(name='ScheduleExpression'),
  scheduleType?: string(name='ScheduleType'),
  tags?: map[string]any(name='Tags'),
  targets?: string(name='Targets'),
  templateName?: string(name='TemplateName'),
  templateVersion?: string(name='TemplateVersion'),
}

model CreateStateConfigurationShrinkRequest {
  clientToken?: string(name='ClientToken'),
  configureMode?: string(name='ConfigureMode'),
  description?: string(name='Description'),
  parameters?: string(name='Parameters'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  scheduleExpression?: string(name='ScheduleExpression'),
  scheduleType?: string(name='ScheduleType'),
  tagsShrink?: string(name='Tags'),
  targets?: string(name='Targets'),
  templateName?: string(name='TemplateName'),
  templateVersion?: string(name='TemplateVersion'),
}

model CreateStateConfigurationResponseBody = {
  requestId?: string(name='RequestId'),
  stateConfiguration?: {
    configureMode?: string(name='ConfigureMode'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    parameters?: map[string]any(name='Parameters'),
    resourceGroupId?: string(name='ResourceGroupId'),
    scheduleExpression?: string(name='ScheduleExpression'),
    scheduleType?: string(name='ScheduleType'),
    stateConfigurationId?: string(name='StateConfigurationId'),
    tags?: map[string]any(name='Tags'),
    targets?: string(name='Targets'),
    templateId?: string(name='TemplateId'),
    templateName?: string(name='TemplateName'),
    templateVersion?: string(name='TemplateVersion'),
  }(name='StateConfiguration'),
}

model CreateStateConfigurationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateStateConfigurationResponseBody(name='body'),
}

async function createStateConfigurationWithOptions(tmpReq: CreateStateConfigurationRequest, runtime: Util.RuntimeOptions): CreateStateConfigurationResponse {
  Util.validateModel(tmpReq);
  var request = new CreateStateConfigurationShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.configureMode)) {
    query['ConfigureMode'] = request.configureMode;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.parameters)) {
    query['Parameters'] = request.parameters;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.scheduleExpression)) {
    query['ScheduleExpression'] = request.scheduleExpression;
  }
  if (!Util.isUnset(request.scheduleType)) {
    query['ScheduleType'] = request.scheduleType;
  }
  if (!Util.isUnset(request.tagsShrink)) {
    query['Tags'] = request.tagsShrink;
  }
  if (!Util.isUnset(request.targets)) {
    query['Targets'] = request.targets;
  }
  if (!Util.isUnset(request.templateName)) {
    query['TemplateName'] = request.templateName;
  }
  if (!Util.isUnset(request.templateVersion)) {
    query['TemplateVersion'] = request.templateVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateStateConfiguration',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createStateConfiguration(request: CreateStateConfigurationRequest): CreateStateConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  return createStateConfigurationWithOptions(request, runtime);
}

model CreateTemplateRequest {
  content?: string(name='Content'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  tags?: map[string]any(name='Tags'),
  templateName?: string(name='TemplateName'),
  versionName?: string(name='VersionName'),
}

model CreateTemplateShrinkRequest {
  content?: string(name='Content'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  tagsShrink?: string(name='Tags'),
  templateName?: string(name='TemplateName'),
  versionName?: string(name='VersionName'),
}

model CreateTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  template?: {
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    description?: string(name='Description'),
    hasTrigger?: boolean(name='HasTrigger'),
    hash?: string(name='Hash'),
    resourceGroupId?: string(name='ResourceGroupId'),
    shareType?: string(name='ShareType'),
    tags?: map[string]any(name='Tags'),
    templateFormat?: string(name='TemplateFormat'),
    templateId?: string(name='TemplateId'),
    templateName?: string(name='TemplateName'),
    templateVersion?: string(name='TemplateVersion'),
    updatedBy?: string(name='UpdatedBy'),
    updatedDate?: string(name='UpdatedDate'),
  }(name='Template'),
  templateType?: string(name='TemplateType'),
}

model CreateTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateTemplateResponseBody(name='body'),
}

async function createTemplateWithOptions(tmpReq: CreateTemplateRequest, runtime: Util.RuntimeOptions): CreateTemplateResponse {
  Util.validateModel(tmpReq);
  var request = new CreateTemplateShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.content)) {
    query['Content'] = request.content;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.tagsShrink)) {
    query['Tags'] = request.tagsShrink;
  }
  if (!Util.isUnset(request.templateName)) {
    query['TemplateName'] = request.templateName;
  }
  if (!Util.isUnset(request.versionName)) {
    query['VersionName'] = request.versionName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateTemplate',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createTemplate(request: CreateTemplateRequest): CreateTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTemplateWithOptions(request, runtime);
}

model DeleteApplicationRequest {
  force?: boolean(name='Force'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
}

model DeleteApplicationResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteApplicationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteApplicationResponseBody(name='body'),
}

async function deleteApplicationWithOptions(request: DeleteApplicationRequest, runtime: Util.RuntimeOptions): DeleteApplicationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.force)) {
    query['Force'] = request.force;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteApplication',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteApplication(request: DeleteApplicationRequest): DeleteApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteApplicationWithOptions(request, runtime);
}

model DeleteApplicationGroupRequest {
  applicationName?: string(name='ApplicationName'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
}

model DeleteApplicationGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteApplicationGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteApplicationGroupResponseBody(name='body'),
}

async function deleteApplicationGroupWithOptions(request: DeleteApplicationGroupRequest, runtime: Util.RuntimeOptions): DeleteApplicationGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.applicationName)) {
    query['ApplicationName'] = request.applicationName;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteApplicationGroup',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteApplicationGroup(request: DeleteApplicationGroupRequest): DeleteApplicationGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteApplicationGroupWithOptions(request, runtime);
}

model DeleteExecutionsRequest {
  executionIds?: string(name='ExecutionIds'),
  regionId?: string(name='RegionId'),
}

model DeleteExecutionsResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteExecutionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteExecutionsResponseBody(name='body'),
}

async function deleteExecutionsWithOptions(request: DeleteExecutionsRequest, runtime: Util.RuntimeOptions): DeleteExecutionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.executionIds)) {
    query['ExecutionIds'] = request.executionIds;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteExecutions',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteExecutions(request: DeleteExecutionsRequest): DeleteExecutionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteExecutionsWithOptions(request, runtime);
}

model DeleteParameterRequest {
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
}

model DeleteParameterResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteParameterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteParameterResponseBody(name='body'),
}

async function deleteParameterWithOptions(request: DeleteParameterRequest, runtime: Util.RuntimeOptions): DeleteParameterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteParameter',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteParameter(request: DeleteParameterRequest): DeleteParameterResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteParameterWithOptions(request, runtime);
}

model DeletePatchBaselineRequest {
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
}

model DeletePatchBaselineResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeletePatchBaselineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeletePatchBaselineResponseBody(name='body'),
}

async function deletePatchBaselineWithOptions(request: DeletePatchBaselineRequest, runtime: Util.RuntimeOptions): DeletePatchBaselineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeletePatchBaseline',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deletePatchBaseline(request: DeletePatchBaselineRequest): DeletePatchBaselineResponse {
  var runtime = new Util.RuntimeOptions{};
  return deletePatchBaselineWithOptions(request, runtime);
}

model DeleteSecretParameterRequest {
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
}

model DeleteSecretParameterResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteSecretParameterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSecretParameterResponseBody(name='body'),
}

async function deleteSecretParameterWithOptions(request: DeleteSecretParameterRequest, runtime: Util.RuntimeOptions): DeleteSecretParameterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSecretParameter',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSecretParameter(request: DeleteSecretParameterRequest): DeleteSecretParameterResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSecretParameterWithOptions(request, runtime);
}

model DeleteStateConfigurationsRequest {
  clientToken?: string(name='ClientToken'),
  regionId?: string(name='RegionId'),
  stateConfigurationIds?: string(name='StateConfigurationIds'),
}

model DeleteStateConfigurationsResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteStateConfigurationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteStateConfigurationsResponseBody(name='body'),
}

async function deleteStateConfigurationsWithOptions(request: DeleteStateConfigurationsRequest, runtime: Util.RuntimeOptions): DeleteStateConfigurationsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.stateConfigurationIds)) {
    query['StateConfigurationIds'] = request.stateConfigurationIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteStateConfigurations',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteStateConfigurations(request: DeleteStateConfigurationsRequest): DeleteStateConfigurationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteStateConfigurationsWithOptions(request, runtime);
}

model DeleteTemplateRequest {
  autoDeleteExecutions?: boolean(name='AutoDeleteExecutions'),
  regionId?: string(name='RegionId'),
  templateName?: string(name='TemplateName'),
}

model DeleteTemplateResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteTemplateResponseBody(name='body'),
}

async function deleteTemplateWithOptions(request: DeleteTemplateRequest, runtime: Util.RuntimeOptions): DeleteTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoDeleteExecutions)) {
    query['AutoDeleteExecutions'] = request.autoDeleteExecutions;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.templateName)) {
    query['TemplateName'] = request.templateName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteTemplate',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteTemplate(request: DeleteTemplateRequest): DeleteTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTemplateWithOptions(request, runtime);
}

model DeleteTemplatesRequest {
  autoDeleteExecutions?: boolean(name='AutoDeleteExecutions'),
  regionId?: string(name='RegionId'),
  templateNames?: string(name='TemplateNames'),
}

model DeleteTemplatesResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteTemplatesResponseBody(name='body'),
}

async function deleteTemplatesWithOptions(request: DeleteTemplatesRequest, runtime: Util.RuntimeOptions): DeleteTemplatesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoDeleteExecutions)) {
    query['AutoDeleteExecutions'] = request.autoDeleteExecutions;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.templateNames)) {
    query['TemplateNames'] = request.templateNames;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteTemplates',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteTemplates(request: DeleteTemplatesRequest): DeleteTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTemplatesWithOptions(request, runtime);
}

model DeployApplicationGroupRequest {
  applicationName?: string(name='ApplicationName'),
  deployParameters?: string(name='DeployParameters'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
}

model DeployApplicationGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeployApplicationGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeployApplicationGroupResponseBody(name='body'),
}

async function deployApplicationGroupWithOptions(request: DeployApplicationGroupRequest, runtime: Util.RuntimeOptions): DeployApplicationGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.applicationName)) {
    query['ApplicationName'] = request.applicationName;
  }
  if (!Util.isUnset(request.deployParameters)) {
    query['DeployParameters'] = request.deployParameters;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeployApplicationGroup',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deployApplicationGroup(request: DeployApplicationGroupRequest): DeployApplicationGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deployApplicationGroupWithOptions(request, runtime);
}

model DescribeRegionsRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  regionId?: string(name='RegionId'),
}

model DescribeRegionsResponseBody = {
  regions?: [ 
    {
      localName?: string(name='LocalName'),
      regionEndpoint?: string(name='RegionEndpoint'),
      regionId?: string(name='RegionId'),
    }
  ](name='Regions'),
  requestId?: string(name='RequestId'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRegions',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(request, runtime);
}

model GenerateExecutionPolicyRequest {
  regionId?: string(name='RegionId'),
  templateName?: string(name='TemplateName'),
  templateVersion?: string(name='TemplateVersion'),
}

model GenerateExecutionPolicyResponseBody = {
  policy?: string(name='Policy'),
  requestId?: string(name='RequestId'),
}

model GenerateExecutionPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GenerateExecutionPolicyResponseBody(name='body'),
}

async function generateExecutionPolicyWithOptions(request: GenerateExecutionPolicyRequest, runtime: Util.RuntimeOptions): GenerateExecutionPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.templateName)) {
    query['TemplateName'] = request.templateName;
  }
  if (!Util.isUnset(request.templateVersion)) {
    query['TemplateVersion'] = request.templateVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GenerateExecutionPolicy',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function generateExecutionPolicy(request: GenerateExecutionPolicyRequest): GenerateExecutionPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateExecutionPolicyWithOptions(request, runtime);
}

model GetApplicationRequest {
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
}

model GetApplicationResponseBody = {
  application?: {
    createDate?: string(name='CreateDate'),
    description?: string(name='Description'),
    name?: string(name='Name'),
    resourceGroupId?: string(name='ResourceGroupId'),
    tags?: map[string]any(name='Tags'),
    updateDate?: string(name='UpdateDate'),
  }(name='Application'),
  requestId?: string(name='RequestId'),
}

model GetApplicationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetApplicationResponseBody(name='body'),
}

async function getApplicationWithOptions(request: GetApplicationRequest, runtime: Util.RuntimeOptions): GetApplicationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetApplication',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getApplication(request: GetApplicationRequest): GetApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return getApplicationWithOptions(request, runtime);
}

model GetApplicationGroupRequest {
  applicationName?: string(name='ApplicationName'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
}

model GetApplicationGroupResponseBody = {
  applicationGroup?: {
    applicationName?: string(name='ApplicationName'),
    cmsGroupId?: string(name='CmsGroupId'),
    createDate?: string(name='CreateDate'),
    deployOutputs?: string(name='DeployOutputs'),
    deployParameters?: string(name='DeployParameters'),
    deployRegionId?: string(name='DeployRegionId'),
    description?: string(name='Description'),
    importTagKey?: string(name='ImportTagKey'),
    importTagValue?: string(name='ImportTagValue'),
    name?: string(name='Name'),
    progress?: string(name='Progress'),
    status?: string(name='Status'),
    statusReason?: string(name='StatusReason'),
    updateDate?: string(name='UpdateDate'),
  }(name='ApplicationGroup'),
  requestId?: string(name='RequestId'),
}

model GetApplicationGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetApplicationGroupResponseBody(name='body'),
}

async function getApplicationGroupWithOptions(request: GetApplicationGroupRequest, runtime: Util.RuntimeOptions): GetApplicationGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.applicationName)) {
    query['ApplicationName'] = request.applicationName;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetApplicationGroup',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getApplicationGroup(request: GetApplicationGroupRequest): GetApplicationGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return getApplicationGroupWithOptions(request, runtime);
}

model GetExecutionTemplateRequest {
  executionId?: string(name='ExecutionId'),
  regionId?: string(name='RegionId'),
}

model GetExecutionTemplateResponseBody = {
  content?: string(name='Content'),
  requestId?: string(name='RequestId'),
  template?: {
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    description?: string(name='Description'),
    hash?: string(name='Hash'),
    shareType?: string(name='ShareType'),
    tags?: map[string]any(name='Tags'),
    templateFormat?: string(name='TemplateFormat'),
    templateId?: string(name='TemplateId'),
    templateName?: string(name='TemplateName'),
    templateVersion?: string(name='TemplateVersion'),
    updatedBy?: string(name='UpdatedBy'),
    updatedDate?: string(name='UpdatedDate'),
  }(name='Template'),
}

model GetExecutionTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetExecutionTemplateResponseBody(name='body'),
}

async function getExecutionTemplateWithOptions(request: GetExecutionTemplateRequest, runtime: Util.RuntimeOptions): GetExecutionTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.executionId)) {
    query['ExecutionId'] = request.executionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetExecutionTemplate',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getExecutionTemplate(request: GetExecutionTemplateRequest): GetExecutionTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return getExecutionTemplateWithOptions(request, runtime);
}

model GetInventorySchemaRequest {
  aggregator?: boolean(name='Aggregator'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  typeName?: string(name='TypeName'),
}

model GetInventorySchemaResponseBody = {
  maxResults?: string(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  schemas?: [ 
    {
      attributes?: [ 
        {
          dataType?: string(name='DataType'),
          name?: string(name='Name'),
        }
      ](name='Attributes'),
      typeName?: string(name='TypeName'),
      version?: string(name='Version'),
    }
  ](name='Schemas'),
}

model GetInventorySchemaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetInventorySchemaResponseBody(name='body'),
}

async function getInventorySchemaWithOptions(request: GetInventorySchemaRequest, runtime: Util.RuntimeOptions): GetInventorySchemaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aggregator)) {
    query['Aggregator'] = request.aggregator;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.typeName)) {
    query['TypeName'] = request.typeName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetInventorySchema',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getInventorySchema(request: GetInventorySchemaRequest): GetInventorySchemaResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInventorySchemaWithOptions(request, runtime);
}

model GetOpsItemRequest {
  opsItemId?: string(name='OpsItemId'),
  regionId?: string(name='RegionId'),
}

model GetOpsItemResponseBody = {
  opsItem?: {
    attributes?: map[string]any(name='Attributes'),
    category?: string(name='Category'),
    createBy?: string(name='CreateBy'),
    createDate?: string(name='CreateDate'),
    dedupString?: string(name='DedupString'),
    description?: string(name='Description'),
    lastModifiedBy?: string(name='LastModifiedBy'),
    opsItemId?: string(name='OpsItemId'),
    priority?: int32(name='Priority'),
    resourceGroupId?: string(name='ResourceGroupId'),
    resources?: [ string ](name='Resources'),
    severity?: string(name='Severity'),
    solutions?: [  map[string]any ](name='Solutions'),
    source?: string(name='Source'),
    status?: string(name='Status'),
    tags?: map[string]any(name='Tags'),
    title?: string(name='Title'),
    updateDate?: string(name='UpdateDate'),
  }(name='OpsItem'),
  requestId?: string(name='RequestId'),
}

model GetOpsItemResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetOpsItemResponseBody(name='body'),
}

async function getOpsItemWithOptions(request: GetOpsItemRequest, runtime: Util.RuntimeOptions): GetOpsItemResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.opsItemId)) {
    query['OpsItemId'] = request.opsItemId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetOpsItem',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getOpsItem(request: GetOpsItemRequest): GetOpsItemResponse {
  var runtime = new Util.RuntimeOptions{};
  return getOpsItemWithOptions(request, runtime);
}

model GetParameterRequest {
  name?: string(name='Name'),
  parameterVersion?: int32(name='ParameterVersion'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model GetParameterResponseBody = {
  parameter?: {
    constraints?: string(name='Constraints'),
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    name?: string(name='Name'),
    parameterVersion?: int32(name='ParameterVersion'),
    resourceGroupId?: string(name='ResourceGroupId'),
    shareType?: string(name='ShareType'),
    tags?: map[string]any(name='Tags'),
    type?: string(name='Type'),
    updatedBy?: string(name='UpdatedBy'),
    updatedDate?: string(name='UpdatedDate'),
    value?: string(name='Value'),
  }(name='Parameter'),
  requestId?: string(name='RequestId'),
}

model GetParameterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetParameterResponseBody(name='body'),
}

async function getParameterWithOptions(request: GetParameterRequest, runtime: Util.RuntimeOptions): GetParameterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.parameterVersion)) {
    query['ParameterVersion'] = request.parameterVersion;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetParameter',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getParameter(request: GetParameterRequest): GetParameterResponse {
  var runtime = new Util.RuntimeOptions{};
  return getParameterWithOptions(request, runtime);
}

model GetParametersRequest {
  names?: string(name='Names'),
  regionId?: string(name='RegionId'),
}

model GetParametersResponseBody = {
  invalidParameters?: [ string ](name='InvalidParameters'),
  parameters?: [ 
    {
      constraints?: string(name='Constraints'),
      createdBy?: string(name='CreatedBy'),
      createdDate?: string(name='CreatedDate'),
      description?: string(name='Description'),
      id?: string(name='Id'),
      name?: string(name='Name'),
      parameterVersion?: int32(name='ParameterVersion'),
      resourceGroupId?: string(name='ResourceGroupId'),
      shareType?: string(name='ShareType'),
      tags?: map[string]any(name='Tags'),
      type?: string(name='Type'),
      updatedBy?: string(name='UpdatedBy'),
      updatedDate?: string(name='UpdatedDate'),
      value?: string(name='Value'),
    }
  ](name='Parameters'),
  requestId?: string(name='RequestId'),
}

model GetParametersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetParametersResponseBody(name='body'),
}

async function getParametersWithOptions(request: GetParametersRequest, runtime: Util.RuntimeOptions): GetParametersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.names)) {
    query['Names'] = request.names;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetParameters',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getParameters(request: GetParametersRequest): GetParametersResponse {
  var runtime = new Util.RuntimeOptions{};
  return getParametersWithOptions(request, runtime);
}

model GetParametersByPathRequest {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  path?: string(name='Path'),
  recursive?: boolean(name='Recursive'),
  regionId?: string(name='RegionId'),
}

model GetParametersByPathResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  parameters?: [ 
    {
      constraints?: string(name='Constraints'),
      createdBy?: string(name='CreatedBy'),
      createdDate?: string(name='CreatedDate'),
      description?: string(name='Description'),
      id?: string(name='Id'),
      name?: string(name='Name'),
      parameterVersion?: int32(name='ParameterVersion'),
      shareType?: string(name='ShareType'),
      type?: string(name='Type'),
      updatedBy?: string(name='UpdatedBy'),
      updatedDate?: string(name='UpdatedDate'),
      value?: string(name='Value'),
    }
  ](name='Parameters'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model GetParametersByPathResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetParametersByPathResponseBody(name='body'),
}

async function getParametersByPathWithOptions(request: GetParametersByPathRequest, runtime: Util.RuntimeOptions): GetParametersByPathResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.path)) {
    query['Path'] = request.path;
  }
  if (!Util.isUnset(request.recursive)) {
    query['Recursive'] = request.recursive;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetParametersByPath',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getParametersByPath(request: GetParametersByPathRequest): GetParametersByPathResponse {
  var runtime = new Util.RuntimeOptions{};
  return getParametersByPathWithOptions(request, runtime);
}

model GetPatchBaselineRequest {
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
}

model GetPatchBaselineResponseBody = {
  patchBaseline?: {
    approvalRules?: string(name='ApprovalRules'),
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    isDefault?: boolean(name='IsDefault'),
    name?: string(name='Name'),
    operationSystem?: string(name='OperationSystem'),
    shareType?: string(name='ShareType'),
    updatedBy?: string(name='UpdatedBy'),
    updatedDate?: string(name='UpdatedDate'),
  }(name='PatchBaseline'),
  requestId?: string(name='RequestId'),
}

model GetPatchBaselineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPatchBaselineResponseBody(name='body'),
}

async function getPatchBaselineWithOptions(request: GetPatchBaselineRequest, runtime: Util.RuntimeOptions): GetPatchBaselineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetPatchBaseline',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPatchBaseline(request: GetPatchBaselineRequest): GetPatchBaselineResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPatchBaselineWithOptions(request, runtime);
}

model GetSecretParameterRequest {
  name?: string(name='Name'),
  parameterVersion?: int32(name='ParameterVersion'),
  regionId?: string(name='RegionId'),
  withDecryption?: boolean(name='WithDecryption'),
}

model GetSecretParameterResponseBody = {
  parameter?: {
    constraints?: string(name='Constraints'),
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    keyId?: string(name='KeyId'),
    name?: string(name='Name'),
    parameterVersion?: int32(name='ParameterVersion'),
    resourceGroupId?: string(name='ResourceGroupId'),
    shareType?: string(name='ShareType'),
    tags?: map[string]any(name='Tags'),
    type?: string(name='Type'),
    updatedBy?: string(name='UpdatedBy'),
    updatedDate?: string(name='UpdatedDate'),
    value?: string(name='Value'),
  }(name='Parameter'),
  requestId?: string(name='RequestId'),
}

model GetSecretParameterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSecretParameterResponseBody(name='body'),
}

async function getSecretParameterWithOptions(request: GetSecretParameterRequest, runtime: Util.RuntimeOptions): GetSecretParameterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.parameterVersion)) {
    query['ParameterVersion'] = request.parameterVersion;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.withDecryption)) {
    query['WithDecryption'] = request.withDecryption;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSecretParameter',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSecretParameter(request: GetSecretParameterRequest): GetSecretParameterResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSecretParameterWithOptions(request, runtime);
}

model GetSecretParametersRequest {
  names?: string(name='Names'),
  regionId?: string(name='RegionId'),
  withDecryption?: boolean(name='WithDecryption'),
}

model GetSecretParametersResponseBody = {
  invalidParameters?: [ string ](name='InvalidParameters'),
  parameters?: [ 
    {
      constraints?: string(name='Constraints'),
      createdBy?: string(name='CreatedBy'),
      createdDate?: string(name='CreatedDate'),
      description?: string(name='Description'),
      id?: string(name='Id'),
      keyId?: string(name='KeyId'),
      name?: string(name='Name'),
      parameterVersion?: int32(name='ParameterVersion'),
      resourceGroupId?: string(name='ResourceGroupId'),
      shareType?: string(name='ShareType'),
      tags?: map[string]any(name='Tags'),
      type?: string(name='Type'),
      updatedBy?: string(name='UpdatedBy'),
      updatedDate?: string(name='UpdatedDate'),
      value?: string(name='Value'),
    }
  ](name='Parameters'),
  requestId?: string(name='RequestId'),
}

model GetSecretParametersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSecretParametersResponseBody(name='body'),
}

async function getSecretParametersWithOptions(request: GetSecretParametersRequest, runtime: Util.RuntimeOptions): GetSecretParametersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.names)) {
    query['Names'] = request.names;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.withDecryption)) {
    query['WithDecryption'] = request.withDecryption;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSecretParameters',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSecretParameters(request: GetSecretParametersRequest): GetSecretParametersResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSecretParametersWithOptions(request, runtime);
}

model GetSecretParametersByPathRequest {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  path?: string(name='Path'),
  recursive?: boolean(name='Recursive'),
  regionId?: string(name='RegionId'),
  withDecryption?: boolean(name='WithDecryption'),
}

model GetSecretParametersByPathResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  parameters?: [ 
    {
      constraints?: string(name='Constraints'),
      createdBy?: string(name='CreatedBy'),
      createdDate?: string(name='CreatedDate'),
      description?: string(name='Description'),
      id?: string(name='Id'),
      keyId?: string(name='KeyId'),
      name?: string(name='Name'),
      parameterVersion?: int32(name='ParameterVersion'),
      shareType?: string(name='ShareType'),
      type?: string(name='Type'),
      updatedBy?: string(name='UpdatedBy'),
      updatedDate?: string(name='UpdatedDate'),
      value?: string(name='Value'),
    }
  ](name='Parameters'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model GetSecretParametersByPathResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSecretParametersByPathResponseBody(name='body'),
}

async function getSecretParametersByPathWithOptions(request: GetSecretParametersByPathRequest, runtime: Util.RuntimeOptions): GetSecretParametersByPathResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.path)) {
    query['Path'] = request.path;
  }
  if (!Util.isUnset(request.recursive)) {
    query['Recursive'] = request.recursive;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.withDecryption)) {
    query['WithDecryption'] = request.withDecryption;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSecretParametersByPath',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSecretParametersByPath(request: GetSecretParametersByPathRequest): GetSecretParametersByPathResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSecretParametersByPathWithOptions(request, runtime);
}

model GetServiceSettingsRequest {
  regionId?: string(name='RegionId'),
}

model GetServiceSettingsResponseBody = {
  requestId?: string(name='RequestId'),
  serviceSettings?: [ 
    {
      deliveryOssBucketName?: string(name='DeliveryOssBucketName'),
      deliveryOssEnabled?: boolean(name='DeliveryOssEnabled'),
      deliveryOssKeyPrefix?: string(name='DeliveryOssKeyPrefix'),
      deliverySlsEnabled?: boolean(name='DeliverySlsEnabled'),
      deliverySlsProjectName?: string(name='DeliverySlsProjectName'),
      rdcEnterpriseId?: string(name='RdcEnterpriseId'),
    }
  ](name='ServiceSettings'),
}

model GetServiceSettingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetServiceSettingsResponseBody(name='body'),
}

async function getServiceSettingsWithOptions(request: GetServiceSettingsRequest, runtime: Util.RuntimeOptions): GetServiceSettingsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetServiceSettings',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getServiceSettings(request: GetServiceSettingsRequest): GetServiceSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getServiceSettingsWithOptions(request, runtime);
}

model GetTemplateRequest {
  regionId?: string(name='RegionId'),
  templateName?: string(name='TemplateName'),
  templateVersion?: string(name='TemplateVersion'),
}

model GetTemplateResponseBody = {
  content?: string(name='Content'),
  requestId?: string(name='RequestId'),
  template?: {
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    description?: string(name='Description'),
    hasTrigger?: boolean(name='HasTrigger'),
    hash?: string(name='Hash'),
    resourceGroupId?: string(name='ResourceGroupId'),
    shareType?: string(name='ShareType'),
    tags?: map[string]any(name='Tags'),
    templateFormat?: string(name='TemplateFormat'),
    templateId?: string(name='TemplateId'),
    templateName?: string(name='TemplateName'),
    templateType?: string(name='TemplateType'),
    templateVersion?: string(name='TemplateVersion'),
    updatedBy?: string(name='UpdatedBy'),
    updatedDate?: string(name='UpdatedDate'),
    versionName?: string(name='VersionName'),
  }(name='Template'),
}

model GetTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTemplateResponseBody(name='body'),
}

async function getTemplateWithOptions(request: GetTemplateRequest, runtime: Util.RuntimeOptions): GetTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.templateName)) {
    query['TemplateName'] = request.templateName;
  }
  if (!Util.isUnset(request.templateVersion)) {
    query['TemplateVersion'] = request.templateVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTemplate',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTemplate(request: GetTemplateRequest): GetTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTemplateWithOptions(request, runtime);
}

model ListActionsRequest {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  OOSActionName?: string(name='OOSActionName'),
  regionId?: string(name='RegionId'),
}

model ListActionsResponseBody = {
  actions?: [ 
    {
      actionType?: string(name='ActionType'),
      createdDate?: string(name='CreatedDate'),
      description?: string(name='Description'),
      OOSActionName?: string(name='OOSActionName'),
      popularity?: int32(name='Popularity'),
      properties?: string(name='Properties'),
      templateVersion?: string(name='TemplateVersion'),
    }
  ](name='Actions'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model ListActionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListActionsResponseBody(name='body'),
}

async function listActionsWithOptions(request: ListActionsRequest, runtime: Util.RuntimeOptions): ListActionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.OOSActionName)) {
    query['OOSActionName'] = request.OOSActionName;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListActions',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listActions(request: ListActionsRequest): ListActionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listActionsWithOptions(request, runtime);
}

model ListApplicationGroupsRequest {
  applicationName?: string(name='ApplicationName'),
  deployRegionId?: string(name='DeployRegionId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  product?: string(name='Product'),
  regionId?: string(name='RegionId'),
  resourceId?: string(name='ResourceId'),
  resourceType?: string(name='ResourceType'),
}

model ListApplicationGroupsResponseBody = {
  applicationGroups?: [ 
    {
      applicationName?: string(name='ApplicationName'),
      cmsGroupId?: string(name='CmsGroupId'),
      createDate?: string(name='CreateDate'),
      deployParameters?: string(name='DeployParameters'),
      deployRegionId?: string(name='DeployRegionId'),
      description?: string(name='Description'),
      importTagKey?: string(name='ImportTagKey'),
      importTagValue?: string(name='ImportTagValue'),
      name?: string(name='Name'),
      status?: string(name='Status'),
      statusReason?: string(name='StatusReason'),
      updateDate?: string(name='UpdateDate'),
    }
  ](name='ApplicationGroups'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model ListApplicationGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListApplicationGroupsResponseBody(name='body'),
}

async function listApplicationGroupsWithOptions(request: ListApplicationGroupsRequest, runtime: Util.RuntimeOptions): ListApplicationGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.applicationName)) {
    query['ApplicationName'] = request.applicationName;
  }
  if (!Util.isUnset(request.deployRegionId)) {
    query['DeployRegionId'] = request.deployRegionId;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.product)) {
    query['Product'] = request.product;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListApplicationGroups',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listApplicationGroups(request: ListApplicationGroupsRequest): ListApplicationGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listApplicationGroupsWithOptions(request, runtime);
}

model ListApplicationsRequest {
  maxResults?: int32(name='MaxResults'),
  name?: string(name='Name'),
  names?: string(name='Names'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  tags?: map[string]any(name='Tags'),
}

model ListApplicationsShrinkRequest {
  maxResults?: int32(name='MaxResults'),
  name?: string(name='Name'),
  names?: string(name='Names'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  tagsShrink?: string(name='Tags'),
}

model ListApplicationsResponseBody = {
  applications?: [ 
    {
      createDate?: string(name='CreateDate'),
      description?: string(name='Description'),
      name?: string(name='Name'),
      resourceGroupId?: string(name='ResourceGroupId'),
      tags?: map[string]any(name='Tags'),
      updateDate?: string(name='UpdateDate'),
    }
  ](name='Applications'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model ListApplicationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListApplicationsResponseBody(name='body'),
}

async function listApplicationsWithOptions(tmpReq: ListApplicationsRequest, runtime: Util.RuntimeOptions): ListApplicationsResponse {
  Util.validateModel(tmpReq);
  var request = new ListApplicationsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.names)) {
    query['Names'] = request.names;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.tagsShrink)) {
    query['Tags'] = request.tagsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListApplications',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listApplications(request: ListApplicationsRequest): ListApplicationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listApplicationsWithOptions(request, runtime);
}

model ListExecutionLogsRequest {
  executionId?: string(name='ExecutionId'),
  logType?: string(name='LogType'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  taskExecutionId?: string(name='TaskExecutionId'),
}

model ListExecutionLogsResponseBody = {
  executionLogs?: [ 
    {
      logType?: string(name='LogType'),
      message?: string(name='Message'),
      taskExecutionId?: string(name='TaskExecutionId'),
      timestamp?: string(name='Timestamp'),
    }
  ](name='ExecutionLogs'),
  isTruncated?: boolean(name='IsTruncated'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model ListExecutionLogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListExecutionLogsResponseBody(name='body'),
}

async function listExecutionLogsWithOptions(request: ListExecutionLogsRequest, runtime: Util.RuntimeOptions): ListExecutionLogsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.executionId)) {
    query['ExecutionId'] = request.executionId;
  }
  if (!Util.isUnset(request.logType)) {
    query['LogType'] = request.logType;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.taskExecutionId)) {
    query['TaskExecutionId'] = request.taskExecutionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListExecutionLogs',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listExecutionLogs(request: ListExecutionLogsRequest): ListExecutionLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listExecutionLogsWithOptions(request, runtime);
}

model ListExecutionRiskyTasksRequest {
  regionId?: string(name='RegionId'),
  templateName?: string(name='TemplateName'),
}

model ListExecutionRiskyTasksResponseBody = {
  requestId?: string(name='RequestId'),
  riskyTasks?: [ 
    {
      API?: string(name='API'),
      service?: string(name='Service'),
      task?: [ string ](name='Task'),
      template?: [ string ](name='Template'),
    }
  ](name='RiskyTasks'),
}

model ListExecutionRiskyTasksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListExecutionRiskyTasksResponseBody(name='body'),
}

async function listExecutionRiskyTasksWithOptions(request: ListExecutionRiskyTasksRequest, runtime: Util.RuntimeOptions): ListExecutionRiskyTasksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.templateName)) {
    query['TemplateName'] = request.templateName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListExecutionRiskyTasks',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listExecutionRiskyTasks(request: ListExecutionRiskyTasksRequest): ListExecutionRiskyTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return listExecutionRiskyTasksWithOptions(request, runtime);
}

model ListExecutionsRequest {
  category?: string(name='Category'),
  endDateAfter?: string(name='EndDateAfter'),
  endDateBefore?: string(name='EndDateBefore'),
  executedBy?: string(name='ExecutedBy'),
  executionId?: string(name='ExecutionId'),
  includeChildExecution?: boolean(name='IncludeChildExecution'),
  maxResults?: int32(name='MaxResults'),
  mode?: string(name='Mode'),
  nextToken?: string(name='NextToken'),
  parentExecutionId?: string(name='ParentExecutionId'),
  ramRole?: string(name='RamRole'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceId?: string(name='ResourceId'),
  resourceTemplateName?: string(name='ResourceTemplateName'),
  sortField?: string(name='SortField'),
  sortOrder?: string(name='SortOrder'),
  startDateAfter?: string(name='StartDateAfter'),
  startDateBefore?: string(name='StartDateBefore'),
  status?: string(name='Status'),
  tags?: map[string]any(name='Tags'),
  templateName?: string(name='TemplateName'),
}

model ListExecutionsShrinkRequest {
  category?: string(name='Category'),
  endDateAfter?: string(name='EndDateAfter'),
  endDateBefore?: string(name='EndDateBefore'),
  executedBy?: string(name='ExecutedBy'),
  executionId?: string(name='ExecutionId'),
  includeChildExecution?: boolean(name='IncludeChildExecution'),
  maxResults?: int32(name='MaxResults'),
  mode?: string(name='Mode'),
  nextToken?: string(name='NextToken'),
  parentExecutionId?: string(name='ParentExecutionId'),
  ramRole?: string(name='RamRole'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceId?: string(name='ResourceId'),
  resourceTemplateName?: string(name='ResourceTemplateName'),
  sortField?: string(name='SortField'),
  sortOrder?: string(name='SortOrder'),
  startDateAfter?: string(name='StartDateAfter'),
  startDateBefore?: string(name='StartDateBefore'),
  status?: string(name='Status'),
  tagsShrink?: string(name='Tags'),
  templateName?: string(name='TemplateName'),
}

model ListExecutionsResponseBody = {
  executions?: [ 
    {
      category?: string(name='Category'),
      counters?: map[string]any(name='Counters'),
      createDate?: string(name='CreateDate'),
      currentTasks?: [ 
        {
          taskAction?: string(name='TaskAction'),
          taskExecutionId?: string(name='TaskExecutionId'),
          taskName?: string(name='TaskName'),
        }
      ](name='CurrentTasks'),
      description?: string(name='Description'),
      endDate?: string(name='EndDate'),
      executedBy?: string(name='ExecutedBy'),
      executionId?: string(name='ExecutionId'),
      isParent?: boolean(name='IsParent'),
      lastSuccessfulTriggerTime?: string(name='LastSuccessfulTriggerTime'),
      lastTriggerStatus?: string(name='LastTriggerStatus'),
      lastTriggerTime?: string(name='LastTriggerTime'),
      mode?: string(name='Mode'),
      outputs?: string(name='Outputs'),
      parameters?: map[string]any(name='Parameters'),
      parentExecutionId?: string(name='ParentExecutionId'),
      ramRole?: string(name='RamRole'),
      resourceGroupId?: string(name='ResourceGroupId'),
      resourceStatus?: string(name='ResourceStatus'),
      safetyCheck?: string(name='SafetyCheck'),
      startDate?: string(name='StartDate'),
      status?: string(name='Status'),
      statusMessage?: string(name='StatusMessage'),
      statusReason?: string(name='StatusReason'),
      tags?: map[string]any(name='Tags'),
      targets?: string(name='Targets'),
      templateId?: string(name='TemplateId'),
      templateName?: string(name='TemplateName'),
      templateVersion?: string(name='TemplateVersion'),
      updateDate?: string(name='UpdateDate'),
      waitingStatus?: string(name='WaitingStatus'),
    }
  ](name='Executions'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model ListExecutionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListExecutionsResponseBody(name='body'),
}

async function listExecutionsWithOptions(tmpReq: ListExecutionsRequest, runtime: Util.RuntimeOptions): ListExecutionsResponse {
  Util.validateModel(tmpReq);
  var request = new ListExecutionsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.category)) {
    query['Category'] = request.category;
  }
  if (!Util.isUnset(request.endDateAfter)) {
    query['EndDateAfter'] = request.endDateAfter;
  }
  if (!Util.isUnset(request.endDateBefore)) {
    query['EndDateBefore'] = request.endDateBefore;
  }
  if (!Util.isUnset(request.executedBy)) {
    query['ExecutedBy'] = request.executedBy;
  }
  if (!Util.isUnset(request.executionId)) {
    query['ExecutionId'] = request.executionId;
  }
  if (!Util.isUnset(request.includeChildExecution)) {
    query['IncludeChildExecution'] = request.includeChildExecution;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.mode)) {
    query['Mode'] = request.mode;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.parentExecutionId)) {
    query['ParentExecutionId'] = request.parentExecutionId;
  }
  if (!Util.isUnset(request.ramRole)) {
    query['RamRole'] = request.ramRole;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceTemplateName)) {
    query['ResourceTemplateName'] = request.resourceTemplateName;
  }
  if (!Util.isUnset(request.sortField)) {
    query['SortField'] = request.sortField;
  }
  if (!Util.isUnset(request.sortOrder)) {
    query['SortOrder'] = request.sortOrder;
  }
  if (!Util.isUnset(request.startDateAfter)) {
    query['StartDateAfter'] = request.startDateAfter;
  }
  if (!Util.isUnset(request.startDateBefore)) {
    query['StartDateBefore'] = request.startDateBefore;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.tagsShrink)) {
    query['Tags'] = request.tagsShrink;
  }
  if (!Util.isUnset(request.templateName)) {
    query['TemplateName'] = request.templateName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListExecutions',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listExecutions(request: ListExecutionsRequest): ListExecutionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listExecutionsWithOptions(request, runtime);
}

model ListInstancePatchStatesRequest {
  instanceIds?: string(name='InstanceIds'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
}

model ListInstancePatchStatesResponseBody = {
  instancePatchStates?: [ 
    {
      baselineId?: string(name='BaselineId'),
      failedCount?: string(name='FailedCount'),
      installedCount?: string(name='InstalledCount'),
      installedOtherCount?: string(name='InstalledOtherCount'),
      installedPendingRebootCount?: string(name='InstalledPendingRebootCount'),
      installedRejectedCount?: string(name='InstalledRejectedCount'),
      instanceId?: string(name='InstanceId'),
      missingCount?: string(name='MissingCount'),
      operationEndTime?: string(name='OperationEndTime'),
      operationStartTime?: string(name='OperationStartTime'),
      operationType?: string(name='OperationType'),
      ownerInformation?: string(name='OwnerInformation'),
      patchGroup?: string(name='PatchGroup'),
    }
  ](name='InstancePatchStates'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model ListInstancePatchStatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInstancePatchStatesResponseBody(name='body'),
}

async function listInstancePatchStatesWithOptions(request: ListInstancePatchStatesRequest, runtime: Util.RuntimeOptions): ListInstancePatchStatesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInstancePatchStates',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listInstancePatchStates(request: ListInstancePatchStatesRequest): ListInstancePatchStatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInstancePatchStatesWithOptions(request, runtime);
}

model ListInstancePatchesRequest {
  instanceId?: string(name='InstanceId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  patchStatuses?: string(name='PatchStatuses'),
  regionId?: string(name='RegionId'),
}

model ListInstancePatchesResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  patches?: [ 
    {
      classification?: string(name='Classification'),
      installedTime?: string(name='InstalledTime'),
      KBId?: string(name='KBId'),
      severity?: string(name='Severity'),
      status?: string(name='Status'),
      title?: string(name='Title'),
    }
  ](name='Patches'),
  requestId?: string(name='RequestId'),
}

model ListInstancePatchesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInstancePatchesResponseBody(name='body'),
}

async function listInstancePatchesWithOptions(request: ListInstancePatchesRequest, runtime: Util.RuntimeOptions): ListInstancePatchesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.patchStatuses)) {
    query['PatchStatuses'] = request.patchStatuses;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInstancePatches',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listInstancePatches(request: ListInstancePatchesRequest): ListInstancePatchesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInstancePatchesWithOptions(request, runtime);
}

model ListInventoryEntriesRequest {
  filter?: [ 
    {
      name?: string(name='Name'),
      operator?: string(name='Operator'),
      value?: [ string ](name='Value'),
    }
  ](name='Filter'),
  instanceId?: string(name='InstanceId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  typeName?: string(name='TypeName'),
}

model ListInventoryEntriesResponseBody = {
  captureTime?: string(name='CaptureTime'),
  entries?: [  map[string]any ](name='Entries'),
  instanceId?: string(name='InstanceId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  schemaVersion?: string(name='SchemaVersion'),
  typeName?: string(name='TypeName'),
}

model ListInventoryEntriesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInventoryEntriesResponseBody(name='body'),
}

async function listInventoryEntriesWithOptions(request: ListInventoryEntriesRequest, runtime: Util.RuntimeOptions): ListInventoryEntriesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.filter)) {
    query['Filter'] = request.filter;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.typeName)) {
    query['TypeName'] = request.typeName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInventoryEntries',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listInventoryEntries(request: ListInventoryEntriesRequest): ListInventoryEntriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInventoryEntriesWithOptions(request, runtime);
}

model ListOpsItemsRequest {
  filter?: [ 
    {
      name?: string(name='Name'),
      operator?: string(name='Operator'),
      value?: [ string ](name='Value'),
    }
  ](name='Filter'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  resourceTags?: map[string]any(name='ResourceTags'),
  tags?: map[string]any(name='Tags'),
}

model ListOpsItemsShrinkRequest {
  filter?: [ 
    {
      name?: string(name='Name'),
      operator?: string(name='Operator'),
      value?: [ string ](name='Value'),
    }
  ](name='Filter'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  resourceTagsShrink?: string(name='ResourceTags'),
  tagsShrink?: string(name='Tags'),
}

model ListOpsItemsResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  opsItems?: [ 
    {
      category?: string(name='Category'),
      createDate?: string(name='CreateDate'),
      opsItemId?: string(name='OpsItemId'),
      priority?: int32(name='Priority'),
      severity?: string(name='Severity'),
      source?: string(name='Source'),
      status?: string(name='Status'),
      tags?: map[string]any(name='Tags'),
      title?: string(name='Title'),
      updateDate?: string(name='UpdateDate'),
    }
  ](name='OpsItems'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListOpsItemsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListOpsItemsResponseBody(name='body'),
}

async function listOpsItemsWithOptions(tmpReq: ListOpsItemsRequest, runtime: Util.RuntimeOptions): ListOpsItemsResponse {
  Util.validateModel(tmpReq);
  var request = new ListOpsItemsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.resourceTags)) {
    request.resourceTagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.resourceTags, 'ResourceTags', 'json');
  }
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.filter)) {
    query['Filter'] = request.filter;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceTagsShrink)) {
    query['ResourceTags'] = request.resourceTagsShrink;
  }
  if (!Util.isUnset(request.tagsShrink)) {
    query['Tags'] = request.tagsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListOpsItems',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listOpsItems(request: ListOpsItemsRequest): ListOpsItemsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listOpsItemsWithOptions(request, runtime);
}

model ListParameterVersionsRequest {
  maxResults?: int32(name='MaxResults'),
  name?: string(name='Name'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  shareType?: string(name='ShareType'),
}

model ListParameterVersionsResponseBody = {
  createdBy?: string(name='CreatedBy'),
  createdDate?: string(name='CreatedDate'),
  description?: string(name='Description'),
  id?: string(name='Id'),
  maxResults?: int32(name='MaxResults'),
  name?: string(name='Name'),
  nextToken?: string(name='NextToken'),
  parameterVersions?: [ 
    {
      parameterVersion?: int32(name='ParameterVersion'),
      updatedBy?: string(name='UpdatedBy'),
      updatedDate?: string(name='UpdatedDate'),
      value?: string(name='Value'),
    }
  ](name='ParameterVersions'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  type?: string(name='Type'),
}

model ListParameterVersionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListParameterVersionsResponseBody(name='body'),
}

async function listParameterVersionsWithOptions(request: ListParameterVersionsRequest, runtime: Util.RuntimeOptions): ListParameterVersionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.shareType)) {
    query['ShareType'] = request.shareType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListParameterVersions',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listParameterVersions(request: ListParameterVersionsRequest): ListParameterVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listParameterVersionsWithOptions(request, runtime);
}

model ListParametersRequest {
  maxResults?: int32(name='MaxResults'),
  name?: string(name='Name'),
  nextToken?: string(name='NextToken'),
  path?: string(name='Path'),
  recursive?: boolean(name='Recursive'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  sortField?: string(name='SortField'),
  sortOrder?: string(name='SortOrder'),
  tags?: map[string]any(name='Tags'),
  type?: string(name='Type'),
}

model ListParametersShrinkRequest {
  maxResults?: int32(name='MaxResults'),
  name?: string(name='Name'),
  nextToken?: string(name='NextToken'),
  path?: string(name='Path'),
  recursive?: boolean(name='Recursive'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  sortField?: string(name='SortField'),
  sortOrder?: string(name='SortOrder'),
  tagsShrink?: string(name='Tags'),
  type?: string(name='Type'),
}

model ListParametersResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  parameters?: [ 
    {
      createdBy?: string(name='CreatedBy'),
      createdDate?: string(name='CreatedDate'),
      description?: string(name='Description'),
      id?: string(name='Id'),
      name?: string(name='Name'),
      parameterVersion?: string(name='ParameterVersion'),
      resourceGroupId?: string(name='ResourceGroupId'),
      shareType?: string(name='ShareType'),
      tags?: map[string]any(name='Tags'),
      type?: string(name='Type'),
      updatedBy?: string(name='UpdatedBy'),
      updatedDate?: string(name='UpdatedDate'),
    }
  ](name='Parameters'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListParametersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListParametersResponseBody(name='body'),
}

async function listParametersWithOptions(tmpReq: ListParametersRequest, runtime: Util.RuntimeOptions): ListParametersResponse {
  Util.validateModel(tmpReq);
  var request = new ListParametersShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.path)) {
    query['Path'] = request.path;
  }
  if (!Util.isUnset(request.recursive)) {
    query['Recursive'] = request.recursive;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.sortField)) {
    query['SortField'] = request.sortField;
  }
  if (!Util.isUnset(request.sortOrder)) {
    query['SortOrder'] = request.sortOrder;
  }
  if (!Util.isUnset(request.tagsShrink)) {
    query['Tags'] = request.tagsShrink;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListParameters',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listParameters(request: ListParametersRequest): ListParametersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listParametersWithOptions(request, runtime);
}

model ListPatchBaselinesRequest {
  maxResults?: int32(name='MaxResults'),
  name?: string(name='Name'),
  nextToken?: string(name='NextToken'),
  operationSystem?: string(name='OperationSystem'),
  regionId?: string(name='RegionId'),
  shareType?: string(name='ShareType'),
}

model ListPatchBaselinesResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  patchBaselines?: [ 
    {
      createdBy?: string(name='CreatedBy'),
      createdDate?: string(name='CreatedDate'),
      description?: string(name='Description'),
      id?: string(name='Id'),
      isDefault?: boolean(name='IsDefault'),
      name?: string(name='Name'),
      operationSystem?: string(name='OperationSystem'),
      shareType?: string(name='ShareType'),
      updatedBy?: string(name='UpdatedBy'),
      updatedDate?: string(name='UpdatedDate'),
    }
  ](name='PatchBaselines'),
  requestId?: string(name='RequestId'),
}

model ListPatchBaselinesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPatchBaselinesResponseBody(name='body'),
}

async function listPatchBaselinesWithOptions(request: ListPatchBaselinesRequest, runtime: Util.RuntimeOptions): ListPatchBaselinesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.operationSystem)) {
    query['OperationSystem'] = request.operationSystem;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.shareType)) {
    query['ShareType'] = request.shareType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPatchBaselines',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPatchBaselines(request: ListPatchBaselinesRequest): ListPatchBaselinesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPatchBaselinesWithOptions(request, runtime);
}

model ListResourceExecutionStatusRequest {
  executionId?: string(name='ExecutionId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
}

model ListResourceExecutionStatusResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  resourceExecutionStatus?: [ 
    {
      executionId?: string(name='ExecutionId'),
      executionTime?: string(name='ExecutionTime'),
      outputs?: string(name='Outputs'),
      resourceId?: string(name='ResourceId'),
      status?: string(name='Status'),
    }
  ](name='ResourceExecutionStatus'),
}

model ListResourceExecutionStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListResourceExecutionStatusResponseBody(name='body'),
}

async function listResourceExecutionStatusWithOptions(request: ListResourceExecutionStatusRequest, runtime: Util.RuntimeOptions): ListResourceExecutionStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.executionId)) {
    query['ExecutionId'] = request.executionId;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListResourceExecutionStatus',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listResourceExecutionStatus(request: ListResourceExecutionStatusRequest): ListResourceExecutionStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return listResourceExecutionStatusWithOptions(request, runtime);
}

model ListSecretParameterVersionsRequest {
  maxResults?: int32(name='MaxResults'),
  name?: string(name='Name'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  shareType?: string(name='ShareType'),
  withDecryption?: boolean(name='WithDecryption'),
}

model ListSecretParameterVersionsResponseBody = {
  createdBy?: string(name='CreatedBy'),
  createdDate?: string(name='CreatedDate'),
  description?: string(name='Description'),
  id?: string(name='Id'),
  maxResults?: int32(name='MaxResults'),
  name?: string(name='Name'),
  nextToken?: string(name='NextToken'),
  parameterVersions?: [ 
    {
      parameterVersion?: int32(name='ParameterVersion'),
      updatedBy?: string(name='UpdatedBy'),
      updatedDate?: string(name='UpdatedDate'),
      value?: string(name='Value'),
    }
  ](name='ParameterVersions'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  type?: string(name='Type'),
}

model ListSecretParameterVersionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSecretParameterVersionsResponseBody(name='body'),
}

async function listSecretParameterVersionsWithOptions(request: ListSecretParameterVersionsRequest, runtime: Util.RuntimeOptions): ListSecretParameterVersionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.shareType)) {
    query['ShareType'] = request.shareType;
  }
  if (!Util.isUnset(request.withDecryption)) {
    query['WithDecryption'] = request.withDecryption;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSecretParameterVersions',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSecretParameterVersions(request: ListSecretParameterVersionsRequest): ListSecretParameterVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSecretParameterVersionsWithOptions(request, runtime);
}

model ListSecretParametersRequest {
  maxResults?: int32(name='MaxResults'),
  name?: string(name='Name'),
  nextToken?: string(name='NextToken'),
  path?: string(name='Path'),
  recursive?: boolean(name='Recursive'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  sortField?: string(name='SortField'),
  sortOrder?: string(name='SortOrder'),
  tags?: map[string]any(name='Tags'),
}

model ListSecretParametersShrinkRequest {
  maxResults?: int32(name='MaxResults'),
  name?: string(name='Name'),
  nextToken?: string(name='NextToken'),
  path?: string(name='Path'),
  recursive?: boolean(name='Recursive'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  sortField?: string(name='SortField'),
  sortOrder?: string(name='SortOrder'),
  tagsShrink?: string(name='Tags'),
}

model ListSecretParametersResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  parameters?: [ 
    {
      createdBy?: string(name='CreatedBy'),
      createdDate?: string(name='CreatedDate'),
      description?: string(name='Description'),
      id?: string(name='Id'),
      keyId?: string(name='KeyId'),
      name?: string(name='Name'),
      parameterVersion?: string(name='ParameterVersion'),
      resourceGroupId?: string(name='ResourceGroupId'),
      shareType?: string(name='ShareType'),
      tags?: map[string]any(name='Tags'),
      type?: string(name='Type'),
      updatedBy?: string(name='UpdatedBy'),
      updatedDate?: string(name='UpdatedDate'),
    }
  ](name='Parameters'),
  requestId?: string(name='RequestId'),
}

model ListSecretParametersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSecretParametersResponseBody(name='body'),
}

async function listSecretParametersWithOptions(tmpReq: ListSecretParametersRequest, runtime: Util.RuntimeOptions): ListSecretParametersResponse {
  Util.validateModel(tmpReq);
  var request = new ListSecretParametersShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.path)) {
    query['Path'] = request.path;
  }
  if (!Util.isUnset(request.recursive)) {
    query['Recursive'] = request.recursive;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.sortField)) {
    query['SortField'] = request.sortField;
  }
  if (!Util.isUnset(request.sortOrder)) {
    query['SortOrder'] = request.sortOrder;
  }
  if (!Util.isUnset(request.tagsShrink)) {
    query['Tags'] = request.tagsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSecretParameters',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSecretParameters(request: ListSecretParametersRequest): ListSecretParametersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSecretParametersWithOptions(request, runtime);
}

model ListStateConfigurationsRequest {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  stateConfigurationIds?: string(name='StateConfigurationIds'),
  tags?: map[string]any(name='Tags'),
  templateName?: string(name='TemplateName'),
  templateVersion?: string(name='TemplateVersion'),
}

model ListStateConfigurationsShrinkRequest {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  stateConfigurationIds?: string(name='StateConfigurationIds'),
  tagsShrink?: string(name='Tags'),
  templateName?: string(name='TemplateName'),
  templateVersion?: string(name='TemplateVersion'),
}

model ListStateConfigurationsResponseBody = {
  requestId?: string(name='RequestId'),
  stateConfigurations?: [ 
    {
      configureMode?: string(name='ConfigureMode'),
      createTime?: string(name='CreateTime'),
      description?: string(name='Description'),
      parameters?: string(name='Parameters'),
      resourceGroupId?: string(name='ResourceGroupId'),
      scheduleExpression?: string(name='ScheduleExpression'),
      scheduleType?: string(name='ScheduleType'),
      stateConfigurationId?: string(name='StateConfigurationId'),
      tags?: map[string]any(name='Tags'),
      targets?: string(name='Targets'),
      templateId?: string(name='TemplateId'),
      templateName?: string(name='TemplateName'),
      templateVersion?: string(name='TemplateVersion'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='StateConfigurations'),
}

model ListStateConfigurationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListStateConfigurationsResponseBody(name='body'),
}

async function listStateConfigurationsWithOptions(tmpReq: ListStateConfigurationsRequest, runtime: Util.RuntimeOptions): ListStateConfigurationsResponse {
  Util.validateModel(tmpReq);
  var request = new ListStateConfigurationsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.stateConfigurationIds)) {
    query['StateConfigurationIds'] = request.stateConfigurationIds;
  }
  if (!Util.isUnset(request.tagsShrink)) {
    query['Tags'] = request.tagsShrink;
  }
  if (!Util.isUnset(request.templateName)) {
    query['TemplateName'] = request.templateName;
  }
  if (!Util.isUnset(request.templateVersion)) {
    query['TemplateVersion'] = request.templateVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListStateConfigurations',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listStateConfigurations(request: ListStateConfigurationsRequest): ListStateConfigurationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listStateConfigurationsWithOptions(request, runtime);
}

model ListTagKeysRequest {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  resourceType?: string(name='ResourceType'),
}

model ListTagKeysResponseBody = {
  keys?: [ string ](name='Keys'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model ListTagKeysResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagKeysResponseBody(name='body'),
}

async function listTagKeysWithOptions(request: ListTagKeysRequest, runtime: Util.RuntimeOptions): ListTagKeysResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagKeys',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTagKeys(request: ListTagKeysRequest): ListTagKeysResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagKeysWithOptions(request, runtime);
}

model ListTagResourcesRequest {
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  resourceIds?: map[string]any(name='ResourceIds'),
  resourceType?: string(name='ResourceType'),
  tags?: map[string]any(name='Tags'),
}

model ListTagResourcesShrinkRequest {
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  resourceIdsShrink?: string(name='ResourceIds'),
  resourceType?: string(name='ResourceType'),
  tagsShrink?: string(name='Tags'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  tagResources?: {
    tagResource?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='TagResource')
  }(name='TagResources'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResourcesWithOptions(tmpReq: ListTagResourcesRequest, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(tmpReq);
  var request = new ListTagResourcesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.resourceIds)) {
    request.resourceIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.resourceIds, 'ResourceIds', 'json');
  }
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceIdsShrink)) {
    query['ResourceIds'] = request.resourceIdsShrink;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagsShrink)) {
    query['Tags'] = request.tagsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagResources',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagResourcesWithOptions(request, runtime);
}

model ListTagValuesRequest {
  key?: string(name='Key'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  resourceType?: string(name='ResourceType'),
}

model ListTagValuesResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  values?: [ string ](name='Values'),
}

model ListTagValuesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagValuesResponseBody(name='body'),
}

async function listTagValuesWithOptions(request: ListTagValuesRequest, runtime: Util.RuntimeOptions): ListTagValuesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.key)) {
    query['Key'] = request.key;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagValues',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTagValues(request: ListTagValuesRequest): ListTagValuesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagValuesWithOptions(request, runtime);
}

model ListTaskExecutionsRequest {
  endDateAfter?: string(name='EndDateAfter'),
  endDateBefore?: string(name='EndDateBefore'),
  executionId?: string(name='ExecutionId'),
  includeChildTaskExecution?: boolean(name='IncludeChildTaskExecution'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  parentTaskExecutionId?: string(name='ParentTaskExecutionId'),
  regionId?: string(name='RegionId'),
  sortField?: string(name='SortField'),
  sortOrder?: string(name='SortOrder'),
  startDateAfter?: string(name='StartDateAfter'),
  startDateBefore?: string(name='StartDateBefore'),
  status?: string(name='Status'),
  taskAction?: string(name='TaskAction'),
  taskExecutionId?: string(name='TaskExecutionId'),
  taskName?: string(name='TaskName'),
}

model ListTaskExecutionsResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  taskExecutions?: [ 
    {
      childExecutionId?: string(name='ChildExecutionId'),
      createDate?: string(name='CreateDate'),
      endDate?: string(name='EndDate'),
      executionId?: string(name='ExecutionId'),
      extraData?: map[string]any(name='ExtraData'),
      loop?: map[string]any(name='Loop'),
      loopBatchNumber?: int32(name='LoopBatchNumber'),
      loopItem?: string(name='LoopItem'),
      outputs?: string(name='Outputs'),
      parentTaskExecutionId?: string(name='ParentTaskExecutionId'),
      properties?: string(name='Properties'),
      startDate?: string(name='StartDate'),
      status?: string(name='Status'),
      statusMessage?: string(name='StatusMessage'),
      taskAction?: string(name='TaskAction'),
      taskExecutionId?: string(name='TaskExecutionId'),
      taskName?: string(name='TaskName'),
      templateId?: string(name='TemplateId'),
      updateDate?: string(name='UpdateDate'),
    }
  ](name='TaskExecutions'),
}

model ListTaskExecutionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTaskExecutionsResponseBody(name='body'),
}

async function listTaskExecutionsWithOptions(request: ListTaskExecutionsRequest, runtime: Util.RuntimeOptions): ListTaskExecutionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endDateAfter)) {
    query['EndDateAfter'] = request.endDateAfter;
  }
  if (!Util.isUnset(request.endDateBefore)) {
    query['EndDateBefore'] = request.endDateBefore;
  }
  if (!Util.isUnset(request.executionId)) {
    query['ExecutionId'] = request.executionId;
  }
  if (!Util.isUnset(request.includeChildTaskExecution)) {
    query['IncludeChildTaskExecution'] = request.includeChildTaskExecution;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.parentTaskExecutionId)) {
    query['ParentTaskExecutionId'] = request.parentTaskExecutionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.sortField)) {
    query['SortField'] = request.sortField;
  }
  if (!Util.isUnset(request.sortOrder)) {
    query['SortOrder'] = request.sortOrder;
  }
  if (!Util.isUnset(request.startDateAfter)) {
    query['StartDateAfter'] = request.startDateAfter;
  }
  if (!Util.isUnset(request.startDateBefore)) {
    query['StartDateBefore'] = request.startDateBefore;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.taskAction)) {
    query['TaskAction'] = request.taskAction;
  }
  if (!Util.isUnset(request.taskExecutionId)) {
    query['TaskExecutionId'] = request.taskExecutionId;
  }
  if (!Util.isUnset(request.taskName)) {
    query['TaskName'] = request.taskName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTaskExecutions',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTaskExecutions(request: ListTaskExecutionsRequest): ListTaskExecutionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTaskExecutionsWithOptions(request, runtime);
}

model ListTemplateVersionsRequest {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  shareType?: string(name='ShareType'),
  templateName?: string(name='TemplateName'),
}

model ListTemplateVersionsResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  templateVersions?: [ 
    {
      description?: string(name='Description'),
      templateFormat?: string(name='TemplateFormat'),
      templateVersion?: string(name='TemplateVersion'),
      updatedBy?: string(name='UpdatedBy'),
      updatedDate?: string(name='UpdatedDate'),
      versionName?: string(name='VersionName'),
    }
  ](name='TemplateVersions'),
}

model ListTemplateVersionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTemplateVersionsResponseBody(name='body'),
}

async function listTemplateVersionsWithOptions(request: ListTemplateVersionsRequest, runtime: Util.RuntimeOptions): ListTemplateVersionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.shareType)) {
    query['ShareType'] = request.shareType;
  }
  if (!Util.isUnset(request.templateName)) {
    query['TemplateName'] = request.templateName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTemplateVersions',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTemplateVersions(request: ListTemplateVersionsRequest): ListTemplateVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTemplateVersionsWithOptions(request, runtime);
}

model ListTemplatesRequest {
  category?: string(name='Category'),
  createdBy?: string(name='CreatedBy'),
  createdDateAfter?: string(name='CreatedDateAfter'),
  createdDateBefore?: string(name='CreatedDateBefore'),
  hasTrigger?: boolean(name='HasTrigger'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  shareType?: string(name='ShareType'),
  sortField?: string(name='SortField'),
  sortOrder?: string(name='SortOrder'),
  tags?: map[string]any(name='Tags'),
  templateFormat?: string(name='TemplateFormat'),
  templateName?: string(name='TemplateName'),
  templateType?: string(name='TemplateType'),
}

model ListTemplatesShrinkRequest {
  category?: string(name='Category'),
  createdBy?: string(name='CreatedBy'),
  createdDateAfter?: string(name='CreatedDateAfter'),
  createdDateBefore?: string(name='CreatedDateBefore'),
  hasTrigger?: boolean(name='HasTrigger'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  shareType?: string(name='ShareType'),
  sortField?: string(name='SortField'),
  sortOrder?: string(name='SortOrder'),
  tagsShrink?: string(name='Tags'),
  templateFormat?: string(name='TemplateFormat'),
  templateName?: string(name='TemplateName'),
  templateType?: string(name='TemplateType'),
}

model ListTemplatesResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  templates?: [ 
    {
      category?: string(name='Category'),
      createdBy?: string(name='CreatedBy'),
      createdDate?: string(name='CreatedDate'),
      description?: string(name='Description'),
      hasTrigger?: boolean(name='HasTrigger'),
      hash?: string(name='Hash'),
      popularity?: int32(name='Popularity'),
      resourceGroupId?: string(name='ResourceGroupId'),
      shareType?: string(name='ShareType'),
      tags?: map[string]any(name='Tags'),
      templateFormat?: string(name='TemplateFormat'),
      templateId?: string(name='TemplateId'),
      templateName?: string(name='TemplateName'),
      templateType?: string(name='TemplateType'),
      templateVersion?: string(name='TemplateVersion'),
      totalExecutionCount?: int32(name='TotalExecutionCount'),
      updatedBy?: string(name='UpdatedBy'),
      updatedDate?: string(name='UpdatedDate'),
    }
  ](name='Templates'),
}

model ListTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTemplatesResponseBody(name='body'),
}

async function listTemplatesWithOptions(tmpReq: ListTemplatesRequest, runtime: Util.RuntimeOptions): ListTemplatesResponse {
  Util.validateModel(tmpReq);
  var request = new ListTemplatesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.category)) {
    query['Category'] = request.category;
  }
  if (!Util.isUnset(request.createdBy)) {
    query['CreatedBy'] = request.createdBy;
  }
  if (!Util.isUnset(request.createdDateAfter)) {
    query['CreatedDateAfter'] = request.createdDateAfter;
  }
  if (!Util.isUnset(request.createdDateBefore)) {
    query['CreatedDateBefore'] = request.createdDateBefore;
  }
  if (!Util.isUnset(request.hasTrigger)) {
    query['HasTrigger'] = request.hasTrigger;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.shareType)) {
    query['ShareType'] = request.shareType;
  }
  if (!Util.isUnset(request.sortField)) {
    query['SortField'] = request.sortField;
  }
  if (!Util.isUnset(request.sortOrder)) {
    query['SortOrder'] = request.sortOrder;
  }
  if (!Util.isUnset(request.tagsShrink)) {
    query['Tags'] = request.tagsShrink;
  }
  if (!Util.isUnset(request.templateFormat)) {
    query['TemplateFormat'] = request.templateFormat;
  }
  if (!Util.isUnset(request.templateName)) {
    query['TemplateName'] = request.templateName;
  }
  if (!Util.isUnset(request.templateType)) {
    query['TemplateType'] = request.templateType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTemplates',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTemplates(request: ListTemplatesRequest): ListTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTemplatesWithOptions(request, runtime);
}

model NotifyExecutionRequest {
  executionId?: string(name='ExecutionId'),
  executionStatus?: string(name='ExecutionStatus'),
  loopItem?: string(name='LoopItem'),
  notifyNote?: string(name='NotifyNote'),
  notifyType?: string(name='NotifyType'),
  parameters?: string(name='Parameters'),
  regionId?: string(name='RegionId'),
  taskExecutionId?: string(name='TaskExecutionId'),
  taskExecutionIds?: string(name='TaskExecutionIds'),
  taskName?: string(name='TaskName'),
}

model NotifyExecutionResponseBody = {
  requestId?: string(name='RequestId'),
}

model NotifyExecutionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: NotifyExecutionResponseBody(name='body'),
}

async function notifyExecutionWithOptions(request: NotifyExecutionRequest, runtime: Util.RuntimeOptions): NotifyExecutionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.executionId)) {
    query['ExecutionId'] = request.executionId;
  }
  if (!Util.isUnset(request.executionStatus)) {
    query['ExecutionStatus'] = request.executionStatus;
  }
  if (!Util.isUnset(request.loopItem)) {
    query['LoopItem'] = request.loopItem;
  }
  if (!Util.isUnset(request.notifyNote)) {
    query['NotifyNote'] = request.notifyNote;
  }
  if (!Util.isUnset(request.notifyType)) {
    query['NotifyType'] = request.notifyType;
  }
  if (!Util.isUnset(request.parameters)) {
    query['Parameters'] = request.parameters;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.taskExecutionId)) {
    query['TaskExecutionId'] = request.taskExecutionId;
  }
  if (!Util.isUnset(request.taskExecutionIds)) {
    query['TaskExecutionIds'] = request.taskExecutionIds;
  }
  if (!Util.isUnset(request.taskName)) {
    query['TaskName'] = request.taskName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'NotifyExecution',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function notifyExecution(request: NotifyExecutionRequest): NotifyExecutionResponse {
  var runtime = new Util.RuntimeOptions{};
  return notifyExecutionWithOptions(request, runtime);
}

model RegisterDefaultPatchBaselineRequest {
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
}

model RegisterDefaultPatchBaselineResponseBody = {
  patchBaseline?: {
    approvalRules?: string(name='ApprovalRules'),
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    name?: string(name='Name'),
    operationSystem?: string(name='OperationSystem'),
    shareType?: string(name='ShareType'),
    updatedBy?: string(name='UpdatedBy'),
    updatedDate?: string(name='UpdatedDate'),
  }(name='PatchBaseline'),
  requestId?: string(name='RequestId'),
}

model RegisterDefaultPatchBaselineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RegisterDefaultPatchBaselineResponseBody(name='body'),
}

async function registerDefaultPatchBaselineWithOptions(request: RegisterDefaultPatchBaselineRequest, runtime: Util.RuntimeOptions): RegisterDefaultPatchBaselineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RegisterDefaultPatchBaseline',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function registerDefaultPatchBaseline(request: RegisterDefaultPatchBaselineRequest): RegisterDefaultPatchBaselineResponse {
  var runtime = new Util.RuntimeOptions{};
  return registerDefaultPatchBaselineWithOptions(request, runtime);
}

model SearchInventoryRequest {
  aggregator?: [ string ](name='Aggregator'),
  filter?: [ 
    {
      name?: string(name='Name'),
      operator?: string(name='Operator'),
      value?: [ string ](name='Value'),
    }
  ](name='Filter'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
}

model SearchInventoryResponseBody = {
  entities?: [  map[string]any ](name='Entities'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model SearchInventoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchInventoryResponseBody(name='body'),
}

async function searchInventoryWithOptions(request: SearchInventoryRequest, runtime: Util.RuntimeOptions): SearchInventoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aggregator)) {
    query['Aggregator'] = request.aggregator;
  }
  if (!Util.isUnset(request.filter)) {
    query['Filter'] = request.filter;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchInventory',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchInventory(request: SearchInventoryRequest): SearchInventoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchInventoryWithOptions(request, runtime);
}

model SetServiceSettingsRequest {
  deliveryOssBucketName?: string(name='DeliveryOssBucketName'),
  deliveryOssEnabled?: boolean(name='DeliveryOssEnabled'),
  deliveryOssKeyPrefix?: string(name='DeliveryOssKeyPrefix'),
  deliverySlsEnabled?: boolean(name='DeliverySlsEnabled'),
  deliverySlsProjectName?: string(name='DeliverySlsProjectName'),
  rdcEnterpriseId?: string(name='RdcEnterpriseId'),
  regionId?: string(name='RegionId'),
}

model SetServiceSettingsResponseBody = {
  requestId?: string(name='RequestId'),
  serviceSettings?: [ 
    {
      deliveryOssBucketName?: string(name='DeliveryOssBucketName'),
      deliveryOssEnabled?: boolean(name='DeliveryOssEnabled'),
      deliveryOssKeyPrefix?: string(name='DeliveryOssKeyPrefix'),
      deliverySlsEnabled?: boolean(name='DeliverySlsEnabled'),
      deliverySlsProjectName?: string(name='DeliverySlsProjectName'),
      rdcEnterpriseId?: string(name='RdcEnterpriseId'),
    }
  ](name='ServiceSettings'),
}

model SetServiceSettingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetServiceSettingsResponseBody(name='body'),
}

async function setServiceSettingsWithOptions(request: SetServiceSettingsRequest, runtime: Util.RuntimeOptions): SetServiceSettingsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deliveryOssBucketName)) {
    query['DeliveryOssBucketName'] = request.deliveryOssBucketName;
  }
  if (!Util.isUnset(request.deliveryOssEnabled)) {
    query['DeliveryOssEnabled'] = request.deliveryOssEnabled;
  }
  if (!Util.isUnset(request.deliveryOssKeyPrefix)) {
    query['DeliveryOssKeyPrefix'] = request.deliveryOssKeyPrefix;
  }
  if (!Util.isUnset(request.deliverySlsEnabled)) {
    query['DeliverySlsEnabled'] = request.deliverySlsEnabled;
  }
  if (!Util.isUnset(request.deliverySlsProjectName)) {
    query['DeliverySlsProjectName'] = request.deliverySlsProjectName;
  }
  if (!Util.isUnset(request.rdcEnterpriseId)) {
    query['RdcEnterpriseId'] = request.rdcEnterpriseId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetServiceSettings',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setServiceSettings(request: SetServiceSettingsRequest): SetServiceSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  return setServiceSettingsWithOptions(request, runtime);
}

model StartExecutionRequest {
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  loopMode?: string(name='LoopMode'),
  mode?: string(name='Mode'),
  parameters?: string(name='Parameters'),
  parentExecutionId?: string(name='ParentExecutionId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  safetyCheck?: string(name='SafetyCheck'),
  tags?: map[string]any(name='Tags'),
  templateContent?: string(name='TemplateContent'),
  templateName?: string(name='TemplateName'),
  templateVersion?: string(name='TemplateVersion'),
}

model StartExecutionShrinkRequest {
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  loopMode?: string(name='LoopMode'),
  mode?: string(name='Mode'),
  parameters?: string(name='Parameters'),
  parentExecutionId?: string(name='ParentExecutionId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  safetyCheck?: string(name='SafetyCheck'),
  tagsShrink?: string(name='Tags'),
  templateContent?: string(name='TemplateContent'),
  templateName?: string(name='TemplateName'),
  templateVersion?: string(name='TemplateVersion'),
}

model StartExecutionResponseBody = {
  execution?: {
    counters?: map[string]any(name='Counters'),
    createDate?: string(name='CreateDate'),
    currentTasks?: [ 
      {
        taskAction?: string(name='TaskAction'),
        taskExecutionId?: string(name='TaskExecutionId'),
        taskName?: string(name='TaskName'),
      }
    ](name='CurrentTasks'),
    description?: string(name='Description'),
    endDate?: string(name='EndDate'),
    executedBy?: string(name='ExecutedBy'),
    executionId?: string(name='ExecutionId'),
    isParent?: boolean(name='IsParent'),
    loopMode?: string(name='LoopMode'),
    mode?: string(name='Mode'),
    outputs?: string(name='Outputs'),
    parameters?: string(name='Parameters'),
    parentExecutionId?: string(name='ParentExecutionId'),
    ramRole?: string(name='RamRole'),
    resourceGroupId?: string(name='ResourceGroupId'),
    safetyCheck?: string(name='SafetyCheck'),
    startDate?: string(name='StartDate'),
    status?: string(name='Status'),
    statusMessage?: string(name='StatusMessage'),
    tags?: map[string]any(name='Tags'),
    templateId?: string(name='TemplateId'),
    templateName?: string(name='TemplateName'),
    templateVersion?: string(name='TemplateVersion'),
    updateDate?: string(name='UpdateDate'),
  }(name='Execution'),
  requestId?: string(name='RequestId'),
}

model StartExecutionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartExecutionResponseBody(name='body'),
}

async function startExecutionWithOptions(tmpReq: StartExecutionRequest, runtime: Util.RuntimeOptions): StartExecutionResponse {
  Util.validateModel(tmpReq);
  var request = new StartExecutionShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.loopMode)) {
    query['LoopMode'] = request.loopMode;
  }
  if (!Util.isUnset(request.mode)) {
    query['Mode'] = request.mode;
  }
  if (!Util.isUnset(request.parameters)) {
    query['Parameters'] = request.parameters;
  }
  if (!Util.isUnset(request.parentExecutionId)) {
    query['ParentExecutionId'] = request.parentExecutionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.safetyCheck)) {
    query['SafetyCheck'] = request.safetyCheck;
  }
  if (!Util.isUnset(request.tagsShrink)) {
    query['Tags'] = request.tagsShrink;
  }
  if (!Util.isUnset(request.templateContent)) {
    query['TemplateContent'] = request.templateContent;
  }
  if (!Util.isUnset(request.templateName)) {
    query['TemplateName'] = request.templateName;
  }
  if (!Util.isUnset(request.templateVersion)) {
    query['TemplateVersion'] = request.templateVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartExecution',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startExecution(request: StartExecutionRequest): StartExecutionResponse {
  var runtime = new Util.RuntimeOptions{};
  return startExecutionWithOptions(request, runtime);
}

model TagResourcesRequest {
  regionId?: string(name='RegionId'),
  resourceIds?: map[string]any(name='ResourceIds'),
  resourceType?: string(name='ResourceType'),
  tags?: map[string]any(name='Tags'),
}

model TagResourcesShrinkRequest {
  regionId?: string(name='RegionId'),
  resourceIdsShrink?: string(name='ResourceIds'),
  resourceType?: string(name='ResourceType'),
  tagsShrink?: string(name='Tags'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResourcesWithOptions(tmpReq: TagResourcesRequest, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(tmpReq);
  var request = new TagResourcesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.resourceIds)) {
    request.resourceIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.resourceIds, 'ResourceIds', 'json');
  }
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceIdsShrink)) {
    query['ResourceIds'] = request.resourceIdsShrink;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagsShrink)) {
    query['Tags'] = request.tagsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TagResources',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagResourcesWithOptions(request, runtime);
}

model TriggerExecutionRequest {
  clientToken?: string(name='ClientToken'),
  content?: string(name='Content'),
  executionId?: string(name='ExecutionId'),
  regionId?: string(name='RegionId'),
  type?: string(name='Type'),
}

model TriggerExecutionResponseBody = {
  requestId?: string(name='RequestId'),
}

model TriggerExecutionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TriggerExecutionResponseBody(name='body'),
}

async function triggerExecutionWithOptions(request: TriggerExecutionRequest, runtime: Util.RuntimeOptions): TriggerExecutionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.content)) {
    query['Content'] = request.content;
  }
  if (!Util.isUnset(request.executionId)) {
    query['ExecutionId'] = request.executionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TriggerExecution',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function triggerExecution(request: TriggerExecutionRequest): TriggerExecutionResponse {
  var runtime = new Util.RuntimeOptions{};
  return triggerExecutionWithOptions(request, runtime);
}

model UntagResourcesRequest {
  all?: boolean(name='All'),
  regionId?: string(name='RegionId'),
  resourceIds?: map[string]any(name='ResourceIds'),
  resourceType?: string(name='ResourceType'),
  tagKeys?: map[string]any(name='TagKeys'),
}

model UntagResourcesShrinkRequest {
  all?: boolean(name='All'),
  regionId?: string(name='RegionId'),
  resourceIdsShrink?: string(name='ResourceIds'),
  resourceType?: string(name='ResourceType'),
  tagKeysShrink?: string(name='TagKeys'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResourcesWithOptions(tmpReq: UntagResourcesRequest, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(tmpReq);
  var request = new UntagResourcesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.resourceIds)) {
    request.resourceIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.resourceIds, 'ResourceIds', 'json');
  }
  if (!Util.isUnset(tmpReq.tagKeys)) {
    request.tagKeysShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tagKeys, 'TagKeys', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.all)) {
    query['All'] = request.all;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceIdsShrink)) {
    query['ResourceIds'] = request.resourceIdsShrink;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagKeysShrink)) {
    query['TagKeys'] = request.tagKeysShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UntagResources',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return untagResourcesWithOptions(request, runtime);
}

model UpdateApplicationRequest {
  description?: string(name='Description'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
  tags?: map[string]any(name='Tags'),
}

model UpdateApplicationShrinkRequest {
  description?: string(name='Description'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
  tagsShrink?: string(name='Tags'),
}

model UpdateApplicationResponseBody = {
  application?: {
    createdDate?: string(name='CreatedDate'),
    description?: string(name='Description'),
    name?: string(name='Name'),
    resourceGroupId?: string(name='ResourceGroupId'),
    tags?: map[string]any(name='Tags'),
    updatedDate?: string(name='UpdatedDate'),
  }(name='Application'),
  requestId?: string(name='RequestId'),
}

model UpdateApplicationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateApplicationResponseBody(name='body'),
}

async function updateApplicationWithOptions(tmpReq: UpdateApplicationRequest, runtime: Util.RuntimeOptions): UpdateApplicationResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateApplicationShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.tagsShrink)) {
    query['Tags'] = request.tagsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateApplication',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateApplication(request: UpdateApplicationRequest): UpdateApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateApplicationWithOptions(request, runtime);
}

model UpdateApplicationGroupRequest {
  applicationName?: string(name='ApplicationName'),
  name?: string(name='Name'),
  newName?: string(name='NewName'),
  regionId?: string(name='RegionId'),
}

model UpdateApplicationGroupResponseBody = {
  applicationGroup?: {
    applicationName?: string(name='ApplicationName'),
    createdDate?: string(name='CreatedDate'),
    deployRegionId?: string(name='DeployRegionId'),
    description?: string(name='Description'),
    importTagKey?: string(name='ImportTagKey'),
    importTagValue?: string(name='ImportTagValue'),
    name?: string(name='Name'),
    updatedDate?: string(name='UpdatedDate'),
  }(name='ApplicationGroup'),
  requestId?: string(name='RequestId'),
}

model UpdateApplicationGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateApplicationGroupResponseBody(name='body'),
}

async function updateApplicationGroupWithOptions(request: UpdateApplicationGroupRequest, runtime: Util.RuntimeOptions): UpdateApplicationGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.applicationName)) {
    query['ApplicationName'] = request.applicationName;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.newName)) {
    query['NewName'] = request.newName;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateApplicationGroup',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateApplicationGroup(request: UpdateApplicationGroupRequest): UpdateApplicationGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateApplicationGroupWithOptions(request, runtime);
}

model UpdateExecutionRequest {
  clientToken?: string(name='ClientToken'),
  executionId?: string(name='ExecutionId'),
  parameters?: string(name='Parameters'),
  regionId?: string(name='RegionId'),
}

model UpdateExecutionResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateExecutionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateExecutionResponseBody(name='body'),
}

async function updateExecutionWithOptions(request: UpdateExecutionRequest, runtime: Util.RuntimeOptions): UpdateExecutionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.executionId)) {
    query['ExecutionId'] = request.executionId;
  }
  if (!Util.isUnset(request.parameters)) {
    query['Parameters'] = request.parameters;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateExecution',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateExecution(request: UpdateExecutionRequest): UpdateExecutionResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateExecutionWithOptions(request, runtime);
}

model UpdateOpsItemRequest {
  category?: string(name='Category'),
  clientToken?: string(name='ClientToken'),
  dedupString?: string(name='DedupString'),
  description?: string(name='Description'),
  opsItemId?: string(name='OpsItemId'),
  priority?: int32(name='Priority'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resources?: string(name='Resources'),
  severity?: string(name='Severity'),
  solutions?: string(name='Solutions'),
  source?: string(name='Source'),
  status?: string(name='Status'),
  tags?: map[string]any(name='Tags'),
  title?: string(name='Title'),
}

model UpdateOpsItemShrinkRequest {
  category?: string(name='Category'),
  clientToken?: string(name='ClientToken'),
  dedupString?: string(name='DedupString'),
  description?: string(name='Description'),
  opsItemId?: string(name='OpsItemId'),
  priority?: int32(name='Priority'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resources?: string(name='Resources'),
  severity?: string(name='Severity'),
  solutions?: string(name='Solutions'),
  source?: string(name='Source'),
  status?: string(name='Status'),
  tagsShrink?: string(name='Tags'),
  title?: string(name='Title'),
}

model UpdateOpsItemResponseBody = {
  opsItem?: {
    attributes?: string(name='Attributes'),
    category?: string(name='Category'),
    createDate?: string(name='CreateDate'),
    createdBy?: string(name='CreatedBy'),
    description?: string(name='Description'),
    lastModifiedBy?: string(name='LastModifiedBy'),
    opsItemId?: string(name='OpsItemId'),
    priority?: int32(name='Priority'),
    resourceGroupId?: string(name='ResourceGroupId'),
    resources?: [ string ](name='Resources'),
    severity?: string(name='Severity'),
    solutions?: [ string ](name='Solutions'),
    source?: string(name='Source'),
    status?: string(name='Status'),
    tags?: map[string]any(name='Tags'),
    title?: string(name='Title'),
    updateDate?: string(name='UpdateDate'),
  }(name='OpsItem'),
  requestId?: string(name='RequestId'),
}

model UpdateOpsItemResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateOpsItemResponseBody(name='body'),
}

async function updateOpsItemWithOptions(tmpReq: UpdateOpsItemRequest, runtime: Util.RuntimeOptions): UpdateOpsItemResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateOpsItemShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.category)) {
    query['Category'] = request.category;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dedupString)) {
    query['DedupString'] = request.dedupString;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.opsItemId)) {
    query['OpsItemId'] = request.opsItemId;
  }
  if (!Util.isUnset(request.priority)) {
    query['Priority'] = request.priority;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resources)) {
    query['Resources'] = request.resources;
  }
  if (!Util.isUnset(request.severity)) {
    query['Severity'] = request.severity;
  }
  if (!Util.isUnset(request.solutions)) {
    query['Solutions'] = request.solutions;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.tagsShrink)) {
    query['Tags'] = request.tagsShrink;
  }
  if (!Util.isUnset(request.title)) {
    query['Title'] = request.title;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateOpsItem',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateOpsItem(request: UpdateOpsItemRequest): UpdateOpsItemResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateOpsItemWithOptions(request, runtime);
}

model UpdateParameterRequest {
  description?: string(name='Description'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  tags?: string(name='Tags'),
  value?: string(name='Value'),
}

model UpdateParameterResponseBody = {
  parameter?: {
    constraints?: string(name='Constraints'),
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    name?: string(name='Name'),
    parameterVersion?: int32(name='ParameterVersion'),
    resourceGroupId?: string(name='ResourceGroupId'),
    shareType?: string(name='ShareType'),
    tags?: string(name='Tags'),
    type?: string(name='Type'),
    updatedBy?: string(name='UpdatedBy'),
    updatedDate?: string(name='UpdatedDate'),
  }(name='Parameter'),
  requestId?: string(name='RequestId'),
}

model UpdateParameterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateParameterResponseBody(name='body'),
}

async function updateParameterWithOptions(request: UpdateParameterRequest, runtime: Util.RuntimeOptions): UpdateParameterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  if (!Util.isUnset(request.value)) {
    query['Value'] = request.value;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateParameter',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateParameter(request: UpdateParameterRequest): UpdateParameterResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateParameterWithOptions(request, runtime);
}

model UpdatePatchBaselineRequest {
  approvalRules?: string(name='ApprovalRules'),
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
}

model UpdatePatchBaselineResponseBody = {
  patchBaseline?: {
    approvalRules?: string(name='ApprovalRules'),
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    name?: string(name='Name'),
    operationSystem?: string(name='OperationSystem'),
    shareType?: string(name='ShareType'),
    updatedBy?: string(name='UpdatedBy'),
    updatedDate?: string(name='UpdatedDate'),
  }(name='PatchBaseline'),
  requestId?: string(name='RequestId'),
}

model UpdatePatchBaselineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdatePatchBaselineResponseBody(name='body'),
}

async function updatePatchBaselineWithOptions(request: UpdatePatchBaselineRequest, runtime: Util.RuntimeOptions): UpdatePatchBaselineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.approvalRules)) {
    query['ApprovalRules'] = request.approvalRules;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdatePatchBaseline',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updatePatchBaseline(request: UpdatePatchBaselineRequest): UpdatePatchBaselineResponse {
  var runtime = new Util.RuntimeOptions{};
  return updatePatchBaselineWithOptions(request, runtime);
}

model UpdateSecretParameterRequest {
  description?: string(name='Description'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  tags?: map[string]any(name='Tags'),
  value?: string(name='Value'),
}

model UpdateSecretParameterShrinkRequest {
  description?: string(name='Description'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  tagsShrink?: string(name='Tags'),
  value?: string(name='Value'),
}

model UpdateSecretParameterResponseBody = {
  parameter?: {
    constraints?: string(name='Constraints'),
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    keyId?: string(name='KeyId'),
    name?: string(name='Name'),
    parameterVersion?: int32(name='ParameterVersion'),
    resourceGroupId?: string(name='ResourceGroupId'),
    shareType?: string(name='ShareType'),
    tags?: string(name='Tags'),
    type?: string(name='Type'),
    updatedBy?: string(name='UpdatedBy'),
    updatedDate?: string(name='UpdatedDate'),
  }(name='Parameter'),
  requestId?: string(name='RequestId'),
}

model UpdateSecretParameterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateSecretParameterResponseBody(name='body'),
}

async function updateSecretParameterWithOptions(tmpReq: UpdateSecretParameterRequest, runtime: Util.RuntimeOptions): UpdateSecretParameterResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateSecretParameterShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.tagsShrink)) {
    query['Tags'] = request.tagsShrink;
  }
  if (!Util.isUnset(request.value)) {
    query['Value'] = request.value;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSecretParameter',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateSecretParameter(request: UpdateSecretParameterRequest): UpdateSecretParameterResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSecretParameterWithOptions(request, runtime);
}

model UpdateStateConfigurationRequest {
  clientToken?: string(name='ClientToken'),
  configureMode?: string(name='ConfigureMode'),
  description?: string(name='Description'),
  parameters?: map[string]any(name='Parameters'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  scheduleExpression?: string(name='ScheduleExpression'),
  scheduleType?: string(name='ScheduleType'),
  stateConfigurationId?: string(name='StateConfigurationId'),
  tags?: map[string]any(name='Tags'),
  targets?: string(name='Targets'),
}

model UpdateStateConfigurationShrinkRequest {
  clientToken?: string(name='ClientToken'),
  configureMode?: string(name='ConfigureMode'),
  description?: string(name='Description'),
  parametersShrink?: string(name='Parameters'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  scheduleExpression?: string(name='ScheduleExpression'),
  scheduleType?: string(name='ScheduleType'),
  stateConfigurationId?: string(name='StateConfigurationId'),
  tagsShrink?: string(name='Tags'),
  targets?: string(name='Targets'),
}

model UpdateStateConfigurationResponseBody = {
  requestId?: string(name='RequestId'),
  stateConfiguration?: [ 
    {
      configureMode?: string(name='ConfigureMode'),
      createTime?: string(name='CreateTime'),
      description?: string(name='Description'),
      parameters?: string(name='Parameters'),
      resourceGroupId?: string(name='ResourceGroupId'),
      scheduleExpression?: string(name='ScheduleExpression'),
      scheduleType?: string(name='ScheduleType'),
      stateConfigurationId?: string(name='StateConfigurationId'),
      tags?: map[string]any(name='Tags'),
      targets?: string(name='Targets'),
      templateId?: string(name='TemplateId'),
      templateName?: string(name='TemplateName'),
      templateVersion?: string(name='TemplateVersion'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='StateConfiguration'),
}

model UpdateStateConfigurationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateStateConfigurationResponseBody(name='body'),
}

async function updateStateConfigurationWithOptions(tmpReq: UpdateStateConfigurationRequest, runtime: Util.RuntimeOptions): UpdateStateConfigurationResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateStateConfigurationShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.parameters)) {
    request.parametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.parameters, 'Parameters', 'json');
  }
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.configureMode)) {
    query['ConfigureMode'] = request.configureMode;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.parametersShrink)) {
    query['Parameters'] = request.parametersShrink;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.scheduleExpression)) {
    query['ScheduleExpression'] = request.scheduleExpression;
  }
  if (!Util.isUnset(request.scheduleType)) {
    query['ScheduleType'] = request.scheduleType;
  }
  if (!Util.isUnset(request.stateConfigurationId)) {
    query['StateConfigurationId'] = request.stateConfigurationId;
  }
  if (!Util.isUnset(request.tagsShrink)) {
    query['Tags'] = request.tagsShrink;
  }
  if (!Util.isUnset(request.targets)) {
    query['Targets'] = request.targets;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateStateConfiguration',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateStateConfiguration(request: UpdateStateConfigurationRequest): UpdateStateConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateStateConfigurationWithOptions(request, runtime);
}

model UpdateTemplateRequest {
  content?: string(name='Content'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  tags?: map[string]any(name='Tags'),
  templateName?: string(name='TemplateName'),
  versionName?: string(name='VersionName'),
}

model UpdateTemplateShrinkRequest {
  content?: string(name='Content'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  tagsShrink?: string(name='Tags'),
  templateName?: string(name='TemplateName'),
  versionName?: string(name='VersionName'),
}

model UpdateTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  template?: {
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    description?: string(name='Description'),
    hasTrigger?: boolean(name='HasTrigger'),
    hash?: string(name='Hash'),
    resourceGroupId?: string(name='ResourceGroupId'),
    shareType?: string(name='ShareType'),
    tags?: map[string]any(name='Tags'),
    templateFormat?: string(name='TemplateFormat'),
    templateId?: string(name='TemplateId'),
    templateName?: string(name='TemplateName'),
    templateVersion?: string(name='TemplateVersion'),
    updatedBy?: string(name='UpdatedBy'),
    updatedDate?: string(name='UpdatedDate'),
  }(name='Template'),
}

model UpdateTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateTemplateResponseBody(name='body'),
}

async function updateTemplateWithOptions(tmpReq: UpdateTemplateRequest, runtime: Util.RuntimeOptions): UpdateTemplateResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateTemplateShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.content)) {
    query['Content'] = request.content;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.tagsShrink)) {
    query['Tags'] = request.tagsShrink;
  }
  if (!Util.isUnset(request.templateName)) {
    query['TemplateName'] = request.templateName;
  }
  if (!Util.isUnset(request.versionName)) {
    query['VersionName'] = request.versionName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTemplate',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateTemplate(request: UpdateTemplateRequest): UpdateTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateTemplateWithOptions(request, runtime);
}

model ValidateTemplateContentRequest {
  content?: string(name='Content'),
  regionId?: string(name='RegionId'),
}

model ValidateTemplateContentResponseBody = {
  outputs?: string(name='Outputs'),
  parameters?: string(name='Parameters'),
  ramRole?: string(name='RamRole'),
  requestId?: string(name='RequestId'),
  tasks?: [ 
    {
      description?: string(name='Description'),
      name?: string(name='Name'),
      outputs?: string(name='Outputs'),
      properties?: string(name='Properties'),
      type?: string(name='Type'),
    }
  ](name='Tasks'),
}

model ValidateTemplateContentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ValidateTemplateContentResponseBody(name='body'),
}

async function validateTemplateContentWithOptions(request: ValidateTemplateContentRequest, runtime: Util.RuntimeOptions): ValidateTemplateContentResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.content)) {
    query['Content'] = request.content;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ValidateTemplateContent',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function validateTemplateContent(request: ValidateTemplateContentRequest): ValidateTemplateContentResponse {
  var runtime = new Util.RuntimeOptions{};
  return validateTemplateContentWithOptions(request, runtime);
}

