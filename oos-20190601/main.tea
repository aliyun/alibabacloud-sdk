/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('oos', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model CancelExecutionRequest {
  regionId?: string(name='RegionId'),
  executionId?: string(name='ExecutionId'),
}

model CancelExecutionResponseBody = {
  requestId?: string(name='RequestId'),
}

model CancelExecutionResponse = {
  headers: map[string]string(name='headers'),
  body: CancelExecutionResponseBody(name='body'),
}

async function cancelExecutionWithOptions(request: CancelExecutionRequest, runtime: Util.RuntimeOptions): CancelExecutionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CancelExecution', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function cancelExecution(request: CancelExecutionRequest): CancelExecutionResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelExecutionWithOptions(request, runtime);
}

model ChangeResourceGroupRequest {
  regionId?: string(name='RegionId'),
  resourceId?: string(name='ResourceId'),
  newResourceGroupId?: string(name='NewResourceGroupId'),
  resourceType?: string(name='ResourceType'),
}

model ChangeResourceGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model ChangeResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ChangeResourceGroupResponseBody(name='body'),
}

async function changeResourceGroupWithOptions(request: ChangeResourceGroupRequest, runtime: Util.RuntimeOptions): ChangeResourceGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ChangeResourceGroup', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function changeResourceGroup(request: ChangeResourceGroupRequest): ChangeResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return changeResourceGroupWithOptions(request, runtime);
}

model CreateApplicationRequest {
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  type?: string(name='Type'),
  resourceGroupId?: string(name='ResourceGroupId'),
  cloudMonitorContactGroupList?: string(name='CloudMonitorContactGroupList'),
  cloudMonitorEnableSubscribeEvent?: boolean(name='CloudMonitorEnableSubscribeEvent'),
  cloudMonitorEnableInstallAgent?: boolean(name='CloudMonitorEnableInstallAgent'),
  cloudMonitorTemplateIdList?: string(name='CloudMonitorTemplateIdList'),
  cloudMonitorRuleEnabled?: boolean(name='CloudMonitorRuleEnabled'),
}

model CreateApplicationResponseBody = {
  requestId?: string(name='RequestId'),
  application?: {
    type?: string(name='Type'),
    isSystem?: boolean(name='IsSystem'),
    description?: string(name='Description'),
    updateDate?: string(name='UpdateDate'),
    name?: string(name='Name'),
    createDate?: string(name='CreateDate'),
    cloudMonitorRule?: {
      enableSubscribeEvent?: boolean(name='EnableSubscribeEvent'),
      enableInstallAgent?: boolean(name='EnableInstallAgent'),
      enabled?: boolean(name='Enabled'),
      contactGroupList?: [ string ](name='ContactGroupList'),
      templateIdList?: [ int32 ](name='TemplateIdList'),
    }(name='CloudMonitorRule'),
  }(name='Application'),
}

model CreateApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: CreateApplicationResponseBody(name='body'),
}

async function createApplicationWithOptions(request: CreateApplicationRequest, runtime: Util.RuntimeOptions): CreateApplicationResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateApplication', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createApplication(request: CreateApplicationRequest): CreateApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return createApplicationWithOptions(request, runtime);
}

model CreateApplicationGroupRequest {
  regionId?: string(name='RegionId'),
  applicationName?: string(name='ApplicationName'),
  description?: string(name='Description'),
  deployRegionId?: string(name='DeployRegionId'),
  environment?: string(name='Environment'),
  createType?: string(name='CreateType'),
  importClusterId?: string(name='ImportClusterId'),
  name?: string(name='Name'),
}

model CreateApplicationGroupResponseBody = {
  requestId?: string(name='RequestId'),
  applicationGroup?: {
    deployRegionId?: string(name='DeployRegionId'),
    description?: string(name='Description'),
    updatedDate?: string(name='UpdatedDate'),
    createdDate?: string(name='CreatedDate'),
    applicationName?: string(name='ApplicationName'),
    name?: string(name='Name'),
    environment?: string(name='Environment'),
    createType?: string(name='CreateType'),
    scalingGroupId?: string(name='ScalingGroupId'),
    importClusterId?: string(name='ImportClusterId'),
  }(name='ApplicationGroup'),
}

model CreateApplicationGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateApplicationGroupResponseBody(name='body'),
}

async function createApplicationGroupWithOptions(request: CreateApplicationGroupRequest, runtime: Util.RuntimeOptions): CreateApplicationGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateApplicationGroup', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createApplicationGroup(request: CreateApplicationGroupRequest): CreateApplicationGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createApplicationGroupWithOptions(request, runtime);
}

model CreateParameterRequest {
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
  type?: string(name='Type'),
  value?: string(name='Value'),
  description?: string(name='Description'),
  clientToken?: string(name='ClientToken'),
  constraints?: string(name='Constraints'),
  tags?: map[string]any(name='Tags'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model CreateParameterShrinkRequest {
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
  type?: string(name='Type'),
  value?: string(name='Value'),
  description?: string(name='Description'),
  clientToken?: string(name='ClientToken'),
  constraints?: string(name='Constraints'),
  tagsShrink?: string(name='Tags'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model CreateParameterResponseBody = {
  requestId?: string(name='RequestId'),
  parameter?: {
    type?: string(name='Type'),
    updatedDate?: string(name='UpdatedDate'),
    updatedBy?: string(name='UpdatedBy'),
    tags?: map[string]any(name='Tags'),
    description?: string(name='Description'),
    constraints?: string(name='Constraints'),
    resourceGroupId?: string(name='ResourceGroupId'),
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    parameterVersion?: int32(name='ParameterVersion'),
    name?: string(name='Name'),
    id?: string(name='Id'),
    shareType?: string(name='ShareType'),
  }(name='Parameter'),
}

model CreateParameterResponse = {
  headers: map[string]string(name='headers'),
  body: CreateParameterResponseBody(name='body'),
}

async function createParameterWithOptions(tmpReq: CreateParameterRequest, runtime: Util.RuntimeOptions): CreateParameterResponse {
  Util.validateModel(tmpReq);
  var request = new CreateParameterShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateParameter', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createParameter(request: CreateParameterRequest): CreateParameterResponse {
  var runtime = new Util.RuntimeOptions{};
  return createParameterWithOptions(request, runtime);
}

model CreatePatchBaselineRequest {
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  clientToken?: string(name='ClientToken'),
  operationSystem?: string(name='OperationSystem'),
  approvalRules?: string(name='ApprovalRules'),
}

model CreatePatchBaselineResponseBody = {
  requestId?: string(name='RequestId'),
  patchBaseline?: {
    operationSystem?: string(name='OperationSystem'),
    description?: string(name='Description'),
    updatedDate?: string(name='UpdatedDate'),
    updatedBy?: string(name='UpdatedBy'),
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    name?: string(name='Name'),
    approvalRules?: string(name='ApprovalRules'),
    id?: string(name='Id'),
    shareType?: string(name='ShareType'),
  }(name='PatchBaseline'),
}

model CreatePatchBaselineResponse = {
  headers: map[string]string(name='headers'),
  body: CreatePatchBaselineResponseBody(name='body'),
}

async function createPatchBaselineWithOptions(request: CreatePatchBaselineRequest, runtime: Util.RuntimeOptions): CreatePatchBaselineResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreatePatchBaseline', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createPatchBaseline(request: CreatePatchBaselineRequest): CreatePatchBaselineResponse {
  var runtime = new Util.RuntimeOptions{};
  return createPatchBaselineWithOptions(request, runtime);
}

model CreateSecretParameterRequest {
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
  type?: string(name='Type'),
  value?: string(name='Value'),
  description?: string(name='Description'),
  keyId?: string(name='KeyId'),
  clientToken?: string(name='ClientToken'),
  constraints?: string(name='Constraints'),
  tags?: string(name='Tags'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model CreateSecretParameterResponseBody = {
  requestId?: string(name='RequestId'),
  parameter?: {
    type?: string(name='Type'),
    updatedDate?: string(name='UpdatedDate'),
    updatedBy?: string(name='UpdatedBy'),
    keyId?: string(name='KeyId'),
    tags?: string(name='Tags'),
    description?: string(name='Description'),
    constraints?: string(name='Constraints'),
    resourceGroupId?: string(name='ResourceGroupId'),
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    parameterVersion?: int32(name='ParameterVersion'),
    name?: string(name='Name'),
    id?: string(name='Id'),
    shareType?: string(name='ShareType'),
  }(name='Parameter'),
}

model CreateSecretParameterResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSecretParameterResponseBody(name='body'),
}

async function createSecretParameterWithOptions(request: CreateSecretParameterRequest, runtime: Util.RuntimeOptions): CreateSecretParameterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateSecretParameter', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createSecretParameter(request: CreateSecretParameterRequest): CreateSecretParameterResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSecretParameterWithOptions(request, runtime);
}

model CreateStateConfigurationRequest {
  regionId?: string(name='RegionId'),
  description?: string(name='Description'),
  templateName?: string(name='TemplateName'),
  templateVersion?: string(name='TemplateVersion'),
  parameters?: string(name='Parameters'),
  configureMode?: string(name='ConfigureMode'),
  scheduleType?: string(name='ScheduleType'),
  scheduleExpression?: string(name='ScheduleExpression'),
  targets?: string(name='Targets'),
  clientToken?: string(name='ClientToken'),
  tags?: map[string]any(name='Tags'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model CreateStateConfigurationShrinkRequest {
  regionId?: string(name='RegionId'),
  description?: string(name='Description'),
  templateName?: string(name='TemplateName'),
  templateVersion?: string(name='TemplateVersion'),
  parameters?: string(name='Parameters'),
  configureMode?: string(name='ConfigureMode'),
  scheduleType?: string(name='ScheduleType'),
  scheduleExpression?: string(name='ScheduleExpression'),
  targets?: string(name='Targets'),
  clientToken?: string(name='ClientToken'),
  tagsShrink?: string(name='Tags'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model CreateStateConfigurationResponseBody = {
  requestId?: string(name='RequestId'),
  stateConfiguration?: {
    createTime?: string(name='CreateTime'),
    targets?: string(name='Targets'),
    tags?: map[string]any(name='Tags'),
    stateConfigurationId?: string(name='StateConfigurationId'),
    scheduleExpression?: string(name='ScheduleExpression'),
    templateName?: string(name='TemplateName'),
    templateVersion?: string(name='TemplateVersion'),
    configureMode?: string(name='ConfigureMode'),
    scheduleType?: string(name='ScheduleType'),
    parameters?: map[string]any(name='Parameters'),
    description?: string(name='Description'),
    resourceGroupId?: string(name='ResourceGroupId'),
    templateId?: string(name='TemplateId'),
  }(name='StateConfiguration'),
}

model CreateStateConfigurationResponse = {
  headers: map[string]string(name='headers'),
  body: CreateStateConfigurationResponseBody(name='body'),
}

async function createStateConfigurationWithOptions(tmpReq: CreateStateConfigurationRequest, runtime: Util.RuntimeOptions): CreateStateConfigurationResponse {
  Util.validateModel(tmpReq);
  var request = new CreateStateConfigurationShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateStateConfiguration', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createStateConfiguration(request: CreateStateConfigurationRequest): CreateStateConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  return createStateConfigurationWithOptions(request, runtime);
}

model CreateTemplateRequest {
  regionId?: string(name='RegionId'),
  templateName?: string(name='TemplateName'),
  content?: string(name='Content'),
  tags?: map[string]any(name='Tags'),
  versionName?: string(name='VersionName'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model CreateTemplateShrinkRequest {
  regionId?: string(name='RegionId'),
  templateName?: string(name='TemplateName'),
  content?: string(name='Content'),
  tagsShrink?: string(name='Tags'),
  versionName?: string(name='VersionName'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model CreateTemplateResponseBody = {
  templateType?: string(name='TemplateType'),
  requestId?: string(name='RequestId'),
  template?: {
    hash?: string(name='Hash'),
    updatedDate?: string(name='UpdatedDate'),
    updatedBy?: string(name='UpdatedBy'),
    tags?: map[string]any(name='Tags'),
    templateName?: string(name='TemplateName'),
    templateVersion?: string(name='TemplateVersion'),
    templateFormat?: string(name='TemplateFormat'),
    description?: string(name='Description'),
    resourceGroupId?: string(name='ResourceGroupId'),
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    templateId?: string(name='TemplateId'),
    hasTrigger?: boolean(name='HasTrigger'),
    shareType?: string(name='ShareType'),
  }(name='Template'),
}

model CreateTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: CreateTemplateResponseBody(name='body'),
}

async function createTemplateWithOptions(tmpReq: CreateTemplateRequest, runtime: Util.RuntimeOptions): CreateTemplateResponse {
  Util.validateModel(tmpReq);
  var request = new CreateTemplateShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateTemplate', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createTemplate(request: CreateTemplateRequest): CreateTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTemplateWithOptions(request, runtime);
}

model DeleteApplicationRequest {
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
}

model DeleteApplicationResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteApplicationResponseBody(name='body'),
}

async function deleteApplicationWithOptions(request: DeleteApplicationRequest, runtime: Util.RuntimeOptions): DeleteApplicationResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteApplication', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteApplication(request: DeleteApplicationRequest): DeleteApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteApplicationWithOptions(request, runtime);
}

model DeleteApplicationGroupRequest {
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
}

model DeleteApplicationGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteApplicationGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteApplicationGroupResponseBody(name='body'),
}

async function deleteApplicationGroupWithOptions(request: DeleteApplicationGroupRequest, runtime: Util.RuntimeOptions): DeleteApplicationGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteApplicationGroup', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteApplicationGroup(request: DeleteApplicationGroupRequest): DeleteApplicationGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteApplicationGroupWithOptions(request, runtime);
}

model DeleteExecutionsRequest {
  regionId?: string(name='RegionId'),
  executionIds?: string(name='ExecutionIds'),
}

model DeleteExecutionsResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteExecutionsResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteExecutionsResponseBody(name='body'),
}

async function deleteExecutionsWithOptions(request: DeleteExecutionsRequest, runtime: Util.RuntimeOptions): DeleteExecutionsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteExecutions', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteExecutions(request: DeleteExecutionsRequest): DeleteExecutionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteExecutionsWithOptions(request, runtime);
}

model DeleteParameterRequest {
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
}

model DeleteParameterResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteParameterResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteParameterResponseBody(name='body'),
}

async function deleteParameterWithOptions(request: DeleteParameterRequest, runtime: Util.RuntimeOptions): DeleteParameterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteParameter', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteParameter(request: DeleteParameterRequest): DeleteParameterResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteParameterWithOptions(request, runtime);
}

model DeletePatchBaselineRequest {
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
}

model DeletePatchBaselineResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeletePatchBaselineResponse = {
  headers: map[string]string(name='headers'),
  body: DeletePatchBaselineResponseBody(name='body'),
}

async function deletePatchBaselineWithOptions(request: DeletePatchBaselineRequest, runtime: Util.RuntimeOptions): DeletePatchBaselineResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeletePatchBaseline', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deletePatchBaseline(request: DeletePatchBaselineRequest): DeletePatchBaselineResponse {
  var runtime = new Util.RuntimeOptions{};
  return deletePatchBaselineWithOptions(request, runtime);
}

model DeleteSecretParameterRequest {
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
}

model DeleteSecretParameterResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteSecretParameterResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSecretParameterResponseBody(name='body'),
}

async function deleteSecretParameterWithOptions(request: DeleteSecretParameterRequest, runtime: Util.RuntimeOptions): DeleteSecretParameterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteSecretParameter', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteSecretParameter(request: DeleteSecretParameterRequest): DeleteSecretParameterResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSecretParameterWithOptions(request, runtime);
}

model DeleteStateConfigurationsRequest {
  regionId?: string(name='RegionId'),
  stateConfigurationIds?: string(name='StateConfigurationIds'),
  clientToken?: string(name='ClientToken'),
}

model DeleteStateConfigurationsResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteStateConfigurationsResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteStateConfigurationsResponseBody(name='body'),
}

async function deleteStateConfigurationsWithOptions(request: DeleteStateConfigurationsRequest, runtime: Util.RuntimeOptions): DeleteStateConfigurationsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteStateConfigurations', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteStateConfigurations(request: DeleteStateConfigurationsRequest): DeleteStateConfigurationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteStateConfigurationsWithOptions(request, runtime);
}

model DeleteTemplateRequest {
  regionId?: string(name='RegionId'),
  templateName?: string(name='TemplateName'),
  autoDeleteExecutions?: boolean(name='AutoDeleteExecutions'),
}

model DeleteTemplateResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteTemplateResponseBody(name='body'),
}

async function deleteTemplateWithOptions(request: DeleteTemplateRequest, runtime: Util.RuntimeOptions): DeleteTemplateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteTemplate', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteTemplate(request: DeleteTemplateRequest): DeleteTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTemplateWithOptions(request, runtime);
}

model DeleteTemplatesRequest {
  regionId?: string(name='RegionId'),
  templateNames?: string(name='TemplateNames'),
  autoDeleteExecutions?: boolean(name='AutoDeleteExecutions'),
}

model DeleteTemplatesResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteTemplatesResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteTemplatesResponseBody(name='body'),
}

async function deleteTemplatesWithOptions(request: DeleteTemplatesRequest, runtime: Util.RuntimeOptions): DeleteTemplatesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteTemplates', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteTemplates(request: DeleteTemplatesRequest): DeleteTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTemplatesWithOptions(request, runtime);
}

model DescribeRegionsRequest {
  regionId?: string(name='RegionId'),
  acceptLanguage?: string(name='AcceptLanguage'),
}

model DescribeRegionsResponseBody = {
  requestId?: string(name='RequestId'),
  regions?: [ 
    {
      regionEndpoint?: string(name='RegionEndpoint'),
      localName?: string(name='LocalName'),
      regionId?: string(name='RegionId'),
    }
  ](name='Regions'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeRegions', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(request, runtime);
}

model GenerateExecutionPolicyRequest {
  regionId?: string(name='RegionId'),
  templateName?: string(name='TemplateName'),
  templateVersion?: string(name='TemplateVersion'),
}

model GenerateExecutionPolicyResponseBody = {
  policy?: string(name='Policy'),
  requestId?: string(name='RequestId'),
}

model GenerateExecutionPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: GenerateExecutionPolicyResponseBody(name='body'),
}

async function generateExecutionPolicyWithOptions(request: GenerateExecutionPolicyRequest, runtime: Util.RuntimeOptions): GenerateExecutionPolicyResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GenerateExecutionPolicy', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function generateExecutionPolicy(request: GenerateExecutionPolicyRequest): GenerateExecutionPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateExecutionPolicyWithOptions(request, runtime);
}

model GetApplicationRequest {
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
}

model GetApplicationResponseBody = {
  requestId?: string(name='RequestId'),
  application?: {
    isSystem?: string(name='IsSystem'),
    description?: string(name='Description'),
    updatedDate?: string(name='UpdatedDate'),
    resourceGroupId?: string(name='ResourceGroupId'),
    createdDate?: string(name='CreatedDate'),
    name?: string(name='Name'),
    cloudMonitorRule?: {
      enableSubscribeEvent?: boolean(name='EnableSubscribeEvent'),
      enableInstallAgent?: boolean(name='EnableInstallAgent'),
      enabled?: boolean(name='Enabled'),
      contactGroupList?: [ string ](name='ContactGroupList'),
      templateIdList?: [ int32 ](name='TemplateIdList'),
    }(name='CloudMonitorRule'),
  }(name='Application'),
}

model GetApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: GetApplicationResponseBody(name='body'),
}

async function getApplicationWithOptions(request: GetApplicationRequest, runtime: Util.RuntimeOptions): GetApplicationResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetApplication', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getApplication(request: GetApplicationRequest): GetApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return getApplicationWithOptions(request, runtime);
}

model GetApplicationGroupRequest {
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
}

model GetApplicationGroupResponseBody = {
  requestId?: string(name='RequestId'),
  applicationGroup?: {
    deployRegionId?: string(name='DeployRegionId'),
    description?: string(name='Description'),
    updatedDate?: string(name='UpdatedDate'),
    createdDate?: string(name='CreatedDate'),
    applicationName?: string(name='ApplicationName'),
    name?: string(name='Name'),
    environment?: string(name='Environment'),
    createType?: string(name='CreateType'),
    scalingGroupId?: string(name='ScalingGroupId'),
    importClusterId?: string(name='ImportClusterId'),
  }(name='ApplicationGroup'),
}

model GetApplicationGroupResponse = {
  headers: map[string]string(name='headers'),
  body: GetApplicationGroupResponseBody(name='body'),
}

async function getApplicationGroupWithOptions(request: GetApplicationGroupRequest, runtime: Util.RuntimeOptions): GetApplicationGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetApplicationGroup', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getApplicationGroup(request: GetApplicationGroupRequest): GetApplicationGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return getApplicationGroupWithOptions(request, runtime);
}

model GetExecutionTemplateRequest {
  regionId?: string(name='RegionId'),
  executionId?: string(name='ExecutionId'),
}

model GetExecutionTemplateResponseBody = {
  content?: string(name='Content'),
  requestId?: string(name='RequestId'),
  template?: {
    hash?: string(name='Hash'),
    updatedDate?: string(name='UpdatedDate'),
    updatedBy?: string(name='UpdatedBy'),
    tags?: map[string]any(name='Tags'),
    templateName?: string(name='TemplateName'),
    templateVersion?: string(name='TemplateVersion'),
    templateFormat?: string(name='TemplateFormat'),
    description?: string(name='Description'),
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    templateId?: string(name='TemplateId'),
    shareType?: string(name='ShareType'),
  }(name='Template'),
}

model GetExecutionTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: GetExecutionTemplateResponseBody(name='body'),
}

async function getExecutionTemplateWithOptions(request: GetExecutionTemplateRequest, runtime: Util.RuntimeOptions): GetExecutionTemplateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetExecutionTemplate', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getExecutionTemplate(request: GetExecutionTemplateRequest): GetExecutionTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return getExecutionTemplateWithOptions(request, runtime);
}

model GetInventorySchemaRequest {
  regionId?: string(name='RegionId'),
  aggregator?: boolean(name='Aggregator'),
  typeName?: string(name='TypeName'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
}

model GetInventorySchemaResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  maxResults?: string(name='MaxResults'),
  schemas?: [ 
    {
      version?: string(name='Version'),
      typeName?: string(name='TypeName'),
      attributes?: [ 
        {
          name?: string(name='Name'),
          dataType?: string(name='DataType'),
        }
      ](name='Attributes'),
    }
  ](name='Schemas'),
}

model GetInventorySchemaResponse = {
  headers: map[string]string(name='headers'),
  body: GetInventorySchemaResponseBody(name='body'),
}

async function getInventorySchemaWithOptions(request: GetInventorySchemaRequest, runtime: Util.RuntimeOptions): GetInventorySchemaResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetInventorySchema', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getInventorySchema(request: GetInventorySchemaRequest): GetInventorySchemaResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInventorySchemaWithOptions(request, runtime);
}

model GetParameterRequest {
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
  parameterVersion?: int32(name='ParameterVersion'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model GetParameterResponseBody = {
  requestId?: string(name='RequestId'),
  parameter?: {
    type?: string(name='Type'),
    updatedDate?: string(name='UpdatedDate'),
    updatedBy?: string(name='UpdatedBy'),
    tags?: map[string]any(name='Tags'),
    value?: string(name='Value'),
    description?: string(name='Description'),
    constraints?: string(name='Constraints'),
    resourceGroupId?: string(name='ResourceGroupId'),
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    parameterVersion?: int32(name='ParameterVersion'),
    name?: string(name='Name'),
    id?: string(name='Id'),
    shareType?: string(name='ShareType'),
  }(name='Parameter'),
}

model GetParameterResponse = {
  headers: map[string]string(name='headers'),
  body: GetParameterResponseBody(name='body'),
}

async function getParameterWithOptions(request: GetParameterRequest, runtime: Util.RuntimeOptions): GetParameterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetParameter', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getParameter(request: GetParameterRequest): GetParameterResponse {
  var runtime = new Util.RuntimeOptions{};
  return getParameterWithOptions(request, runtime);
}

model GetParametersRequest {
  regionId?: string(name='RegionId'),
  names?: string(name='Names'),
}

model GetParametersResponseBody = {
  requestId?: string(name='RequestId'),
  invalidParameters?: [ string ](name='InvalidParameters'),
  parameters?: [ 
    {
      type?: string(name='Type'),
      updatedDate?: string(name='UpdatedDate'),
      updatedBy?: string(name='UpdatedBy'),
      tags?: map[string]any(name='Tags'),
      value?: string(name='Value'),
      description?: string(name='Description'),
      constraints?: string(name='Constraints'),
      resourceGroupId?: string(name='ResourceGroupId'),
      createdBy?: string(name='CreatedBy'),
      createdDate?: string(name='CreatedDate'),
      parameterVersion?: int32(name='ParameterVersion'),
      name?: string(name='Name'),
      id?: string(name='Id'),
      shareType?: string(name='ShareType'),
    }
  ](name='Parameters'),
}

model GetParametersResponse = {
  headers: map[string]string(name='headers'),
  body: GetParametersResponseBody(name='body'),
}

async function getParametersWithOptions(request: GetParametersRequest, runtime: Util.RuntimeOptions): GetParametersResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetParameters', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getParameters(request: GetParametersRequest): GetParametersResponse {
  var runtime = new Util.RuntimeOptions{};
  return getParametersWithOptions(request, runtime);
}

model GetParametersByPathRequest {
  regionId?: string(name='RegionId'),
  path?: string(name='Path'),
  recursive?: boolean(name='Recursive'),
  nextToken?: string(name='NextToken'),
  maxResults?: int32(name='MaxResults'),
}

model GetParametersByPathResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  maxResults?: int32(name='MaxResults'),
  parameters?: [ 
    {
      type?: string(name='Type'),
      updatedDate?: string(name='UpdatedDate'),
      updatedBy?: string(name='UpdatedBy'),
      value?: string(name='Value'),
      description?: string(name='Description'),
      constraints?: string(name='Constraints'),
      createdBy?: string(name='CreatedBy'),
      createdDate?: string(name='CreatedDate'),
      parameterVersion?: int32(name='ParameterVersion'),
      name?: string(name='Name'),
      id?: string(name='Id'),
      shareType?: string(name='ShareType'),
    }
  ](name='Parameters'),
}

model GetParametersByPathResponse = {
  headers: map[string]string(name='headers'),
  body: GetParametersByPathResponseBody(name='body'),
}

async function getParametersByPathWithOptions(request: GetParametersByPathRequest, runtime: Util.RuntimeOptions): GetParametersByPathResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetParametersByPath', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getParametersByPath(request: GetParametersByPathRequest): GetParametersByPathResponse {
  var runtime = new Util.RuntimeOptions{};
  return getParametersByPathWithOptions(request, runtime);
}

model GetPatchBaselineRequest {
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
}

model GetPatchBaselineResponseBody = {
  requestId?: string(name='RequestId'),
  patchBaseline?: {
    operationSystem?: string(name='OperationSystem'),
    isDefault?: boolean(name='IsDefault'),
    description?: string(name='Description'),
    updatedDate?: string(name='UpdatedDate'),
    updatedBy?: string(name='UpdatedBy'),
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    name?: string(name='Name'),
    approvalRules?: string(name='ApprovalRules'),
    id?: string(name='Id'),
    shareType?: string(name='ShareType'),
  }(name='PatchBaseline'),
}

model GetPatchBaselineResponse = {
  headers: map[string]string(name='headers'),
  body: GetPatchBaselineResponseBody(name='body'),
}

async function getPatchBaselineWithOptions(request: GetPatchBaselineRequest, runtime: Util.RuntimeOptions): GetPatchBaselineResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetPatchBaseline', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getPatchBaseline(request: GetPatchBaselineRequest): GetPatchBaselineResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPatchBaselineWithOptions(request, runtime);
}

model GetSecretParameterRequest {
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
  parameterVersion?: int32(name='ParameterVersion'),
  withDecryption?: boolean(name='WithDecryption'),
}

model GetSecretParameterResponseBody = {
  requestId?: string(name='RequestId'),
  parameter?: {
    type?: string(name='Type'),
    updatedDate?: string(name='UpdatedDate'),
    updatedBy?: string(name='UpdatedBy'),
    keyId?: string(name='KeyId'),
    tags?: map[string]any(name='Tags'),
    value?: string(name='Value'),
    description?: string(name='Description'),
    constraints?: string(name='Constraints'),
    resourceGroupId?: string(name='ResourceGroupId'),
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    parameterVersion?: int32(name='ParameterVersion'),
    name?: string(name='Name'),
    id?: string(name='Id'),
    shareType?: string(name='ShareType'),
  }(name='Parameter'),
}

model GetSecretParameterResponse = {
  headers: map[string]string(name='headers'),
  body: GetSecretParameterResponseBody(name='body'),
}

async function getSecretParameterWithOptions(request: GetSecretParameterRequest, runtime: Util.RuntimeOptions): GetSecretParameterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetSecretParameter', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getSecretParameter(request: GetSecretParameterRequest): GetSecretParameterResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSecretParameterWithOptions(request, runtime);
}

model GetSecretParametersRequest {
  regionId?: string(name='RegionId'),
  names?: string(name='Names'),
  withDecryption?: boolean(name='WithDecryption'),
}

model GetSecretParametersResponseBody = {
  requestId?: string(name='RequestId'),
  invalidParameters?: [ string ](name='InvalidParameters'),
  parameters?: [ 
    {
      type?: string(name='Type'),
      updatedDate?: string(name='UpdatedDate'),
      updatedBy?: string(name='UpdatedBy'),
      keyId?: string(name='KeyId'),
      tags?: map[string]any(name='Tags'),
      value?: string(name='Value'),
      description?: string(name='Description'),
      constraints?: string(name='Constraints'),
      resourceGroupId?: string(name='ResourceGroupId'),
      createdBy?: string(name='CreatedBy'),
      createdDate?: string(name='CreatedDate'),
      parameterVersion?: int32(name='ParameterVersion'),
      name?: string(name='Name'),
      id?: string(name='Id'),
      shareType?: string(name='ShareType'),
    }
  ](name='Parameters'),
}

model GetSecretParametersResponse = {
  headers: map[string]string(name='headers'),
  body: GetSecretParametersResponseBody(name='body'),
}

async function getSecretParametersWithOptions(request: GetSecretParametersRequest, runtime: Util.RuntimeOptions): GetSecretParametersResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetSecretParameters', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getSecretParameters(request: GetSecretParametersRequest): GetSecretParametersResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSecretParametersWithOptions(request, runtime);
}

model GetSecretParametersByPathRequest {
  regionId?: string(name='RegionId'),
  path?: string(name='Path'),
  recursive?: boolean(name='Recursive'),
  nextToken?: string(name='NextToken'),
  maxResults?: int32(name='MaxResults'),
  withDecryption?: boolean(name='WithDecryption'),
}

model GetSecretParametersByPathResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  maxResults?: int32(name='MaxResults'),
  parameters?: [ 
    {
      type?: string(name='Type'),
      updatedDate?: string(name='UpdatedDate'),
      updatedBy?: string(name='UpdatedBy'),
      keyId?: string(name='KeyId'),
      value?: string(name='Value'),
      description?: string(name='Description'),
      constraints?: string(name='Constraints'),
      createdBy?: string(name='CreatedBy'),
      createdDate?: string(name='CreatedDate'),
      parameterVersion?: int32(name='ParameterVersion'),
      name?: string(name='Name'),
      id?: string(name='Id'),
      shareType?: string(name='ShareType'),
    }
  ](name='Parameters'),
}

model GetSecretParametersByPathResponse = {
  headers: map[string]string(name='headers'),
  body: GetSecretParametersByPathResponseBody(name='body'),
}

async function getSecretParametersByPathWithOptions(request: GetSecretParametersByPathRequest, runtime: Util.RuntimeOptions): GetSecretParametersByPathResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetSecretParametersByPath', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getSecretParametersByPath(request: GetSecretParametersByPathRequest): GetSecretParametersByPathResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSecretParametersByPathWithOptions(request, runtime);
}

model GetServiceSettingsRequest {
  regionId?: string(name='RegionId'),
}

model GetServiceSettingsResponseBody = {
  requestId?: string(name='RequestId'),
  serviceSettings?: [ 
    {
      deliveryOssBucketName?: string(name='DeliveryOssBucketName'),
      deliveryOssKeyPrefix?: string(name='DeliveryOssKeyPrefix'),
      deliveryOssEnabled?: boolean(name='DeliveryOssEnabled'),
      deliverySlsEnabled?: boolean(name='DeliverySlsEnabled'),
      deliverySlsProjectName?: string(name='DeliverySlsProjectName'),
      rdcEnterpriseId?: string(name='RdcEnterpriseId'),
    }
  ](name='ServiceSettings'),
}

model GetServiceSettingsResponse = {
  headers: map[string]string(name='headers'),
  body: GetServiceSettingsResponseBody(name='body'),
}

async function getServiceSettingsWithOptions(request: GetServiceSettingsRequest, runtime: Util.RuntimeOptions): GetServiceSettingsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetServiceSettings', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getServiceSettings(request: GetServiceSettingsRequest): GetServiceSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getServiceSettingsWithOptions(request, runtime);
}

model GetTemplateRequest {
  regionId?: string(name='RegionId'),
  templateName?: string(name='TemplateName'),
  templateVersion?: string(name='TemplateVersion'),
}

model GetTemplateResponseBody = {
  content?: string(name='Content'),
  requestId?: string(name='RequestId'),
  template?: {
    hash?: string(name='Hash'),
    updatedDate?: string(name='UpdatedDate'),
    updatedBy?: string(name='UpdatedBy'),
    templateType?: string(name='TemplateType'),
    tags?: map[string]any(name='Tags'),
    templateName?: string(name='TemplateName'),
    templateVersion?: string(name='TemplateVersion'),
    templateFormat?: string(name='TemplateFormat'),
    description?: string(name='Description'),
    resourceGroupId?: string(name='ResourceGroupId'),
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    versionName?: string(name='VersionName'),
    templateId?: string(name='TemplateId'),
    hasTrigger?: boolean(name='HasTrigger'),
    shareType?: string(name='ShareType'),
  }(name='Template'),
}

model GetTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: GetTemplateResponseBody(name='body'),
}

async function getTemplateWithOptions(request: GetTemplateRequest, runtime: Util.RuntimeOptions): GetTemplateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetTemplate', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getTemplate(request: GetTemplateRequest): GetTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTemplateWithOptions(request, runtime);
}

model ListActionsRequest {
  regionId?: string(name='RegionId'),
  OOSActionName?: string(name='OOSActionName'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
}

model ListActionsResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  maxResults?: int32(name='MaxResults'),
  actions?: [ 
    {
      popularity?: int32(name='Popularity'),
      actionType?: string(name='ActionType'),
      description?: string(name='Description'),
      createdDate?: string(name='CreatedDate'),
      templateVersion?: string(name='TemplateVersion'),
      OOSActionName?: string(name='OOSActionName'),
      properties?: string(name='Properties'),
    }
  ](name='Actions'),
}

model ListActionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListActionsResponseBody(name='body'),
}

async function listActionsWithOptions(request: ListActionsRequest, runtime: Util.RuntimeOptions): ListActionsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListActions', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listActions(request: ListActionsRequest): ListActionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listActionsWithOptions(request, runtime);
}

model ListApplicationGroupsRequest {
  regionId?: string(name='RegionId'),
  applicationName?: string(name='ApplicationName'),
  deployRegionId?: boolean(name='DeployRegionId'),
  environment?: boolean(name='Environment'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
}

model ListApplicationGroupsResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  maxResults?: int32(name='MaxResults'),
  applicationGroups?: [ 
    {
      deployRegionId?: string(name='DeployRegionId'),
      description?: string(name='Description'),
      updatedDate?: string(name='UpdatedDate'),
      createdDate?: string(name='CreatedDate'),
      applicationName?: string(name='ApplicationName'),
      name?: string(name='Name'),
      environment?: string(name='Environment'),
      createType?: string(name='CreateType'),
      scalingGroupId?: string(name='ScalingGroupId'),
      importClusterId?: string(name='ImportClusterId'),
    }
  ](name='ApplicationGroups'),
}

model ListApplicationGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: ListApplicationGroupsResponseBody(name='body'),
}

async function listApplicationGroupsWithOptions(request: ListApplicationGroupsRequest, runtime: Util.RuntimeOptions): ListApplicationGroupsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListApplicationGroups', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listApplicationGroups(request: ListApplicationGroupsRequest): ListApplicationGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listApplicationGroupsWithOptions(request, runtime);
}

model ListApplicationsRequest {
  regionId?: string(name='RegionId'),
  isSystem?: boolean(name='IsSystem'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
}

model ListApplicationsResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  maxResults?: int32(name='MaxResults'),
  applications?: [ 
    {
      type?: string(name='Type'),
      isSystem?: boolean(name='IsSystem'),
      description?: string(name='Description'),
      updateDate?: string(name='UpdateDate'),
      resourceGroupId?: string(name='ResourceGroupId'),
      createdDate?: string(name='CreatedDate'),
      name?: string(name='Name'),
      cloudMonitorRule?: {
        enableSubscribeEvent?: boolean(name='EnableSubscribeEvent'),
        enableInstallAgent?: boolean(name='EnableInstallAgent'),
        enabled?: boolean(name='Enabled'),
        contactGroupList?: [ string ](name='ContactGroupList'),
        templateIdList?: [ int32 ](name='TemplateIdList'),
      }(name='CloudMonitorRule'),
    }
  ](name='Applications'),
}

model ListApplicationsResponse = {
  headers: map[string]string(name='headers'),
  body: ListApplicationsResponseBody(name='body'),
}

async function listApplicationsWithOptions(request: ListApplicationsRequest, runtime: Util.RuntimeOptions): ListApplicationsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListApplications', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listApplications(request: ListApplicationsRequest): ListApplicationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listApplicationsWithOptions(request, runtime);
}

model ListExecutionLogsRequest {
  regionId?: string(name='RegionId'),
  executionId?: string(name='ExecutionId'),
  taskExecutionId?: string(name='TaskExecutionId'),
  logType?: string(name='LogType'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
}

model ListExecutionLogsResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  isTruncated?: boolean(name='IsTruncated'),
  maxResults?: int32(name='MaxResults'),
  executionLogs?: [ 
    {
      taskExecutionId?: string(name='TaskExecutionId'),
      message?: string(name='Message'),
      logType?: string(name='LogType'),
      timestamp?: string(name='Timestamp'),
    }
  ](name='ExecutionLogs'),
}

model ListExecutionLogsResponse = {
  headers: map[string]string(name='headers'),
  body: ListExecutionLogsResponseBody(name='body'),
}

async function listExecutionLogsWithOptions(request: ListExecutionLogsRequest, runtime: Util.RuntimeOptions): ListExecutionLogsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListExecutionLogs', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listExecutionLogs(request: ListExecutionLogsRequest): ListExecutionLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listExecutionLogsWithOptions(request, runtime);
}

model ListExecutionRiskyTasksRequest {
  regionId?: string(name='RegionId'),
  templateName?: string(name='TemplateName'),
}

model ListExecutionRiskyTasksResponseBody = {
  requestId?: string(name='RequestId'),
  riskyTasks?: [ 
    {
      service?: string(name='Service'),
      API?: string(name='API'),
      task?: [ string ](name='Task'),
      template?: [ string ](name='Template'),
    }
  ](name='RiskyTasks'),
}

model ListExecutionRiskyTasksResponse = {
  headers: map[string]string(name='headers'),
  body: ListExecutionRiskyTasksResponseBody(name='body'),
}

async function listExecutionRiskyTasksWithOptions(request: ListExecutionRiskyTasksRequest, runtime: Util.RuntimeOptions): ListExecutionRiskyTasksResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListExecutionRiskyTasks', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listExecutionRiskyTasks(request: ListExecutionRiskyTasksRequest): ListExecutionRiskyTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return listExecutionRiskyTasksWithOptions(request, runtime);
}

model ListExecutionsRequest {
  regionId?: string(name='RegionId'),
  templateName?: string(name='TemplateName'),
  status?: string(name='Status'),
  executionId?: string(name='ExecutionId'),
  startDateBefore?: string(name='StartDateBefore'),
  startDateAfter?: string(name='StartDateAfter'),
  endDateBefore?: string(name='EndDateBefore'),
  endDateAfter?: string(name='EndDateAfter'),
  mode?: string(name='Mode'),
  executedBy?: string(name='ExecutedBy'),
  parentExecutionId?: string(name='ParentExecutionId'),
  ramRole?: string(name='RamRole'),
  includeChildExecution?: boolean(name='IncludeChildExecution'),
  category?: string(name='Category'),
  tags?: map[string]any(name='Tags'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  sortField?: string(name='SortField'),
  sortOrder?: string(name='SortOrder'),
  resourceId?: string(name='ResourceId'),
  resourceTemplateName?: string(name='ResourceTemplateName'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model ListExecutionsShrinkRequest {
  regionId?: string(name='RegionId'),
  templateName?: string(name='TemplateName'),
  status?: string(name='Status'),
  executionId?: string(name='ExecutionId'),
  startDateBefore?: string(name='StartDateBefore'),
  startDateAfter?: string(name='StartDateAfter'),
  endDateBefore?: string(name='EndDateBefore'),
  endDateAfter?: string(name='EndDateAfter'),
  mode?: string(name='Mode'),
  executedBy?: string(name='ExecutedBy'),
  parentExecutionId?: string(name='ParentExecutionId'),
  ramRole?: string(name='RamRole'),
  includeChildExecution?: boolean(name='IncludeChildExecution'),
  category?: string(name='Category'),
  tagsShrink?: string(name='Tags'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  sortField?: string(name='SortField'),
  sortOrder?: string(name='SortOrder'),
  resourceId?: string(name='ResourceId'),
  resourceTemplateName?: string(name='ResourceTemplateName'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model ListExecutionsResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  maxResults?: int32(name='MaxResults'),
  executions?: [ 
    {
      status?: string(name='Status'),
      waitingStatus?: string(name='WaitingStatus'),
      targets?: string(name='Targets'),
      statusReason?: string(name='StatusReason'),
      tags?: map[string]any(name='Tags'),
      lastSuccessfulTriggerTime?: string(name='LastSuccessfulTriggerTime'),
      mode?: string(name='Mode'),
      safetyCheck?: string(name='SafetyCheck'),
      templateName?: string(name='TemplateName'),
      templateVersion?: string(name='TemplateVersion'),
      createDate?: string(name='CreateDate'),
      updateDate?: string(name='UpdateDate'),
      description?: string(name='Description'),
      lastTriggerTime?: string(name='LastTriggerTime'),
      parentExecutionId?: string(name='ParentExecutionId'),
      lastTriggerStatus?: string(name='LastTriggerStatus'),
      statusMessage?: string(name='StatusMessage'),
      outputs?: string(name='Outputs'),
      executedBy?: string(name='ExecutedBy'),
      endDate?: string(name='EndDate'),
      isParent?: boolean(name='IsParent'),
      startDate?: string(name='StartDate'),
      executionId?: string(name='ExecutionId'),
      parameters?: map[string]any(name='Parameters'),
      counters?: map[string]any(name='Counters'),
      resourceGroupId?: string(name='ResourceGroupId'),
      category?: string(name='Category'),
      templateId?: string(name='TemplateId'),
      ramRole?: string(name='RamRole'),
      resourceStatus?: string(name='ResourceStatus'),
      currentTasks?: [ 
        {
          taskExecutionId?: string(name='TaskExecutionId'),
          taskName?: string(name='TaskName'),
          taskAction?: string(name='TaskAction'),
        }
      ](name='CurrentTasks'),
    }
  ](name='Executions'),
}

model ListExecutionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListExecutionsResponseBody(name='body'),
}

async function listExecutionsWithOptions(tmpReq: ListExecutionsRequest, runtime: Util.RuntimeOptions): ListExecutionsResponse {
  Util.validateModel(tmpReq);
  var request = new ListExecutionsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListExecutions', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listExecutions(request: ListExecutionsRequest): ListExecutionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listExecutionsWithOptions(request, runtime);
}

model ListInstancePatchesRequest {
  regionId?: string(name='RegionId'),
  instanceId?: string(name='InstanceId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  patchStatuses?: string(name='PatchStatuses'),
}

model ListInstancePatchesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  maxResults?: int32(name='MaxResults'),
  patches?: [ 
    {
      severity?: string(name='Severity'),
      status?: string(name='Status'),
      installedTime?: string(name='InstalledTime'),
      KBId?: string(name='KBId'),
      title?: string(name='Title'),
      classification?: string(name='Classification'),
    }
  ](name='Patches'),
}

model ListInstancePatchesResponse = {
  headers: map[string]string(name='headers'),
  body: ListInstancePatchesResponseBody(name='body'),
}

async function listInstancePatchesWithOptions(request: ListInstancePatchesRequest, runtime: Util.RuntimeOptions): ListInstancePatchesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListInstancePatches', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listInstancePatches(request: ListInstancePatchesRequest): ListInstancePatchesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInstancePatchesWithOptions(request, runtime);
}

model ListInstancePatchStatesRequest {
  regionId?: string(name='RegionId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  instanceIds?: string(name='InstanceIds'),
}

model ListInstancePatchStatesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  maxResults?: int32(name='MaxResults'),
  instancePatchStates?: [ 
    {
      missingCount?: string(name='MissingCount'),
      operationEndTime?: string(name='OperationEndTime'),
      ownerInformation?: string(name='OwnerInformation'),
      installedOtherCount?: string(name='InstalledOtherCount'),
      instanceId?: string(name='InstanceId'),
      operationType?: string(name='OperationType'),
      operationStartTime?: string(name='OperationStartTime'),
      failedCount?: string(name='FailedCount'),
      baselineId?: string(name='BaselineId'),
      installedPendingRebootCount?: string(name='InstalledPendingRebootCount'),
      installedRejectedCount?: string(name='InstalledRejectedCount'),
      patchGroup?: string(name='PatchGroup'),
      installedCount?: string(name='InstalledCount'),
    }
  ](name='InstancePatchStates'),
}

model ListInstancePatchStatesResponse = {
  headers: map[string]string(name='headers'),
  body: ListInstancePatchStatesResponseBody(name='body'),
}

async function listInstancePatchStatesWithOptions(request: ListInstancePatchStatesRequest, runtime: Util.RuntimeOptions): ListInstancePatchStatesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListInstancePatchStates', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listInstancePatchStates(request: ListInstancePatchStatesRequest): ListInstancePatchStatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInstancePatchStatesWithOptions(request, runtime);
}

model ListInstanceStateReportsRequest {
  regionId?: string(name='RegionId'),
  instanceId?: string(name='InstanceId'),
  stateConfigurationId?: string(name='StateConfigurationId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
}

model ListInstanceStateReportsResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  maxResults?: int32(name='MaxResults'),
  stateReports?: [ 
    {
      reportStatus?: string(name='ReportStatus'),
      reportInfo?: string(name='ReportInfo'),
      successApplyTime?: string(name='SuccessApplyTime'),
      stateConfigurationId?: string(name='StateConfigurationId'),
      instanceId?: string(name='InstanceId'),
      mode?: string(name='Mode'),
      reportTime?: string(name='ReportTime'),
    }
  ](name='StateReports'),
}

model ListInstanceStateReportsResponse = {
  headers: map[string]string(name='headers'),
  body: ListInstanceStateReportsResponseBody(name='body'),
}

async function listInstanceStateReportsWithOptions(request: ListInstanceStateReportsRequest, runtime: Util.RuntimeOptions): ListInstanceStateReportsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListInstanceStateReports', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listInstanceStateReports(request: ListInstanceStateReportsRequest): ListInstanceStateReportsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInstanceStateReportsWithOptions(request, runtime);
}

model ListInventoryEntriesRequest {
  instanceId?: string(name='InstanceId'),
  typeName?: string(name='TypeName'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  filter?: [ 
    {
      value?: [ string ](name='Value'),
      operator?: string(name='Operator'),
      name?: string(name='Name'),
    }
  ](name='Filter'),
}

model ListInventoryEntriesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  schemaVersion?: string(name='SchemaVersion'),
  maxResults?: int32(name='MaxResults'),
  captureTime?: string(name='CaptureTime'),
  typeName?: string(name='TypeName'),
  instanceId?: string(name='InstanceId'),
  entries?: [  map[string]any ](name='Entries'),
}

model ListInventoryEntriesResponse = {
  headers: map[string]string(name='headers'),
  body: ListInventoryEntriesResponseBody(name='body'),
}

async function listInventoryEntriesWithOptions(request: ListInventoryEntriesRequest, runtime: Util.RuntimeOptions): ListInventoryEntriesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListInventoryEntries', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listInventoryEntries(request: ListInventoryEntriesRequest): ListInventoryEntriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInventoryEntriesWithOptions(request, runtime);
}

model ListParametersRequest {
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  sortField?: string(name='SortField'),
  sortOrder?: string(name='SortOrder'),
  type?: string(name='Type'),
  path?: string(name='Path'),
  recursive?: boolean(name='Recursive'),
  tags?: map[string]any(name='Tags'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model ListParametersShrinkRequest {
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  sortField?: string(name='SortField'),
  sortOrder?: string(name='SortOrder'),
  type?: string(name='Type'),
  path?: string(name='Path'),
  recursive?: boolean(name='Recursive'),
  tagsShrink?: string(name='Tags'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model ListParametersResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  maxResults?: int32(name='MaxResults'),
  parameters?: [ 
    {
      type?: string(name='Type'),
      updatedDate?: string(name='UpdatedDate'),
      updatedBy?: string(name='UpdatedBy'),
      tags?: map[string]any(name='Tags'),
      description?: string(name='Description'),
      createdBy?: string(name='CreatedBy'),
      resourceGroupId?: string(name='ResourceGroupId'),
      createdDate?: string(name='CreatedDate'),
      parameterVersion?: string(name='ParameterVersion'),
      name?: string(name='Name'),
      id?: string(name='Id'),
      shareType?: string(name='ShareType'),
    }
  ](name='Parameters'),
}

model ListParametersResponse = {
  headers: map[string]string(name='headers'),
  body: ListParametersResponseBody(name='body'),
}

async function listParametersWithOptions(tmpReq: ListParametersRequest, runtime: Util.RuntimeOptions): ListParametersResponse {
  Util.validateModel(tmpReq);
  var request = new ListParametersShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListParameters', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listParameters(request: ListParametersRequest): ListParametersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listParametersWithOptions(request, runtime);
}

model ListParameterVersionsRequest {
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  shareType?: string(name='ShareType'),
}

model ListParameterVersionsResponseBody = {
  type?: string(name='Type'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  description?: string(name='Description'),
  maxResults?: int32(name='MaxResults'),
  createdBy?: string(name='CreatedBy'),
  createdDate?: string(name='CreatedDate'),
  name?: string(name='Name'),
  totalCount?: int32(name='TotalCount'),
  id?: string(name='Id'),
  parameterVersions?: [ 
    {
      parameterVersion?: int32(name='ParameterVersion'),
      value?: string(name='Value'),
      updatedDate?: string(name='UpdatedDate'),
      updatedBy?: string(name='UpdatedBy'),
    }
  ](name='ParameterVersions'),
}

model ListParameterVersionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListParameterVersionsResponseBody(name='body'),
}

async function listParameterVersionsWithOptions(request: ListParameterVersionsRequest, runtime: Util.RuntimeOptions): ListParameterVersionsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListParameterVersions', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listParameterVersions(request: ListParameterVersionsRequest): ListParameterVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listParameterVersionsWithOptions(request, runtime);
}

model ListPatchBaselinesRequest {
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
  operationSystem?: string(name='OperationSystem'),
  shareType?: string(name='ShareType'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
}

model ListPatchBaselinesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  maxResults?: int32(name='MaxResults'),
  patchBaselines?: [ 
    {
      operationSystem?: string(name='OperationSystem'),
      isDefault?: boolean(name='IsDefault'),
      description?: string(name='Description'),
      updatedDate?: string(name='UpdatedDate'),
      updatedBy?: string(name='UpdatedBy'),
      createdBy?: string(name='CreatedBy'),
      createdDate?: string(name='CreatedDate'),
      name?: string(name='Name'),
      id?: string(name='Id'),
      shareType?: string(name='ShareType'),
    }
  ](name='PatchBaselines'),
}

model ListPatchBaselinesResponse = {
  headers: map[string]string(name='headers'),
  body: ListPatchBaselinesResponseBody(name='body'),
}

async function listPatchBaselinesWithOptions(request: ListPatchBaselinesRequest, runtime: Util.RuntimeOptions): ListPatchBaselinesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListPatchBaselines', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listPatchBaselines(request: ListPatchBaselinesRequest): ListPatchBaselinesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPatchBaselinesWithOptions(request, runtime);
}

model ListResourceExecutionStatusRequest {
  regionId?: string(name='RegionId'),
  executionId?: string(name='ExecutionId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
}

model ListResourceExecutionStatusResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  maxResults?: int32(name='MaxResults'),
  resourceExecutionStatus?: [ 
    {
      outputs?: string(name='Outputs'),
      status?: string(name='Status'),
      executionTime?: string(name='ExecutionTime'),
      resourceId?: string(name='ResourceId'),
      executionId?: string(name='ExecutionId'),
    }
  ](name='ResourceExecutionStatus'),
}

model ListResourceExecutionStatusResponse = {
  headers: map[string]string(name='headers'),
  body: ListResourceExecutionStatusResponseBody(name='body'),
}

async function listResourceExecutionStatusWithOptions(request: ListResourceExecutionStatusRequest, runtime: Util.RuntimeOptions): ListResourceExecutionStatusResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListResourceExecutionStatus', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listResourceExecutionStatus(request: ListResourceExecutionStatusRequest): ListResourceExecutionStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return listResourceExecutionStatusWithOptions(request, runtime);
}

model ListSecretParametersRequest {
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  sortField?: string(name='SortField'),
  sortOrder?: string(name='SortOrder'),
  path?: string(name='Path'),
  recursive?: boolean(name='Recursive'),
  tags?: map[string]any(name='Tags'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model ListSecretParametersShrinkRequest {
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  sortField?: string(name='SortField'),
  sortOrder?: string(name='SortOrder'),
  path?: string(name='Path'),
  recursive?: boolean(name='Recursive'),
  tagsShrink?: string(name='Tags'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model ListSecretParametersResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  maxResults?: int32(name='MaxResults'),
  parameters?: [ 
    {
      type?: string(name='Type'),
      updatedDate?: string(name='UpdatedDate'),
      updatedBy?: string(name='UpdatedBy'),
      keyId?: string(name='KeyId'),
      tags?: map[string]any(name='Tags'),
      description?: string(name='Description'),
      resourceGroupId?: string(name='ResourceGroupId'),
      createdBy?: string(name='CreatedBy'),
      createdDate?: string(name='CreatedDate'),
      parameterVersion?: string(name='ParameterVersion'),
      name?: string(name='Name'),
      id?: string(name='Id'),
      shareType?: string(name='ShareType'),
    }
  ](name='Parameters'),
}

model ListSecretParametersResponse = {
  headers: map[string]string(name='headers'),
  body: ListSecretParametersResponseBody(name='body'),
}

async function listSecretParametersWithOptions(tmpReq: ListSecretParametersRequest, runtime: Util.RuntimeOptions): ListSecretParametersResponse {
  Util.validateModel(tmpReq);
  var request = new ListSecretParametersShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListSecretParameters', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listSecretParameters(request: ListSecretParametersRequest): ListSecretParametersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSecretParametersWithOptions(request, runtime);
}

model ListSecretParameterVersionsRequest {
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  shareType?: string(name='ShareType'),
  withDecryption?: boolean(name='WithDecryption'),
}

model ListSecretParameterVersionsResponseBody = {
  type?: string(name='Type'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  description?: string(name='Description'),
  maxResults?: int32(name='MaxResults'),
  createdBy?: string(name='CreatedBy'),
  createdDate?: string(name='CreatedDate'),
  name?: string(name='Name'),
  totalCount?: int32(name='TotalCount'),
  id?: string(name='Id'),
  parameterVersions?: [ 
    {
      parameterVersion?: int32(name='ParameterVersion'),
      value?: string(name='Value'),
      updatedDate?: string(name='UpdatedDate'),
      updatedBy?: string(name='UpdatedBy'),
    }
  ](name='ParameterVersions'),
}

model ListSecretParameterVersionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListSecretParameterVersionsResponseBody(name='body'),
}

async function listSecretParameterVersionsWithOptions(request: ListSecretParameterVersionsRequest, runtime: Util.RuntimeOptions): ListSecretParameterVersionsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListSecretParameterVersions', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listSecretParameterVersions(request: ListSecretParameterVersionsRequest): ListSecretParameterVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSecretParameterVersionsWithOptions(request, runtime);
}

model ListStateConfigurationsRequest {
  regionId?: string(name='RegionId'),
  templateName?: string(name='TemplateName'),
  templateVersion?: string(name='TemplateVersion'),
  stateConfigurationIds?: string(name='StateConfigurationIds'),
  tags?: map[string]any(name='Tags'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model ListStateConfigurationsShrinkRequest {
  regionId?: string(name='RegionId'),
  templateName?: string(name='TemplateName'),
  templateVersion?: string(name='TemplateVersion'),
  stateConfigurationIds?: string(name='StateConfigurationIds'),
  tagsShrink?: string(name='Tags'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model ListStateConfigurationsResponseBody = {
  requestId?: string(name='RequestId'),
  stateConfigurations?: [ 
    {
      updateTime?: string(name='UpdateTime'),
      createTime?: string(name='CreateTime'),
      targets?: string(name='Targets'),
      tags?: map[string]any(name='Tags'),
      stateConfigurationId?: string(name='StateConfigurationId'),
      scheduleExpression?: string(name='ScheduleExpression'),
      templateName?: string(name='TemplateName'),
      templateVersion?: string(name='TemplateVersion'),
      configureMode?: string(name='ConfigureMode'),
      scheduleType?: string(name='ScheduleType'),
      parameters?: string(name='Parameters'),
      description?: string(name='Description'),
      resourceGroupId?: string(name='ResourceGroupId'),
      templateId?: string(name='TemplateId'),
    }
  ](name='StateConfigurations'),
}

model ListStateConfigurationsResponse = {
  headers: map[string]string(name='headers'),
  body: ListStateConfigurationsResponseBody(name='body'),
}

async function listStateConfigurationsWithOptions(tmpReq: ListStateConfigurationsRequest, runtime: Util.RuntimeOptions): ListStateConfigurationsResponse {
  Util.validateModel(tmpReq);
  var request = new ListStateConfigurationsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListStateConfigurations', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listStateConfigurations(request: ListStateConfigurationsRequest): ListStateConfigurationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listStateConfigurationsWithOptions(request, runtime);
}

model ListTagKeysRequest {
  regionId?: string(name='RegionId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  resourceType?: string(name='ResourceType'),
}

model ListTagKeysResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  maxResults?: int32(name='MaxResults'),
  keys?: [ string ](name='Keys'),
}

model ListTagKeysResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagKeysResponseBody(name='body'),
}

async function listTagKeysWithOptions(request: ListTagKeysRequest, runtime: Util.RuntimeOptions): ListTagKeysResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListTagKeys', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listTagKeys(request: ListTagKeysRequest): ListTagKeysResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagKeysWithOptions(request, runtime);
}

model ListTagResourcesRequest {
  regionId?: string(name='RegionId'),
  resourceIds?: map[string]any(name='ResourceIds'),
  resourceType?: string(name='ResourceType'),
  tags?: map[string]any(name='Tags'),
  nextToken?: string(name='NextToken'),
}

model ListTagResourcesShrinkRequest {
  regionId?: string(name='RegionId'),
  resourceIdsShrink?: string(name='ResourceIds'),
  resourceType?: string(name='ResourceType'),
  tagsShrink?: string(name='Tags'),
  nextToken?: string(name='NextToken'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  tagResources?: {
    tagResource?: [ 
    {
      resourceType?: string(name='ResourceType'),
      tagValue?: string(name='TagValue'),
      resourceId?: string(name='ResourceId'),
      tagKey?: string(name='TagKey'),
    }
  ](name='TagResource')
  }(name='TagResources'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResourcesWithOptions(tmpReq: ListTagResourcesRequest, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(tmpReq);
  var request = new ListTagResourcesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.resourceIds)) {
    request.resourceIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.resourceIds, 'ResourceIds', 'json');
  }
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListTagResources', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagResourcesWithOptions(request, runtime);
}

model ListTagValuesRequest {
  regionId?: string(name='RegionId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  resourceType?: string(name='ResourceType'),
  key?: string(name='Key'),
}

model ListTagValuesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  maxResults?: int32(name='MaxResults'),
  values?: [ string ](name='Values'),
}

model ListTagValuesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagValuesResponseBody(name='body'),
}

async function listTagValuesWithOptions(request: ListTagValuesRequest, runtime: Util.RuntimeOptions): ListTagValuesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListTagValues', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listTagValues(request: ListTagValuesRequest): ListTagValuesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagValuesWithOptions(request, runtime);
}

model ListTaskExecutionsRequest {
  regionId?: string(name='RegionId'),
  executionId?: string(name='ExecutionId'),
  status?: string(name='Status'),
  startDateBefore?: string(name='StartDateBefore'),
  startDateAfter?: string(name='StartDateAfter'),
  endDateBefore?: string(name='EndDateBefore'),
  endDateAfter?: string(name='EndDateAfter'),
  taskExecutionId?: string(name='TaskExecutionId'),
  taskName?: string(name='TaskName'),
  taskAction?: string(name='TaskAction'),
  parentTaskExecutionId?: string(name='ParentTaskExecutionId'),
  includeChildTaskExecution?: boolean(name='IncludeChildTaskExecution'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  sortField?: string(name='SortField'),
  sortOrder?: string(name='SortOrder'),
}

model ListTaskExecutionsResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  maxResults?: int32(name='MaxResults'),
  taskExecutions?: [ 
    {
      childExecutionId?: string(name='ChildExecutionId'),
      outputs?: string(name='Outputs'),
      status?: string(name='Status'),
      endDate?: string(name='EndDate'),
      parentTaskExecutionId?: string(name='ParentTaskExecutionId'),
      taskName?: string(name='TaskName'),
      startDate?: string(name='StartDate'),
      loopItem?: string(name='LoopItem'),
      createDate?: string(name='CreateDate'),
      executionId?: string(name='ExecutionId'),
      taskAction?: string(name='TaskAction'),
      taskExecutionId?: string(name='TaskExecutionId'),
      updateDate?: string(name='UpdateDate'),
      loop?: map[string]any(name='Loop'),
      templateId?: string(name='TemplateId'),
      loopBatchNumber?: int32(name='LoopBatchNumber'),
      statusMessage?: string(name='StatusMessage'),
      extraData?: map[string]any(name='ExtraData'),
      properties?: string(name='Properties'),
    }
  ](name='TaskExecutions'),
}

model ListTaskExecutionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListTaskExecutionsResponseBody(name='body'),
}

async function listTaskExecutionsWithOptions(request: ListTaskExecutionsRequest, runtime: Util.RuntimeOptions): ListTaskExecutionsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListTaskExecutions', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listTaskExecutions(request: ListTaskExecutionsRequest): ListTaskExecutionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTaskExecutionsWithOptions(request, runtime);
}

model ListTemplatesRequest {
  regionId?: string(name='RegionId'),
  templateName?: string(name='TemplateName'),
  templateFormat?: string(name='TemplateFormat'),
  shareType?: string(name='ShareType'),
  createdBy?: string(name='CreatedBy'),
  createdDateBefore?: string(name='CreatedDateBefore'),
  createdDateAfter?: string(name='CreatedDateAfter'),
  tags?: map[string]any(name='Tags'),
  category?: string(name='Category'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  sortField?: string(name='SortField'),
  sortOrder?: string(name='SortOrder'),
  hasTrigger?: boolean(name='HasTrigger'),
  templateType?: string(name='TemplateType'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model ListTemplatesShrinkRequest {
  regionId?: string(name='RegionId'),
  templateName?: string(name='TemplateName'),
  templateFormat?: string(name='TemplateFormat'),
  shareType?: string(name='ShareType'),
  createdBy?: string(name='CreatedBy'),
  createdDateBefore?: string(name='CreatedDateBefore'),
  createdDateAfter?: string(name='CreatedDateAfter'),
  tagsShrink?: string(name='Tags'),
  category?: string(name='Category'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  sortField?: string(name='SortField'),
  sortOrder?: string(name='SortOrder'),
  hasTrigger?: boolean(name='HasTrigger'),
  templateType?: string(name='TemplateType'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model ListTemplatesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  maxResults?: int32(name='MaxResults'),
  templates?: [ 
    {
      hash?: string(name='Hash'),
      updatedDate?: string(name='UpdatedDate'),
      updatedBy?: string(name='UpdatedBy'),
      templateType?: string(name='TemplateType'),
      tags?: map[string]any(name='Tags'),
      templateName?: string(name='TemplateName'),
      templateVersion?: string(name='TemplateVersion'),
      templateFormat?: string(name='TemplateFormat'),
      popularity?: int32(name='Popularity'),
      totalExecutionCount?: int32(name='TotalExecutionCount'),
      description?: string(name='Description'),
      resourceGroupId?: string(name='ResourceGroupId'),
      createdBy?: string(name='CreatedBy'),
      createdDate?: string(name='CreatedDate'),
      category?: string(name='Category'),
      hasTrigger?: boolean(name='HasTrigger'),
      templateId?: string(name='TemplateId'),
      shareType?: string(name='ShareType'),
    }
  ](name='Templates'),
}

model ListTemplatesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTemplatesResponseBody(name='body'),
}

async function listTemplatesWithOptions(tmpReq: ListTemplatesRequest, runtime: Util.RuntimeOptions): ListTemplatesResponse {
  Util.validateModel(tmpReq);
  var request = new ListTemplatesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListTemplates', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listTemplates(request: ListTemplatesRequest): ListTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTemplatesWithOptions(request, runtime);
}

model ListTemplateVersionsRequest {
  regionId?: string(name='RegionId'),
  templateName?: string(name='TemplateName'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  shareType?: string(name='ShareType'),
}

model ListTemplateVersionsResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  maxResults?: int32(name='MaxResults'),
  templateVersions?: [ 
    {
      description?: string(name='Description'),
      updatedDate?: string(name='UpdatedDate'),
      updatedBy?: string(name='UpdatedBy'),
      versionName?: string(name='VersionName'),
      templateVersion?: string(name='TemplateVersion'),
      templateFormat?: string(name='TemplateFormat'),
    }
  ](name='TemplateVersions'),
}

model ListTemplateVersionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListTemplateVersionsResponseBody(name='body'),
}

async function listTemplateVersionsWithOptions(request: ListTemplateVersionsRequest, runtime: Util.RuntimeOptions): ListTemplateVersionsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListTemplateVersions', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listTemplateVersions(request: ListTemplateVersionsRequest): ListTemplateVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTemplateVersionsWithOptions(request, runtime);
}

model NotifyExecutionRequest {
  regionId?: string(name='RegionId'),
  executionId?: string(name='ExecutionId'),
  notifyType?: string(name='NotifyType'),
  notifyNote?: string(name='NotifyNote'),
  taskName?: string(name='TaskName'),
  taskExecutionId?: string(name='TaskExecutionId'),
  executionStatus?: string(name='ExecutionStatus'),
  parameters?: string(name='Parameters'),
  loopItem?: string(name='LoopItem'),
  taskExecutionIds?: string(name='TaskExecutionIds'),
}

model NotifyExecutionResponseBody = {
  requestId?: string(name='RequestId'),
}

model NotifyExecutionResponse = {
  headers: map[string]string(name='headers'),
  body: NotifyExecutionResponseBody(name='body'),
}

async function notifyExecutionWithOptions(request: NotifyExecutionRequest, runtime: Util.RuntimeOptions): NotifyExecutionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('NotifyExecution', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function notifyExecution(request: NotifyExecutionRequest): NotifyExecutionResponse {
  var runtime = new Util.RuntimeOptions{};
  return notifyExecutionWithOptions(request, runtime);
}

model RegisterDefaultPatchBaselineRequest {
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
}

model RegisterDefaultPatchBaselineResponseBody = {
  requestId?: string(name='RequestId'),
  patchBaseline?: {
    operationSystem?: string(name='OperationSystem'),
    description?: string(name='Description'),
    updatedDate?: string(name='UpdatedDate'),
    updatedBy?: string(name='UpdatedBy'),
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    name?: string(name='Name'),
    approvalRules?: string(name='ApprovalRules'),
    id?: string(name='Id'),
    shareType?: string(name='ShareType'),
  }(name='PatchBaseline'),
}

model RegisterDefaultPatchBaselineResponse = {
  headers: map[string]string(name='headers'),
  body: RegisterDefaultPatchBaselineResponseBody(name='body'),
}

async function registerDefaultPatchBaselineWithOptions(request: RegisterDefaultPatchBaselineRequest, runtime: Util.RuntimeOptions): RegisterDefaultPatchBaselineResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RegisterDefaultPatchBaseline', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function registerDefaultPatchBaseline(request: RegisterDefaultPatchBaselineRequest): RegisterDefaultPatchBaselineResponse {
  var runtime = new Util.RuntimeOptions{};
  return registerDefaultPatchBaselineWithOptions(request, runtime);
}

model SearchInventoryRequest {
  regionId?: string(name='RegionId'),
  nextToken?: string(name='NextToken'),
  maxResults?: int32(name='MaxResults'),
  filter?: [ 
    {
      value?: [ string ](name='Value'),
      operator?: string(name='Operator'),
      name?: string(name='Name'),
    }
  ](name='Filter'),
  aggregator?: [ string ](name='Aggregator'),
}

model SearchInventoryResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  maxResults?: int32(name='MaxResults'),
  entities?: [  map[string]any ](name='Entities'),
}

model SearchInventoryResponse = {
  headers: map[string]string(name='headers'),
  body: SearchInventoryResponseBody(name='body'),
}

async function searchInventoryWithOptions(request: SearchInventoryRequest, runtime: Util.RuntimeOptions): SearchInventoryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SearchInventory', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function searchInventory(request: SearchInventoryRequest): SearchInventoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchInventoryWithOptions(request, runtime);
}

model SetServiceSettingsRequest {
  deliveryOssEnabled?: boolean(name='DeliveryOssEnabled'),
  deliveryOssBucketName?: string(name='DeliveryOssBucketName'),
  deliveryOssKeyPrefix?: string(name='DeliveryOssKeyPrefix'),
  deliverySlsProjectName?: string(name='DeliverySlsProjectName'),
  deliverySlsEnabled?: boolean(name='DeliverySlsEnabled'),
  regionId?: string(name='RegionId'),
  rdcEnterpriseId?: string(name='RdcEnterpriseId'),
}

model SetServiceSettingsResponseBody = {
  requestId?: string(name='RequestId'),
  serviceSettings?: [ 
    {
      deliveryOssBucketName?: string(name='DeliveryOssBucketName'),
      deliveryOssKeyPrefix?: string(name='DeliveryOssKeyPrefix'),
      deliveryOssEnabled?: boolean(name='DeliveryOssEnabled'),
      deliverySlsEnabled?: boolean(name='DeliverySlsEnabled'),
      deliverySlsProjectName?: string(name='DeliverySlsProjectName'),
      rdcEnterpriseId?: string(name='RdcEnterpriseId'),
    }
  ](name='ServiceSettings'),
}

model SetServiceSettingsResponse = {
  headers: map[string]string(name='headers'),
  body: SetServiceSettingsResponseBody(name='body'),
}

async function setServiceSettingsWithOptions(request: SetServiceSettingsRequest, runtime: Util.RuntimeOptions): SetServiceSettingsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SetServiceSettings', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function setServiceSettings(request: SetServiceSettingsRequest): SetServiceSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  return setServiceSettingsWithOptions(request, runtime);
}

model StartExecutionRequest {
  regionId?: string(name='RegionId'),
  templateName?: string(name='TemplateName'),
  templateVersion?: string(name='TemplateVersion'),
  mode?: string(name='Mode'),
  loopMode?: string(name='LoopMode'),
  parentExecutionId?: string(name='ParentExecutionId'),
  safetyCheck?: string(name='SafetyCheck'),
  parameters?: string(name='Parameters'),
  clientToken?: string(name='ClientToken'),
  tags?: map[string]any(name='Tags'),
  description?: string(name='Description'),
  templateContent?: string(name='TemplateContent'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model StartExecutionShrinkRequest {
  regionId?: string(name='RegionId'),
  templateName?: string(name='TemplateName'),
  templateVersion?: string(name='TemplateVersion'),
  mode?: string(name='Mode'),
  loopMode?: string(name='LoopMode'),
  parentExecutionId?: string(name='ParentExecutionId'),
  safetyCheck?: string(name='SafetyCheck'),
  parameters?: string(name='Parameters'),
  clientToken?: string(name='ClientToken'),
  tagsShrink?: string(name='Tags'),
  description?: string(name='Description'),
  templateContent?: string(name='TemplateContent'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model StartExecutionResponseBody = {
  requestId?: string(name='RequestId'),
  execution?: {
    outputs?: string(name='Outputs'),
    status?: string(name='Status'),
    endDate?: string(name='EndDate'),
    executedBy?: string(name='ExecutedBy'),
    isParent?: boolean(name='IsParent'),
    tags?: map[string]any(name='Tags'),
    startDate?: string(name='StartDate'),
    safetyCheck?: string(name='SafetyCheck'),
    mode?: string(name='Mode'),
    templateName?: string(name='TemplateName'),
    createDate?: string(name='CreateDate'),
    templateVersion?: string(name='TemplateVersion'),
    executionId?: string(name='ExecutionId'),
    parameters?: string(name='Parameters'),
    description?: string(name='Description'),
    counters?: map[string]any(name='Counters'),
    updateDate?: string(name='UpdateDate'),
    resourceGroupId?: string(name='ResourceGroupId'),
    parentExecutionId?: string(name='ParentExecutionId'),
    ramRole?: string(name='RamRole'),
    templateId?: string(name='TemplateId'),
    statusMessage?: string(name='StatusMessage'),
    loopMode?: string(name='LoopMode'),
    currentTasks?: [ 
      {
        taskExecutionId?: string(name='TaskExecutionId'),
        taskName?: string(name='TaskName'),
        taskAction?: string(name='TaskAction'),
      }
    ](name='CurrentTasks'),
  }(name='Execution'),
}

model StartExecutionResponse = {
  headers: map[string]string(name='headers'),
  body: StartExecutionResponseBody(name='body'),
}

async function startExecutionWithOptions(tmpReq: StartExecutionRequest, runtime: Util.RuntimeOptions): StartExecutionResponse {
  Util.validateModel(tmpReq);
  var request = new StartExecutionShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('StartExecution', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function startExecution(request: StartExecutionRequest): StartExecutionResponse {
  var runtime = new Util.RuntimeOptions{};
  return startExecutionWithOptions(request, runtime);
}

model TagResourcesRequest {
  regionId?: string(name='RegionId'),
  resourceIds?: map[string]any(name='ResourceIds'),
  resourceType?: string(name='ResourceType'),
  tags?: map[string]any(name='Tags'),
}

model TagResourcesShrinkRequest {
  regionId?: string(name='RegionId'),
  resourceIdsShrink?: string(name='ResourceIds'),
  resourceType?: string(name='ResourceType'),
  tagsShrink?: string(name='Tags'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResourcesWithOptions(tmpReq: TagResourcesRequest, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(tmpReq);
  var request = new TagResourcesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.resourceIds)) {
    request.resourceIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.resourceIds, 'ResourceIds', 'json');
  }
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('TagResources', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagResourcesWithOptions(request, runtime);
}

model TriggerExecutionRequest {
  regionId?: string(name='RegionId'),
  executionId?: string(name='ExecutionId'),
  type?: string(name='Type'),
  content?: string(name='Content'),
  clientToken?: string(name='ClientToken'),
}

model TriggerExecutionResponseBody = {
  requestId?: string(name='RequestId'),
}

model TriggerExecutionResponse = {
  headers: map[string]string(name='headers'),
  body: TriggerExecutionResponseBody(name='body'),
}

async function triggerExecutionWithOptions(request: TriggerExecutionRequest, runtime: Util.RuntimeOptions): TriggerExecutionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('TriggerExecution', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function triggerExecution(request: TriggerExecutionRequest): TriggerExecutionResponse {
  var runtime = new Util.RuntimeOptions{};
  return triggerExecutionWithOptions(request, runtime);
}

model UntagResourcesRequest {
  regionId?: string(name='RegionId'),
  resourceIds?: map[string]any(name='ResourceIds'),
  resourceType?: string(name='ResourceType'),
  tagKeys?: map[string]any(name='TagKeys'),
  all?: boolean(name='All'),
}

model UntagResourcesShrinkRequest {
  regionId?: string(name='RegionId'),
  resourceIdsShrink?: string(name='ResourceIds'),
  resourceType?: string(name='ResourceType'),
  tagKeysShrink?: string(name='TagKeys'),
  all?: boolean(name='All'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResourcesWithOptions(tmpReq: UntagResourcesRequest, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(tmpReq);
  var request = new UntagResourcesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.resourceIds)) {
    request.resourceIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.resourceIds, 'ResourceIds', 'json');
  }
  if (!Util.isUnset(tmpReq.tagKeys)) {
    request.tagKeysShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tagKeys, 'TagKeys', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UntagResources', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return untagResourcesWithOptions(request, runtime);
}

model UpdateApplicationGroupRequest {
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
  scalingGroupId?: string(name='ScalingGroupId'),
}

model UpdateApplicationGroupResponseBody = {
  requestId?: string(name='RequestId'),
  applicationGroup?: {
    deployRegionId?: string(name='DeployRegionId'),
    description?: string(name='Description'),
    updatedDate?: string(name='UpdatedDate'),
    createdDate?: string(name='CreatedDate'),
    applicationName?: string(name='ApplicationName'),
    name?: string(name='Name'),
    environment?: string(name='Environment'),
    createType?: string(name='CreateType'),
    scalingGroupId?: string(name='ScalingGroupId'),
    importClusterId?: string(name='ImportClusterId'),
  }(name='ApplicationGroup'),
}

model UpdateApplicationGroupResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateApplicationGroupResponseBody(name='body'),
}

async function updateApplicationGroupWithOptions(request: UpdateApplicationGroupRequest, runtime: Util.RuntimeOptions): UpdateApplicationGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateApplicationGroup', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateApplicationGroup(request: UpdateApplicationGroupRequest): UpdateApplicationGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateApplicationGroupWithOptions(request, runtime);
}

model UpdateExecutionRequest {
  regionId?: string(name='RegionId'),
  executionId?: string(name='ExecutionId'),
  parameters?: string(name='Parameters'),
  clientToken?: string(name='ClientToken'),
}

model UpdateExecutionResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateExecutionResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateExecutionResponseBody(name='body'),
}

async function updateExecutionWithOptions(request: UpdateExecutionRequest, runtime: Util.RuntimeOptions): UpdateExecutionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateExecution', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateExecution(request: UpdateExecutionRequest): UpdateExecutionResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateExecutionWithOptions(request, runtime);
}

model UpdateInstanceInformationRequest {
  regionId?: string(name='RegionId'),
  instanceId?: string(name='InstanceId'),
  agentVersion?: string(name='AgentVersion'),
  platformType?: string(name='PlatformType'),
  platformName?: string(name='PlatformName'),
  platformVersion?: string(name='PlatformVersion'),
  ipAddress?: string(name='IpAddress'),
  computerName?: string(name='ComputerName'),
  agentName?: string(name='AgentName'),
}

model UpdateInstanceInformationResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateInstanceInformationResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateInstanceInformationResponseBody(name='body'),
}

async function updateInstanceInformationWithOptions(request: UpdateInstanceInformationRequest, runtime: Util.RuntimeOptions): UpdateInstanceInformationResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateInstanceInformation', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateInstanceInformation(request: UpdateInstanceInformationRequest): UpdateInstanceInformationResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateInstanceInformationWithOptions(request, runtime);
}

model UpdateParameterRequest {
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
  value?: string(name='Value'),
  description?: string(name='Description'),
  tags?: string(name='Tags'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model UpdateParameterResponseBody = {
  requestId?: string(name='RequestId'),
  parameter?: {
    type?: string(name='Type'),
    updatedDate?: string(name='UpdatedDate'),
    updatedBy?: string(name='UpdatedBy'),
    tags?: string(name='Tags'),
    description?: string(name='Description'),
    constraints?: string(name='Constraints'),
    resourceGroupId?: string(name='ResourceGroupId'),
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    parameterVersion?: int32(name='ParameterVersion'),
    name?: string(name='Name'),
    id?: string(name='Id'),
    shareType?: string(name='ShareType'),
  }(name='Parameter'),
}

model UpdateParameterResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateParameterResponseBody(name='body'),
}

async function updateParameterWithOptions(request: UpdateParameterRequest, runtime: Util.RuntimeOptions): UpdateParameterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateParameter', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateParameter(request: UpdateParameterRequest): UpdateParameterResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateParameterWithOptions(request, runtime);
}

model UpdatePatchBaselineRequest {
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  clientToken?: string(name='ClientToken'),
  approvalRules?: string(name='ApprovalRules'),
}

model UpdatePatchBaselineResponseBody = {
  requestId?: string(name='RequestId'),
  patchBaseline?: {
    operationSystem?: string(name='OperationSystem'),
    description?: string(name='Description'),
    updatedDate?: string(name='UpdatedDate'),
    updatedBy?: string(name='UpdatedBy'),
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    name?: string(name='Name'),
    approvalRules?: string(name='ApprovalRules'),
    id?: string(name='Id'),
    shareType?: string(name='ShareType'),
  }(name='PatchBaseline'),
}

model UpdatePatchBaselineResponse = {
  headers: map[string]string(name='headers'),
  body: UpdatePatchBaselineResponseBody(name='body'),
}

async function updatePatchBaselineWithOptions(request: UpdatePatchBaselineRequest, runtime: Util.RuntimeOptions): UpdatePatchBaselineResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdatePatchBaseline', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updatePatchBaseline(request: UpdatePatchBaselineRequest): UpdatePatchBaselineResponse {
  var runtime = new Util.RuntimeOptions{};
  return updatePatchBaselineWithOptions(request, runtime);
}

model UpdateSecretParameterRequest {
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
  value?: string(name='Value'),
  description?: string(name='Description'),
  tags?: map[string]any(name='Tags'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model UpdateSecretParameterShrinkRequest {
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
  value?: string(name='Value'),
  description?: string(name='Description'),
  tagsShrink?: string(name='Tags'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model UpdateSecretParameterResponseBody = {
  requestId?: string(name='RequestId'),
  parameter?: {
    type?: string(name='Type'),
    updatedDate?: string(name='UpdatedDate'),
    updatedBy?: string(name='UpdatedBy'),
    keyId?: string(name='KeyId'),
    tags?: string(name='Tags'),
    description?: string(name='Description'),
    constraints?: string(name='Constraints'),
    resourceGroupId?: string(name='ResourceGroupId'),
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    parameterVersion?: int32(name='ParameterVersion'),
    name?: string(name='Name'),
    id?: string(name='Id'),
    shareType?: string(name='ShareType'),
  }(name='Parameter'),
}

model UpdateSecretParameterResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateSecretParameterResponseBody(name='body'),
}

async function updateSecretParameterWithOptions(tmpReq: UpdateSecretParameterRequest, runtime: Util.RuntimeOptions): UpdateSecretParameterResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateSecretParameterShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateSecretParameter', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateSecretParameter(request: UpdateSecretParameterRequest): UpdateSecretParameterResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSecretParameterWithOptions(request, runtime);
}

model UpdateStateConfigurationRequest {
  regionId?: string(name='RegionId'),
  description?: string(name='Description'),
  parameters?: map[string]any(name='Parameters'),
  configureMode?: string(name='ConfigureMode'),
  scheduleType?: string(name='ScheduleType'),
  scheduleExpression?: string(name='ScheduleExpression'),
  targets?: string(name='Targets'),
  clientToken?: string(name='ClientToken'),
  stateConfigurationId?: string(name='StateConfigurationId'),
  tags?: map[string]any(name='Tags'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model UpdateStateConfigurationShrinkRequest {
  regionId?: string(name='RegionId'),
  description?: string(name='Description'),
  parametersShrink?: string(name='Parameters'),
  configureMode?: string(name='ConfigureMode'),
  scheduleType?: string(name='ScheduleType'),
  scheduleExpression?: string(name='ScheduleExpression'),
  targets?: string(name='Targets'),
  clientToken?: string(name='ClientToken'),
  stateConfigurationId?: string(name='StateConfigurationId'),
  tagsShrink?: string(name='Tags'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model UpdateStateConfigurationResponseBody = {
  requestId?: string(name='RequestId'),
  stateConfiguration?: [ 
    {
      updateTime?: string(name='UpdateTime'),
      createTime?: string(name='CreateTime'),
      targets?: string(name='Targets'),
      tags?: map[string]any(name='Tags'),
      stateConfigurationId?: string(name='StateConfigurationId'),
      scheduleExpression?: string(name='ScheduleExpression'),
      templateName?: string(name='TemplateName'),
      templateVersion?: string(name='TemplateVersion'),
      configureMode?: string(name='ConfigureMode'),
      scheduleType?: string(name='ScheduleType'),
      parameters?: string(name='Parameters'),
      description?: string(name='Description'),
      resourceGroupId?: string(name='ResourceGroupId'),
      templateId?: string(name='TemplateId'),
    }
  ](name='StateConfiguration'),
}

model UpdateStateConfigurationResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateStateConfigurationResponseBody(name='body'),
}

async function updateStateConfigurationWithOptions(tmpReq: UpdateStateConfigurationRequest, runtime: Util.RuntimeOptions): UpdateStateConfigurationResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateStateConfigurationShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.parameters)) {
    request.parametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.parameters, 'Parameters', 'json');
  }
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateStateConfiguration', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateStateConfiguration(request: UpdateStateConfigurationRequest): UpdateStateConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateStateConfigurationWithOptions(request, runtime);
}

model UpdateTemplateRequest {
  regionId?: string(name='RegionId'),
  templateName?: string(name='TemplateName'),
  content?: string(name='Content'),
  tags?: map[string]any(name='Tags'),
  versionName?: string(name='VersionName'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model UpdateTemplateShrinkRequest {
  regionId?: string(name='RegionId'),
  templateName?: string(name='TemplateName'),
  content?: string(name='Content'),
  tagsShrink?: string(name='Tags'),
  versionName?: string(name='VersionName'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model UpdateTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  template?: {
    hash?: string(name='Hash'),
    updatedDate?: string(name='UpdatedDate'),
    updatedBy?: string(name='UpdatedBy'),
    tags?: map[string]any(name='Tags'),
    templateName?: string(name='TemplateName'),
    templateVersion?: string(name='TemplateVersion'),
    templateFormat?: string(name='TemplateFormat'),
    description?: string(name='Description'),
    resourceGroupId?: string(name='ResourceGroupId'),
    createdBy?: string(name='CreatedBy'),
    createdDate?: string(name='CreatedDate'),
    templateId?: string(name='TemplateId'),
    hasTrigger?: boolean(name='HasTrigger'),
    shareType?: string(name='ShareType'),
  }(name='Template'),
}

model UpdateTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateTemplateResponseBody(name='body'),
}

async function updateTemplateWithOptions(tmpReq: UpdateTemplateRequest, runtime: Util.RuntimeOptions): UpdateTemplateResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateTemplateShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateTemplate', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateTemplate(request: UpdateTemplateRequest): UpdateTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateTemplateWithOptions(request, runtime);
}

model ValidateTemplateContentRequest {
  regionId?: string(name='RegionId'),
  content?: string(name='Content'),
}

model ValidateTemplateContentResponseBody = {
  outputs?: string(name='Outputs'),
  requestId?: string(name='RequestId'),
  parameters?: string(name='Parameters'),
  ramRole?: string(name='RamRole'),
  tasks?: [ 
    {
      outputs?: string(name='Outputs'),
      type?: string(name='Type'),
      description?: string(name='Description'),
      name?: string(name='Name'),
      properties?: string(name='Properties'),
    }
  ](name='Tasks'),
}

model ValidateTemplateContentResponse = {
  headers: map[string]string(name='headers'),
  body: ValidateTemplateContentResponseBody(name='body'),
}

async function validateTemplateContentWithOptions(request: ValidateTemplateContentRequest, runtime: Util.RuntimeOptions): ValidateTemplateContentResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ValidateTemplateContent', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function validateTemplateContent(request: ValidateTemplateContentRequest): ValidateTemplateContentResponse {
  var runtime = new Util.RuntimeOptions{};
  return validateTemplateContentWithOptions(request, runtime);
}

