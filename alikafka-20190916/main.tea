/**
 *
 */
import Util;
import OpenApi;

import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
@endpointMap = {
    ap-northeast-2-pop = 'alikafka.aliyuncs.com',
    ap-southeast-2 = 'alikafka.aliyuncs.com',
    cn-beijing-finance-1 = 'alikafka.aliyuncs.com',
    cn-beijing-finance-pop = 'alikafka.aliyuncs.com',
    cn-beijing-gov-1 = 'alikafka.aliyuncs.com',
    cn-beijing-nu16-b01 = 'alikafka.aliyuncs.com',
    cn-edge-1 = 'alikafka.aliyuncs.com',
    cn-fujian = 'alikafka.aliyuncs.com',
    cn-haidian-cm12-c01 = 'alikafka.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'alikafka.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'alikafka.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'alikafka.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'alikafka.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'alikafka.aliyuncs.com',
    cn-hangzhou-test-306 = 'alikafka.aliyuncs.com',
    cn-hongkong-finance-pop = 'alikafka.aliyuncs.com',
    cn-huhehaote-nebula-1 = 'alikafka.aliyuncs.com',
    cn-qingdao-nebula = 'alikafka.aliyuncs.com',
    cn-shanghai-et15-b01 = 'alikafka.aliyuncs.com',
    cn-shanghai-et2-b01 = 'alikafka.aliyuncs.com',
    cn-shanghai-inner = 'alikafka.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'alikafka.aliyuncs.com',
    cn-shenzhen-inner = 'alikafka.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'alikafka.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'alikafka.aliyuncs.com',
    cn-wuhan = 'alikafka.aliyuncs.com',
    cn-wulanchabu = 'alikafka.aliyuncs.com',
    cn-yushanfang = 'alikafka.aliyuncs.com',
    cn-zhangbei = 'alikafka.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'alikafka.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'alikafka.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'alikafka.aliyuncs.com',
    eu-west-1-oxs = 'alikafka.aliyuncs.com',
    me-east-1 = 'alikafka.aliyuncs.com',
    rus-west-1-pop = 'alikafka.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('alikafka', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model ConvertPostPayOrderRequest {
  regionId?: string(name='RegionId'),
  instanceId?: string(name='InstanceId'),
  duration?: int32(name='Duration'),
}

model ConvertPostPayOrderResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  orderId?: string(name='OrderId'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model ConvertPostPayOrderResponse = {
  headers: map[string]string(name='headers'),
  body: ConvertPostPayOrderResponseBody(name='body'),
}

async function convertPostPayOrderWithOptions(request: ConvertPostPayOrderRequest, runtime: Util.RuntimeOptions): ConvertPostPayOrderResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ConvertPostPayOrder', '2019-09-16', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function convertPostPayOrder(request: ConvertPostPayOrderRequest): ConvertPostPayOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return convertPostPayOrderWithOptions(request, runtime);
}

model CreateAclRequest {
  regionId?: string(name='RegionId'),
  instanceId?: string(name='InstanceId'),
  username?: string(name='Username'),
  aclResourceType?: string(name='AclResourceType'),
  aclResourceName?: string(name='AclResourceName'),
  aclResourcePatternType?: string(name='AclResourcePatternType'),
  aclOperationType?: string(name='AclOperationType'),
}

model CreateAclResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model CreateAclResponse = {
  headers: map[string]string(name='headers'),
  body: CreateAclResponseBody(name='body'),
}

async function createAclWithOptions(request: CreateAclRequest, runtime: Util.RuntimeOptions): CreateAclResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateAcl', '2019-09-16', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createAcl(request: CreateAclRequest): CreateAclResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAclWithOptions(request, runtime);
}

model CreateConsumerGroupRequest {
  instanceId?: string(name='InstanceId'),
  consumerId?: string(name='ConsumerId'),
  regionId?: string(name='RegionId'),
  remark?: string(name='Remark'),
}

model CreateConsumerGroupResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model CreateConsumerGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateConsumerGroupResponseBody(name='body'),
}

async function createConsumerGroupWithOptions(request: CreateConsumerGroupRequest, runtime: Util.RuntimeOptions): CreateConsumerGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateConsumerGroup', '2019-09-16', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createConsumerGroup(request: CreateConsumerGroupRequest): CreateConsumerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createConsumerGroupWithOptions(request, runtime);
}

model CreatePostPayOrderRequest {
  regionId?: string(name='RegionId'),
  topicQuota?: int32(name='TopicQuota'),
  diskType?: string(name='DiskType'),
  diskSize?: int32(name='DiskSize'),
  deployType?: int32(name='DeployType'),
  ioMax?: int32(name='IoMax'),
  eipMax?: int32(name='EipMax'),
  paidType?: int32(name='PaidType'),
  specType?: string(name='SpecType'),
  ioMaxSpec?: string(name='IoMaxSpec'),
}

model CreatePostPayOrderResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  orderId?: string(name='OrderId'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model CreatePostPayOrderResponse = {
  headers: map[string]string(name='headers'),
  body: CreatePostPayOrderResponseBody(name='body'),
}

async function createPostPayOrderWithOptions(request: CreatePostPayOrderRequest, runtime: Util.RuntimeOptions): CreatePostPayOrderResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreatePostPayOrder', '2019-09-16', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createPostPayOrder(request: CreatePostPayOrderRequest): CreatePostPayOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return createPostPayOrderWithOptions(request, runtime);
}

model CreatePrePayOrderRequest {
  regionId?: string(name='RegionId'),
  topicQuota?: int32(name='TopicQuota'),
  diskType?: string(name='DiskType'),
  diskSize?: int32(name='DiskSize'),
  deployType?: int32(name='DeployType'),
  ioMax?: int32(name='IoMax'),
  eipMax?: int32(name='EipMax'),
  specType?: string(name='SpecType'),
  ioMaxSpec?: string(name='IoMaxSpec'),
}

model CreatePrePayOrderResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  orderId?: string(name='OrderId'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model CreatePrePayOrderResponse = {
  headers: map[string]string(name='headers'),
  body: CreatePrePayOrderResponseBody(name='body'),
}

async function createPrePayOrderWithOptions(request: CreatePrePayOrderRequest, runtime: Util.RuntimeOptions): CreatePrePayOrderResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreatePrePayOrder', '2019-09-16', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createPrePayOrder(request: CreatePrePayOrderRequest): CreatePrePayOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return createPrePayOrderWithOptions(request, runtime);
}

model CreateSaslUserRequest {
  regionId?: string(name='RegionId'),
  instanceId?: string(name='InstanceId'),
  username?: string(name='Username'),
  password?: string(name='Password'),
  type?: string(name='Type'),
}

model CreateSaslUserResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model CreateSaslUserResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSaslUserResponseBody(name='body'),
}

async function createSaslUserWithOptions(request: CreateSaslUserRequest, runtime: Util.RuntimeOptions): CreateSaslUserResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateSaslUser', '2019-09-16', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createSaslUser(request: CreateSaslUserRequest): CreateSaslUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSaslUserWithOptions(request, runtime);
}

model CreateTopicRequest {
  instanceId?: string(name='InstanceId'),
  topic?: string(name='Topic'),
  remark?: string(name='Remark'),
  regionId?: string(name='RegionId'),
  compactTopic?: boolean(name='CompactTopic'),
  partitionNum?: string(name='PartitionNum'),
  localTopic?: boolean(name='LocalTopic'),
}

model CreateTopicResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model CreateTopicResponse = {
  headers: map[string]string(name='headers'),
  body: CreateTopicResponseBody(name='body'),
}

async function createTopicWithOptions(request: CreateTopicRequest, runtime: Util.RuntimeOptions): CreateTopicResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateTopic', '2019-09-16', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createTopic(request: CreateTopicRequest): CreateTopicResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTopicWithOptions(request, runtime);
}

model DeleteAclRequest {
  regionId?: string(name='RegionId'),
  instanceId?: string(name='InstanceId'),
  username?: string(name='Username'),
  aclResourceType?: string(name='AclResourceType'),
  aclResourceName?: string(name='AclResourceName'),
  aclResourcePatternType?: string(name='AclResourcePatternType'),
  aclOperationType?: string(name='AclOperationType'),
}

model DeleteAclResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model DeleteAclResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAclResponseBody(name='body'),
}

async function deleteAclWithOptions(request: DeleteAclRequest, runtime: Util.RuntimeOptions): DeleteAclResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteAcl', '2019-09-16', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteAcl(request: DeleteAclRequest): DeleteAclResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAclWithOptions(request, runtime);
}

model DeleteConsumerGroupRequest {
  instanceId?: string(name='InstanceId'),
  consumerId?: string(name='ConsumerId'),
  regionId?: string(name='RegionId'),
}

model DeleteConsumerGroupResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model DeleteConsumerGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteConsumerGroupResponseBody(name='body'),
}

async function deleteConsumerGroupWithOptions(request: DeleteConsumerGroupRequest, runtime: Util.RuntimeOptions): DeleteConsumerGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteConsumerGroup', '2019-09-16', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteConsumerGroup(request: DeleteConsumerGroupRequest): DeleteConsumerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteConsumerGroupWithOptions(request, runtime);
}

model DeleteInstanceRequest {
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
}

model DeleteInstanceResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model DeleteInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteInstanceResponseBody(name='body'),
}

async function deleteInstanceWithOptions(request: DeleteInstanceRequest, runtime: Util.RuntimeOptions): DeleteInstanceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteInstance', '2019-09-16', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteInstance(request: DeleteInstanceRequest): DeleteInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteInstanceWithOptions(request, runtime);
}

model DeleteSaslUserRequest {
  regionId?: string(name='RegionId'),
  instanceId?: string(name='InstanceId'),
  username?: string(name='Username'),
  type?: string(name='Type'),
}

model DeleteSaslUserResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model DeleteSaslUserResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSaslUserResponseBody(name='body'),
}

async function deleteSaslUserWithOptions(request: DeleteSaslUserRequest, runtime: Util.RuntimeOptions): DeleteSaslUserResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteSaslUser', '2019-09-16', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteSaslUser(request: DeleteSaslUserRequest): DeleteSaslUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSaslUserWithOptions(request, runtime);
}

model DeleteTopicRequest {
  instanceId?: string(name='InstanceId'),
  topic?: string(name='Topic'),
  regionId?: string(name='RegionId'),
}

model DeleteTopicResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model DeleteTopicResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteTopicResponseBody(name='body'),
}

async function deleteTopicWithOptions(request: DeleteTopicRequest, runtime: Util.RuntimeOptions): DeleteTopicResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteTopic', '2019-09-16', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteTopic(request: DeleteTopicRequest): DeleteTopicResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTopicWithOptions(request, runtime);
}

model DescribeAclsRequest {
  regionId?: string(name='RegionId'),
  instanceId?: string(name='InstanceId'),
  username?: string(name='Username'),
  aclResourceType?: string(name='AclResourceType'),
  aclResourceName?: string(name='AclResourceName'),
}

model DescribeAclsResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
  kafkaAclList?: [ 
    {
      aclResourceType?: string(name='AclResourceType'),
      host?: string(name='Host'),
      aclOperationType?: string(name='AclOperationType'),
      aclResourceName?: string(name='AclResourceName'),
      aclResourcePatternType?: string(name='AclResourcePatternType'),
      username?: string(name='Username'),
    }
  ](name='KafkaAclList'),
}

model DescribeAclsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAclsResponseBody(name='body'),
}

async function describeAclsWithOptions(request: DescribeAclsRequest, runtime: Util.RuntimeOptions): DescribeAclsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeAcls', '2019-09-16', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeAcls(request: DescribeAclsRequest): DescribeAclsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAclsWithOptions(request, runtime);
}

model DescribeNodeStatusRequest {
  regionId?: string(name='RegionId'),
  instanceId?: string(name='InstanceId'),
}

model DescribeNodeStatusResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  statusList?: [ string ](name='StatusList'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model DescribeNodeStatusResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeNodeStatusResponseBody(name='body'),
}

async function describeNodeStatusWithOptions(request: DescribeNodeStatusRequest, runtime: Util.RuntimeOptions): DescribeNodeStatusResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeNodeStatus', '2019-09-16', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeNodeStatus(request: DescribeNodeStatusRequest): DescribeNodeStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeNodeStatusWithOptions(request, runtime);
}

model DescribeSaslUsersRequest {
  regionId?: string(name='RegionId'),
  instanceId?: string(name='InstanceId'),
}

model DescribeSaslUsersResponseBody = {
  saslUserList?: [ 
    {
      type?: string(name='Type'),
      password?: string(name='Password'),
      username?: string(name='Username'),
    }
  ](name='SaslUserList'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model DescribeSaslUsersResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSaslUsersResponseBody(name='body'),
}

async function describeSaslUsersWithOptions(request: DescribeSaslUsersRequest, runtime: Util.RuntimeOptions): DescribeSaslUsersResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeSaslUsers', '2019-09-16', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeSaslUsers(request: DescribeSaslUsersRequest): DescribeSaslUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSaslUsersWithOptions(request, runtime);
}

model GetAllowedIpListRequest {
  regionId?: string(name='RegionId'),
  instanceId?: string(name='InstanceId'),
}

model GetAllowedIpListResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  allowedList?: {
    deployType?: int32(name='DeployType'),
    internetList?: [ 
      {
        portRange?: string(name='PortRange'),
        allowedIpList?: [ string ](name='AllowedIpList'),
      }
    ](name='InternetList'),
    vpcList?: [ 
      {
        portRange?: string(name='PortRange'),
        allowedIpList?: [ string ](name='AllowedIpList'),
      }
    ](name='VpcList'),
  }(name='AllowedList'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model GetAllowedIpListResponse = {
  headers: map[string]string(name='headers'),
  body: GetAllowedIpListResponseBody(name='body'),
}

async function getAllowedIpListWithOptions(request: GetAllowedIpListRequest, runtime: Util.RuntimeOptions): GetAllowedIpListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetAllowedIpList', '2019-09-16', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getAllowedIpList(request: GetAllowedIpListRequest): GetAllowedIpListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAllowedIpListWithOptions(request, runtime);
}

model GetConsumerListRequest {
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
}

model GetConsumerListResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
  consumerList?: [ 
    {
      remark?: string(name='Remark'),
      tags?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tags'),
      consumerId?: string(name='ConsumerId'),
      instanceId?: string(name='InstanceId'),
      regionId?: string(name='RegionId'),
    }
  ](name='ConsumerList'),
  success?: boolean(name='Success'),
}

model GetConsumerListResponse = {
  headers: map[string]string(name='headers'),
  body: GetConsumerListResponseBody(name='body'),
}

async function getConsumerListWithOptions(request: GetConsumerListRequest, runtime: Util.RuntimeOptions): GetConsumerListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetConsumerList', '2019-09-16', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getConsumerList(request: GetConsumerListRequest): GetConsumerListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getConsumerListWithOptions(request, runtime);
}

model GetConsumerProgressRequest {
  instanceId?: string(name='InstanceId'),
  consumerId?: string(name='ConsumerId'),
  regionId?: string(name='RegionId'),
}

model GetConsumerProgressResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  consumerProgress?: {
    topicList?: [ 
      {
        totalDiff?: long(name='TotalDiff'),
        lastTimestamp?: long(name='LastTimestamp'),
        topic?: string(name='Topic'),
        offsetList?: [ 
          {
            brokerOffset?: long(name='BrokerOffset'),
            consumerOffset?: long(name='ConsumerOffset'),
            lastTimestamp?: long(name='LastTimestamp'),
            partition?: int32(name='Partition'),
          }
        ](name='OffsetList'),
      }
    ](name='TopicList'),
    lastTimestamp?: long(name='LastTimestamp'),
    totalDiff?: long(name='TotalDiff'),
  }(name='ConsumerProgress'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model GetConsumerProgressResponse = {
  headers: map[string]string(name='headers'),
  body: GetConsumerProgressResponseBody(name='body'),
}

async function getConsumerProgressWithOptions(request: GetConsumerProgressRequest, runtime: Util.RuntimeOptions): GetConsumerProgressResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetConsumerProgress', '2019-09-16', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getConsumerProgress(request: GetConsumerProgressRequest): GetConsumerProgressResponse {
  var runtime = new Util.RuntimeOptions{};
  return getConsumerProgressWithOptions(request, runtime);
}

model GetInstanceListRequest {
  regionId?: string(name='RegionId'),
  orderId?: string(name='OrderId'),
  instanceId?: [ string ](name='InstanceId'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model GetInstanceListResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  instanceList?: [ 
    {
      vpcId?: string(name='VpcId'),
      upgradeServiceDetailInfo?: [ 
        {
          current2OpenSourceVersion?: string(name='Current2OpenSourceVersion'),
        }
      ](name='UpgradeServiceDetailInfo'),
      specType?: string(name='SpecType'),
      createTime?: long(name='CreateTime'),
      deployType?: int32(name='DeployType'),
      diskSize?: int32(name='DiskSize'),
      tags?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tags'),
      diskType?: int32(name='DiskType'),
      instanceId?: string(name='InstanceId'),
      sslEndPoint?: string(name='SslEndPoint'),
      securityGroup?: string(name='SecurityGroup'),
      serviceStatus?: int32(name='ServiceStatus'),
      eipMax?: int32(name='EipMax'),
      regionId?: string(name='RegionId'),
      msgRetain?: int32(name='MsgRetain'),
      vSwitchId?: string(name='VSwitchId'),
      expiredTime?: long(name='ExpiredTime'),
      topicNumLimit?: int32(name='TopicNumLimit'),
      zoneId?: string(name='ZoneId'),
      ioMax?: int32(name='IoMax'),
      paidType?: int32(name='PaidType'),
      name?: string(name='Name'),
      endPoint?: string(name='EndPoint'),
    }
  ](name='InstanceList'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model GetInstanceListResponse = {
  headers: map[string]string(name='headers'),
  body: GetInstanceListResponseBody(name='body'),
}

async function getInstanceListWithOptions(request: GetInstanceListRequest, runtime: Util.RuntimeOptions): GetInstanceListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetInstanceList', '2019-09-16', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getInstanceList(request: GetInstanceListRequest): GetInstanceListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInstanceListWithOptions(request, runtime);
}

model GetMetaProductListRequest {
  listNormal?: string(name='ListNormal'),
  regionId?: string(name='RegionId'),
}

model GetMetaProductListResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  metaData?: {
    productsNormal?: [ 
      {
        topicQuota?: string(name='TopicQuota'),
        specType?: string(name='SpecType'),
        deployType?: string(name='DeployType'),
        diskSize?: string(name='DiskSize'),
        ioMax?: long(name='IoMax'),
        diskType?: string(name='DiskType'),
        regionId?: string(name='RegionId'),
      }
    ](name='ProductsNormal'),
    productsProfessional?: [ 
      {
        topicQuota?: string(name='TopicQuota'),
        specType?: string(name='SpecType'),
        deployType?: string(name='DeployType'),
        diskSize?: string(name='DiskSize'),
        ioMax?: int32(name='IoMax'),
        diskType?: string(name='DiskType'),
        regionId?: string(name='RegionId'),
      }
    ](name='ProductsProfessional'),
    names?: map[string]any(name='Names'),
  }(name='MetaData'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model GetMetaProductListResponse = {
  headers: map[string]string(name='headers'),
  body: GetMetaProductListResponseBody(name='body'),
}

async function getMetaProductListWithOptions(request: GetMetaProductListRequest, runtime: Util.RuntimeOptions): GetMetaProductListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetMetaProductList', '2019-09-16', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getMetaProductList(request: GetMetaProductListRequest): GetMetaProductListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaProductListWithOptions(request, runtime);
}

model GetTopicListRequest {
  instanceId?: string(name='InstanceId'),
  currentPage?: string(name='CurrentPage'),
  pageSize?: string(name='PageSize'),
  regionId?: string(name='RegionId'),
}

model GetTopicListResponseBody = {
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  pageSize?: int32(name='PageSize'),
  currentPage?: int32(name='CurrentPage'),
  total?: int32(name='Total'),
  topicList?: [ 
    {
      status?: int32(name='Status'),
      remark?: string(name='Remark'),
      createTime?: long(name='CreateTime'),
      topic?: string(name='Topic'),
      statusName?: string(name='StatusName'),
      tags?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tags'),
      instanceId?: string(name='InstanceId'),
      regionId?: string(name='RegionId'),
    }
  ](name='TopicList'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model GetTopicListResponse = {
  headers: map[string]string(name='headers'),
  body: GetTopicListResponseBody(name='body'),
}

async function getTopicListWithOptions(request: GetTopicListRequest, runtime: Util.RuntimeOptions): GetTopicListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetTopicList', '2019-09-16', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getTopicList(request: GetTopicListRequest): GetTopicListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTopicListWithOptions(request, runtime);
}

model GetTopicStatusRequest {
  instanceId?: string(name='InstanceId'),
  topic?: string(name='Topic'),
  regionId?: string(name='RegionId'),
}

model GetTopicStatusResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  topicStatus?: {
    lastTimeStamp?: long(name='LastTimeStamp'),
    totalCount?: long(name='TotalCount'),
    offsetTable?: [ 
      {
        minOffset?: long(name='MinOffset'),
        topic?: string(name='Topic'),
        partition?: int32(name='Partition'),
        lastUpdateTimestamp?: long(name='LastUpdateTimestamp'),
        maxOffset?: long(name='MaxOffset'),
      }
    ](name='OffsetTable'),
  }(name='TopicStatus'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model GetTopicStatusResponse = {
  headers: map[string]string(name='headers'),
  body: GetTopicStatusResponseBody(name='body'),
}

async function getTopicStatusWithOptions(request: GetTopicStatusRequest, runtime: Util.RuntimeOptions): GetTopicStatusResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetTopicStatus', '2019-09-16', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getTopicStatus(request: GetTopicStatusRequest): GetTopicStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTopicStatusWithOptions(request, runtime);
}

model ListTagResourcesRequest {
  regionId?: string(name='RegionId'),
  resourceType?: string(name='ResourceType'),
  nextToken?: string(name='NextToken'),
  resourceId?: [ string ](name='ResourceId'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  tagResources?: [ 
    {
      resourceType?: string(name='ResourceType'),
      tagValue?: string(name='TagValue'),
      resourceId?: string(name='ResourceId'),
      tagKey?: string(name='TagKey'),
    }
  ](name='TagResources'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListTagResources', '2019-09-16', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagResourcesWithOptions(request, runtime);
}

model ModifyInstanceNameRequest {
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
  instanceName?: string(name='InstanceName'),
}

model ModifyInstanceNameResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model ModifyInstanceNameResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyInstanceNameResponseBody(name='body'),
}

async function modifyInstanceNameWithOptions(request: ModifyInstanceNameRequest, runtime: Util.RuntimeOptions): ModifyInstanceNameResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyInstanceName', '2019-09-16', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyInstanceName(request: ModifyInstanceNameRequest): ModifyInstanceNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyInstanceNameWithOptions(request, runtime);
}

model ModifyPartitionNumRequest {
  instanceId?: string(name='InstanceId'),
  topic?: string(name='Topic'),
  regionId?: string(name='RegionId'),
  addPartitionNum?: int32(name='AddPartitionNum'),
}

model ModifyPartitionNumResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model ModifyPartitionNumResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyPartitionNumResponseBody(name='body'),
}

async function modifyPartitionNumWithOptions(request: ModifyPartitionNumRequest, runtime: Util.RuntimeOptions): ModifyPartitionNumResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyPartitionNum', '2019-09-16', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyPartitionNum(request: ModifyPartitionNumRequest): ModifyPartitionNumResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyPartitionNumWithOptions(request, runtime);
}

model ModifyTopicRemarkRequest {
  instanceId?: string(name='InstanceId'),
  topic?: string(name='Topic'),
  regionId?: string(name='RegionId'),
  remark?: string(name='Remark'),
}

model ModifyTopicRemarkResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model ModifyTopicRemarkResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyTopicRemarkResponseBody(name='body'),
}

async function modifyTopicRemarkWithOptions(request: ModifyTopicRemarkRequest, runtime: Util.RuntimeOptions): ModifyTopicRemarkResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyTopicRemark', '2019-09-16', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyTopicRemark(request: ModifyTopicRemarkRequest): ModifyTopicRemarkResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyTopicRemarkWithOptions(request, runtime);
}

model ReleaseInstanceRequest {
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
  releaseIgnoreTime?: boolean(name='ReleaseIgnoreTime'),
  forceDeleteInstance?: boolean(name='ForceDeleteInstance'),
}

model ReleaseInstanceResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model ReleaseInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: ReleaseInstanceResponseBody(name='body'),
}

async function releaseInstanceWithOptions(request: ReleaseInstanceRequest, runtime: Util.RuntimeOptions): ReleaseInstanceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ReleaseInstance', '2019-09-16', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function releaseInstance(request: ReleaseInstanceRequest): ReleaseInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return releaseInstanceWithOptions(request, runtime);
}

model StartInstanceRequest {
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
  vpcId?: string(name='VpcId'),
  vSwitchId?: string(name='VSwitchId'),
  deployModule?: string(name='DeployModule'),
  zoneId?: string(name='ZoneId'),
  isEipInner?: boolean(name='IsEipInner'),
  isSetUserAndPassword?: boolean(name='IsSetUserAndPassword'),
  username?: string(name='Username'),
  password?: string(name='Password'),
  name?: string(name='Name'),
  crossZone?: boolean(name='CrossZone'),
  securityGroup?: string(name='SecurityGroup'),
}

model StartInstanceResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model StartInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: StartInstanceResponseBody(name='body'),
}

async function startInstanceWithOptions(request: StartInstanceRequest, runtime: Util.RuntimeOptions): StartInstanceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('StartInstance', '2019-09-16', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function startInstance(request: StartInstanceRequest): StartInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return startInstanceWithOptions(request, runtime);
}

model TagResourcesRequest {
  regionId?: string(name='RegionId'),
  resourceType?: string(name='ResourceType'),
  resourceId?: [ string ](name='ResourceId'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResourcesWithOptions(request: TagResourcesRequest, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('TagResources', '2019-09-16', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagResourcesWithOptions(request, runtime);
}

model UntagResourcesRequest {
  regionId?: string(name='RegionId'),
  resourceType?: string(name='ResourceType'),
  all?: boolean(name='All'),
  resourceId?: [ string ](name='ResourceId'),
  tagKey?: [ string ](name='TagKey'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResourcesWithOptions(request: UntagResourcesRequest, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UntagResources', '2019-09-16', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return untagResourcesWithOptions(request, runtime);
}

model UpdateAllowedIpRequest {
  regionId?: string(name='RegionId'),
  updateType?: string(name='UpdateType'),
  portRange?: string(name='PortRange'),
  allowedListType?: string(name='AllowedListType'),
  allowedListIp?: string(name='AllowedListIp'),
  instanceId?: string(name='InstanceId'),
}

model UpdateAllowedIpResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model UpdateAllowedIpResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAllowedIpResponseBody(name='body'),
}

async function updateAllowedIpWithOptions(request: UpdateAllowedIpRequest, runtime: Util.RuntimeOptions): UpdateAllowedIpResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateAllowedIp', '2019-09-16', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateAllowedIp(request: UpdateAllowedIpRequest): UpdateAllowedIpResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAllowedIpWithOptions(request, runtime);
}

model UpgradePostPayOrderRequest {
  instanceId?: string(name='InstanceId'),
  topicQuota?: int32(name='TopicQuota'),
  diskSize?: int32(name='DiskSize'),
  regionId?: string(name='RegionId'),
  ioMax?: int32(name='IoMax'),
  specType?: string(name='SpecType'),
  eipMax?: int32(name='EipMax'),
  ioMaxSpec?: string(name='IoMaxSpec'),
}

model UpgradePostPayOrderResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model UpgradePostPayOrderResponse = {
  headers: map[string]string(name='headers'),
  body: UpgradePostPayOrderResponseBody(name='body'),
}

async function upgradePostPayOrderWithOptions(request: UpgradePostPayOrderRequest, runtime: Util.RuntimeOptions): UpgradePostPayOrderResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpgradePostPayOrder', '2019-09-16', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function upgradePostPayOrder(request: UpgradePostPayOrderRequest): UpgradePostPayOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradePostPayOrderWithOptions(request, runtime);
}

model UpgradePrePayOrderRequest {
  instanceId?: string(name='InstanceId'),
  topicQuota?: int32(name='TopicQuota'),
  diskSize?: int32(name='DiskSize'),
  regionId?: string(name='RegionId'),
  ioMax?: int32(name='IoMax'),
  specType?: string(name='SpecType'),
  eipMax?: int32(name='EipMax'),
  ioMaxSpec?: string(name='IoMaxSpec'),
}

model UpgradePrePayOrderResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model UpgradePrePayOrderResponse = {
  headers: map[string]string(name='headers'),
  body: UpgradePrePayOrderResponseBody(name='body'),
}

async function upgradePrePayOrderWithOptions(request: UpgradePrePayOrderRequest, runtime: Util.RuntimeOptions): UpgradePrePayOrderResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpgradePrePayOrder', '2019-09-16', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function upgradePrePayOrder(request: UpgradePrePayOrderRequest): UpgradePrePayOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradePrePayOrderWithOptions(request, runtime);
}

