/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    ap-northeast-2-pop = 'alikafka.aliyuncs.com',
    ap-southeast-2 = 'alikafka.aliyuncs.com',
    cn-beijing-finance-1 = 'alikafka.aliyuncs.com',
    cn-beijing-finance-pop = 'alikafka.aliyuncs.com',
    cn-beijing-gov-1 = 'alikafka.aliyuncs.com',
    cn-beijing-nu16-b01 = 'alikafka.aliyuncs.com',
    cn-edge-1 = 'alikafka.aliyuncs.com',
    cn-fujian = 'alikafka.aliyuncs.com',
    cn-haidian-cm12-c01 = 'alikafka.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'alikafka.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'alikafka.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'alikafka.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'alikafka.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'alikafka.aliyuncs.com',
    cn-hangzhou-test-306 = 'alikafka.aliyuncs.com',
    cn-hongkong-finance-pop = 'alikafka.aliyuncs.com',
    cn-huhehaote-nebula-1 = 'alikafka.aliyuncs.com',
    cn-qingdao-nebula = 'alikafka.aliyuncs.com',
    cn-shanghai-et15-b01 = 'alikafka.aliyuncs.com',
    cn-shanghai-et2-b01 = 'alikafka.aliyuncs.com',
    cn-shanghai-inner = 'alikafka.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'alikafka.aliyuncs.com',
    cn-shenzhen-inner = 'alikafka.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'alikafka.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'alikafka.aliyuncs.com',
    cn-wuhan = 'alikafka.aliyuncs.com',
    cn-wulanchabu = 'alikafka.aliyuncs.com',
    cn-yushanfang = 'alikafka.aliyuncs.com',
    cn-zhangbei = 'alikafka.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'alikafka.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'alikafka.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'alikafka.aliyuncs.com',
    eu-west-1-oxs = 'alikafka.aliyuncs.com',
    me-east-1 = 'alikafka.aliyuncs.com',
    rus-west-1-pop = 'alikafka.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('alikafka', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model ChangeResourceGroupRequest {
  newResourceGroupId?: string(name='NewResourceGroupId'),
  regionId?: string(name='RegionId'),
  resourceId?: string(name='ResourceId'),
}

model ChangeResourceGroupResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  newResourceGroupId?: string(name='NewResourceGroupId'),
  requestId?: string(name='RequestId'),
  success?: long(name='Success'),
}

model ChangeResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ChangeResourceGroupResponseBody(name='body'),
}

async function changeResourceGroupWithOptions(request: ChangeResourceGroupRequest, runtime: Util.RuntimeOptions): ChangeResourceGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.newResourceGroupId)) {
    query['NewResourceGroupId'] = request.newResourceGroupId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ChangeResourceGroup',
    version = '2019-09-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function changeResourceGroup(request: ChangeResourceGroupRequest): ChangeResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return changeResourceGroupWithOptions(request, runtime);
}

model ConvertPostPayOrderRequest {
  duration?: int32(name='Duration'),
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
}

model ConvertPostPayOrderResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ConvertPostPayOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ConvertPostPayOrderResponseBody(name='body'),
}

async function convertPostPayOrderWithOptions(request: ConvertPostPayOrderRequest, runtime: Util.RuntimeOptions): ConvertPostPayOrderResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.duration)) {
    query['Duration'] = request.duration;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ConvertPostPayOrder',
    version = '2019-09-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function convertPostPayOrder(request: ConvertPostPayOrderRequest): ConvertPostPayOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return convertPostPayOrderWithOptions(request, runtime);
}

model CreateAclRequest {
  aclOperationType?: string(name='AclOperationType'),
  aclResourceName?: string(name='AclResourceName'),
  aclResourcePatternType?: string(name='AclResourcePatternType'),
  aclResourceType?: string(name='AclResourceType'),
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
  username?: string(name='Username'),
}

model CreateAclResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateAclResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAclResponseBody(name='body'),
}

async function createAclWithOptions(request: CreateAclRequest, runtime: Util.RuntimeOptions): CreateAclResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclOperationType)) {
    query['AclOperationType'] = request.aclOperationType;
  }
  if (!Util.isUnset(request.aclResourceName)) {
    query['AclResourceName'] = request.aclResourceName;
  }
  if (!Util.isUnset(request.aclResourcePatternType)) {
    query['AclResourcePatternType'] = request.aclResourcePatternType;
  }
  if (!Util.isUnset(request.aclResourceType)) {
    query['AclResourceType'] = request.aclResourceType;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.username)) {
    query['Username'] = request.username;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateAcl',
    version = '2019-09-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createAcl(request: CreateAclRequest): CreateAclResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAclWithOptions(request, runtime);
}

model CreateConsumerGroupRequest {
  consumerId?: string(name='ConsumerId'),
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
  remark?: string(name='Remark'),
}

model CreateConsumerGroupResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateConsumerGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateConsumerGroupResponseBody(name='body'),
}

async function createConsumerGroupWithOptions(request: CreateConsumerGroupRequest, runtime: Util.RuntimeOptions): CreateConsumerGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consumerId)) {
    query['ConsumerId'] = request.consumerId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateConsumerGroup',
    version = '2019-09-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createConsumerGroup(request: CreateConsumerGroupRequest): CreateConsumerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createConsumerGroupWithOptions(request, runtime);
}

model CreatePostPayOrderRequest {
  deployType?: int32(name='DeployType'),
  diskSize?: int32(name='DiskSize'),
  diskType?: string(name='DiskType'),
  eipMax?: int32(name='EipMax'),
  ioMax?: int32(name='IoMax'),
  ioMaxSpec?: string(name='IoMaxSpec'),
  partitionNum?: int32(name='PartitionNum'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  specType?: string(name='SpecType'),
  topicQuota?: int32(name='TopicQuota'),
}

model CreatePostPayOrderResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreatePostPayOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreatePostPayOrderResponseBody(name='body'),
}

async function createPostPayOrderWithOptions(request: CreatePostPayOrderRequest, runtime: Util.RuntimeOptions): CreatePostPayOrderResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deployType)) {
    query['DeployType'] = request.deployType;
  }
  if (!Util.isUnset(request.diskSize)) {
    query['DiskSize'] = request.diskSize;
  }
  if (!Util.isUnset(request.diskType)) {
    query['DiskType'] = request.diskType;
  }
  if (!Util.isUnset(request.eipMax)) {
    query['EipMax'] = request.eipMax;
  }
  if (!Util.isUnset(request.ioMax)) {
    query['IoMax'] = request.ioMax;
  }
  if (!Util.isUnset(request.ioMaxSpec)) {
    query['IoMaxSpec'] = request.ioMaxSpec;
  }
  if (!Util.isUnset(request.partitionNum)) {
    query['PartitionNum'] = request.partitionNum;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.specType)) {
    query['SpecType'] = request.specType;
  }
  if (!Util.isUnset(request.topicQuota)) {
    query['TopicQuota'] = request.topicQuota;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreatePostPayOrder',
    version = '2019-09-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createPostPayOrder(request: CreatePostPayOrderRequest): CreatePostPayOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return createPostPayOrderWithOptions(request, runtime);
}

model CreatePrePayOrderRequest {
  deployType?: int32(name='DeployType'),
  diskSize?: int32(name='DiskSize'),
  diskType?: string(name='DiskType'),
  eipMax?: int32(name='EipMax'),
  ioMax?: int32(name='IoMax'),
  ioMaxSpec?: string(name='IoMaxSpec'),
  partitionNum?: int32(name='PartitionNum'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  specType?: string(name='SpecType'),
  topicQuota?: int32(name='TopicQuota'),
}

model CreatePrePayOrderResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreatePrePayOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreatePrePayOrderResponseBody(name='body'),
}

async function createPrePayOrderWithOptions(request: CreatePrePayOrderRequest, runtime: Util.RuntimeOptions): CreatePrePayOrderResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deployType)) {
    query['DeployType'] = request.deployType;
  }
  if (!Util.isUnset(request.diskSize)) {
    query['DiskSize'] = request.diskSize;
  }
  if (!Util.isUnset(request.diskType)) {
    query['DiskType'] = request.diskType;
  }
  if (!Util.isUnset(request.eipMax)) {
    query['EipMax'] = request.eipMax;
  }
  if (!Util.isUnset(request.ioMax)) {
    query['IoMax'] = request.ioMax;
  }
  if (!Util.isUnset(request.ioMaxSpec)) {
    query['IoMaxSpec'] = request.ioMaxSpec;
  }
  if (!Util.isUnset(request.partitionNum)) {
    query['PartitionNum'] = request.partitionNum;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.specType)) {
    query['SpecType'] = request.specType;
  }
  if (!Util.isUnset(request.topicQuota)) {
    query['TopicQuota'] = request.topicQuota;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreatePrePayOrder',
    version = '2019-09-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createPrePayOrder(request: CreatePrePayOrderRequest): CreatePrePayOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return createPrePayOrderWithOptions(request, runtime);
}

model CreateSaslUserRequest {
  instanceId?: string(name='InstanceId'),
  password?: string(name='Password'),
  regionId?: string(name='RegionId'),
  type?: string(name='Type'),
  username?: string(name='Username'),
}

model CreateSaslUserResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateSaslUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSaslUserResponseBody(name='body'),
}

async function createSaslUserWithOptions(request: CreateSaslUserRequest, runtime: Util.RuntimeOptions): CreateSaslUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.username)) {
    query['Username'] = request.username;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateSaslUser',
    version = '2019-09-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createSaslUser(request: CreateSaslUserRequest): CreateSaslUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSaslUserWithOptions(request, runtime);
}

model CreateTopicRequest {
  compactTopic?: boolean(name='CompactTopic'),
  config?: map[string]any(name='Config'),
  instanceId?: string(name='InstanceId'),
  localTopic?: boolean(name='LocalTopic'),
  minInsyncReplicas?: long(name='MinInsyncReplicas'),
  partitionNum?: string(name='PartitionNum'),
  regionId?: string(name='RegionId'),
  remark?: string(name='Remark'),
  replicationFactor?: long(name='ReplicationFactor'),
  topic?: string(name='Topic'),
}

model CreateTopicShrinkRequest {
  compactTopic?: boolean(name='CompactTopic'),
  configShrink?: string(name='Config'),
  instanceId?: string(name='InstanceId'),
  localTopic?: boolean(name='LocalTopic'),
  minInsyncReplicas?: long(name='MinInsyncReplicas'),
  partitionNum?: string(name='PartitionNum'),
  regionId?: string(name='RegionId'),
  remark?: string(name='Remark'),
  replicationFactor?: long(name='ReplicationFactor'),
  topic?: string(name='Topic'),
}

model CreateTopicResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateTopicResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateTopicResponseBody(name='body'),
}

async function createTopicWithOptions(tmpReq: CreateTopicRequest, runtime: Util.RuntimeOptions): CreateTopicResponse {
  Util.validateModel(tmpReq);
  var request = new CreateTopicShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.config)) {
    request.configShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.config, 'Config', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.compactTopic)) {
    query['CompactTopic'] = request.compactTopic;
  }
  if (!Util.isUnset(request.configShrink)) {
    query['Config'] = request.configShrink;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.localTopic)) {
    query['LocalTopic'] = request.localTopic;
  }
  if (!Util.isUnset(request.minInsyncReplicas)) {
    query['MinInsyncReplicas'] = request.minInsyncReplicas;
  }
  if (!Util.isUnset(request.partitionNum)) {
    query['PartitionNum'] = request.partitionNum;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.replicationFactor)) {
    query['ReplicationFactor'] = request.replicationFactor;
  }
  if (!Util.isUnset(request.topic)) {
    query['Topic'] = request.topic;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateTopic',
    version = '2019-09-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createTopic(request: CreateTopicRequest): CreateTopicResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTopicWithOptions(request, runtime);
}

model DeleteAclRequest {
  aclOperationType?: string(name='AclOperationType'),
  aclResourceName?: string(name='AclResourceName'),
  aclResourcePatternType?: string(name='AclResourcePatternType'),
  aclResourceType?: string(name='AclResourceType'),
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
  username?: string(name='Username'),
}

model DeleteAclResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteAclResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAclResponseBody(name='body'),
}

async function deleteAclWithOptions(request: DeleteAclRequest, runtime: Util.RuntimeOptions): DeleteAclResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclOperationType)) {
    query['AclOperationType'] = request.aclOperationType;
  }
  if (!Util.isUnset(request.aclResourceName)) {
    query['AclResourceName'] = request.aclResourceName;
  }
  if (!Util.isUnset(request.aclResourcePatternType)) {
    query['AclResourcePatternType'] = request.aclResourcePatternType;
  }
  if (!Util.isUnset(request.aclResourceType)) {
    query['AclResourceType'] = request.aclResourceType;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.username)) {
    query['Username'] = request.username;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAcl',
    version = '2019-09-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteAcl(request: DeleteAclRequest): DeleteAclResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAclWithOptions(request, runtime);
}

model DeleteConsumerGroupRequest {
  consumerId?: string(name='ConsumerId'),
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
}

model DeleteConsumerGroupResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteConsumerGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteConsumerGroupResponseBody(name='body'),
}

async function deleteConsumerGroupWithOptions(request: DeleteConsumerGroupRequest, runtime: Util.RuntimeOptions): DeleteConsumerGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consumerId)) {
    query['ConsumerId'] = request.consumerId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteConsumerGroup',
    version = '2019-09-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteConsumerGroup(request: DeleteConsumerGroupRequest): DeleteConsumerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteConsumerGroupWithOptions(request, runtime);
}

model DeleteInstanceRequest {
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
}

model DeleteInstanceResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteInstanceResponseBody(name='body'),
}

async function deleteInstanceWithOptions(request: DeleteInstanceRequest, runtime: Util.RuntimeOptions): DeleteInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteInstance',
    version = '2019-09-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteInstance(request: DeleteInstanceRequest): DeleteInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteInstanceWithOptions(request, runtime);
}

model DeleteSaslUserRequest {
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
  type?: string(name='Type'),
  username?: string(name='Username'),
}

model DeleteSaslUserResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteSaslUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSaslUserResponseBody(name='body'),
}

async function deleteSaslUserWithOptions(request: DeleteSaslUserRequest, runtime: Util.RuntimeOptions): DeleteSaslUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.username)) {
    query['Username'] = request.username;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSaslUser',
    version = '2019-09-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSaslUser(request: DeleteSaslUserRequest): DeleteSaslUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSaslUserWithOptions(request, runtime);
}

model DeleteTopicRequest {
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
  topic?: string(name='Topic'),
}

model DeleteTopicResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteTopicResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteTopicResponseBody(name='body'),
}

async function deleteTopicWithOptions(request: DeleteTopicRequest, runtime: Util.RuntimeOptions): DeleteTopicResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.topic)) {
    query['Topic'] = request.topic;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteTopic',
    version = '2019-09-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteTopic(request: DeleteTopicRequest): DeleteTopicResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTopicWithOptions(request, runtime);
}

model DescribeAclsRequest {
  aclResourceName?: string(name='AclResourceName'),
  aclResourcePatternType?: string(name='AclResourcePatternType'),
  aclResourceType?: string(name='AclResourceType'),
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
  username?: string(name='Username'),
}

model DescribeAclsResponseBody = {
  code?: int32(name='Code'),
  kafkaAclList?: {
    kafkaAclVO?: [ 
    {
      aclOperationType?: string(name='AclOperationType'),
      aclResourceName?: string(name='AclResourceName'),
      aclResourcePatternType?: string(name='AclResourcePatternType'),
      aclResourceType?: string(name='AclResourceType'),
      host?: string(name='Host'),
      username?: string(name='Username'),
    }
  ](name='KafkaAclVO')
  }(name='KafkaAclList'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeAclsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAclsResponseBody(name='body'),
}

async function describeAclsWithOptions(request: DescribeAclsRequest, runtime: Util.RuntimeOptions): DescribeAclsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclResourceName)) {
    query['AclResourceName'] = request.aclResourceName;
  }
  if (!Util.isUnset(request.aclResourcePatternType)) {
    query['AclResourcePatternType'] = request.aclResourcePatternType;
  }
  if (!Util.isUnset(request.aclResourceType)) {
    query['AclResourceType'] = request.aclResourceType;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.username)) {
    query['Username'] = request.username;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAcls',
    version = '2019-09-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAcls(request: DescribeAclsRequest): DescribeAclsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAclsWithOptions(request, runtime);
}

model DescribeNodeStatusRequest {
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
}

model DescribeNodeStatusResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  statusList?: {
    status?: [ string ](name='Status')
  }(name='StatusList'),
  success?: boolean(name='Success'),
}

model DescribeNodeStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeNodeStatusResponseBody(name='body'),
}

async function describeNodeStatusWithOptions(request: DescribeNodeStatusRequest, runtime: Util.RuntimeOptions): DescribeNodeStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeNodeStatus',
    version = '2019-09-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeNodeStatus(request: DescribeNodeStatusRequest): DescribeNodeStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeNodeStatusWithOptions(request, runtime);
}

model DescribeSaslUsersRequest {
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
}

model DescribeSaslUsersResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  saslUserList?: {
    saslUserVO?: [ 
    {
      password?: string(name='Password'),
      type?: string(name='Type'),
      username?: string(name='Username'),
    }
  ](name='SaslUserVO')
  }(name='SaslUserList'),
  success?: boolean(name='Success'),
}

model DescribeSaslUsersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSaslUsersResponseBody(name='body'),
}

async function describeSaslUsersWithOptions(request: DescribeSaslUsersRequest, runtime: Util.RuntimeOptions): DescribeSaslUsersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSaslUsers',
    version = '2019-09-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSaslUsers(request: DescribeSaslUsersRequest): DescribeSaslUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSaslUsersWithOptions(request, runtime);
}

model GetAllInstanceIdListRequest {
  regionId?: string(name='RegionId'),
}

model GetAllInstanceIdListResponseBody = {
  code?: int32(name='Code'),
  instanceIds?: map[string]any(name='InstanceIds'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetAllInstanceIdListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAllInstanceIdListResponseBody(name='body'),
}

async function getAllInstanceIdListWithOptions(request: GetAllInstanceIdListRequest, runtime: Util.RuntimeOptions): GetAllInstanceIdListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAllInstanceIdList',
    version = '2019-09-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAllInstanceIdList(request: GetAllInstanceIdListRequest): GetAllInstanceIdListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAllInstanceIdListWithOptions(request, runtime);
}

model GetAllowedIpListRequest {
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
}

model GetAllowedIpListResponseBody = {
  allowedList?: {
    deployType?: int32(name='DeployType'),
    internetList?: [ 
      {
        allowedIpList?: [ string ](name='AllowedIpList'),
        portRange?: string(name='PortRange'),
      }
    ](name='InternetList'),
    vpcList?: [ 
      {
        allowedIpList?: [ string ](name='AllowedIpList'),
        portRange?: string(name='PortRange'),
      }
    ](name='VpcList'),
  }(name='AllowedList'),
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetAllowedIpListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAllowedIpListResponseBody(name='body'),
}

async function getAllowedIpListWithOptions(request: GetAllowedIpListRequest, runtime: Util.RuntimeOptions): GetAllowedIpListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAllowedIpList',
    version = '2019-09-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAllowedIpList(request: GetAllowedIpListRequest): GetAllowedIpListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAllowedIpListWithOptions(request, runtime);
}

model GetConsumerListRequest {
  consumerId?: string(name='ConsumerId'),
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
}

model GetConsumerListResponseBody = {
  code?: int32(name='Code'),
  consumerList?: {
    consumerVO?: [ 
    {
      consumerId?: string(name='ConsumerId'),
      instanceId?: string(name='InstanceId'),
      regionId?: string(name='RegionId'),
      remark?: string(name='Remark'),
      tags?: {
        tagVO?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='TagVO')
      }(name='Tags'),
    }
  ](name='ConsumerVO')
  }(name='ConsumerList'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetConsumerListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetConsumerListResponseBody(name='body'),
}

async function getConsumerListWithOptions(request: GetConsumerListRequest, runtime: Util.RuntimeOptions): GetConsumerListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consumerId)) {
    query['ConsumerId'] = request.consumerId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetConsumerList',
    version = '2019-09-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getConsumerList(request: GetConsumerListRequest): GetConsumerListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getConsumerListWithOptions(request, runtime);
}

model GetConsumerProgressRequest {
  consumerId?: string(name='ConsumerId'),
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
}

model GetConsumerProgressResponseBody = {
  code?: int32(name='Code'),
  consumerProgress?: {
    lastTimestamp?: long(name='LastTimestamp'),
    topicList?: {
      topicList?: [ 
      {
        lastTimestamp?: long(name='LastTimestamp'),
        offsetList?: {
          offsetList?: [ 
          {
            brokerOffset?: long(name='BrokerOffset'),
            consumerOffset?: long(name='ConsumerOffset'),
            lastTimestamp?: long(name='LastTimestamp'),
            partition?: int32(name='Partition'),
          }
        ](name='OffsetList')
        }(name='OffsetList'),
        topic?: string(name='Topic'),
        totalDiff?: long(name='TotalDiff'),
      }
    ](name='TopicList')
    }(name='TopicList'),
    totalDiff?: long(name='TotalDiff'),
  }(name='ConsumerProgress'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetConsumerProgressResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetConsumerProgressResponseBody(name='body'),
}

async function getConsumerProgressWithOptions(request: GetConsumerProgressRequest, runtime: Util.RuntimeOptions): GetConsumerProgressResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consumerId)) {
    query['ConsumerId'] = request.consumerId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetConsumerProgress',
    version = '2019-09-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getConsumerProgress(request: GetConsumerProgressRequest): GetConsumerProgressResponse {
  var runtime = new Util.RuntimeOptions{};
  return getConsumerProgressWithOptions(request, runtime);
}

model GetInstanceListRequest {
  instanceId?: [ string ](name='InstanceId'),
  orderId?: string(name='OrderId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model GetInstanceListResponseBody = {
  code?: int32(name='Code'),
  instanceList?: {
    instanceVO?: [ 
    {
      allConfig?: string(name='AllConfig'),
      createTime?: long(name='CreateTime'),
      deployType?: int32(name='DeployType'),
      diskSize?: int32(name='DiskSize'),
      diskType?: int32(name='DiskType'),
      domainEndpoint?: string(name='DomainEndpoint'),
      eipMax?: int32(name='EipMax'),
      endPoint?: string(name='EndPoint'),
      expiredTime?: long(name='ExpiredTime'),
      instanceId?: string(name='InstanceId'),
      ioMax?: int32(name='IoMax'),
      kmsKeyId?: string(name='KmsKeyId'),
      msgRetain?: int32(name='MsgRetain'),
      name?: string(name='Name'),
      paidType?: int32(name='PaidType'),
      regionId?: string(name='RegionId'),
      resourceGroupId?: string(name='ResourceGroupId'),
      saslDomainEndpoint?: string(name='SaslDomainEndpoint'),
      securityGroup?: string(name='SecurityGroup'),
      serviceStatus?: int32(name='ServiceStatus'),
      specType?: string(name='SpecType'),
      sslDomainEndpoint?: string(name='SslDomainEndpoint'),
      sslEndPoint?: string(name='SslEndPoint'),
      tags?: {
        tagVO?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='TagVO')
      }(name='Tags'),
      topicNumLimit?: int32(name='TopicNumLimit'),
      upgradeServiceDetailInfo?: {
        current2OpenSourceVersion?: string(name='Current2OpenSourceVersion'),
      }(name='UpgradeServiceDetailInfo'),
      usedGroupCount?: int32(name='UsedGroupCount'),
      usedPartitionCount?: int32(name='UsedPartitionCount'),
      usedTopicCount?: int32(name='UsedTopicCount'),
      vSwitchId?: string(name='VSwitchId'),
      vpcId?: string(name='VpcId'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='InstanceVO')
  }(name='InstanceList'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetInstanceListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetInstanceListResponseBody(name='body'),
}

async function getInstanceListWithOptions(request: GetInstanceListRequest, runtime: Util.RuntimeOptions): GetInstanceListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetInstanceList',
    version = '2019-09-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getInstanceList(request: GetInstanceListRequest): GetInstanceListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInstanceListWithOptions(request, runtime);
}

model GetTopicListRequest {
  currentPage?: string(name='CurrentPage'),
  instanceId?: string(name='InstanceId'),
  pageSize?: string(name='PageSize'),
  regionId?: string(name='RegionId'),
  topic?: string(name='Topic'),
}

model GetTopicListResponseBody = {
  code?: int32(name='Code'),
  currentPage?: int32(name='CurrentPage'),
  message?: string(name='Message'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  topicList?: {
    topicVO?: [ 
    {
      compactTopic?: boolean(name='CompactTopic'),
      createTime?: long(name='CreateTime'),
      instanceId?: string(name='InstanceId'),
      localTopic?: boolean(name='LocalTopic'),
      partitionNum?: int32(name='PartitionNum'),
      regionId?: string(name='RegionId'),
      remark?: string(name='Remark'),
      status?: int32(name='Status'),
      statusName?: string(name='StatusName'),
      tags?: {
        tagVO?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='TagVO')
      }(name='Tags'),
      topic?: string(name='Topic'),
    }
  ](name='TopicVO')
  }(name='TopicList'),
  total?: int32(name='Total'),
}

model GetTopicListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTopicListResponseBody(name='body'),
}

async function getTopicListWithOptions(request: GetTopicListRequest, runtime: Util.RuntimeOptions): GetTopicListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.topic)) {
    query['Topic'] = request.topic;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTopicList',
    version = '2019-09-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTopicList(request: GetTopicListRequest): GetTopicListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTopicListWithOptions(request, runtime);
}

model GetTopicStatusRequest {
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
  topic?: string(name='Topic'),
}

model GetTopicStatusResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  topicStatus?: {
    lastTimeStamp?: long(name='LastTimeStamp'),
    offsetTable?: {
      offsetTable?: [ 
      {
        lastUpdateTimestamp?: long(name='LastUpdateTimestamp'),
        maxOffset?: long(name='MaxOffset'),
        minOffset?: long(name='MinOffset'),
        partition?: int32(name='Partition'),
        topic?: string(name='Topic'),
      }
    ](name='OffsetTable')
    }(name='OffsetTable'),
    totalCount?: long(name='TotalCount'),
  }(name='TopicStatus'),
}

model GetTopicStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTopicStatusResponseBody(name='body'),
}

async function getTopicStatusWithOptions(request: GetTopicStatusRequest, runtime: Util.RuntimeOptions): GetTopicStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.topic)) {
    query['Topic'] = request.topic;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTopicStatus',
    version = '2019-09-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTopicStatus(request: GetTopicStatusRequest): GetTopicStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTopicStatusWithOptions(request, runtime);
}

model ListTagResourcesRequest {
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  resourceId?: [ string ](name='ResourceId'),
  resourceType?: string(name='ResourceType'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  tagResources?: {
    tagResource?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='TagResource')
  }(name='TagResources'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagResources',
    version = '2019-09-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagResourcesWithOptions(request, runtime);
}

model ModifyInstanceNameRequest {
  instanceId?: string(name='InstanceId'),
  instanceName?: string(name='InstanceName'),
  regionId?: string(name='RegionId'),
}

model ModifyInstanceNameResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ModifyInstanceNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyInstanceNameResponseBody(name='body'),
}

async function modifyInstanceNameWithOptions(request: ModifyInstanceNameRequest, runtime: Util.RuntimeOptions): ModifyInstanceNameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceName)) {
    query['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyInstanceName',
    version = '2019-09-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyInstanceName(request: ModifyInstanceNameRequest): ModifyInstanceNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyInstanceNameWithOptions(request, runtime);
}

model ModifyPartitionNumRequest {
  addPartitionNum?: int32(name='AddPartitionNum'),
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
  topic?: string(name='Topic'),
}

model ModifyPartitionNumResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ModifyPartitionNumResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyPartitionNumResponseBody(name='body'),
}

async function modifyPartitionNumWithOptions(request: ModifyPartitionNumRequest, runtime: Util.RuntimeOptions): ModifyPartitionNumResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addPartitionNum)) {
    query['AddPartitionNum'] = request.addPartitionNum;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.topic)) {
    query['Topic'] = request.topic;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyPartitionNum',
    version = '2019-09-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyPartitionNum(request: ModifyPartitionNumRequest): ModifyPartitionNumResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyPartitionNumWithOptions(request, runtime);
}

model ModifyTopicRemarkRequest {
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
  remark?: string(name='Remark'),
  topic?: string(name='Topic'),
}

model ModifyTopicRemarkResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ModifyTopicRemarkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyTopicRemarkResponseBody(name='body'),
}

async function modifyTopicRemarkWithOptions(request: ModifyTopicRemarkRequest, runtime: Util.RuntimeOptions): ModifyTopicRemarkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.topic)) {
    query['Topic'] = request.topic;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyTopicRemark',
    version = '2019-09-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyTopicRemark(request: ModifyTopicRemarkRequest): ModifyTopicRemarkResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyTopicRemarkWithOptions(request, runtime);
}

model ReleaseInstanceRequest {
  forceDeleteInstance?: boolean(name='ForceDeleteInstance'),
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
}

model ReleaseInstanceResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ReleaseInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ReleaseInstanceResponseBody(name='body'),
}

async function releaseInstanceWithOptions(request: ReleaseInstanceRequest, runtime: Util.RuntimeOptions): ReleaseInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.forceDeleteInstance)) {
    query['ForceDeleteInstance'] = request.forceDeleteInstance;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ReleaseInstance',
    version = '2019-09-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function releaseInstance(request: ReleaseInstanceRequest): ReleaseInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return releaseInstanceWithOptions(request, runtime);
}

model StartInstanceRequest {
  config?: string(name='Config'),
  deployModule?: string(name='DeployModule'),
  instanceId?: string(name='InstanceId'),
  isEipInner?: boolean(name='IsEipInner'),
  isForceSelectedZones?: boolean(name='IsForceSelectedZones'),
  isSetUserAndPassword?: boolean(name='IsSetUserAndPassword'),
  KMSKeyId?: string(name='KMSKeyId'),
  name?: string(name='Name'),
  notifier?: string(name='Notifier'),
  password?: string(name='Password'),
  regionId?: string(name='RegionId'),
  securityGroup?: string(name='SecurityGroup'),
  selectedZones?: string(name='SelectedZones'),
  serviceVersion?: string(name='ServiceVersion'),
  userPhoneNum?: string(name='UserPhoneNum'),
  username?: string(name='Username'),
  vSwitchId?: string(name='VSwitchId'),
  vpcId?: string(name='VpcId'),
  zoneId?: string(name='ZoneId'),
}

model StartInstanceResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model StartInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartInstanceResponseBody(name='body'),
}

async function startInstanceWithOptions(request: StartInstanceRequest, runtime: Util.RuntimeOptions): StartInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.config)) {
    query['Config'] = request.config;
  }
  if (!Util.isUnset(request.deployModule)) {
    query['DeployModule'] = request.deployModule;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.isEipInner)) {
    query['IsEipInner'] = request.isEipInner;
  }
  if (!Util.isUnset(request.isForceSelectedZones)) {
    query['IsForceSelectedZones'] = request.isForceSelectedZones;
  }
  if (!Util.isUnset(request.isSetUserAndPassword)) {
    query['IsSetUserAndPassword'] = request.isSetUserAndPassword;
  }
  if (!Util.isUnset(request.KMSKeyId)) {
    query['KMSKeyId'] = request.KMSKeyId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.notifier)) {
    query['Notifier'] = request.notifier;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.securityGroup)) {
    query['SecurityGroup'] = request.securityGroup;
  }
  if (!Util.isUnset(request.selectedZones)) {
    query['SelectedZones'] = request.selectedZones;
  }
  if (!Util.isUnset(request.serviceVersion)) {
    query['ServiceVersion'] = request.serviceVersion;
  }
  if (!Util.isUnset(request.userPhoneNum)) {
    query['UserPhoneNum'] = request.userPhoneNum;
  }
  if (!Util.isUnset(request.username)) {
    query['Username'] = request.username;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartInstance',
    version = '2019-09-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startInstance(request: StartInstanceRequest): StartInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return startInstanceWithOptions(request, runtime);
}

model TagResourcesRequest {
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
  resourceId?: [ string ](name='ResourceId'),
  resourceType?: string(name='ResourceType'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResourcesWithOptions(request: TagResourcesRequest, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TagResources',
    version = '2019-09-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagResourcesWithOptions(request, runtime);
}

model UntagResourcesRequest {
  all?: boolean(name='All'),
  regionId?: string(name='RegionId'),
  resourceId?: [ string ](name='ResourceId'),
  resourceType?: string(name='ResourceType'),
  tagKey?: [ string ](name='TagKey'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResourcesWithOptions(request: UntagResourcesRequest, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.all)) {
    query['All'] = request.all;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagKey)) {
    query['TagKey'] = request.tagKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UntagResources',
    version = '2019-09-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return untagResourcesWithOptions(request, runtime);
}

model UpdateAllowedIpRequest {
  allowedListIp?: string(name='AllowedListIp'),
  allowedListType?: string(name='AllowedListType'),
  instanceId?: string(name='InstanceId'),
  portRange?: string(name='PortRange'),
  regionId?: string(name='RegionId'),
  updateType?: string(name='UpdateType'),
}

model UpdateAllowedIpResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateAllowedIpResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAllowedIpResponseBody(name='body'),
}

async function updateAllowedIpWithOptions(request: UpdateAllowedIpRequest, runtime: Util.RuntimeOptions): UpdateAllowedIpResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.allowedListIp)) {
    query['AllowedListIp'] = request.allowedListIp;
  }
  if (!Util.isUnset(request.allowedListType)) {
    query['AllowedListType'] = request.allowedListType;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.portRange)) {
    query['PortRange'] = request.portRange;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.updateType)) {
    query['UpdateType'] = request.updateType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAllowedIp',
    version = '2019-09-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAllowedIp(request: UpdateAllowedIpRequest): UpdateAllowedIpResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAllowedIpWithOptions(request, runtime);
}

model UpdateInstanceConfigRequest {
  config?: string(name='Config'),
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
}

model UpdateInstanceConfigResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateInstanceConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateInstanceConfigResponseBody(name='body'),
}

async function updateInstanceConfigWithOptions(request: UpdateInstanceConfigRequest, runtime: Util.RuntimeOptions): UpdateInstanceConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.config)) {
    query['Config'] = request.config;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateInstanceConfig',
    version = '2019-09-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateInstanceConfig(request: UpdateInstanceConfigRequest): UpdateInstanceConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateInstanceConfigWithOptions(request, runtime);
}

model UpgradeInstanceVersionRequest {
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
  targetVersion?: string(name='TargetVersion'),
}

model UpgradeInstanceVersionResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpgradeInstanceVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpgradeInstanceVersionResponseBody(name='body'),
}

async function upgradeInstanceVersionWithOptions(request: UpgradeInstanceVersionRequest, runtime: Util.RuntimeOptions): UpgradeInstanceVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.targetVersion)) {
    query['TargetVersion'] = request.targetVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpgradeInstanceVersion',
    version = '2019-09-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function upgradeInstanceVersion(request: UpgradeInstanceVersionRequest): UpgradeInstanceVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeInstanceVersionWithOptions(request, runtime);
}

model UpgradePostPayOrderRequest {
  diskSize?: int32(name='DiskSize'),
  eipMax?: int32(name='EipMax'),
  eipModel?: boolean(name='EipModel'),
  instanceId?: string(name='InstanceId'),
  ioMax?: int32(name='IoMax'),
  ioMaxSpec?: string(name='IoMaxSpec'),
  partitionNum?: int32(name='PartitionNum'),
  regionId?: string(name='RegionId'),
  specType?: string(name='SpecType'),
  topicQuota?: int32(name='TopicQuota'),
}

model UpgradePostPayOrderResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpgradePostPayOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpgradePostPayOrderResponseBody(name='body'),
}

async function upgradePostPayOrderWithOptions(request: UpgradePostPayOrderRequest, runtime: Util.RuntimeOptions): UpgradePostPayOrderResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.diskSize)) {
    query['DiskSize'] = request.diskSize;
  }
  if (!Util.isUnset(request.eipMax)) {
    query['EipMax'] = request.eipMax;
  }
  if (!Util.isUnset(request.eipModel)) {
    query['EipModel'] = request.eipModel;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ioMax)) {
    query['IoMax'] = request.ioMax;
  }
  if (!Util.isUnset(request.ioMaxSpec)) {
    query['IoMaxSpec'] = request.ioMaxSpec;
  }
  if (!Util.isUnset(request.partitionNum)) {
    query['PartitionNum'] = request.partitionNum;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.specType)) {
    query['SpecType'] = request.specType;
  }
  if (!Util.isUnset(request.topicQuota)) {
    query['TopicQuota'] = request.topicQuota;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpgradePostPayOrder',
    version = '2019-09-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function upgradePostPayOrder(request: UpgradePostPayOrderRequest): UpgradePostPayOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradePostPayOrderWithOptions(request, runtime);
}

model UpgradePrePayOrderRequest {
  diskSize?: int32(name='DiskSize'),
  eipMax?: int32(name='EipMax'),
  eipModel?: boolean(name='EipModel'),
  instanceId?: string(name='InstanceId'),
  ioMax?: int32(name='IoMax'),
  ioMaxSpec?: string(name='IoMaxSpec'),
  partitionNum?: int32(name='PartitionNum'),
  regionId?: string(name='RegionId'),
  specType?: string(name='SpecType'),
  topicQuota?: int32(name='TopicQuota'),
}

model UpgradePrePayOrderResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpgradePrePayOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpgradePrePayOrderResponseBody(name='body'),
}

async function upgradePrePayOrderWithOptions(request: UpgradePrePayOrderRequest, runtime: Util.RuntimeOptions): UpgradePrePayOrderResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.diskSize)) {
    query['DiskSize'] = request.diskSize;
  }
  if (!Util.isUnset(request.eipMax)) {
    query['EipMax'] = request.eipMax;
  }
  if (!Util.isUnset(request.eipModel)) {
    query['EipModel'] = request.eipModel;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ioMax)) {
    query['IoMax'] = request.ioMax;
  }
  if (!Util.isUnset(request.ioMaxSpec)) {
    query['IoMaxSpec'] = request.ioMaxSpec;
  }
  if (!Util.isUnset(request.partitionNum)) {
    query['PartitionNum'] = request.partitionNum;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.specType)) {
    query['SpecType'] = request.specType;
  }
  if (!Util.isUnset(request.topicQuota)) {
    query['TopicQuota'] = request.topicQuota;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpgradePrePayOrder',
    version = '2019-09-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function upgradePrePayOrder(request: UpgradePrePayOrderRequest): UpgradePrePayOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradePrePayOrderWithOptions(request, runtime);
}

