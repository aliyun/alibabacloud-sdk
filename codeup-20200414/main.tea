/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @signatureAlgorithm = 'v2';
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('codeup', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AcceptMergeRequestRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
}

model AcceptMergeRequestResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    acceptedRevision?: string(name='AcceptedRevision'),
    aheadCommitCount?: int32(name='AheadCommitCount'),
    approveCheckResult?: {
      satisfiedCheckResults?: [ 
        {
          checkName?: string(name='CheckName'),
          checkStatus?: string(name='CheckStatus'),
          checkType?: string(name='CheckType'),
          extraUsers?: [ 
            {
              avatarUrl?: string(name='AvatarUrl'),
              externUserId?: string(name='ExternUserId'),
              id?: long(name='Id'),
              name?: string(name='Name'),
            }
          ](name='ExtraUsers'),
          satisfiedItems?: [ string ](name='SatisfiedItems'),
          unsatisfiedItems?: [ string ](name='UnsatisfiedItems'),
        }
      ](name='SatisfiedCheckResults'),
      totalCheckResult?: string(name='TotalCheckResult'),
      unsatisfiedCheckResults?: [ 
        {
          checkName?: string(name='CheckName'),
          checkStatus?: string(name='CheckStatus'),
          checkType?: string(name='CheckType'),
          extraUsers?: [ 
            {
              avatarUrl?: string(name='AvatarUrl'),
              externUserId?: string(name='ExternUserId'),
              id?: long(name='Id'),
              name?: string(name='Name'),
            }
          ](name='ExtraUsers'),
          satisfiedItems?: [ string ](name='SatisfiedItems'),
          unsatisfiedItems?: [ string ](name='UnsatisfiedItems'),
        }
      ](name='UnsatisfiedCheckResults'),
    }(name='ApproveCheckResult'),
    assigneeList?: [ 
      {
        avatarUrl?: string(name='AvatarUrl'),
        externUserId?: string(name='ExternUserId'),
        id?: string(name='Id'),
        name?: string(name='Name'),
      }
    ](name='AssigneeList'),
    author?: {
      avatarUrl?: string(name='AvatarUrl'),
      externUserId?: string(name='ExternUserId'),
      id?: long(name='Id'),
      name?: string(name='Name'),
    }(name='Author'),
    behindCommitCount?: int32(name='BehindCommitCount'),
    createdAt?: string(name='CreatedAt'),
    description?: string(name='Description'),
    id?: long(name='Id'),
    mergeError?: string(name='MergeError'),
    mergeStatus?: string(name='MergeStatus'),
    mergeType?: string(name='MergeType'),
    mergedRevision?: string(name='MergedRevision'),
    nameWithNamespace?: string(name='NameWithNamespace'),
    projectId?: long(name='ProjectId'),
    sourceBranch?: string(name='SourceBranch'),
    state?: string(name='State'),
    targetBranch?: string(name='TargetBranch'),
    title?: string(name='Title'),
    updatedAt?: string(name='UpdatedAt'),
    webUrl?: string(name='WebUrl'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model AcceptMergeRequestResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AcceptMergeRequestResponseBody(name='body'),
}

async function acceptMergeRequest(ProjectId: string, MergeRequestId: string, request: AcceptMergeRequestRequest): AcceptMergeRequestResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return acceptMergeRequestWithOptions(ProjectId, MergeRequestId, request, headers, runtime);
}

async function acceptMergeRequestWithOptions(ProjectId: string, MergeRequestId: string, request: AcceptMergeRequestRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AcceptMergeRequestResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AcceptMergeRequest',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v3/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/merge_request/${OpenApiUtil.getEncodeParam(MergeRequestId)}/accept`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model AddGroupMemberRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model AddGroupMemberResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      accessLevel?: int32(name='AccessLevel'),
      avatarUrl?: string(name='AvatarUrl'),
      email?: string(name='Email'),
      externUserId?: string(name='ExternUserId'),
      id?: long(name='Id'),
      state?: string(name='State'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
}

model AddGroupMemberResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddGroupMemberResponseBody(name='body'),
}

async function addGroupMember(GroupId: string, request: AddGroupMemberRequest): AddGroupMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addGroupMemberWithOptions(GroupId, request, headers, runtime);
}

async function addGroupMemberWithOptions(GroupId: string, request: AddGroupMemberRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddGroupMemberResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query['SubUserId'] = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddGroupMember',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v4/groups/${OpenApiUtil.getEncodeParam(GroupId)}/members`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model AddRepositoryMemberRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model AddRepositoryMemberResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      accessLevel?: int32(name='AccessLevel'),
      avatarUrl?: string(name='AvatarUrl'),
      email?: string(name='Email'),
      externUserId?: string(name='ExternUserId'),
      id?: long(name='Id'),
      state?: string(name='State'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
}

model AddRepositoryMemberResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddRepositoryMemberResponseBody(name='body'),
}

async function addRepositoryMember(ProjectId: string, request: AddRepositoryMemberRequest): AddRepositoryMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addRepositoryMemberWithOptions(ProjectId, request, headers, runtime);
}

async function addRepositoryMemberWithOptions(ProjectId: string, request: AddRepositoryMemberRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddRepositoryMemberResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query['SubUserId'] = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddRepositoryMember',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v4/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/members`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model AddWebhookRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
}

model AddWebhookResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    buildEvents?: boolean(name='BuildEvents'),
    createdAt?: string(name='CreatedAt'),
    description?: string(name='Description'),
    enableSslVerification?: boolean(name='EnableSslVerification'),
    id?: long(name='Id'),
    issuesEvents?: boolean(name='IssuesEvents'),
    lastTestResult?: string(name='LastTestResult'),
    mergeRequestsEvents?: boolean(name='MergeRequestsEvents'),
    noteEvents?: boolean(name='NoteEvents'),
    projectId?: long(name='ProjectId'),
    pushEvents?: boolean(name='PushEvents'),
    secretToken?: string(name='SecretToken'),
    tagPushEvents?: boolean(name='TagPushEvents'),
    url?: string(name='Url'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model AddWebhookResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddWebhookResponseBody(name='body'),
}

async function addWebhook(ProjectId: string, request: AddWebhookRequest): AddWebhookResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addWebhookWithOptions(ProjectId, request, headers, runtime);
}

async function addWebhookWithOptions(ProjectId: string, request: AddWebhookRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddWebhookResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddWebhook',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v3/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/hooks`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateBranchRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
  branchName?: string(name='branchName'),
  ref?: string(name='ref'),
}

model CreateBranchResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    branchName?: string(name='BranchName'),
    commitInfo?: {
      authorDate?: string(name='AuthorDate'),
      authorEmail?: string(name='AuthorEmail'),
      authorName?: string(name='AuthorName'),
      committedDate?: string(name='CommittedDate'),
      committerEmail?: string(name='CommitterEmail'),
      committerName?: string(name='CommitterName'),
      createdAt?: string(name='CreatedAt'),
      id?: string(name='Id'),
      message?: string(name='Message'),
      parentIds?: [ string ](name='ParentIds'),
      shortId?: string(name='ShortId'),
      title?: string(name='Title'),
    }(name='CommitInfo'),
    protectedBranch?: boolean(name='ProtectedBranch'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model CreateBranchResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateBranchResponseBody(name='body'),
}

async function createBranch(ProjectId: string, request: CreateBranchRequest): CreateBranchResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createBranchWithOptions(ProjectId, request, headers, runtime);
}

async function createBranchWithOptions(ProjectId: string, request: CreateBranchRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateBranchResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query['SubUserId'] = request.subUserId;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.branchName)) {
    body['branchName'] = request.branchName;
  }
  if (!Util.isUnset(request.ref)) {
    body['ref'] = request.ref;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateBranch',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v3/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/repository/branches`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateFileRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model CreateFileResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    branchName?: string(name='BranchName'),
    filePath?: string(name='FilePath'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model CreateFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateFileResponseBody(name='body'),
}

async function createFile(ProjectId: string, request: CreateFileRequest): CreateFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createFileWithOptions(ProjectId, request, headers, runtime);
}

async function createFileWithOptions(ProjectId: string, request: CreateFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateFileResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query['SubUserId'] = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateFile',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v3/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/repository/files`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateMergeRequestRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model CreateMergeRequestResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    acceptedRevision?: string(name='AcceptedRevision'),
    aheadCommitCount?: int32(name='AheadCommitCount'),
    approveCheckResult?: {
      satisfiedCheckResults?: [ 
        {
          checkName?: string(name='CheckName'),
          checkStatus?: string(name='CheckStatus'),
          checkType?: string(name='CheckType'),
          extraUsers?: [ 
            {
              avatarUrl?: string(name='AvatarUrl'),
              externUserId?: string(name='ExternUserId'),
              id?: long(name='Id'),
              name?: string(name='Name'),
            }
          ](name='ExtraUsers'),
          satisfiedItems?: [ string ](name='SatisfiedItems'),
          unsatisfiedItems?: [ string ](name='UnsatisfiedItems'),
        }
      ](name='SatisfiedCheckResults'),
      totalCheckResult?: string(name='TotalCheckResult'),
      unsatisfiedCheckResults?: [ 
        {
          checkName?: string(name='CheckName'),
          checkStatus?: string(name='CheckStatus'),
          checkType?: string(name='CheckType'),
          extraUsers?: [ 
            {
              avatarUrl?: string(name='AvatarUrl'),
              externUserId?: string(name='ExternUserId'),
              id?: long(name='Id'),
              name?: string(name='Name'),
            }
          ](name='ExtraUsers'),
          satisfiedItems?: [ string ](name='SatisfiedItems'),
          unsatisfiedItems?: [ string ](name='UnsatisfiedItems'),
        }
      ](name='UnsatisfiedCheckResults'),
    }(name='ApproveCheckResult'),
    assigneeList?: [ 
      {
        avatarUrl?: string(name='AvatarUrl'),
        externUserId?: string(name='ExternUserId'),
        id?: string(name='Id'),
        name?: string(name='Name'),
      }
    ](name='AssigneeList'),
    author?: {
      avatarUrl?: string(name='AvatarUrl'),
      externUserId?: string(name='ExternUserId'),
      id?: long(name='Id'),
      name?: string(name='Name'),
    }(name='Author'),
    behindCommitCount?: int32(name='BehindCommitCount'),
    createdAt?: string(name='CreatedAt'),
    description?: string(name='Description'),
    id?: long(name='Id'),
    mergeError?: string(name='MergeError'),
    mergeStatus?: string(name='MergeStatus'),
    mergeType?: string(name='MergeType'),
    mergedRevision?: string(name='MergedRevision'),
    nameWithNamespace?: string(name='NameWithNamespace'),
    projectId?: long(name='ProjectId'),
    sourceBranch?: string(name='SourceBranch'),
    state?: string(name='State'),
    targetBranch?: string(name='TargetBranch'),
    title?: string(name='Title'),
    updatedAt?: string(name='UpdatedAt'),
    webUrl?: string(name='WebUrl'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model CreateMergeRequestResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateMergeRequestResponseBody(name='body'),
}

async function createMergeRequest(ProjectId: string, request: CreateMergeRequestRequest): CreateMergeRequestResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createMergeRequestWithOptions(ProjectId, request, headers, runtime);
}

async function createMergeRequestWithOptions(ProjectId: string, request: CreateMergeRequestRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateMergeRequestResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query['SubUserId'] = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateMergeRequest',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v4/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/merge_requests`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateMergeRequestCommentRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
}

model CreateMergeRequestCommentResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    author?: {
      avatarUrl?: string(name='AvatarUrl'),
      email?: string(name='Email'),
      externUserId?: string(name='ExternUserId'),
      id?: long(name='Id'),
      name?: string(name='Name'),
    }(name='Author'),
    closed?: int32(name='Closed'),
    createdAt?: string(name='CreatedAt'),
    id?: long(name='Id'),
    isDraft?: boolean(name='IsDraft'),
    line?: long(name='Line'),
    note?: string(name='Note'),
    outDated?: boolean(name='OutDated'),
    parentNoteId?: long(name='ParentNoteId'),
    path?: string(name='Path'),
    projectId?: long(name='ProjectId'),
    rangeContext?: string(name='RangeContext'),
    side?: string(name='Side'),
    updatedAt?: string(name='UpdatedAt'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model CreateMergeRequestCommentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateMergeRequestCommentResponseBody(name='body'),
}

async function createMergeRequestComment(ProjectId: string, MergeRequestId: string, request: CreateMergeRequestCommentRequest): CreateMergeRequestCommentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createMergeRequestCommentWithOptions(ProjectId, MergeRequestId, request, headers, runtime);
}

async function createMergeRequestCommentWithOptions(ProjectId: string, MergeRequestId: string, request: CreateMergeRequestCommentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateMergeRequestCommentResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateMergeRequestComment',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v4/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/merge_request/${OpenApiUtil.getEncodeParam(MergeRequestId)}/comments`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateRepositoryRequest {
  accessToken?: string(name='AccessToken'),
  createParentPath?: boolean(name='CreateParentPath'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
  sync?: boolean(name='Sync'),
  avatarUrl?: string(name='avatarUrl'),
  description?: string(name='description'),
  gitignoreType?: string(name='gitignoreType'),
  importAccount?: string(name='importAccount'),
  importDemoProject?: boolean(name='importDemoProject'),
  importRepoType?: string(name='importRepoType'),
  importToken?: string(name='importToken'),
  importTokenEncrypted?: string(name='importTokenEncrypted'),
  importUrl?: string(name='importUrl'),
  initStandardService?: boolean(name='initStandardService'),
  isCryptoEnabled?: boolean(name='isCryptoEnabled'),
  localImportUrl?: string(name='localImportUrl'),
  name?: string(name='name'),
  namespaceId?: long(name='namespaceId'),
  path?: string(name='path'),
  readmeType?: string(name='readmeType'),
  visibilityLevel?: int32(name='visibilityLevel'),
}

model CreateRepositoryResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    archive?: boolean(name='Archive'),
    avatarUrl?: string(name='AvatarUrl'),
    buildsEnableStatus?: boolean(name='BuildsEnableStatus'),
    createdAt?: string(name='CreatedAt'),
    creatorId?: long(name='CreatorId'),
    defaultBranch?: string(name='DefaultBranch'),
    demoProjectStatus?: boolean(name='DemoProjectStatus'),
    description?: string(name='Description'),
    httpUrlToRepo?: string(name='HttpUrlToRepo'),
    id?: long(name='Id'),
    issuesEnableStatus?: boolean(name='IssuesEnableStatus'),
    lastActivityAt?: string(name='LastActivityAt'),
    mergeRequestEnableStatus?: boolean(name='MergeRequestEnableStatus'),
    name?: string(name='Name'),
    nameWithNamespace?: string(name='NameWithNamespace'),
    namespace?: {
      avatar?: string(name='Avatar'),
      createdAt?: string(name='CreatedAt'),
      description?: string(name='Description'),
      id?: long(name='Id'),
      name?: string(name='Name'),
      ownerId?: long(name='OwnerId'),
      path?: string(name='Path'),
      public?: boolean(name='Public'),
      state?: string(name='State'),
      updatedAt?: string(name='UpdatedAt'),
      visibilityLevel?: string(name='VisibilityLevel'),
    }(name='Namespace'),
    path?: string(name='Path'),
    pathWithNamespace?: string(name='PathWithNamespace'),
    public?: boolean(name='Public'),
    snippetsEnableStatus?: boolean(name='SnippetsEnableStatus'),
    sshUrlToRepo?: string(name='SshUrlToRepo'),
    tagList?: [ string ](name='TagList'),
    visibilityLevel?: string(name='VisibilityLevel'),
    webUrl?: string(name='WebUrl'),
    wikiEnableStatus?: boolean(name='WikiEnableStatus'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model CreateRepositoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRepositoryResponseBody(name='body'),
}

async function createRepository(request: CreateRepositoryRequest): CreateRepositoryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createRepositoryWithOptions(request, headers, runtime);
}

async function createRepositoryWithOptions(request: CreateRepositoryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateRepositoryResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.createParentPath)) {
    query['CreateParentPath'] = request.createParentPath;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query['SubUserId'] = request.subUserId;
  }
  if (!Util.isUnset(request.sync)) {
    query['Sync'] = request.sync;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.avatarUrl)) {
    body['avatarUrl'] = request.avatarUrl;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.gitignoreType)) {
    body['gitignoreType'] = request.gitignoreType;
  }
  if (!Util.isUnset(request.importAccount)) {
    body['importAccount'] = request.importAccount;
  }
  if (!Util.isUnset(request.importDemoProject)) {
    body['importDemoProject'] = request.importDemoProject;
  }
  if (!Util.isUnset(request.importRepoType)) {
    body['importRepoType'] = request.importRepoType;
  }
  if (!Util.isUnset(request.importToken)) {
    body['importToken'] = request.importToken;
  }
  if (!Util.isUnset(request.importTokenEncrypted)) {
    body['importTokenEncrypted'] = request.importTokenEncrypted;
  }
  if (!Util.isUnset(request.importUrl)) {
    body['importUrl'] = request.importUrl;
  }
  if (!Util.isUnset(request.initStandardService)) {
    body['initStandardService'] = request.initStandardService;
  }
  if (!Util.isUnset(request.isCryptoEnabled)) {
    body['isCryptoEnabled'] = request.isCryptoEnabled;
  }
  if (!Util.isUnset(request.localImportUrl)) {
    body['localImportUrl'] = request.localImportUrl;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.namespaceId)) {
    body['namespaceId'] = request.namespaceId;
  }
  if (!Util.isUnset(request.path)) {
    body['path'] = request.path;
  }
  if (!Util.isUnset(request.readmeType)) {
    body['readmeType'] = request.readmeType;
  }
  if (!Util.isUnset(request.visibilityLevel)) {
    body['visibilityLevel'] = request.visibilityLevel;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateRepository',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v3/projects`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateRepositoryDeployKeyRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model CreateRepositoryDeployKeyResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    createdAt?: string(name='CreatedAt'),
    fingerPrint?: string(name='FingerPrint'),
    id?: long(name='Id'),
    key?: string(name='Key'),
    title?: string(name='Title'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model CreateRepositoryDeployKeyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRepositoryDeployKeyResponseBody(name='body'),
}

async function createRepositoryDeployKey(ProjectId: string, request: CreateRepositoryDeployKeyRequest): CreateRepositoryDeployKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createRepositoryDeployKeyWithOptions(ProjectId, request, headers, runtime);
}

async function createRepositoryDeployKeyWithOptions(ProjectId: string, request: CreateRepositoryDeployKeyRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateRepositoryDeployKeyResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query['SubUserId'] = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateRepositoryDeployKey',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v3/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/keys`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateRepositoryGroupRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model CreateRepositoryGroupResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    avatarUrl?: string(name='AvatarUrl'),
    description?: string(name='Description'),
    id?: long(name='Id'),
    name?: string(name='Name'),
    nameWithNamespace?: string(name='NameWithNamespace'),
    ownerId?: long(name='OwnerId'),
    parentId?: long(name='ParentId'),
    path?: string(name='Path'),
    pathWithNamespace?: string(name='PathWithNamespace'),
    type?: string(name='Type'),
    visibilityLevel?: string(name='VisibilityLevel'),
    webUrl?: string(name='WebUrl'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model CreateRepositoryGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRepositoryGroupResponseBody(name='body'),
}

async function createRepositoryGroup(request: CreateRepositoryGroupRequest): CreateRepositoryGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createRepositoryGroupWithOptions(request, headers, runtime);
}

async function createRepositoryGroupWithOptions(request: CreateRepositoryGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateRepositoryGroupResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query['SubUserId'] = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateRepositoryGroup',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v3/groups`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateRepositoryProtectedBranchRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
}

model CreateRepositoryProtectedBranchResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    allowMergeRoles?: [ int32 ](name='AllowMergeRoles'),
    allowPushRoles?: [ int32 ](name='AllowPushRoles'),
    branch?: string(name='Branch'),
    id?: long(name='Id'),
    mergeRequestSetting?: {
      allowMergeRequestRoles?: [ int32 ](name='AllowMergeRequestRoles'),
      allowSelfApproval?: boolean(name='AllowSelfApproval'),
      defaultAssignees?: [ string ](name='DefaultAssignees'),
      isRequireDiscussionProcessed?: boolean(name='IsRequireDiscussionProcessed'),
      isResetApprovalWhenNewPush?: boolean(name='IsResetApprovalWhenNewPush'),
      mergeRequestMode?: string(name='MergeRequestMode'),
      minimualApproval?: int32(name='MinimualApproval'),
      required?: boolean(name='Required'),
    }(name='MergeRequestSetting'),
    testSetting?: {
      checkConfig?: {
        checkItems?: [ 
          {
            name?: string(name='Name'),
            required?: boolean(name='Required'),
          }
        ](name='CheckItems'),
      }(name='CheckConfig'),
      codingGuidelinesDetection?: {
        enabled?: boolean(name='Enabled'),
        message?: string(name='Message'),
      }(name='CodingGuidelinesDetection'),
      required?: boolean(name='Required'),
      sensitiveInfoDetection?: {
        enabled?: boolean(name='Enabled'),
        message?: string(name='Message'),
      }(name='SensitiveInfoDetection'),
    }(name='TestSetting'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model CreateRepositoryProtectedBranchResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRepositoryProtectedBranchResponseBody(name='body'),
}

async function createRepositoryProtectedBranch(ProjectId: string, request: CreateRepositoryProtectedBranchRequest): CreateRepositoryProtectedBranchResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createRepositoryProtectedBranchWithOptions(ProjectId, request, headers, runtime);
}

async function createRepositoryProtectedBranchWithOptions(ProjectId: string, request: CreateRepositoryProtectedBranchRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateRepositoryProtectedBranchResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateRepositoryProtectedBranch',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v4/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/repository/protect_branches`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateSshKeyRequest {
  accessToken?: string(name='AccessToken'),
}

model CreateSshKeyResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    createdAt?: string(name='CreatedAt'),
    fingerPrint?: string(name='FingerPrint'),
    id?: long(name='Id'),
    key?: string(name='Key'),
    keyScope?: string(name='KeyScope'),
    title?: string(name='Title'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model CreateSshKeyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSshKeyResponseBody(name='body'),
}

async function createSshKey(request: CreateSshKeyRequest): CreateSshKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createSshKeyWithOptions(request, headers, runtime);
}

async function createSshKeyWithOptions(request: CreateSshKeyRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateSshKeyResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateSshKey',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v3/user/keys`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateTagRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model CreateTagResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    commitInfo?: {
      authorEmail?: string(name='AuthorEmail'),
      authorName?: string(name='AuthorName'),
      authoredDate?: string(name='AuthoredDate'),
      committedDate?: string(name='CommittedDate'),
      committerEmail?: string(name='CommitterEmail'),
      committerName?: string(name='CommitterName'),
      createdAt?: string(name='CreatedAt'),
      id?: string(name='Id'),
      message?: string(name='Message'),
      parentIds?: [ string ](name='ParentIds'),
      shortId?: string(name='ShortId'),
      title?: string(name='Title'),
    }(name='CommitInfo'),
    message?: string(name='Message'),
    name?: string(name='Name'),
    release?: {
      description?: string(name='Description'),
      tagName?: string(name='TagName'),
    }(name='Release'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model CreateTagResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateTagResponseBody(name='body'),
}

async function createTag(ProjectId: string, request: CreateTagRequest): CreateTagResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createTagWithOptions(ProjectId, request, headers, runtime);
}

async function createTagWithOptions(ProjectId: string, request: CreateTagRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateTagResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query['SubUserId'] = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateTag',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v3/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/repository/tags`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteBranchRequest {
  accessToken?: string(name='AccessToken'),
  branchName?: string(name='BranchName'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model DeleteBranchResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    branchName?: string(name='BranchName'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model DeleteBranchResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteBranchResponseBody(name='body'),
}

async function deleteBranch(ProjectId: string, request: DeleteBranchRequest): DeleteBranchResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteBranchWithOptions(ProjectId, request, headers, runtime);
}

async function deleteBranchWithOptions(ProjectId: string, request: DeleteBranchRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteBranchResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.branchName)) {
    query['BranchName'] = request.branchName;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query['SubUserId'] = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteBranch',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v3/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/repository/branches/delete`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteFileRequest {
  accessToken?: string(name='AccessToken'),
  branchName?: string(name='BranchName'),
  commitMessage?: string(name='CommitMessage'),
  filePath?: string(name='FilePath'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model DeleteFileResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    branchName?: string(name='BranchName'),
    filePath?: string(name='FilePath'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model DeleteFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteFileResponseBody(name='body'),
}

async function deleteFile(ProjectId: string, request: DeleteFileRequest): DeleteFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteFileWithOptions(ProjectId, request, headers, runtime);
}

async function deleteFileWithOptions(ProjectId: string, request: DeleteFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteFileResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.branchName)) {
    query['BranchName'] = request.branchName;
  }
  if (!Util.isUnset(request.commitMessage)) {
    query['CommitMessage'] = request.commitMessage;
  }
  if (!Util.isUnset(request.filePath)) {
    query['FilePath'] = request.filePath;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query['SubUserId'] = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFile',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v3/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/repository/files`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteGroupMemberRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model DeleteGroupMemberResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    accessLevel?: int32(name='AccessLevel'),
    avatarUrl?: string(name='AvatarUrl'),
    email?: string(name='Email'),
    externUserId?: string(name='ExternUserId'),
    id?: long(name='Id'),
    state?: string(name='State'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model DeleteGroupMemberResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteGroupMemberResponseBody(name='body'),
}

async function deleteGroupMember(GroupId: string, UserId: string, request: DeleteGroupMemberRequest): DeleteGroupMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteGroupMemberWithOptions(GroupId, UserId, request, headers, runtime);
}

async function deleteGroupMemberWithOptions(GroupId: string, UserId: string, request: DeleteGroupMemberRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteGroupMemberResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query['SubUserId'] = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGroupMember',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v3/groups/${OpenApiUtil.getEncodeParam(GroupId)}/members/${OpenApiUtil.getEncodeParam(UserId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteRepositoryRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model DeleteRepositoryResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    result?: boolean(name='Result'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model DeleteRepositoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteRepositoryResponseBody(name='body'),
}

async function deleteRepository(ProjectId: string, request: DeleteRepositoryRequest): DeleteRepositoryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteRepositoryWithOptions(ProjectId, request, headers, runtime);
}

async function deleteRepositoryWithOptions(ProjectId: string, request: DeleteRepositoryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteRepositoryResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query['SubUserId'] = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRepository',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v3/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/remove`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteRepositoryGroupRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model DeleteRepositoryGroupResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    result?: boolean(name='Result'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model DeleteRepositoryGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteRepositoryGroupResponseBody(name='body'),
}

async function deleteRepositoryGroup(GroupId: string, request: DeleteRepositoryGroupRequest): DeleteRepositoryGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteRepositoryGroupWithOptions(GroupId, request, headers, runtime);
}

async function deleteRepositoryGroupWithOptions(GroupId: string, request: DeleteRepositoryGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteRepositoryGroupResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query['SubUserId'] = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRepositoryGroup',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v3/groups/${OpenApiUtil.getEncodeParam(GroupId)}/remove`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteRepositoryMemberRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model DeleteRepositoryMemberResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    accessLevel?: int32(name='AccessLevel'),
    createdAt?: string(name='CreatedAt'),
    id?: long(name='Id'),
    message?: string(name='Message'),
    notificationLevel?: int32(name='NotificationLevel'),
    sourceId?: long(name='SourceId'),
    sourceType?: string(name='SourceType'),
    updatedAt?: string(name='UpdatedAt'),
    userId?: long(name='UserId'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model DeleteRepositoryMemberResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteRepositoryMemberResponseBody(name='body'),
}

async function deleteRepositoryMember(ProjectId: string, UserId: string, request: DeleteRepositoryMemberRequest): DeleteRepositoryMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteRepositoryMemberWithOptions(ProjectId, UserId, request, headers, runtime);
}

async function deleteRepositoryMemberWithOptions(ProjectId: string, UserId: string, request: DeleteRepositoryMemberRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteRepositoryMemberResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query['SubUserId'] = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRepositoryMember',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v3/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/members/${OpenApiUtil.getEncodeParam(UserId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteRepositoryMemberWithExternUidRequest {
  accessToken?: string(name='AccessToken'),
  externUserId?: string(name='ExternUserId'),
  organizationId?: string(name='OrganizationId'),
}

model DeleteRepositoryMemberWithExternUidResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    accessLevel?: int32(name='AccessLevel'),
    createdAt?: string(name='CreatedAt'),
    id?: long(name='Id'),
    sourceId?: long(name='SourceId'),
    sourceType?: string(name='SourceType'),
    updatedAt?: string(name='UpdatedAt'),
    userId?: long(name='UserId'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model DeleteRepositoryMemberWithExternUidResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteRepositoryMemberWithExternUidResponseBody(name='body'),
}

async function deleteRepositoryMemberWithExternUid(ProjectId: string, request: DeleteRepositoryMemberWithExternUidRequest): DeleteRepositoryMemberWithExternUidResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteRepositoryMemberWithExternUidWithOptions(ProjectId, request, headers, runtime);
}

async function deleteRepositoryMemberWithExternUidWithOptions(ProjectId: string, request: DeleteRepositoryMemberWithExternUidRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteRepositoryMemberWithExternUidResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.externUserId)) {
    query['ExternUserId'] = request.externUserId;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRepositoryMemberWithExternUid',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v4/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/members/remove`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteRepositoryProtectedBranchRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
}

model DeleteRepositoryProtectedBranchResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    result?: boolean(name='Result'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model DeleteRepositoryProtectedBranchResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteRepositoryProtectedBranchResponseBody(name='body'),
}

async function deleteRepositoryProtectedBranch(ProjectId: string, ProtectedBranchId: string, request: DeleteRepositoryProtectedBranchRequest): DeleteRepositoryProtectedBranchResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteRepositoryProtectedBranchWithOptions(ProjectId, ProtectedBranchId, request, headers, runtime);
}

async function deleteRepositoryProtectedBranchWithOptions(ProjectId: string, ProtectedBranchId: string, request: DeleteRepositoryProtectedBranchRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteRepositoryProtectedBranchResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRepositoryProtectedBranch',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v4/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/repository/protect_branches/${OpenApiUtil.getEncodeParam(ProtectedBranchId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteRepositoryTagRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
}

model DeleteRepositoryTagResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    tagName?: string(name='TagName'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model DeleteRepositoryTagResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteRepositoryTagResponseBody(name='body'),
}

async function deleteRepositoryTag(ProjectId: string, TagName: string, request: DeleteRepositoryTagRequest): DeleteRepositoryTagResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteRepositoryTagWithOptions(ProjectId, TagName, request, headers, runtime);
}

async function deleteRepositoryTagWithOptions(ProjectId: string, TagName: string, request: DeleteRepositoryTagRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteRepositoryTagResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRepositoryTag',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v3/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/repository/tags/${OpenApiUtil.getEncodeParam(TagName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteRepositoryTagV2Request {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  tagName?: string(name='TagName'),
}

model DeleteRepositoryTagV2ResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    tagName?: string(name='TagName'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model DeleteRepositoryTagV2Response = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteRepositoryTagV2ResponseBody(name='body'),
}

async function deleteRepositoryTagV2(ProjectId: string, request: DeleteRepositoryTagV2Request): DeleteRepositoryTagV2Response {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteRepositoryTagV2WithOptions(ProjectId, request, headers, runtime);
}

async function deleteRepositoryTagV2WithOptions(ProjectId: string, request: DeleteRepositoryTagV2Request, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteRepositoryTagV2Response {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.tagName)) {
    query['TagName'] = request.tagName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRepositoryTagV2',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v3/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/repository/tag/delete`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteRepositoryWebhookRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
}

model DeleteRepositoryWebhookResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    createdAt?: string(name='CreatedAt'),
    description?: string(name='Description'),
    enableSslVerification?: boolean(name='EnableSslVerification'),
    id?: long(name='Id'),
    lastTestResult?: string(name='LastTestResult'),
    mergeRequestsEvents?: boolean(name='MergeRequestsEvents'),
    noteEvents?: boolean(name='NoteEvents'),
    projectId?: long(name='ProjectId'),
    pushEvents?: boolean(name='PushEvents'),
    secretToken?: string(name='SecretToken'),
    tagPushEvents?: boolean(name='TagPushEvents'),
    url?: string(name='Url'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model DeleteRepositoryWebhookResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteRepositoryWebhookResponseBody(name='body'),
}

async function deleteRepositoryWebhook(ProjectId: string, WebhookId: string, request: DeleteRepositoryWebhookRequest): DeleteRepositoryWebhookResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteRepositoryWebhookWithOptions(ProjectId, WebhookId, request, headers, runtime);
}

async function deleteRepositoryWebhookWithOptions(ProjectId: string, WebhookId: string, request: DeleteRepositoryWebhookRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteRepositoryWebhookResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRepositoryWebhook',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v3/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/hooks/${OpenApiUtil.getEncodeParam(WebhookId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model EnableRepositoryDeployKeyRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model EnableRepositoryDeployKeyResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    result?: boolean(name='Result'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model EnableRepositoryDeployKeyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableRepositoryDeployKeyResponseBody(name='body'),
}

async function enableRepositoryDeployKey(ProjectId: string, KeyId: string, request: EnableRepositoryDeployKeyRequest): EnableRepositoryDeployKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return enableRepositoryDeployKeyWithOptions(ProjectId, KeyId, request, headers, runtime);
}

async function enableRepositoryDeployKeyWithOptions(ProjectId: string, KeyId: string, request: EnableRepositoryDeployKeyRequest, headers: map[string]string, runtime: Util.RuntimeOptions): EnableRepositoryDeployKeyResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query['SubUserId'] = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableRepositoryDeployKey',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v3/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/keys/${OpenApiUtil.getEncodeParam(KeyId)}/enable`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetBranchInfoRequest {
  accessToken?: string(name='AccessToken'),
  branchName?: string(name='BranchName'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model GetBranchInfoResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    branchName?: string(name='BranchName'),
    commitInfo?: {
      authorDate?: string(name='AuthorDate'),
      authorEmail?: string(name='AuthorEmail'),
      authorName?: string(name='AuthorName'),
      committedDate?: string(name='CommittedDate'),
      committerEmail?: string(name='CommitterEmail'),
      committerName?: string(name='CommitterName'),
      createdAt?: string(name='CreatedAt'),
      id?: string(name='Id'),
      message?: string(name='Message'),
      parentIds?: [ string ](name='ParentIds'),
      shortId?: string(name='ShortId'),
      title?: string(name='Title'),
    }(name='CommitInfo'),
    protectedBranch?: boolean(name='ProtectedBranch'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model GetBranchInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetBranchInfoResponseBody(name='body'),
}

async function getBranchInfo(ProjectId: string, request: GetBranchInfoRequest): GetBranchInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getBranchInfoWithOptions(ProjectId, request, headers, runtime);
}

async function getBranchInfoWithOptions(ProjectId: string, request: GetBranchInfoRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetBranchInfoResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.branchName)) {
    query['BranchName'] = request.branchName;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query['SubUserId'] = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetBranchInfo',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v3/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/repository/branches/detail`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetCodeCompletionRequest {
  fetchKeys?: string(name='FetchKeys'),
  isEncrypted?: boolean(name='IsEncrypted'),
}

model GetCodeCompletionResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    body?: string(name='Body'),
    clientTimestamp?: string(name='ClientTimestamp'),
    fetchTimestamp?: string(name='FetchTimestamp'),
    invokeTimestamp?: string(name='InvokeTimestamp'),
    receiveTimestamp?: string(name='ReceiveTimestamp'),
    rspTimestamp?: string(name='RspTimestamp'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model GetCodeCompletionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetCodeCompletionResponseBody(name='body'),
}

async function getCodeCompletion(ServiceName: string, request: GetCodeCompletionRequest): GetCodeCompletionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getCodeCompletionWithOptions(ServiceName, request, headers, runtime);
}

async function getCodeCompletionWithOptions(ServiceName: string, request: GetCodeCompletionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetCodeCompletionResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.fetchKeys)) {
    query['FetchKeys'] = request.fetchKeys;
  }
  if (!Util.isUnset(request.isEncrypted)) {
    query['IsEncrypted'] = request.isEncrypted;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCodeCompletion',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v2/service/invoke/${OpenApiUtil.getEncodeParam(ServiceName)}`,
    method = 'POST',
    authType = 'Anonymous',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetCodeupOrganizationRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model GetCodeupOrganizationResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    createdAt?: string(name='CreatedAt'),
    id?: long(name='Id'),
    namespaceId?: long(name='NamespaceId'),
    organizationId?: string(name='OrganizationId'),
    path?: string(name='Path'),
    updatedAt?: string(name='UpdatedAt'),
    userRole?: string(name='UserRole'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model GetCodeupOrganizationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetCodeupOrganizationResponseBody(name='body'),
}

async function getCodeupOrganization(OrganizationIdentity: string, request: GetCodeupOrganizationRequest): GetCodeupOrganizationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getCodeupOrganizationWithOptions(OrganizationIdentity, request, headers, runtime);
}

async function getCodeupOrganizationWithOptions(OrganizationIdentity: string, request: GetCodeupOrganizationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetCodeupOrganizationResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query['SubUserId'] = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCodeupOrganization',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v4/organization/${OpenApiUtil.getEncodeParam(OrganizationIdentity)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetFileBlobsRequest {
  accessToken?: string(name='AccessToken'),
  filePath?: string(name='FilePath'),
  from?: long(name='From'),
  organizationId?: string(name='OrganizationId'),
  ref?: string(name='Ref'),
  subUserId?: string(name='SubUserId'),
  to?: long(name='To'),
}

model GetFileBlobsResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    content?: string(name='Content'),
    totalLines?: int32(name='TotalLines'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model GetFileBlobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetFileBlobsResponseBody(name='body'),
}

async function getFileBlobs(ProjectId: string, request: GetFileBlobsRequest): GetFileBlobsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getFileBlobsWithOptions(ProjectId, request, headers, runtime);
}

async function getFileBlobsWithOptions(ProjectId: string, request: GetFileBlobsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetFileBlobsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.filePath)) {
    query['FilePath'] = request.filePath;
  }
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.ref)) {
    query['Ref'] = request.ref;
  }
  if (!Util.isUnset(request.subUserId)) {
    query['SubUserId'] = request.subUserId;
  }
  if (!Util.isUnset(request.to)) {
    query['To'] = request.to;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetFileBlobs',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v4/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/repository/blobs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetFileLastCommitRequest {
  accessToken?: string(name='AccessToken'),
  filePath?: string(name='FilePath'),
  organizationId?: string(name='OrganizationId'),
  sha?: string(name='Sha'),
}

model GetFileLastCommitResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    authorDate?: string(name='AuthorDate'),
    authorEmail?: string(name='AuthorEmail'),
    authorName?: string(name='AuthorName'),
    committedDate?: string(name='CommittedDate'),
    committerEmail?: string(name='CommitterEmail'),
    committerName?: string(name='CommitterName'),
    createdAt?: string(name='CreatedAt'),
    id?: string(name='Id'),
    message?: string(name='Message'),
    parentIds?: [ string ](name='ParentIds'),
    shortId?: string(name='ShortId'),
    signature?: {
      gpgKeyId?: string(name='GpgKeyId'),
      verificationStatus?: string(name='VerificationStatus'),
    }(name='Signature'),
    title?: string(name='Title'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model GetFileLastCommitResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetFileLastCommitResponseBody(name='body'),
}

async function getFileLastCommit(ProjectId: string, request: GetFileLastCommitRequest): GetFileLastCommitResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getFileLastCommitWithOptions(ProjectId, request, headers, runtime);
}

async function getFileLastCommitWithOptions(ProjectId: string, request: GetFileLastCommitRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetFileLastCommitResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.filePath)) {
    query['FilePath'] = request.filePath;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.sha)) {
    query['Sha'] = request.sha;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetFileLastCommit',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v3/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/repository/files/last_commit`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetGroupDetailRequest {
  accessToken?: string(name='AccessToken'),
  groupId?: long(name='GroupId'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model GetGroupDetailResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    avatarUrl?: string(name='AvatarUrl'),
    description?: string(name='Description'),
    id?: long(name='Id'),
    name?: string(name='Name'),
    nameWithNamespace?: string(name='NameWithNamespace'),
    ownerId?: long(name='OwnerId'),
    parentId?: long(name='ParentId'),
    path?: string(name='Path'),
    pathWithNamespace?: string(name='PathWithNamespace'),
    type?: string(name='Type'),
    visibilityLevel?: string(name='VisibilityLevel'),
    webUrl?: string(name='WebUrl'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model GetGroupDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetGroupDetailResponseBody(name='body'),
}

async function getGroupDetail(request: GetGroupDetailRequest): GetGroupDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getGroupDetailWithOptions(request, headers, runtime);
}

async function getGroupDetailWithOptions(request: GetGroupDetailRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetGroupDetailResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query['SubUserId'] = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetGroupDetail',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v3/groups/detail`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetMergeRequestApproveStatusRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
}

model GetMergeRequestApproveStatusResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    approveStatus?: string(name='ApproveStatus'),
    message?: string(name='Message'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model GetMergeRequestApproveStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMergeRequestApproveStatusResponseBody(name='body'),
}

async function getMergeRequestApproveStatus(ProjectId: string, MergeRequestId: string, request: GetMergeRequestApproveStatusRequest): GetMergeRequestApproveStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getMergeRequestApproveStatusWithOptions(ProjectId, MergeRequestId, request, headers, runtime);
}

async function getMergeRequestApproveStatusWithOptions(ProjectId: string, MergeRequestId: string, request: GetMergeRequestApproveStatusRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetMergeRequestApproveStatusResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMergeRequestApproveStatus',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v4/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/merge_request/${OpenApiUtil.getEncodeParam(MergeRequestId)}/approve_status`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetMergeRequestDetailRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
}

model GetMergeRequestDetailResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    acceptedRevision?: string(name='AcceptedRevision'),
    aheadCommitCount?: int32(name='AheadCommitCount'),
    approveCheckResult?: {
      satisfiedCheckResults?: [ 
        {
          checkName?: string(name='CheckName'),
          checkStatus?: string(name='CheckStatus'),
          checkType?: string(name='CheckType'),
          extraUsers?: [ 
            {
              avatarUrl?: string(name='AvatarUrl'),
              externUserId?: string(name='ExternUserId'),
              id?: long(name='Id'),
              name?: string(name='Name'),
            }
          ](name='ExtraUsers'),
          satisfiedItems?: [ string ](name='SatisfiedItems'),
          unsatisfiedItems?: [ string ](name='UnsatisfiedItems'),
        }
      ](name='SatisfiedCheckResults'),
      totalCheckResult?: string(name='TotalCheckResult'),
      unsatisfiedCheckResults?: [ 
        {
          checkName?: string(name='CheckName'),
          checkStatus?: string(name='CheckStatus'),
          checkType?: string(name='CheckType'),
          extraUsers?: [ 
            {
              avatarUrl?: string(name='AvatarUrl'),
              externUserId?: string(name='ExternUserId'),
              id?: long(name='Id'),
              name?: string(name='Name'),
            }
          ](name='ExtraUsers'),
          satisfiedItems?: [ string ](name='SatisfiedItems'),
          unsatisfiedItems?: [ string ](name='UnsatisfiedItems'),
        }
      ](name='UnsatisfiedCheckResults'),
    }(name='ApproveCheckResult'),
    assigneeList?: [ 
      {
        avatarUrl?: string(name='AvatarUrl'),
        email?: string(name='Email'),
        externUserId?: string(name='ExternUserId'),
        id?: string(name='Id'),
        name?: string(name='Name'),
        status?: string(name='Status'),
      }
    ](name='AssigneeList'),
    author?: {
      avatarUrl?: string(name='AvatarUrl'),
      externUserId?: string(name='ExternUserId'),
      id?: long(name='Id'),
      name?: string(name='Name'),
    }(name='Author'),
    behindCommitCount?: int32(name='BehindCommitCount'),
    createdAt?: string(name='CreatedAt'),
    description?: string(name='Description'),
    id?: long(name='Id'),
    isSupportMerge?: boolean(name='IsSupportMerge'),
    mergeError?: string(name='MergeError'),
    mergeStatus?: string(name='MergeStatus'),
    mergeType?: string(name='MergeType'),
    mergedRevision?: string(name='MergedRevision'),
    nameWithNamespace?: string(name='NameWithNamespace'),
    projectId?: long(name='ProjectId'),
    sourceBranch?: string(name='SourceBranch'),
    state?: string(name='State'),
    targetBranch?: string(name='TargetBranch'),
    title?: string(name='Title'),
    updatedAt?: string(name='UpdatedAt'),
    webUrl?: string(name='WebUrl'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model GetMergeRequestDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMergeRequestDetailResponseBody(name='body'),
}

async function getMergeRequestDetail(ProjectId: string, MergeRequestId: string, request: GetMergeRequestDetailRequest): GetMergeRequestDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getMergeRequestDetailWithOptions(ProjectId, MergeRequestId, request, headers, runtime);
}

async function getMergeRequestDetailWithOptions(ProjectId: string, MergeRequestId: string, request: GetMergeRequestDetailRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetMergeRequestDetailResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMergeRequestDetail',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v4/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/merge_request/${OpenApiUtil.getEncodeParam(MergeRequestId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetMergeRequestSettingRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
}

model GetMergeRequestSettingResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    isEnableSmartCodeReview?: boolean(name='IsEnableSmartCodeReview'),
    mergeTypes?: [ string ](name='MergeTypes'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model GetMergeRequestSettingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMergeRequestSettingResponseBody(name='body'),
}

async function getMergeRequestSetting(ProjectId: string, request: GetMergeRequestSettingRequest): GetMergeRequestSettingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getMergeRequestSettingWithOptions(ProjectId, request, headers, runtime);
}

async function getMergeRequestSettingWithOptions(ProjectId: string, request: GetMergeRequestSettingRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetMergeRequestSettingResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMergeRequestSetting',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v4/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/settings/merge_requests`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetOrganizationRepositorySettingRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
}

model GetOrganizationRepositorySettingResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    forcePushForbidden?: boolean(name='ForcePushForbidden'),
    groupRequired?: boolean(name='GroupRequired'),
    openCloneDownloadControl?: boolean(name='OpenCloneDownloadControl'),
    orgCloneDownloadMethodList?: [ 
      {
        allowed?: boolean(name='Allowed'),
        permissionCode?: string(name='PermissionCode'),
      }
    ](name='OrgCloneDownloadMethodList'),
    orgCloneDownloadRoleList?: [ 
      {
        allowed?: boolean(name='Allowed'),
        roleCode?: long(name='RoleCode'),
      }
    ](name='OrgCloneDownloadRoleList'),
    repoAdminAccessVisibilityLevel?: [ long ](name='RepoAdminAccessVisibilityLevel'),
    repoAdminOperation?: [ long ](name='RepoAdminOperation'),
    repoCreatorIdentity?: [ long ](name='RepoCreatorIdentity'),
    repoVisibilityLevel?: [ long ](name='RepoVisibilityLevel'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model GetOrganizationRepositorySettingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetOrganizationRepositorySettingResponseBody(name='body'),
}

async function getOrganizationRepositorySetting(request: GetOrganizationRepositorySettingRequest): GetOrganizationRepositorySettingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getOrganizationRepositorySettingWithOptions(request, headers, runtime);
}

async function getOrganizationRepositorySettingWithOptions(request: GetOrganizationRepositorySettingRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetOrganizationRepositorySettingResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetOrganizationRepositorySetting',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v4/organization/settings/repo`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetOrganizationSecurityCenterStatusRequest {
  accessToken?: string(name='AccessToken'),
}

model GetOrganizationSecurityCenterStatusResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    enable?: boolean(name='Enable'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model GetOrganizationSecurityCenterStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetOrganizationSecurityCenterStatusResponseBody(name='body'),
}

async function getOrganizationSecurityCenterStatus(request: GetOrganizationSecurityCenterStatusRequest): GetOrganizationSecurityCenterStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getOrganizationSecurityCenterStatusWithOptions(request, headers, runtime);
}

async function getOrganizationSecurityCenterStatusWithOptions(request: GetOrganizationSecurityCenterStatusRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetOrganizationSecurityCenterStatusResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetOrganizationSecurityCenterStatus',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v4/organization/security/status`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetProjectMemberRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model GetProjectMemberResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    accessLevel?: int32(name='AccessLevel'),
    avatarUrl?: string(name='AvatarUrl'),
    externUserId?: string(name='ExternUserId'),
    id?: long(name='Id'),
    name?: string(name='Name'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model GetProjectMemberResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetProjectMemberResponseBody(name='body'),
}

async function getProjectMember(ProjectId: string, UserId: string, request: GetProjectMemberRequest): GetProjectMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getProjectMemberWithOptions(ProjectId, UserId, request, headers, runtime);
}

async function getProjectMemberWithOptions(ProjectId: string, UserId: string, request: GetProjectMemberRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetProjectMemberResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query['SubUserId'] = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetProjectMember',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v3/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/members/${OpenApiUtil.getEncodeParam(UserId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetRepositoryCommitRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
}

model GetRepositoryCommitResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    authorDate?: string(name='AuthorDate'),
    authorEmail?: string(name='AuthorEmail'),
    authorName?: string(name='AuthorName'),
    committedDate?: string(name='CommittedDate'),
    committerEmail?: string(name='CommitterEmail'),
    committerName?: string(name='CommitterName'),
    createdAt?: string(name='CreatedAt'),
    id?: string(name='Id'),
    message?: string(name='Message'),
    parentIds?: [ string ](name='ParentIds'),
    shortId?: string(name='ShortId'),
    signature?: {
      gpgKeyId?: string(name='GpgKeyId'),
      verificationStatus?: string(name='VerificationStatus'),
    }(name='Signature'),
    title?: string(name='Title'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model GetRepositoryCommitResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRepositoryCommitResponseBody(name='body'),
}

async function getRepositoryCommit(ProjectId: string, Sha: string, request: GetRepositoryCommitRequest): GetRepositoryCommitResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getRepositoryCommitWithOptions(ProjectId, Sha, request, headers, runtime);
}

async function getRepositoryCommitWithOptions(ProjectId: string, Sha: string, request: GetRepositoryCommitRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetRepositoryCommitResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRepositoryCommit',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v4/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/repository/commits/${OpenApiUtil.getEncodeParam(Sha)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetRepositoryInfoRequest {
  accessToken?: string(name='AccessToken'),
  identity?: string(name='Identity'),
  organizationId?: string(name='OrganizationId'),
}

model GetRepositoryInfoResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    accessLevel?: int32(name='AccessLevel'),
    archive?: boolean(name='Archive'),
    avatarUrl?: string(name='AvatarUrl'),
    createdAt?: string(name='CreatedAt'),
    creatorId?: long(name='CreatorId'),
    defaultBranch?: string(name='DefaultBranch'),
    demoProjectStatus?: boolean(name='DemoProjectStatus'),
    description?: string(name='Description'),
    httpUrlToRepo?: string(name='HttpUrlToRepo'),
    id?: long(name='Id'),
    importFromSubversion?: boolean(name='ImportFromSubversion'),
    importStatus?: string(name='ImportStatus'),
    importUrl?: string(name='ImportUrl'),
    lastActivityAt?: string(name='LastActivityAt'),
    name?: string(name='Name'),
    nameWithNamespace?: string(name='NameWithNamespace'),
    namespace?: {
      avatar?: string(name='Avatar'),
      createdAt?: string(name='CreatedAt'),
      description?: string(name='Description'),
      id?: long(name='Id'),
      name?: string(name='Name'),
      ownerId?: long(name='OwnerId'),
      path?: string(name='Path'),
      public?: boolean(name='Public'),
      state?: string(name='State'),
      updatedAt?: string(name='UpdatedAt'),
      visibilityLevel?: string(name='VisibilityLevel'),
    }(name='Namespace'),
    path?: string(name='Path'),
    pathWithNamespace?: string(name='PathWithNamespace'),
    permissions?: {
      groupAccess?: {
        accessLevel?: int32(name='AccessLevel'),
      }(name='GroupAccess'),
      projectAccess?: {
        accessLevel?: int32(name='AccessLevel'),
      }(name='ProjectAccess'),
    }(name='Permissions'),
    public?: boolean(name='Public'),
    sshUrlToRepo?: string(name='SshUrlToRepo'),
    tagList?: [ string ](name='TagList'),
    visibilityLevel?: string(name='VisibilityLevel'),
    webUrl?: string(name='WebUrl'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model GetRepositoryInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRepositoryInfoResponseBody(name='body'),
}

async function getRepositoryInfo(request: GetRepositoryInfoRequest): GetRepositoryInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getRepositoryInfoWithOptions(request, headers, runtime);
}

async function getRepositoryInfoWithOptions(request: GetRepositoryInfoRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetRepositoryInfoResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.identity)) {
    query['Identity'] = request.identity;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRepositoryInfo',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v3/projects/info`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetRepositoryTagRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
}

model GetRepositoryTagResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    commit?: {
      authorEmail?: string(name='AuthorEmail'),
      authorName?: string(name='AuthorName'),
      authoredDate?: string(name='AuthoredDate'),
      committedDate?: string(name='CommittedDate'),
      committerEmail?: string(name='CommitterEmail'),
      committerName?: string(name='CommitterName'),
      createdAt?: string(name='CreatedAt'),
      id?: string(name='Id'),
      message?: string(name='Message'),
      parentIds?: [ string ](name='ParentIds'),
      shortId?: string(name='ShortId'),
      signature?: {
        gpgKeyId?: string(name='GpgKeyId'),
        verificationStatus?: string(name='VerificationStatus'),
      }(name='Signature'),
      title?: string(name='Title'),
    }(name='Commit'),
    id?: string(name='Id'),
    message?: string(name='Message'),
    name?: string(name='Name'),
    signature?: {
      gpgKeyId?: string(name='GpgKeyId'),
      verificationStatus?: string(name='VerificationStatus'),
    }(name='Signature'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model GetRepositoryTagResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRepositoryTagResponseBody(name='body'),
}

async function getRepositoryTag(ProjectId: string, TagName: string, request: GetRepositoryTagRequest): GetRepositoryTagResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getRepositoryTagWithOptions(ProjectId, TagName, request, headers, runtime);
}

async function getRepositoryTagWithOptions(ProjectId: string, TagName: string, request: GetRepositoryTagRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetRepositoryTagResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRepositoryTag',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v3/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/repository/tags/${OpenApiUtil.getEncodeParam(TagName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetRepositoryTagV2Request {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  tagName?: string(name='TagName'),
}

model GetRepositoryTagV2ResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    commit?: {
      authorEmail?: string(name='AuthorEmail'),
      authorName?: string(name='AuthorName'),
      authoredDate?: string(name='AuthoredDate'),
      committedDate?: string(name='CommittedDate'),
      committerEmail?: string(name='CommitterEmail'),
      committerName?: string(name='CommitterName'),
      createdAt?: string(name='CreatedAt'),
      id?: string(name='Id'),
      message?: string(name='Message'),
      parentIds?: [ string ](name='ParentIds'),
      shortId?: string(name='ShortId'),
      signature?: {
        gpgKeyId?: string(name='GpgKeyId'),
        verificationStatus?: string(name='VerificationStatus'),
      }(name='Signature'),
      title?: string(name='Title'),
    }(name='Commit'),
    id?: string(name='Id'),
    message?: string(name='Message'),
    name?: string(name='Name'),
    signature?: {
      gpgKeyId?: string(name='GpgKeyId'),
      verificationStatus?: string(name='VerificationStatus'),
    }(name='Signature'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model GetRepositoryTagV2Response = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRepositoryTagV2ResponseBody(name='body'),
}

async function getRepositoryTagV2(ProjectId: string, request: GetRepositoryTagV2Request): GetRepositoryTagV2Response {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getRepositoryTagV2WithOptions(ProjectId, request, headers, runtime);
}

async function getRepositoryTagV2WithOptions(ProjectId: string, request: GetRepositoryTagV2Request, headers: map[string]string, runtime: Util.RuntimeOptions): GetRepositoryTagV2Response {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.tagName)) {
    query['TagName'] = request.tagName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRepositoryTagV2',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v3/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/repository/tag/info`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetUserInfoRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
}

model GetUserInfoResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    avatarUrl?: string(name='AvatarUrl'),
    email?: string(name='Email'),
    externalUserId?: string(name='ExternalUserId'),
    id?: long(name='Id'),
    name?: string(name='Name'),
    username?: string(name='Username'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model GetUserInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetUserInfoResponseBody(name='body'),
}

async function getUserInfo(request: GetUserInfoRequest): GetUserInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getUserInfoWithOptions(request, headers, runtime);
}

async function getUserInfoWithOptions(request: GetUserInfoRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetUserInfoResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetUserInfo',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v3/user/current`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model IsSlsUserAuthrizedCodeupRequest {
  organizationId?: string(name='OrganizationId'),
  aliyunSubUserId?: string(name='aliyunSubUserId'),
  aliyunUserId?: string(name='aliyunUserId'),
  codeupProjectId?: long(name='codeupProjectId'),
  slsLogStore?: string(name='slsLogStore'),
  slsProject?: string(name='slsProject'),
}

model IsSlsUserAuthrizedCodeupResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    authrized?: boolean(name='authrized'),
  }(name='Result'),
  success?: string(name='Success'),
}

model IsSlsUserAuthrizedCodeupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: IsSlsUserAuthrizedCodeupResponseBody(name='body'),
}

async function isSlsUserAuthrizedCodeup(request: IsSlsUserAuthrizedCodeupRequest): IsSlsUserAuthrizedCodeupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return isSlsUserAuthrizedCodeupWithOptions(request, headers, runtime);
}

async function isSlsUserAuthrizedCodeupWithOptions(request: IsSlsUserAuthrizedCodeupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): IsSlsUserAuthrizedCodeupResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.aliyunSubUserId)) {
    body['aliyunSubUserId'] = request.aliyunSubUserId;
  }
  if (!Util.isUnset(request.aliyunUserId)) {
    body['aliyunUserId'] = request.aliyunUserId;
  }
  if (!Util.isUnset(request.codeupProjectId)) {
    body['codeupProjectId'] = request.codeupProjectId;
  }
  if (!Util.isUnset(request.slsLogStore)) {
    body['slsLogStore'] = request.slsLogStore;
  }
  if (!Util.isUnset(request.slsProject)) {
    body['slsProject'] = request.slsProject;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'IsSlsUserAuthrizedCodeup',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v3/repository/is_codeup_authrized`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListGroupMemberRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  page?: long(name='Page'),
  pageSize?: long(name='PageSize'),
  subUserId?: string(name='SubUserId'),
}

model ListGroupMemberResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      accessLevel?: int32(name='AccessLevel'),
      avatarUrl?: string(name='AvatarUrl'),
      email?: string(name='Email'),
      externUserId?: string(name='ExternUserId'),
      id?: long(name='Id'),
      state?: string(name='State'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
  total?: long(name='Total'),
}

model ListGroupMemberResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListGroupMemberResponseBody(name='body'),
}

async function listGroupMember(GroupId: string, request: ListGroupMemberRequest): ListGroupMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listGroupMemberWithOptions(GroupId, request, headers, runtime);
}

async function listGroupMemberWithOptions(GroupId: string, request: ListGroupMemberRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListGroupMemberResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.page)) {
    query['Page'] = request.page;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.subUserId)) {
    query['SubUserId'] = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListGroupMember',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v3/groups/${OpenApiUtil.getEncodeParam(GroupId)}/members`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListGroupRepositoriesRequest {
  accessToken?: string(name='AccessToken'),
  isMember?: boolean(name='IsMember'),
  organizationId?: string(name='OrganizationId'),
  page?: long(name='Page'),
  pageSize?: long(name='PageSize'),
  search?: string(name='Search'),
  subUserId?: string(name='SubUserId'),
}

model ListGroupRepositoriesResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      archive?: boolean(name='Archive'),
      createdAt?: string(name='CreatedAt'),
      creatorId?: long(name='CreatorId'),
      httpCloneUrl?: string(name='HttpCloneUrl'),
      id?: long(name='Id'),
      importStatus?: string(name='ImportStatus'),
      lastActivityAt?: string(name='LastActivityAt'),
      name?: string(name='Name'),
      nameWithNamespace?: string(name='NameWithNamespace'),
      namespaceId?: long(name='NamespaceId'),
      path?: string(name='Path'),
      pathWithNamespace?: string(name='PathWithNamespace'),
      sshCloneUrl?: string(name='SshCloneUrl'),
      updatedAt?: string(name='UpdatedAt'),
      visibilityLevel?: int32(name='VisibilityLevel'),
      webUrl?: string(name='WebUrl'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
  total?: long(name='Total'),
}

model ListGroupRepositoriesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListGroupRepositoriesResponseBody(name='body'),
}

async function listGroupRepositories(Identity: string, request: ListGroupRepositoriesRequest): ListGroupRepositoriesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listGroupRepositoriesWithOptions(Identity, request, headers, runtime);
}

async function listGroupRepositoriesWithOptions(Identity: string, request: ListGroupRepositoriesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListGroupRepositoriesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.isMember)) {
    query['IsMember'] = request.isMember;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.page)) {
    query['Page'] = request.page;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.search)) {
    query['Search'] = request.search;
  }
  if (!Util.isUnset(request.subUserId)) {
    query['SubUserId'] = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListGroupRepositories',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v3/groups/${OpenApiUtil.getEncodeParam(Identity)}/projects`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListGroupsRequest {
  accessToken?: string(name='AccessToken'),
  includePersonal?: boolean(name='IncludePersonal'),
  organizationId?: string(name='OrganizationId'),
  page?: long(name='Page'),
  pageSize?: long(name='PageSize'),
  search?: string(name='Search'),
  subUserId?: string(name='SubUserId'),
}

model ListGroupsResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      accessLevel?: int32(name='AccessLevel'),
      createdAt?: string(name='CreatedAt'),
      description?: string(name='Description'),
      id?: long(name='Id'),
      name?: string(name='Name'),
      nameWithNamespace?: string(name='NameWithNamespace'),
      ownerId?: long(name='OwnerId'),
      parentId?: long(name='ParentId'),
      path?: string(name='Path'),
      pathWithNamespace?: string(name='PathWithNamespace'),
      type?: string(name='Type'),
      updatedAt?: string(name='UpdatedAt'),
      visibilityLevel?: string(name='VisibilityLevel'),
      webUrl?: string(name='WebUrl'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
  total?: long(name='Total'),
}

model ListGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListGroupsResponseBody(name='body'),
}

async function listGroups(request: ListGroupsRequest): ListGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listGroupsWithOptions(request, headers, runtime);
}

async function listGroupsWithOptions(request: ListGroupsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListGroupsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.includePersonal)) {
    query['IncludePersonal'] = request.includePersonal;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.page)) {
    query['Page'] = request.page;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.search)) {
    query['Search'] = request.search;
  }
  if (!Util.isUnset(request.subUserId)) {
    query['SubUserId'] = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListGroups',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v3/groups/all`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListMergeRequestCommentsRequest {
  accessToken?: string(name='AccessToken'),
  fromCommit?: string(name='FromCommit'),
  organizationId?: string(name='OrganizationId'),
  toCommit?: string(name='ToCommit'),
}

model ListMergeRequestCommentsResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      author?: {
        avatarUrl?: string(name='AvatarUrl'),
        email?: string(name='Email'),
        externUserId?: string(name='ExternUserId'),
        id?: long(name='Id'),
        name?: string(name='Name'),
      }(name='Author'),
      closed?: int32(name='Closed'),
      createdAt?: string(name='CreatedAt'),
      id?: long(name='Id'),
      isDraft?: boolean(name='IsDraft'),
      line?: long(name='Line'),
      note?: string(name='Note'),
      outDated?: boolean(name='OutDated'),
      parentNoteId?: long(name='ParentNoteId'),
      path?: string(name='Path'),
      projectId?: long(name='ProjectId'),
      rangeContext?: string(name='RangeContext'),
      side?: string(name='Side'),
      updatedAt?: string(name='UpdatedAt'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
  total?: long(name='Total'),
}

model ListMergeRequestCommentsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListMergeRequestCommentsResponseBody(name='body'),
}

async function listMergeRequestComments(ProjectId: string, MergeRequestId: string, request: ListMergeRequestCommentsRequest): ListMergeRequestCommentsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listMergeRequestCommentsWithOptions(ProjectId, MergeRequestId, request, headers, runtime);
}

async function listMergeRequestCommentsWithOptions(ProjectId: string, MergeRequestId: string, request: ListMergeRequestCommentsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListMergeRequestCommentsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.fromCommit)) {
    query['FromCommit'] = request.fromCommit;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.toCommit)) {
    query['ToCommit'] = request.toCommit;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListMergeRequestComments',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v4/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/merge_request/${OpenApiUtil.getEncodeParam(MergeRequestId)}/comments`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListMergeRequestsRequest {
  accessToken?: string(name='AccessToken'),
  afterDate?: string(name='AfterDate'),
  assigneeCodeupIdList?: string(name='AssigneeCodeupIdList'),
  assigneeIdList?: string(name='AssigneeIdList'),
  authorCodeupIdList?: string(name='AuthorCodeupIdList'),
  authorIdList?: string(name='AuthorIdList'),
  beforeDate?: string(name='BeforeDate'),
  groupIdList?: string(name='GroupIdList'),
  order?: string(name='Order'),
  organizationId?: string(name='OrganizationId'),
  page?: long(name='Page'),
  pageSize?: long(name='PageSize'),
  projectIdList?: string(name='ProjectIdList'),
  search?: string(name='Search'),
  state?: string(name='State'),
  subscriberCodeupIdList?: string(name='SubscriberCodeupIdList'),
}

model ListMergeRequestsResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      acceptedRevision?: string(name='AcceptedRevision'),
      aheadCommitCount?: int32(name='AheadCommitCount'),
      approveCheckResult?: {
        satisfiedCheckResults?: [ 
          {
            checkName?: string(name='CheckName'),
            checkStatus?: string(name='CheckStatus'),
            checkType?: string(name='CheckType'),
            extraUsers?: [ 
              {
                avatarUrl?: string(name='AvatarUrl'),
                externUserId?: string(name='ExternUserId'),
                id?: long(name='Id'),
                name?: string(name='Name'),
              }
            ](name='ExtraUsers'),
            satisfiedItems?: [ string ](name='SatisfiedItems'),
            unsatisfiedItems?: [ string ](name='UnsatisfiedItems'),
          }
        ](name='SatisfiedCheckResults'),
        totalCheckResult?: string(name='TotalCheckResult'),
        unsatisfiedCheckResults?: [ 
          {
            checkName?: string(name='CheckName'),
            checkStatus?: string(name='CheckStatus'),
            checkType?: string(name='CheckType'),
            extraUsers?: [ 
              {
                avatarUrl?: string(name='AvatarUrl'),
                externUserId?: string(name='ExternUserId'),
                id?: long(name='Id'),
                name?: string(name='Name'),
              }
            ](name='ExtraUsers'),
            satisfiedItems?: [ string ](name='SatisfiedItems'),
            unsatisfiedItems?: [ string ](name='UnsatisfiedItems'),
          }
        ](name='UnsatisfiedCheckResults'),
      }(name='ApproveCheckResult'),
      assigneeList?: [ 
        {
          avatarUrl?: string(name='AvatarUrl'),
          email?: string(name='Email'),
          externUserId?: string(name='ExternUserId'),
          id?: string(name='Id'),
          name?: string(name='Name'),
          status?: string(name='Status'),
        }
      ](name='AssigneeList'),
      author?: {
        avatarUrl?: string(name='AvatarUrl'),
        externUserId?: string(name='ExternUserId'),
        id?: long(name='Id'),
        name?: string(name='Name'),
      }(name='Author'),
      behindCommitCount?: int32(name='BehindCommitCount'),
      createdAt?: string(name='CreatedAt'),
      description?: string(name='Description'),
      id?: long(name='Id'),
      isSupportMerge?: boolean(name='IsSupportMerge'),
      mergeError?: string(name='MergeError'),
      mergeStatus?: string(name='MergeStatus'),
      mergeType?: string(name='MergeType'),
      mergedRevision?: string(name='MergedRevision'),
      nameWithNamespace?: string(name='NameWithNamespace'),
      projectId?: long(name='ProjectId'),
      sourceBranch?: string(name='SourceBranch'),
      state?: string(name='State'),
      targetBranch?: string(name='TargetBranch'),
      title?: string(name='Title'),
      updatedAt?: string(name='UpdatedAt'),
      webUrl?: string(name='WebUrl'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
  total?: long(name='Total'),
}

model ListMergeRequestsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListMergeRequestsResponseBody(name='body'),
}

async function listMergeRequests(request: ListMergeRequestsRequest): ListMergeRequestsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listMergeRequestsWithOptions(request, headers, runtime);
}

async function listMergeRequestsWithOptions(request: ListMergeRequestsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListMergeRequestsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.afterDate)) {
    query['AfterDate'] = request.afterDate;
  }
  if (!Util.isUnset(request.assigneeCodeupIdList)) {
    query['AssigneeCodeupIdList'] = request.assigneeCodeupIdList;
  }
  if (!Util.isUnset(request.assigneeIdList)) {
    query['AssigneeIdList'] = request.assigneeIdList;
  }
  if (!Util.isUnset(request.authorCodeupIdList)) {
    query['AuthorCodeupIdList'] = request.authorCodeupIdList;
  }
  if (!Util.isUnset(request.authorIdList)) {
    query['AuthorIdList'] = request.authorIdList;
  }
  if (!Util.isUnset(request.beforeDate)) {
    query['BeforeDate'] = request.beforeDate;
  }
  if (!Util.isUnset(request.groupIdList)) {
    query['GroupIdList'] = request.groupIdList;
  }
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.page)) {
    query['Page'] = request.page;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectIdList)) {
    query['ProjectIdList'] = request.projectIdList;
  }
  if (!Util.isUnset(request.search)) {
    query['Search'] = request.search;
  }
  if (!Util.isUnset(request.state)) {
    query['State'] = request.state;
  }
  if (!Util.isUnset(request.subscriberCodeupIdList)) {
    query['SubscriberCodeupIdList'] = request.subscriberCodeupIdList;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListMergeRequests',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v4/merge_requests/advanced_search`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListOrganizationSecurityScoresRequest {
  accessToken?: string(name='AccessToken'),
}

model ListOrganizationSecurityScoresResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      enable?: boolean(name='Enable'),
      id?: long(name='Id'),
      organizationId?: string(name='OrganizationId'),
      organizationSecurityScore?: {
        authorityControlScore?: int32(name='AuthorityControlScore'),
        codeContentScore?: int32(name='CodeContentScore'),
        level?: string(name='Level'),
        memberBehaviorScore?: int32(name='MemberBehaviorScore'),
      }(name='OrganizationSecurityScore'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
}

model ListOrganizationSecurityScoresResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListOrganizationSecurityScoresResponseBody(name='body'),
}

async function listOrganizationSecurityScores(request: ListOrganizationSecurityScoresRequest): ListOrganizationSecurityScoresResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listOrganizationSecurityScoresWithOptions(request, headers, runtime);
}

async function listOrganizationSecurityScoresWithOptions(request: ListOrganizationSecurityScoresRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListOrganizationSecurityScoresResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListOrganizationSecurityScores',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v4/organization/security/scores`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListOrganizationsRequest {
  accessLevel?: int32(name='AccessLevel'),
  accessToken?: string(name='AccessToken'),
  minAccessLevel?: int32(name='MinAccessLevel'),
}

model ListOrganizationsResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      accessLevel?: int32(name='AccessLevel'),
      organizationId?: string(name='OrganizationId'),
      organizationName?: string(name='OrganizationName'),
      organizationRole?: string(name='OrganizationRole'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
}

model ListOrganizationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListOrganizationsResponseBody(name='body'),
}

async function listOrganizations(request: ListOrganizationsRequest): ListOrganizationsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listOrganizationsWithOptions(request, headers, runtime);
}

async function listOrganizationsWithOptions(request: ListOrganizationsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListOrganizationsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessLevel)) {
    query['AccessLevel'] = request.accessLevel;
  }
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.minAccessLevel)) {
    query['MinAccessLevel'] = request.minAccessLevel;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListOrganizations',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v4/organization`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListRepositoriesRequest {
  accessToken?: string(name='AccessToken'),
  archive?: boolean(name='Archive'),
  order?: string(name='Order'),
  organizationId?: string(name='OrganizationId'),
  page?: long(name='Page'),
  pageSize?: long(name='PageSize'),
  search?: string(name='Search'),
  sort?: string(name='Sort'),
}

model ListRepositoriesResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      accessLevel?: int32(name='AccessLevel'),
      archive?: boolean(name='Archive'),
      avatarUrl?: string(name='AvatarUrl'),
      createdAt?: string(name='CreatedAt'),
      demoProjectStatus?: boolean(name='DemoProjectStatus'),
      description?: string(name='Description'),
      id?: long(name='Id'),
      importStatus?: string(name='ImportStatus'),
      lastActivityAt?: string(name='LastActivityAt'),
      name?: string(name='Name'),
      nameWithNamespace?: string(name='NameWithNamespace'),
      namespaceId?: long(name='NamespaceId'),
      path?: string(name='Path'),
      pathWithNamespace?: string(name='PathWithNamespace'),
      star?: boolean(name='Star'),
      starCount?: long(name='StarCount'),
      updatedAt?: string(name='UpdatedAt'),
      visibilityLevel?: string(name='VisibilityLevel'),
      webUrl?: string(name='WebUrl'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
  total?: long(name='Total'),
}

model ListRepositoriesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRepositoriesResponseBody(name='body'),
}

async function listRepositories(request: ListRepositoriesRequest): ListRepositoriesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRepositoriesWithOptions(request, headers, runtime);
}

async function listRepositoriesWithOptions(request: ListRepositoriesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRepositoriesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.archive)) {
    query['Archive'] = request.archive;
  }
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.page)) {
    query['Page'] = request.page;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.search)) {
    query['Search'] = request.search;
  }
  if (!Util.isUnset(request.sort)) {
    query['Sort'] = request.sort;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRepositories',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v3/projects/all`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListRepositoryBranchesRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  page?: long(name='Page'),
  pageSize?: long(name='PageSize'),
  search?: string(name='Search'),
  subUserId?: string(name='SubUserId'),
}

model ListRepositoryBranchesResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      branchName?: string(name='BranchName'),
      commitInfo?: {
        authorDate?: string(name='AuthorDate'),
        authorEmail?: string(name='AuthorEmail'),
        authorName?: string(name='AuthorName'),
        committedDate?: string(name='CommittedDate'),
        committerEmail?: string(name='CommitterEmail'),
        committerName?: string(name='CommitterName'),
        createdAt?: string(name='CreatedAt'),
        id?: string(name='Id'),
        message?: string(name='Message'),
        parentIds?: [ string ](name='ParentIds'),
        shortId?: string(name='ShortId'),
        title?: string(name='Title'),
      }(name='CommitInfo'),
      protectedBranch?: boolean(name='ProtectedBranch'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
  total?: long(name='Total'),
}

model ListRepositoryBranchesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRepositoryBranchesResponseBody(name='body'),
}

async function listRepositoryBranches(ProjectId: string, request: ListRepositoryBranchesRequest): ListRepositoryBranchesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRepositoryBranchesWithOptions(ProjectId, request, headers, runtime);
}

async function listRepositoryBranchesWithOptions(ProjectId: string, request: ListRepositoryBranchesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRepositoryBranchesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.page)) {
    query['Page'] = request.page;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.search)) {
    query['Search'] = request.search;
  }
  if (!Util.isUnset(request.subUserId)) {
    query['SubUserId'] = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRepositoryBranches',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v3/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/repository/branches`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListRepositoryCodeRequest {
  organizationId?: string(name='OrganizationId'),
  filePath?: {
    matchType?: string(name='MatchType'),
    name?: string(name='Name'),
    operatorType?: string(name='OperatorType'),
    value?: string(name='Value'),
  }(name='FilePath'),
  isCodeBlock?: boolean(name='IsCodeBlock'),
  keyWord?: string(name='KeyWord'),
  language?: string(name='Language'),
  order?: string(name='Order'),
  page?: long(name='Page'),
  pageSize?: long(name='PageSize'),
  repositoryPath?: {
    matchType?: string(name='MatchType'),
    name?: string(name='Name'),
    operatorType?: string(name='OperatorType'),
    value?: string(name='Value'),
  }(name='RepositoryPath'),
  scope?: string(name='Scope'),
  sort?: string(name='Sort'),
}

model ListRepositoryCodeResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      docId?: string(name='DocId'),
      highlightTextMap?: map[string]any(name='HighlightTextMap'),
      source?: {
        branch?: string(name='Branch'),
        checkinDate?: string(name='CheckinDate'),
        fileName?: string(name='FileName'),
        filePath?: string(name='FilePath'),
        language?: string(name='Language'),
        organizationId?: string(name='OrganizationId'),
        repoPath?: string(name='RepoPath'),
      }(name='Source'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
  total?: long(name='Total'),
}

model ListRepositoryCodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRepositoryCodeResponseBody(name='body'),
}

async function listRepositoryCode(request: ListRepositoryCodeRequest): ListRepositoryCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRepositoryCodeWithOptions(request, headers, runtime);
}

async function listRepositoryCodeWithOptions(request: ListRepositoryCodeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRepositoryCodeResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.filePath)) {
    body['FilePath'] = request.filePath;
  }
  if (!Util.isUnset(request.isCodeBlock)) {
    body['IsCodeBlock'] = request.isCodeBlock;
  }
  if (!Util.isUnset(request.keyWord)) {
    body['KeyWord'] = request.keyWord;
  }
  if (!Util.isUnset(request.language)) {
    body['Language'] = request.language;
  }
  if (!Util.isUnset(request.order)) {
    body['Order'] = request.order;
  }
  if (!Util.isUnset(request.page)) {
    body['Page'] = request.page;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.repositoryPath)) {
    body['RepositoryPath'] = request.repositoryPath;
  }
  if (!Util.isUnset(request.scope)) {
    body['Scope'] = request.scope;
  }
  if (!Util.isUnset(request.sort)) {
    body['Sort'] = request.sort;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListRepositoryCode',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/search/v3/code`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListRepositoryCommitDiffRequest {
  accessToken?: string(name='AccessToken'),
  contextLine?: int32(name='ContextLine'),
  organizationId?: string(name='OrganizationId'),
}

model ListRepositoryCommitDiffResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      AMode?: string(name='AMode'),
      BMode?: string(name='BMode'),
      deletedFile?: boolean(name='DeletedFile'),
      diff?: string(name='Diff'),
      isBinary?: boolean(name='IsBinary'),
      isNewLfs?: boolean(name='IsNewLfs'),
      isOldLfs?: boolean(name='IsOldLfs'),
      newFile?: boolean(name='NewFile'),
      newId?: string(name='NewId'),
      newPath?: string(name='NewPath'),
      oldId?: string(name='OldId'),
      oldPath?: string(name='OldPath'),
      renamedFile?: boolean(name='RenamedFile'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
}

model ListRepositoryCommitDiffResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRepositoryCommitDiffResponseBody(name='body'),
}

async function listRepositoryCommitDiff(ProjectId: string, Sha: string, request: ListRepositoryCommitDiffRequest): ListRepositoryCommitDiffResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRepositoryCommitDiffWithOptions(ProjectId, Sha, request, headers, runtime);
}

async function listRepositoryCommitDiffWithOptions(ProjectId: string, Sha: string, request: ListRepositoryCommitDiffRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRepositoryCommitDiffResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.contextLine)) {
    query['ContextLine'] = request.contextLine;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRepositoryCommitDiff',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v3/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/repository/commits/${OpenApiUtil.getEncodeParam(Sha)}/diff`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListRepositoryCommitsRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  page?: long(name='Page'),
  pageSize?: long(name='PageSize'),
  path?: string(name='Path'),
  refName?: string(name='RefName'),
  search?: string(name='Search'),
  showSignature?: boolean(name='ShowSignature'),
}

model ListRepositoryCommitsResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      authorDate?: string(name='AuthorDate'),
      authorEmail?: string(name='AuthorEmail'),
      authorName?: string(name='AuthorName'),
      committedDate?: string(name='CommittedDate'),
      committerEmail?: string(name='CommitterEmail'),
      committerName?: string(name='CommitterName'),
      createdAt?: string(name='CreatedAt'),
      id?: string(name='Id'),
      message?: string(name='Message'),
      parentIds?: [ string ](name='ParentIds'),
      shortId?: string(name='ShortId'),
      signature?: {
        gpgKeyId?: string(name='GpgKeyId'),
        verificationStatus?: string(name='VerificationStatus'),
      }(name='Signature'),
      title?: string(name='Title'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
  total?: long(name='Total'),
}

model ListRepositoryCommitsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRepositoryCommitsResponseBody(name='body'),
}

async function listRepositoryCommits(ProjectId: string, request: ListRepositoryCommitsRequest): ListRepositoryCommitsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRepositoryCommitsWithOptions(ProjectId, request, headers, runtime);
}

async function listRepositoryCommitsWithOptions(ProjectId: string, request: ListRepositoryCommitsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRepositoryCommitsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.page)) {
    query['Page'] = request.page;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.path)) {
    query['Path'] = request.path;
  }
  if (!Util.isUnset(request.refName)) {
    query['RefName'] = request.refName;
  }
  if (!Util.isUnset(request.search)) {
    query['Search'] = request.search;
  }
  if (!Util.isUnset(request.showSignature)) {
    query['ShowSignature'] = request.showSignature;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRepositoryCommits',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v4/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/repository/commits`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListRepositoryMemberRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  page?: long(name='Page'),
  pageSize?: long(name='PageSize'),
  query?: string(name='Query'),
  subUserId?: string(name='SubUserId'),
}

model ListRepositoryMemberResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      accessLevel?: int32(name='AccessLevel'),
      avatarUrl?: string(name='AvatarUrl'),
      email?: string(name='Email'),
      externUserId?: string(name='ExternUserId'),
      id?: long(name='Id'),
      name?: string(name='Name'),
      state?: string(name='State'),
      username?: string(name='Username'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
  total?: long(name='Total'),
}

model ListRepositoryMemberResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRepositoryMemberResponseBody(name='body'),
}

async function listRepositoryMember(ProjectId: string, request: ListRepositoryMemberRequest): ListRepositoryMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRepositoryMemberWithOptions(ProjectId, request, headers, runtime);
}

async function listRepositoryMemberWithOptions(ProjectId: string, request: ListRepositoryMemberRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRepositoryMemberResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.page)) {
    query['Page'] = request.page;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.query)) {
    query['Query'] = request.query;
  }
  if (!Util.isUnset(request.subUserId)) {
    query['SubUserId'] = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRepositoryMember',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v3/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/members`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListRepositoryMemberWithInheritedRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
}

model ListRepositoryMemberWithInheritedResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      accessLevel?: int32(name='AccessLevel'),
      avatarUrl?: string(name='AvatarUrl'),
      email?: string(name='Email'),
      externUserId?: string(name='ExternUserId'),
      id?: long(name='Id'),
      inherited?: {
        id?: long(name='Id'),
        name?: string(name='Name'),
        nameWithNamespace?: string(name='NameWithNamespace'),
        path?: string(name='Path'),
        pathWithNamespace?: string(name='PathWithNamespace'),
        type?: string(name='Type'),
        visibilityLevel?: string(name='VisibilityLevel'),
      }(name='Inherited'),
      name?: string(name='Name'),
      state?: string(name='State'),
      username?: string(name='Username'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
}

model ListRepositoryMemberWithInheritedResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRepositoryMemberWithInheritedResponseBody(name='body'),
}

async function listRepositoryMemberWithInherited(ProjectId: string, request: ListRepositoryMemberWithInheritedRequest): ListRepositoryMemberWithInheritedResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRepositoryMemberWithInheritedWithOptions(ProjectId, request, headers, runtime);
}

async function listRepositoryMemberWithInheritedWithOptions(ProjectId: string, request: ListRepositoryMemberWithInheritedRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRepositoryMemberWithInheritedResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRepositoryMemberWithInherited',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v4/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/all_members`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListRepositoryProtectedBranchRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
}

model ListRepositoryProtectedBranchResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      allowMergeRoles?: [ int32 ](name='AllowMergeRoles'),
      allowPushRoles?: [ int32 ](name='AllowPushRoles'),
      branch?: string(name='Branch'),
      id?: long(name='Id'),
      mergeRequestSetting?: {
        allowMergeRequestRoles?: [ int32 ](name='AllowMergeRequestRoles'),
        allowSelfApproval?: boolean(name='AllowSelfApproval'),
        defaultAssignees?: [ 
          {
            avatarUrl?: string(name='AvatarUrl'),
            email?: string(name='Email'),
            externUid?: string(name='ExternUid'),
            id?: long(name='Id'),
            name?: string(name='Name'),
          }
        ](name='DefaultAssignees'),
        isRequireDiscussionProcessed?: boolean(name='IsRequireDiscussionProcessed'),
        mergeRequestMode?: string(name='MergeRequestMode'),
        minimumApproval?: int32(name='MinimumApproval'),
        required?: boolean(name='Required'),
        whiteList?: string(name='WhiteList'),
      }(name='MergeRequestSetting'),
      testSetting?: {
        checkConfig?: {
          checkItems?: [ 
            {
              name?: string(name='Name'),
              required?: boolean(name='Required'),
            }
          ](name='CheckItems'),
        }(name='CheckConfig'),
        codingGuidelinesDetection?: {
          enabled?: boolean(name='Enabled'),
          message?: string(name='Message'),
        }(name='CodingGuidelinesDetection'),
        required?: boolean(name='Required'),
        sensitiveInfoDetection?: {
          enabled?: boolean(name='Enabled'),
          message?: string(name='Message'),
        }(name='SensitiveInfoDetection'),
      }(name='TestSetting'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
}

model ListRepositoryProtectedBranchResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRepositoryProtectedBranchResponseBody(name='body'),
}

async function listRepositoryProtectedBranch(ProjectId: string, request: ListRepositoryProtectedBranchRequest): ListRepositoryProtectedBranchResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRepositoryProtectedBranchWithOptions(ProjectId, request, headers, runtime);
}

async function listRepositoryProtectedBranchWithOptions(ProjectId: string, request: ListRepositoryProtectedBranchRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRepositoryProtectedBranchResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRepositoryProtectedBranch',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v4/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/repository/protect_branches`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListRepositoryTagsRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  page?: long(name='Page'),
  pageSize?: long(name='PageSize'),
  search?: string(name='Search'),
  showSignature?: boolean(name='ShowSignature'),
  sort?: string(name='Sort'),
}

model ListRepositoryTagsResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      commit?: {
        authorEmail?: string(name='AuthorEmail'),
        authorName?: string(name='AuthorName'),
        authoredDate?: string(name='AuthoredDate'),
        committedDate?: string(name='CommittedDate'),
        committerEmail?: string(name='CommitterEmail'),
        committerName?: string(name='CommitterName'),
        createdAt?: string(name='CreatedAt'),
        id?: string(name='Id'),
        message?: string(name='Message'),
        parentIds?: [ string ](name='ParentIds'),
        shortId?: string(name='ShortId'),
        signature?: {
          gpgKeyId?: string(name='GpgKeyId'),
          verificationStatus?: string(name='VerificationStatus'),
        }(name='Signature'),
        title?: string(name='Title'),
      }(name='Commit'),
      id?: string(name='Id'),
      message?: string(name='Message'),
      name?: string(name='Name'),
      signature?: {
        gpgKeyId?: string(name='GpgKeyId'),
        verificationStatus?: string(name='VerificationStatus'),
      }(name='Signature'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
  total?: long(name='Total'),
}

model ListRepositoryTagsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRepositoryTagsResponseBody(name='body'),
}

async function listRepositoryTags(ProjectId: string, request: ListRepositoryTagsRequest): ListRepositoryTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRepositoryTagsWithOptions(ProjectId, request, headers, runtime);
}

async function listRepositoryTagsWithOptions(ProjectId: string, request: ListRepositoryTagsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRepositoryTagsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.page)) {
    query['Page'] = request.page;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.search)) {
    query['Search'] = request.search;
  }
  if (!Util.isUnset(request.showSignature)) {
    query['ShowSignature'] = request.showSignature;
  }
  if (!Util.isUnset(request.sort)) {
    query['Sort'] = request.sort;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRepositoryTags',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v4/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/repository/tags`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListRepositoryTreeRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  path?: string(name='Path'),
  refName?: string(name='RefName'),
  subUserId?: string(name='SubUserId'),
  type?: string(name='Type'),
}

model ListRepositoryTreeResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      id?: string(name='Id'),
      mode?: string(name='Mode'),
      name?: string(name='Name'),
      path?: string(name='Path'),
      type?: string(name='Type'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
}

model ListRepositoryTreeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRepositoryTreeResponseBody(name='body'),
}

async function listRepositoryTree(ProjectId: string, request: ListRepositoryTreeRequest): ListRepositoryTreeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRepositoryTreeWithOptions(ProjectId, request, headers, runtime);
}

async function listRepositoryTreeWithOptions(ProjectId: string, request: ListRepositoryTreeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRepositoryTreeResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.path)) {
    query['Path'] = request.path;
  }
  if (!Util.isUnset(request.refName)) {
    query['RefName'] = request.refName;
  }
  if (!Util.isUnset(request.subUserId)) {
    query['SubUserId'] = request.subUserId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRepositoryTree',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v4/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/repository/tree`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListRepositoryWebhookRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  page?: long(name='Page'),
  pageSize?: long(name='PageSize'),
}

model ListRepositoryWebhookResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      createdAt?: string(name='CreatedAt'),
      description?: string(name='Description'),
      enableSslVerification?: boolean(name='EnableSslVerification'),
      id?: long(name='Id'),
      lastTestResult?: string(name='LastTestResult'),
      mergeRequestsEvents?: boolean(name='MergeRequestsEvents'),
      noteEvents?: boolean(name='NoteEvents'),
      projectId?: long(name='ProjectId'),
      pushEvents?: boolean(name='PushEvents'),
      secretToken?: string(name='SecretToken'),
      tagPushEvents?: boolean(name='TagPushEvents'),
      url?: string(name='Url'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
  total?: long(name='Total'),
}

model ListRepositoryWebhookResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRepositoryWebhookResponseBody(name='body'),
}

async function listRepositoryWebhook(ProjectId: string, request: ListRepositoryWebhookRequest): ListRepositoryWebhookResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRepositoryWebhookWithOptions(ProjectId, request, headers, runtime);
}

async function listRepositoryWebhookWithOptions(ProjectId: string, request: ListRepositoryWebhookRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRepositoryWebhookResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.page)) {
    query['Page'] = request.page;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRepositoryWebhook',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v3/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/hooks`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model MergeMergeRequestRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model MergeMergeRequestResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    acceptedRevision?: string(name='AcceptedRevision'),
    aheadCommitCount?: int32(name='AheadCommitCount'),
    approveCheckResult?: {
      satisfiedCheckResults?: [ 
        {
          checkName?: string(name='CheckName'),
          checkStatus?: string(name='CheckStatus'),
          checkType?: string(name='CheckType'),
          extraUsers?: [ 
            {
              avatarUrl?: string(name='AvatarUrl'),
              externUserId?: string(name='ExternUserId'),
              id?: long(name='Id'),
              name?: string(name='Name'),
            }
          ](name='ExtraUsers'),
          satisfiedItems?: [ string ](name='SatisfiedItems'),
          unsatisfiedItems?: [ string ](name='UnsatisfiedItems'),
        }
      ](name='SatisfiedCheckResults'),
      totalCheckResult?: string(name='TotalCheckResult'),
      unsatisfiedCheckResults?: [ 
        {
          checkName?: string(name='CheckName'),
          checkStatus?: string(name='CheckStatus'),
          checkType?: string(name='CheckType'),
          extraUsers?: [ 
            {
              avatarUrl?: string(name='AvatarUrl'),
              externUserId?: string(name='ExternUserId'),
              id?: long(name='Id'),
              name?: string(name='Name'),
            }
          ](name='ExtraUsers'),
          satisfiedItems?: [ string ](name='SatisfiedItems'),
          unsatisfiedItems?: [ string ](name='UnsatisfiedItems'),
        }
      ](name='UnsatisfiedCheckResults'),
    }(name='ApproveCheckResult'),
    assigneeList?: [ 
      {
        avatarUrl?: string(name='AvatarUrl'),
        externUserId?: string(name='ExternUserId'),
        id?: string(name='Id'),
        name?: string(name='Name'),
      }
    ](name='AssigneeList'),
    author?: {
      avatarUrl?: string(name='AvatarUrl'),
      externUserId?: string(name='ExternUserId'),
      id?: long(name='Id'),
      name?: string(name='Name'),
    }(name='Author'),
    behindCommitCount?: int32(name='BehindCommitCount'),
    createdAt?: string(name='CreatedAt'),
    description?: string(name='Description'),
    id?: long(name='Id'),
    mergeError?: string(name='MergeError'),
    mergeStatus?: string(name='MergeStatus'),
    mergeType?: string(name='MergeType'),
    mergedRevision?: string(name='MergedRevision'),
    nameWithNamespace?: string(name='NameWithNamespace'),
    projectId?: long(name='ProjectId'),
    sourceBranch?: string(name='SourceBranch'),
    state?: string(name='State'),
    targetBranch?: string(name='TargetBranch'),
    title?: string(name='Title'),
    updatedAt?: string(name='UpdatedAt'),
    webUrl?: string(name='WebUrl'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model MergeMergeRequestResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MergeMergeRequestResponseBody(name='body'),
}

async function mergeMergeRequest(ProjectId: string, MergeRequestId: string, request: MergeMergeRequestRequest): MergeMergeRequestResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return mergeMergeRequestWithOptions(ProjectId, MergeRequestId, request, headers, runtime);
}

async function mergeMergeRequestWithOptions(ProjectId: string, MergeRequestId: string, request: MergeMergeRequestRequest, headers: map[string]string, runtime: Util.RuntimeOptions): MergeMergeRequestResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query['SubUserId'] = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'MergeMergeRequest',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v3/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/merge_request/${OpenApiUtil.getEncodeParam(MergeRequestId)}/merge`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model QuerySlsRelationRequest {
  organizationId?: string(name='OrganizationId'),
  aliyunUserId?: string(name='aliyunUserId'),
  codeupProjectId?: long(name='codeupProjectId'),
  slsLogStore?: string(name='slsLogStore'),
  slsProject?: string(name='slsProject'),
}

model QuerySlsRelationResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      aliyunUserId?: string(name='aliyunUserId'),
      codeupProjectId?: long(name='codeupProjectId'),
      defaultViewer?: boolean(name='defaultViewer'),
      organizationId?: string(name='organizationId'),
      slsLogStore?: string(name='slsLogStore'),
      slsProject?: string(name='slsProject'),
    }
  ](name='Result'),
  success?: string(name='Success'),
}

model QuerySlsRelationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QuerySlsRelationResponseBody(name='body'),
}

async function querySlsRelation(request: QuerySlsRelationRequest): QuerySlsRelationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return querySlsRelationWithOptions(request, headers, runtime);
}

async function querySlsRelationWithOptions(request: QuerySlsRelationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QuerySlsRelationResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.aliyunUserId)) {
    body['aliyunUserId'] = request.aliyunUserId;
  }
  if (!Util.isUnset(request.codeupProjectId)) {
    body['codeupProjectId'] = request.codeupProjectId;
  }
  if (!Util.isUnset(request.slsLogStore)) {
    body['slsLogStore'] = request.slsLogStore;
  }
  if (!Util.isUnset(request.slsProject)) {
    body['slsProject'] = request.slsProject;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QuerySlsRelation',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v3/repository/query_sls_relation`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RelatedSlsLogStoreRequest {
  organizationId?: string(name='OrganizationId'),
  aliyunUserId?: string(name='aliyunUserId'),
  codeupProjectId?: long(name='codeupProjectId'),
  defaultViewer?: boolean(name='defaultViewer'),
  slsLogStore?: string(name='slsLogStore'),
  slsProject?: string(name='slsProject'),
}

model RelatedSlsLogStoreResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    relatedResult?: boolean(name='RelatedResult'),
  }(name='Result'),
  success?: string(name='Success'),
}

model RelatedSlsLogStoreResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RelatedSlsLogStoreResponseBody(name='body'),
}

async function relatedSlsLogStore(request: RelatedSlsLogStoreRequest): RelatedSlsLogStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return relatedSlsLogStoreWithOptions(request, headers, runtime);
}

async function relatedSlsLogStoreWithOptions(request: RelatedSlsLogStoreRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RelatedSlsLogStoreResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.aliyunUserId)) {
    body['aliyunUserId'] = request.aliyunUserId;
  }
  if (!Util.isUnset(request.codeupProjectId)) {
    body['codeupProjectId'] = request.codeupProjectId;
  }
  if (!Util.isUnset(request.defaultViewer)) {
    body['defaultViewer'] = request.defaultViewer;
  }
  if (!Util.isUnset(request.slsLogStore)) {
    body['slsLogStore'] = request.slsLogStore;
  }
  if (!Util.isUnset(request.slsProject)) {
    body['slsProject'] = request.slsProject;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RelatedSlsLogStore',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v3/repository/related_to_sls_log_store`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model TriggerRepositoryMirrorSyncRequest {
  accessToken?: string(name='AccessToken'),
  account?: string(name='Account'),
  organizationId?: string(name='OrganizationId'),
  token?: string(name='Token'),
}

model TriggerRepositoryMirrorSyncResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    result?: boolean(name='Result'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model TriggerRepositoryMirrorSyncResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TriggerRepositoryMirrorSyncResponseBody(name='body'),
}

async function triggerRepositoryMirrorSync(ProjectId: string, request: TriggerRepositoryMirrorSyncRequest): TriggerRepositoryMirrorSyncResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return triggerRepositoryMirrorSyncWithOptions(ProjectId, request, headers, runtime);
}

async function triggerRepositoryMirrorSyncWithOptions(ProjectId: string, request: TriggerRepositoryMirrorSyncRequest, headers: map[string]string, runtime: Util.RuntimeOptions): TriggerRepositoryMirrorSyncResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.account)) {
    query['Account'] = request.account;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.token)) {
    query['Token'] = request.token;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TriggerRepositoryMirrorSync',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v4/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/mirror`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UnRelatedSlsLogStoreRequest {
  organizationId?: string(name='OrganizationId'),
  aliyunUserId?: string(name='aliyunUserId'),
  codeupProjectId?: long(name='codeupProjectId'),
  slsLogStore?: string(name='slsLogStore'),
  slsProject?: string(name='slsProject'),
}

model UnRelatedSlsLogStoreResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    unRelatedResult?: boolean(name='UnRelatedResult'),
  }(name='Result'),
  success?: string(name='Success'),
}

model UnRelatedSlsLogStoreResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UnRelatedSlsLogStoreResponseBody(name='body'),
}

async function unRelatedSlsLogStore(request: UnRelatedSlsLogStoreRequest): UnRelatedSlsLogStoreResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return unRelatedSlsLogStoreWithOptions(request, headers, runtime);
}

async function unRelatedSlsLogStoreWithOptions(request: UnRelatedSlsLogStoreRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UnRelatedSlsLogStoreResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.aliyunUserId)) {
    body['aliyunUserId'] = request.aliyunUserId;
  }
  if (!Util.isUnset(request.codeupProjectId)) {
    body['codeupProjectId'] = request.codeupProjectId;
  }
  if (!Util.isUnset(request.slsLogStore)) {
    body['slsLogStore'] = request.slsLogStore;
  }
  if (!Util.isUnset(request.slsProject)) {
    body['slsProject'] = request.slsProject;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UnRelatedSlsLogStore',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v3/repository/unrelated_to_sls_log_store`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateFileRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model UpdateFileResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    branchName?: string(name='BranchName'),
    filePath?: string(name='FilePath'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model UpdateFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateFileResponseBody(name='body'),
}

async function updateFile(ProjectId: string, request: UpdateFileRequest): UpdateFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateFileWithOptions(ProjectId, request, headers, runtime);
}

async function updateFileWithOptions(ProjectId: string, request: UpdateFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateFileResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query['SubUserId'] = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateFile',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v4/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/repository/files`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateGroupMemberRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model UpdateGroupMemberResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    accessLevel?: int32(name='AccessLevel'),
    avatarUrl?: string(name='AvatarUrl'),
    email?: string(name='Email'),
    externUserId?: string(name='ExternUserId'),
    id?: long(name='Id'),
    state?: string(name='State'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model UpdateGroupMemberResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateGroupMemberResponseBody(name='body'),
}

async function updateGroupMember(GroupId: string, UserId: string, request: UpdateGroupMemberRequest): UpdateGroupMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateGroupMemberWithOptions(GroupId, UserId, request, headers, runtime);
}

async function updateGroupMemberWithOptions(GroupId: string, UserId: string, request: UpdateGroupMemberRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateGroupMemberResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query['SubUserId'] = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateGroupMember',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v3/groups/${OpenApiUtil.getEncodeParam(GroupId)}/members/${OpenApiUtil.getEncodeParam(UserId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateMergeRequestRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
}

model UpdateMergeRequestResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    acceptedRevision?: string(name='AcceptedRevision'),
    aheadCommitCount?: int32(name='AheadCommitCount'),
    approveCheckResult?: {
      satisfiedCheckResults?: [ 
        {
          checkName?: string(name='CheckName'),
          checkStatus?: string(name='CheckStatus'),
          checkType?: string(name='CheckType'),
          extraUsers?: [ 
            {
              avatarUrl?: string(name='AvatarUrl'),
              externUserId?: string(name='ExternUserId'),
              id?: long(name='Id'),
              name?: string(name='Name'),
            }
          ](name='ExtraUsers'),
          satisfiedItems?: [ string ](name='SatisfiedItems'),
          unsatisfiedItems?: [ string ](name='UnsatisfiedItems'),
        }
      ](name='SatisfiedCheckResults'),
      totalCheckResult?: string(name='TotalCheckResult'),
      unsatisfiedCheckResults?: [ 
        {
          checkName?: string(name='CheckName'),
          checkStatus?: string(name='CheckStatus'),
          checkType?: string(name='CheckType'),
          extraUsers?: [ 
            {
              avatarUrl?: string(name='AvatarUrl'),
              externUserId?: string(name='ExternUserId'),
              id?: long(name='Id'),
              name?: string(name='Name'),
            }
          ](name='ExtraUsers'),
          satisfiedItems?: [ string ](name='SatisfiedItems'),
          unsatisfiedItems?: [ string ](name='UnsatisfiedItems'),
        }
      ](name='UnsatisfiedCheckResults'),
    }(name='ApproveCheckResult'),
    assigneeList?: [ 
      {
        avatarUrl?: string(name='AvatarUrl'),
        externUserId?: string(name='ExternUserId'),
        id?: string(name='Id'),
        name?: string(name='Name'),
      }
    ](name='AssigneeList'),
    author?: {
      avatarUrl?: string(name='AvatarUrl'),
      externUserId?: string(name='ExternUserId'),
      id?: long(name='Id'),
      name?: string(name='Name'),
    }(name='Author'),
    behindCommitCount?: int32(name='BehindCommitCount'),
    createdAt?: string(name='CreatedAt'),
    description?: string(name='Description'),
    id?: long(name='Id'),
    mergeError?: string(name='MergeError'),
    mergeStatus?: string(name='MergeStatus'),
    mergeType?: string(name='MergeType'),
    mergedRevision?: string(name='MergedRevision'),
    nameWithNamespace?: string(name='NameWithNamespace'),
    projectId?: long(name='ProjectId'),
    sourceBranch?: string(name='SourceBranch'),
    state?: string(name='State'),
    targetBranch?: string(name='TargetBranch'),
    title?: string(name='Title'),
    updatedAt?: string(name='UpdatedAt'),
    webUrl?: string(name='WebUrl'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model UpdateMergeRequestResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateMergeRequestResponseBody(name='body'),
}

async function updateMergeRequest(ProjectId: string, MergeRequestId: string, request: UpdateMergeRequestRequest): UpdateMergeRequestResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateMergeRequestWithOptions(ProjectId, MergeRequestId, request, headers, runtime);
}

async function updateMergeRequestWithOptions(ProjectId: string, MergeRequestId: string, request: UpdateMergeRequestRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateMergeRequestResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMergeRequest',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v3/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/merge_request/${OpenApiUtil.getEncodeParam(MergeRequestId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateMergeRequestCommentRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
}

model UpdateMergeRequestCommentResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    result?: boolean(name='Result'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model UpdateMergeRequestCommentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateMergeRequestCommentResponseBody(name='body'),
}

async function updateMergeRequestComment(ProjectId: string, MergeRequestId: string, NoteId: string, request: UpdateMergeRequestCommentRequest): UpdateMergeRequestCommentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateMergeRequestCommentWithOptions(ProjectId, MergeRequestId, NoteId, request, headers, runtime);
}

async function updateMergeRequestCommentWithOptions(ProjectId: string, MergeRequestId: string, NoteId: string, request: UpdateMergeRequestCommentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateMergeRequestCommentResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMergeRequestComment',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v3/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/merge_requests/${OpenApiUtil.getEncodeParam(MergeRequestId)}/notes/${OpenApiUtil.getEncodeParam(NoteId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateMergeRequestSettingRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
}

model UpdateMergeRequestSettingResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    result?: boolean(name='Result'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model UpdateMergeRequestSettingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateMergeRequestSettingResponseBody(name='body'),
}

async function updateMergeRequestSetting(ProjectId: string, request: UpdateMergeRequestSettingRequest): UpdateMergeRequestSettingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateMergeRequestSettingWithOptions(ProjectId, request, headers, runtime);
}

async function updateMergeRequestSettingWithOptions(ProjectId: string, request: UpdateMergeRequestSettingRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateMergeRequestSettingResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMergeRequestSetting',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v4/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/settings/merge_requests`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateRepositoryRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
}

model UpdateRepositoryResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    archive?: boolean(name='Archive'),
    avatarUrl?: string(name='AvatarUrl'),
    createdAt?: string(name='CreatedAt'),
    creatorId?: long(name='CreatorId'),
    defaultBranch?: string(name='DefaultBranch'),
    description?: string(name='Description'),
    httpUrlToRepo?: string(name='HttpUrlToRepo'),
    id?: long(name='Id'),
    lastActivityAt?: string(name='LastActivityAt'),
    name?: string(name='Name'),
    nameWithNamespace?: string(name='NameWithNamespace'),
    namespace?: {
      avatar?: string(name='Avatar'),
      createdAt?: string(name='CreatedAt'),
      description?: string(name='Description'),
      id?: long(name='Id'),
      name?: string(name='Name'),
      ownerId?: long(name='OwnerId'),
      path?: string(name='Path'),
      public?: boolean(name='Public'),
      updatedAt?: string(name='UpdatedAt'),
      visibilityLevel?: string(name='VisibilityLevel'),
    }(name='Namespace'),
    path?: string(name='Path'),
    pathWithNamespace?: string(name='PathWithNamespace'),
    sshUrlToRepo?: string(name='SshUrlToRepo'),
    visibilityLevel?: string(name='VisibilityLevel'),
    webUrl?: string(name='WebUrl'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model UpdateRepositoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateRepositoryResponseBody(name='body'),
}

async function updateRepository(ProjectId: string, request: UpdateRepositoryRequest): UpdateRepositoryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateRepositoryWithOptions(ProjectId, request, headers, runtime);
}

async function updateRepositoryWithOptions(ProjectId: string, request: UpdateRepositoryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateRepositoryResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateRepository',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v3/projects/${OpenApiUtil.getEncodeParam(ProjectId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateRepositoryMemberRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model UpdateRepositoryMemberResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: {
    accessLevel?: int32(name='AccessLevel'),
    avatarUrl?: string(name='AvatarUrl'),
    email?: string(name='Email'),
    externUserId?: string(name='ExternUserId'),
    id?: long(name='Id'),
    state?: string(name='State'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model UpdateRepositoryMemberResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateRepositoryMemberResponseBody(name='body'),
}

async function updateRepositoryMember(ProjectId: string, UserId: string, request: UpdateRepositoryMemberRequest): UpdateRepositoryMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateRepositoryMemberWithOptions(ProjectId, UserId, request, headers, runtime);
}

async function updateRepositoryMemberWithOptions(ProjectId: string, UserId: string, request: UpdateRepositoryMemberRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateRepositoryMemberResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query['OrganizationId'] = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query['SubUserId'] = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateRepositoryMember',
    version = '2020-04-14',
    protocol = 'HTTPS',
    pathname = `/api/v3/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/members/${OpenApiUtil.getEncodeParam(UserId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

