/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('codeup', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model DeleteRepositoryMemberRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model DeleteRepositoryMemberResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  result?: {
    userId?: long(name='UserId'),
    sourceType?: string(name='SourceType'),
    createdAt?: string(name='CreatedAt'),
    message?: string(name='Message'),
    accessLevel?: int32(name='AccessLevel'),
    updatedAt?: string(name='UpdatedAt'),
    sourceId?: long(name='SourceId'),
    notificationLevel?: int32(name='NotificationLevel'),
    id?: long(name='Id'),
  }(name='Result'),
}

model DeleteRepositoryMemberResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteRepositoryMemberResponseBody(name='body'),
}

async function deleteRepositoryMember(ProjectId: string, UserId: string, request: DeleteRepositoryMemberRequest): DeleteRepositoryMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteRepositoryMemberWithOptions(ProjectId, UserId, request, headers, runtime);
}

async function deleteRepositoryMemberWithOptions(ProjectId: string, UserId: string, request: DeleteRepositoryMemberRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteRepositoryMemberResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeleteRepositoryMember', '2020-04-14', 'HTTPS', 'DELETE', 'AK', `/api/v3/projects/${ProjectId}/members/${UserId}`, 'json', req, runtime);
}

model CreateRepositoryProtectedBranchRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
}

model CreateRepositoryProtectedBranchResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  result?: {
    branch?: string(name='Branch'),
    id?: long(name='Id'),
    allowPushRoles?: [ int32 ](name='AllowPushRoles'),
    allowMergeRoles?: [ int32 ](name='AllowMergeRoles'),
    mergeRequestSetting?: {
      mergeRequestMode?: string(name='MergeRequestMode'),
      allowSelfApproval?: boolean(name='AllowSelfApproval'),
      isRequireDiscussionProcessed?: boolean(name='IsRequireDiscussionProcessed'),
      required?: boolean(name='Required'),
      isResetApprovalWhenNewPush?: boolean(name='IsResetApprovalWhenNewPush'),
      minimualApproval?: int32(name='MinimualApproval'),
      defaultAssignees?: [ string ](name='DefaultAssignees'),
      allowMergeRequestRoles?: [ int32 ](name='AllowMergeRequestRoles'),
    }(name='MergeRequestSetting'),
    testSetting?: {
      required?: boolean(name='Required'),
      codingGuidelinesDetection?: {
        message?: string(name='Message'),
        enabled?: boolean(name='Enabled'),
      }(name='CodingGuidelinesDetection'),
      sensitiveInfoDetection?: {
        message?: string(name='Message'),
        enabled?: boolean(name='Enabled'),
      }(name='SensitiveInfoDetection'),
      checkConfig?: {
        checkItems?: [ 
          {
            name?: string(name='Name'),
            required?: boolean(name='Required'),
          }
        ](name='CheckItems'),
      }(name='CheckConfig'),
    }(name='TestSetting'),
  }(name='Result'),
}

model CreateRepositoryProtectedBranchResponse = {
  headers: map[string]string(name='headers'),
  body: CreateRepositoryProtectedBranchResponseBody(name='body'),
}

async function createRepositoryProtectedBranch(ProjectId: string, request: CreateRepositoryProtectedBranchRequest): CreateRepositoryProtectedBranchResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createRepositoryProtectedBranchWithOptions(ProjectId, request, headers, runtime);
}

async function createRepositoryProtectedBranchWithOptions(ProjectId: string, request: CreateRepositoryProtectedBranchRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateRepositoryProtectedBranchResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('CreateRepositoryProtectedBranch', '2020-04-14', 'HTTPS', 'POST', 'AK', `/api/v4/projects/${ProjectId}/repository/protect_branches`, 'json', req, runtime);
}

model CreateMergeRequestRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model CreateMergeRequestResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  result?: {
    behindCommitCount?: int32(name='BehindCommitCount'),
    state?: string(name='State'),
    projectId?: long(name='ProjectId'),
    createdAt?: string(name='CreatedAt'),
    acceptedRevision?: string(name='AcceptedRevision'),
    sourceBranch?: string(name='SourceBranch'),
    webUrl?: string(name='WebUrl'),
    description?: string(name='Description'),
    mergeType?: string(name='MergeType'),
    nameWithNamespace?: string(name='NameWithNamespace'),
    targetBranch?: string(name='TargetBranch'),
    aheadCommitCount?: int32(name='AheadCommitCount'),
    updatedAt?: string(name='UpdatedAt'),
    title?: string(name='Title'),
    mergeError?: string(name='MergeError'),
    mergedRevision?: string(name='MergedRevision'),
    id?: long(name='Id'),
    mergeStatus?: string(name='MergeStatus'),
    assigneeList?: [ 
      {
        externUserId?: string(name='ExternUserId'),
        name?: string(name='Name'),
        avatarUrl?: string(name='AvatarUrl'),
        id?: string(name='Id'),
      }
    ](name='AssigneeList'),
    author?: {
      externUserId?: string(name='ExternUserId'),
      name?: string(name='Name'),
      avatarUrl?: string(name='AvatarUrl'),
      id?: long(name='Id'),
    }(name='Author'),
    approveCheckResult?: {
      totalCheckResult?: string(name='TotalCheckResult'),
      satisfiedCheckResults?: [ 
        {
          checkStatus?: string(name='CheckStatus'),
          checkType?: string(name='CheckType'),
          checkName?: string(name='CheckName'),
          extraUsers?: [ 
            {
              externUserId?: string(name='ExternUserId'),
              name?: string(name='Name'),
              avatarUrl?: string(name='AvatarUrl'),
              id?: long(name='Id'),
            }
          ](name='ExtraUsers'),
          unsatisfiedItems?: [ string ](name='UnsatisfiedItems'),
          satisfiedItems?: [ string ](name='SatisfiedItems'),
        }
      ](name='SatisfiedCheckResults'),
      unsatisfiedCheckResults?: [ 
        {
          checkStatus?: string(name='CheckStatus'),
          checkType?: string(name='CheckType'),
          checkName?: string(name='CheckName'),
          extraUsers?: [ 
            {
              externUserId?: string(name='ExternUserId'),
              name?: string(name='Name'),
              avatarUrl?: string(name='AvatarUrl'),
              id?: long(name='Id'),
            }
          ](name='ExtraUsers'),
          unsatisfiedItems?: [ string ](name='UnsatisfiedItems'),
          satisfiedItems?: [ string ](name='SatisfiedItems'),
        }
      ](name='UnsatisfiedCheckResults'),
    }(name='ApproveCheckResult'),
  }(name='Result'),
}

model CreateMergeRequestResponse = {
  headers: map[string]string(name='headers'),
  body: CreateMergeRequestResponseBody(name='body'),
}

async function createMergeRequest(ProjectId: string, request: CreateMergeRequestRequest): CreateMergeRequestResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createMergeRequestWithOptions(ProjectId, request, headers, runtime);
}

async function createMergeRequestWithOptions(ProjectId: string, request: CreateMergeRequestRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateMergeRequestResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('CreateMergeRequest', '2020-04-14', 'HTTPS', 'POST', 'AK', `/api/v4/projects/${ProjectId}/merge_requests`, 'json', req, runtime);
}

model DeleteRepositoryMemberWithExternUidRequest {
  accessToken?: string(name='AccessToken', description='个人访问令牌。 使用阿里云AK+SK或使用STS临时授权方式不需要传该字段'),
  organizationId?: string(name='OrganizationId', description='企业标识，也称企业id，字符串形式，可在云效访问链接中获取，如 https://devops.aliyun.com/organization/'),
  externUserId?: string(name='ExternUserId', description='云效用户ID'),
}

model DeleteRepositoryMemberWithExternUidResponseBody = {
  errorMessage?: string(name='ErrorMessage', description='错误信息'),
  requestId?: string(name='RequestId', description='请求ID'),
  errorCode?: string(name='ErrorCode', description='错误码'),
  success?: boolean(name='Success', description='请求结果'),
  result?: {
    userId?: long(name='UserId', description='Codeup用户ID'),
    sourceType?: string(name='SourceType', description='资源类型'),
    createdAt?: string(name='CreatedAt', description='创建时间'),
    accessLevel?: int32(name='AccessLevel', description='权限类型。20-浏览者，30-开发者,40-管理员。'),
    updatedAt?: string(name='UpdatedAt', description='更新时间'),
    sourceId?: long(name='SourceId', description='代码库ID'),
    id?: long(name='Id', description='ID'),
  }(name='Result', description='响应结果'),
}

model DeleteRepositoryMemberWithExternUidResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteRepositoryMemberWithExternUidResponseBody(name='body'),
}

async function deleteRepositoryMemberWithExternUid(ProjectId: string, request: DeleteRepositoryMemberWithExternUidRequest): DeleteRepositoryMemberWithExternUidResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteRepositoryMemberWithExternUidWithOptions(ProjectId, request, headers, runtime);
}

async function deleteRepositoryMemberWithExternUidWithOptions(ProjectId: string, request: DeleteRepositoryMemberWithExternUidRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteRepositoryMemberWithExternUidResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.externUserId)) {
    query.ExternUserId = request.externUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeleteRepositoryMemberWithExternUid', '2020-04-14', 'HTTPS', 'POST', 'AK', `/api/v4/projects/${ProjectId}/members/remove`, 'json', req, runtime);
}

model DeleteRepositoryRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model DeleteRepositoryResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  result?: {
    result?: boolean(name='Result'),
  }(name='Result'),
}

model DeleteRepositoryResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteRepositoryResponseBody(name='body'),
}

async function deleteRepository(ProjectId: string, request: DeleteRepositoryRequest): DeleteRepositoryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteRepositoryWithOptions(ProjectId, request, headers, runtime);
}

async function deleteRepositoryWithOptions(ProjectId: string, request: DeleteRepositoryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteRepositoryResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeleteRepository', '2020-04-14', 'HTTPS', 'POST', 'AK', `/api/v3/projects/${ProjectId}/remove`, 'json', req, runtime);
}

model GetRepositoryTagRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
}

model GetRepositoryTagResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  result?: {
    message?: string(name='Message'),
    name?: string(name='Name'),
    id?: string(name='Id'),
    commit?: {
      shortId?: string(name='ShortId'),
      authorName?: string(name='AuthorName'),
      createdAt?: string(name='CreatedAt'),
      message?: string(name='Message'),
      authoredDate?: string(name='AuthoredDate'),
      committerName?: string(name='CommitterName'),
      title?: string(name='Title'),
      authorEmail?: string(name='AuthorEmail'),
      committerEmail?: string(name='CommitterEmail'),
      id?: string(name='Id'),
      committedDate?: string(name='CommittedDate'),
      parentIds?: [ string ](name='ParentIds'),
      signature?: {
        verificationStatus?: string(name='VerificationStatus'),
        gpgKeyId?: string(name='GpgKeyId'),
      }(name='Signature'),
    }(name='Commit'),
    signature?: {
      verificationStatus?: string(name='VerificationStatus'),
      gpgKeyId?: string(name='GpgKeyId'),
    }(name='Signature'),
  }(name='Result'),
}

model GetRepositoryTagResponse = {
  headers: map[string]string(name='headers'),
  body: GetRepositoryTagResponseBody(name='body'),
}

async function getRepositoryTag(ProjectId: string, TagName: string, request: GetRepositoryTagRequest): GetRepositoryTagResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getRepositoryTagWithOptions(ProjectId, TagName, request, headers, runtime);
}

async function getRepositoryTagWithOptions(ProjectId: string, TagName: string, request: GetRepositoryTagRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetRepositoryTagResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetRepositoryTag', '2020-04-14', 'HTTPS', 'GET', 'AK', `/api/v3/projects/${ProjectId}/repository/tags/${TagName}`, 'json', req, runtime);
}

model UpdateMergeRequestRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
}

model UpdateMergeRequestResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  result?: {
    state?: string(name='State'),
    behindCommitCount?: int32(name='BehindCommitCount'),
    projectId?: long(name='ProjectId'),
    createdAt?: string(name='CreatedAt'),
    acceptedRevision?: string(name='AcceptedRevision'),
    sourceBranch?: string(name='SourceBranch'),
    webUrl?: string(name='WebUrl'),
    description?: string(name='Description'),
    nameWithNamespace?: string(name='NameWithNamespace'),
    mergeType?: string(name='MergeType'),
    targetBranch?: string(name='TargetBranch'),
    aheadCommitCount?: int32(name='AheadCommitCount'),
    updatedAt?: string(name='UpdatedAt'),
    title?: string(name='Title'),
    mergeError?: string(name='MergeError'),
    mergedRevision?: string(name='MergedRevision'),
    id?: long(name='Id'),
    mergeStatus?: string(name='MergeStatus'),
    assigneeList?: [ 
      {
        externUserId?: string(name='ExternUserId'),
        name?: string(name='Name'),
        avatarUrl?: string(name='AvatarUrl'),
        id?: string(name='Id'),
      }
    ](name='AssigneeList'),
    approveCheckResult?: {
      totalCheckResult?: string(name='TotalCheckResult'),
      satisfiedCheckResults?: [ 
        {
          checkStatus?: string(name='CheckStatus'),
          checkType?: string(name='CheckType'),
          checkName?: string(name='CheckName'),
          extraUsers?: [ 
            {
              externUserId?: string(name='ExternUserId'),
              name?: string(name='Name'),
              avatarUrl?: string(name='AvatarUrl'),
              id?: long(name='Id'),
            }
          ](name='ExtraUsers'),
          unsatisfiedItems?: [ string ](name='UnsatisfiedItems'),
          satisfiedItems?: [ string ](name='SatisfiedItems'),
        }
      ](name='SatisfiedCheckResults'),
      unsatisfiedCheckResults?: [ 
        {
          checkStatus?: string(name='CheckStatus'),
          checkType?: string(name='CheckType'),
          checkName?: string(name='CheckName'),
          extraUsers?: [ 
            {
              externUserId?: string(name='ExternUserId'),
              name?: string(name='Name'),
              avatarUrl?: string(name='AvatarUrl'),
              id?: long(name='Id'),
            }
          ](name='ExtraUsers'),
          unsatisfiedItems?: [ string ](name='UnsatisfiedItems'),
          satisfiedItems?: [ string ](name='SatisfiedItems'),
        }
      ](name='UnsatisfiedCheckResults'),
    }(name='ApproveCheckResult'),
    author?: {
      externUserId?: string(name='ExternUserId'),
      name?: string(name='Name'),
      avatarUrl?: string(name='AvatarUrl'),
      id?: long(name='Id'),
    }(name='Author'),
  }(name='Result'),
}

model UpdateMergeRequestResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateMergeRequestResponseBody(name='body'),
}

async function updateMergeRequest(ProjectId: string, MergeRequestId: string, request: UpdateMergeRequestRequest): UpdateMergeRequestResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateMergeRequestWithOptions(ProjectId, MergeRequestId, request, headers, runtime);
}

async function updateMergeRequestWithOptions(ProjectId: string, MergeRequestId: string, request: UpdateMergeRequestRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateMergeRequestResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateMergeRequest', '2020-04-14', 'HTTPS', 'PUT', 'AK', `/api/v3/projects/${ProjectId}/merge_request/${MergeRequestId}`, 'json', req, runtime);
}

model UpdateRepositoryRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
}

model UpdateRepositoryResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  result?: {
    lastActivityAt?: string(name='LastActivityAt'),
    defaultBranch?: string(name='DefaultBranch'),
    avatarUrl?: string(name='AvatarUrl'),
    archive?: boolean(name='Archive'),
    createdAt?: string(name='CreatedAt'),
    creatorId?: long(name='CreatorId'),
    httpUrlToRepo?: string(name='HttpUrlToRepo'),
    webUrl?: string(name='WebUrl'),
    description?: string(name='Description'),
    nameWithNamespace?: string(name='NameWithNamespace'),
    pathWithNamespace?: string(name='PathWithNamespace'),
    visibilityLevel?: string(name='VisibilityLevel'),
    path?: string(name='Path'),
    sshUrlToRepo?: string(name='SshUrlToRepo'),
    name?: string(name='Name'),
    id?: long(name='Id'),
    namespace?: {
      avatar?: string(name='Avatar'),
      description?: string(name='Description'),
      public?: boolean(name='Public'),
      visibilityLevel?: string(name='VisibilityLevel'),
      path?: string(name='Path'),
      createdAt?: string(name='CreatedAt'),
      updatedAt?: string(name='UpdatedAt'),
      name?: string(name='Name'),
      ownerId?: long(name='OwnerId'),
      id?: long(name='Id'),
    }(name='Namespace'),
  }(name='Result'),
}

model UpdateRepositoryResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateRepositoryResponseBody(name='body'),
}

async function updateRepository(ProjectId: string, request: UpdateRepositoryRequest): UpdateRepositoryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateRepositoryWithOptions(ProjectId, request, headers, runtime);
}

async function updateRepositoryWithOptions(ProjectId: string, request: UpdateRepositoryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateRepositoryResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateRepository', '2020-04-14', 'HTTPS', 'PUT', 'AK', `/api/v3/projects/${ProjectId}`, 'json', req, runtime);
}

model UpdateMergeRequestCommentRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
}

model UpdateMergeRequestCommentResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  result?: {
    result?: boolean(name='Result'),
  }(name='Result'),
}

model UpdateMergeRequestCommentResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateMergeRequestCommentResponseBody(name='body'),
}

async function updateMergeRequestComment(ProjectId: string, MergeRequestId: string, NoteId: string, request: UpdateMergeRequestCommentRequest): UpdateMergeRequestCommentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateMergeRequestCommentWithOptions(ProjectId, MergeRequestId, NoteId, request, headers, runtime);
}

async function updateMergeRequestCommentWithOptions(ProjectId: string, MergeRequestId: string, NoteId: string, request: UpdateMergeRequestCommentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateMergeRequestCommentResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateMergeRequestComment', '2020-04-14', 'HTTPS', 'PUT', 'AK', `/api/v3/projects/${ProjectId}/merge_requests/${MergeRequestId}/notes/${NoteId}`, 'json', req, runtime);
}

model TriggerRepositoryMirrorSyncRequest {
  accessToken?: string(name='AccessToken', description='个人访问令牌。 使用阿里云AK+SK或使用STS临时授权方式不需要传该字段'),
  organizationId?: string(name='OrganizationId', description='企业标识，也称企业id，字符串形式，可在云效访问链接中获取，如 https://devops.aliyun.com/organization/'),
  account?: string(name='Account', description='远程同步库克隆账号'),
  token?: string(name='Token', description='远程同步库克隆令牌'),
}

model TriggerRepositoryMirrorSyncResponseBody = {
  errorMessage?: string(name='ErrorMessage', description='错误信息'),
  requestId?: string(name='RequestId', description='请求ID'),
  success?: boolean(name='Success', description='请求结果'),
  errorCode?: string(name='ErrorCode', description='错误码'),
  result?: {
    result?: boolean(name='Result', description='仓库同步触发结果'),
  }(name='Result', description='响应结果'),
}

model TriggerRepositoryMirrorSyncResponse = {
  headers: map[string]string(name='headers'),
  body: TriggerRepositoryMirrorSyncResponseBody(name='body'),
}

async function triggerRepositoryMirrorSync(ProjectId: string, request: TriggerRepositoryMirrorSyncRequest): TriggerRepositoryMirrorSyncResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return triggerRepositoryMirrorSyncWithOptions(ProjectId, request, headers, runtime);
}

async function triggerRepositoryMirrorSyncWithOptions(ProjectId: string, request: TriggerRepositoryMirrorSyncRequest, headers: map[string]string, runtime: Util.RuntimeOptions): TriggerRepositoryMirrorSyncResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.account)) {
    query.Account = request.account;
  }
  if (!Util.isUnset(request.token)) {
    query.Token = request.token;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('TriggerRepositoryMirrorSync', '2020-04-14', 'HTTPS', 'POST', 'AK', `/api/v4/projects/${ProjectId}/mirror`, 'json', req, runtime);
}

model DeleteBranchRequest {
  accessToken?: string(name='AccessToken'),
  branchName?: string(name='BranchName'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model DeleteBranchResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  result?: {
    branchName?: string(name='BranchName'),
  }(name='Result'),
}

model DeleteBranchResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteBranchResponseBody(name='body'),
}

async function deleteBranch(ProjectId: string, request: DeleteBranchRequest): DeleteBranchResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteBranchWithOptions(ProjectId, request, headers, runtime);
}

async function deleteBranchWithOptions(ProjectId: string, request: DeleteBranchRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteBranchResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.branchName)) {
    query.BranchName = request.branchName;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeleteBranch', '2020-04-14', 'HTTPS', 'DELETE', 'AK', `/api/v3/projects/${ProjectId}/repository/branches/delete`, 'json', req, runtime);
}

model ListRepositoryCommitDiffRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  contextLine?: int32(name='ContextLine'),
}

model ListRepositoryCommitDiffResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  result?: [ 
    {
      deletedFile?: boolean(name='DeletedFile'),
      diff?: string(name='Diff'),
      oldPath?: string(name='OldPath'),
      oldId?: string(name='OldId'),
      BMode?: string(name='BMode'),
      isOldLfs?: boolean(name='IsOldLfs'),
      isNewLfs?: boolean(name='IsNewLfs'),
      renamedFile?: boolean(name='RenamedFile'),
      newFile?: boolean(name='NewFile'),
      newId?: string(name='NewId'),
      isBinary?: boolean(name='IsBinary'),
      newPath?: string(name='NewPath'),
      AMode?: string(name='AMode'),
    }
  ](name='Result'),
}

model ListRepositoryCommitDiffResponse = {
  headers: map[string]string(name='headers'),
  body: ListRepositoryCommitDiffResponseBody(name='body'),
}

async function listRepositoryCommitDiff(ProjectId: string, Sha: string, request: ListRepositoryCommitDiffRequest): ListRepositoryCommitDiffResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRepositoryCommitDiffWithOptions(ProjectId, Sha, request, headers, runtime);
}

async function listRepositoryCommitDiffWithOptions(ProjectId: string, Sha: string, request: ListRepositoryCommitDiffRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRepositoryCommitDiffResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.contextLine)) {
    query.ContextLine = request.contextLine;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListRepositoryCommitDiff', '2020-04-14', 'HTTPS', 'GET', 'AK', `/api/v3/projects/${ProjectId}/repository/commits/${Sha}/diff`, 'json', req, runtime);
}

model GetRepositoryInfoRequest {
  accessToken?: string(name='AccessToken'),
  identity?: string(name='Identity'),
  organizationId?: string(name='OrganizationId'),
}

model GetRepositoryInfoResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: int32(name='ErrorCode'),
  result?: {
    lastActivityAt?: string(name='LastActivityAt'),
    defaultBranch?: string(name='DefaultBranch'),
    avatarUrl?: string(name='AvatarUrl'),
    archive?: boolean(name='Archive'),
    importUrl?: string(name='ImportUrl'),
    createdAt?: string(name='CreatedAt'),
    demoProjectStatus?: boolean(name='DemoProjectStatus'),
    creatorId?: long(name='CreatorId'),
    importStatus?: string(name='ImportStatus'),
    httpUrlToRepo?: string(name='HttpUrlToRepo'),
    webUrl?: string(name='WebUrl'),
    description?: string(name='Description'),
    nameWithNamespace?: string(name='NameWithNamespace'),
    public?: boolean(name='Public'),
    pathWithNamespace?: string(name='PathWithNamespace'),
    path?: string(name='Path'),
    visibilityLevel?: string(name='VisibilityLevel'),
    accessLevel?: int32(name='AccessLevel'),
    importFromSubversion?: boolean(name='ImportFromSubversion'),
    sshUrlToRepo?: string(name='SshUrlToRepo'),
    name?: string(name='Name'),
    id?: long(name='Id'),
    tagList?: [ string ](name='TagList'),
    namespace?: {
      avatar?: string(name='Avatar'),
      description?: string(name='Description'),
      state?: string(name='State'),
      public?: boolean(name='Public'),
      visibilityLevel?: string(name='VisibilityLevel'),
      createdAt?: string(name='CreatedAt'),
      path?: string(name='Path'),
      updatedAt?: string(name='UpdatedAt'),
      name?: string(name='Name'),
      ownerId?: long(name='OwnerId'),
      id?: long(name='Id'),
    }(name='Namespace'),
    permissions?: {
      projectAccess?: {
        accessLevel?: int32(name='AccessLevel'),
      }(name='ProjectAccess'),
      groupAccess?: {
        accessLevel?: int32(name='AccessLevel'),
      }(name='GroupAccess'),
    }(name='Permissions'),
  }(name='Result'),
}

model GetRepositoryInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetRepositoryInfoResponseBody(name='body'),
}

async function getRepositoryInfo(request: GetRepositoryInfoRequest): GetRepositoryInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getRepositoryInfoWithOptions(request, headers, runtime);
}

async function getRepositoryInfoWithOptions(request: GetRepositoryInfoRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetRepositoryInfoResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.identity)) {
    query.Identity = request.identity;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetRepositoryInfo', '2020-04-14', 'HTTPS', 'GET', 'AK', `/api/v3/projects/info`, 'json', req, runtime);
}

model AcceptMergeRequestRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
}

model AcceptMergeRequestResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  result?: {
    state?: string(name='State'),
    behindCommitCount?: int32(name='BehindCommitCount'),
    projectId?: long(name='ProjectId'),
    createdAt?: string(name='CreatedAt'),
    acceptedRevision?: string(name='AcceptedRevision'),
    sourceBranch?: string(name='SourceBranch'),
    webUrl?: string(name='WebUrl'),
    description?: string(name='Description'),
    nameWithNamespace?: string(name='NameWithNamespace'),
    mergeType?: string(name='MergeType'),
    targetBranch?: string(name='TargetBranch'),
    aheadCommitCount?: int32(name='AheadCommitCount'),
    updatedAt?: string(name='UpdatedAt'),
    title?: string(name='Title'),
    mergeError?: string(name='MergeError'),
    mergedRevision?: string(name='MergedRevision'),
    id?: long(name='Id'),
    mergeStatus?: string(name='MergeStatus'),
    assigneeList?: [ 
      {
        externUserId?: string(name='ExternUserId'),
        name?: string(name='Name'),
        avatarUrl?: string(name='AvatarUrl'),
        id?: string(name='Id'),
      }
    ](name='AssigneeList'),
    approveCheckResult?: {
      totalCheckResult?: string(name='TotalCheckResult'),
      satisfiedCheckResults?: [ 
        {
          checkStatus?: string(name='CheckStatus'),
          checkType?: string(name='CheckType'),
          checkName?: string(name='CheckName'),
          extraUsers?: [ 
            {
              externUserId?: string(name='ExternUserId'),
              name?: string(name='Name'),
              avatarUrl?: string(name='AvatarUrl'),
              id?: long(name='Id'),
            }
          ](name='ExtraUsers'),
          unsatisfiedItems?: [ string ](name='UnsatisfiedItems'),
          satisfiedItems?: [ string ](name='SatisfiedItems'),
        }
      ](name='SatisfiedCheckResults'),
      unsatisfiedCheckResults?: [ 
        {
          checkStatus?: string(name='CheckStatus'),
          checkType?: string(name='CheckType'),
          checkName?: string(name='CheckName'),
          extraUsers?: [ 
            {
              externUserId?: string(name='ExternUserId'),
              name?: string(name='Name'),
              avatarUrl?: string(name='AvatarUrl'),
              id?: long(name='Id'),
            }
          ](name='ExtraUsers'),
          unsatisfiedItems?: [ string ](name='UnsatisfiedItems'),
          satisfiedItems?: [ string ](name='SatisfiedItems'),
        }
      ](name='UnsatisfiedCheckResults'),
    }(name='ApproveCheckResult'),
    author?: {
      externUserId?: string(name='ExternUserId'),
      name?: string(name='Name'),
      avatarUrl?: string(name='AvatarUrl'),
      id?: long(name='Id'),
    }(name='Author'),
  }(name='Result'),
}

model AcceptMergeRequestResponse = {
  headers: map[string]string(name='headers'),
  body: AcceptMergeRequestResponseBody(name='body'),
}

async function acceptMergeRequest(ProjectId: string, MergeRequestId: string, request: AcceptMergeRequestRequest): AcceptMergeRequestResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return acceptMergeRequestWithOptions(ProjectId, MergeRequestId, request, headers, runtime);
}

async function acceptMergeRequestWithOptions(ProjectId: string, MergeRequestId: string, request: AcceptMergeRequestRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AcceptMergeRequestResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('AcceptMergeRequest', '2020-04-14', 'HTTPS', 'PUT', 'AK', `/api/v3/projects/${ProjectId}/merge_request/${MergeRequestId}/accept`, 'json', req, runtime);
}

model DeleteFileRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  branchName?: string(name='BranchName'),
  filePath?: string(name='FilePath'),
  commitMessage?: string(name='CommitMessage'),
  subUserId?: string(name='SubUserId'),
}

model DeleteFileResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  result?: {
    filePath?: string(name='FilePath'),
    branchName?: string(name='BranchName'),
  }(name='Result'),
}

model DeleteFileResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFileResponseBody(name='body'),
}

async function deleteFile(ProjectId: string, request: DeleteFileRequest): DeleteFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteFileWithOptions(ProjectId, request, headers, runtime);
}

async function deleteFileWithOptions(ProjectId: string, request: DeleteFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteFileResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.branchName)) {
    query.BranchName = request.branchName;
  }
  if (!Util.isUnset(request.filePath)) {
    query.FilePath = request.filePath;
  }
  if (!Util.isUnset(request.commitMessage)) {
    query.CommitMessage = request.commitMessage;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeleteFile', '2020-04-14', 'HTTPS', 'DELETE', 'AK', `/api/v3/projects/${ProjectId}/repository/files`, 'json', req, runtime);
}

model DeleteRepositoryProtectedBranchRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
}

model DeleteRepositoryProtectedBranchResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  result?: {
    result?: boolean(name='Result'),
  }(name='Result'),
}

model DeleteRepositoryProtectedBranchResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteRepositoryProtectedBranchResponseBody(name='body'),
}

async function deleteRepositoryProtectedBranch(ProjectId: string, ProtectedBranchId: string, request: DeleteRepositoryProtectedBranchRequest): DeleteRepositoryProtectedBranchResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteRepositoryProtectedBranchWithOptions(ProjectId, ProtectedBranchId, request, headers, runtime);
}

async function deleteRepositoryProtectedBranchWithOptions(ProjectId: string, ProtectedBranchId: string, request: DeleteRepositoryProtectedBranchRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteRepositoryProtectedBranchResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeleteRepositoryProtectedBranch', '2020-04-14', 'HTTPS', 'DELETE', 'AK', `/api/v4/projects/${ProjectId}/repository/protect_branches/${ProtectedBranchId}`, 'json', req, runtime);
}

model DeleteRepositoryTagV2Request {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  tagName?: string(name='TagName'),
}

model DeleteRepositoryTagV2ResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  result?: {
    tagName?: string(name='TagName'),
  }(name='Result'),
}

model DeleteRepositoryTagV2Response = {
  headers: map[string]string(name='headers'),
  body: DeleteRepositoryTagV2ResponseBody(name='body'),
}

async function deleteRepositoryTagV2(ProjectId: string, request: DeleteRepositoryTagV2Request): DeleteRepositoryTagV2Response {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteRepositoryTagV2WithOptions(ProjectId, request, headers, runtime);
}

async function deleteRepositoryTagV2WithOptions(ProjectId: string, request: DeleteRepositoryTagV2Request, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteRepositoryTagV2Response {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.tagName)) {
    query.TagName = request.tagName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeleteRepositoryTagV2', '2020-04-14', 'HTTPS', 'DELETE', 'AK', `/api/v3/projects/${ProjectId}/repository/tag/delete`, 'json', req, runtime);
}

model GetFileLastCommitRequest {
  accessToken?: string(name='AccessToken', description='个人访问令牌'),
  organizationId?: string(name='OrganizationId', description='云效企业ID'),
  sha?: string(name='Sha', description='分支名称、标签名称或Commit ID'),
  filePath?: string(name='FilePath', description='文件路径'),
}

model GetFileLastCommitResponseBody = {
  errorMessage?: string(name='ErrorMessage', description='错误信息'),
  requestId?: string(name='RequestId', description='请求ID'),
  success?: boolean(name='Success', description='请求结果'),
  errorCode?: string(name='ErrorCode', description='错误码'),
  result?: {
    shortId?: string(name='ShortId', description='Commit短ID'),
    authorName?: string(name='AuthorName', description='作者姓名'),
    authorDate?: string(name='AuthorDate', description='作者提交时间'),
    createdAt?: string(name='CreatedAt', description='创建时间'),
    message?: string(name='Message', description='提交内容'),
    title?: string(name='Title', description='标题，提交的第一行内容'),
    committerName?: string(name='CommitterName', description='提交者姓名'),
    authorEmail?: string(name='AuthorEmail', description='提交者邮箱'),
    id?: string(name='Id', description='Commit ID'),
    committerEmail?: string(name='CommitterEmail', description='提交者邮箱'),
    committedDate?: string(name='CommittedDate', description='提交者提交时间'),
    parentIds?: [ string ](name='ParentIds', description='父提交ID'),
    signature?: {
      verificationStatus?: string(name='VerificationStatus', description='验证状态'),
      gpgKeyId?: string(name='GpgKeyId', description='GPG密钥ID'),
    }(name='Signature', description='签名'),
  }(name='Result', description='响应结果'),
}

model GetFileLastCommitResponse = {
  headers: map[string]string(name='headers'),
  body: GetFileLastCommitResponseBody(name='body'),
}

async function getFileLastCommit(ProjectId: string, request: GetFileLastCommitRequest): GetFileLastCommitResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getFileLastCommitWithOptions(ProjectId, request, headers, runtime);
}

async function getFileLastCommitWithOptions(ProjectId: string, request: GetFileLastCommitRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetFileLastCommitResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.sha)) {
    query.Sha = request.sha;
  }
  if (!Util.isUnset(request.filePath)) {
    query.FilePath = request.filePath;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetFileLastCommit', '2020-04-14', 'HTTPS', 'GET', 'AK', `/api/v3/projects/${ProjectId}/repository/files/last_commit`, 'json', req, runtime);
}

model UpdateFileRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model UpdateFileResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  result?: {
    filePath?: string(name='FilePath'),
    branchName?: string(name='BranchName'),
  }(name='Result'),
}

model UpdateFileResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateFileResponseBody(name='body'),
}

async function updateFile(ProjectId: string, request: UpdateFileRequest): UpdateFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateFileWithOptions(ProjectId, request, headers, runtime);
}

async function updateFileWithOptions(ProjectId: string, request: UpdateFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateFileResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateFile', '2020-04-14', 'HTTPS', 'PUT', 'AK', `/api/v4/projects/${ProjectId}/repository/files`, 'json', req, runtime);
}

model UpdateRepositoryMemberRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model UpdateRepositoryMemberResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  result?: {
    externUserId?: string(name='ExternUserId'),
    email?: string(name='Email'),
    avatarUrl?: string(name='AvatarUrl'),
    state?: string(name='State'),
    accessLevel?: int32(name='AccessLevel'),
    id?: long(name='Id'),
  }(name='Result'),
}

model UpdateRepositoryMemberResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateRepositoryMemberResponseBody(name='body'),
}

async function updateRepositoryMember(ProjectId: string, UserId: string, request: UpdateRepositoryMemberRequest): UpdateRepositoryMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateRepositoryMemberWithOptions(ProjectId, UserId, request, headers, runtime);
}

async function updateRepositoryMemberWithOptions(ProjectId: string, UserId: string, request: UpdateRepositoryMemberRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateRepositoryMemberResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateRepositoryMember', '2020-04-14', 'HTTPS', 'PUT', 'AK', `/api/v3/projects/${ProjectId}/members/${UserId}`, 'json', req, runtime);
}

model AddRepositoryMemberRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model AddRepositoryMemberResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  result?: [ 
    {
      externUserId?: string(name='ExternUserId'),
      email?: string(name='Email'),
      avatarUrl?: string(name='AvatarUrl'),
      state?: string(name='State'),
      accessLevel?: int32(name='AccessLevel'),
      id?: long(name='Id'),
    }
  ](name='Result'),
}

model AddRepositoryMemberResponse = {
  headers: map[string]string(name='headers'),
  body: AddRepositoryMemberResponseBody(name='body'),
}

async function addRepositoryMember(ProjectId: string, request: AddRepositoryMemberRequest): AddRepositoryMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addRepositoryMemberWithOptions(ProjectId, request, headers, runtime);
}

async function addRepositoryMemberWithOptions(ProjectId: string, request: AddRepositoryMemberRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddRepositoryMemberResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('AddRepositoryMember', '2020-04-14', 'HTTPS', 'POST', 'AK', `/api/v4/projects/${ProjectId}/members`, 'json', req, runtime);
}

model CreateSshKeyRequest {
  accessToken?: string(name='AccessToken'),
}

model CreateSshKeyResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  result?: {
    key?: string(name='Key'),
    fingerPrint?: string(name='FingerPrint'),
    createdAt?: string(name='CreatedAt'),
    title?: string(name='Title'),
    keyScope?: string(name='KeyScope'),
    id?: long(name='Id'),
  }(name='Result'),
}

model CreateSshKeyResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSshKeyResponseBody(name='body'),
}

async function createSshKey(request: CreateSshKeyRequest): CreateSshKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createSshKeyWithOptions(request, headers, runtime);
}

async function createSshKeyWithOptions(request: CreateSshKeyRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateSshKeyResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('CreateSshKey', '2020-04-14', 'HTTPS', 'POST', 'AK', `/api/v3/user/keys`, 'json', req, runtime);
}

model ListRepositoryTagsRequest {
  accessToken?: string(name='AccessToken'),
  search?: string(name='Search'),
  organizationId?: string(name='OrganizationId'),
  page?: long(name='Page'),
  pageSize?: long(name='PageSize'),
  sort?: string(name='Sort'),
  showSignature?: boolean(name='ShowSignature'),
}

model ListRepositoryTagsResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  total?: long(name='Total'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  result?: [ 
    {
      message?: string(name='Message'),
      name?: string(name='Name'),
      id?: string(name='Id'),
      commit?: {
        shortId?: string(name='ShortId'),
        authorName?: string(name='AuthorName'),
        createdAt?: string(name='CreatedAt'),
        message?: string(name='Message'),
        authoredDate?: string(name='AuthoredDate'),
        committerName?: string(name='CommitterName'),
        title?: string(name='Title'),
        authorEmail?: string(name='AuthorEmail'),
        committerEmail?: string(name='CommitterEmail'),
        id?: string(name='Id'),
        committedDate?: string(name='CommittedDate'),
        parentIds?: [ string ](name='ParentIds'),
        signature?: {
          verificationStatus?: string(name='VerificationStatus'),
          gpgKeyId?: string(name='GpgKeyId'),
        }(name='Signature'),
      }(name='Commit'),
      signature?: {
        verificationStatus?: string(name='VerificationStatus'),
        gpgKeyId?: string(name='GpgKeyId'),
      }(name='Signature'),
    }
  ](name='Result'),
}

model ListRepositoryTagsResponse = {
  headers: map[string]string(name='headers'),
  body: ListRepositoryTagsResponseBody(name='body'),
}

async function listRepositoryTags(ProjectId: string, request: ListRepositoryTagsRequest): ListRepositoryTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRepositoryTagsWithOptions(ProjectId, request, headers, runtime);
}

async function listRepositoryTagsWithOptions(ProjectId: string, request: ListRepositoryTagsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRepositoryTagsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.search)) {
    query.Search = request.search;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.page)) {
    query.Page = request.page;
  }
  if (!Util.isUnset(request.pageSize)) {
    query.PageSize = request.pageSize;
  }
  if (!Util.isUnset(request.sort)) {
    query.Sort = request.sort;
  }
  if (!Util.isUnset(request.showSignature)) {
    query.ShowSignature = request.showSignature;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListRepositoryTags', '2020-04-14', 'HTTPS', 'GET', 'AK', `/api/v4/projects/${ProjectId}/repository/tags`, 'json', req, runtime);
}

model AddWebhookRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
}

model AddWebhookResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  result?: {
    pushEvents?: boolean(name='PushEvents'),
    buildEvents?: boolean(name='BuildEvents'),
    projectId?: long(name='ProjectId'),
    createdAt?: string(name='CreatedAt'),
    url?: string(name='Url'),
    issuesEvents?: boolean(name='IssuesEvents'),
    tagPushEvents?: boolean(name='TagPushEvents'),
    lastTestResult?: string(name='LastTestResult'),
    description?: string(name='Description'),
    mergeRequestsEvents?: boolean(name='MergeRequestsEvents'),
    secretToken?: string(name='SecretToken'),
    noteEvents?: boolean(name='NoteEvents'),
    id?: long(name='Id'),
    enableSslVerification?: boolean(name='EnableSslVerification'),
  }(name='Result'),
}

model AddWebhookResponse = {
  headers: map[string]string(name='headers'),
  body: AddWebhookResponseBody(name='body'),
}

async function addWebhook(ProjectId: string, request: AddWebhookRequest): AddWebhookResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addWebhookWithOptions(ProjectId, request, headers, runtime);
}

async function addWebhookWithOptions(ProjectId: string, request: AddWebhookRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddWebhookResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('AddWebhook', '2020-04-14', 'HTTPS', 'POST', 'AK', `/api/v3/projects/${ProjectId}/hooks`, 'json', req, runtime);
}

model EnableRepositoryDeployKeyRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model EnableRepositoryDeployKeyResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  result?: {
    result?: boolean(name='Result'),
  }(name='Result'),
}

model EnableRepositoryDeployKeyResponse = {
  headers: map[string]string(name='headers'),
  body: EnableRepositoryDeployKeyResponseBody(name='body'),
}

async function enableRepositoryDeployKey(ProjectId: string, KeyId: string, request: EnableRepositoryDeployKeyRequest): EnableRepositoryDeployKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return enableRepositoryDeployKeyWithOptions(ProjectId, KeyId, request, headers, runtime);
}

async function enableRepositoryDeployKeyWithOptions(ProjectId: string, KeyId: string, request: EnableRepositoryDeployKeyRequest, headers: map[string]string, runtime: Util.RuntimeOptions): EnableRepositoryDeployKeyResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('EnableRepositoryDeployKey', '2020-04-14', 'HTTPS', 'POST', 'AK', `/api/v3/projects/${ProjectId}/keys/${KeyId}/enable`, 'json', req, runtime);
}

model GetUserInfoRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
}

model GetUserInfoResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  result?: {
    email?: string(name='Email'),
    avatarUrl?: string(name='AvatarUrl'),
    externalUserId?: string(name='ExternalUserId'),
    name?: string(name='Name'),
    id?: long(name='Id'),
    username?: string(name='Username'),
  }(name='Result'),
}

model GetUserInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetUserInfoResponseBody(name='body'),
}

async function getUserInfo(request: GetUserInfoRequest): GetUserInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getUserInfoWithOptions(request, headers, runtime);
}

async function getUserInfoWithOptions(request: GetUserInfoRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetUserInfoResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetUserInfo', '2020-04-14', 'HTTPS', 'GET', 'AK', `/api/v3/user/current`, 'json', req, runtime);
}

model ListRepositoryTreeRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  path?: string(name='Path'),
  type?: string(name='Type'),
  refName?: string(name='RefName'),
  subUserId?: string(name='SubUserId'),
}

model ListRepositoryTreeResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  result?: [ 
    {
      type?: string(name='Type'),
      path?: string(name='Path'),
      mode?: string(name='Mode'),
      name?: string(name='Name'),
      id?: string(name='Id'),
    }
  ](name='Result'),
}

model ListRepositoryTreeResponse = {
  headers: map[string]string(name='headers'),
  body: ListRepositoryTreeResponseBody(name='body'),
}

async function listRepositoryTree(ProjectId: string, request: ListRepositoryTreeRequest): ListRepositoryTreeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRepositoryTreeWithOptions(ProjectId, request, headers, runtime);
}

async function listRepositoryTreeWithOptions(ProjectId: string, request: ListRepositoryTreeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRepositoryTreeResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.path)) {
    query.Path = request.path;
  }
  if (!Util.isUnset(request.type)) {
    query.Type = request.type;
  }
  if (!Util.isUnset(request.refName)) {
    query.RefName = request.refName;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListRepositoryTree', '2020-04-14', 'HTTPS', 'GET', 'AK', `/api/v4/projects/${ProjectId}/repository/tree`, 'json', req, runtime);
}

model DeleteRepositoryGroupRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model DeleteRepositoryGroupResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  result?: {
    result?: boolean(name='Result'),
  }(name='Result'),
}

model DeleteRepositoryGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteRepositoryGroupResponseBody(name='body'),
}

async function deleteRepositoryGroup(GroupId: string, request: DeleteRepositoryGroupRequest): DeleteRepositoryGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteRepositoryGroupWithOptions(GroupId, request, headers, runtime);
}

async function deleteRepositoryGroupWithOptions(GroupId: string, request: DeleteRepositoryGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteRepositoryGroupResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeleteRepositoryGroup', '2020-04-14', 'HTTPS', 'POST', 'AK', `/api/v3/groups/${GroupId}/remove`, 'json', req, runtime);
}

model DeleteRepositoryWebhookRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
}

model DeleteRepositoryWebhookResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  result?: {
    pushEvents?: boolean(name='PushEvents'),
    projectId?: long(name='ProjectId'),
    createdAt?: string(name='CreatedAt'),
    url?: string(name='Url'),
    tagPushEvents?: boolean(name='TagPushEvents'),
    lastTestResult?: string(name='LastTestResult'),
    mergeRequestsEvents?: boolean(name='MergeRequestsEvents'),
    description?: string(name='Description'),
    noteEvents?: boolean(name='NoteEvents'),
    secretToken?: string(name='SecretToken'),
    id?: long(name='Id'),
    enableSslVerification?: boolean(name='EnableSslVerification'),
  }(name='Result'),
}

model DeleteRepositoryWebhookResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteRepositoryWebhookResponseBody(name='body'),
}

async function deleteRepositoryWebhook(ProjectId: string, WebhookId: string, request: DeleteRepositoryWebhookRequest): DeleteRepositoryWebhookResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteRepositoryWebhookWithOptions(ProjectId, WebhookId, request, headers, runtime);
}

async function deleteRepositoryWebhookWithOptions(ProjectId: string, WebhookId: string, request: DeleteRepositoryWebhookRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteRepositoryWebhookResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeleteRepositoryWebhook', '2020-04-14', 'HTTPS', 'DELETE', 'AK', `/api/v3/projects/${ProjectId}/hooks/${WebhookId}`, 'json', req, runtime);
}

model ListRepositoryMemberRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  query?: string(name='Query'),
  page?: long(name='Page'),
  pageSize?: long(name='PageSize'),
  subUserId?: string(name='SubUserId'),
}

model ListRepositoryMemberResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  total?: long(name='Total'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  result?: [ 
    {
      externUserId?: string(name='ExternUserId'),
      email?: string(name='Email'),
      avatarUrl?: string(name='AvatarUrl'),
      state?: string(name='State'),
      accessLevel?: int32(name='AccessLevel'),
      name?: string(name='Name'),
      id?: long(name='Id'),
      username?: string(name='Username'),
    }
  ](name='Result'),
}

model ListRepositoryMemberResponse = {
  headers: map[string]string(name='headers'),
  body: ListRepositoryMemberResponseBody(name='body'),
}

async function listRepositoryMember(ProjectId: string, request: ListRepositoryMemberRequest): ListRepositoryMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRepositoryMemberWithOptions(ProjectId, request, headers, runtime);
}

async function listRepositoryMemberWithOptions(ProjectId: string, request: ListRepositoryMemberRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRepositoryMemberResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.query)) {
    query.Query = request.query;
  }
  if (!Util.isUnset(request.page)) {
    query.Page = request.page;
  }
  if (!Util.isUnset(request.pageSize)) {
    query.PageSize = request.pageSize;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListRepositoryMember', '2020-04-14', 'HTTPS', 'GET', 'AK', `/api/v3/projects/${ProjectId}/members`, 'json', req, runtime);
}

model CreateTagRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model CreateTagResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  result?: {
    name?: string(name='Name'),
    message?: string(name='Message'),
    commitInfo?: {
      shortId?: string(name='ShortId'),
      authorName?: string(name='AuthorName'),
      createdAt?: string(name='CreatedAt'),
      message?: string(name='Message'),
      authoredDate?: string(name='AuthoredDate'),
      committerName?: string(name='CommitterName'),
      title?: string(name='Title'),
      authorEmail?: string(name='AuthorEmail'),
      committerEmail?: string(name='CommitterEmail'),
      id?: string(name='Id'),
      committedDate?: string(name='CommittedDate'),
      parentIds?: [ string ](name='ParentIds'),
    }(name='CommitInfo'),
    release?: {
      description?: string(name='Description'),
      tagName?: string(name='TagName'),
    }(name='Release'),
  }(name='Result'),
}

model CreateTagResponse = {
  headers: map[string]string(name='headers'),
  body: CreateTagResponseBody(name='body'),
}

async function createTag(ProjectId: string, request: CreateTagRequest): CreateTagResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createTagWithOptions(ProjectId, request, headers, runtime);
}

async function createTagWithOptions(ProjectId: string, request: CreateTagRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateTagResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('CreateTag', '2020-04-14', 'HTTPS', 'POST', 'AK', `/api/v3/projects/${ProjectId}/repository/tags`, 'json', req, runtime);
}

model GetRepositoryCommitRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
}

model GetRepositoryCommitResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  result?: {
    shortId?: string(name='ShortId'),
    authorName?: string(name='AuthorName'),
    authorDate?: string(name='AuthorDate'),
    createdAt?: string(name='CreatedAt'),
    message?: string(name='Message'),
    title?: string(name='Title'),
    committerName?: string(name='CommitterName'),
    authorEmail?: string(name='AuthorEmail'),
    id?: string(name='Id'),
    committerEmail?: string(name='CommitterEmail'),
    committedDate?: string(name='CommittedDate'),
    parentIds?: [ string ](name='ParentIds'),
    signature?: {
      verificationStatus?: string(name='VerificationStatus'),
      gpgKeyId?: string(name='GpgKeyId'),
    }(name='Signature'),
  }(name='Result'),
}

model GetRepositoryCommitResponse = {
  headers: map[string]string(name='headers'),
  body: GetRepositoryCommitResponseBody(name='body'),
}

async function getRepositoryCommit(ProjectId: string, Sha: string, request: GetRepositoryCommitRequest): GetRepositoryCommitResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getRepositoryCommitWithOptions(ProjectId, Sha, request, headers, runtime);
}

async function getRepositoryCommitWithOptions(ProjectId: string, Sha: string, request: GetRepositoryCommitRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetRepositoryCommitResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetRepositoryCommit', '2020-04-14', 'HTTPS', 'GET', 'AK', `/api/v4/projects/${ProjectId}/repository/commits/${Sha}`, 'json', req, runtime);
}

model AddGroupMemberRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model AddGroupMemberResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  result?: [ 
    {
      externUserId?: string(name='ExternUserId'),
      email?: string(name='Email'),
      avatarUrl?: string(name='AvatarUrl'),
      state?: string(name='State'),
      accessLevel?: int32(name='AccessLevel'),
      id?: long(name='Id'),
    }
  ](name='Result'),
}

model AddGroupMemberResponse = {
  headers: map[string]string(name='headers'),
  body: AddGroupMemberResponseBody(name='body'),
}

async function addGroupMember(GroupId: string, request: AddGroupMemberRequest): AddGroupMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addGroupMemberWithOptions(GroupId, request, headers, runtime);
}

async function addGroupMemberWithOptions(GroupId: string, request: AddGroupMemberRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddGroupMemberResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('AddGroupMember', '2020-04-14', 'HTTPS', 'POST', 'AK', `/api/v4/groups/${GroupId}/members`, 'json', req, runtime);
}

model GetBranchInfoRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
  branchName?: string(name='BranchName'),
}

model GetBranchInfoResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  result?: {
    protectedBranch?: boolean(name='ProtectedBranch'),
    branchName?: string(name='BranchName'),
    commitInfo?: {
      shortId?: string(name='ShortId'),
      authorName?: string(name='AuthorName'),
      authorDate?: string(name='AuthorDate'),
      createdAt?: string(name='CreatedAt'),
      message?: string(name='Message'),
      committerName?: string(name='CommitterName'),
      title?: string(name='Title'),
      authorEmail?: string(name='AuthorEmail'),
      committerEmail?: string(name='CommitterEmail'),
      id?: string(name='Id'),
      committedDate?: string(name='CommittedDate'),
      parentIds?: [ string ](name='ParentIds'),
    }(name='CommitInfo'),
  }(name='Result'),
}

model GetBranchInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetBranchInfoResponseBody(name='body'),
}

async function getBranchInfo(ProjectId: string, request: GetBranchInfoRequest): GetBranchInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getBranchInfoWithOptions(ProjectId, request, headers, runtime);
}

async function getBranchInfoWithOptions(ProjectId: string, request: GetBranchInfoRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetBranchInfoResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }
  if (!Util.isUnset(request.branchName)) {
    query.BranchName = request.branchName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetBranchInfo', '2020-04-14', 'HTTPS', 'GET', 'AK', `/api/v3/projects/${ProjectId}/repository/branches/detail`, 'json', req, runtime);
}

model ListMergeRequestCommentsRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  fromCommit?: string(name='FromCommit'),
  toCommit?: string(name='ToCommit'),
}

model ListMergeRequestCommentsResponseBody = {
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  total?: long(name='Total'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  result?: [ 
    {
      outDated?: boolean(name='OutDated'),
      projectId?: long(name='ProjectId'),
      rangeContext?: string(name='RangeContext'),
      createdAt?: string(name='CreatedAt'),
      parentNoteId?: long(name='ParentNoteId'),
      isDraft?: boolean(name='IsDraft'),
      closed?: int32(name='Closed'),
      line?: long(name='Line'),
      side?: string(name='Side'),
      path?: string(name='Path'),
      note?: string(name='Note'),
      updatedAt?: string(name='UpdatedAt'),
      id?: long(name='Id'),
      author?: {
        externUserId?: string(name='ExternUserId'),
        email?: string(name='Email'),
        name?: string(name='Name'),
        avatarUrl?: string(name='AvatarUrl'),
        id?: long(name='Id'),
      }(name='Author'),
    }
  ](name='Result'),
}

model ListMergeRequestCommentsResponse = {
  headers: map[string]string(name='headers'),
  body: ListMergeRequestCommentsResponseBody(name='body'),
}

async function listMergeRequestComments(ProjectId: string, MergeRequestId: string, request: ListMergeRequestCommentsRequest): ListMergeRequestCommentsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listMergeRequestCommentsWithOptions(ProjectId, MergeRequestId, request, headers, runtime);
}

async function listMergeRequestCommentsWithOptions(ProjectId: string, MergeRequestId: string, request: ListMergeRequestCommentsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListMergeRequestCommentsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.fromCommit)) {
    query.FromCommit = request.fromCommit;
  }
  if (!Util.isUnset(request.toCommit)) {
    query.ToCommit = request.toCommit;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListMergeRequestComments', '2020-04-14', 'HTTPS', 'GET', 'AK', `/api/v4/projects/${ProjectId}/merge_request/${MergeRequestId}/comments`, 'json', req, runtime);
}

model CreateRepositoryGroupRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model CreateRepositoryGroupResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: int32(name='ErrorCode'),
  result?: {
    type?: string(name='Type'),
    avatarUrl?: string(name='AvatarUrl'),
    ownerId?: long(name='OwnerId'),
    webUrl?: string(name='WebUrl'),
    parentId?: long(name='ParentId'),
    description?: string(name='Description'),
    nameWithNamespace?: string(name='NameWithNamespace'),
    pathWithNamespace?: string(name='PathWithNamespace'),
    visibilityLevel?: string(name='VisibilityLevel'),
    path?: string(name='Path'),
    name?: string(name='Name'),
    id?: long(name='Id'),
  }(name='Result'),
}

model CreateRepositoryGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateRepositoryGroupResponseBody(name='body'),
}

async function createRepositoryGroup(request: CreateRepositoryGroupRequest): CreateRepositoryGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createRepositoryGroupWithOptions(request, headers, runtime);
}

async function createRepositoryGroupWithOptions(request: CreateRepositoryGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateRepositoryGroupResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('CreateRepositoryGroup', '2020-04-14', 'HTTPS', 'POST', 'AK', `/api/v3/groups`, 'json', req, runtime);
}

model GetMergeRequestDetailRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
}

model GetMergeRequestDetailResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  result?: {
    isSupportMerge?: boolean(name='IsSupportMerge'),
    state?: string(name='State'),
    behindCommitCount?: int32(name='BehindCommitCount'),
    projectId?: long(name='ProjectId'),
    createdAt?: string(name='CreatedAt'),
    acceptedRevision?: string(name='AcceptedRevision'),
    sourceBranch?: string(name='SourceBranch'),
    webUrl?: string(name='WebUrl'),
    description?: string(name='Description'),
    nameWithNamespace?: string(name='NameWithNamespace'),
    mergeType?: string(name='MergeType'),
    targetBranch?: string(name='TargetBranch'),
    aheadCommitCount?: int32(name='AheadCommitCount'),
    updatedAt?: string(name='UpdatedAt'),
    title?: string(name='Title'),
    mergeError?: string(name='MergeError'),
    mergedRevision?: string(name='MergedRevision'),
    id?: long(name='Id'),
    mergeStatus?: string(name='MergeStatus'),
    assigneeList?: [ 
      {
        status?: string(name='Status'),
        externUserId?: string(name='ExternUserId'),
        email?: string(name='Email'),
        avatarUrl?: string(name='AvatarUrl'),
        name?: string(name='Name'),
        id?: string(name='Id'),
      }
    ](name='AssigneeList'),
    approveCheckResult?: {
      totalCheckResult?: string(name='TotalCheckResult'),
      satisfiedCheckResults?: [ 
        {
          checkStatus?: string(name='CheckStatus'),
          checkType?: string(name='CheckType'),
          checkName?: string(name='CheckName'),
          extraUsers?: [ 
            {
              externUserId?: string(name='ExternUserId'),
              name?: string(name='Name'),
              avatarUrl?: string(name='AvatarUrl'),
              id?: long(name='Id'),
            }
          ](name='ExtraUsers'),
          unsatisfiedItems?: [ string ](name='UnsatisfiedItems'),
          satisfiedItems?: [ string ](name='SatisfiedItems'),
        }
      ](name='SatisfiedCheckResults'),
      unsatisfiedCheckResults?: [ 
        {
          checkStatus?: string(name='CheckStatus'),
          checkType?: string(name='CheckType'),
          checkName?: string(name='CheckName'),
          extraUsers?: [ 
            {
              externUserId?: string(name='ExternUserId'),
              name?: string(name='Name'),
              avatarUrl?: string(name='AvatarUrl'),
              id?: long(name='Id'),
            }
          ](name='ExtraUsers'),
          unsatisfiedItems?: [ string ](name='UnsatisfiedItems'),
          satisfiedItems?: [ string ](name='SatisfiedItems'),
        }
      ](name='UnsatisfiedCheckResults'),
    }(name='ApproveCheckResult'),
    author?: {
      externUserId?: string(name='ExternUserId'),
      name?: string(name='Name'),
      avatarUrl?: string(name='AvatarUrl'),
      id?: long(name='Id'),
    }(name='Author'),
  }(name='Result'),
}

model GetMergeRequestDetailResponse = {
  headers: map[string]string(name='headers'),
  body: GetMergeRequestDetailResponseBody(name='body'),
}

async function getMergeRequestDetail(ProjectId: string, MergeRequestId: string, request: GetMergeRequestDetailRequest): GetMergeRequestDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getMergeRequestDetailWithOptions(ProjectId, MergeRequestId, request, headers, runtime);
}

async function getMergeRequestDetailWithOptions(ProjectId: string, MergeRequestId: string, request: GetMergeRequestDetailRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetMergeRequestDetailResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetMergeRequestDetail', '2020-04-14', 'HTTPS', 'GET', 'AK', `/api/v4/projects/${ProjectId}/merge_request/${MergeRequestId}`, 'json', req, runtime);
}

model ListGroupsRequest {
  accessToken?: string(name='AccessToken'),
  search?: string(name='Search'),
  organizationId?: string(name='OrganizationId'),
  page?: long(name='Page'),
  pageSize?: long(name='PageSize'),
  subUserId?: string(name='SubUserId'),
  includePersonal?: boolean(name='IncludePersonal'),
}

model ListGroupsResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  total?: long(name='Total'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  result?: [ 
    {
      type?: string(name='Type'),
      createdAt?: string(name='CreatedAt'),
      ownerId?: long(name='OwnerId'),
      webUrl?: string(name='WebUrl'),
      parentId?: long(name='ParentId'),
      description?: string(name='Description'),
      nameWithNamespace?: string(name='NameWithNamespace'),
      pathWithNamespace?: string(name='PathWithNamespace'),
      visibilityLevel?: string(name='VisibilityLevel'),
      path?: string(name='Path'),
      accessLevel?: int32(name='AccessLevel'),
      updatedAt?: string(name='UpdatedAt'),
      name?: string(name='Name'),
      id?: long(name='Id'),
    }
  ](name='Result'),
}

model ListGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: ListGroupsResponseBody(name='body'),
}

async function listGroups(request: ListGroupsRequest): ListGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listGroupsWithOptions(request, headers, runtime);
}

async function listGroupsWithOptions(request: ListGroupsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListGroupsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.search)) {
    query.Search = request.search;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.page)) {
    query.Page = request.page;
  }
  if (!Util.isUnset(request.pageSize)) {
    query.PageSize = request.pageSize;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }
  if (!Util.isUnset(request.includePersonal)) {
    query.IncludePersonal = request.includePersonal;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListGroups', '2020-04-14', 'HTTPS', 'GET', 'AK', `/api/v3/groups/all`, 'json', req, runtime);
}

model ListRepositoryProtectedBranchRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
}

model ListRepositoryProtectedBranchResponseBody = {
  errorMessage?: string(name='ErrorMessage', description='错误信息'),
  requestId?: string(name='RequestId', description='请求ID'),
  success?: boolean(name='Success', description='请求结果'),
  errorCode?: string(name='ErrorCode', description='错误码'),
  result?: [ 
    {
      branch?: string(name='Branch', description='保护分支名称'),
      id?: long(name='Id', description='保护分支 ID'),
      allowPushRoles?: [ int32 ](name='AllowPushRoles', description='允许推送代码的角色。  40：管理员  30：开发者'),
      allowMergeRoles?: [ int32 ](name='AllowMergeRoles', description='允许合并的角色。  40：管理员  30：开发者'),
      mergeRequestSetting?: {
        mergeRequestMode?: string(name='MergeRequestMode', description='评审模式。  general：普通 codeowner：CodeOwner模式'),
        allowSelfApproval?: boolean(name='AllowSelfApproval', description='是否允许创建者通过代码评审。'),
        isRequireDiscussionProcessed?: boolean(name='IsRequireDiscussionProcessed', description='是否要求评论全部已解决。'),
        required?: boolean(name='Required', description='是否要求合并前通过代码评审。'),
        minimumApproval?: int32(name='MinimumApproval', description='评审通过的最少人数。  注：仅普通模式生效。'),
        defaultAssignees?: [ 
          {
            name?: string(name='Name', description='姓名'),
            externUid?: string(name='ExternUid', description='云效用户ID'),
            avatarUrl?: string(name='AvatarUrl', description='头像地址'),
            id?: long(name='Id', description='用户ID'),
            email?: string(name='Email', description='邮箱'),
          }
        ](name='DefaultAssignees', description='默认评审者。  注：云效用户 ID 列表。'),
        allowMergeRequestRoles?: [ int32 ](name='AllowMergeRequestRoles', description='允许通过代码评审的角色。  40：管理员  30：开发者'),
        whiteList?: string(name='WhiteList', description='评审文件白名单'),
      }(name='MergeRequestSetting', description='代码评审设置'),
      testSetting?: {
        required?: boolean(name='Required', description='要求合并前通过自动化执行检查。'),
        codingGuidelinesDetection?: {
          message?: string(name='Message', description='检查信息'),
          enabled?: boolean(name='Enabled', description='合并前是否需要通过Java 代码规约扫描。'),
        }(name='CodingGuidelinesDetection', description='Java 代码规约扫描'),
        sensitiveInfoDetection?: {
          message?: string(name='Message', description='检查信息'),
          enabled?: boolean(name='Enabled', description='合并前是否需要通过敏感信息检查'),
        }(name='SensitiveInfoDetection', description='敏感信息检查'),
        checkConfig?: {
          checkItems?: [ 
            {
              name?: string(name='Name', description='流水线名称'),
              required?: boolean(name='Required', description='是否开启检测'),
            }
          ](name='CheckItems', description='流水线检测列表'),
        }(name='CheckConfig', description='卡点检测'),
      }(name='TestSetting', description='自动化检查设置'),
    }
  ](name='Result', description='响应结果'),
}

model ListRepositoryProtectedBranchResponse = {
  headers: map[string]string(name='headers'),
  body: ListRepositoryProtectedBranchResponseBody(name='body'),
}

async function listRepositoryProtectedBranch(ProjectId: string, request: ListRepositoryProtectedBranchRequest): ListRepositoryProtectedBranchResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRepositoryProtectedBranchWithOptions(ProjectId, request, headers, runtime);
}

async function listRepositoryProtectedBranchWithOptions(ProjectId: string, request: ListRepositoryProtectedBranchRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRepositoryProtectedBranchResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListRepositoryProtectedBranch', '2020-04-14', 'HTTPS', 'GET', 'AK', `/api/v4/projects/${ProjectId}/repository/protect_branches`, 'json', req, runtime);
}

model ListOrganizationsRequest {
  accessToken?: string(name='AccessToken'),
  accessLevel?: int32(name='AccessLevel'),
  minAccessLevel?: int32(name='MinAccessLevel'),
}

model ListOrganizationsResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  result?: [ 
    {
      organizationRole?: string(name='OrganizationRole'),
      accessLevel?: int32(name='AccessLevel'),
      organizationName?: string(name='OrganizationName'),
      organizationId?: string(name='OrganizationId'),
    }
  ](name='Result'),
}

model ListOrganizationsResponse = {
  headers: map[string]string(name='headers'),
  body: ListOrganizationsResponseBody(name='body'),
}

async function listOrganizations(request: ListOrganizationsRequest): ListOrganizationsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listOrganizationsWithOptions(request, headers, runtime);
}

async function listOrganizationsWithOptions(request: ListOrganizationsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListOrganizationsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.accessLevel)) {
    query.AccessLevel = request.accessLevel;
  }
  if (!Util.isUnset(request.minAccessLevel)) {
    query.MinAccessLevel = request.minAccessLevel;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListOrganizations', '2020-04-14', 'HTTPS', 'GET', 'AK', `/api/v4/organization`, 'json', req, runtime);
}

model GetProjectMemberRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model GetProjectMemberResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  result?: {
    accessLevel?: int32(name='AccessLevel'),
    externUserId?: string(name='ExternUserId'),
    name?: string(name='Name'),
    avatarUrl?: string(name='AvatarUrl'),
    id?: long(name='Id'),
  }(name='Result'),
}

model GetProjectMemberResponse = {
  headers: map[string]string(name='headers'),
  body: GetProjectMemberResponseBody(name='body'),
}

async function getProjectMember(ProjectId: string, UserId: string, request: GetProjectMemberRequest): GetProjectMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getProjectMemberWithOptions(ProjectId, UserId, request, headers, runtime);
}

async function getProjectMemberWithOptions(ProjectId: string, UserId: string, request: GetProjectMemberRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetProjectMemberResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetProjectMember', '2020-04-14', 'HTTPS', 'GET', 'AK', `/api/v3/projects/${ProjectId}/members/${UserId}`, 'json', req, runtime);
}

model CreateFileRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model CreateFileResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  result?: {
    filePath?: string(name='FilePath'),
    branchName?: string(name='BranchName'),
  }(name='Result'),
}

model CreateFileResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFileResponseBody(name='body'),
}

async function createFile(ProjectId: string, request: CreateFileRequest): CreateFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createFileWithOptions(ProjectId, request, headers, runtime);
}

async function createFileWithOptions(ProjectId: string, request: CreateFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateFileResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('CreateFile', '2020-04-14', 'HTTPS', 'POST', 'AK', `/api/v3/projects/${ProjectId}/repository/files`, 'json', req, runtime);
}

model ListRepositoryCommitsRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  page?: long(name='Page'),
  pageSize?: long(name='PageSize'),
  search?: string(name='Search'),
  path?: string(name='Path'),
  refName?: string(name='RefName'),
  showSignature?: boolean(name='ShowSignature'),
}

model ListRepositoryCommitsResponseBody = {
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  total?: long(name='Total'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  result?: [ 
    {
      shortId?: string(name='ShortId'),
      authorName?: string(name='AuthorName'),
      authorDate?: string(name='AuthorDate'),
      createdAt?: string(name='CreatedAt'),
      message?: string(name='Message'),
      title?: string(name='Title'),
      committerName?: string(name='CommitterName'),
      authorEmail?: string(name='AuthorEmail'),
      id?: string(name='Id'),
      committerEmail?: string(name='CommitterEmail'),
      committedDate?: string(name='CommittedDate'),
      parentIds?: [ string ](name='ParentIds'),
      signature?: {
        verificationStatus?: string(name='VerificationStatus'),
        gpgKeyId?: string(name='GpgKeyId'),
      }(name='Signature'),
    }
  ](name='Result'),
}

model ListRepositoryCommitsResponse = {
  headers: map[string]string(name='headers'),
  body: ListRepositoryCommitsResponseBody(name='body'),
}

async function listRepositoryCommits(ProjectId: string, request: ListRepositoryCommitsRequest): ListRepositoryCommitsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRepositoryCommitsWithOptions(ProjectId, request, headers, runtime);
}

async function listRepositoryCommitsWithOptions(ProjectId: string, request: ListRepositoryCommitsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRepositoryCommitsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.page)) {
    query.Page = request.page;
  }
  if (!Util.isUnset(request.pageSize)) {
    query.PageSize = request.pageSize;
  }
  if (!Util.isUnset(request.search)) {
    query.Search = request.search;
  }
  if (!Util.isUnset(request.path)) {
    query.Path = request.path;
  }
  if (!Util.isUnset(request.refName)) {
    query.RefName = request.refName;
  }
  if (!Util.isUnset(request.showSignature)) {
    query.ShowSignature = request.showSignature;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListRepositoryCommits', '2020-04-14', 'HTTPS', 'GET', 'AK', `/api/v4/projects/${ProjectId}/repository/commits`, 'json', req, runtime);
}

model GetMergeRequestApproveStatusRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
}

model GetMergeRequestApproveStatusResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  result?: {
    message?: string(name='Message'),
    approveStatus?: string(name='ApproveStatus'),
  }(name='Result'),
}

model GetMergeRequestApproveStatusResponse = {
  headers: map[string]string(name='headers'),
  body: GetMergeRequestApproveStatusResponseBody(name='body'),
}

async function getMergeRequestApproveStatus(ProjectId: string, MergeRequestId: string, request: GetMergeRequestApproveStatusRequest): GetMergeRequestApproveStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getMergeRequestApproveStatusWithOptions(ProjectId, MergeRequestId, request, headers, runtime);
}

async function getMergeRequestApproveStatusWithOptions(ProjectId: string, MergeRequestId: string, request: GetMergeRequestApproveStatusRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetMergeRequestApproveStatusResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetMergeRequestApproveStatus', '2020-04-14', 'HTTPS', 'GET', 'AK', `/api/v4/projects/${ProjectId}/merge_request/${MergeRequestId}/approve_status`, 'json', req, runtime);
}

model ListRepositoriesRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  page?: long(name='Page'),
  pageSize?: long(name='PageSize'),
  order?: string(name='Order'),
  sort?: string(name='Sort'),
  search?: string(name='Search'),
  archive?: boolean(name='Archive'),
}

model ListRepositoriesResponseBody = {
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  total?: long(name='Total'),
  success?: boolean(name='Success'),
  errorCode?: int32(name='ErrorCode'),
  result?: [ 
    {
      lastActivityAt?: string(name='LastActivityAt'),
      namespaceId?: long(name='NamespaceId'),
      avatarUrl?: string(name='AvatarUrl'),
      starCount?: long(name='StarCount'),
      archive?: boolean(name='Archive'),
      createdAt?: string(name='CreatedAt'),
      star?: boolean(name='Star'),
      demoProjectStatus?: boolean(name='DemoProjectStatus'),
      importStatus?: string(name='ImportStatus'),
      webUrl?: string(name='WebUrl'),
      description?: string(name='Description'),
      nameWithNamespace?: string(name='NameWithNamespace'),
      pathWithNamespace?: string(name='PathWithNamespace'),
      path?: string(name='Path'),
      visibilityLevel?: string(name='VisibilityLevel'),
      accessLevel?: int32(name='AccessLevel'),
      updatedAt?: string(name='UpdatedAt'),
      name?: string(name='Name'),
      id?: long(name='Id'),
    }
  ](name='Result'),
}

model ListRepositoriesResponse = {
  headers: map[string]string(name='headers'),
  body: ListRepositoriesResponseBody(name='body'),
}

async function listRepositories(request: ListRepositoriesRequest): ListRepositoriesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRepositoriesWithOptions(request, headers, runtime);
}

async function listRepositoriesWithOptions(request: ListRepositoriesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRepositoriesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.page)) {
    query.Page = request.page;
  }
  if (!Util.isUnset(request.pageSize)) {
    query.PageSize = request.pageSize;
  }
  if (!Util.isUnset(request.order)) {
    query.Order = request.order;
  }
  if (!Util.isUnset(request.sort)) {
    query.Sort = request.sort;
  }
  if (!Util.isUnset(request.search)) {
    query.Search = request.search;
  }
  if (!Util.isUnset(request.archive)) {
    query.Archive = request.archive;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListRepositories', '2020-04-14', 'HTTPS', 'GET', 'AK', `/api/v3/projects/all`, 'json', req, runtime);
}

model UpdateMergeRequestSettingRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
}

model UpdateMergeRequestSettingResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  result?: {
    result?: boolean(name='Result'),
  }(name='Result'),
}

model UpdateMergeRequestSettingResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateMergeRequestSettingResponseBody(name='body'),
}

async function updateMergeRequestSetting(ProjectId: string, request: UpdateMergeRequestSettingRequest): UpdateMergeRequestSettingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateMergeRequestSettingWithOptions(ProjectId, request, headers, runtime);
}

async function updateMergeRequestSettingWithOptions(ProjectId: string, request: UpdateMergeRequestSettingRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateMergeRequestSettingResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateMergeRequestSetting', '2020-04-14', 'HTTPS', 'PUT', 'AK', `/api/v4/projects/${ProjectId}/settings/merge_requests`, 'json', req, runtime);
}

model ListGroupMemberRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  page?: long(name='Page'),
  pageSize?: long(name='PageSize'),
  subUserId?: string(name='SubUserId'),
}

model ListGroupMemberResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  total?: long(name='Total'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  result?: [ 
    {
      externUserId?: string(name='ExternUserId'),
      email?: string(name='Email'),
      avatarUrl?: string(name='AvatarUrl'),
      state?: string(name='State'),
      accessLevel?: int32(name='AccessLevel'),
      id?: long(name='Id'),
    }
  ](name='Result'),
}

model ListGroupMemberResponse = {
  headers: map[string]string(name='headers'),
  body: ListGroupMemberResponseBody(name='body'),
}

async function listGroupMember(GroupId: string, request: ListGroupMemberRequest): ListGroupMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listGroupMemberWithOptions(GroupId, request, headers, runtime);
}

async function listGroupMemberWithOptions(GroupId: string, request: ListGroupMemberRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListGroupMemberResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.page)) {
    query.Page = request.page;
  }
  if (!Util.isUnset(request.pageSize)) {
    query.PageSize = request.pageSize;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListGroupMember', '2020-04-14', 'HTTPS', 'GET', 'AK', `/api/v3/groups/${GroupId}/members`, 'json', req, runtime);
}

model UpdateGroupMemberRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model UpdateGroupMemberResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  result?: {
    externUserId?: string(name='ExternUserId'),
    email?: string(name='Email'),
    avatarUrl?: string(name='AvatarUrl'),
    state?: string(name='State'),
    accessLevel?: int32(name='AccessLevel'),
    id?: long(name='Id'),
  }(name='Result'),
}

model UpdateGroupMemberResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateGroupMemberResponseBody(name='body'),
}

async function updateGroupMember(GroupId: string, UserId: string, request: UpdateGroupMemberRequest): UpdateGroupMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateGroupMemberWithOptions(GroupId, UserId, request, headers, runtime);
}

async function updateGroupMemberWithOptions(GroupId: string, UserId: string, request: UpdateGroupMemberRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateGroupMemberResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateGroupMember', '2020-04-14', 'HTTPS', 'PUT', 'AK', `/api/v3/groups/${GroupId}/members/${UserId}`, 'json', req, runtime);
}

model CreateMergeRequestCommentRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
}

model CreateMergeRequestCommentResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  result?: {
    outDated?: boolean(name='OutDated'),
    projectId?: long(name='ProjectId'),
    rangeContext?: string(name='RangeContext'),
    createdAt?: string(name='CreatedAt'),
    parentNoteId?: long(name='ParentNoteId'),
    isDraft?: boolean(name='IsDraft'),
    closed?: int32(name='Closed'),
    line?: long(name='Line'),
    side?: string(name='Side'),
    path?: string(name='Path'),
    note?: string(name='Note'),
    updatedAt?: string(name='UpdatedAt'),
    id?: long(name='Id'),
    author?: {
      externUserId?: string(name='ExternUserId'),
      email?: string(name='Email'),
      name?: string(name='Name'),
      avatarUrl?: string(name='AvatarUrl'),
      id?: long(name='Id'),
    }(name='Author'),
  }(name='Result'),
}

model CreateMergeRequestCommentResponse = {
  headers: map[string]string(name='headers'),
  body: CreateMergeRequestCommentResponseBody(name='body'),
}

async function createMergeRequestComment(ProjectId: string, MergeRequestId: string, request: CreateMergeRequestCommentRequest): CreateMergeRequestCommentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createMergeRequestCommentWithOptions(ProjectId, MergeRequestId, request, headers, runtime);
}

async function createMergeRequestCommentWithOptions(ProjectId: string, MergeRequestId: string, request: CreateMergeRequestCommentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateMergeRequestCommentResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('CreateMergeRequestComment', '2020-04-14', 'HTTPS', 'POST', 'AK', `/api/v4/projects/${ProjectId}/merge_request/${MergeRequestId}/comments`, 'json', req, runtime);
}

model CreateRepositoryDeployKeyRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model CreateRepositoryDeployKeyResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  result?: {
    createdAt?: string(name='CreatedAt'),
    key?: string(name='Key'),
    title?: string(name='Title'),
    id?: long(name='Id'),
    fingerPrint?: string(name='FingerPrint'),
  }(name='Result'),
}

model CreateRepositoryDeployKeyResponse = {
  headers: map[string]string(name='headers'),
  body: CreateRepositoryDeployKeyResponseBody(name='body'),
}

async function createRepositoryDeployKey(ProjectId: string, request: CreateRepositoryDeployKeyRequest): CreateRepositoryDeployKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createRepositoryDeployKeyWithOptions(ProjectId, request, headers, runtime);
}

async function createRepositoryDeployKeyWithOptions(ProjectId: string, request: CreateRepositoryDeployKeyRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateRepositoryDeployKeyResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('CreateRepositoryDeployKey', '2020-04-14', 'HTTPS', 'POST', 'AK', `/api/v3/projects/${ProjectId}/keys`, 'json', req, runtime);
}

model DeleteRepositoryTagRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
}

model DeleteRepositoryTagResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  result?: {
    tagName?: string(name='TagName'),
  }(name='Result'),
}

model DeleteRepositoryTagResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteRepositoryTagResponseBody(name='body'),
}

async function deleteRepositoryTag(ProjectId: string, TagName: string, request: DeleteRepositoryTagRequest): DeleteRepositoryTagResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteRepositoryTagWithOptions(ProjectId, TagName, request, headers, runtime);
}

async function deleteRepositoryTagWithOptions(ProjectId: string, TagName: string, request: DeleteRepositoryTagRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteRepositoryTagResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeleteRepositoryTag', '2020-04-14', 'HTTPS', 'DELETE', 'AK', `/api/v3/projects/${ProjectId}/repository/tags/${TagName}`, 'json', req, runtime);
}

model CreateRepositoryRequest {
  accessToken?: string(name='AccessToken'),
  sync?: boolean(name='Sync'),
  createParentPath?: boolean(name='CreateParentPath'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model CreateRepositoryResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: int32(name='ErrorCode'),
  result?: {
    lastActivityAt?: string(name='LastActivityAt'),
    defaultBranch?: string(name='DefaultBranch'),
    avatarUrl?: string(name='AvatarUrl'),
    archive?: boolean(name='Archive'),
    snippetsEnableStatus?: boolean(name='SnippetsEnableStatus'),
    createdAt?: string(name='CreatedAt'),
    issuesEnableStatus?: boolean(name='IssuesEnableStatus'),
    demoProjectStatus?: boolean(name='DemoProjectStatus'),
    creatorId?: long(name='CreatorId'),
    buildsEnableStatus?: boolean(name='BuildsEnableStatus'),
    httpUrlToRepo?: string(name='HttpUrlToRepo'),
    webUrl?: string(name='WebUrl'),
    description?: string(name='Description'),
    nameWithNamespace?: string(name='NameWithNamespace'),
    public?: boolean(name='Public'),
    pathWithNamespace?: string(name='PathWithNamespace'),
    mergeRequestEnableStatus?: boolean(name='MergeRequestEnableStatus'),
    path?: string(name='Path'),
    visibilityLevel?: string(name='VisibilityLevel'),
    wikiEnableStatus?: boolean(name='WikiEnableStatus'),
    sshUrlToRepo?: string(name='SshUrlToRepo'),
    name?: string(name='Name'),
    id?: long(name='Id'),
    tagList?: [ string ](name='TagList'),
    namespace?: {
      avatar?: string(name='Avatar'),
      description?: string(name='Description'),
      state?: string(name='State'),
      public?: boolean(name='Public'),
      visibilityLevel?: string(name='VisibilityLevel'),
      createdAt?: string(name='CreatedAt'),
      path?: string(name='Path'),
      updatedAt?: string(name='UpdatedAt'),
      name?: string(name='Name'),
      ownerId?: long(name='OwnerId'),
      id?: long(name='Id'),
    }(name='Namespace'),
  }(name='Result'),
}

model CreateRepositoryResponse = {
  headers: map[string]string(name='headers'),
  body: CreateRepositoryResponseBody(name='body'),
}

async function createRepository(request: CreateRepositoryRequest): CreateRepositoryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createRepositoryWithOptions(request, headers, runtime);
}

async function createRepositoryWithOptions(request: CreateRepositoryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateRepositoryResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.sync)) {
    query.Sync = request.sync;
  }
  if (!Util.isUnset(request.createParentPath)) {
    query.CreateParentPath = request.createParentPath;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('CreateRepository', '2020-04-14', 'HTTPS', 'POST', 'AK', `/api/v3/projects`, 'json', req, runtime);
}

model GetCodeCompletionRequest {
  fetchKeys?: string(name='FetchKeys'),
  isEncrypted?: boolean(name='IsEncrypted'),
}

model GetCodeCompletionResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  result?: {
    clientTimestamp?: string(name='ClientTimestamp'),
    receiveTimestamp?: string(name='ReceiveTimestamp'),
    rspTimestamp?: string(name='RspTimestamp'),
    invokeTimestamp?: string(name='InvokeTimestamp'),
    body?: string(name='Body'),
    fetchTimestamp?: string(name='FetchTimestamp'),
  }(name='Result'),
}

model GetCodeCompletionResponse = {
  headers: map[string]string(name='headers'),
  body: GetCodeCompletionResponseBody(name='body'),
}

async function getCodeCompletion(ServiceName: string, request: GetCodeCompletionRequest): GetCodeCompletionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getCodeCompletionWithOptions(ServiceName, request, headers, runtime);
}

async function getCodeCompletionWithOptions(ServiceName: string, request: GetCodeCompletionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetCodeCompletionResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.fetchKeys)) {
    query.FetchKeys = request.fetchKeys;
  }
  if (!Util.isUnset(request.isEncrypted)) {
    query.IsEncrypted = request.isEncrypted;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetCodeCompletion', '2020-04-14', 'HTTPS', 'POST', 'AK', `/api/v2/service/invoke/${ServiceName}`, 'json', req, runtime);
}

model ListMergeRequestsRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  page?: long(name='Page'),
  pageSize?: long(name='PageSize'),
  groupIdList?: string(name='GroupIdList'),
  projectIdList?: string(name='ProjectIdList'),
  authorCodeupIdList?: string(name='AuthorCodeupIdList'),
  authorIdList?: string(name='AuthorIdList'),
  assigneeCodeupIdList?: string(name='AssigneeCodeupIdList'),
  assigneeIdList?: string(name='AssigneeIdList'),
  subscriberCodeupIdList?: string(name='SubscriberCodeupIdList'),
  state?: string(name='State'),
  search?: string(name='Search'),
  order?: string(name='Order'),
  afterDate?: string(name='AfterDate'),
  beforeDate?: string(name='BeforeDate'),
}

model ListMergeRequestsResponseBody = {
  requestId?: string(name='RequestId'),
  errorMessage?: string(name='ErrorMessage'),
  total?: long(name='Total'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  result?: [ 
    {
      isSupportMerge?: boolean(name='IsSupportMerge'),
      state?: string(name='State'),
      behindCommitCount?: int32(name='BehindCommitCount'),
      projectId?: long(name='ProjectId'),
      createdAt?: string(name='CreatedAt'),
      acceptedRevision?: string(name='AcceptedRevision'),
      sourceBranch?: string(name='SourceBranch'),
      webUrl?: string(name='WebUrl'),
      description?: string(name='Description'),
      nameWithNamespace?: string(name='NameWithNamespace'),
      mergeType?: string(name='MergeType'),
      targetBranch?: string(name='TargetBranch'),
      aheadCommitCount?: int32(name='AheadCommitCount'),
      updatedAt?: string(name='UpdatedAt'),
      title?: string(name='Title'),
      mergeError?: string(name='MergeError'),
      mergedRevision?: string(name='MergedRevision'),
      id?: long(name='Id'),
      mergeStatus?: string(name='MergeStatus'),
      assigneeList?: [ 
        {
          status?: string(name='Status'),
          externUserId?: string(name='ExternUserId'),
          email?: string(name='Email'),
          avatarUrl?: string(name='AvatarUrl'),
          name?: string(name='Name'),
          id?: string(name='Id'),
        }
      ](name='AssigneeList'),
      approveCheckResult?: {
        totalCheckResult?: string(name='TotalCheckResult'),
        satisfiedCheckResults?: [ 
          {
            checkStatus?: string(name='CheckStatus'),
            checkType?: string(name='CheckType'),
            checkName?: string(name='CheckName'),
            extraUsers?: [ 
              {
                externUserId?: string(name='ExternUserId'),
                name?: string(name='Name'),
                avatarUrl?: string(name='AvatarUrl'),
                id?: long(name='Id'),
              }
            ](name='ExtraUsers'),
            unsatisfiedItems?: [ string ](name='UnsatisfiedItems'),
            satisfiedItems?: [ string ](name='SatisfiedItems'),
          }
        ](name='SatisfiedCheckResults'),
        unsatisfiedCheckResults?: [ 
          {
            checkStatus?: string(name='CheckStatus'),
            checkType?: string(name='CheckType'),
            checkName?: string(name='CheckName'),
            extraUsers?: [ 
              {
                externUserId?: string(name='ExternUserId'),
                name?: string(name='Name'),
                avatarUrl?: string(name='AvatarUrl'),
                id?: long(name='Id'),
              }
            ](name='ExtraUsers'),
            unsatisfiedItems?: [ string ](name='UnsatisfiedItems'),
            satisfiedItems?: [ string ](name='SatisfiedItems'),
          }
        ](name='UnsatisfiedCheckResults'),
      }(name='ApproveCheckResult'),
      author?: {
        externUserId?: string(name='ExternUserId'),
        name?: string(name='Name'),
        avatarUrl?: string(name='AvatarUrl'),
        id?: long(name='Id'),
      }(name='Author'),
    }
  ](name='Result'),
}

model ListMergeRequestsResponse = {
  headers: map[string]string(name='headers'),
  body: ListMergeRequestsResponseBody(name='body'),
}

async function listMergeRequests(request: ListMergeRequestsRequest): ListMergeRequestsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listMergeRequestsWithOptions(request, headers, runtime);
}

async function listMergeRequestsWithOptions(request: ListMergeRequestsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListMergeRequestsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.page)) {
    query.Page = request.page;
  }
  if (!Util.isUnset(request.pageSize)) {
    query.PageSize = request.pageSize;
  }
  if (!Util.isUnset(request.groupIdList)) {
    query.GroupIdList = request.groupIdList;
  }
  if (!Util.isUnset(request.projectIdList)) {
    query.ProjectIdList = request.projectIdList;
  }
  if (!Util.isUnset(request.authorCodeupIdList)) {
    query.AuthorCodeupIdList = request.authorCodeupIdList;
  }
  if (!Util.isUnset(request.authorIdList)) {
    query.AuthorIdList = request.authorIdList;
  }
  if (!Util.isUnset(request.assigneeCodeupIdList)) {
    query.AssigneeCodeupIdList = request.assigneeCodeupIdList;
  }
  if (!Util.isUnset(request.assigneeIdList)) {
    query.AssigneeIdList = request.assigneeIdList;
  }
  if (!Util.isUnset(request.subscriberCodeupIdList)) {
    query.SubscriberCodeupIdList = request.subscriberCodeupIdList;
  }
  if (!Util.isUnset(request.state)) {
    query.State = request.state;
  }
  if (!Util.isUnset(request.search)) {
    query.Search = request.search;
  }
  if (!Util.isUnset(request.order)) {
    query.Order = request.order;
  }
  if (!Util.isUnset(request.afterDate)) {
    query.AfterDate = request.afterDate;
  }
  if (!Util.isUnset(request.beforeDate)) {
    query.BeforeDate = request.beforeDate;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListMergeRequests', '2020-04-14', 'HTTPS', 'GET', 'AK', `/api/v4/merge_requests/advanced_search`, 'json', req, runtime);
}

model ListOrganizationSecurityScoresRequest {
  accessToken?: string(name='AccessToken'),
}

model ListOrganizationSecurityScoresResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  result?: [ 
    {
      id?: long(name='Id'),
      enable?: boolean(name='Enable'),
      organizationId?: string(name='OrganizationId'),
      organizationSecurityScore?: {
        codeContentScore?: int32(name='CodeContentScore'),
        memberBehaviorScore?: int32(name='MemberBehaviorScore'),
        authorityControlScore?: int32(name='AuthorityControlScore'),
        level?: string(name='Level'),
      }(name='OrganizationSecurityScore'),
    }
  ](name='Result'),
}

model ListOrganizationSecurityScoresResponse = {
  headers: map[string]string(name='headers'),
  body: ListOrganizationSecurityScoresResponseBody(name='body'),
}

async function listOrganizationSecurityScores(request: ListOrganizationSecurityScoresRequest): ListOrganizationSecurityScoresResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listOrganizationSecurityScoresWithOptions(request, headers, runtime);
}

async function listOrganizationSecurityScoresWithOptions(request: ListOrganizationSecurityScoresRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListOrganizationSecurityScoresResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListOrganizationSecurityScores', '2020-04-14', 'HTTPS', 'GET', 'AK', `/api/v4/organization/security/scores`, 'json', req, runtime);
}

model GetFileBlobsRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  filePath?: string(name='FilePath'),
  ref?: string(name='Ref'),
  from?: long(name='From'),
  to?: long(name='To'),
  subUserId?: string(name='SubUserId'),
}

model GetFileBlobsResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  result?: {
    totalLines?: int32(name='TotalLines'),
    content?: string(name='Content'),
  }(name='Result'),
}

model GetFileBlobsResponse = {
  headers: map[string]string(name='headers'),
  body: GetFileBlobsResponseBody(name='body'),
}

async function getFileBlobs(ProjectId: string, request: GetFileBlobsRequest): GetFileBlobsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getFileBlobsWithOptions(ProjectId, request, headers, runtime);
}

async function getFileBlobsWithOptions(ProjectId: string, request: GetFileBlobsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetFileBlobsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.filePath)) {
    query.FilePath = request.filePath;
  }
  if (!Util.isUnset(request.ref)) {
    query.Ref = request.ref;
  }
  if (!Util.isUnset(request.from)) {
    query.From = request.from;
  }
  if (!Util.isUnset(request.to)) {
    query.To = request.to;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetFileBlobs', '2020-04-14', 'HTTPS', 'GET', 'AK', `/api/v4/projects/${ProjectId}/repository/blobs`, 'json', req, runtime);
}

model MergeMergeRequestRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model MergeMergeRequestResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  result?: {
    behindCommitCount?: int32(name='BehindCommitCount'),
    state?: string(name='State'),
    projectId?: long(name='ProjectId'),
    createdAt?: string(name='CreatedAt'),
    acceptedRevision?: string(name='AcceptedRevision'),
    sourceBranch?: string(name='SourceBranch'),
    webUrl?: string(name='WebUrl'),
    description?: string(name='Description'),
    mergeType?: string(name='MergeType'),
    nameWithNamespace?: string(name='NameWithNamespace'),
    targetBranch?: string(name='TargetBranch'),
    aheadCommitCount?: int32(name='AheadCommitCount'),
    updatedAt?: string(name='UpdatedAt'),
    title?: string(name='Title'),
    mergeError?: string(name='MergeError'),
    mergedRevision?: string(name='MergedRevision'),
    id?: long(name='Id'),
    mergeStatus?: string(name='MergeStatus'),
    assigneeList?: [ 
      {
        externUserId?: string(name='ExternUserId'),
        name?: string(name='Name'),
        avatarUrl?: string(name='AvatarUrl'),
        id?: string(name='Id'),
      }
    ](name='AssigneeList'),
    author?: {
      externUserId?: string(name='ExternUserId'),
      name?: string(name='Name'),
      avatarUrl?: string(name='AvatarUrl'),
      id?: long(name='Id'),
    }(name='Author'),
    approveCheckResult?: {
      totalCheckResult?: string(name='TotalCheckResult'),
      satisfiedCheckResults?: [ 
        {
          checkStatus?: string(name='CheckStatus'),
          checkType?: string(name='CheckType'),
          checkName?: string(name='CheckName'),
          extraUsers?: [ 
            {
              externUserId?: string(name='ExternUserId'),
              name?: string(name='Name'),
              avatarUrl?: string(name='AvatarUrl'),
              id?: long(name='Id'),
            }
          ](name='ExtraUsers'),
          unsatisfiedItems?: [ string ](name='UnsatisfiedItems'),
          satisfiedItems?: [ string ](name='SatisfiedItems'),
        }
      ](name='SatisfiedCheckResults'),
      unsatisfiedCheckResults?: [ 
        {
          checkStatus?: string(name='CheckStatus'),
          checkType?: string(name='CheckType'),
          checkName?: string(name='CheckName'),
          extraUsers?: [ 
            {
              externUserId?: string(name='ExternUserId'),
              name?: string(name='Name'),
              avatarUrl?: string(name='AvatarUrl'),
              id?: long(name='Id'),
            }
          ](name='ExtraUsers'),
          unsatisfiedItems?: [ string ](name='UnsatisfiedItems'),
          satisfiedItems?: [ string ](name='SatisfiedItems'),
        }
      ](name='UnsatisfiedCheckResults'),
    }(name='ApproveCheckResult'),
  }(name='Result'),
}

model MergeMergeRequestResponse = {
  headers: map[string]string(name='headers'),
  body: MergeMergeRequestResponseBody(name='body'),
}

async function mergeMergeRequest(ProjectId: string, MergeRequestId: string, request: MergeMergeRequestRequest): MergeMergeRequestResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return mergeMergeRequestWithOptions(ProjectId, MergeRequestId, request, headers, runtime);
}

async function mergeMergeRequestWithOptions(ProjectId: string, MergeRequestId: string, request: MergeMergeRequestRequest, headers: map[string]string, runtime: Util.RuntimeOptions): MergeMergeRequestResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('MergeMergeRequest', '2020-04-14', 'HTTPS', 'PUT', 'AK', `/api/v3/projects/${ProjectId}/merge_request/${MergeRequestId}/merge`, 'json', req, runtime);
}

model DeleteGroupMemberRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model DeleteGroupMemberResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  result?: {
    externUserId?: string(name='ExternUserId'),
    email?: string(name='Email'),
    avatarUrl?: string(name='AvatarUrl'),
    state?: string(name='State'),
    accessLevel?: int32(name='AccessLevel'),
    id?: long(name='Id'),
  }(name='Result'),
}

model DeleteGroupMemberResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteGroupMemberResponseBody(name='body'),
}

async function deleteGroupMember(GroupId: string, UserId: string, request: DeleteGroupMemberRequest): DeleteGroupMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteGroupMemberWithOptions(GroupId, UserId, request, headers, runtime);
}

async function deleteGroupMemberWithOptions(GroupId: string, UserId: string, request: DeleteGroupMemberRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteGroupMemberResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeleteGroupMember', '2020-04-14', 'HTTPS', 'DELETE', 'AK', `/api/v3/groups/${GroupId}/members/${UserId}`, 'json', req, runtime);
}

model ListRepositoryMemberWithInheritedRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
}

model ListRepositoryMemberWithInheritedResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  result?: [ 
    {
      externUserId?: string(name='ExternUserId'),
      email?: string(name='Email'),
      avatarUrl?: string(name='AvatarUrl'),
      state?: string(name='State'),
      accessLevel?: int32(name='AccessLevel'),
      name?: string(name='Name'),
      id?: long(name='Id'),
      username?: string(name='Username'),
      inherited?: {
        type?: string(name='Type'),
        nameWithNamespace?: string(name='NameWithNamespace'),
        pathWithNamespace?: string(name='PathWithNamespace'),
        visibilityLevel?: string(name='VisibilityLevel'),
        path?: string(name='Path'),
        name?: string(name='Name'),
        id?: long(name='Id'),
      }(name='Inherited'),
    }
  ](name='Result'),
}

model ListRepositoryMemberWithInheritedResponse = {
  headers: map[string]string(name='headers'),
  body: ListRepositoryMemberWithInheritedResponseBody(name='body'),
}

async function listRepositoryMemberWithInherited(ProjectId: string, request: ListRepositoryMemberWithInheritedRequest): ListRepositoryMemberWithInheritedResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRepositoryMemberWithInheritedWithOptions(ProjectId, request, headers, runtime);
}

async function listRepositoryMemberWithInheritedWithOptions(ProjectId: string, request: ListRepositoryMemberWithInheritedRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRepositoryMemberWithInheritedResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListRepositoryMemberWithInherited', '2020-04-14', 'HTTPS', 'GET', 'AK', `/api/v4/projects/${ProjectId}/all_members`, 'json', req, runtime);
}

model GetGroupDetailRequest {
  accessToken?: string(name='AccessToken'),
  groupId?: long(name='GroupId'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model GetGroupDetailResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  result?: {
    type?: string(name='Type'),
    avatarUrl?: string(name='AvatarUrl'),
    ownerId?: long(name='OwnerId'),
    webUrl?: string(name='WebUrl'),
    parentId?: long(name='ParentId'),
    description?: string(name='Description'),
    nameWithNamespace?: string(name='NameWithNamespace'),
    pathWithNamespace?: string(name='PathWithNamespace'),
    path?: string(name='Path'),
    visibilityLevel?: string(name='VisibilityLevel'),
    name?: string(name='Name'),
    id?: long(name='Id'),
  }(name='Result'),
}

model GetGroupDetailResponse = {
  headers: map[string]string(name='headers'),
  body: GetGroupDetailResponseBody(name='body'),
}

async function getGroupDetail(request: GetGroupDetailRequest): GetGroupDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getGroupDetailWithOptions(request, headers, runtime);
}

async function getGroupDetailWithOptions(request: GetGroupDetailRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetGroupDetailResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.groupId)) {
    query.GroupId = request.groupId;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetGroupDetail', '2020-04-14', 'HTTPS', 'GET', 'AK', `/api/v3/groups/detail`, 'json', req, runtime);
}

model GetCodeupOrganizationRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model GetCodeupOrganizationResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  result?: {
    namespaceId?: long(name='NamespaceId'),
    userRole?: string(name='UserRole'),
    path?: string(name='Path'),
    createdAt?: string(name='CreatedAt'),
    updatedAt?: string(name='UpdatedAt'),
    id?: long(name='Id'),
    organizationId?: string(name='OrganizationId'),
  }(name='Result'),
}

model GetCodeupOrganizationResponse = {
  headers: map[string]string(name='headers'),
  body: GetCodeupOrganizationResponseBody(name='body'),
}

async function getCodeupOrganization(OrganizationIdentity: string, request: GetCodeupOrganizationRequest): GetCodeupOrganizationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getCodeupOrganizationWithOptions(OrganizationIdentity, request, headers, runtime);
}

async function getCodeupOrganizationWithOptions(OrganizationIdentity: string, request: GetCodeupOrganizationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetCodeupOrganizationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetCodeupOrganization', '2020-04-14', 'HTTPS', 'GET', 'AK', `/api/v4/organization/${OrganizationIdentity}`, 'json', req, runtime);
}

model GetOrganizationSecurityCenterStatusRequest {
  accessToken?: string(name='AccessToken'),
}

model GetOrganizationSecurityCenterStatusResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  result?: {
    enable?: boolean(name='Enable'),
  }(name='Result'),
}

model GetOrganizationSecurityCenterStatusResponse = {
  headers: map[string]string(name='headers'),
  body: GetOrganizationSecurityCenterStatusResponseBody(name='body'),
}

async function getOrganizationSecurityCenterStatus(request: GetOrganizationSecurityCenterStatusRequest): GetOrganizationSecurityCenterStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getOrganizationSecurityCenterStatusWithOptions(request, headers, runtime);
}

async function getOrganizationSecurityCenterStatusWithOptions(request: GetOrganizationSecurityCenterStatusRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetOrganizationSecurityCenterStatusResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetOrganizationSecurityCenterStatus', '2020-04-14', 'HTTPS', 'GET', 'AK', `/api/v4/organization/security/status`, 'json', req, runtime);
}

model ListRepositoryBranchesRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
  page?: long(name='Page'),
  pageSize?: long(name='PageSize'),
  search?: string(name='Search'),
}

model ListRepositoryBranchesResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  total?: long(name='Total'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  result?: [ 
    {
      protectedBranch?: boolean(name='ProtectedBranch'),
      branchName?: string(name='BranchName'),
      commitInfo?: {
        shortId?: string(name='ShortId'),
        authorName?: string(name='AuthorName'),
        authorDate?: string(name='AuthorDate'),
        createdAt?: string(name='CreatedAt'),
        message?: string(name='Message'),
        committerName?: string(name='CommitterName'),
        title?: string(name='Title'),
        authorEmail?: string(name='AuthorEmail'),
        committerEmail?: string(name='CommitterEmail'),
        id?: string(name='Id'),
        committedDate?: string(name='CommittedDate'),
        parentIds?: [ string ](name='ParentIds'),
      }(name='CommitInfo'),
    }
  ](name='Result'),
}

model ListRepositoryBranchesResponse = {
  headers: map[string]string(name='headers'),
  body: ListRepositoryBranchesResponseBody(name='body'),
}

async function listRepositoryBranches(ProjectId: string, request: ListRepositoryBranchesRequest): ListRepositoryBranchesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRepositoryBranchesWithOptions(ProjectId, request, headers, runtime);
}

async function listRepositoryBranchesWithOptions(ProjectId: string, request: ListRepositoryBranchesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRepositoryBranchesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }
  if (!Util.isUnset(request.page)) {
    query.Page = request.page;
  }
  if (!Util.isUnset(request.pageSize)) {
    query.PageSize = request.pageSize;
  }
  if (!Util.isUnset(request.search)) {
    query.Search = request.search;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListRepositoryBranches', '2020-04-14', 'HTTPS', 'GET', 'AK', `/api/v3/projects/${ProjectId}/repository/branches`, 'json', req, runtime);
}

model CreateBranchRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  subUserId?: string(name='SubUserId'),
}

model CreateBranchResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  result?: {
    protectedBranch?: boolean(name='ProtectedBranch'),
    branchName?: string(name='BranchName'),
    commitInfo?: {
      shortId?: string(name='ShortId'),
      authorName?: string(name='AuthorName'),
      authorDate?: string(name='AuthorDate'),
      createdAt?: string(name='CreatedAt'),
      message?: string(name='Message'),
      committerName?: string(name='CommitterName'),
      title?: string(name='Title'),
      authorEmail?: string(name='AuthorEmail'),
      committerEmail?: string(name='CommitterEmail'),
      id?: string(name='Id'),
      committedDate?: string(name='CommittedDate'),
      parentIds?: [ string ](name='ParentIds'),
    }(name='CommitInfo'),
  }(name='Result'),
}

model CreateBranchResponse = {
  headers: map[string]string(name='headers'),
  body: CreateBranchResponseBody(name='body'),
}

async function createBranch(ProjectId: string, request: CreateBranchRequest): CreateBranchResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createBranchWithOptions(ProjectId, request, headers, runtime);
}

async function createBranchWithOptions(ProjectId: string, request: CreateBranchRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateBranchResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('CreateBranch', '2020-04-14', 'HTTPS', 'POST', 'AK', `/api/v3/projects/${ProjectId}/repository/branches`, 'json', req, runtime);
}

model GetOrganizationRepositorySettingRequest {
  accessToken?: string(name='AccessToken', description='个人访问令牌。 使用阿里云AK+SK或使用STS临时授权方式不需要传该字段'),
  organizationId?: string(name='OrganizationId', description='企业标识，也称企业id，字符串形式，可在云效访问链接中获取，如 https://devops.aliyun.com/organization/'),
}

model GetOrganizationRepositorySettingResponseBody = {
  errorMessage?: string(name='ErrorMessage', description='错误信息'),
  requestId?: string(name='RequestId', description='请求ID'),
  success?: boolean(name='Success', description='请求结果'),
  errorCode?: string(name='ErrorCode', description='错误码'),
  result?: {
    groupRequired?: boolean(name='GroupRequired', description='创建库是否必选代码组'),
    repoVisibilityLevel?: [ long ](name='RepoVisibilityLevel', description='创建代码库允许使用的可见性选项。0：允许私有；10：允许企业可见'),
    repoCreatorIdentity?: [ long ](name='RepoCreatorIdentity', description='允许创建代码库的角色。5：企业外部成员；15：企业成员；60：企业管理员'),
    repoAdminAccessVisibilityLevel?: [ long ](name='RepoAdminAccessVisibilityLevel', description='库公开性调整设置。0：允许库管理员调整公开性为私有；10：允许库管理员调整公开性为企业可见'),
    repoAdminOperation?: [ long ](name='RepoAdminOperation', description='库管理员允许操作。1：允许库管理员删除代码库；2：未使用保留操作'),
    openCloneDownloadControl?: boolean(name='OpenCloneDownloadControl', description='开启克隆下载限制'),
    orgCloneDownloadMethodList?: [ 
      {
        permissionCode?: string(name='PermissionCode', description='权限码。ssh-clone：SSH克隆；http-clone：HTTP克隆；download：下载ZIP/TAR'),
        allowed?: boolean(name='Allowed', description='是否允许'),
      }
    ](name='OrgCloneDownloadMethodList', description='克隆下载限制方法列表'),
    orgCloneDownloadRoleList?: [ 
      {
        roleCode?: long(name='RoleCode', description='角色Code。5：企业外部成员；9999：企业成员（含管理员）'),
        allowed?: boolean(name='Allowed', description='是否允许'),
      }
    ](name='OrgCloneDownloadRoleList', description='克隆下载限制角色列表'),
    forcePushForbidden?: boolean(name='ForcePushForbidden', description='禁止强制推送（Force Push）'),
  }(name='Result', description='响应结果'),
}

model GetOrganizationRepositorySettingResponse = {
  headers: map[string]string(name='headers'),
  body: GetOrganizationRepositorySettingResponseBody(name='body'),
}

async function getOrganizationRepositorySetting(request: GetOrganizationRepositorySettingRequest): GetOrganizationRepositorySettingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getOrganizationRepositorySettingWithOptions(request, headers, runtime);
}

async function getOrganizationRepositorySettingWithOptions(request: GetOrganizationRepositorySettingRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetOrganizationRepositorySettingResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetOrganizationRepositorySetting', '2020-04-14', 'HTTPS', 'GET', 'AK', `/api/v4/organization/settings/repo`, 'json', req, runtime);
}

model ListGroupRepositoriesRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  isMember?: boolean(name='IsMember'),
  subUserId?: string(name='SubUserId'),
  search?: string(name='Search'),
  page?: long(name='Page'),
  pageSize?: long(name='PageSize'),
}

model ListGroupRepositoriesResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  total?: long(name='Total'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  result?: [ 
    {
      lastActivityAt?: string(name='LastActivityAt'),
      namespaceId?: long(name='NamespaceId'),
      httpCloneUrl?: string(name='HttpCloneUrl'),
      archive?: boolean(name='Archive'),
      sshCloneUrl?: string(name='SshCloneUrl'),
      createdAt?: string(name='CreatedAt'),
      creatorId?: long(name='CreatorId'),
      importStatus?: string(name='ImportStatus'),
      webUrl?: string(name='WebUrl'),
      nameWithNamespace?: string(name='NameWithNamespace'),
      pathWithNamespace?: string(name='PathWithNamespace'),
      visibilityLevel?: int32(name='VisibilityLevel'),
      path?: string(name='Path'),
      updatedAt?: string(name='UpdatedAt'),
      name?: string(name='Name'),
      id?: long(name='Id'),
    }
  ](name='Result'),
}

model ListGroupRepositoriesResponse = {
  headers: map[string]string(name='headers'),
  body: ListGroupRepositoriesResponseBody(name='body'),
}

async function listGroupRepositories(Identity: string, request: ListGroupRepositoriesRequest): ListGroupRepositoriesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listGroupRepositoriesWithOptions(Identity, request, headers, runtime);
}

async function listGroupRepositoriesWithOptions(Identity: string, request: ListGroupRepositoriesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListGroupRepositoriesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.isMember)) {
    query.IsMember = request.isMember;
  }
  if (!Util.isUnset(request.subUserId)) {
    query.SubUserId = request.subUserId;
  }
  if (!Util.isUnset(request.search)) {
    query.Search = request.search;
  }
  if (!Util.isUnset(request.page)) {
    query.Page = request.page;
  }
  if (!Util.isUnset(request.pageSize)) {
    query.PageSize = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListGroupRepositories', '2020-04-14', 'HTTPS', 'GET', 'AK', `/api/v3/groups/${Identity}/projects`, 'json', req, runtime);
}

model GetRepositoryTagV2Request {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  tagName?: string(name='TagName'),
}

model GetRepositoryTagV2ResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  result?: {
    message?: string(name='Message'),
    name?: string(name='Name'),
    id?: string(name='Id'),
    commit?: {
      shortId?: string(name='ShortId'),
      authorName?: string(name='AuthorName'),
      createdAt?: string(name='CreatedAt'),
      message?: string(name='Message'),
      authoredDate?: string(name='AuthoredDate'),
      title?: string(name='Title'),
      committerName?: string(name='CommitterName'),
      authorEmail?: string(name='AuthorEmail'),
      id?: string(name='Id'),
      committerEmail?: string(name='CommitterEmail'),
      committedDate?: string(name='CommittedDate'),
      parentIds?: [ string ](name='ParentIds'),
      signature?: {
        verificationStatus?: string(name='VerificationStatus'),
        gpgKeyId?: string(name='GpgKeyId'),
      }(name='Signature'),
    }(name='Commit'),
    signature?: {
      verificationStatus?: string(name='VerificationStatus'),
      gpgKeyId?: string(name='GpgKeyId'),
    }(name='Signature'),
  }(name='Result'),
}

model GetRepositoryTagV2Response = {
  headers: map[string]string(name='headers'),
  body: GetRepositoryTagV2ResponseBody(name='body'),
}

async function getRepositoryTagV2(ProjectId: string, request: GetRepositoryTagV2Request): GetRepositoryTagV2Response {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getRepositoryTagV2WithOptions(ProjectId, request, headers, runtime);
}

async function getRepositoryTagV2WithOptions(ProjectId: string, request: GetRepositoryTagV2Request, headers: map[string]string, runtime: Util.RuntimeOptions): GetRepositoryTagV2Response {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.tagName)) {
    query.TagName = request.tagName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetRepositoryTagV2', '2020-04-14', 'HTTPS', 'GET', 'AK', `/api/v3/projects/${ProjectId}/repository/tag/info`, 'json', req, runtime);
}

model GetMergeRequestSettingRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
}

model GetMergeRequestSettingResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  result?: {
    isEnableSmartCodeReview?: boolean(name='IsEnableSmartCodeReview'),
    mergeTypes?: [ string ](name='MergeTypes'),
  }(name='Result'),
}

model GetMergeRequestSettingResponse = {
  headers: map[string]string(name='headers'),
  body: GetMergeRequestSettingResponseBody(name='body'),
}

async function getMergeRequestSetting(ProjectId: string, request: GetMergeRequestSettingRequest): GetMergeRequestSettingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getMergeRequestSettingWithOptions(ProjectId, request, headers, runtime);
}

async function getMergeRequestSettingWithOptions(ProjectId: string, request: GetMergeRequestSettingRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetMergeRequestSettingResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetMergeRequestSetting', '2020-04-14', 'HTTPS', 'GET', 'AK', `/api/v4/projects/${ProjectId}/settings/merge_requests`, 'json', req, runtime);
}

model ListRepositoryWebhookRequest {
  accessToken?: string(name='AccessToken'),
  organizationId?: string(name='OrganizationId'),
  page?: long(name='Page'),
  pageSize?: long(name='PageSize'),
}

model ListRepositoryWebhookResponseBody = {
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  total?: long(name='Total'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  result?: [ 
    {
      pushEvents?: boolean(name='PushEvents'),
      projectId?: long(name='ProjectId'),
      createdAt?: string(name='CreatedAt'),
      url?: string(name='Url'),
      tagPushEvents?: boolean(name='TagPushEvents'),
      lastTestResult?: string(name='LastTestResult'),
      mergeRequestsEvents?: boolean(name='MergeRequestsEvents'),
      description?: string(name='Description'),
      noteEvents?: boolean(name='NoteEvents'),
      secretToken?: string(name='SecretToken'),
      id?: long(name='Id'),
      enableSslVerification?: boolean(name='EnableSslVerification'),
    }
  ](name='Result'),
}

model ListRepositoryWebhookResponse = {
  headers: map[string]string(name='headers'),
  body: ListRepositoryWebhookResponseBody(name='body'),
}

async function listRepositoryWebhook(ProjectId: string, request: ListRepositoryWebhookRequest): ListRepositoryWebhookResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRepositoryWebhookWithOptions(ProjectId, request, headers, runtime);
}

async function listRepositoryWebhookWithOptions(ProjectId: string, request: ListRepositoryWebhookRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRepositoryWebhookResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.accessToken)) {
    query.AccessToken = request.accessToken;
  }
  if (!Util.isUnset(request.organizationId)) {
    query.OrganizationId = request.organizationId;
  }
  if (!Util.isUnset(request.page)) {
    query.Page = request.page;
  }
  if (!Util.isUnset(request.pageSize)) {
    query.PageSize = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListRepositoryWebhook', '2020-04-14', 'HTTPS', 'GET', 'AK', `/api/v3/projects/${ProjectId}/hooks`, 'json', req, runtime);
}

