/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'imm';
  @version = '2017-09-06';
  @endpointRule = 'regional';
  @endpointMap = {
    cn-beijing-gov-1 = 'imm-vpc.cn-beijing-gov-1.aliyuncs.com',
  };
}

function close(): void {
  @handler.close();
}

model CompareImageFacesRequest {
  faceIdA?: string(name='FaceIdA', position='Query'),
  faceIdB?: string(name='FaceIdB', position='Query'),
  imageUriA?: string(name='ImageUriA', position='Query'),
  imageUriB?: string(name='ImageUriB', position='Query'),
  project: string(name='Project', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  setId?: string(name='SetId', position='Query'),
}

model CompareImageFacesResponseBody = {
  faceA?: {
    faceAttributes?: {
      faceBoundary?: {
        height?: int32(name='Height'),
        left?: int32(name='Left'),
        top?: int32(name='Top'),
        width?: int32(name='Width'),
      }(name='FaceBoundary'),
    }(name='FaceAttributes'),
    faceId?: string(name='FaceId'),
  }(name='FaceA'),
  faceB?: {
    faceAttributes?: {
      faceBoundary?: {
        height?: int32(name='Height'),
        left?: int32(name='Left'),
        top?: int32(name='Top'),
        width?: int32(name='Width'),
      }(name='FaceBoundary'),
    }(name='FaceAttributes'),
    faceId?: string(name='FaceId'),
  }(name='FaceB'),
  requestId?: string(name='RequestId'),
  setId?: string(name='SetId'),
  similarity?: float(name='Similarity'),
}

model CompareImageFacesResponse = {
  headers: map[string]string(name='headers'),
  body: CompareImageFacesResponseBody(name='body'),
}

async function compareImageFaces(request: CompareImageFacesRequest): CompareImageFacesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CompareImageFaces', 'POST', '/', 'json', false, 'json', request);
}

model ConvertOfficeFormatRequest {
  endPage?: long(name='EndPage', position='Query'),
  fitToPagesTall?: boolean(name='FitToPagesTall', position='Query'),
  fitToPagesWide?: boolean(name='FitToPagesWide', position='Query'),
  hidecomments?: boolean(name='Hidecomments', position='Query'),
  maxSheetCol?: long(name='MaxSheetCol', position='Query'),
  maxSheetCount?: long(name='MaxSheetCount', position='Query'),
  maxSheetRow?: long(name='MaxSheetRow', position='Query'),
  modelId?: string(name='ModelId', position='Query'),
  password?: string(name='Password', position='Query'),
  pdfVector?: boolean(name='PdfVector', position='Query'),
  project: string(name='Project', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  sheetOnePage?: boolean(name='SheetOnePage', position='Query'),
  srcType?: string(name='SrcType', position='Query'),
  srcUri: string(name='SrcUri', position='Query'),
  startPage?: long(name='StartPage', position='Query'),
  tgtFilePages?: string(name='TgtFilePages', position='Query'),
  tgtFilePrefix?: string(name='TgtFilePrefix', position='Query'),
  tgtFileSuffix?: string(name='TgtFileSuffix', position='Query'),
  tgtType?: string(name='TgtType', position='Query'),
  tgtUri: string(name='TgtUri', position='Query'),
}

model ConvertOfficeFormatResponseBody = {
  pageCount?: int32(name='PageCount'),
  requestId?: string(name='RequestId'),
}

model ConvertOfficeFormatResponse = {
  headers: map[string]string(name='headers'),
  body: ConvertOfficeFormatResponseBody(name='body'),
}

async function convertOfficeFormat(request: ConvertOfficeFormatRequest): ConvertOfficeFormatResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ConvertOfficeFormat', 'POST', '/', 'json', false, 'json', request);
}

model CreateGrabFrameTaskRequest {
  customMessage?: string(name='CustomMessage', position='Query'),
  notifyEndpoint?: string(name='NotifyEndpoint', position='Query'),
  notifyTopicName?: string(name='NotifyTopicName', position='Query'),
  project: string(name='Project', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  targetList: string(name='TargetList', position='Query'),
  videoUri: string(name='VideoUri', position='Query'),
}

model CreateGrabFrameTaskResponseBody = {
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
  taskType?: string(name='TaskType'),
}

model CreateGrabFrameTaskResponse = {
  headers: map[string]string(name='headers'),
  body: CreateGrabFrameTaskResponseBody(name='body'),
}

async function createGrabFrameTask(request: CreateGrabFrameTaskRequest): CreateGrabFrameTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateGrabFrameTask', 'POST', '/', 'json', false, 'json', request);
}

model CreateGroupFacesJobRequest {
  notifyEndpoint?: string(name='NotifyEndpoint', position='Query'),
  notifyTopicName?: string(name='NotifyTopicName', position='Query'),
  project: string(name='Project', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  setId: string(name='SetId', position='Query'),
}

model CreateGroupFacesJobResponseBody = {
  jobId?: string(name='JobId'),
  jobType?: string(name='JobType'),
  requestId?: string(name='RequestId'),
  setId?: string(name='SetId'),
}

model CreateGroupFacesJobResponse = {
  headers: map[string]string(name='headers'),
  body: CreateGroupFacesJobResponseBody(name='body'),
}

async function createGroupFacesJob(request: CreateGroupFacesJobRequest): CreateGroupFacesJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateGroupFacesJob', 'POST', '/', 'json', false, 'json', request);
}

model CreateMergeFaceGroupsJobRequest {
  customMessage?: string(name='CustomMessage', position='Query'),
  groupIdFrom?: string(name='GroupIdFrom', position='Query'),
  groupIdTo?: string(name='GroupIdTo', position='Query'),
  notifyEndpoint?: string(name='NotifyEndpoint', position='Query'),
  notifyTopicName?: string(name='NotifyTopicName', position='Query'),
  project: string(name='Project', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  setId: string(name='SetId', position='Query'),
}

model CreateMergeFaceGroupsJobResponseBody = {
  groupIdFrom?: string(name='GroupIdFrom'),
  groupIdTo?: string(name='GroupIdTo'),
  jobId?: string(name='JobId'),
  jobType?: string(name='JobType'),
  requestId?: string(name='RequestId'),
  setId?: string(name='SetId'),
}

model CreateMergeFaceGroupsJobResponse = {
  headers: map[string]string(name='headers'),
  body: CreateMergeFaceGroupsJobResponseBody(name='body'),
}

async function createMergeFaceGroupsJob(request: CreateMergeFaceGroupsJobRequest): CreateMergeFaceGroupsJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateMergeFaceGroupsJob', 'POST', '/', 'json', false, 'json', request);
}

model CreateOfficeConversionTaskRequest {
  displayDpi?: int32(name='DisplayDpi', position='Query'),
  endPage?: long(name='EndPage', position='Query'),
  fitToPagesTall?: boolean(name='FitToPagesTall', position='Query'),
  fitToPagesWide?: boolean(name='FitToPagesWide', position='Query'),
  hidecomments?: boolean(name='Hidecomments', position='Query'),
  idempotentToken?: string(name='IdempotentToken', position='Query'),
  maxSheetCol?: long(name='MaxSheetCol', position='Query'),
  maxSheetCount?: long(name='MaxSheetCount', position='Query'),
  maxSheetRow?: long(name='MaxSheetRow', position='Query'),
  modelId?: string(name='ModelId', position='Query'),
  notifyEndpoint?: string(name='NotifyEndpoint', position='Query'),
  notifyTopicName?: string(name='NotifyTopicName', position='Query'),
  password?: string(name='Password', position='Query'),
  pdfVector?: boolean(name='PdfVector', position='Query'),
  project: string(name='Project', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  sheetOnePage?: boolean(name='SheetOnePage', position='Query'),
  srcType?: string(name='SrcType', position='Query'),
  srcUri: string(name='SrcUri', position='Query'),
  startPage?: long(name='StartPage', position='Query'),
  tgtFilePages?: string(name='TgtFilePages', position='Query'),
  tgtFilePrefix?: string(name='TgtFilePrefix', position='Query'),
  tgtFileSuffix?: string(name='TgtFileSuffix', position='Query'),
  tgtType?: string(name='TgtType', position='Query'),
  tgtUri: string(name='TgtUri', position='Query'),
  userData?: string(name='UserData', position='Query'),
}

model CreateOfficeConversionTaskResponseBody = {
  createTime?: string(name='CreateTime'),
  percent?: int32(name='Percent'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
  taskId?: string(name='TaskId'),
  tgtLoc?: string(name='TgtLoc'),
}

model CreateOfficeConversionTaskResponse = {
  headers: map[string]string(name='headers'),
  body: CreateOfficeConversionTaskResponseBody(name='body'),
}

async function createOfficeConversionTask(request: CreateOfficeConversionTaskRequest): CreateOfficeConversionTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateOfficeConversionTask', 'POST', '/', 'json', false, 'json', request);
}

model CreateSetRequest {
  project: string(name='Project', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  setId?: string(name='SetId', position='Query'),
  setName?: string(name='SetName', position='Query'),
}

model CreateSetResponseBody = {
  createTime?: string(name='CreateTime'),
  faceCount?: int32(name='FaceCount'),
  imageCount?: int32(name='ImageCount'),
  modifyTime?: string(name='ModifyTime'),
  requestId?: string(name='RequestId'),
  setId?: string(name='SetId'),
  setName?: string(name='SetName'),
  videoCount?: int32(name='VideoCount'),
  videoLength?: int32(name='VideoLength'),
}

model CreateSetResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSetResponseBody(name='body'),
}

async function createSet(request: CreateSetRequest): CreateSetResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateSet', 'POST', '/', 'json', false, 'json', request);
}

model CreateVideoCompressTaskRequest {
  customMessage?: string(name='CustomMessage', position='Query'),
  notifyEndpoint?: string(name='NotifyEndpoint', position='Query'),
  notifyTopicName?: string(name='NotifyTopicName', position='Query'),
  project: string(name='Project', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  targetList?: string(name='TargetList', position='Query'),
  targetSegment?: string(name='TargetSegment', position='Query'),
  targetSubtitle?: string(name='TargetSubtitle', position='Query'),
  videoUri: string(name='VideoUri', position='Query'),
}

model CreateVideoCompressTaskResponseBody = {
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
  taskType?: string(name='TaskType'),
}

model CreateVideoCompressTaskResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVideoCompressTaskResponseBody(name='body'),
}

async function createVideoCompressTask(request: CreateVideoCompressTaskRequest): CreateVideoCompressTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateVideoCompressTask', 'POST', '/', 'json', false, 'json', request);
}

model DecodeBlindWatermarkRequest {
  imageQuality?: int32(name='ImageQuality', position='Query'),
  imageUri: string(name='ImageUri', position='Query'),
  model?: string(name='Model', position='Query'),
  originalImageUri?: string(name='OriginalImageUri', position='Query'),
  project: string(name='Project', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  targetUri?: string(name='TargetUri', position='Query'),
}

model DecodeBlindWatermarkResponseBody = {
  content?: string(name='Content'),
  requestId?: string(name='RequestId'),
  targetUri?: string(name='TargetUri'),
}

model DecodeBlindWatermarkResponse = {
  headers: map[string]string(name='headers'),
  body: DecodeBlindWatermarkResponseBody(name='body'),
}

async function decodeBlindWatermark(request: DecodeBlindWatermarkRequest): DecodeBlindWatermarkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DecodeBlindWatermark', 'POST', '/', 'json', false, 'json', request);
}

model DeleteImageRequest {
  imageUri: string(name='ImageUri', position='Query'),
  project: string(name='Project', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  setId: string(name='SetId', position='Query'),
}

model DeleteImageResponseBody = {
  imageUri?: string(name='ImageUri'),
  requestId?: string(name='RequestId'),
  setId?: string(name='SetId'),
}

model DeleteImageResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteImageResponseBody(name='body'),
}

async function deleteImage(request: DeleteImageRequest): DeleteImageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteImage', 'POST', '/', 'json', false, 'json', request);
}

model DeleteOfficeConversionTaskRequest {
  project: string(name='Project', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  taskId: string(name='TaskId', position='Query'),
}

model DeleteOfficeConversionTaskResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteOfficeConversionTaskResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteOfficeConversionTaskResponseBody(name='body'),
}

async function deleteOfficeConversionTask(request: DeleteOfficeConversionTaskRequest): DeleteOfficeConversionTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteOfficeConversionTask', 'POST', '/', 'json', false, 'json', request);
}

model DeleteProjectRequest {
  project: string(name='Project', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
}

model DeleteProjectResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteProjectResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteProjectResponseBody(name='body'),
}

async function deleteProject(request: DeleteProjectRequest): DeleteProjectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteProject', 'POST', '/', 'json', false, 'json', request);
}

model DeleteSetRequest {
  project: string(name='Project', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  setId: string(name='SetId', position='Query'),
}

model DeleteSetResponseBody = {
  requestId?: string(name='RequestId'),
  setId?: string(name='SetId'),
}

model DeleteSetResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSetResponseBody(name='body'),
}

async function deleteSet(request: DeleteSetRequest): DeleteSetResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteSet', 'POST', '/', 'json', false, 'json', request);
}

model DeleteVideoRequest {
  project: string(name='Project', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  resources?: boolean(name='Resources', position='Query'),
  setId: string(name='SetId', position='Query'),
  videoUri: string(name='VideoUri', position='Query'),
}

model DeleteVideoResponseBody = {
  requestId?: string(name='RequestId'),
  setId?: string(name='SetId'),
  videoUri?: string(name='VideoUri'),
}

model DeleteVideoResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVideoResponseBody(name='body'),
}

async function deleteVideo(request: DeleteVideoRequest): DeleteVideoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteVideo', 'POST', '/', 'json', false, 'json', request);
}

model DeleteVideoTaskRequest {
  project: string(name='Project', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  taskId?: string(name='TaskId', position='Query'),
  taskType: string(name='TaskType', position='Query'),
}

model DeleteVideoTaskResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVideoTaskResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVideoTaskResponseBody(name='body'),
}

async function deleteVideoTask(request: DeleteVideoTaskRequest): DeleteVideoTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteVideoTask', 'POST', '/', 'json', false, 'json', request);
}

model DetectImageBodiesRequest {
  imageUri: string(name='ImageUri', position='Query'),
  project: string(name='Project', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
}

model DetectImageBodiesResponseBody = {
  bodies?: [ 
    {
      bodyBoundary?: {
        height?: int32(name='Height'),
        left?: int32(name='Left'),
        top?: int32(name='Top'),
        width?: int32(name='Width'),
      }(name='BodyBoundary'),
      bodyConfidence?: float(name='BodyConfidence'),
    }
  ](name='Bodies'),
  imageUri?: string(name='ImageUri'),
  requestId?: string(name='RequestId'),
}

model DetectImageBodiesResponse = {
  headers: map[string]string(name='headers'),
  body: DetectImageBodiesResponseBody(name='body'),
}

async function detectImageBodies(request: DetectImageBodiesRequest): DetectImageBodiesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DetectImageBodies', 'POST', '/', 'json', false, 'json', request);
}

model DetectImageFacesRequest {
  imageUri: string(name='ImageUri', position='Query'),
  project: string(name='Project', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
}

model DetectImageFacesResponseBody = {
  faces?: [ 
    {
      age?: int32(name='Age'),
      ageConfidence?: float(name='AgeConfidence'),
      attractive?: float(name='Attractive'),
      attractiveConfidence?: float(name='AttractiveConfidence'),
      emotion?: string(name='Emotion'),
      emotionConfidence?: float(name='EmotionConfidence'),
      emotionDetails?: {
        ANGRY?: float(name='ANGRY'),
        CALM?: float(name='CALM'),
        DISGUSTED?: float(name='DISGUSTED'),
        HAPPY?: float(name='HAPPY'),
        SAD?: float(name='SAD'),
        SCARED?: float(name='SCARED'),
        SURPRISED?: float(name='SURPRISED'),
      }(name='EmotionDetails'),
      faceAttributes?: {
        beard?: string(name='Beard'),
        beardConfidence?: float(name='BeardConfidence'),
        faceBoundary?: {
          height?: int32(name='Height'),
          left?: int32(name='Left'),
          top?: int32(name='Top'),
          width?: int32(name='Width'),
        }(name='FaceBoundary'),
        glasses?: string(name='Glasses'),
        glassesConfidence?: float(name='GlassesConfidence'),
        headPose?: {
          pitch?: float(name='Pitch'),
          roll?: float(name='Roll'),
          yaw?: float(name='Yaw'),
        }(name='HeadPose'),
        mask?: string(name='Mask'),
        maskConfidence?: float(name='MaskConfidence'),
      }(name='FaceAttributes'),
      faceConfidence?: float(name='FaceConfidence'),
      faceId?: string(name='FaceId'),
      faceQuality?: float(name='FaceQuality'),
      gender?: string(name='Gender'),
      genderConfidence?: float(name='GenderConfidence'),
    }
  ](name='Faces'),
  imageUri?: string(name='ImageUri'),
  requestId?: string(name='RequestId'),
}

model DetectImageFacesResponse = {
  headers: map[string]string(name='headers'),
  body: DetectImageFacesResponseBody(name='body'),
}

async function detectImageFaces(request: DetectImageFacesRequest): DetectImageFacesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DetectImageFaces', 'POST', '/', 'json', false, 'json', request);
}

model DetectImageQRCodesRequest {
  imageUri: string(name='ImageUri', position='Query'),
  project: string(name='Project', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
}

model DetectImageQRCodesResponseBody = {
  imageUri?: string(name='ImageUri'),
  QRCodes?: [ 
    {
      content?: string(name='Content'),
      QRCodeBoundary?: {
        height?: int32(name='Height'),
        left?: int32(name='Left'),
        top?: int32(name='Top'),
        width?: int32(name='Width'),
      }(name='QRCodeBoundary'),
    }
  ](name='QRCodes'),
  requestId?: string(name='RequestId'),
}

model DetectImageQRCodesResponse = {
  headers: map[string]string(name='headers'),
  body: DetectImageQRCodesResponseBody(name='body'),
}

async function detectImageQRCodes(request: DetectImageQRCodesRequest): DetectImageQRCodesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DetectImageQRCodes', 'POST', '/', 'json', false, 'json', request);
}

model DetectImageTagsRequest {
  imageUri: string(name='ImageUri', position='Query'),
  project: string(name='Project', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
}

model DetectImageTagsResponseBody = {
  imageUri?: string(name='ImageUri'),
  requestId?: string(name='RequestId'),
  tags?: [ 
    {
      centricScore?: float(name='CentricScore'),
      parentTagEnName?: string(name='ParentTagEnName'),
      parentTagName?: string(name='ParentTagName'),
      tagConfidence?: float(name='TagConfidence'),
      tagEnName?: string(name='TagEnName'),
      tagLevel?: int32(name='TagLevel'),
      tagName?: string(name='TagName'),
    }
  ](name='Tags'),
}

model DetectImageTagsResponse = {
  headers: map[string]string(name='headers'),
  body: DetectImageTagsResponseBody(name='body'),
}

async function detectImageTags(request: DetectImageTagsRequest): DetectImageTagsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DetectImageTags', 'POST', '/', 'json', false, 'json', request);
}

model DetectQRCodesRequest {
  project: string(name='Project', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  srcUris: string(name='SrcUris', position='Query'),
}

model DetectQRCodesResponseBody = {
  failDetails?: [ 
    {
      errorCode?: string(name='ErrorCode'),
      errorMessage?: string(name='ErrorMessage'),
      srcUri?: string(name='SrcUri'),
    }
  ](name='FailDetails'),
  requestId?: string(name='RequestId'),
  successDetails?: [ 
    {
      QRCodes?: [ 
        {
          content?: string(name='Content'),
          QRCodesRectangle?: {
            height?: string(name='Height'),
            left?: string(name='Left'),
            top?: string(name='Top'),
            width?: string(name='Width'),
          }(name='QRCodesRectangle'),
        }
      ](name='QRCodes'),
      srcUri?: string(name='SrcUri'),
    }
  ](name='SuccessDetails'),
}

model DetectQRCodesResponse = {
  headers: map[string]string(name='headers'),
  body: DetectQRCodesResponseBody(name='body'),
}

async function detectQRCodes(request: DetectQRCodesRequest): DetectQRCodesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DetectQRCodes', 'POST', '/', 'json', false, 'json', request);
}

model EncodeBlindWatermarkRequest {
  content?: string(name='Content', position='Query'),
  imageQuality?: string(name='ImageQuality', position='Query'),
  imageUri: string(name='ImageUri', position='Query'),
  model?: string(name='Model', position='Query'),
  project: string(name='Project', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  targetImageType?: string(name='TargetImageType', position='Query'),
  targetUri: string(name='TargetUri', position='Query'),
  watermarkUri?: string(name='WatermarkUri', position='Query'),
}

model EncodeBlindWatermarkResponseBody = {
  content?: string(name='Content'),
  requestId?: string(name='RequestId'),
  targetUri?: string(name='TargetUri'),
}

model EncodeBlindWatermarkResponse = {
  headers: map[string]string(name='headers'),
  body: EncodeBlindWatermarkResponseBody(name='body'),
}

async function encodeBlindWatermark(request: EncodeBlindWatermarkRequest): EncodeBlindWatermarkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EncodeBlindWatermark', 'POST', '/', 'json', false, 'json', request);
}

model FindImagesRequest {
  addressLineContentsMatch?: string(name='AddressLineContentsMatch', position='Query'),
  ageRange?: string(name='AgeRange', position='Query'),
  createTimeRange?: string(name='CreateTimeRange', position='Query'),
  emotion?: string(name='Emotion', position='Query'),
  externalId?: string(name='ExternalId', position='Query'),
  facesModifyTimeRange?: string(name='FacesModifyTimeRange', position='Query'),
  gender?: string(name='Gender', position='Query'),
  groupId?: string(name='GroupId', position='Query'),
  imageSizeRange?: string(name='ImageSizeRange', position='Query'),
  imageTimeRange?: string(name='ImageTimeRange', position='Query'),
  limit?: int32(name='Limit', position='Query'),
  locationBoundary?: string(name='LocationBoundary', position='Query'),
  marker?: string(name='Marker', position='Query'),
  modifyTimeRange?: string(name='ModifyTimeRange', position='Query'),
  OCRContentsMatch?: string(name='OCRContentsMatch', position='Query'),
  order?: string(name='Order', position='Query'),
  orderBy?: string(name='OrderBy', position='Query'),
  project: string(name='Project', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  remarksAPrefix?: string(name='RemarksAPrefix', position='Query'),
  remarksArrayAIn?: string(name='RemarksArrayAIn', position='Query'),
  remarksArrayBIn?: string(name='RemarksArrayBIn', position='Query'),
  remarksBPrefix?: string(name='RemarksBPrefix', position='Query'),
  remarksCPrefix?: string(name='RemarksCPrefix', position='Query'),
  remarksDPrefix?: string(name='RemarksDPrefix', position='Query'),
  setId: string(name='SetId', position='Query'),
  sourceType?: string(name='SourceType', position='Query'),
  sourceUriPrefix?: string(name='SourceUriPrefix', position='Query'),
  tagNames?: string(name='TagNames', position='Query'),
  tagsModifyTimeRange?: string(name='TagsModifyTimeRange', position='Query'),
}

model FindImagesResponseBody = {
  images?: [ 
    {
      address?: {
        addressLine?: string(name='AddressLine'),
        city?: string(name='City'),
        country?: string(name='Country'),
        district?: string(name='District'),
        province?: string(name='Province'),
        township?: string(name='Township'),
      }(name='Address'),
      addressFailReason?: string(name='AddressFailReason'),
      addressModifyTime?: string(name='AddressModifyTime'),
      addressStatus?: string(name='AddressStatus'),
      createTime?: string(name='CreateTime'),
      croppingSuggestion?: [ 
        {
          aspectRatio?: string(name='AspectRatio'),
          croppingBoundary?: {
            height?: int32(name='Height'),
            left?: int32(name='Left'),
            top?: int32(name='Top'),
            width?: int32(name='Width'),
          }(name='CroppingBoundary'),
          score?: float(name='Score'),
        }
      ](name='CroppingSuggestion'),
      croppingSuggestionFailReason?: string(name='CroppingSuggestionFailReason'),
      croppingSuggestionModifyTime?: string(name='CroppingSuggestionModifyTime'),
      croppingSuggestionStatus?: string(name='CroppingSuggestionStatus'),
      exif?: string(name='Exif'),
      externalId?: string(name='ExternalId'),
      faces?: [ 
        {
          age?: int32(name='Age'),
          attractive?: float(name='Attractive'),
          emotion?: string(name='Emotion'),
          emotionConfidence?: float(name='EmotionConfidence'),
          emotionDetails?: {
            ANGRY?: float(name='ANGRY'),
            CALM?: float(name='CALM'),
            DISGUSTED?: float(name='DISGUSTED'),
            HAPPY?: float(name='HAPPY'),
            SAD?: float(name='SAD'),
            SCARED?: float(name='SCARED'),
            SURPRISED?: float(name='SURPRISED'),
          }(name='EmotionDetails'),
          faceAttributes?: {
            beard?: string(name='Beard'),
            beardConfidence?: float(name='BeardConfidence'),
            faceBoundary?: {
              height?: int32(name='Height'),
              left?: int32(name='Left'),
              top?: int32(name='Top'),
              width?: int32(name='Width'),
            }(name='FaceBoundary'),
            glasses?: string(name='Glasses'),
            glassesConfidence?: float(name='GlassesConfidence'),
            headPose?: {
              pitch?: float(name='Pitch'),
              roll?: float(name='Roll'),
              yaw?: float(name='Yaw'),
            }(name='HeadPose'),
            mask?: string(name='Mask'),
            maskConfidence?: float(name='MaskConfidence'),
          }(name='FaceAttributes'),
          faceConfidence?: float(name='FaceConfidence'),
          faceId?: string(name='FaceId'),
          faceQuality?: float(name='FaceQuality'),
          gender?: string(name='Gender'),
          genderConfidence?: float(name='GenderConfidence'),
          groupId?: string(name='GroupId'),
        }
      ](name='Faces'),
      facesFailReason?: string(name='FacesFailReason'),
      facesModifyTime?: string(name='FacesModifyTime'),
      facesStatus?: string(name='FacesStatus'),
      fileSize?: int32(name='FileSize'),
      imageFormat?: string(name='ImageFormat'),
      imageHeight?: int32(name='ImageHeight'),
      imageQuality?: {
        clarity?: float(name='Clarity'),
        clarityScore?: float(name='ClarityScore'),
        color?: float(name='Color'),
        colorScore?: float(name='ColorScore'),
        compositionScore?: float(name='CompositionScore'),
        contrast?: float(name='Contrast'),
        contrastScore?: float(name='ContrastScore'),
        exposure?: float(name='Exposure'),
        exposureScore?: float(name='ExposureScore'),
        overallScore?: float(name='OverallScore'),
      }(name='ImageQuality'),
      imageQualityFailReason?: string(name='ImageQualityFailReason'),
      imageQualityModifyTime?: string(name='ImageQualityModifyTime'),
      imageQualityStatus?: string(name='ImageQualityStatus'),
      imageTime?: string(name='ImageTime'),
      imageUri?: string(name='ImageUri'),
      imageWidth?: int32(name='ImageWidth'),
      location?: string(name='Location'),
      modifyTime?: string(name='ModifyTime'),
      OCR?: [ 
        {
          OCRBoundary?: {
            height?: int32(name='Height'),
            left?: int32(name='Left'),
            top?: int32(name='Top'),
            width?: int32(name='Width'),
          }(name='OCRBoundary'),
          OCRConfidence?: float(name='OCRConfidence'),
          OCRContents?: string(name='OCRContents'),
        }
      ](name='OCR'),
      OCRFailReason?: string(name='OCRFailReason'),
      OCRModifyTime?: string(name='OCRModifyTime'),
      OCRStatus?: string(name='OCRStatus'),
      orientation?: string(name='Orientation'),
      remarksA?: string(name='RemarksA'),
      remarksArrayA?: string(name='RemarksArrayA'),
      remarksArrayB?: string(name='RemarksArrayB'),
      remarksB?: string(name='RemarksB'),
      remarksC?: string(name='RemarksC'),
      remarksD?: string(name='RemarksD'),
      sourcePosition?: string(name='SourcePosition'),
      sourceType?: string(name='SourceType'),
      sourceUri?: string(name='SourceUri'),
      tags?: [ 
        {
          centricScore?: float(name='CentricScore'),
          parentTagName?: string(name='ParentTagName'),
          tagConfidence?: float(name='TagConfidence'),
          tagLevel?: int32(name='TagLevel'),
          tagName?: string(name='TagName'),
        }
      ](name='Tags'),
      tagsFailReason?: string(name='TagsFailReason'),
      tagsModifyTime?: string(name='TagsModifyTime'),
      tagsStatus?: string(name='TagsStatus'),
    }
  ](name='Images'),
  nextMarker?: string(name='NextMarker'),
  requestId?: string(name='RequestId'),
  setId?: string(name='SetId'),
}

model FindImagesResponse = {
  headers: map[string]string(name='headers'),
  body: FindImagesResponseBody(name='body'),
}

async function findImages(request: FindImagesRequest): FindImagesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'FindImages', 'POST', '/', 'json', false, 'json', request);
}

model FindSimilarFacesRequest {
  faceId?: string(name='FaceId', position='Query'),
  imageUri?: string(name='ImageUri', position='Query'),
  limit?: int32(name='Limit', position='Query'),
  minSimilarity?: float(name='MinSimilarity', position='Query'),
  project: string(name='Project', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  responseFormat?: string(name='ResponseFormat', position='Query'),
  setId: string(name='SetId', position='Query'),
}

model FindSimilarFacesResponseBody = {
  faces?: [ 
    {
      externalId?: string(name='ExternalId'),
      faceAttributes?: {
        faceBoundary?: {
          height?: int32(name='Height'),
          left?: int32(name='Left'),
          top?: int32(name='Top'),
          width?: int32(name='Width'),
        }(name='FaceBoundary'),
      }(name='FaceAttributes'),
      faceId?: string(name='FaceId'),
      imageUri?: string(name='ImageUri'),
      similarFaces?: [ 
        {
          externalId?: string(name='ExternalId'),
          faceAttributes?: {
            faceBoundary?: {
              height?: int32(name='Height'),
              left?: int32(name='Left'),
              top?: int32(name='Top'),
              width?: int32(name='Width'),
            }(name='FaceBoundary'),
          }(name='FaceAttributes'),
          faceId?: string(name='FaceId'),
          imageUri?: string(name='ImageUri'),
          similarity?: float(name='Similarity'),
        }
      ](name='SimilarFaces'),
      similarity?: float(name='Similarity'),
    }
  ](name='Faces'),
  requestId?: string(name='RequestId'),
}

model FindSimilarFacesResponse = {
  headers: map[string]string(name='headers'),
  body: FindSimilarFacesResponseBody(name='body'),
}

async function findSimilarFaces(request: FindSimilarFacesRequest): FindSimilarFacesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'FindSimilarFaces', 'POST', '/', 'json', false, 'json', request);
}

model GetImageRequest {
  imageUri: string(name='ImageUri', position='Query'),
  project: string(name='Project', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  setId: string(name='SetId', position='Query'),
}

model GetImageResponseBody = {
  address?: {
    addressLine?: string(name='AddressLine'),
    city?: string(name='City'),
    country?: string(name='Country'),
    district?: string(name='District'),
    province?: string(name='Province'),
    township?: string(name='Township'),
  }(name='Address'),
  addressFailReason?: string(name='AddressFailReason'),
  addressModifyTime?: string(name='AddressModifyTime'),
  addressStatus?: string(name='AddressStatus'),
  createTime?: string(name='CreateTime'),
  croppingSuggestion?: [ 
    {
      aspectRatio?: string(name='AspectRatio'),
      croppingBoundary?: {
        height?: int32(name='Height'),
        left?: int32(name='Left'),
        top?: int32(name='Top'),
        width?: int32(name='Width'),
      }(name='CroppingBoundary'),
      score?: float(name='Score'),
    }
  ](name='CroppingSuggestion'),
  croppingSuggestionFailReason?: string(name='CroppingSuggestionFailReason'),
  croppingSuggestionModifyTime?: string(name='CroppingSuggestionModifyTime'),
  croppingSuggestionStatus?: string(name='CroppingSuggestionStatus'),
  exif?: string(name='Exif'),
  externalId?: string(name='ExternalId'),
  faces?: [ 
    {
      age?: string(name='Age'),
      attractive?: float(name='Attractive'),
      emotion?: string(name='Emotion'),
      emotionConfidence?: float(name='EmotionConfidence'),
      emotionDetails?: {
        ANGRY?: float(name='ANGRY'),
        CALM?: float(name='CALM'),
        DISGUSTED?: float(name='DISGUSTED'),
        HAPPY?: float(name='HAPPY'),
        SAD?: float(name='SAD'),
        SCARED?: float(name='SCARED'),
        SURPRISED?: float(name='SURPRISED'),
      }(name='EmotionDetails'),
      faceAttributes?: {
        beard?: string(name='Beard'),
        beardConfidence?: float(name='BeardConfidence'),
        faceBoundary?: {
          height?: int32(name='Height'),
          left?: int32(name='Left'),
          top?: int32(name='Top'),
          width?: int32(name='Width'),
        }(name='FaceBoundary'),
        glasses?: string(name='Glasses'),
        glassesConfidence?: float(name='GlassesConfidence'),
        headPose?: {
          pitch?: float(name='Pitch'),
          roll?: float(name='Roll'),
          yaw?: float(name='Yaw'),
        }(name='HeadPose'),
        mask?: string(name='Mask'),
        maskConfidence?: float(name='MaskConfidence'),
      }(name='FaceAttributes'),
      faceConfidence?: float(name='FaceConfidence'),
      faceId?: string(name='FaceId'),
      faceQuality?: float(name='FaceQuality'),
      gender?: string(name='Gender'),
      genderConfidence?: float(name='GenderConfidence'),
      groupId?: string(name='GroupId'),
    }
  ](name='Faces'),
  facesFailReason?: string(name='FacesFailReason'),
  facesModifyTime?: string(name='FacesModifyTime'),
  facesStatus?: string(name='FacesStatus'),
  fileSize?: int32(name='FileSize'),
  imageFormat?: string(name='ImageFormat'),
  imageHeight?: int32(name='ImageHeight'),
  imageQuality?: {
    clarity?: float(name='Clarity'),
    clarityScore?: float(name='ClarityScore'),
    color?: float(name='Color'),
    colorScore?: float(name='ColorScore'),
    compositionScore?: float(name='CompositionScore'),
    contrast?: float(name='Contrast'),
    contrastScore?: float(name='ContrastScore'),
    exposure?: float(name='Exposure'),
    exposureScore?: float(name='ExposureScore'),
    overallScore?: float(name='OverallScore'),
  }(name='ImageQuality'),
  imageQualityFailReason?: string(name='ImageQualityFailReason'),
  imageQualityModifyTime?: string(name='ImageQualityModifyTime'),
  imageQualityStatus?: string(name='ImageQualityStatus'),
  imageTime?: string(name='ImageTime'),
  imageUri?: string(name='ImageUri'),
  imageWidth?: int32(name='ImageWidth'),
  location?: string(name='Location'),
  modifyTime?: string(name='ModifyTime'),
  OCR?: [ 
    {
      OCRBoundary?: {
        height?: int32(name='Height'),
        left?: int32(name='Left'),
        top?: int32(name='Top'),
        width?: int32(name='Width'),
      }(name='OCRBoundary'),
      OCRConfidence?: float(name='OCRConfidence'),
      OCRContents?: string(name='OCRContents'),
    }
  ](name='OCR'),
  OCRFailReason?: string(name='OCRFailReason'),
  OCRModifyTime?: string(name='OCRModifyTime'),
  OCRStatus?: string(name='OCRStatus'),
  orientation?: string(name='Orientation'),
  remarksA?: string(name='RemarksA'),
  remarksArrayA?: string(name='RemarksArrayA'),
  remarksArrayB?: string(name='RemarksArrayB'),
  remarksB?: string(name='RemarksB'),
  remarksC?: string(name='RemarksC'),
  remarksD?: string(name='RemarksD'),
  requestId?: string(name='RequestId'),
  setId?: string(name='SetId'),
  sourcePosition?: string(name='SourcePosition'),
  sourceType?: string(name='SourceType'),
  sourceUri?: string(name='SourceUri'),
  tags?: [ 
    {
      centricScore?: float(name='CentricScore'),
      parentTagName?: string(name='ParentTagName'),
      tagConfidence?: float(name='TagConfidence'),
      tagLevel?: int32(name='TagLevel'),
      tagName?: string(name='TagName'),
    }
  ](name='Tags'),
  tagsFailReason?: string(name='TagsFailReason'),
  tagsModifyTime?: string(name='TagsModifyTime'),
  tagsStatus?: string(name='TagsStatus'),
}

model GetImageResponse = {
  headers: map[string]string(name='headers'),
  body: GetImageResponseBody(name='body'),
}

async function getImage(request: GetImageRequest): GetImageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetImage', 'POST', '/', 'json', false, 'json', request);
}

model GetImageCroppingSuggestionsRequest {
  aspectRatios: string(name='AspectRatios', position='Query'),
  imageUri: string(name='ImageUri', position='Query'),
  project: string(name='Project', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
}

model GetImageCroppingSuggestionsResponseBody = {
  croppingSuggestions?: [ 
    {
      aspectRatio?: string(name='AspectRatio'),
      croppingBoundary?: {
        height?: int32(name='Height'),
        left?: int32(name='Left'),
        top?: int32(name='Top'),
        width?: int32(name='Width'),
      }(name='CroppingBoundary'),
      score?: float(name='Score'),
    }
  ](name='CroppingSuggestions'),
  imageUri?: string(name='ImageUri'),
  requestId?: string(name='RequestId'),
}

model GetImageCroppingSuggestionsResponse = {
  headers: map[string]string(name='headers'),
  body: GetImageCroppingSuggestionsResponseBody(name='body'),
}

async function getImageCroppingSuggestions(request: GetImageCroppingSuggestionsRequest): GetImageCroppingSuggestionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetImageCroppingSuggestions', 'POST', '/', 'json', false, 'json', request);
}

model GetImageQualityRequest {
  imageUri: string(name='ImageUri', position='Query'),
  project: string(name='Project', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
}

model GetImageQualityResponseBody = {
  imageQuality?: {
    clarity?: float(name='Clarity'),
    clarityScore?: float(name='ClarityScore'),
    color?: float(name='Color'),
    colorScore?: float(name='ColorScore'),
    compositionScore?: float(name='CompositionScore'),
    contrast?: float(name='Contrast'),
    contrastScore?: float(name='ContrastScore'),
    exposure?: float(name='Exposure'),
    exposureScore?: float(name='ExposureScore'),
    overallScore?: float(name='OverallScore'),
  }(name='ImageQuality'),
  imageUri?: string(name='ImageUri'),
  requestId?: string(name='RequestId'),
}

model GetImageQualityResponse = {
  headers: map[string]string(name='headers'),
  body: GetImageQualityResponseBody(name='body'),
}

async function getImageQuality(request: GetImageQualityRequest): GetImageQualityResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetImageQuality', 'POST', '/', 'json', false, 'json', request);
}

model GetMediaMetaRequest {
  mediaUri: string(name='MediaUri', position='Query'),
  project: string(name='Project', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
}

model GetMediaMetaResponseBody = {
  mediaMeta?: {
    mediaFormat?: {
      address?: {
        addressLine?: string(name='AddressLine'),
        city?: string(name='City'),
        country?: string(name='Country'),
        district?: string(name='District'),
        province?: string(name='Province'),
        township?: string(name='Township'),
      }(name='Address'),
      bitrate?: string(name='Bitrate'),
      creationTime?: string(name='CreationTime'),
      duration?: string(name='Duration'),
      formatLongName?: string(name='FormatLongName'),
      formatName?: string(name='FormatName'),
      location?: string(name='Location'),
      numberPrograms?: int32(name='NumberPrograms'),
      numberStreams?: int32(name='NumberStreams'),
      size?: string(name='Size'),
      startTime?: string(name='StartTime'),
      tag?: {
        album?: string(name='Album'),
        albumArtist?: string(name='AlbumArtist'),
        artist?: string(name='Artist'),
        composer?: string(name='Composer'),
        creationTime?: string(name='CreationTime'),
        language?: string(name='Language'),
        performer?: string(name='Performer'),
        title?: string(name='Title'),
      }(name='Tag'),
    }(name='MediaFormat'),
    mediaStreams?: {
      audioStreams?: [ 
        {
          bitrate?: string(name='Bitrate'),
          channelLayout?: string(name='ChannelLayout'),
          channels?: int32(name='Channels'),
          codecLongName?: string(name='CodecLongName'),
          codecName?: string(name='CodecName'),
          codecTag?: string(name='CodecTag'),
          codecTagString?: string(name='CodecTagString'),
          codecTimeBase?: string(name='CodecTimeBase'),
          duration?: string(name='Duration'),
          frames?: string(name='Frames'),
          index?: int32(name='Index'),
          language?: string(name='Language'),
          sampleFormat?: string(name='SampleFormat'),
          sampleRate?: string(name='SampleRate'),
          startTime?: string(name='StartTime'),
          timeBase?: string(name='TimeBase'),
        }
      ](name='AudioStreams'),
      subtitleStreams?: [ 
        {
          index?: int32(name='Index'),
          language?: string(name='Language'),
        }
      ](name='SubtitleStreams'),
      videoStreams?: [ 
        {
          averageFrameRate?: string(name='AverageFrameRate'),
          bitrate?: string(name='Bitrate'),
          codecLongName?: string(name='CodecLongName'),
          codecName?: string(name='CodecName'),
          codecTag?: string(name='CodecTag'),
          codecTagString?: string(name='CodecTagString'),
          codecTimeBase?: string(name='CodecTimeBase'),
          displayAspectRatio?: string(name='DisplayAspectRatio'),
          duration?: string(name='Duration'),
          frameRrate?: string(name='FrameRrate'),
          frames?: string(name='Frames'),
          hasBFrames?: int32(name='HasBFrames'),
          height?: int32(name='Height'),
          index?: int32(name='Index'),
          language?: string(name='Language'),
          level?: int32(name='Level'),
          pixelFormat?: string(name='PixelFormat'),
          profile?: string(name='Profile'),
          rotate?: string(name='Rotate'),
          sampleAspectRatio?: string(name='SampleAspectRatio'),
          startTime?: string(name='StartTime'),
          timeBase?: string(name='TimeBase'),
          width?: int32(name='Width'),
        }
      ](name='VideoStreams'),
    }(name='MediaStreams'),
  }(name='MediaMeta'),
  mediaUri?: string(name='MediaUri'),
  requestId?: string(name='RequestId'),
}

model GetMediaMetaResponse = {
  headers: map[string]string(name='headers'),
  body: GetMediaMetaResponseBody(name='body'),
}

async function getMediaMeta(request: GetMediaMetaRequest): GetMediaMetaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMediaMeta', 'POST', '/', 'json', false, 'json', request);
}

model GetOfficeConversionTaskRequest {
  project: string(name='Project', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  taskId: string(name='TaskId', position='Query'),
}

model GetOfficeConversionTaskResponseBody = {
  createTime?: string(name='CreateTime'),
  externalID?: string(name='ExternalID'),
  failDetail?: {
    code?: string(name='Code'),
  }(name='FailDetail'),
  finishTime?: string(name='FinishTime'),
  imageSpec?: string(name='ImageSpec'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
  notifyTopicName?: string(name='NotifyTopicName'),
  pageCount?: int32(name='PageCount'),
  percent?: int32(name='Percent'),
  requestId?: string(name='RequestId'),
  srcUri?: string(name='SrcUri'),
  status?: string(name='Status'),
  taskId?: string(name='TaskId'),
  tgtType?: string(name='TgtType'),
  tgtUri?: string(name='TgtUri'),
}

model GetOfficeConversionTaskResponse = {
  headers: map[string]string(name='headers'),
  body: GetOfficeConversionTaskResponseBody(name='body'),
}

async function getOfficeConversionTask(request: GetOfficeConversionTaskRequest): GetOfficeConversionTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetOfficeConversionTask', 'POST', '/', 'json', false, 'json', request);
}

model GetOfficePreviewURLRequest {
  project: string(name='Project', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  srcType?: string(name='SrcType', position='Query'),
  srcUri: string(name='SrcUri', position='Query'),
  watermarkFillStyle?: string(name='WatermarkFillStyle', position='Query'),
  watermarkFont?: string(name='WatermarkFont', position='Query'),
  watermarkHorizontal?: int32(name='WatermarkHorizontal', position='Query'),
  watermarkRotate?: float(name='WatermarkRotate', position='Query'),
  watermarkType?: int32(name='WatermarkType', position='Query'),
  watermarkValue?: string(name='WatermarkValue', position='Query'),
  watermarkVertical?: int32(name='WatermarkVertical', position='Query'),
}

model GetOfficePreviewURLResponseBody = {
  accessToken?: string(name='AccessToken'),
  accessTokenExpiredTime?: string(name='AccessTokenExpiredTime'),
  previewURL?: string(name='PreviewURL'),
  refreshToken?: string(name='RefreshToken'),
  refreshTokenExpiredTime?: string(name='RefreshTokenExpiredTime'),
  requestId?: string(name='RequestId'),
}

model GetOfficePreviewURLResponse = {
  headers: map[string]string(name='headers'),
  body: GetOfficePreviewURLResponseBody(name='body'),
}

async function getOfficePreviewURL(request: GetOfficePreviewURLRequest): GetOfficePreviewURLResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetOfficePreviewURL', 'POST', '/', 'json', false, 'json', request);
}

model GetProjectRequest {
  project: string(name='Project', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
}

model GetProjectResponseBody = {
  billingType?: string(name='BillingType'),
  CU?: int32(name='CU'),
  createTime?: string(name='CreateTime'),
  endpoint?: string(name='Endpoint'),
  modifyTime?: string(name='ModifyTime'),
  project?: string(name='Project'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  serviceRole?: string(name='ServiceRole'),
  type?: string(name='Type'),
}

model GetProjectResponse = {
  headers: map[string]string(name='headers'),
  body: GetProjectResponseBody(name='body'),
}

async function getProject(request: GetProjectRequest): GetProjectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetProject', 'POST', '/', 'json', false, 'json', request);
}

model GetSetRequest {
  project: string(name='Project', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  setId: string(name='SetId', position='Query'),
}

model GetSetResponseBody = {
  createTime?: string(name='CreateTime'),
  faceCount?: int32(name='FaceCount'),
  imageCount?: int32(name='ImageCount'),
  modifyTime?: string(name='ModifyTime'),
  requestId?: string(name='RequestId'),
  setId?: string(name='SetId'),
  setName?: string(name='SetName'),
  videoCount?: int32(name='VideoCount'),
  videoLength?: int32(name='VideoLength'),
}

model GetSetResponse = {
  headers: map[string]string(name='headers'),
  body: GetSetResponseBody(name='body'),
}

async function getSet(request: GetSetRequest): GetSetResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetSet', 'POST', '/', 'json', false, 'json', request);
}

model GetVideoRequest {
  project: string(name='Project', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  setId: string(name='SetId', position='Query'),
  videoUri: string(name='VideoUri', position='Query'),
}

model GetVideoResponseBody = {
  createTime?: string(name='CreateTime'),
  externalId?: string(name='ExternalId'),
  fileSize?: int32(name='FileSize'),
  modifyTime?: string(name='ModifyTime'),
  processFailReason?: string(name='ProcessFailReason'),
  processModifyTime?: string(name='ProcessModifyTime'),
  processStatus?: string(name='ProcessStatus'),
  remarksA?: string(name='RemarksA'),
  remarksB?: string(name='RemarksB'),
  remarksC?: string(name='RemarksC'),
  remarksD?: string(name='RemarksD'),
  requestId?: string(name='RequestId'),
  setId?: string(name='SetId'),
  sourcePosition?: string(name='SourcePosition'),
  sourceType?: string(name='SourceType'),
  sourceUri?: string(name='SourceUri'),
  videoDuration?: float(name='VideoDuration'),
  videoFacesFailReason?: string(name='VideoFacesFailReason'),
  videoFacesModifyTime?: string(name='VideoFacesModifyTime'),
  videoFacesStatus?: string(name='VideoFacesStatus'),
  videoFormat?: string(name='VideoFormat'),
  videoFrameTagsFailReason?: string(name='VideoFrameTagsFailReason'),
  videoFrameTagsModifyTime?: string(name='VideoFrameTagsModifyTime'),
  videoFrameTagsStatus?: string(name='VideoFrameTagsStatus'),
  videoFrames?: int32(name='VideoFrames'),
  videoHeight?: int32(name='VideoHeight'),
  videoInfo?: string(name='VideoInfo'),
  videoOCRFailReason?: string(name='VideoOCRFailReason'),
  videoOCRModifyTime?: string(name='VideoOCRModifyTime'),
  videoOCRStatus?: string(name='VideoOCRStatus'),
  videoSTTFailReason?: string(name='VideoSTTFailReason'),
  videoSTTModifyTime?: string(name='VideoSTTModifyTime'),
  videoSTTStatus?: string(name='VideoSTTStatus'),
  videoTags?: [ 
    {
      parentTagName?: string(name='ParentTagName'),
      tagConfidence?: float(name='TagConfidence'),
      tagLevel?: int32(name='TagLevel'),
      tagName?: string(name='TagName'),
    }
  ](name='VideoTags'),
  videoTagsFailReason?: string(name='VideoTagsFailReason'),
  videoTagsModifyTime?: string(name='VideoTagsModifyTime'),
  videoTagsStatus?: string(name='VideoTagsStatus'),
  videoUri?: string(name='VideoUri'),
  videoWidth?: int32(name='VideoWidth'),
}

model GetVideoResponse = {
  headers: map[string]string(name='headers'),
  body: GetVideoResponseBody(name='body'),
}

async function getVideo(request: GetVideoRequest): GetVideoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetVideo', 'POST', '/', 'json', false, 'json', request);
}

model GetVideoTaskRequest {
  project: string(name='Project', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  taskId?: string(name='TaskId', position='Query'),
  taskType: string(name='TaskType', position='Query'),
}

model GetVideoTaskResponseBody = {
  endTime?: string(name='EndTime'),
  errorMessage?: string(name='ErrorMessage'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
  notifyTopicName?: string(name='NotifyTopicName'),
  parameters?: string(name='Parameters'),
  progress?: int32(name='Progress'),
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
  startTime?: string(name='StartTime'),
  status?: string(name='Status'),
  taskId?: string(name='TaskId'),
  taskType?: string(name='TaskType'),
}

model GetVideoTaskResponse = {
  headers: map[string]string(name='headers'),
  body: GetVideoTaskResponseBody(name='body'),
}

async function getVideoTask(request: GetVideoTaskRequest): GetVideoTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetVideoTask', 'POST', '/', 'json', false, 'json', request);
}

model GetWebofficeURLRequest {
  file: string(name='File', position='Query'),
  fileID: string(name='FileID', position='Query'),
  hidecmb?: boolean(name='Hidecmb', position='Query'),
  notifyEndpoint?: string(name='NotifyEndpoint', position='Query'),
  notifyTopicName?: string(name='NotifyTopicName', position='Query'),
  permission: string(name='Permission', position='Query'),
  project: string(name='Project', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  srcType?: string(name='SrcType', position='Query'),
  user: string(name='User', position='Query'),
  watermark?: string(name='Watermark', position='Query'),
}

model GetWebofficeURLResponseBody = {
  accessToken?: string(name='AccessToken'),
  accessTokenExpiredTime?: string(name='AccessTokenExpiredTime'),
  refreshToken?: string(name='RefreshToken'),
  refreshTokenExpiredTime?: string(name='RefreshTokenExpiredTime'),
  requestId?: string(name='RequestId'),
  webofficeURL?: string(name='WebofficeURL'),
}

model GetWebofficeURLResponse = {
  headers: map[string]string(name='headers'),
  body: GetWebofficeURLResponseBody(name='body'),
}

async function getWebofficeURL(request: GetWebofficeURLRequest): GetWebofficeURLResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetWebofficeURL', 'POST', '/', 'json', false, 'json', request);
}

model IndexImageRequest {
  externalId?: string(name='ExternalId', position='Query'),
  imageUri: string(name='ImageUri', position='Query'),
  notifyEndpoint?: string(name='NotifyEndpoint', position='Query'),
  notifyTopicName?: string(name='NotifyTopicName', position='Query'),
  project: string(name='Project', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  remarksA?: string(name='RemarksA', position='Query'),
  remarksArrayA?: string(name='RemarksArrayA', position='Query'),
  remarksArrayB?: string(name='RemarksArrayB', position='Query'),
  remarksB?: string(name='RemarksB', position='Query'),
  remarksC?: string(name='RemarksC', position='Query'),
  remarksD?: string(name='RemarksD', position='Query'),
  setId: string(name='SetId', position='Query'),
  sourcePosition?: string(name='SourcePosition', position='Query'),
  sourceType?: string(name='SourceType', position='Query'),
  sourceUri?: string(name='SourceUri', position='Query'),
}

model IndexImageResponseBody = {
  createTime?: string(name='CreateTime'),
  externalId?: string(name='ExternalId'),
  imageUri?: string(name='ImageUri'),
  modifyTime?: string(name='ModifyTime'),
  remarksA?: string(name='RemarksA'),
  remarksArrayA?: string(name='RemarksArrayA'),
  remarksArrayB?: string(name='RemarksArrayB'),
  remarksB?: string(name='RemarksB'),
  remarksC?: string(name='RemarksC'),
  remarksD?: string(name='RemarksD'),
  requestId?: string(name='RequestId'),
  setId?: string(name='SetId'),
}

model IndexImageResponse = {
  headers: map[string]string(name='headers'),
  body: IndexImageResponseBody(name='body'),
}

async function indexImage(request: IndexImageRequest): IndexImageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'IndexImage', 'POST', '/', 'json', false, 'json', request);
}

model IndexVideoRequest {
  externalId?: string(name='ExternalId', position='Query'),
  notifyEndpoint?: string(name='NotifyEndpoint', position='Query'),
  notifyTopicName?: string(name='NotifyTopicName', position='Query'),
  project: string(name='Project', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  remarksA?: string(name='RemarksA', position='Query'),
  remarksB?: string(name='RemarksB', position='Query'),
  remarksC?: string(name='RemarksC', position='Query'),
  remarksD?: string(name='RemarksD', position='Query'),
  setId: string(name='SetId', position='Query'),
  tgtUri?: string(name='TgtUri', position='Query'),
  videoUri: string(name='VideoUri', position='Query'),
}

model IndexVideoResponseBody = {
  createTime?: string(name='CreateTime'),
  externalId?: string(name='ExternalId'),
  modifyTime?: string(name='ModifyTime'),
  remarksA?: string(name='RemarksA'),
  remarksB?: string(name='RemarksB'),
  remarksC?: string(name='RemarksC'),
  remarksD?: string(name='RemarksD'),
  requestId?: string(name='RequestId'),
  setId?: string(name='SetId'),
  videoUri?: string(name='VideoUri'),
}

model IndexVideoResponse = {
  headers: map[string]string(name='headers'),
  body: IndexVideoResponseBody(name='body'),
}

async function indexVideo(request: IndexVideoRequest): IndexVideoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'IndexVideo', 'POST', '/', 'json', false, 'json', request);
}

model ListFaceGroupsRequest {
  externalId?: string(name='ExternalId', position='Query'),
  limit?: int32(name='Limit', position='Query'),
  marker?: string(name='Marker', position='Query'),
  order?: string(name='Order', position='Query'),
  orderBy?: string(name='OrderBy', position='Query'),
  project: string(name='Project', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  remarksAQuery?: string(name='RemarksAQuery', position='Query'),
  remarksArrayAQuery?: string(name='RemarksArrayAQuery', position='Query'),
  remarksArrayBQuery?: string(name='RemarksArrayBQuery', position='Query'),
  remarksBQuery?: string(name='RemarksBQuery', position='Query'),
  remarksCQuery?: string(name='RemarksCQuery', position='Query'),
  remarksDQuery?: string(name='RemarksDQuery', position='Query'),
  setId: string(name='SetId', position='Query'),
}

model ListFaceGroupsResponseBody = {
  faceGroups?: [ 
    {
      averageAge?: float(name='AverageAge'),
      createTime?: string(name='CreateTime'),
      externalId?: string(name='ExternalId'),
      faceCount?: int32(name='FaceCount'),
      gender?: string(name='Gender'),
      groupCoverFace?: {
        externalId?: string(name='ExternalId'),
        faceBoundary?: {
          height?: int32(name='Height'),
          left?: int32(name='Left'),
          top?: int32(name='Top'),
          width?: int32(name='Width'),
        }(name='FaceBoundary'),
        faceId?: string(name='FaceId'),
        imageHeight?: long(name='ImageHeight'),
        imageUri?: string(name='ImageUri'),
        imageWidth?: long(name='ImageWidth'),
      }(name='GroupCoverFace'),
      groupId?: string(name='GroupId'),
      groupName?: string(name='GroupName'),
      imageCount?: int32(name='ImageCount'),
      maxAge?: float(name='MaxAge'),
      minAge?: float(name='MinAge'),
      modifyTime?: string(name='ModifyTime'),
      remarksA?: string(name='RemarksA'),
      remarksArrayA?: string(name='RemarksArrayA'),
      remarksArrayB?: string(name='RemarksArrayB'),
      remarksB?: string(name='RemarksB'),
      remarksC?: string(name='RemarksC'),
      remarksD?: string(name='RemarksD'),
    }
  ](name='FaceGroups'),
  nextMarker?: string(name='NextMarker'),
  requestId?: string(name='RequestId'),
}

model ListFaceGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: ListFaceGroupsResponseBody(name='body'),
}

async function listFaceGroups(request: ListFaceGroupsRequest): ListFaceGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListFaceGroups', 'POST', '/', 'json', false, 'json', request);
}

model ListImagesRequest {
  createTimeStart?: string(name='CreateTimeStart', position='Query'),
  limit?: int32(name='Limit', position='Query'),
  marker?: string(name='Marker', position='Query'),
  project: string(name='Project', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  setId: string(name='SetId', position='Query'),
}

model ListImagesResponseBody = {
  images?: [ 
    {
      address?: {
        addressLine?: string(name='AddressLine'),
        city?: string(name='City'),
        country?: string(name='Country'),
        district?: string(name='District'),
        province?: string(name='Province'),
        township?: string(name='Township'),
      }(name='Address'),
      addressFailReason?: string(name='AddressFailReason'),
      addressModifyTime?: string(name='AddressModifyTime'),
      addressStatus?: string(name='AddressStatus'),
      createTime?: string(name='CreateTime'),
      croppingSuggestion?: [ 
        {
          aspectRatio?: string(name='AspectRatio'),
          croppingBoundary?: {
            height?: int32(name='Height'),
            left?: int32(name='Left'),
            top?: int32(name='Top'),
            width?: int32(name='Width'),
          }(name='CroppingBoundary'),
          score?: float(name='Score'),
        }
      ](name='CroppingSuggestion'),
      croppingSuggestionFailReason?: string(name='CroppingSuggestionFailReason'),
      croppingSuggestionModifyTime?: string(name='CroppingSuggestionModifyTime'),
      croppingSuggestionStatus?: string(name='CroppingSuggestionStatus'),
      exif?: string(name='Exif'),
      externalId?: string(name='ExternalId'),
      faces?: [ 
        {
          age?: int32(name='Age'),
          attractive?: float(name='Attractive'),
          emotion?: string(name='Emotion'),
          emotionConfidence?: float(name='EmotionConfidence'),
          emotionDetails?: {
            ANGRY?: float(name='ANGRY'),
            CALM?: float(name='CALM'),
            DISGUSTED?: float(name='DISGUSTED'),
            HAPPY?: float(name='HAPPY'),
            SAD?: float(name='SAD'),
            SCARED?: float(name='SCARED'),
            SURPRISED?: float(name='SURPRISED'),
          }(name='EmotionDetails'),
          faceAttributes?: {
            beard?: string(name='Beard'),
            beardConfidence?: float(name='BeardConfidence'),
            faceBoundary?: {
              height?: int32(name='Height'),
              left?: int32(name='Left'),
              top?: int32(name='Top'),
              width?: int32(name='Width'),
            }(name='FaceBoundary'),
            glasses?: string(name='Glasses'),
            glassesConfidence?: float(name='GlassesConfidence'),
            headPose?: {
              pitch?: float(name='Pitch'),
              roll?: float(name='Roll'),
              yaw?: float(name='Yaw'),
            }(name='HeadPose'),
            mask?: string(name='Mask'),
            maskConfidence?: float(name='MaskConfidence'),
          }(name='FaceAttributes'),
          faceConfidence?: float(name='FaceConfidence'),
          faceId?: string(name='FaceId'),
          faceQuality?: float(name='FaceQuality'),
          gender?: string(name='Gender'),
          genderConfidence?: float(name='GenderConfidence'),
          groupId?: string(name='GroupId'),
        }
      ](name='Faces'),
      facesFailReason?: string(name='FacesFailReason'),
      facesModifyTime?: string(name='FacesModifyTime'),
      facesStatus?: string(name='FacesStatus'),
      fileSize?: int32(name='FileSize'),
      imageFormat?: string(name='ImageFormat'),
      imageHeight?: int32(name='ImageHeight'),
      imageQuality?: {
        clarity?: float(name='Clarity'),
        clarityScore?: float(name='ClarityScore'),
        color?: float(name='Color'),
        colorScore?: float(name='ColorScore'),
        compositionScore?: float(name='CompositionScore'),
        contrast?: float(name='Contrast'),
        contrastScore?: float(name='ContrastScore'),
        exposure?: float(name='Exposure'),
        exposureScore?: float(name='ExposureScore'),
        overallScore?: float(name='OverallScore'),
      }(name='ImageQuality'),
      imageQualityFailReason?: string(name='ImageQualityFailReason'),
      imageQualityModifyTime?: string(name='ImageQualityModifyTime'),
      imageQualityStatus?: string(name='ImageQualityStatus'),
      imageTime?: string(name='ImageTime'),
      imageUri?: string(name='ImageUri'),
      imageWidth?: int32(name='ImageWidth'),
      location?: string(name='Location'),
      modifyTime?: string(name='ModifyTime'),
      OCR?: [ 
        {
          OCRBoundary?: {
            height?: int32(name='Height'),
            left?: int32(name='Left'),
            top?: int32(name='Top'),
            width?: int32(name='Width'),
          }(name='OCRBoundary'),
          OCRConfidence?: float(name='OCRConfidence'),
          OCRContents?: string(name='OCRContents'),
        }
      ](name='OCR'),
      OCRFailReason?: string(name='OCRFailReason'),
      OCRModifyTime?: string(name='OCRModifyTime'),
      OCRStatus?: string(name='OCRStatus'),
      orientation?: string(name='Orientation'),
      remarksA?: string(name='RemarksA'),
      remarksArrayA?: string(name='RemarksArrayA'),
      remarksArrayB?: string(name='RemarksArrayB'),
      remarksB?: string(name='RemarksB'),
      remarksC?: string(name='RemarksC'),
      remarksD?: string(name='RemarksD'),
      sourcePosition?: string(name='SourcePosition'),
      sourceType?: string(name='SourceType'),
      sourceUri?: string(name='SourceUri'),
      tags?: [ 
        {
          centricScore?: float(name='CentricScore'),
          parentTagName?: string(name='ParentTagName'),
          tagConfidence?: float(name='TagConfidence'),
          tagLevel?: int32(name='TagLevel'),
          tagName?: string(name='TagName'),
        }
      ](name='Tags'),
      tagsFailReason?: string(name='TagsFailReason'),
      tagsModifyTime?: string(name='TagsModifyTime'),
      tagsStatus?: string(name='TagsStatus'),
    }
  ](name='Images'),
  nextMarker?: string(name='NextMarker'),
  requestId?: string(name='RequestId'),
  setId?: string(name='SetId'),
}

model ListImagesResponse = {
  headers: map[string]string(name='headers'),
  body: ListImagesResponseBody(name='body'),
}

async function listImages(request: ListImagesRequest): ListImagesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListImages', 'POST', '/', 'json', false, 'json', request);
}

model ListOfficeConversionTaskRequest {
  marker?: string(name='Marker', position='Query'),
  maxKeys?: int32(name='MaxKeys', position='Query'),
  project: string(name='Project', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
}

model ListOfficeConversionTaskResponseBody = {
  nextMarker?: string(name='NextMarker'),
  requestId?: string(name='RequestId'),
  tasks?: [ 
    {
      createTime?: string(name='CreateTime'),
      externalID?: string(name='ExternalID'),
      finishTime?: string(name='FinishTime'),
      imageSpec?: string(name='ImageSpec'),
      notifyEndpoint?: string(name='NotifyEndpoint'),
      notifyTopicName?: string(name='NotifyTopicName'),
      pageCount?: int32(name='PageCount'),
      percent?: int32(name='Percent'),
      srcUri?: string(name='SrcUri'),
      status?: string(name='Status'),
      taskId?: string(name='TaskId'),
      tgtType?: string(name='TgtType'),
      tgtUri?: string(name='TgtUri'),
    }
  ](name='Tasks'),
}

model ListOfficeConversionTaskResponse = {
  headers: map[string]string(name='headers'),
  body: ListOfficeConversionTaskResponseBody(name='body'),
}

async function listOfficeConversionTask(request: ListOfficeConversionTaskRequest): ListOfficeConversionTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListOfficeConversionTask', 'POST', '/', 'json', false, 'json', request);
}

model ListProjectsRequest {
  marker?: string(name='Marker', position='Query'),
  maxKeys?: int32(name='MaxKeys', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
}

model ListProjectsResponseBody = {
  nextMarker?: string(name='NextMarker'),
  projects?: [ 
    {
      billingType?: string(name='BillingType'),
      CU?: int32(name='CU'),
      createTime?: string(name='CreateTime'),
      endpoint?: string(name='Endpoint'),
      modifyTime?: string(name='ModifyTime'),
      project?: string(name='Project'),
      regionId?: string(name='RegionId'),
      serviceRole?: string(name='ServiceRole'),
      type?: string(name='Type'),
    }
  ](name='Projects'),
  requestId?: string(name='RequestId'),
}

model ListProjectsResponse = {
  headers: map[string]string(name='headers'),
  body: ListProjectsResponseBody(name='body'),
}

async function listProjects(request: ListProjectsRequest): ListProjectsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListProjects', 'POST', '/', 'json', false, 'json', request);
}

model ListSetTagsRequest {
  project: string(name='Project', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  setId: string(name='SetId', position='Query'),
}

model ListSetTagsResponseBody = {
  requestId?: string(name='RequestId'),
  setId?: string(name='SetId'),
  tags?: [ 
    {
      tagCount?: int32(name='TagCount'),
      tagLevel?: int32(name='TagLevel'),
      tagName?: string(name='TagName'),
    }
  ](name='Tags'),
}

model ListSetTagsResponse = {
  headers: map[string]string(name='headers'),
  body: ListSetTagsResponseBody(name='body'),
}

async function listSetTags(request: ListSetTagsRequest): ListSetTagsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListSetTags', 'POST', '/', 'json', false, 'json', request);
}

model ListSetsRequest {
  marker?: string(name='Marker', position='Query'),
  project: string(name='Project', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
}

model ListSetsResponseBody = {
  nextMarker?: string(name='NextMarker'),
  requestId?: string(name='RequestId'),
  sets?: [ 
    {
      createTime?: string(name='CreateTime'),
      faceCount?: int32(name='FaceCount'),
      imageCount?: int32(name='ImageCount'),
      modifyTime?: string(name='ModifyTime'),
      setId?: string(name='SetId'),
      setName?: string(name='SetName'),
      videoCount?: int32(name='VideoCount'),
      videoLength?: int32(name='VideoLength'),
    }
  ](name='Sets'),
}

model ListSetsResponse = {
  headers: map[string]string(name='headers'),
  body: ListSetsResponseBody(name='body'),
}

async function listSets(request: ListSetsRequest): ListSetsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListSets', 'POST', '/', 'json', false, 'json', request);
}

model ListVideoAudiosRequest {
  marker?: string(name='Marker', position='Query'),
  project: string(name='Project', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  setId: string(name='SetId', position='Query'),
  videoUri: string(name='VideoUri', position='Query'),
}

model ListVideoAudiosResponseBody = {
  audios?: [ 
    {
      audioDuration?: float(name='AudioDuration'),
      audioFormat?: string(name='AudioFormat'),
      audioRate?: int32(name='AudioRate'),
      audioTexts?: [ 
        {
          beginTime?: float(name='BeginTime'),
          channelId?: int32(name='ChannelId'),
          confidence?: float(name='Confidence'),
          emotionValue?: float(name='EmotionValue'),
          endTime?: float(name='EndTime'),
          library?: string(name='Library'),
          person?: string(name='Person'),
          silenceDuration?: float(name='SilenceDuration'),
          speechRate?: int32(name='SpeechRate'),
          text?: string(name='Text'),
        }
      ](name='AudioTexts'),
      audioTextsFailReason?: string(name='AudioTextsFailReason'),
      audioTextsModifyTime?: string(name='AudioTextsModifyTime'),
      audioTextsStatus?: string(name='AudioTextsStatus'),
      audioUri?: string(name='AudioUri'),
      createTime?: string(name='CreateTime'),
      externalId?: string(name='ExternalId'),
      fileSize?: int32(name='FileSize'),
      modifyTime?: string(name='ModifyTime'),
      processFailReason?: string(name='ProcessFailReason'),
      processModifyTime?: string(name='ProcessModifyTime'),
      processStatus?: string(name='ProcessStatus'),
      remarksA?: string(name='RemarksA'),
      remarksB?: string(name='RemarksB'),
      remarksC?: string(name='RemarksC'),
      remarksD?: string(name='RemarksD'),
      sourcePosition?: string(name='SourcePosition'),
      sourceType?: string(name='SourceType'),
      sourceUri?: string(name='SourceUri'),
    }
  ](name='Audios'),
  nextMarker?: string(name='NextMarker'),
  requestId?: string(name='RequestId'),
  setId?: string(name='SetId'),
  videoUri?: string(name='VideoUri'),
}

model ListVideoAudiosResponse = {
  headers: map[string]string(name='headers'),
  body: ListVideoAudiosResponseBody(name='body'),
}

async function listVideoAudios(request: ListVideoAudiosRequest): ListVideoAudiosResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListVideoAudios', 'POST', '/', 'json', false, 'json', request);
}

model ListVideoFramesRequest {
  marker?: string(name='Marker', position='Query'),
  project: string(name='Project', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  setId: string(name='SetId', position='Query'),
  videoUri: string(name='VideoUri', position='Query'),
}

model ListVideoFramesResponseBody = {
  frames?: [ 
    {
      createTime?: string(name='CreateTime'),
      exif?: string(name='Exif'),
      externalId?: string(name='ExternalId'),
      faces?: [ 
        {
          age?: int32(name='Age'),
          attractive?: float(name='Attractive'),
          emotion?: string(name='Emotion'),
          emotionConfidence?: float(name='EmotionConfidence'),
          emotionDetails?: {
            ANGRY?: float(name='ANGRY'),
            CALM?: float(name='CALM'),
            DISGUSTED?: float(name='DISGUSTED'),
            HAPPY?: float(name='HAPPY'),
            SAD?: float(name='SAD'),
            SCARED?: float(name='SCARED'),
            SURPRISED?: float(name='SURPRISED'),
          }(name='EmotionDetails'),
          faceAttributes?: {
            beard?: string(name='Beard'),
            beardConfidence?: float(name='BeardConfidence'),
            faceBoundary?: {
              height?: int32(name='Height'),
              left?: int32(name='Left'),
              top?: int32(name='Top'),
              width?: int32(name='Width'),
            }(name='FaceBoundary'),
            glasses?: string(name='Glasses'),
            glassesConfidence?: float(name='GlassesConfidence'),
            headPose?: {
              pitch?: float(name='Pitch'),
              roll?: float(name='Roll'),
              yaw?: float(name='Yaw'),
            }(name='HeadPose'),
            mask?: string(name='Mask'),
            maskConfidence?: float(name='MaskConfidence'),
          }(name='FaceAttributes'),
          faceConfidence?: float(name='FaceConfidence'),
          faceId?: string(name='FaceId'),
          faceQuality?: float(name='FaceQuality'),
          gender?: string(name='Gender'),
          genderConfidence?: float(name='GenderConfidence'),
          groupId?: string(name='GroupId'),
        }
      ](name='Faces'),
      facesFailReason?: string(name='FacesFailReason'),
      facesModifyTime?: string(name='FacesModifyTime'),
      facesStatus?: string(name='FacesStatus'),
      fileSize?: int32(name='FileSize'),
      imageFormat?: string(name='ImageFormat'),
      imageHeight?: int32(name='ImageHeight'),
      imageTime?: string(name='ImageTime'),
      imageUri?: string(name='ImageUri'),
      imageWidth?: int32(name='ImageWidth'),
      location?: string(name='Location'),
      modifyTime?: string(name='ModifyTime'),
      OCR?: [ 
        {
          OCRBoundary?: {
            height?: int32(name='Height'),
            left?: int32(name='Left'),
            top?: int32(name='Top'),
            width?: int32(name='Width'),
          }(name='OCRBoundary'),
          OCRConfidence?: float(name='OCRConfidence'),
          OCRContents?: string(name='OCRContents'),
        }
      ](name='OCR'),
      OCRFailReason?: string(name='OCRFailReason'),
      OCRModifyTime?: string(name='OCRModifyTime'),
      OCRStatus?: string(name='OCRStatus'),
      orientation?: string(name='Orientation'),
      remarksA?: string(name='RemarksA'),
      remarksB?: string(name='RemarksB'),
      remarksC?: string(name='RemarksC'),
      remarksD?: string(name='RemarksD'),
      sourcePosition?: string(name='SourcePosition'),
      sourceType?: string(name='SourceType'),
      sourceUri?: string(name='SourceUri'),
      tags?: [ 
        {
          parentTagName?: string(name='ParentTagName'),
          tagConfidence?: float(name='TagConfidence'),
          tagLevel?: int32(name='TagLevel'),
          tagName?: string(name='TagName'),
        }
      ](name='Tags'),
      tagsFailReason?: string(name='TagsFailReason'),
      tagsModifyTime?: string(name='TagsModifyTime'),
      tagsStatus?: string(name='TagsStatus'),
    }
  ](name='Frames'),
  nextMarker?: string(name='NextMarker'),
  requestId?: string(name='RequestId'),
  setId?: string(name='SetId'),
  videoUri?: string(name='VideoUri'),
}

model ListVideoFramesResponse = {
  headers: map[string]string(name='headers'),
  body: ListVideoFramesResponseBody(name='body'),
}

async function listVideoFrames(request: ListVideoFramesRequest): ListVideoFramesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListVideoFrames', 'POST', '/', 'json', false, 'json', request);
}

model ListVideoTasksRequest {
  marker?: string(name='Marker', position='Query'),
  maxKeys?: int32(name='MaxKeys', position='Query'),
  project: string(name='Project', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  taskType?: string(name='TaskType', position='Query'),
}

model ListVideoTasksResponseBody = {
  nextMarker?: string(name='NextMarker'),
  requestId?: string(name='RequestId'),
  tasks?: [ 
    {
      endTime?: string(name='EndTime'),
      errorMessage?: string(name='ErrorMessage'),
      notifyEndpoint?: string(name='NotifyEndpoint'),
      notifyTopicName?: string(name='NotifyTopicName'),
      parameters?: string(name='Parameters'),
      progress?: int32(name='Progress'),
      result?: string(name='Result'),
      startTime?: string(name='StartTime'),
      status?: string(name='Status'),
      taskId?: string(name='TaskId'),
      taskType?: string(name='TaskType'),
    }
  ](name='Tasks'),
}

model ListVideoTasksResponse = {
  headers: map[string]string(name='headers'),
  body: ListVideoTasksResponseBody(name='body'),
}

async function listVideoTasks(request: ListVideoTasksRequest): ListVideoTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListVideoTasks', 'POST', '/', 'json', false, 'json', request);
}

model ListVideosRequest {
  createTimeStart?: string(name='CreateTimeStart', position='Query'),
  marker?: string(name='Marker', position='Query'),
  project: string(name='Project', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  setId: string(name='SetId', position='Query'),
}

model ListVideosResponseBody = {
  nextMarker?: string(name='NextMarker'),
  requestId?: string(name='RequestId'),
  setId?: string(name='SetId'),
  videos?: [ 
    {
      createTime?: string(name='CreateTime'),
      externalId?: string(name='ExternalId'),
      fileSize?: int32(name='FileSize'),
      modifyTime?: string(name='ModifyTime'),
      processFailReason?: string(name='ProcessFailReason'),
      processModifyTime?: string(name='ProcessModifyTime'),
      processStatus?: string(name='ProcessStatus'),
      remarksA?: string(name='RemarksA'),
      remarksB?: string(name='RemarksB'),
      remarksC?: string(name='RemarksC'),
      remarksD?: string(name='RemarksD'),
      sourcePosition?: string(name='SourcePosition'),
      sourceType?: string(name='SourceType'),
      sourceUri?: string(name='SourceUri'),
      videoDuration?: float(name='VideoDuration'),
      videoFormat?: string(name='VideoFormat'),
      videoFrames?: int32(name='VideoFrames'),
      videoHeight?: int32(name='VideoHeight'),
      videoTags?: [ 
        {
          parentTagName?: string(name='ParentTagName'),
          tagConfidence?: float(name='TagConfidence'),
          tagLevel?: int32(name='TagLevel'),
          tagName?: string(name='TagName'),
        }
      ](name='VideoTags'),
      videoTagsFailReason?: string(name='VideoTagsFailReason'),
      videoTagsModifyTime?: string(name='VideoTagsModifyTime'),
      videoTagsStatus?: string(name='VideoTagsStatus'),
      videoUri?: string(name='VideoUri'),
      videoWidth?: int32(name='VideoWidth'),
    }
  ](name='Videos'),
}

model ListVideosResponse = {
  headers: map[string]string(name='headers'),
  body: ListVideosResponseBody(name='body'),
}

async function listVideos(request: ListVideosRequest): ListVideosResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListVideos', 'POST', '/', 'json', false, 'json', request);
}

model OpenImmServiceRequest {
  ownerId?: long(name='OwnerId', position='Query'),
}

model OpenImmServiceResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model OpenImmServiceResponse = {
  headers: map[string]string(name='headers'),
  body: OpenImmServiceResponseBody(name='body'),
}

async function openImmService(request: OpenImmServiceRequest): OpenImmServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OpenImmService', 'POST', '/', 'json', false, 'json', request);
}

model PutProjectRequest {
  project: string(name='Project', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  serviceRole?: string(name='ServiceRole', position='Query'),
}

model PutProjectResponseBody = {
  billingType?: string(name='BillingType'),
  CU?: int32(name='CU'),
  createTime?: string(name='CreateTime'),
  endpoint?: string(name='Endpoint'),
  modifyTime?: string(name='ModifyTime'),
  project?: string(name='Project'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  serviceRole?: string(name='ServiceRole'),
  type?: string(name='Type'),
}

model PutProjectResponse = {
  headers: map[string]string(name='headers'),
  body: PutProjectResponseBody(name='body'),
}

async function putProject(request: PutProjectRequest): PutProjectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PutProject', 'POST', '/', 'json', false, 'json', request);
}

model RefreshOfficePreviewTokenRequest {
  accessToken: string(name='AccessToken', position='Query'),
  project: string(name='Project', position='Query'),
  refreshToken?: string(name='RefreshToken', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
}

model RefreshOfficePreviewTokenResponseBody = {
  accessToken?: string(name='AccessToken'),
  accessTokenExpiredTime?: string(name='AccessTokenExpiredTime'),
  refreshToken?: string(name='RefreshToken'),
  refreshTokenExpiredTime?: string(name='RefreshTokenExpiredTime'),
  requestId?: string(name='RequestId'),
}

model RefreshOfficePreviewTokenResponse = {
  headers: map[string]string(name='headers'),
  body: RefreshOfficePreviewTokenResponseBody(name='body'),
}

async function refreshOfficePreviewToken(request: RefreshOfficePreviewTokenRequest): RefreshOfficePreviewTokenResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RefreshOfficePreviewToken', 'POST', '/', 'json', false, 'json', request);
}

model RefreshWebofficeTokenRequest {
  accessToken: string(name='AccessToken', position='Query'),
  project: string(name='Project', position='Query'),
  refreshToken?: string(name='RefreshToken', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
}

model RefreshWebofficeTokenResponseBody = {
  accessToken?: string(name='AccessToken'),
  accessTokenExpiredTime?: string(name='AccessTokenExpiredTime'),
  refreshToken?: string(name='RefreshToken'),
  refreshTokenExpiredTime?: string(name='RefreshTokenExpiredTime'),
  requestId?: string(name='RequestId'),
}

model RefreshWebofficeTokenResponse = {
  headers: map[string]string(name='headers'),
  body: RefreshWebofficeTokenResponseBody(name='body'),
}

async function refreshWebofficeToken(request: RefreshWebofficeTokenRequest): RefreshWebofficeTokenResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RefreshWebofficeToken', 'POST', '/', 'json', false, 'json', request);
}

model UpdateFaceGroupRequest {
  externalId?: string(name='ExternalId', position='Query'),
  groupCoverFaceId?: string(name='GroupCoverFaceId', position='Query'),
  groupId: string(name='GroupId', position='Query'),
  groupName?: string(name='GroupName', position='Query'),
  project: string(name='Project', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  remarksA?: string(name='RemarksA', position='Query'),
  remarksArrayA?: string(name='RemarksArrayA', position='Query'),
  remarksArrayB?: string(name='RemarksArrayB', position='Query'),
  remarksB?: string(name='RemarksB', position='Query'),
  remarksC?: string(name='RemarksC', position='Query'),
  remarksD?: string(name='RemarksD', position='Query'),
  resetItems?: string(name='ResetItems', position='Query'),
  setId: string(name='SetId', position='Query'),
}

model UpdateFaceGroupResponseBody = {
  groupId?: string(name='GroupId'),
  requestId?: string(name='RequestId'),
  setId?: string(name='SetId'),
}

model UpdateFaceGroupResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateFaceGroupResponseBody(name='body'),
}

async function updateFaceGroup(request: UpdateFaceGroupRequest): UpdateFaceGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateFaceGroup', 'POST', '/', 'json', false, 'json', request);
}

model UpdateImageRequest {
  externalId?: string(name='ExternalId', position='Query'),
  faces?: [ 
    {
      faceId?: string(name='FaceId'),
      groupId?: string(name='GroupId'),
    }
  ](name='Faces', position='Query'),
  imageUri: string(name='ImageUri', position='Query'),
  project: string(name='Project', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  remarksA?: string(name='RemarksA', position='Query'),
  remarksArrayA?: string(name='RemarksArrayA', position='Query'),
  remarksArrayB?: string(name='RemarksArrayB', position='Query'),
  remarksB?: string(name='RemarksB', position='Query'),
  remarksC?: string(name='RemarksC', position='Query'),
  remarksD?: string(name='RemarksD', position='Query'),
  setId: string(name='SetId', position='Query'),
  sourcePosition?: string(name='SourcePosition', position='Query'),
  sourceType?: string(name='SourceType', position='Query'),
  sourceUri?: string(name='SourceUri', position='Query'),
}

model UpdateImageResponseBody = {
  createTime?: string(name='CreateTime'),
  externalId?: string(name='ExternalId'),
  imageUri?: string(name='ImageUri'),
  modifyTime?: string(name='ModifyTime'),
  remarksA?: string(name='RemarksA'),
  remarksArrayA?: string(name='RemarksArrayA'),
  remarksArrayB?: string(name='RemarksArrayB'),
  remarksB?: string(name='RemarksB'),
  remarksC?: string(name='RemarksC'),
  remarksD?: string(name='RemarksD'),
  requestId?: string(name='RequestId'),
  setId?: string(name='SetId'),
}

model UpdateImageResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateImageResponseBody(name='body'),
}

async function updateImage(request: UpdateImageRequest): UpdateImageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateImage', 'POST', '/', 'json', false, 'json', request);
}

model UpdateProjectRequest {
  newCU?: int32(name='NewCU', position='Query'),
  newServiceRole?: string(name='NewServiceRole', position='Query'),
  project: string(name='Project', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
}

model UpdateProjectResponseBody = {
  CU?: int32(name='CU'),
  createTime?: string(name='CreateTime'),
  modifyTime?: string(name='ModifyTime'),
  project?: string(name='Project'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  serviceRole?: string(name='ServiceRole'),
  type?: string(name='Type'),
}

model UpdateProjectResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateProjectResponseBody(name='body'),
}

async function updateProject(request: UpdateProjectRequest): UpdateProjectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateProject', 'POST', '/', 'json', false, 'json', request);
}

model UpdateSetRequest {
  project: string(name='Project', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  setId: string(name='SetId', position='Query'),
  setName?: string(name='SetName', position='Query'),
}

model UpdateSetResponseBody = {
  createTime?: string(name='CreateTime'),
  modifyTime?: string(name='ModifyTime'),
  requestId?: string(name='RequestId'),
  setId?: string(name='SetId'),
  setName?: string(name='SetName'),
}

model UpdateSetResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateSetResponseBody(name='body'),
}

async function updateSet(request: UpdateSetRequest): UpdateSetResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateSet', 'POST', '/', 'json', false, 'json', request);
}

