/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    cn-beijing-gov-1 = 'imm-vpc.cn-beijing-gov-1.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('imm', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model CompareImageFacesRequest {
  faceIdA?: string(name='FaceIdA'),
  faceIdB?: string(name='FaceIdB'),
  imageUriA?: string(name='ImageUriA'),
  imageUriB?: string(name='ImageUriB'),
  project?: string(name='Project'),
  setId?: string(name='SetId'),
}

model CompareImageFacesResponseBody = {
  faceA?: {
    faceAttributes?: {
      faceBoundary?: {
        height?: int32(name='Height'),
        left?: int32(name='Left'),
        top?: int32(name='Top'),
        width?: int32(name='Width'),
      }(name='FaceBoundary'),
    }(name='FaceAttributes'),
    faceId?: string(name='FaceId'),
  }(name='FaceA'),
  faceB?: {
    faceAttributes?: {
      faceBoundary?: {
        height?: int32(name='Height'),
        left?: int32(name='Left'),
        top?: int32(name='Top'),
        width?: int32(name='Width'),
      }(name='FaceBoundary'),
    }(name='FaceAttributes'),
    faceId?: string(name='FaceId'),
  }(name='FaceB'),
  requestId?: string(name='RequestId'),
  setId?: string(name='SetId'),
  similarity?: float(name='Similarity'),
}

model CompareImageFacesResponse = {
  headers: map[string]string(name='headers'),
  body: CompareImageFacesResponseBody(name='body'),
}

async function compareImageFacesWithOptions(request: CompareImageFacesRequest, runtime: Util.RuntimeOptions): CompareImageFacesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.faceIdA)) {
    query['FaceIdA'] = request.faceIdA;
  }
  if (!Util.isUnset(request.faceIdB)) {
    query['FaceIdB'] = request.faceIdB;
  }
  if (!Util.isUnset(request.imageUriA)) {
    query['ImageUriA'] = request.imageUriA;
  }
  if (!Util.isUnset(request.imageUriB)) {
    query['ImageUriB'] = request.imageUriB;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.setId)) {
    query['SetId'] = request.setId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CompareImageFaces',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function compareImageFaces(request: CompareImageFacesRequest): CompareImageFacesResponse {
  var runtime = new Util.RuntimeOptions{};
  return compareImageFacesWithOptions(request, runtime);
}

model ConvertOfficeFormatRequest {
  endPage?: long(name='EndPage'),
  fitToPagesTall?: boolean(name='FitToPagesTall'),
  fitToPagesWide?: boolean(name='FitToPagesWide'),
  hidecomments?: boolean(name='Hidecomments'),
  maxSheetCol?: long(name='MaxSheetCol'),
  maxSheetCount?: long(name='MaxSheetCount'),
  maxSheetRow?: long(name='MaxSheetRow'),
  modelId?: string(name='ModelId'),
  password?: string(name='Password'),
  pdfVector?: boolean(name='PdfVector'),
  project?: string(name='Project'),
  sheetOnePage?: boolean(name='SheetOnePage'),
  srcType?: string(name='SrcType'),
  srcUri?: string(name='SrcUri'),
  startPage?: long(name='StartPage'),
  tgtFilePages?: string(name='TgtFilePages'),
  tgtFilePrefix?: string(name='TgtFilePrefix'),
  tgtFileSuffix?: string(name='TgtFileSuffix'),
  tgtType?: string(name='TgtType'),
  tgtUri?: string(name='TgtUri'),
}

model ConvertOfficeFormatResponseBody = {
  pageCount?: int32(name='PageCount'),
  requestId?: string(name='RequestId'),
}

model ConvertOfficeFormatResponse = {
  headers: map[string]string(name='headers'),
  body: ConvertOfficeFormatResponseBody(name='body'),
}

async function convertOfficeFormatWithOptions(request: ConvertOfficeFormatRequest, runtime: Util.RuntimeOptions): ConvertOfficeFormatResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endPage)) {
    query['EndPage'] = request.endPage;
  }
  if (!Util.isUnset(request.fitToPagesTall)) {
    query['FitToPagesTall'] = request.fitToPagesTall;
  }
  if (!Util.isUnset(request.fitToPagesWide)) {
    query['FitToPagesWide'] = request.fitToPagesWide;
  }
  if (!Util.isUnset(request.hidecomments)) {
    query['Hidecomments'] = request.hidecomments;
  }
  if (!Util.isUnset(request.maxSheetCol)) {
    query['MaxSheetCol'] = request.maxSheetCol;
  }
  if (!Util.isUnset(request.maxSheetCount)) {
    query['MaxSheetCount'] = request.maxSheetCount;
  }
  if (!Util.isUnset(request.maxSheetRow)) {
    query['MaxSheetRow'] = request.maxSheetRow;
  }
  if (!Util.isUnset(request.modelId)) {
    query['ModelId'] = request.modelId;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.pdfVector)) {
    query['PdfVector'] = request.pdfVector;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.sheetOnePage)) {
    query['SheetOnePage'] = request.sheetOnePage;
  }
  if (!Util.isUnset(request.srcType)) {
    query['SrcType'] = request.srcType;
  }
  if (!Util.isUnset(request.srcUri)) {
    query['SrcUri'] = request.srcUri;
  }
  if (!Util.isUnset(request.startPage)) {
    query['StartPage'] = request.startPage;
  }
  if (!Util.isUnset(request.tgtFilePages)) {
    query['TgtFilePages'] = request.tgtFilePages;
  }
  if (!Util.isUnset(request.tgtFilePrefix)) {
    query['TgtFilePrefix'] = request.tgtFilePrefix;
  }
  if (!Util.isUnset(request.tgtFileSuffix)) {
    query['TgtFileSuffix'] = request.tgtFileSuffix;
  }
  if (!Util.isUnset(request.tgtType)) {
    query['TgtType'] = request.tgtType;
  }
  if (!Util.isUnset(request.tgtUri)) {
    query['TgtUri'] = request.tgtUri;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ConvertOfficeFormat',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function convertOfficeFormat(request: ConvertOfficeFormatRequest): ConvertOfficeFormatResponse {
  var runtime = new Util.RuntimeOptions{};
  return convertOfficeFormatWithOptions(request, runtime);
}

model CreateGrabFrameTaskRequest {
  customMessage?: string(name='CustomMessage'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
  notifyTopicName?: string(name='NotifyTopicName'),
  project?: string(name='Project'),
  targetList?: string(name='TargetList'),
  videoUri?: string(name='VideoUri'),
}

model CreateGrabFrameTaskResponseBody = {
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
  taskType?: string(name='TaskType'),
}

model CreateGrabFrameTaskResponse = {
  headers: map[string]string(name='headers'),
  body: CreateGrabFrameTaskResponseBody(name='body'),
}

async function createGrabFrameTaskWithOptions(request: CreateGrabFrameTaskRequest, runtime: Util.RuntimeOptions): CreateGrabFrameTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.customMessage)) {
    query['CustomMessage'] = request.customMessage;
  }
  if (!Util.isUnset(request.notifyEndpoint)) {
    query['NotifyEndpoint'] = request.notifyEndpoint;
  }
  if (!Util.isUnset(request.notifyTopicName)) {
    query['NotifyTopicName'] = request.notifyTopicName;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.targetList)) {
    query['TargetList'] = request.targetList;
  }
  if (!Util.isUnset(request.videoUri)) {
    query['VideoUri'] = request.videoUri;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateGrabFrameTask',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createGrabFrameTask(request: CreateGrabFrameTaskRequest): CreateGrabFrameTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createGrabFrameTaskWithOptions(request, runtime);
}

model CreateGroupFacesJobRequest {
  notifyEndpoint?: string(name='NotifyEndpoint'),
  notifyTopicName?: string(name='NotifyTopicName'),
  project?: string(name='Project'),
  setId?: string(name='SetId'),
}

model CreateGroupFacesJobResponseBody = {
  jobId?: string(name='JobId'),
  jobType?: string(name='JobType'),
  requestId?: string(name='RequestId'),
  setId?: string(name='SetId'),
}

model CreateGroupFacesJobResponse = {
  headers: map[string]string(name='headers'),
  body: CreateGroupFacesJobResponseBody(name='body'),
}

async function createGroupFacesJobWithOptions(request: CreateGroupFacesJobRequest, runtime: Util.RuntimeOptions): CreateGroupFacesJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.notifyEndpoint)) {
    query['NotifyEndpoint'] = request.notifyEndpoint;
  }
  if (!Util.isUnset(request.notifyTopicName)) {
    query['NotifyTopicName'] = request.notifyTopicName;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.setId)) {
    query['SetId'] = request.setId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateGroupFacesJob',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createGroupFacesJob(request: CreateGroupFacesJobRequest): CreateGroupFacesJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return createGroupFacesJobWithOptions(request, runtime);
}

model CreateMergeFaceGroupsJobRequest {
  customMessage?: string(name='CustomMessage'),
  groupIdFrom?: string(name='GroupIdFrom'),
  groupIdTo?: string(name='GroupIdTo'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
  notifyTopicName?: string(name='NotifyTopicName'),
  project?: string(name='Project'),
  setId?: string(name='SetId'),
}

model CreateMergeFaceGroupsJobResponseBody = {
  groupIdFrom?: string(name='GroupIdFrom'),
  groupIdTo?: string(name='GroupIdTo'),
  jobId?: string(name='JobId'),
  jobType?: string(name='JobType'),
  requestId?: string(name='RequestId'),
  setId?: string(name='SetId'),
}

model CreateMergeFaceGroupsJobResponse = {
  headers: map[string]string(name='headers'),
  body: CreateMergeFaceGroupsJobResponseBody(name='body'),
}

async function createMergeFaceGroupsJobWithOptions(request: CreateMergeFaceGroupsJobRequest, runtime: Util.RuntimeOptions): CreateMergeFaceGroupsJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.customMessage)) {
    query['CustomMessage'] = request.customMessage;
  }
  if (!Util.isUnset(request.groupIdFrom)) {
    query['GroupIdFrom'] = request.groupIdFrom;
  }
  if (!Util.isUnset(request.groupIdTo)) {
    query['GroupIdTo'] = request.groupIdTo;
  }
  if (!Util.isUnset(request.notifyEndpoint)) {
    query['NotifyEndpoint'] = request.notifyEndpoint;
  }
  if (!Util.isUnset(request.notifyTopicName)) {
    query['NotifyTopicName'] = request.notifyTopicName;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.setId)) {
    query['SetId'] = request.setId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateMergeFaceGroupsJob',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMergeFaceGroupsJob(request: CreateMergeFaceGroupsJobRequest): CreateMergeFaceGroupsJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMergeFaceGroupsJobWithOptions(request, runtime);
}

model CreateOfficeConversionTaskRequest {
  displayDpi?: int32(name='DisplayDpi'),
  endPage?: long(name='EndPage'),
  fitToPagesTall?: boolean(name='FitToPagesTall'),
  fitToPagesWide?: boolean(name='FitToPagesWide'),
  hidecomments?: boolean(name='Hidecomments'),
  idempotentToken?: string(name='IdempotentToken'),
  maxSheetCol?: long(name='MaxSheetCol'),
  maxSheetCount?: long(name='MaxSheetCount'),
  maxSheetRow?: long(name='MaxSheetRow'),
  modelId?: string(name='ModelId'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
  notifyTopicName?: string(name='NotifyTopicName'),
  password?: string(name='Password'),
  pdfVector?: boolean(name='PdfVector'),
  project?: string(name='Project'),
  sheetOnePage?: boolean(name='SheetOnePage'),
  srcType?: string(name='SrcType'),
  srcUri?: string(name='SrcUri'),
  startPage?: long(name='StartPage'),
  tgtFilePages?: string(name='TgtFilePages'),
  tgtFilePrefix?: string(name='TgtFilePrefix'),
  tgtFileSuffix?: string(name='TgtFileSuffix'),
  tgtType?: string(name='TgtType'),
  tgtUri?: string(name='TgtUri'),
  userData?: string(name='UserData'),
}

model CreateOfficeConversionTaskResponseBody = {
  createTime?: string(name='CreateTime'),
  percent?: int32(name='Percent'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
  taskId?: string(name='TaskId'),
  tgtLoc?: string(name='TgtLoc'),
}

model CreateOfficeConversionTaskResponse = {
  headers: map[string]string(name='headers'),
  body: CreateOfficeConversionTaskResponseBody(name='body'),
}

async function createOfficeConversionTaskWithOptions(request: CreateOfficeConversionTaskRequest, runtime: Util.RuntimeOptions): CreateOfficeConversionTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.displayDpi)) {
    query['DisplayDpi'] = request.displayDpi;
  }
  if (!Util.isUnset(request.endPage)) {
    query['EndPage'] = request.endPage;
  }
  if (!Util.isUnset(request.fitToPagesTall)) {
    query['FitToPagesTall'] = request.fitToPagesTall;
  }
  if (!Util.isUnset(request.fitToPagesWide)) {
    query['FitToPagesWide'] = request.fitToPagesWide;
  }
  if (!Util.isUnset(request.hidecomments)) {
    query['Hidecomments'] = request.hidecomments;
  }
  if (!Util.isUnset(request.idempotentToken)) {
    query['IdempotentToken'] = request.idempotentToken;
  }
  if (!Util.isUnset(request.maxSheetCol)) {
    query['MaxSheetCol'] = request.maxSheetCol;
  }
  if (!Util.isUnset(request.maxSheetCount)) {
    query['MaxSheetCount'] = request.maxSheetCount;
  }
  if (!Util.isUnset(request.maxSheetRow)) {
    query['MaxSheetRow'] = request.maxSheetRow;
  }
  if (!Util.isUnset(request.modelId)) {
    query['ModelId'] = request.modelId;
  }
  if (!Util.isUnset(request.notifyEndpoint)) {
    query['NotifyEndpoint'] = request.notifyEndpoint;
  }
  if (!Util.isUnset(request.notifyTopicName)) {
    query['NotifyTopicName'] = request.notifyTopicName;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.pdfVector)) {
    query['PdfVector'] = request.pdfVector;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.sheetOnePage)) {
    query['SheetOnePage'] = request.sheetOnePage;
  }
  if (!Util.isUnset(request.srcType)) {
    query['SrcType'] = request.srcType;
  }
  if (!Util.isUnset(request.srcUri)) {
    query['SrcUri'] = request.srcUri;
  }
  if (!Util.isUnset(request.startPage)) {
    query['StartPage'] = request.startPage;
  }
  if (!Util.isUnset(request.tgtFilePages)) {
    query['TgtFilePages'] = request.tgtFilePages;
  }
  if (!Util.isUnset(request.tgtFilePrefix)) {
    query['TgtFilePrefix'] = request.tgtFilePrefix;
  }
  if (!Util.isUnset(request.tgtFileSuffix)) {
    query['TgtFileSuffix'] = request.tgtFileSuffix;
  }
  if (!Util.isUnset(request.tgtType)) {
    query['TgtType'] = request.tgtType;
  }
  if (!Util.isUnset(request.tgtUri)) {
    query['TgtUri'] = request.tgtUri;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateOfficeConversionTask',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createOfficeConversionTask(request: CreateOfficeConversionTaskRequest): CreateOfficeConversionTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOfficeConversionTaskWithOptions(request, runtime);
}

model CreateSetRequest {
  project?: string(name='Project'),
  setId?: string(name='SetId'),
  setName?: string(name='SetName'),
}

model CreateSetResponseBody = {
  createTime?: string(name='CreateTime'),
  faceCount?: int32(name='FaceCount'),
  imageCount?: int32(name='ImageCount'),
  modifyTime?: string(name='ModifyTime'),
  requestId?: string(name='RequestId'),
  setId?: string(name='SetId'),
  setName?: string(name='SetName'),
  videoCount?: int32(name='VideoCount'),
  videoLength?: int32(name='VideoLength'),
}

model CreateSetResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSetResponseBody(name='body'),
}

async function createSetWithOptions(request: CreateSetRequest, runtime: Util.RuntimeOptions): CreateSetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.setId)) {
    query['SetId'] = request.setId;
  }
  if (!Util.isUnset(request.setName)) {
    query['SetName'] = request.setName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateSet',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createSet(request: CreateSetRequest): CreateSetResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSetWithOptions(request, runtime);
}

model CreateVideoCompressTaskRequest {
  customMessage?: string(name='CustomMessage'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
  notifyTopicName?: string(name='NotifyTopicName'),
  project?: string(name='Project'),
  targetList?: string(name='TargetList'),
  targetSegment?: string(name='TargetSegment'),
  targetSubtitle?: string(name='TargetSubtitle'),
  videoUri?: string(name='VideoUri'),
}

model CreateVideoCompressTaskResponseBody = {
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
  taskType?: string(name='TaskType'),
}

model CreateVideoCompressTaskResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVideoCompressTaskResponseBody(name='body'),
}

async function createVideoCompressTaskWithOptions(request: CreateVideoCompressTaskRequest, runtime: Util.RuntimeOptions): CreateVideoCompressTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.customMessage)) {
    query['CustomMessage'] = request.customMessage;
  }
  if (!Util.isUnset(request.notifyEndpoint)) {
    query['NotifyEndpoint'] = request.notifyEndpoint;
  }
  if (!Util.isUnset(request.notifyTopicName)) {
    query['NotifyTopicName'] = request.notifyTopicName;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.targetList)) {
    query['TargetList'] = request.targetList;
  }
  if (!Util.isUnset(request.targetSegment)) {
    query['TargetSegment'] = request.targetSegment;
  }
  if (!Util.isUnset(request.targetSubtitle)) {
    query['TargetSubtitle'] = request.targetSubtitle;
  }
  if (!Util.isUnset(request.videoUri)) {
    query['VideoUri'] = request.videoUri;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateVideoCompressTask',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createVideoCompressTask(request: CreateVideoCompressTaskRequest): CreateVideoCompressTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVideoCompressTaskWithOptions(request, runtime);
}

model DecodeBlindWatermarkRequest {
  imageQuality?: int32(name='ImageQuality'),
  imageUri?: string(name='ImageUri'),
  model?: string(name='Model'),
  originalImageUri?: string(name='OriginalImageUri'),
  project?: string(name='Project'),
  targetUri?: string(name='TargetUri'),
}

model DecodeBlindWatermarkResponseBody = {
  requestId?: string(name='RequestId'),
  targetUri?: string(name='TargetUri'),
}

model DecodeBlindWatermarkResponse = {
  headers: map[string]string(name='headers'),
  body: DecodeBlindWatermarkResponseBody(name='body'),
}

async function decodeBlindWatermarkWithOptions(request: DecodeBlindWatermarkRequest, runtime: Util.RuntimeOptions): DecodeBlindWatermarkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.imageQuality)) {
    query['ImageQuality'] = request.imageQuality;
  }
  if (!Util.isUnset(request.imageUri)) {
    query['ImageUri'] = request.imageUri;
  }
  if (!Util.isUnset(request.model)) {
    query['Model'] = request.model;
  }
  if (!Util.isUnset(request.originalImageUri)) {
    query['OriginalImageUri'] = request.originalImageUri;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.targetUri)) {
    query['TargetUri'] = request.targetUri;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DecodeBlindWatermark',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function decodeBlindWatermark(request: DecodeBlindWatermarkRequest): DecodeBlindWatermarkResponse {
  var runtime = new Util.RuntimeOptions{};
  return decodeBlindWatermarkWithOptions(request, runtime);
}

model DeleteImageRequest {
  imageUri?: string(name='ImageUri'),
  project?: string(name='Project'),
  setId?: string(name='SetId'),
}

model DeleteImageResponseBody = {
  imageUri?: string(name='ImageUri'),
  requestId?: string(name='RequestId'),
  setId?: string(name='SetId'),
}

model DeleteImageResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteImageResponseBody(name='body'),
}

async function deleteImageWithOptions(request: DeleteImageRequest, runtime: Util.RuntimeOptions): DeleteImageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.imageUri)) {
    query['ImageUri'] = request.imageUri;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.setId)) {
    query['SetId'] = request.setId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteImage',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteImage(request: DeleteImageRequest): DeleteImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteImageWithOptions(request, runtime);
}

model DeleteOfficeConversionTaskRequest {
  project?: string(name='Project'),
  taskId?: string(name='TaskId'),
}

model DeleteOfficeConversionTaskResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteOfficeConversionTaskResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteOfficeConversionTaskResponseBody(name='body'),
}

async function deleteOfficeConversionTaskWithOptions(request: DeleteOfficeConversionTaskRequest, runtime: Util.RuntimeOptions): DeleteOfficeConversionTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteOfficeConversionTask',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteOfficeConversionTask(request: DeleteOfficeConversionTaskRequest): DeleteOfficeConversionTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteOfficeConversionTaskWithOptions(request, runtime);
}

model DeleteProjectRequest {
  project?: string(name='Project'),
}

model DeleteProjectResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteProjectResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteProjectResponseBody(name='body'),
}

async function deleteProjectWithOptions(request: DeleteProjectRequest, runtime: Util.RuntimeOptions): DeleteProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteProject',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteProject(request: DeleteProjectRequest): DeleteProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteProjectWithOptions(request, runtime);
}

model DeleteSetRequest {
  project?: string(name='Project'),
  setId?: string(name='SetId'),
}

model DeleteSetResponseBody = {
  requestId?: string(name='RequestId'),
  setId?: string(name='SetId'),
}

model DeleteSetResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSetResponseBody(name='body'),
}

async function deleteSetWithOptions(request: DeleteSetRequest, runtime: Util.RuntimeOptions): DeleteSetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.setId)) {
    query['SetId'] = request.setId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSet',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSet(request: DeleteSetRequest): DeleteSetResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSetWithOptions(request, runtime);
}

model DeleteVideoRequest {
  project?: string(name='Project'),
  resources?: boolean(name='Resources'),
  setId?: string(name='SetId'),
  videoUri?: string(name='VideoUri'),
}

model DeleteVideoResponseBody = {
  requestId?: string(name='RequestId'),
  setId?: string(name='SetId'),
  videoUri?: string(name='VideoUri'),
}

model DeleteVideoResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVideoResponseBody(name='body'),
}

async function deleteVideoWithOptions(request: DeleteVideoRequest, runtime: Util.RuntimeOptions): DeleteVideoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.resources)) {
    query['Resources'] = request.resources;
  }
  if (!Util.isUnset(request.setId)) {
    query['SetId'] = request.setId;
  }
  if (!Util.isUnset(request.videoUri)) {
    query['VideoUri'] = request.videoUri;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteVideo',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteVideo(request: DeleteVideoRequest): DeleteVideoResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVideoWithOptions(request, runtime);
}

model DeleteVideoTaskRequest {
  project?: string(name='Project'),
  taskId?: string(name='TaskId'),
  taskType?: string(name='TaskType'),
}

model DeleteVideoTaskResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVideoTaskResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVideoTaskResponseBody(name='body'),
}

async function deleteVideoTaskWithOptions(request: DeleteVideoTaskRequest, runtime: Util.RuntimeOptions): DeleteVideoTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.taskType)) {
    query['TaskType'] = request.taskType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteVideoTask',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteVideoTask(request: DeleteVideoTaskRequest): DeleteVideoTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVideoTaskWithOptions(request, runtime);
}

model DetectImageBodiesRequest {
  imageUri?: string(name='ImageUri'),
  project?: string(name='Project'),
}

model DetectImageBodiesResponseBody = {
  bodies?: [ 
    {
      bodyBoundary?: {
        height?: int32(name='Height'),
        left?: int32(name='Left'),
        top?: int32(name='Top'),
        width?: int32(name='Width'),
      }(name='BodyBoundary'),
      bodyConfidence?: float(name='BodyConfidence'),
    }
  ](name='Bodies'),
  imageUri?: string(name='ImageUri'),
  requestId?: string(name='RequestId'),
}

model DetectImageBodiesResponse = {
  headers: map[string]string(name='headers'),
  body: DetectImageBodiesResponseBody(name='body'),
}

async function detectImageBodiesWithOptions(request: DetectImageBodiesRequest, runtime: Util.RuntimeOptions): DetectImageBodiesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.imageUri)) {
    query['ImageUri'] = request.imageUri;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DetectImageBodies',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detectImageBodies(request: DetectImageBodiesRequest): DetectImageBodiesResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectImageBodiesWithOptions(request, runtime);
}

model DetectImageFacesRequest {
  imageUri?: string(name='ImageUri'),
  project?: string(name='Project'),
}

model DetectImageFacesResponseBody = {
  faces?: [ 
    {
      age?: int32(name='Age'),
      ageConfidence?: float(name='AgeConfidence'),
      attractive?: float(name='Attractive'),
      attractiveConfidence?: float(name='AttractiveConfidence'),
      emotion?: string(name='Emotion'),
      emotionConfidence?: float(name='EmotionConfidence'),
      emotionDetails?: {
        ANGRY?: float(name='ANGRY'),
        CALM?: float(name='CALM'),
        DISGUSTED?: float(name='DISGUSTED'),
        HAPPY?: float(name='HAPPY'),
        SAD?: float(name='SAD'),
        SCARED?: float(name='SCARED'),
        SURPRISED?: float(name='SURPRISED'),
      }(name='EmotionDetails'),
      faceAttributes?: {
        beard?: string(name='Beard'),
        beardConfidence?: float(name='BeardConfidence'),
        faceBoundary?: {
          height?: int32(name='Height'),
          left?: int32(name='Left'),
          top?: int32(name='Top'),
          width?: int32(name='Width'),
        }(name='FaceBoundary'),
        glasses?: string(name='Glasses'),
        glassesConfidence?: float(name='GlassesConfidence'),
        headPose?: {
          pitch?: float(name='Pitch'),
          roll?: float(name='Roll'),
          yaw?: float(name='Yaw'),
        }(name='HeadPose'),
        mask?: string(name='Mask'),
        maskConfidence?: float(name='MaskConfidence'),
      }(name='FaceAttributes'),
      faceConfidence?: float(name='FaceConfidence'),
      faceId?: string(name='FaceId'),
      faceQuality?: float(name='FaceQuality'),
      gender?: string(name='Gender'),
      genderConfidence?: float(name='GenderConfidence'),
    }
  ](name='Faces'),
  imageUri?: string(name='ImageUri'),
  requestId?: string(name='RequestId'),
}

model DetectImageFacesResponse = {
  headers: map[string]string(name='headers'),
  body: DetectImageFacesResponseBody(name='body'),
}

async function detectImageFacesWithOptions(request: DetectImageFacesRequest, runtime: Util.RuntimeOptions): DetectImageFacesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.imageUri)) {
    query['ImageUri'] = request.imageUri;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DetectImageFaces',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detectImageFaces(request: DetectImageFacesRequest): DetectImageFacesResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectImageFacesWithOptions(request, runtime);
}

model DetectImageQRCodesRequest {
  imageUri?: string(name='ImageUri'),
  project?: string(name='Project'),
}

model DetectImageQRCodesResponseBody = {
  imageUri?: string(name='ImageUri'),
  QRCodes?: [ 
    {
      content?: string(name='Content'),
      QRCodeBoundary?: {
        height?: int32(name='Height'),
        left?: int32(name='Left'),
        top?: int32(name='Top'),
        width?: int32(name='Width'),
      }(name='QRCodeBoundary'),
    }
  ](name='QRCodes'),
  requestId?: string(name='RequestId'),
}

model DetectImageQRCodesResponse = {
  headers: map[string]string(name='headers'),
  body: DetectImageQRCodesResponseBody(name='body'),
}

async function detectImageQRCodesWithOptions(request: DetectImageQRCodesRequest, runtime: Util.RuntimeOptions): DetectImageQRCodesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.imageUri)) {
    query['ImageUri'] = request.imageUri;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DetectImageQRCodes',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detectImageQRCodes(request: DetectImageQRCodesRequest): DetectImageQRCodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectImageQRCodesWithOptions(request, runtime);
}

model DetectImageTagsRequest {
  imageUri?: string(name='ImageUri'),
  project?: string(name='Project'),
}

model DetectImageTagsResponseBody = {
  imageUri?: string(name='ImageUri'),
  requestId?: string(name='RequestId'),
  tags?: [ 
    {
      centricScore?: float(name='CentricScore'),
      parentTagEnName?: string(name='ParentTagEnName'),
      parentTagName?: string(name='ParentTagName'),
      tagConfidence?: float(name='TagConfidence'),
      tagEnName?: string(name='TagEnName'),
      tagLevel?: int32(name='TagLevel'),
      tagName?: string(name='TagName'),
    }
  ](name='Tags'),
}

model DetectImageTagsResponse = {
  headers: map[string]string(name='headers'),
  body: DetectImageTagsResponseBody(name='body'),
}

async function detectImageTagsWithOptions(request: DetectImageTagsRequest, runtime: Util.RuntimeOptions): DetectImageTagsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.imageUri)) {
    query['ImageUri'] = request.imageUri;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DetectImageTags',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detectImageTags(request: DetectImageTagsRequest): DetectImageTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectImageTagsWithOptions(request, runtime);
}

model DetectQRCodesRequest {
  project?: string(name='Project'),
  srcUris?: string(name='SrcUris'),
}

model DetectQRCodesResponseBody = {
  failDetails?: [ 
    {
      errorCode?: string(name='ErrorCode'),
      errorMessage?: string(name='ErrorMessage'),
      srcUri?: string(name='SrcUri'),
    }
  ](name='FailDetails'),
  requestId?: string(name='RequestId'),
  successDetails?: [ 
    {
      QRCodes?: [ 
        {
          content?: string(name='Content'),
          QRCodesRectangle?: {
            height?: string(name='Height'),
            left?: string(name='Left'),
            top?: string(name='Top'),
            width?: string(name='Width'),
          }(name='QRCodesRectangle'),
        }
      ](name='QRCodes'),
      srcUri?: string(name='SrcUri'),
    }
  ](name='SuccessDetails'),
}

model DetectQRCodesResponse = {
  headers: map[string]string(name='headers'),
  body: DetectQRCodesResponseBody(name='body'),
}

async function detectQRCodesWithOptions(request: DetectQRCodesRequest, runtime: Util.RuntimeOptions): DetectQRCodesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.srcUris)) {
    query['SrcUris'] = request.srcUris;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DetectQRCodes',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detectQRCodes(request: DetectQRCodesRequest): DetectQRCodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectQRCodesWithOptions(request, runtime);
}

model EncodeBlindWatermarkRequest {
  content?: string(name='Content'),
  imageQuality?: string(name='ImageQuality'),
  imageUri?: string(name='ImageUri'),
  model?: string(name='Model'),
  project?: string(name='Project'),
  targetImageType?: string(name='TargetImageType'),
  targetUri?: string(name='TargetUri'),
  watermarkUri?: string(name='WatermarkUri'),
}

model EncodeBlindWatermarkResponseBody = {
  content?: string(name='Content'),
  requestId?: string(name='RequestId'),
  targetUri?: string(name='TargetUri'),
}

model EncodeBlindWatermarkResponse = {
  headers: map[string]string(name='headers'),
  body: EncodeBlindWatermarkResponseBody(name='body'),
}

async function encodeBlindWatermarkWithOptions(request: EncodeBlindWatermarkRequest, runtime: Util.RuntimeOptions): EncodeBlindWatermarkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.content)) {
    query['Content'] = request.content;
  }
  if (!Util.isUnset(request.imageQuality)) {
    query['ImageQuality'] = request.imageQuality;
  }
  if (!Util.isUnset(request.imageUri)) {
    query['ImageUri'] = request.imageUri;
  }
  if (!Util.isUnset(request.model)) {
    query['Model'] = request.model;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.targetImageType)) {
    query['TargetImageType'] = request.targetImageType;
  }
  if (!Util.isUnset(request.targetUri)) {
    query['TargetUri'] = request.targetUri;
  }
  if (!Util.isUnset(request.watermarkUri)) {
    query['WatermarkUri'] = request.watermarkUri;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EncodeBlindWatermark',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function encodeBlindWatermark(request: EncodeBlindWatermarkRequest): EncodeBlindWatermarkResponse {
  var runtime = new Util.RuntimeOptions{};
  return encodeBlindWatermarkWithOptions(request, runtime);
}

model FindImagesRequest {
  addressLineContentsMatch?: string(name='AddressLineContentsMatch'),
  ageRange?: string(name='AgeRange'),
  createTimeRange?: string(name='CreateTimeRange'),
  emotion?: string(name='Emotion'),
  externalId?: string(name='ExternalId'),
  facesModifyTimeRange?: string(name='FacesModifyTimeRange'),
  gender?: string(name='Gender'),
  groupId?: string(name='GroupId'),
  imageSizeRange?: string(name='ImageSizeRange'),
  imageTimeRange?: string(name='ImageTimeRange'),
  limit?: int32(name='Limit'),
  locationBoundary?: string(name='LocationBoundary'),
  marker?: string(name='Marker'),
  modifyTimeRange?: string(name='ModifyTimeRange'),
  OCRContentsMatch?: string(name='OCRContentsMatch'),
  order?: string(name='Order'),
  orderBy?: string(name='OrderBy'),
  project?: string(name='Project'),
  remarksAPrefix?: string(name='RemarksAPrefix'),
  remarksArrayAIn?: string(name='RemarksArrayAIn'),
  remarksArrayBIn?: string(name='RemarksArrayBIn'),
  remarksBPrefix?: string(name='RemarksBPrefix'),
  remarksCPrefix?: string(name='RemarksCPrefix'),
  remarksDPrefix?: string(name='RemarksDPrefix'),
  setId?: string(name='SetId'),
  sourceType?: string(name='SourceType'),
  sourceUriPrefix?: string(name='SourceUriPrefix'),
  tagNames?: string(name='TagNames'),
  tagsModifyTimeRange?: string(name='TagsModifyTimeRange'),
}

model FindImagesResponseBody = {
  images?: [ 
    {
      address?: {
        addressLine?: string(name='AddressLine'),
        city?: string(name='City'),
        country?: string(name='Country'),
        district?: string(name='District'),
        province?: string(name='Province'),
        township?: string(name='Township'),
      }(name='Address'),
      addressFailReason?: string(name='AddressFailReason'),
      addressModifyTime?: string(name='AddressModifyTime'),
      addressStatus?: string(name='AddressStatus'),
      createTime?: string(name='CreateTime'),
      croppingSuggestion?: [ 
        {
          aspectRatio?: string(name='AspectRatio'),
          croppingBoundary?: {
            height?: int32(name='Height'),
            left?: int32(name='Left'),
            top?: int32(name='Top'),
            width?: int32(name='Width'),
          }(name='CroppingBoundary'),
          score?: float(name='Score'),
        }
      ](name='CroppingSuggestion'),
      croppingSuggestionFailReason?: string(name='CroppingSuggestionFailReason'),
      croppingSuggestionModifyTime?: string(name='CroppingSuggestionModifyTime'),
      croppingSuggestionStatus?: string(name='CroppingSuggestionStatus'),
      exif?: string(name='Exif'),
      externalId?: string(name='ExternalId'),
      faces?: [ 
        {
          age?: int32(name='Age'),
          attractive?: float(name='Attractive'),
          emotion?: string(name='Emotion'),
          emotionConfidence?: float(name='EmotionConfidence'),
          emotionDetails?: {
            ANGRY?: float(name='ANGRY'),
            CALM?: float(name='CALM'),
            DISGUSTED?: float(name='DISGUSTED'),
            HAPPY?: float(name='HAPPY'),
            SAD?: float(name='SAD'),
            SCARED?: float(name='SCARED'),
            SURPRISED?: float(name='SURPRISED'),
          }(name='EmotionDetails'),
          faceAttributes?: {
            beard?: string(name='Beard'),
            beardConfidence?: float(name='BeardConfidence'),
            faceBoundary?: {
              height?: int32(name='Height'),
              left?: int32(name='Left'),
              top?: int32(name='Top'),
              width?: int32(name='Width'),
            }(name='FaceBoundary'),
            glasses?: string(name='Glasses'),
            glassesConfidence?: float(name='GlassesConfidence'),
            headPose?: {
              pitch?: float(name='Pitch'),
              roll?: float(name='Roll'),
              yaw?: float(name='Yaw'),
            }(name='HeadPose'),
            mask?: string(name='Mask'),
            maskConfidence?: float(name='MaskConfidence'),
          }(name='FaceAttributes'),
          faceConfidence?: float(name='FaceConfidence'),
          faceId?: string(name='FaceId'),
          faceQuality?: float(name='FaceQuality'),
          gender?: string(name='Gender'),
          genderConfidence?: float(name='GenderConfidence'),
          groupId?: string(name='GroupId'),
        }
      ](name='Faces'),
      facesFailReason?: string(name='FacesFailReason'),
      facesModifyTime?: string(name='FacesModifyTime'),
      facesStatus?: string(name='FacesStatus'),
      fileSize?: int32(name='FileSize'),
      imageFormat?: string(name='ImageFormat'),
      imageHeight?: int32(name='ImageHeight'),
      imageQuality?: {
        clarity?: float(name='Clarity'),
        clarityScore?: float(name='ClarityScore'),
        color?: float(name='Color'),
        colorScore?: float(name='ColorScore'),
        compositionScore?: float(name='CompositionScore'),
        contrast?: float(name='Contrast'),
        contrastScore?: float(name='ContrastScore'),
        exposure?: float(name='Exposure'),
        exposureScore?: float(name='ExposureScore'),
        overallScore?: float(name='OverallScore'),
      }(name='ImageQuality'),
      imageQualityFailReason?: string(name='ImageQualityFailReason'),
      imageQualityModifyTime?: string(name='ImageQualityModifyTime'),
      imageQualityStatus?: string(name='ImageQualityStatus'),
      imageTime?: string(name='ImageTime'),
      imageUri?: string(name='ImageUri'),
      imageWidth?: int32(name='ImageWidth'),
      location?: string(name='Location'),
      modifyTime?: string(name='ModifyTime'),
      OCR?: [ 
        {
          OCRBoundary?: {
            height?: int32(name='Height'),
            left?: int32(name='Left'),
            top?: int32(name='Top'),
            width?: int32(name='Width'),
          }(name='OCRBoundary'),
          OCRConfidence?: float(name='OCRConfidence'),
          OCRContents?: string(name='OCRContents'),
        }
      ](name='OCR'),
      OCRFailReason?: string(name='OCRFailReason'),
      OCRModifyTime?: string(name='OCRModifyTime'),
      OCRStatus?: string(name='OCRStatus'),
      orientation?: string(name='Orientation'),
      remarksA?: string(name='RemarksA'),
      remarksArrayA?: string(name='RemarksArrayA'),
      remarksArrayB?: string(name='RemarksArrayB'),
      remarksB?: string(name='RemarksB'),
      remarksC?: string(name='RemarksC'),
      remarksD?: string(name='RemarksD'),
      sourcePosition?: string(name='SourcePosition'),
      sourceType?: string(name='SourceType'),
      sourceUri?: string(name='SourceUri'),
      tags?: [ 
        {
          centricScore?: float(name='CentricScore'),
          parentTagName?: string(name='ParentTagName'),
          tagConfidence?: float(name='TagConfidence'),
          tagLevel?: int32(name='TagLevel'),
          tagName?: string(name='TagName'),
        }
      ](name='Tags'),
      tagsFailReason?: string(name='TagsFailReason'),
      tagsModifyTime?: string(name='TagsModifyTime'),
      tagsStatus?: string(name='TagsStatus'),
    }
  ](name='Images'),
  nextMarker?: string(name='NextMarker'),
  requestId?: string(name='RequestId'),
  setId?: string(name='SetId'),
}

model FindImagesResponse = {
  headers: map[string]string(name='headers'),
  body: FindImagesResponseBody(name='body'),
}

async function findImagesWithOptions(request: FindImagesRequest, runtime: Util.RuntimeOptions): FindImagesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addressLineContentsMatch)) {
    query['AddressLineContentsMatch'] = request.addressLineContentsMatch;
  }
  if (!Util.isUnset(request.ageRange)) {
    query['AgeRange'] = request.ageRange;
  }
  if (!Util.isUnset(request.createTimeRange)) {
    query['CreateTimeRange'] = request.createTimeRange;
  }
  if (!Util.isUnset(request.emotion)) {
    query['Emotion'] = request.emotion;
  }
  if (!Util.isUnset(request.externalId)) {
    query['ExternalId'] = request.externalId;
  }
  if (!Util.isUnset(request.facesModifyTimeRange)) {
    query['FacesModifyTimeRange'] = request.facesModifyTimeRange;
  }
  if (!Util.isUnset(request.gender)) {
    query['Gender'] = request.gender;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.imageSizeRange)) {
    query['ImageSizeRange'] = request.imageSizeRange;
  }
  if (!Util.isUnset(request.imageTimeRange)) {
    query['ImageTimeRange'] = request.imageTimeRange;
  }
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.locationBoundary)) {
    query['LocationBoundary'] = request.locationBoundary;
  }
  if (!Util.isUnset(request.marker)) {
    query['Marker'] = request.marker;
  }
  if (!Util.isUnset(request.modifyTimeRange)) {
    query['ModifyTimeRange'] = request.modifyTimeRange;
  }
  if (!Util.isUnset(request.OCRContentsMatch)) {
    query['OCRContentsMatch'] = request.OCRContentsMatch;
  }
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['OrderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.remarksAPrefix)) {
    query['RemarksAPrefix'] = request.remarksAPrefix;
  }
  if (!Util.isUnset(request.remarksArrayAIn)) {
    query['RemarksArrayAIn'] = request.remarksArrayAIn;
  }
  if (!Util.isUnset(request.remarksArrayBIn)) {
    query['RemarksArrayBIn'] = request.remarksArrayBIn;
  }
  if (!Util.isUnset(request.remarksBPrefix)) {
    query['RemarksBPrefix'] = request.remarksBPrefix;
  }
  if (!Util.isUnset(request.remarksCPrefix)) {
    query['RemarksCPrefix'] = request.remarksCPrefix;
  }
  if (!Util.isUnset(request.remarksDPrefix)) {
    query['RemarksDPrefix'] = request.remarksDPrefix;
  }
  if (!Util.isUnset(request.setId)) {
    query['SetId'] = request.setId;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  if (!Util.isUnset(request.sourceUriPrefix)) {
    query['SourceUriPrefix'] = request.sourceUriPrefix;
  }
  if (!Util.isUnset(request.tagNames)) {
    query['TagNames'] = request.tagNames;
  }
  if (!Util.isUnset(request.tagsModifyTimeRange)) {
    query['TagsModifyTimeRange'] = request.tagsModifyTimeRange;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'FindImages',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function findImages(request: FindImagesRequest): FindImagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return findImagesWithOptions(request, runtime);
}

model FindSimilarFacesRequest {
  faceId?: string(name='FaceId'),
  imageUri?: string(name='ImageUri'),
  limit?: int32(name='Limit'),
  minSimilarity?: float(name='MinSimilarity'),
  project?: string(name='Project'),
  responseFormat?: string(name='ResponseFormat'),
  setId?: string(name='SetId'),
}

model FindSimilarFacesResponseBody = {
  faces?: [ 
    {
      externalId?: string(name='ExternalId'),
      faceAttributes?: {
        faceBoundary?: {
          height?: int32(name='Height'),
          left?: int32(name='Left'),
          top?: int32(name='Top'),
          width?: int32(name='Width'),
        }(name='FaceBoundary'),
      }(name='FaceAttributes'),
      faceId?: string(name='FaceId'),
      imageUri?: string(name='ImageUri'),
      similarFaces?: [ 
        {
          externalId?: string(name='ExternalId'),
          faceAttributes?: {
            faceBoundary?: {
              height?: int32(name='Height'),
              left?: int32(name='Left'),
              top?: int32(name='Top'),
              width?: int32(name='Width'),
            }(name='FaceBoundary'),
          }(name='FaceAttributes'),
          faceId?: string(name='FaceId'),
          imageUri?: string(name='ImageUri'),
          similarity?: float(name='Similarity'),
        }
      ](name='SimilarFaces'),
      similarity?: float(name='Similarity'),
    }
  ](name='Faces'),
  requestId?: string(name='RequestId'),
}

model FindSimilarFacesResponse = {
  headers: map[string]string(name='headers'),
  body: FindSimilarFacesResponseBody(name='body'),
}

async function findSimilarFacesWithOptions(request: FindSimilarFacesRequest, runtime: Util.RuntimeOptions): FindSimilarFacesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.faceId)) {
    query['FaceId'] = request.faceId;
  }
  if (!Util.isUnset(request.imageUri)) {
    query['ImageUri'] = request.imageUri;
  }
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.minSimilarity)) {
    query['MinSimilarity'] = request.minSimilarity;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.responseFormat)) {
    query['ResponseFormat'] = request.responseFormat;
  }
  if (!Util.isUnset(request.setId)) {
    query['SetId'] = request.setId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'FindSimilarFaces',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function findSimilarFaces(request: FindSimilarFacesRequest): FindSimilarFacesResponse {
  var runtime = new Util.RuntimeOptions{};
  return findSimilarFacesWithOptions(request, runtime);
}

model GetImageRequest {
  imageUri?: string(name='ImageUri'),
  project?: string(name='Project'),
  setId?: string(name='SetId'),
}

model GetImageResponseBody = {
  address?: {
    addressLine?: string(name='AddressLine'),
    city?: string(name='City'),
    country?: string(name='Country'),
    district?: string(name='District'),
    province?: string(name='Province'),
    township?: string(name='Township'),
  }(name='Address'),
  addressFailReason?: string(name='AddressFailReason'),
  addressModifyTime?: string(name='AddressModifyTime'),
  addressStatus?: string(name='AddressStatus'),
  createTime?: string(name='CreateTime'),
  croppingSuggestion?: [ 
    {
      aspectRatio?: string(name='AspectRatio'),
      croppingBoundary?: {
        height?: int32(name='Height'),
        left?: int32(name='Left'),
        top?: int32(name='Top'),
        width?: int32(name='Width'),
      }(name='CroppingBoundary'),
      score?: float(name='Score'),
    }
  ](name='CroppingSuggestion'),
  croppingSuggestionFailReason?: string(name='CroppingSuggestionFailReason'),
  croppingSuggestionModifyTime?: string(name='CroppingSuggestionModifyTime'),
  croppingSuggestionStatus?: string(name='CroppingSuggestionStatus'),
  exif?: string(name='Exif'),
  externalId?: string(name='ExternalId'),
  faces?: [ 
    {
      age?: string(name='Age'),
      attractive?: float(name='Attractive'),
      emotion?: string(name='Emotion'),
      emotionConfidence?: float(name='EmotionConfidence'),
      emotionDetails?: {
        ANGRY?: float(name='ANGRY'),
        CALM?: float(name='CALM'),
        DISGUSTED?: float(name='DISGUSTED'),
        HAPPY?: float(name='HAPPY'),
        SAD?: float(name='SAD'),
        SCARED?: float(name='SCARED'),
        SURPRISED?: float(name='SURPRISED'),
      }(name='EmotionDetails'),
      faceAttributes?: {
        beard?: string(name='Beard'),
        beardConfidence?: float(name='BeardConfidence'),
        faceBoundary?: {
          height?: int32(name='Height'),
          left?: int32(name='Left'),
          top?: int32(name='Top'),
          width?: int32(name='Width'),
        }(name='FaceBoundary'),
        glasses?: string(name='Glasses'),
        glassesConfidence?: float(name='GlassesConfidence'),
        headPose?: {
          pitch?: float(name='Pitch'),
          roll?: float(name='Roll'),
          yaw?: float(name='Yaw'),
        }(name='HeadPose'),
        mask?: string(name='Mask'),
        maskConfidence?: float(name='MaskConfidence'),
      }(name='FaceAttributes'),
      faceConfidence?: float(name='FaceConfidence'),
      faceId?: string(name='FaceId'),
      faceQuality?: float(name='FaceQuality'),
      gender?: string(name='Gender'),
      genderConfidence?: float(name='GenderConfidence'),
      groupId?: string(name='GroupId'),
    }
  ](name='Faces'),
  facesFailReason?: string(name='FacesFailReason'),
  facesModifyTime?: string(name='FacesModifyTime'),
  facesStatus?: string(name='FacesStatus'),
  fileSize?: int32(name='FileSize'),
  imageFormat?: string(name='ImageFormat'),
  imageHeight?: int32(name='ImageHeight'),
  imageQuality?: {
    clarity?: float(name='Clarity'),
    clarityScore?: float(name='ClarityScore'),
    color?: float(name='Color'),
    colorScore?: float(name='ColorScore'),
    compositionScore?: float(name='CompositionScore'),
    contrast?: float(name='Contrast'),
    contrastScore?: float(name='ContrastScore'),
    exposure?: float(name='Exposure'),
    exposureScore?: float(name='ExposureScore'),
    overallScore?: float(name='OverallScore'),
  }(name='ImageQuality'),
  imageQualityFailReason?: string(name='ImageQualityFailReason'),
  imageQualityModifyTime?: string(name='ImageQualityModifyTime'),
  imageQualityStatus?: string(name='ImageQualityStatus'),
  imageTime?: string(name='ImageTime'),
  imageUri?: string(name='ImageUri'),
  imageWidth?: int32(name='ImageWidth'),
  location?: string(name='Location'),
  modifyTime?: string(name='ModifyTime'),
  OCR?: [ 
    {
      OCRBoundary?: {
        height?: int32(name='Height'),
        left?: int32(name='Left'),
        top?: int32(name='Top'),
        width?: int32(name='Width'),
      }(name='OCRBoundary'),
      OCRConfidence?: float(name='OCRConfidence'),
      OCRContents?: string(name='OCRContents'),
    }
  ](name='OCR'),
  OCRFailReason?: string(name='OCRFailReason'),
  OCRModifyTime?: string(name='OCRModifyTime'),
  OCRStatus?: string(name='OCRStatus'),
  orientation?: string(name='Orientation'),
  remarksA?: string(name='RemarksA'),
  remarksArrayA?: string(name='RemarksArrayA'),
  remarksArrayB?: string(name='RemarksArrayB'),
  remarksB?: string(name='RemarksB'),
  remarksC?: string(name='RemarksC'),
  remarksD?: string(name='RemarksD'),
  requestId?: string(name='RequestId'),
  setId?: string(name='SetId'),
  sourcePosition?: string(name='SourcePosition'),
  sourceType?: string(name='SourceType'),
  sourceUri?: string(name='SourceUri'),
  tags?: [ 
    {
      centricScore?: float(name='CentricScore'),
      parentTagName?: string(name='ParentTagName'),
      tagConfidence?: float(name='TagConfidence'),
      tagLevel?: int32(name='TagLevel'),
      tagName?: string(name='TagName'),
    }
  ](name='Tags'),
  tagsFailReason?: string(name='TagsFailReason'),
  tagsModifyTime?: string(name='TagsModifyTime'),
  tagsStatus?: string(name='TagsStatus'),
}

model GetImageResponse = {
  headers: map[string]string(name='headers'),
  body: GetImageResponseBody(name='body'),
}

async function getImageWithOptions(request: GetImageRequest, runtime: Util.RuntimeOptions): GetImageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.imageUri)) {
    query['ImageUri'] = request.imageUri;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.setId)) {
    query['SetId'] = request.setId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetImage',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getImage(request: GetImageRequest): GetImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return getImageWithOptions(request, runtime);
}

model GetImageCroppingSuggestionsRequest {
  aspectRatios?: string(name='AspectRatios'),
  imageUri?: string(name='ImageUri'),
  project?: string(name='Project'),
}

model GetImageCroppingSuggestionsResponseBody = {
  croppingSuggestions?: [ 
    {
      aspectRatio?: string(name='AspectRatio'),
      croppingBoundary?: {
        height?: int32(name='Height'),
        left?: int32(name='Left'),
        top?: int32(name='Top'),
        width?: int32(name='Width'),
      }(name='CroppingBoundary'),
      score?: float(name='Score'),
    }
  ](name='CroppingSuggestions'),
  imageUri?: string(name='ImageUri'),
  requestId?: string(name='RequestId'),
}

model GetImageCroppingSuggestionsResponse = {
  headers: map[string]string(name='headers'),
  body: GetImageCroppingSuggestionsResponseBody(name='body'),
}

async function getImageCroppingSuggestionsWithOptions(request: GetImageCroppingSuggestionsRequest, runtime: Util.RuntimeOptions): GetImageCroppingSuggestionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aspectRatios)) {
    query['AspectRatios'] = request.aspectRatios;
  }
  if (!Util.isUnset(request.imageUri)) {
    query['ImageUri'] = request.imageUri;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetImageCroppingSuggestions',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getImageCroppingSuggestions(request: GetImageCroppingSuggestionsRequest): GetImageCroppingSuggestionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getImageCroppingSuggestionsWithOptions(request, runtime);
}

model GetImageQualityRequest {
  imageUri?: string(name='ImageUri'),
  project?: string(name='Project'),
}

model GetImageQualityResponseBody = {
  imageQuality?: {
    clarity?: float(name='Clarity'),
    clarityScore?: float(name='ClarityScore'),
    color?: float(name='Color'),
    colorScore?: float(name='ColorScore'),
    compositionScore?: float(name='CompositionScore'),
    contrast?: float(name='Contrast'),
    contrastScore?: float(name='ContrastScore'),
    exposure?: float(name='Exposure'),
    exposureScore?: float(name='ExposureScore'),
    overallScore?: float(name='OverallScore'),
  }(name='ImageQuality'),
  imageUri?: string(name='ImageUri'),
  requestId?: string(name='RequestId'),
}

model GetImageQualityResponse = {
  headers: map[string]string(name='headers'),
  body: GetImageQualityResponseBody(name='body'),
}

async function getImageQualityWithOptions(request: GetImageQualityRequest, runtime: Util.RuntimeOptions): GetImageQualityResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.imageUri)) {
    query['ImageUri'] = request.imageUri;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetImageQuality',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getImageQuality(request: GetImageQualityRequest): GetImageQualityResponse {
  var runtime = new Util.RuntimeOptions{};
  return getImageQualityWithOptions(request, runtime);
}

model GetMediaMetaRequest {
  mediaUri?: string(name='MediaUri'),
  project?: string(name='Project'),
}

model GetMediaMetaResponseBody = {
  mediaMeta?: {
    mediaFormat?: {
      address?: {
        addressLine?: string(name='AddressLine'),
        city?: string(name='City'),
        country?: string(name='Country'),
        district?: string(name='District'),
        province?: string(name='Province'),
        township?: string(name='Township'),
      }(name='Address'),
      bitrate?: string(name='Bitrate'),
      creationTime?: string(name='CreationTime'),
      duration?: string(name='Duration'),
      formatLongName?: string(name='FormatLongName'),
      formatName?: string(name='FormatName'),
      location?: string(name='Location'),
      numberPrograms?: int32(name='NumberPrograms'),
      numberStreams?: int32(name='NumberStreams'),
      size?: string(name='Size'),
      startTime?: string(name='StartTime'),
      tag?: {
        album?: string(name='Album'),
        albumArtist?: string(name='AlbumArtist'),
        artist?: string(name='Artist'),
        composer?: string(name='Composer'),
        creationTime?: string(name='CreationTime'),
        language?: string(name='Language'),
        performer?: string(name='Performer'),
        title?: string(name='Title'),
      }(name='Tag'),
    }(name='MediaFormat'),
    mediaStreams?: {
      audioStreams?: [ 
        {
          bitrate?: string(name='Bitrate'),
          channelLayout?: string(name='ChannelLayout'),
          channels?: int32(name='Channels'),
          codecLongName?: string(name='CodecLongName'),
          codecName?: string(name='CodecName'),
          codecTag?: string(name='CodecTag'),
          codecTagString?: string(name='CodecTagString'),
          codecTimeBase?: string(name='CodecTimeBase'),
          duration?: string(name='Duration'),
          frames?: string(name='Frames'),
          index?: int32(name='Index'),
          language?: string(name='Language'),
          sampleFormat?: string(name='SampleFormat'),
          sampleRate?: string(name='SampleRate'),
          startTime?: string(name='StartTime'),
          timeBase?: string(name='TimeBase'),
        }
      ](name='AudioStreams'),
      subtitleStreams?: [ 
        {
          index?: int32(name='Index'),
          language?: string(name='Language'),
        }
      ](name='SubtitleStreams'),
      videoStreams?: [ 
        {
          averageFrameRate?: string(name='AverageFrameRate'),
          bitrate?: string(name='Bitrate'),
          codecLongName?: string(name='CodecLongName'),
          codecName?: string(name='CodecName'),
          codecTag?: string(name='CodecTag'),
          codecTagString?: string(name='CodecTagString'),
          codecTimeBase?: string(name='CodecTimeBase'),
          displayAspectRatio?: string(name='DisplayAspectRatio'),
          duration?: string(name='Duration'),
          frameRrate?: string(name='FrameRrate'),
          frames?: string(name='Frames'),
          hasBFrames?: int32(name='HasBFrames'),
          height?: int32(name='Height'),
          index?: int32(name='Index'),
          language?: string(name='Language'),
          level?: int32(name='Level'),
          pixelFormat?: string(name='PixelFormat'),
          profile?: string(name='Profile'),
          rotate?: string(name='Rotate'),
          sampleAspectRatio?: string(name='SampleAspectRatio'),
          startTime?: string(name='StartTime'),
          timeBase?: string(name='TimeBase'),
          width?: int32(name='Width'),
        }
      ](name='VideoStreams'),
    }(name='MediaStreams'),
  }(name='MediaMeta'),
  mediaUri?: string(name='MediaUri'),
  requestId?: string(name='RequestId'),
}

model GetMediaMetaResponse = {
  headers: map[string]string(name='headers'),
  body: GetMediaMetaResponseBody(name='body'),
}

async function getMediaMetaWithOptions(request: GetMediaMetaRequest, runtime: Util.RuntimeOptions): GetMediaMetaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.mediaUri)) {
    query['MediaUri'] = request.mediaUri;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMediaMeta',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMediaMeta(request: GetMediaMetaRequest): GetMediaMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMediaMetaWithOptions(request, runtime);
}

model GetOfficeConversionTaskRequest {
  project?: string(name='Project'),
  taskId?: string(name='TaskId'),
}

model GetOfficeConversionTaskResponseBody = {
  createTime?: string(name='CreateTime'),
  externalID?: string(name='ExternalID'),
  failDetail?: {
    code?: string(name='Code'),
  }(name='FailDetail'),
  finishTime?: string(name='FinishTime'),
  imageSpec?: string(name='ImageSpec'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
  notifyTopicName?: string(name='NotifyTopicName'),
  pageCount?: int32(name='PageCount'),
  percent?: int32(name='Percent'),
  requestId?: string(name='RequestId'),
  srcUri?: string(name='SrcUri'),
  status?: string(name='Status'),
  taskId?: string(name='TaskId'),
  tgtType?: string(name='TgtType'),
  tgtUri?: string(name='TgtUri'),
}

model GetOfficeConversionTaskResponse = {
  headers: map[string]string(name='headers'),
  body: GetOfficeConversionTaskResponseBody(name='body'),
}

async function getOfficeConversionTaskWithOptions(request: GetOfficeConversionTaskRequest, runtime: Util.RuntimeOptions): GetOfficeConversionTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetOfficeConversionTask',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getOfficeConversionTask(request: GetOfficeConversionTaskRequest): GetOfficeConversionTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return getOfficeConversionTaskWithOptions(request, runtime);
}

model GetOfficePreviewURLRequest {
  project?: string(name='Project'),
  srcType?: string(name='SrcType'),
  srcUri?: string(name='SrcUri'),
  watermarkFillStyle?: string(name='WatermarkFillStyle'),
  watermarkFont?: string(name='WatermarkFont'),
  watermarkHorizontal?: int32(name='WatermarkHorizontal'),
  watermarkRotate?: float(name='WatermarkRotate'),
  watermarkType?: int32(name='WatermarkType'),
  watermarkValue?: string(name='WatermarkValue'),
  watermarkVertical?: int32(name='WatermarkVertical'),
}

model GetOfficePreviewURLResponseBody = {
  accessToken?: string(name='AccessToken'),
  accessTokenExpiredTime?: string(name='AccessTokenExpiredTime'),
  previewURL?: string(name='PreviewURL'),
  refreshToken?: string(name='RefreshToken'),
  refreshTokenExpiredTime?: string(name='RefreshTokenExpiredTime'),
  requestId?: string(name='RequestId'),
}

model GetOfficePreviewURLResponse = {
  headers: map[string]string(name='headers'),
  body: GetOfficePreviewURLResponseBody(name='body'),
}

async function getOfficePreviewURLWithOptions(request: GetOfficePreviewURLRequest, runtime: Util.RuntimeOptions): GetOfficePreviewURLResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.srcType)) {
    query['SrcType'] = request.srcType;
  }
  if (!Util.isUnset(request.srcUri)) {
    query['SrcUri'] = request.srcUri;
  }
  if (!Util.isUnset(request.watermarkFillStyle)) {
    query['WatermarkFillStyle'] = request.watermarkFillStyle;
  }
  if (!Util.isUnset(request.watermarkFont)) {
    query['WatermarkFont'] = request.watermarkFont;
  }
  if (!Util.isUnset(request.watermarkHorizontal)) {
    query['WatermarkHorizontal'] = request.watermarkHorizontal;
  }
  if (!Util.isUnset(request.watermarkRotate)) {
    query['WatermarkRotate'] = request.watermarkRotate;
  }
  if (!Util.isUnset(request.watermarkType)) {
    query['WatermarkType'] = request.watermarkType;
  }
  if (!Util.isUnset(request.watermarkValue)) {
    query['WatermarkValue'] = request.watermarkValue;
  }
  if (!Util.isUnset(request.watermarkVertical)) {
    query['WatermarkVertical'] = request.watermarkVertical;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetOfficePreviewURL',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getOfficePreviewURL(request: GetOfficePreviewURLRequest): GetOfficePreviewURLResponse {
  var runtime = new Util.RuntimeOptions{};
  return getOfficePreviewURLWithOptions(request, runtime);
}

model GetProjectRequest {
  project?: string(name='Project'),
}

model GetProjectResponseBody = {
  billingType?: string(name='BillingType'),
  CU?: int32(name='CU'),
  createTime?: string(name='CreateTime'),
  endpoint?: string(name='Endpoint'),
  modifyTime?: string(name='ModifyTime'),
  project?: string(name='Project'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  serviceRole?: string(name='ServiceRole'),
  type?: string(name='Type'),
}

model GetProjectResponse = {
  headers: map[string]string(name='headers'),
  body: GetProjectResponseBody(name='body'),
}

async function getProjectWithOptions(request: GetProjectRequest, runtime: Util.RuntimeOptions): GetProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetProject',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getProject(request: GetProjectRequest): GetProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return getProjectWithOptions(request, runtime);
}

model GetSetRequest {
  project?: string(name='Project'),
  setId?: string(name='SetId'),
}

model GetSetResponseBody = {
  createTime?: string(name='CreateTime'),
  faceCount?: int32(name='FaceCount'),
  imageCount?: int32(name='ImageCount'),
  modifyTime?: string(name='ModifyTime'),
  requestId?: string(name='RequestId'),
  setId?: string(name='SetId'),
  setName?: string(name='SetName'),
  videoCount?: int32(name='VideoCount'),
  videoLength?: int32(name='VideoLength'),
}

model GetSetResponse = {
  headers: map[string]string(name='headers'),
  body: GetSetResponseBody(name='body'),
}

async function getSetWithOptions(request: GetSetRequest, runtime: Util.RuntimeOptions): GetSetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.setId)) {
    query['SetId'] = request.setId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSet',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSet(request: GetSetRequest): GetSetResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSetWithOptions(request, runtime);
}

model GetVideoRequest {
  project?: string(name='Project'),
  setId?: string(name='SetId'),
  videoUri?: string(name='VideoUri'),
}

model GetVideoResponseBody = {
  createTime?: string(name='CreateTime'),
  externalId?: string(name='ExternalId'),
  fileSize?: int32(name='FileSize'),
  modifyTime?: string(name='ModifyTime'),
  processFailReason?: string(name='ProcessFailReason'),
  processModifyTime?: string(name='ProcessModifyTime'),
  processStatus?: string(name='ProcessStatus'),
  remarksA?: string(name='RemarksA'),
  remarksB?: string(name='RemarksB'),
  remarksC?: string(name='RemarksC'),
  remarksD?: string(name='RemarksD'),
  requestId?: string(name='RequestId'),
  setId?: string(name='SetId'),
  sourcePosition?: string(name='SourcePosition'),
  sourceType?: string(name='SourceType'),
  sourceUri?: string(name='SourceUri'),
  videoDuration?: float(name='VideoDuration'),
  videoFacesFailReason?: string(name='VideoFacesFailReason'),
  videoFacesModifyTime?: string(name='VideoFacesModifyTime'),
  videoFacesStatus?: string(name='VideoFacesStatus'),
  videoFormat?: string(name='VideoFormat'),
  videoFrameTagsFailReason?: string(name='VideoFrameTagsFailReason'),
  videoFrameTagsModifyTime?: string(name='VideoFrameTagsModifyTime'),
  videoFrameTagsStatus?: string(name='VideoFrameTagsStatus'),
  videoFrames?: int32(name='VideoFrames'),
  videoHeight?: int32(name='VideoHeight'),
  videoInfo?: string(name='VideoInfo'),
  videoOCRFailReason?: string(name='VideoOCRFailReason'),
  videoOCRModifyTime?: string(name='VideoOCRModifyTime'),
  videoOCRStatus?: string(name='VideoOCRStatus'),
  videoSTTFailReason?: string(name='VideoSTTFailReason'),
  videoSTTModifyTime?: string(name='VideoSTTModifyTime'),
  videoSTTStatus?: string(name='VideoSTTStatus'),
  videoTags?: [ 
    {
      parentTagName?: string(name='ParentTagName'),
      tagConfidence?: float(name='TagConfidence'),
      tagLevel?: int32(name='TagLevel'),
      tagName?: string(name='TagName'),
    }
  ](name='VideoTags'),
  videoTagsFailReason?: string(name='VideoTagsFailReason'),
  videoTagsModifyTime?: string(name='VideoTagsModifyTime'),
  videoTagsStatus?: string(name='VideoTagsStatus'),
  videoUri?: string(name='VideoUri'),
  videoWidth?: int32(name='VideoWidth'),
}

model GetVideoResponse = {
  headers: map[string]string(name='headers'),
  body: GetVideoResponseBody(name='body'),
}

async function getVideoWithOptions(request: GetVideoRequest, runtime: Util.RuntimeOptions): GetVideoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.setId)) {
    query['SetId'] = request.setId;
  }
  if (!Util.isUnset(request.videoUri)) {
    query['VideoUri'] = request.videoUri;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetVideo',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getVideo(request: GetVideoRequest): GetVideoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVideoWithOptions(request, runtime);
}

model GetVideoTaskRequest {
  project?: string(name='Project'),
  taskId?: string(name='TaskId'),
  taskType?: string(name='TaskType'),
}

model GetVideoTaskResponseBody = {
  endTime?: string(name='EndTime'),
  errorMessage?: string(name='ErrorMessage'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
  notifyTopicName?: string(name='NotifyTopicName'),
  parameters?: string(name='Parameters'),
  progress?: int32(name='Progress'),
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
  startTime?: string(name='StartTime'),
  status?: string(name='Status'),
  taskId?: string(name='TaskId'),
  taskType?: string(name='TaskType'),
}

model GetVideoTaskResponse = {
  headers: map[string]string(name='headers'),
  body: GetVideoTaskResponseBody(name='body'),
}

async function getVideoTaskWithOptions(request: GetVideoTaskRequest, runtime: Util.RuntimeOptions): GetVideoTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.taskType)) {
    query['TaskType'] = request.taskType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetVideoTask',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getVideoTask(request: GetVideoTaskRequest): GetVideoTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVideoTaskWithOptions(request, runtime);
}

model GetWebofficeURLRequest {
  file?: string(name='File'),
  fileID?: string(name='FileID'),
  hidecmb?: boolean(name='Hidecmb'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
  notifyTopicName?: string(name='NotifyTopicName'),
  permission?: string(name='Permission'),
  project?: string(name='Project'),
  srcType?: string(name='SrcType'),
  user?: string(name='User'),
  watermark?: string(name='Watermark'),
}

model GetWebofficeURLResponseBody = {
  accessToken?: string(name='AccessToken'),
  accessTokenExpiredTime?: string(name='AccessTokenExpiredTime'),
  refreshToken?: string(name='RefreshToken'),
  refreshTokenExpiredTime?: string(name='RefreshTokenExpiredTime'),
  requestId?: string(name='RequestId'),
  webofficeURL?: string(name='WebofficeURL'),
}

model GetWebofficeURLResponse = {
  headers: map[string]string(name='headers'),
  body: GetWebofficeURLResponseBody(name='body'),
}

async function getWebofficeURLWithOptions(request: GetWebofficeURLRequest, runtime: Util.RuntimeOptions): GetWebofficeURLResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.file)) {
    query['File'] = request.file;
  }
  if (!Util.isUnset(request.fileID)) {
    query['FileID'] = request.fileID;
  }
  if (!Util.isUnset(request.hidecmb)) {
    query['Hidecmb'] = request.hidecmb;
  }
  if (!Util.isUnset(request.notifyEndpoint)) {
    query['NotifyEndpoint'] = request.notifyEndpoint;
  }
  if (!Util.isUnset(request.notifyTopicName)) {
    query['NotifyTopicName'] = request.notifyTopicName;
  }
  if (!Util.isUnset(request.permission)) {
    query['Permission'] = request.permission;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.srcType)) {
    query['SrcType'] = request.srcType;
  }
  if (!Util.isUnset(request.user)) {
    query['User'] = request.user;
  }
  if (!Util.isUnset(request.watermark)) {
    query['Watermark'] = request.watermark;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetWebofficeURL',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getWebofficeURL(request: GetWebofficeURLRequest): GetWebofficeURLResponse {
  var runtime = new Util.RuntimeOptions{};
  return getWebofficeURLWithOptions(request, runtime);
}

model IndexImageRequest {
  externalId?: string(name='ExternalId'),
  imageUri?: string(name='ImageUri'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
  notifyTopicName?: string(name='NotifyTopicName'),
  project?: string(name='Project'),
  remarksA?: string(name='RemarksA'),
  remarksArrayA?: string(name='RemarksArrayA'),
  remarksArrayB?: string(name='RemarksArrayB'),
  remarksB?: string(name='RemarksB'),
  remarksC?: string(name='RemarksC'),
  remarksD?: string(name='RemarksD'),
  setId?: string(name='SetId'),
  sourcePosition?: string(name='SourcePosition'),
  sourceType?: string(name='SourceType'),
  sourceUri?: string(name='SourceUri'),
}

model IndexImageResponseBody = {
  createTime?: string(name='CreateTime'),
  externalId?: string(name='ExternalId'),
  imageUri?: string(name='ImageUri'),
  modifyTime?: string(name='ModifyTime'),
  remarksA?: string(name='RemarksA'),
  remarksArrayA?: string(name='RemarksArrayA'),
  remarksArrayB?: string(name='RemarksArrayB'),
  remarksB?: string(name='RemarksB'),
  remarksC?: string(name='RemarksC'),
  remarksD?: string(name='RemarksD'),
  requestId?: string(name='RequestId'),
  setId?: string(name='SetId'),
}

model IndexImageResponse = {
  headers: map[string]string(name='headers'),
  body: IndexImageResponseBody(name='body'),
}

async function indexImageWithOptions(request: IndexImageRequest, runtime: Util.RuntimeOptions): IndexImageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.externalId)) {
    query['ExternalId'] = request.externalId;
  }
  if (!Util.isUnset(request.imageUri)) {
    query['ImageUri'] = request.imageUri;
  }
  if (!Util.isUnset(request.notifyEndpoint)) {
    query['NotifyEndpoint'] = request.notifyEndpoint;
  }
  if (!Util.isUnset(request.notifyTopicName)) {
    query['NotifyTopicName'] = request.notifyTopicName;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.remarksA)) {
    query['RemarksA'] = request.remarksA;
  }
  if (!Util.isUnset(request.remarksArrayA)) {
    query['RemarksArrayA'] = request.remarksArrayA;
  }
  if (!Util.isUnset(request.remarksArrayB)) {
    query['RemarksArrayB'] = request.remarksArrayB;
  }
  if (!Util.isUnset(request.remarksB)) {
    query['RemarksB'] = request.remarksB;
  }
  if (!Util.isUnset(request.remarksC)) {
    query['RemarksC'] = request.remarksC;
  }
  if (!Util.isUnset(request.remarksD)) {
    query['RemarksD'] = request.remarksD;
  }
  if (!Util.isUnset(request.setId)) {
    query['SetId'] = request.setId;
  }
  if (!Util.isUnset(request.sourcePosition)) {
    query['SourcePosition'] = request.sourcePosition;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  if (!Util.isUnset(request.sourceUri)) {
    query['SourceUri'] = request.sourceUri;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'IndexImage',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function indexImage(request: IndexImageRequest): IndexImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return indexImageWithOptions(request, runtime);
}

model IndexVideoRequest {
  externalId?: string(name='ExternalId'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
  notifyTopicName?: string(name='NotifyTopicName'),
  project?: string(name='Project'),
  remarksA?: string(name='RemarksA'),
  remarksB?: string(name='RemarksB'),
  remarksC?: string(name='RemarksC'),
  remarksD?: string(name='RemarksD'),
  setId?: string(name='SetId'),
  tgtUri?: string(name='TgtUri'),
  videoUri?: string(name='VideoUri'),
}

model IndexVideoResponseBody = {
  createTime?: string(name='CreateTime'),
  externalId?: string(name='ExternalId'),
  modifyTime?: string(name='ModifyTime'),
  remarksA?: string(name='RemarksA'),
  remarksB?: string(name='RemarksB'),
  remarksC?: string(name='RemarksC'),
  remarksD?: string(name='RemarksD'),
  requestId?: string(name='RequestId'),
  setId?: string(name='SetId'),
  videoUri?: string(name='VideoUri'),
}

model IndexVideoResponse = {
  headers: map[string]string(name='headers'),
  body: IndexVideoResponseBody(name='body'),
}

async function indexVideoWithOptions(request: IndexVideoRequest, runtime: Util.RuntimeOptions): IndexVideoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.externalId)) {
    query['ExternalId'] = request.externalId;
  }
  if (!Util.isUnset(request.notifyEndpoint)) {
    query['NotifyEndpoint'] = request.notifyEndpoint;
  }
  if (!Util.isUnset(request.notifyTopicName)) {
    query['NotifyTopicName'] = request.notifyTopicName;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.remarksA)) {
    query['RemarksA'] = request.remarksA;
  }
  if (!Util.isUnset(request.remarksB)) {
    query['RemarksB'] = request.remarksB;
  }
  if (!Util.isUnset(request.remarksC)) {
    query['RemarksC'] = request.remarksC;
  }
  if (!Util.isUnset(request.remarksD)) {
    query['RemarksD'] = request.remarksD;
  }
  if (!Util.isUnset(request.setId)) {
    query['SetId'] = request.setId;
  }
  if (!Util.isUnset(request.tgtUri)) {
    query['TgtUri'] = request.tgtUri;
  }
  if (!Util.isUnset(request.videoUri)) {
    query['VideoUri'] = request.videoUri;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'IndexVideo',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function indexVideo(request: IndexVideoRequest): IndexVideoResponse {
  var runtime = new Util.RuntimeOptions{};
  return indexVideoWithOptions(request, runtime);
}

model ListFaceGroupsRequest {
  externalId?: string(name='ExternalId'),
  limit?: int32(name='Limit'),
  marker?: string(name='Marker'),
  order?: string(name='Order'),
  orderBy?: string(name='OrderBy'),
  project?: string(name='Project'),
  remarksAQuery?: string(name='RemarksAQuery'),
  remarksArrayAQuery?: string(name='RemarksArrayAQuery'),
  remarksArrayBQuery?: string(name='RemarksArrayBQuery'),
  remarksBQuery?: string(name='RemarksBQuery'),
  remarksCQuery?: string(name='RemarksCQuery'),
  remarksDQuery?: string(name='RemarksDQuery'),
  setId?: string(name='SetId'),
}

model ListFaceGroupsResponseBody = {
  faceGroups?: [ 
    {
      averageAge?: float(name='AverageAge'),
      createTime?: string(name='CreateTime'),
      externalId?: string(name='ExternalId'),
      faceCount?: int32(name='FaceCount'),
      gender?: string(name='Gender'),
      groupCoverFace?: {
        externalId?: string(name='ExternalId'),
        faceBoundary?: {
          height?: int32(name='Height'),
          left?: int32(name='Left'),
          top?: int32(name='Top'),
          width?: int32(name='Width'),
        }(name='FaceBoundary'),
        faceId?: string(name='FaceId'),
        imageHeight?: long(name='ImageHeight'),
        imageUri?: string(name='ImageUri'),
        imageWidth?: long(name='ImageWidth'),
      }(name='GroupCoverFace'),
      groupId?: string(name='GroupId'),
      groupName?: string(name='GroupName'),
      imageCount?: int32(name='ImageCount'),
      maxAge?: float(name='MaxAge'),
      minAge?: float(name='MinAge'),
      modifyTime?: string(name='ModifyTime'),
      remarksA?: string(name='RemarksA'),
      remarksArrayA?: string(name='RemarksArrayA'),
      remarksArrayB?: string(name='RemarksArrayB'),
      remarksB?: string(name='RemarksB'),
      remarksC?: string(name='RemarksC'),
      remarksD?: string(name='RemarksD'),
    }
  ](name='FaceGroups'),
  nextMarker?: string(name='NextMarker'),
  requestId?: string(name='RequestId'),
}

model ListFaceGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: ListFaceGroupsResponseBody(name='body'),
}

async function listFaceGroupsWithOptions(request: ListFaceGroupsRequest, runtime: Util.RuntimeOptions): ListFaceGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.externalId)) {
    query['ExternalId'] = request.externalId;
  }
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    query['Marker'] = request.marker;
  }
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['OrderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.remarksAQuery)) {
    query['RemarksAQuery'] = request.remarksAQuery;
  }
  if (!Util.isUnset(request.remarksArrayAQuery)) {
    query['RemarksArrayAQuery'] = request.remarksArrayAQuery;
  }
  if (!Util.isUnset(request.remarksArrayBQuery)) {
    query['RemarksArrayBQuery'] = request.remarksArrayBQuery;
  }
  if (!Util.isUnset(request.remarksBQuery)) {
    query['RemarksBQuery'] = request.remarksBQuery;
  }
  if (!Util.isUnset(request.remarksCQuery)) {
    query['RemarksCQuery'] = request.remarksCQuery;
  }
  if (!Util.isUnset(request.remarksDQuery)) {
    query['RemarksDQuery'] = request.remarksDQuery;
  }
  if (!Util.isUnset(request.setId)) {
    query['SetId'] = request.setId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFaceGroups',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFaceGroups(request: ListFaceGroupsRequest): ListFaceGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFaceGroupsWithOptions(request, runtime);
}

model ListImagesRequest {
  createTimeStart?: string(name='CreateTimeStart'),
  limit?: int32(name='Limit'),
  marker?: string(name='Marker'),
  project?: string(name='Project'),
  setId?: string(name='SetId'),
}

model ListImagesResponseBody = {
  images?: [ 
    {
      address?: {
        addressLine?: string(name='AddressLine'),
        city?: string(name='City'),
        country?: string(name='Country'),
        district?: string(name='District'),
        province?: string(name='Province'),
        township?: string(name='Township'),
      }(name='Address'),
      addressFailReason?: string(name='AddressFailReason'),
      addressModifyTime?: string(name='AddressModifyTime'),
      addressStatus?: string(name='AddressStatus'),
      createTime?: string(name='CreateTime'),
      croppingSuggestion?: [ 
        {
          aspectRatio?: string(name='AspectRatio'),
          croppingBoundary?: {
            height?: int32(name='Height'),
            left?: int32(name='Left'),
            top?: int32(name='Top'),
            width?: int32(name='Width'),
          }(name='CroppingBoundary'),
          score?: float(name='Score'),
        }
      ](name='CroppingSuggestion'),
      croppingSuggestionFailReason?: string(name='CroppingSuggestionFailReason'),
      croppingSuggestionModifyTime?: string(name='CroppingSuggestionModifyTime'),
      croppingSuggestionStatus?: string(name='CroppingSuggestionStatus'),
      exif?: string(name='Exif'),
      externalId?: string(name='ExternalId'),
      faces?: [ 
        {
          age?: int32(name='Age'),
          attractive?: float(name='Attractive'),
          emotion?: string(name='Emotion'),
          emotionConfidence?: float(name='EmotionConfidence'),
          emotionDetails?: {
            ANGRY?: float(name='ANGRY'),
            CALM?: float(name='CALM'),
            DISGUSTED?: float(name='DISGUSTED'),
            HAPPY?: float(name='HAPPY'),
            SAD?: float(name='SAD'),
            SCARED?: float(name='SCARED'),
            SURPRISED?: float(name='SURPRISED'),
          }(name='EmotionDetails'),
          faceAttributes?: {
            beard?: string(name='Beard'),
            beardConfidence?: float(name='BeardConfidence'),
            faceBoundary?: {
              height?: int32(name='Height'),
              left?: int32(name='Left'),
              top?: int32(name='Top'),
              width?: int32(name='Width'),
            }(name='FaceBoundary'),
            glasses?: string(name='Glasses'),
            glassesConfidence?: float(name='GlassesConfidence'),
            headPose?: {
              pitch?: float(name='Pitch'),
              roll?: float(name='Roll'),
              yaw?: float(name='Yaw'),
            }(name='HeadPose'),
            mask?: string(name='Mask'),
            maskConfidence?: float(name='MaskConfidence'),
          }(name='FaceAttributes'),
          faceConfidence?: float(name='FaceConfidence'),
          faceId?: string(name='FaceId'),
          faceQuality?: float(name='FaceQuality'),
          gender?: string(name='Gender'),
          genderConfidence?: float(name='GenderConfidence'),
          groupId?: string(name='GroupId'),
        }
      ](name='Faces'),
      facesFailReason?: string(name='FacesFailReason'),
      facesModifyTime?: string(name='FacesModifyTime'),
      facesStatus?: string(name='FacesStatus'),
      fileSize?: int32(name='FileSize'),
      imageFormat?: string(name='ImageFormat'),
      imageHeight?: int32(name='ImageHeight'),
      imageQuality?: {
        clarity?: float(name='Clarity'),
        clarityScore?: float(name='ClarityScore'),
        color?: float(name='Color'),
        colorScore?: float(name='ColorScore'),
        compositionScore?: float(name='CompositionScore'),
        contrast?: float(name='Contrast'),
        contrastScore?: float(name='ContrastScore'),
        exposure?: float(name='Exposure'),
        exposureScore?: float(name='ExposureScore'),
        overallScore?: float(name='OverallScore'),
      }(name='ImageQuality'),
      imageQualityFailReason?: string(name='ImageQualityFailReason'),
      imageQualityModifyTime?: string(name='ImageQualityModifyTime'),
      imageQualityStatus?: string(name='ImageQualityStatus'),
      imageTime?: string(name='ImageTime'),
      imageUri?: string(name='ImageUri'),
      imageWidth?: int32(name='ImageWidth'),
      location?: string(name='Location'),
      modifyTime?: string(name='ModifyTime'),
      OCR?: [ 
        {
          OCRBoundary?: {
            height?: int32(name='Height'),
            left?: int32(name='Left'),
            top?: int32(name='Top'),
            width?: int32(name='Width'),
          }(name='OCRBoundary'),
          OCRConfidence?: float(name='OCRConfidence'),
          OCRContents?: string(name='OCRContents'),
        }
      ](name='OCR'),
      OCRFailReason?: string(name='OCRFailReason'),
      OCRModifyTime?: string(name='OCRModifyTime'),
      OCRStatus?: string(name='OCRStatus'),
      orientation?: string(name='Orientation'),
      remarksA?: string(name='RemarksA'),
      remarksArrayA?: string(name='RemarksArrayA'),
      remarksArrayB?: string(name='RemarksArrayB'),
      remarksB?: string(name='RemarksB'),
      remarksC?: string(name='RemarksC'),
      remarksD?: string(name='RemarksD'),
      sourcePosition?: string(name='SourcePosition'),
      sourceType?: string(name='SourceType'),
      sourceUri?: string(name='SourceUri'),
      tags?: [ 
        {
          centricScore?: float(name='CentricScore'),
          parentTagName?: string(name='ParentTagName'),
          tagConfidence?: float(name='TagConfidence'),
          tagLevel?: int32(name='TagLevel'),
          tagName?: string(name='TagName'),
        }
      ](name='Tags'),
      tagsFailReason?: string(name='TagsFailReason'),
      tagsModifyTime?: string(name='TagsModifyTime'),
      tagsStatus?: string(name='TagsStatus'),
    }
  ](name='Images'),
  nextMarker?: string(name='NextMarker'),
  requestId?: string(name='RequestId'),
  setId?: string(name='SetId'),
}

model ListImagesResponse = {
  headers: map[string]string(name='headers'),
  body: ListImagesResponseBody(name='body'),
}

async function listImagesWithOptions(request: ListImagesRequest, runtime: Util.RuntimeOptions): ListImagesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.createTimeStart)) {
    query['CreateTimeStart'] = request.createTimeStart;
  }
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    query['Marker'] = request.marker;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.setId)) {
    query['SetId'] = request.setId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListImages',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listImages(request: ListImagesRequest): ListImagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listImagesWithOptions(request, runtime);
}

model ListOfficeConversionTaskRequest {
  marker?: string(name='Marker'),
  maxKeys?: int32(name='MaxKeys'),
  project?: string(name='Project'),
}

model ListOfficeConversionTaskResponseBody = {
  nextMarker?: string(name='NextMarker'),
  requestId?: string(name='RequestId'),
  tasks?: [ 
    {
      createTime?: string(name='CreateTime'),
      externalID?: string(name='ExternalID'),
      finishTime?: string(name='FinishTime'),
      imageSpec?: string(name='ImageSpec'),
      notifyEndpoint?: string(name='NotifyEndpoint'),
      notifyTopicName?: string(name='NotifyTopicName'),
      pageCount?: int32(name='PageCount'),
      percent?: int32(name='Percent'),
      srcUri?: string(name='SrcUri'),
      status?: string(name='Status'),
      taskId?: string(name='TaskId'),
      tgtType?: string(name='TgtType'),
      tgtUri?: string(name='TgtUri'),
    }
  ](name='Tasks'),
}

model ListOfficeConversionTaskResponse = {
  headers: map[string]string(name='headers'),
  body: ListOfficeConversionTaskResponseBody(name='body'),
}

async function listOfficeConversionTaskWithOptions(request: ListOfficeConversionTaskRequest, runtime: Util.RuntimeOptions): ListOfficeConversionTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.marker)) {
    query['Marker'] = request.marker;
  }
  if (!Util.isUnset(request.maxKeys)) {
    query['MaxKeys'] = request.maxKeys;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListOfficeConversionTask',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listOfficeConversionTask(request: ListOfficeConversionTaskRequest): ListOfficeConversionTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return listOfficeConversionTaskWithOptions(request, runtime);
}

model ListProjectsRequest {
  marker?: string(name='Marker'),
  maxKeys?: int32(name='MaxKeys'),
}

model ListProjectsResponseBody = {
  nextMarker?: string(name='NextMarker'),
  projects?: [ 
    {
      billingType?: string(name='BillingType'),
      CU?: int32(name='CU'),
      createTime?: string(name='CreateTime'),
      endpoint?: string(name='Endpoint'),
      modifyTime?: string(name='ModifyTime'),
      project?: string(name='Project'),
      regionId?: string(name='RegionId'),
      serviceRole?: string(name='ServiceRole'),
      type?: string(name='Type'),
    }
  ](name='Projects'),
  requestId?: string(name='RequestId'),
}

model ListProjectsResponse = {
  headers: map[string]string(name='headers'),
  body: ListProjectsResponseBody(name='body'),
}

async function listProjectsWithOptions(request: ListProjectsRequest, runtime: Util.RuntimeOptions): ListProjectsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.marker)) {
    query['Marker'] = request.marker;
  }
  if (!Util.isUnset(request.maxKeys)) {
    query['MaxKeys'] = request.maxKeys;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListProjects',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listProjects(request: ListProjectsRequest): ListProjectsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listProjectsWithOptions(request, runtime);
}

model ListSetTagsRequest {
  project?: string(name='Project'),
  setId?: string(name='SetId'),
}

model ListSetTagsResponseBody = {
  requestId?: string(name='RequestId'),
  setId?: string(name='SetId'),
  tags?: [ 
    {
      tagCount?: int32(name='TagCount'),
      tagLevel?: int32(name='TagLevel'),
      tagName?: string(name='TagName'),
    }
  ](name='Tags'),
}

model ListSetTagsResponse = {
  headers: map[string]string(name='headers'),
  body: ListSetTagsResponseBody(name='body'),
}

async function listSetTagsWithOptions(request: ListSetTagsRequest, runtime: Util.RuntimeOptions): ListSetTagsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.setId)) {
    query['SetId'] = request.setId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSetTags',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSetTags(request: ListSetTagsRequest): ListSetTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSetTagsWithOptions(request, runtime);
}

model ListSetsRequest {
  marker?: string(name='Marker'),
  project?: string(name='Project'),
}

model ListSetsResponseBody = {
  nextMarker?: string(name='NextMarker'),
  requestId?: string(name='RequestId'),
  sets?: [ 
    {
      createTime?: string(name='CreateTime'),
      faceCount?: int32(name='FaceCount'),
      imageCount?: int32(name='ImageCount'),
      modifyTime?: string(name='ModifyTime'),
      setId?: string(name='SetId'),
      setName?: string(name='SetName'),
      videoCount?: int32(name='VideoCount'),
      videoLength?: int32(name='VideoLength'),
    }
  ](name='Sets'),
}

model ListSetsResponse = {
  headers: map[string]string(name='headers'),
  body: ListSetsResponseBody(name='body'),
}

async function listSetsWithOptions(request: ListSetsRequest, runtime: Util.RuntimeOptions): ListSetsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.marker)) {
    query['Marker'] = request.marker;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSets',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSets(request: ListSetsRequest): ListSetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSetsWithOptions(request, runtime);
}

model ListVideoAudiosRequest {
  marker?: string(name='Marker'),
  project?: string(name='Project'),
  setId?: string(name='SetId'),
  videoUri?: string(name='VideoUri'),
}

model ListVideoAudiosResponseBody = {
  audios?: [ 
    {
      audioDuration?: float(name='AudioDuration'),
      audioFormat?: string(name='AudioFormat'),
      audioRate?: int32(name='AudioRate'),
      audioTexts?: [ 
        {
          beginTime?: float(name='BeginTime'),
          channelId?: int32(name='ChannelId'),
          confidence?: float(name='Confidence'),
          emotionValue?: float(name='EmotionValue'),
          endTime?: float(name='EndTime'),
          library?: string(name='Library'),
          person?: string(name='Person'),
          silenceDuration?: float(name='SilenceDuration'),
          speechRate?: int32(name='SpeechRate'),
          text?: string(name='Text'),
        }
      ](name='AudioTexts'),
      audioTextsFailReason?: string(name='AudioTextsFailReason'),
      audioTextsModifyTime?: string(name='AudioTextsModifyTime'),
      audioTextsStatus?: string(name='AudioTextsStatus'),
      audioUri?: string(name='AudioUri'),
      createTime?: string(name='CreateTime'),
      externalId?: string(name='ExternalId'),
      fileSize?: int32(name='FileSize'),
      modifyTime?: string(name='ModifyTime'),
      processFailReason?: string(name='ProcessFailReason'),
      processModifyTime?: string(name='ProcessModifyTime'),
      processStatus?: string(name='ProcessStatus'),
      remarksA?: string(name='RemarksA'),
      remarksB?: string(name='RemarksB'),
      remarksC?: string(name='RemarksC'),
      remarksD?: string(name='RemarksD'),
      sourcePosition?: string(name='SourcePosition'),
      sourceType?: string(name='SourceType'),
      sourceUri?: string(name='SourceUri'),
    }
  ](name='Audios'),
  nextMarker?: string(name='NextMarker'),
  requestId?: string(name='RequestId'),
  setId?: string(name='SetId'),
  videoUri?: string(name='VideoUri'),
}

model ListVideoAudiosResponse = {
  headers: map[string]string(name='headers'),
  body: ListVideoAudiosResponseBody(name='body'),
}

async function listVideoAudiosWithOptions(request: ListVideoAudiosRequest, runtime: Util.RuntimeOptions): ListVideoAudiosResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.marker)) {
    query['Marker'] = request.marker;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.setId)) {
    query['SetId'] = request.setId;
  }
  if (!Util.isUnset(request.videoUri)) {
    query['VideoUri'] = request.videoUri;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListVideoAudios',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listVideoAudios(request: ListVideoAudiosRequest): ListVideoAudiosResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVideoAudiosWithOptions(request, runtime);
}

model ListVideoFramesRequest {
  marker?: string(name='Marker'),
  project?: string(name='Project'),
  setId?: string(name='SetId'),
  videoUri?: string(name='VideoUri'),
}

model ListVideoFramesResponseBody = {
  frames?: [ 
    {
      createTime?: string(name='CreateTime'),
      exif?: string(name='Exif'),
      externalId?: string(name='ExternalId'),
      faces?: [ 
        {
          age?: int32(name='Age'),
          attractive?: float(name='Attractive'),
          emotion?: string(name='Emotion'),
          emotionConfidence?: float(name='EmotionConfidence'),
          emotionDetails?: {
            ANGRY?: float(name='ANGRY'),
            CALM?: float(name='CALM'),
            DISGUSTED?: float(name='DISGUSTED'),
            HAPPY?: float(name='HAPPY'),
            SAD?: float(name='SAD'),
            SCARED?: float(name='SCARED'),
            SURPRISED?: float(name='SURPRISED'),
          }(name='EmotionDetails'),
          faceAttributes?: {
            beard?: string(name='Beard'),
            beardConfidence?: float(name='BeardConfidence'),
            faceBoundary?: {
              height?: int32(name='Height'),
              left?: int32(name='Left'),
              top?: int32(name='Top'),
              width?: int32(name='Width'),
            }(name='FaceBoundary'),
            glasses?: string(name='Glasses'),
            glassesConfidence?: float(name='GlassesConfidence'),
            headPose?: {
              pitch?: float(name='Pitch'),
              roll?: float(name='Roll'),
              yaw?: float(name='Yaw'),
            }(name='HeadPose'),
            mask?: string(name='Mask'),
            maskConfidence?: float(name='MaskConfidence'),
          }(name='FaceAttributes'),
          faceConfidence?: float(name='FaceConfidence'),
          faceId?: string(name='FaceId'),
          faceQuality?: float(name='FaceQuality'),
          gender?: string(name='Gender'),
          genderConfidence?: float(name='GenderConfidence'),
          groupId?: string(name='GroupId'),
        }
      ](name='Faces'),
      facesFailReason?: string(name='FacesFailReason'),
      facesModifyTime?: string(name='FacesModifyTime'),
      facesStatus?: string(name='FacesStatus'),
      fileSize?: int32(name='FileSize'),
      imageFormat?: string(name='ImageFormat'),
      imageHeight?: int32(name='ImageHeight'),
      imageTime?: string(name='ImageTime'),
      imageUri?: string(name='ImageUri'),
      imageWidth?: int32(name='ImageWidth'),
      location?: string(name='Location'),
      modifyTime?: string(name='ModifyTime'),
      OCR?: [ 
        {
          OCRBoundary?: {
            height?: int32(name='Height'),
            left?: int32(name='Left'),
            top?: int32(name='Top'),
            width?: int32(name='Width'),
          }(name='OCRBoundary'),
          OCRConfidence?: float(name='OCRConfidence'),
          OCRContents?: string(name='OCRContents'),
        }
      ](name='OCR'),
      OCRFailReason?: string(name='OCRFailReason'),
      OCRModifyTime?: string(name='OCRModifyTime'),
      OCRStatus?: string(name='OCRStatus'),
      orientation?: string(name='Orientation'),
      remarksA?: string(name='RemarksA'),
      remarksB?: string(name='RemarksB'),
      remarksC?: string(name='RemarksC'),
      remarksD?: string(name='RemarksD'),
      sourcePosition?: string(name='SourcePosition'),
      sourceType?: string(name='SourceType'),
      sourceUri?: string(name='SourceUri'),
      tags?: [ 
        {
          parentTagName?: string(name='ParentTagName'),
          tagConfidence?: float(name='TagConfidence'),
          tagLevel?: int32(name='TagLevel'),
          tagName?: string(name='TagName'),
        }
      ](name='Tags'),
      tagsFailReason?: string(name='TagsFailReason'),
      tagsModifyTime?: string(name='TagsModifyTime'),
      tagsStatus?: string(name='TagsStatus'),
    }
  ](name='Frames'),
  nextMarker?: string(name='NextMarker'),
  requestId?: string(name='RequestId'),
  setId?: string(name='SetId'),
  videoUri?: string(name='VideoUri'),
}

model ListVideoFramesResponse = {
  headers: map[string]string(name='headers'),
  body: ListVideoFramesResponseBody(name='body'),
}

async function listVideoFramesWithOptions(request: ListVideoFramesRequest, runtime: Util.RuntimeOptions): ListVideoFramesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.marker)) {
    query['Marker'] = request.marker;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.setId)) {
    query['SetId'] = request.setId;
  }
  if (!Util.isUnset(request.videoUri)) {
    query['VideoUri'] = request.videoUri;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListVideoFrames',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listVideoFrames(request: ListVideoFramesRequest): ListVideoFramesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVideoFramesWithOptions(request, runtime);
}

model ListVideoTasksRequest {
  marker?: string(name='Marker'),
  maxKeys?: int32(name='MaxKeys'),
  project?: string(name='Project'),
  taskType?: string(name='TaskType'),
}

model ListVideoTasksResponseBody = {
  nextMarker?: string(name='NextMarker'),
  requestId?: string(name='RequestId'),
  tasks?: [ 
    {
      endTime?: string(name='EndTime'),
      errorMessage?: string(name='ErrorMessage'),
      notifyEndpoint?: string(name='NotifyEndpoint'),
      notifyTopicName?: string(name='NotifyTopicName'),
      parameters?: string(name='Parameters'),
      progress?: int32(name='Progress'),
      result?: string(name='Result'),
      startTime?: string(name='StartTime'),
      status?: string(name='Status'),
      taskId?: string(name='TaskId'),
      taskType?: string(name='TaskType'),
    }
  ](name='Tasks'),
}

model ListVideoTasksResponse = {
  headers: map[string]string(name='headers'),
  body: ListVideoTasksResponseBody(name='body'),
}

async function listVideoTasksWithOptions(request: ListVideoTasksRequest, runtime: Util.RuntimeOptions): ListVideoTasksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.marker)) {
    query['Marker'] = request.marker;
  }
  if (!Util.isUnset(request.maxKeys)) {
    query['MaxKeys'] = request.maxKeys;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.taskType)) {
    query['TaskType'] = request.taskType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListVideoTasks',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listVideoTasks(request: ListVideoTasksRequest): ListVideoTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVideoTasksWithOptions(request, runtime);
}

model ListVideosRequest {
  createTimeStart?: string(name='CreateTimeStart'),
  marker?: string(name='Marker'),
  project?: string(name='Project'),
  setId?: string(name='SetId'),
}

model ListVideosResponseBody = {
  nextMarker?: string(name='NextMarker'),
  requestId?: string(name='RequestId'),
  setId?: string(name='SetId'),
  videos?: [ 
    {
      createTime?: string(name='CreateTime'),
      externalId?: string(name='ExternalId'),
      fileSize?: int32(name='FileSize'),
      modifyTime?: string(name='ModifyTime'),
      processFailReason?: string(name='ProcessFailReason'),
      processModifyTime?: string(name='ProcessModifyTime'),
      processStatus?: string(name='ProcessStatus'),
      remarksA?: string(name='RemarksA'),
      remarksB?: string(name='RemarksB'),
      remarksC?: string(name='RemarksC'),
      remarksD?: string(name='RemarksD'),
      sourcePosition?: string(name='SourcePosition'),
      sourceType?: string(name='SourceType'),
      sourceUri?: string(name='SourceUri'),
      videoDuration?: float(name='VideoDuration'),
      videoFormat?: string(name='VideoFormat'),
      videoFrames?: int32(name='VideoFrames'),
      videoHeight?: int32(name='VideoHeight'),
      videoTags?: [ 
        {
          parentTagName?: string(name='ParentTagName'),
          tagConfidence?: float(name='TagConfidence'),
          tagLevel?: int32(name='TagLevel'),
          tagName?: string(name='TagName'),
        }
      ](name='VideoTags'),
      videoTagsFailReason?: string(name='VideoTagsFailReason'),
      videoTagsModifyTime?: string(name='VideoTagsModifyTime'),
      videoTagsStatus?: string(name='VideoTagsStatus'),
      videoUri?: string(name='VideoUri'),
      videoWidth?: int32(name='VideoWidth'),
    }
  ](name='Videos'),
}

model ListVideosResponse = {
  headers: map[string]string(name='headers'),
  body: ListVideosResponseBody(name='body'),
}

async function listVideosWithOptions(request: ListVideosRequest, runtime: Util.RuntimeOptions): ListVideosResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.createTimeStart)) {
    query['CreateTimeStart'] = request.createTimeStart;
  }
  if (!Util.isUnset(request.marker)) {
    query['Marker'] = request.marker;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.setId)) {
    query['SetId'] = request.setId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListVideos',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listVideos(request: ListVideosRequest): ListVideosResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVideosWithOptions(request, runtime);
}

model OpenImmServiceRequest {
  ownerId?: long(name='OwnerId'),
}

model OpenImmServiceResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model OpenImmServiceResponse = {
  headers: map[string]string(name='headers'),
  body: OpenImmServiceResponseBody(name='body'),
}

async function openImmServiceWithOptions(request: OpenImmServiceRequest, runtime: Util.RuntimeOptions): OpenImmServiceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OpenImmService',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function openImmService(request: OpenImmServiceRequest): OpenImmServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return openImmServiceWithOptions(request, runtime);
}

model PutProjectRequest {
  project?: string(name='Project'),
  serviceRole?: string(name='ServiceRole'),
}

model PutProjectResponseBody = {
  billingType?: string(name='BillingType'),
  CU?: int32(name='CU'),
  createTime?: string(name='CreateTime'),
  endpoint?: string(name='Endpoint'),
  modifyTime?: string(name='ModifyTime'),
  project?: string(name='Project'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  serviceRole?: string(name='ServiceRole'),
  type?: string(name='Type'),
}

model PutProjectResponse = {
  headers: map[string]string(name='headers'),
  body: PutProjectResponseBody(name='body'),
}

async function putProjectWithOptions(request: PutProjectRequest, runtime: Util.RuntimeOptions): PutProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.serviceRole)) {
    query['ServiceRole'] = request.serviceRole;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PutProject',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function putProject(request: PutProjectRequest): PutProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return putProjectWithOptions(request, runtime);
}

model RefreshOfficePreviewTokenRequest {
  accessToken?: string(name='AccessToken'),
  project?: string(name='Project'),
  refreshToken?: string(name='RefreshToken'),
}

model RefreshOfficePreviewTokenResponseBody = {
  accessToken?: string(name='AccessToken'),
  accessTokenExpiredTime?: string(name='AccessTokenExpiredTime'),
  refreshToken?: string(name='RefreshToken'),
  refreshTokenExpiredTime?: string(name='RefreshTokenExpiredTime'),
  requestId?: string(name='RequestId'),
}

model RefreshOfficePreviewTokenResponse = {
  headers: map[string]string(name='headers'),
  body: RefreshOfficePreviewTokenResponseBody(name='body'),
}

async function refreshOfficePreviewTokenWithOptions(request: RefreshOfficePreviewTokenRequest, runtime: Util.RuntimeOptions): RefreshOfficePreviewTokenResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.refreshToken)) {
    query['RefreshToken'] = request.refreshToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RefreshOfficePreviewToken',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function refreshOfficePreviewToken(request: RefreshOfficePreviewTokenRequest): RefreshOfficePreviewTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return refreshOfficePreviewTokenWithOptions(request, runtime);
}

model RefreshWebofficeTokenRequest {
  accessToken?: string(name='AccessToken'),
  project?: string(name='Project'),
  refreshToken?: string(name='RefreshToken'),
}

model RefreshWebofficeTokenResponseBody = {
  accessToken?: string(name='AccessToken'),
  accessTokenExpiredTime?: string(name='AccessTokenExpiredTime'),
  refreshToken?: string(name='RefreshToken'),
  refreshTokenExpiredTime?: string(name='RefreshTokenExpiredTime'),
  requestId?: string(name='RequestId'),
}

model RefreshWebofficeTokenResponse = {
  headers: map[string]string(name='headers'),
  body: RefreshWebofficeTokenResponseBody(name='body'),
}

async function refreshWebofficeTokenWithOptions(request: RefreshWebofficeTokenRequest, runtime: Util.RuntimeOptions): RefreshWebofficeTokenResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.refreshToken)) {
    query['RefreshToken'] = request.refreshToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RefreshWebofficeToken',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function refreshWebofficeToken(request: RefreshWebofficeTokenRequest): RefreshWebofficeTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return refreshWebofficeTokenWithOptions(request, runtime);
}

model UpdateFaceGroupRequest {
  externalId?: string(name='ExternalId'),
  groupCoverFaceId?: string(name='GroupCoverFaceId'),
  groupId?: string(name='GroupId'),
  groupName?: string(name='GroupName'),
  project?: string(name='Project'),
  remarksA?: string(name='RemarksA'),
  remarksArrayA?: string(name='RemarksArrayA'),
  remarksArrayB?: string(name='RemarksArrayB'),
  remarksB?: string(name='RemarksB'),
  remarksC?: string(name='RemarksC'),
  remarksD?: string(name='RemarksD'),
  resetItems?: string(name='ResetItems'),
  setId?: string(name='SetId'),
}

model UpdateFaceGroupResponseBody = {
  groupId?: string(name='GroupId'),
  requestId?: string(name='RequestId'),
  setId?: string(name='SetId'),
}

model UpdateFaceGroupResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateFaceGroupResponseBody(name='body'),
}

async function updateFaceGroupWithOptions(request: UpdateFaceGroupRequest, runtime: Util.RuntimeOptions): UpdateFaceGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.externalId)) {
    query['ExternalId'] = request.externalId;
  }
  if (!Util.isUnset(request.groupCoverFaceId)) {
    query['GroupCoverFaceId'] = request.groupCoverFaceId;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.remarksA)) {
    query['RemarksA'] = request.remarksA;
  }
  if (!Util.isUnset(request.remarksArrayA)) {
    query['RemarksArrayA'] = request.remarksArrayA;
  }
  if (!Util.isUnset(request.remarksArrayB)) {
    query['RemarksArrayB'] = request.remarksArrayB;
  }
  if (!Util.isUnset(request.remarksB)) {
    query['RemarksB'] = request.remarksB;
  }
  if (!Util.isUnset(request.remarksC)) {
    query['RemarksC'] = request.remarksC;
  }
  if (!Util.isUnset(request.remarksD)) {
    query['RemarksD'] = request.remarksD;
  }
  if (!Util.isUnset(request.resetItems)) {
    query['ResetItems'] = request.resetItems;
  }
  if (!Util.isUnset(request.setId)) {
    query['SetId'] = request.setId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateFaceGroup',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateFaceGroup(request: UpdateFaceGroupRequest): UpdateFaceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateFaceGroupWithOptions(request, runtime);
}

model UpdateImageRequest {
  externalId?: string(name='ExternalId'),
  faces?: [ 
    {
      faceId?: string(name='FaceId'),
      groupId?: string(name='GroupId'),
    }
  ](name='Faces'),
  imageUri?: string(name='ImageUri'),
  project?: string(name='Project'),
  remarksA?: string(name='RemarksA'),
  remarksArrayA?: string(name='RemarksArrayA'),
  remarksArrayB?: string(name='RemarksArrayB'),
  remarksB?: string(name='RemarksB'),
  remarksC?: string(name='RemarksC'),
  remarksD?: string(name='RemarksD'),
  setId?: string(name='SetId'),
  sourcePosition?: string(name='SourcePosition'),
  sourceType?: string(name='SourceType'),
  sourceUri?: string(name='SourceUri'),
}

model UpdateImageShrinkRequest {
  externalId?: string(name='ExternalId'),
  facesShrink?: string(name='Faces'),
  imageUri?: string(name='ImageUri'),
  project?: string(name='Project'),
  remarksA?: string(name='RemarksA'),
  remarksArrayA?: string(name='RemarksArrayA'),
  remarksArrayB?: string(name='RemarksArrayB'),
  remarksB?: string(name='RemarksB'),
  remarksC?: string(name='RemarksC'),
  remarksD?: string(name='RemarksD'),
  setId?: string(name='SetId'),
  sourcePosition?: string(name='SourcePosition'),
  sourceType?: string(name='SourceType'),
  sourceUri?: string(name='SourceUri'),
}

model UpdateImageResponseBody = {
  createTime?: string(name='CreateTime'),
  externalId?: string(name='ExternalId'),
  imageUri?: string(name='ImageUri'),
  modifyTime?: string(name='ModifyTime'),
  remarksA?: string(name='RemarksA'),
  remarksArrayA?: string(name='RemarksArrayA'),
  remarksArrayB?: string(name='RemarksArrayB'),
  remarksB?: string(name='RemarksB'),
  remarksC?: string(name='RemarksC'),
  remarksD?: string(name='RemarksD'),
  requestId?: string(name='RequestId'),
  setId?: string(name='SetId'),
}

model UpdateImageResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateImageResponseBody(name='body'),
}

async function updateImageWithOptions(tmpReq: UpdateImageRequest, runtime: Util.RuntimeOptions): UpdateImageResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateImageShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.faces)) {
    request.facesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.faces, 'Faces', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.externalId)) {
    query['ExternalId'] = request.externalId;
  }
  if (!Util.isUnset(request.facesShrink)) {
    query['Faces'] = request.facesShrink;
  }
  if (!Util.isUnset(request.imageUri)) {
    query['ImageUri'] = request.imageUri;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.remarksA)) {
    query['RemarksA'] = request.remarksA;
  }
  if (!Util.isUnset(request.remarksArrayA)) {
    query['RemarksArrayA'] = request.remarksArrayA;
  }
  if (!Util.isUnset(request.remarksArrayB)) {
    query['RemarksArrayB'] = request.remarksArrayB;
  }
  if (!Util.isUnset(request.remarksB)) {
    query['RemarksB'] = request.remarksB;
  }
  if (!Util.isUnset(request.remarksC)) {
    query['RemarksC'] = request.remarksC;
  }
  if (!Util.isUnset(request.remarksD)) {
    query['RemarksD'] = request.remarksD;
  }
  if (!Util.isUnset(request.setId)) {
    query['SetId'] = request.setId;
  }
  if (!Util.isUnset(request.sourcePosition)) {
    query['SourcePosition'] = request.sourcePosition;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  if (!Util.isUnset(request.sourceUri)) {
    query['SourceUri'] = request.sourceUri;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateImage',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateImage(request: UpdateImageRequest): UpdateImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateImageWithOptions(request, runtime);
}

model UpdateProjectRequest {
  newCU?: int32(name='NewCU'),
  newServiceRole?: string(name='NewServiceRole'),
  project?: string(name='Project'),
}

model UpdateProjectResponseBody = {
  CU?: int32(name='CU'),
  createTime?: string(name='CreateTime'),
  modifyTime?: string(name='ModifyTime'),
  project?: string(name='Project'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  serviceRole?: string(name='ServiceRole'),
  type?: string(name='Type'),
}

model UpdateProjectResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateProjectResponseBody(name='body'),
}

async function updateProjectWithOptions(request: UpdateProjectRequest, runtime: Util.RuntimeOptions): UpdateProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.newCU)) {
    query['NewCU'] = request.newCU;
  }
  if (!Util.isUnset(request.newServiceRole)) {
    query['NewServiceRole'] = request.newServiceRole;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateProject',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateProject(request: UpdateProjectRequest): UpdateProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateProjectWithOptions(request, runtime);
}

model UpdateSetRequest {
  project?: string(name='Project'),
  setId?: string(name='SetId'),
  setName?: string(name='SetName'),
}

model UpdateSetResponseBody = {
  createTime?: string(name='CreateTime'),
  modifyTime?: string(name='ModifyTime'),
  requestId?: string(name='RequestId'),
  setId?: string(name='SetId'),
  setName?: string(name='SetName'),
}

model UpdateSetResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateSetResponseBody(name='body'),
}

async function updateSetWithOptions(request: UpdateSetRequest, runtime: Util.RuntimeOptions): UpdateSetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.setId)) {
    query['SetId'] = request.setId;
  }
  if (!Util.isUnset(request.setName)) {
    query['SetName'] = request.setName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSet',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateSet(request: UpdateSetRequest): UpdateSetResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSetWithOptions(request, runtime);
}

