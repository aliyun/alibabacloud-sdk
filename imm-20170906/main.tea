/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
@endpointMap = {
    cn-beijing-gov-1 = 'imm-vpc.cn-beijing-gov-1.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('imm', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model CompareImageFacesRequest {
  project?: string(name='Project'),
  setId?: string(name='SetId'),
  imageUriA?: string(name='ImageUriA'),
  imageUriB?: string(name='ImageUriB'),
  faceIdA?: string(name='FaceIdA'),
  faceIdB?: string(name='FaceIdB'),
}

model CompareImageFacesResponseBody = {
  requestId?: string(name='RequestId'),
  similarity?: float(name='Similarity'),
  setId?: string(name='SetId'),
  faceA?: {
    faceId?: string(name='FaceId'),
    faceAttributes?: {
      faceBoundary?: {
        top?: int32(name='Top'),
        width?: int32(name='Width'),
        height?: int32(name='Height'),
        left?: int32(name='Left'),
      }(name='FaceBoundary'),
    }(name='FaceAttributes'),
  }(name='FaceA'),
  faceB?: {
    faceId?: string(name='FaceId'),
    faceAttributes?: {
      faceBoundary?: {
        top?: int32(name='Top'),
        width?: int32(name='Width'),
        height?: int32(name='Height'),
        left?: int32(name='Left'),
      }(name='FaceBoundary'),
    }(name='FaceAttributes'),
  }(name='FaceB'),
}

model CompareImageFacesResponse = {
  headers: map[string]string(name='headers'),
  body: CompareImageFacesResponseBody(name='body'),
}

async function compareImageFacesWithOptions(request: CompareImageFacesRequest, runtime: Util.RuntimeOptions): CompareImageFacesResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["SetId"] = request.setId;
  query["ImageUriA"] = request.imageUriA;
  query["ImageUriB"] = request.imageUriB;
  query["FaceIdA"] = request.faceIdA;
  query["FaceIdB"] = request.faceIdB;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CompareImageFaces',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function compareImageFaces(request: CompareImageFacesRequest): CompareImageFacesResponse {
  var runtime = new Util.RuntimeOptions{};
  return compareImageFacesWithOptions(request, runtime);
}

model ConvertOfficeFormatRequest {
  project?: string(name='Project'),
  srcUri?: string(name='SrcUri'),
  tgtType?: string(name='TgtType'),
  tgtUri?: string(name='TgtUri'),
  srcType?: string(name='SrcType'),
  startPage?: long(name='StartPage'),
  endPage?: long(name='EndPage'),
  maxSheetRow?: long(name='MaxSheetRow'),
  maxSheetCol?: long(name='MaxSheetCol'),
  maxSheetCount?: long(name='MaxSheetCount'),
  sheetOnePage?: boolean(name='SheetOnePage'),
  modelId?: string(name='ModelId'),
  password?: string(name='Password'),
  tgtFilePrefix?: string(name='TgtFilePrefix'),
  tgtFileSuffix?: string(name='TgtFileSuffix'),
  tgtFilePages?: string(name='TgtFilePages'),
  fitToPagesTall?: boolean(name='FitToPagesTall'),
  fitToPagesWide?: boolean(name='FitToPagesWide'),
  pdfVector?: boolean(name='PdfVector'),
  hidecomments?: boolean(name='Hidecomments'),
}

model ConvertOfficeFormatResponseBody = {
  pageCount?: int32(name='PageCount'),
  requestId?: string(name='RequestId'),
}

model ConvertOfficeFormatResponse = {
  headers: map[string]string(name='headers'),
  body: ConvertOfficeFormatResponseBody(name='body'),
}

async function convertOfficeFormatWithOptions(request: ConvertOfficeFormatRequest, runtime: Util.RuntimeOptions): ConvertOfficeFormatResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["SrcUri"] = request.srcUri;
  query["TgtType"] = request.tgtType;
  query["TgtUri"] = request.tgtUri;
  query["SrcType"] = request.srcType;
  query["StartPage"] = request.startPage;
  query["EndPage"] = request.endPage;
  query["MaxSheetRow"] = request.maxSheetRow;
  query["MaxSheetCol"] = request.maxSheetCol;
  query["MaxSheetCount"] = request.maxSheetCount;
  query["SheetOnePage"] = request.sheetOnePage;
  query["ModelId"] = request.modelId;
  query["Password"] = request.password;
  query["TgtFilePrefix"] = request.tgtFilePrefix;
  query["TgtFileSuffix"] = request.tgtFileSuffix;
  query["TgtFilePages"] = request.tgtFilePages;
  query["FitToPagesTall"] = request.fitToPagesTall;
  query["FitToPagesWide"] = request.fitToPagesWide;
  query["PdfVector"] = request.pdfVector;
  query["Hidecomments"] = request.hidecomments;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ConvertOfficeFormat',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function convertOfficeFormat(request: ConvertOfficeFormatRequest): ConvertOfficeFormatResponse {
  var runtime = new Util.RuntimeOptions{};
  return convertOfficeFormatWithOptions(request, runtime);
}

model CreateGrabFrameTaskRequest {
  project?: string(name='Project'),
  videoUri?: string(name='VideoUri'),
  notifyTopicName?: string(name='NotifyTopicName'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
  targetList?: string(name='TargetList'),
  customMessage?: string(name='CustomMessage'),
}

model CreateGrabFrameTaskResponseBody = {
  taskId?: string(name='TaskId'),
  requestId?: string(name='RequestId'),
  taskType?: string(name='TaskType'),
}

model CreateGrabFrameTaskResponse = {
  headers: map[string]string(name='headers'),
  body: CreateGrabFrameTaskResponseBody(name='body'),
}

async function createGrabFrameTaskWithOptions(request: CreateGrabFrameTaskRequest, runtime: Util.RuntimeOptions): CreateGrabFrameTaskResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["VideoUri"] = request.videoUri;
  query["NotifyTopicName"] = request.notifyTopicName;
  query["NotifyEndpoint"] = request.notifyEndpoint;
  query["TargetList"] = request.targetList;
  query["CustomMessage"] = request.customMessage;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateGrabFrameTask',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createGrabFrameTask(request: CreateGrabFrameTaskRequest): CreateGrabFrameTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createGrabFrameTaskWithOptions(request, runtime);
}

model CreateGroupFacesJobRequest {
  project?: string(name='Project'),
  setId?: string(name='SetId'),
  notifyTopicName?: string(name='NotifyTopicName'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
}

model CreateGroupFacesJobResponseBody = {
  jobType?: string(name='JobType'),
  requestId?: string(name='RequestId'),
  setId?: string(name='SetId'),
  jobId?: string(name='JobId'),
}

model CreateGroupFacesJobResponse = {
  headers: map[string]string(name='headers'),
  body: CreateGroupFacesJobResponseBody(name='body'),
}

async function createGroupFacesJobWithOptions(request: CreateGroupFacesJobRequest, runtime: Util.RuntimeOptions): CreateGroupFacesJobResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["SetId"] = request.setId;
  query["NotifyTopicName"] = request.notifyTopicName;
  query["NotifyEndpoint"] = request.notifyEndpoint;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateGroupFacesJob',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createGroupFacesJob(request: CreateGroupFacesJobRequest): CreateGroupFacesJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return createGroupFacesJobWithOptions(request, runtime);
}

model CreateImageProcessTaskRequest {
  project?: string(name='Project'),
  imageUri?: string(name='ImageUri'),
  notifyTopicName?: string(name='NotifyTopicName'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
  targetList?: string(name='TargetList'),
}

model CreateImageProcessTaskResponseBody = {
  taskId?: string(name='TaskId'),
  requestId?: string(name='RequestId'),
  taskType?: string(name='TaskType'),
}

model CreateImageProcessTaskResponse = {
  headers: map[string]string(name='headers'),
  body: CreateImageProcessTaskResponseBody(name='body'),
}

async function createImageProcessTaskWithOptions(request: CreateImageProcessTaskRequest, runtime: Util.RuntimeOptions): CreateImageProcessTaskResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["ImageUri"] = request.imageUri;
  query["NotifyTopicName"] = request.notifyTopicName;
  query["NotifyEndpoint"] = request.notifyEndpoint;
  query["TargetList"] = request.targetList;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateImageProcessTask',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createImageProcessTask(request: CreateImageProcessTaskRequest): CreateImageProcessTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createImageProcessTaskWithOptions(request, runtime);
}

model CreateMediaComplexTaskRequest {
  project?: string(name='Project'),
  parameters?: string(name='Parameters'),
  notifyTopicName?: string(name='NotifyTopicName'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
}

model CreateMediaComplexTaskResponseBody = {
  taskId?: string(name='TaskId'),
  requestId?: string(name='RequestId'),
  taskType?: string(name='TaskType'),
}

model CreateMediaComplexTaskResponse = {
  headers: map[string]string(name='headers'),
  body: CreateMediaComplexTaskResponseBody(name='body'),
}

async function createMediaComplexTaskWithOptions(request: CreateMediaComplexTaskRequest, runtime: Util.RuntimeOptions): CreateMediaComplexTaskResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["Parameters"] = request.parameters;
  query["NotifyTopicName"] = request.notifyTopicName;
  query["NotifyEndpoint"] = request.notifyEndpoint;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateMediaComplexTask',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMediaComplexTask(request: CreateMediaComplexTaskRequest): CreateMediaComplexTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMediaComplexTaskWithOptions(request, runtime);
}

model CreateMergeFaceGroupsJobRequest {
  project?: string(name='Project'),
  setId?: string(name='SetId'),
  notifyTopicName?: string(name='NotifyTopicName'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
  groupIdFrom?: string(name='GroupIdFrom'),
  groupIdTo?: string(name='GroupIdTo'),
}

model CreateMergeFaceGroupsJobResponseBody = {
  groupIdFrom?: string(name='GroupIdFrom'),
  jobType?: string(name='JobType'),
  requestId?: string(name='RequestId'),
  setId?: string(name='SetId'),
  groupIdTo?: string(name='GroupIdTo'),
  jobId?: string(name='JobId'),
}

model CreateMergeFaceGroupsJobResponse = {
  headers: map[string]string(name='headers'),
  body: CreateMergeFaceGroupsJobResponseBody(name='body'),
}

async function createMergeFaceGroupsJobWithOptions(request: CreateMergeFaceGroupsJobRequest, runtime: Util.RuntimeOptions): CreateMergeFaceGroupsJobResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["SetId"] = request.setId;
  query["NotifyTopicName"] = request.notifyTopicName;
  query["NotifyEndpoint"] = request.notifyEndpoint;
  query["GroupIdFrom"] = request.groupIdFrom;
  query["GroupIdTo"] = request.groupIdTo;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateMergeFaceGroupsJob',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMergeFaceGroupsJob(request: CreateMergeFaceGroupsJobRequest): CreateMergeFaceGroupsJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMergeFaceGroupsJobWithOptions(request, runtime);
}

model CreateOfficeConversionTaskRequest {
  project?: string(name='Project'),
  srcUri?: string(name='SrcUri'),
  tgtType?: string(name='TgtType'),
  tgtUri?: string(name='TgtUri'),
  notifyTopicName?: string(name='NotifyTopicName'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
  srcType?: string(name='SrcType'),
  startPage?: long(name='StartPage'),
  endPage?: long(name='EndPage'),
  maxSheetRow?: long(name='MaxSheetRow'),
  maxSheetCol?: long(name='MaxSheetCol'),
  maxSheetCount?: long(name='MaxSheetCount'),
  sheetOnePage?: boolean(name='SheetOnePage'),
  modelId?: string(name='ModelId'),
  password?: string(name='Password'),
  tgtFilePrefix?: string(name='TgtFilePrefix'),
  tgtFileSuffix?: string(name='TgtFileSuffix'),
  tgtFilePages?: string(name='TgtFilePages'),
  fitToPagesTall?: boolean(name='FitToPagesTall'),
  fitToPagesWide?: boolean(name='FitToPagesWide'),
  idempotentToken?: string(name='IdempotentToken'),
  pdfVector?: boolean(name='PdfVector'),
  hidecomments?: boolean(name='Hidecomments'),
  displayDpi?: int32(name='DisplayDpi'),
}

model CreateOfficeConversionTaskResponseBody = {
  status?: string(name='Status'),
  taskId?: string(name='TaskId'),
  requestId?: string(name='RequestId'),
  percent?: int32(name='Percent'),
  createTime?: string(name='CreateTime'),
  tgtLoc?: string(name='TgtLoc'),
}

model CreateOfficeConversionTaskResponse = {
  headers: map[string]string(name='headers'),
  body: CreateOfficeConversionTaskResponseBody(name='body'),
}

async function createOfficeConversionTaskWithOptions(request: CreateOfficeConversionTaskRequest, runtime: Util.RuntimeOptions): CreateOfficeConversionTaskResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["SrcUri"] = request.srcUri;
  query["TgtType"] = request.tgtType;
  query["TgtUri"] = request.tgtUri;
  query["NotifyTopicName"] = request.notifyTopicName;
  query["NotifyEndpoint"] = request.notifyEndpoint;
  query["SrcType"] = request.srcType;
  query["StartPage"] = request.startPage;
  query["EndPage"] = request.endPage;
  query["MaxSheetRow"] = request.maxSheetRow;
  query["MaxSheetCol"] = request.maxSheetCol;
  query["MaxSheetCount"] = request.maxSheetCount;
  query["SheetOnePage"] = request.sheetOnePage;
  query["ModelId"] = request.modelId;
  query["Password"] = request.password;
  query["TgtFilePrefix"] = request.tgtFilePrefix;
  query["TgtFileSuffix"] = request.tgtFileSuffix;
  query["TgtFilePages"] = request.tgtFilePages;
  query["FitToPagesTall"] = request.fitToPagesTall;
  query["FitToPagesWide"] = request.fitToPagesWide;
  query["IdempotentToken"] = request.idempotentToken;
  query["PdfVector"] = request.pdfVector;
  query["Hidecomments"] = request.hidecomments;
  query["DisplayDpi"] = request.displayDpi;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateOfficeConversionTask',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createOfficeConversionTask(request: CreateOfficeConversionTaskRequest): CreateOfficeConversionTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOfficeConversionTaskWithOptions(request, runtime);
}

model CreateSetRequest {
  project?: string(name='Project'),
  setId?: string(name='SetId'),
  setName?: string(name='SetName'),
}

model CreateSetResponseBody = {
  modifyTime?: string(name='ModifyTime'),
  videoCount?: int32(name='VideoCount'),
  imageCount?: int32(name='ImageCount'),
  requestId?: string(name='RequestId'),
  createTime?: string(name='CreateTime'),
  setName?: string(name='SetName'),
  setId?: string(name='SetId'),
  videoLength?: int32(name='VideoLength'),
  faceCount?: int32(name='FaceCount'),
}

model CreateSetResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSetResponseBody(name='body'),
}

async function createSetWithOptions(request: CreateSetRequest, runtime: Util.RuntimeOptions): CreateSetResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["SetId"] = request.setId;
  query["SetName"] = request.setName;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateSet',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createSet(request: CreateSetRequest): CreateSetResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSetWithOptions(request, runtime);
}

model CreateVideoAbstractTaskRequest {
  project?: string(name='Project'),
  videoUri?: string(name='VideoUri'),
  notifyTopicName?: string(name='NotifyTopicName'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
  targetVideoUri?: string(name='TargetVideoUri'),
  targetClipsUri?: string(name='TargetClipsUri'),
  abstractLength?: int32(name='AbstractLength'),
}

model CreateVideoAbstractTaskResponseBody = {
  taskId?: string(name='TaskId'),
  requestId?: string(name='RequestId'),
  taskType?: string(name='TaskType'),
}

model CreateVideoAbstractTaskResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVideoAbstractTaskResponseBody(name='body'),
}

async function createVideoAbstractTaskWithOptions(request: CreateVideoAbstractTaskRequest, runtime: Util.RuntimeOptions): CreateVideoAbstractTaskResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["VideoUri"] = request.videoUri;
  query["NotifyTopicName"] = request.notifyTopicName;
  query["NotifyEndpoint"] = request.notifyEndpoint;
  query["TargetVideoUri"] = request.targetVideoUri;
  query["TargetClipsUri"] = request.targetClipsUri;
  query["AbstractLength"] = request.abstractLength;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateVideoAbstractTask',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createVideoAbstractTask(request: CreateVideoAbstractTaskRequest): CreateVideoAbstractTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVideoAbstractTaskWithOptions(request, runtime);
}

model CreateVideoAnalyseTaskRequest {
  project?: string(name='Project'),
  videoUri?: string(name='VideoUri'),
  tgtUri?: string(name='TgtUri'),
  notifyTopicName?: string(name='NotifyTopicName'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
}

model CreateVideoAnalyseTaskResponseBody = {
  taskId?: string(name='TaskId'),
  requestId?: string(name='RequestId'),
  taskType?: string(name='TaskType'),
}

model CreateVideoAnalyseTaskResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVideoAnalyseTaskResponseBody(name='body'),
}

async function createVideoAnalyseTaskWithOptions(request: CreateVideoAnalyseTaskRequest, runtime: Util.RuntimeOptions): CreateVideoAnalyseTaskResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["VideoUri"] = request.videoUri;
  query["TgtUri"] = request.tgtUri;
  query["NotifyTopicName"] = request.notifyTopicName;
  query["NotifyEndpoint"] = request.notifyEndpoint;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateVideoAnalyseTask',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createVideoAnalyseTask(request: CreateVideoAnalyseTaskRequest): CreateVideoAnalyseTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVideoAnalyseTaskWithOptions(request, runtime);
}

model CreateVideoCompressTaskRequest {
  project?: string(name='Project'),
  videoUri?: string(name='VideoUri'),
  notifyTopicName?: string(name='NotifyTopicName'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
  targetList?: string(name='TargetList'),
  customMessage?: string(name='CustomMessage'),
  targetContainer?: string(name='TargetContainer'),
}

model CreateVideoCompressTaskResponseBody = {
  taskId?: string(name='TaskId'),
  requestId?: string(name='RequestId'),
  taskType?: string(name='TaskType'),
}

model CreateVideoCompressTaskResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVideoCompressTaskResponseBody(name='body'),
}

async function createVideoCompressTaskWithOptions(request: CreateVideoCompressTaskRequest, runtime: Util.RuntimeOptions): CreateVideoCompressTaskResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["VideoUri"] = request.videoUri;
  query["NotifyTopicName"] = request.notifyTopicName;
  query["NotifyEndpoint"] = request.notifyEndpoint;
  query["TargetList"] = request.targetList;
  query["CustomMessage"] = request.customMessage;
  query["TargetContainer"] = request.targetContainer;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateVideoCompressTask',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createVideoCompressTask(request: CreateVideoCompressTaskRequest): CreateVideoCompressTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVideoCompressTaskWithOptions(request, runtime);
}

model CreateVideoProduceTaskRequest {
  project?: string(name='Project'),
  images?: string(name='Images'),
  notifyTopicName?: string(name='NotifyTopicName'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
  targetUri?: string(name='TargetUri'),
  customMessage?: string(name='CustomMessage'),
  music?: string(name='Music'),
  width?: int32(name='Width'),
  height?: int32(name='Height'),
  templateName?: string(name='TemplateName'),
}

model CreateVideoProduceTaskResponseBody = {
  taskId?: string(name='TaskId'),
  requestId?: string(name='RequestId'),
  taskType?: string(name='TaskType'),
}

model CreateVideoProduceTaskResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVideoProduceTaskResponseBody(name='body'),
}

async function createVideoProduceTaskWithOptions(request: CreateVideoProduceTaskRequest, runtime: Util.RuntimeOptions): CreateVideoProduceTaskResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["Images"] = request.images;
  query["NotifyTopicName"] = request.notifyTopicName;
  query["NotifyEndpoint"] = request.notifyEndpoint;
  query["TargetUri"] = request.targetUri;
  query["CustomMessage"] = request.customMessage;
  query["Music"] = request.music;
  query["Width"] = request.width;
  query["Height"] = request.height;
  query["TemplateName"] = request.templateName;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateVideoProduceTask',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createVideoProduceTask(request: CreateVideoProduceTaskRequest): CreateVideoProduceTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVideoProduceTaskWithOptions(request, runtime);
}

model DecodeBlindWatermarkRequest {
  project?: string(name='Project'),
  imageUri?: string(name='ImageUri'),
  originalImageUri?: string(name='OriginalImageUri'),
  targetUri?: string(name='TargetUri'),
  imageQuality?: int32(name='ImageQuality'),
  model?: string(name='Model'),
}

model DecodeBlindWatermarkResponseBody = {
  requestId?: string(name='RequestId'),
  content?: string(name='Content'),
  targetUri?: string(name='TargetUri'),
}

model DecodeBlindWatermarkResponse = {
  headers: map[string]string(name='headers'),
  body: DecodeBlindWatermarkResponseBody(name='body'),
}

async function decodeBlindWatermarkWithOptions(request: DecodeBlindWatermarkRequest, runtime: Util.RuntimeOptions): DecodeBlindWatermarkResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["ImageUri"] = request.imageUri;
  query["OriginalImageUri"] = request.originalImageUri;
  query["TargetUri"] = request.targetUri;
  query["ImageQuality"] = request.imageQuality;
  query["Model"] = request.model;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DecodeBlindWatermark',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function decodeBlindWatermark(request: DecodeBlindWatermarkRequest): DecodeBlindWatermarkResponse {
  var runtime = new Util.RuntimeOptions{};
  return decodeBlindWatermarkWithOptions(request, runtime);
}

model DeleteImageRequest {
  project?: string(name='Project'),
  setId?: string(name='SetId'),
  imageUri?: string(name='ImageUri'),
}

model DeleteImageResponseBody = {
  requestId?: string(name='RequestId'),
  setId?: string(name='SetId'),
  imageUri?: string(name='ImageUri'),
}

model DeleteImageResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteImageResponseBody(name='body'),
}

async function deleteImageWithOptions(request: DeleteImageRequest, runtime: Util.RuntimeOptions): DeleteImageResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["SetId"] = request.setId;
  query["ImageUri"] = request.imageUri;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteImage',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteImage(request: DeleteImageRequest): DeleteImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteImageWithOptions(request, runtime);
}

model DeleteImageJobRequest {
  project?: string(name='Project'),
  jobType?: string(name='JobType'),
  jobId?: string(name='JobId'),
}

model DeleteImageJobResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteImageJobResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteImageJobResponseBody(name='body'),
}

async function deleteImageJobWithOptions(request: DeleteImageJobRequest, runtime: Util.RuntimeOptions): DeleteImageJobResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["JobType"] = request.jobType;
  query["JobId"] = request.jobId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteImageJob',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteImageJob(request: DeleteImageJobRequest): DeleteImageJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteImageJobWithOptions(request, runtime);
}

model DeleteOfficeConversionTaskRequest {
  project?: string(name='Project'),
  taskId?: string(name='TaskId'),
}

model DeleteOfficeConversionTaskResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteOfficeConversionTaskResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteOfficeConversionTaskResponseBody(name='body'),
}

async function deleteOfficeConversionTaskWithOptions(request: DeleteOfficeConversionTaskRequest, runtime: Util.RuntimeOptions): DeleteOfficeConversionTaskResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["TaskId"] = request.taskId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteOfficeConversionTask',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteOfficeConversionTask(request: DeleteOfficeConversionTaskRequest): DeleteOfficeConversionTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteOfficeConversionTaskWithOptions(request, runtime);
}

model DeleteProjectRequest {
  project?: string(name='Project'),
}

model DeleteProjectResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteProjectResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteProjectResponseBody(name='body'),
}

async function deleteProjectWithOptions(request: DeleteProjectRequest, runtime: Util.RuntimeOptions): DeleteProjectResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteProject',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteProject(request: DeleteProjectRequest): DeleteProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteProjectWithOptions(request, runtime);
}

model DeleteSetRequest {
  project?: string(name='Project'),
  setId?: string(name='SetId'),
}

model DeleteSetResponseBody = {
  requestId?: string(name='RequestId'),
  setId?: string(name='SetId'),
}

model DeleteSetResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSetResponseBody(name='body'),
}

async function deleteSetWithOptions(request: DeleteSetRequest, runtime: Util.RuntimeOptions): DeleteSetResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["SetId"] = request.setId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSet',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSet(request: DeleteSetRequest): DeleteSetResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSetWithOptions(request, runtime);
}

model DeleteVideoRequest {
  project?: string(name='Project'),
  setId?: string(name='SetId'),
  videoUri?: string(name='VideoUri'),
  resources?: boolean(name='Resources'),
}

model DeleteVideoResponseBody = {
  requestId?: string(name='RequestId'),
  videoUri?: string(name='VideoUri'),
  setId?: string(name='SetId'),
}

model DeleteVideoResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVideoResponseBody(name='body'),
}

async function deleteVideoWithOptions(request: DeleteVideoRequest, runtime: Util.RuntimeOptions): DeleteVideoResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["SetId"] = request.setId;
  query["VideoUri"] = request.videoUri;
  query["Resources"] = request.resources;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteVideo',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteVideo(request: DeleteVideoRequest): DeleteVideoResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVideoWithOptions(request, runtime);
}

model DeleteVideoTaskRequest {
  project?: string(name='Project'),
  taskType?: string(name='TaskType'),
  taskId?: string(name='TaskId'),
}

model DeleteVideoTaskResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVideoTaskResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVideoTaskResponseBody(name='body'),
}

async function deleteVideoTaskWithOptions(request: DeleteVideoTaskRequest, runtime: Util.RuntimeOptions): DeleteVideoTaskResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["TaskType"] = request.taskType;
  query["TaskId"] = request.taskId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteVideoTask',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteVideoTask(request: DeleteVideoTaskRequest): DeleteVideoTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVideoTaskWithOptions(request, runtime);
}

model DescribeRegionsResponseBody = {
  requestId?: string(name='RequestId'),
  regions?: {
    region?: [ 
      {
        projectTypes?: [ string ](name='ProjectTypes'),
        regionId?: string(name='RegionId'),
      }
    ](name='Region'),
  }(name='Regions'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegionsWithOptions(runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeRegions',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRegions(): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(runtime);
}

model DetectImageBodiesRequest {
  project?: string(name='Project'),
  imageUri?: string(name='ImageUri'),
}

model DetectImageBodiesResponseBody = {
  requestId?: string(name='RequestId'),
  bodies?: [ 
    {
      bodyConfidence?: float(name='BodyConfidence'),
      bodyBoundary?: {
        top?: int32(name='Top'),
        width?: int32(name='Width'),
        height?: int32(name='Height'),
        left?: int32(name='Left'),
      }(name='BodyBoundary'),
    }
  ](name='Bodies'),
  imageUri?: string(name='ImageUri'),
}

model DetectImageBodiesResponse = {
  headers: map[string]string(name='headers'),
  body: DetectImageBodiesResponseBody(name='body'),
}

async function detectImageBodiesWithOptions(request: DetectImageBodiesRequest, runtime: Util.RuntimeOptions): DetectImageBodiesResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["ImageUri"] = request.imageUri;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DetectImageBodies',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detectImageBodies(request: DetectImageBodiesRequest): DetectImageBodiesResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectImageBodiesWithOptions(request, runtime);
}

model DetectImageFacesRequest {
  project?: string(name='Project'),
  imageUri?: string(name='ImageUri'),
}

model DetectImageFacesResponseBody = {
  requestId?: string(name='RequestId'),
  imageUri?: string(name='ImageUri'),
  faces?: [ 
    {
      attractiveConfidence?: float(name='AttractiveConfidence'),
      gender?: string(name='Gender'),
      genderConfidence?: float(name='GenderConfidence'),
      faceId?: string(name='FaceId'),
      faceAttributes?: {
        glassesConfidence?: float(name='GlassesConfidence'),
        glasses?: string(name='Glasses'),
        mask?: string(name='Mask'),
        beardConfidence?: float(name='BeardConfidence'),
        maskConfidence?: float(name='MaskConfidence'),
        faceBoundary?: {
          top?: int32(name='Top'),
          width?: int32(name='Width'),
          height?: int32(name='Height'),
          left?: int32(name='Left'),
        }(name='FaceBoundary'),
        headPose?: {
          pitch?: float(name='Pitch'),
          roll?: float(name='Roll'),
          yaw?: float(name='Yaw'),
        }(name='HeadPose'),
        beard?: string(name='Beard'),
      }(name='FaceAttributes'),
      faceQuality?: float(name='FaceQuality'),
      emotion?: string(name='Emotion'),
      age?: int32(name='Age'),
      faceConfidence?: float(name='FaceConfidence'),
      emotionConfidence?: float(name='EmotionConfidence'),
      attractive?: float(name='Attractive'),
      ageConfidence?: float(name='AgeConfidence'),
      emotionDetails?: {
        HAPPY?: float(name='HAPPY'),
        CALM?: float(name='CALM'),
        SURPRISED?: float(name='SURPRISED'),
        DISGUSTED?: float(name='DISGUSTED'),
        ANGRY?: float(name='ANGRY'),
        SAD?: float(name='SAD'),
        SCARED?: float(name='SCARED'),
      }(name='EmotionDetails'),
    }
  ](name='Faces'),
}

model DetectImageFacesResponse = {
  headers: map[string]string(name='headers'),
  body: DetectImageFacesResponseBody(name='body'),
}

async function detectImageFacesWithOptions(request: DetectImageFacesRequest, runtime: Util.RuntimeOptions): DetectImageFacesResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["ImageUri"] = request.imageUri;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DetectImageFaces',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detectImageFaces(request: DetectImageFacesRequest): DetectImageFacesResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectImageFacesWithOptions(request, runtime);
}

model DetectImageLogosRequest {
  project?: string(name='Project'),
  imageUri?: string(name='ImageUri'),
}

model DetectImageLogosResponseBody = {
  requestId?: string(name='RequestId'),
  logos?: [ 
    {
      logoConfidence?: float(name='LogoConfidence'),
      logoBoundary?: {
        top?: int32(name='Top'),
        width?: int32(name='Width'),
        height?: int32(name='Height'),
        left?: int32(name='Left'),
      }(name='LogoBoundary'),
      logoName?: string(name='LogoName'),
    }
  ](name='Logos'),
  imageUri?: string(name='ImageUri'),
}

model DetectImageLogosResponse = {
  headers: map[string]string(name='headers'),
  body: DetectImageLogosResponseBody(name='body'),
}

async function detectImageLogosWithOptions(request: DetectImageLogosRequest, runtime: Util.RuntimeOptions): DetectImageLogosResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["ImageUri"] = request.imageUri;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DetectImageLogos',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detectImageLogos(request: DetectImageLogosRequest): DetectImageLogosResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectImageLogosWithOptions(request, runtime);
}

model DetectImageQRCodesRequest {
  project?: string(name='Project'),
  imageUri?: string(name='ImageUri'),
}

model DetectImageQRCodesResponseBody = {
  requestId?: string(name='RequestId'),
  imageUri?: string(name='ImageUri'),
  QRCodes?: [ 
    {
      content?: string(name='Content'),
      QRCodeBoundary?: {
        top?: int32(name='Top'),
        width?: int32(name='Width'),
        height?: int32(name='Height'),
        left?: int32(name='Left'),
      }(name='QRCodeBoundary'),
    }
  ](name='QRCodes'),
}

model DetectImageQRCodesResponse = {
  headers: map[string]string(name='headers'),
  body: DetectImageQRCodesResponseBody(name='body'),
}

async function detectImageQRCodesWithOptions(request: DetectImageQRCodesRequest, runtime: Util.RuntimeOptions): DetectImageQRCodesResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["ImageUri"] = request.imageUri;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DetectImageQRCodes',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detectImageQRCodes(request: DetectImageQRCodesRequest): DetectImageQRCodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectImageQRCodesWithOptions(request, runtime);
}

model DetectImageTagsRequest {
  project?: string(name='Project'),
  imageUri?: string(name='ImageUri'),
}

model DetectImageTagsResponseBody = {
  requestId?: string(name='RequestId'),
  imageUri?: string(name='ImageUri'),
  tags?: [ 
    {
      parentTagEnName?: string(name='ParentTagEnName'),
      tagName?: string(name='TagName'),
      tagConfidence?: float(name='TagConfidence'),
      tagEnName?: string(name='TagEnName'),
      tagLevel?: int32(name='TagLevel'),
      parentTagName?: string(name='ParentTagName'),
    }
  ](name='Tags'),
}

model DetectImageTagsResponse = {
  headers: map[string]string(name='headers'),
  body: DetectImageTagsResponseBody(name='body'),
}

async function detectImageTagsWithOptions(request: DetectImageTagsRequest, runtime: Util.RuntimeOptions): DetectImageTagsResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["ImageUri"] = request.imageUri;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DetectImageTags',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detectImageTags(request: DetectImageTagsRequest): DetectImageTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectImageTagsWithOptions(request, runtime);
}

model DetectQRCodesRequest {
  project?: string(name='Project'),
  srcUris?: string(name='SrcUris'),
}

model DetectQRCodesResponseBody = {
  successDetails?: [ 
    {
      srcUri?: string(name='SrcUri'),
      QRCodes?: [ 
        {
          QRCodesRectangle?: {
            top?: string(name='Top'),
            width?: string(name='Width'),
            height?: string(name='Height'),
            left?: string(name='Left'),
          }(name='QRCodesRectangle'),
          content?: string(name='Content'),
        }
      ](name='QRCodes'),
    }
  ](name='SuccessDetails'),
  requestId?: string(name='RequestId'),
  failDetails?: [ 
    {
      errorMessage?: string(name='ErrorMessage'),
      srcUri?: string(name='SrcUri'),
      errorCode?: string(name='ErrorCode'),
    }
  ](name='FailDetails'),
}

model DetectQRCodesResponse = {
  headers: map[string]string(name='headers'),
  body: DetectQRCodesResponseBody(name='body'),
}

async function detectQRCodesWithOptions(request: DetectQRCodesRequest, runtime: Util.RuntimeOptions): DetectQRCodesResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["SrcUris"] = request.srcUris;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DetectQRCodes',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detectQRCodes(request: DetectQRCodesRequest): DetectQRCodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectQRCodesWithOptions(request, runtime);
}

model EncodeBlindWatermarkRequest {
  project?: string(name='Project'),
  imageUri?: string(name='ImageUri'),
  watermarkUri?: string(name='WatermarkUri'),
  targetUri?: string(name='TargetUri'),
  imageQuality?: string(name='ImageQuality'),
  content?: string(name='Content'),
  targetImageType?: string(name='TargetImageType'),
  model?: string(name='Model'),
}

model EncodeBlindWatermarkResponseBody = {
  requestId?: string(name='RequestId'),
  content?: string(name='Content'),
  targetUri?: string(name='TargetUri'),
}

model EncodeBlindWatermarkResponse = {
  headers: map[string]string(name='headers'),
  body: EncodeBlindWatermarkResponseBody(name='body'),
}

async function encodeBlindWatermarkWithOptions(request: EncodeBlindWatermarkRequest, runtime: Util.RuntimeOptions): EncodeBlindWatermarkResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["ImageUri"] = request.imageUri;
  query["WatermarkUri"] = request.watermarkUri;
  query["TargetUri"] = request.targetUri;
  query["ImageQuality"] = request.imageQuality;
  query["Content"] = request.content;
  query["TargetImageType"] = request.targetImageType;
  query["Model"] = request.model;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'EncodeBlindWatermark',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function encodeBlindWatermark(request: EncodeBlindWatermarkRequest): EncodeBlindWatermarkResponse {
  var runtime = new Util.RuntimeOptions{};
  return encodeBlindWatermarkWithOptions(request, runtime);
}

model FindImagesRequest {
  project?: string(name='Project'),
  setId?: string(name='SetId'),
  imageSizeRange?: string(name='ImageSizeRange'),
  imageTimeRange?: string(name='ImageTimeRange'),
  createTimeRange?: string(name='CreateTimeRange'),
  modifyTimeRange?: string(name='ModifyTimeRange'),
  sourceType?: string(name='SourceType'),
  sourceUriPrefix?: string(name='SourceUriPrefix'),
  remarksAPrefix?: string(name='RemarksAPrefix'),
  remarksBPrefix?: string(name='RemarksBPrefix'),
  tagNames?: string(name='TagNames'),
  OCRContentsMatch?: string(name='OCRContentsMatch'),
  ageRange?: string(name='AgeRange'),
  gender?: string(name='Gender'),
  emotion?: string(name='Emotion'),
  orderBy?: string(name='OrderBy'),
  order?: string(name='Order'),
  marker?: string(name='Marker'),
  locationBoundary?: string(name='LocationBoundary'),
  remarksCPrefix?: string(name='RemarksCPrefix'),
  remarksDPrefix?: string(name='RemarksDPrefix'),
  externalId?: string(name='ExternalId'),
  groupId?: string(name='GroupId'),
  limit?: int32(name='Limit'),
  facesModifyTimeRange?: string(name='FacesModifyTimeRange'),
  tagsModifyTimeRange?: string(name='TagsModifyTimeRange'),
  addressLineContentsMatch?: string(name='AddressLineContentsMatch'),
  remarksArrayAIn?: string(name='RemarksArrayAIn'),
  remarksArrayBIn?: string(name='RemarksArrayBIn'),
}

model FindImagesResponseBody = {
  requestId?: string(name='RequestId'),
  images?: [ 
    {
      croppingSuggestionStatus?: string(name='CroppingSuggestionStatus'),
      imageQualityModifyTime?: string(name='ImageQualityModifyTime'),
      tagsFailReason?: string(name='TagsFailReason'),
      remarksC?: string(name='RemarksC'),
      createTime?: string(name='CreateTime'),
      sourceType?: string(name='SourceType'),
      facesFailReason?: string(name='FacesFailReason'),
      tags?: [ 
        {
          tagConfidence?: float(name='TagConfidence'),
          tagName?: string(name='TagName'),
          tagLevel?: int32(name='TagLevel'),
          parentTagName?: string(name='ParentTagName'),
        }
      ](name='Tags'),
      facesModifyTime?: string(name='FacesModifyTime'),
      imageTime?: string(name='ImageTime'),
      OCRModifyTime?: string(name='OCRModifyTime'),
      addressModifyTime?: string(name='AddressModifyTime'),
      OCR?: [ 
        {
          OCRConfidence?: float(name='OCRConfidence'),
          OCRContents?: string(name='OCRContents'),
          OCRBoundary?: {
            top?: int32(name='Top'),
            width?: int32(name='Width'),
            height?: int32(name='Height'),
            left?: int32(name='Left'),
          }(name='OCRBoundary'),
        }
      ](name='OCR'),
      imageQualityFailReason?: string(name='ImageQualityFailReason'),
      facesStatus?: string(name='FacesStatus'),
      imageHeight?: int32(name='ImageHeight'),
      remarksArrayA?: string(name='RemarksArrayA'),
      address?: {
        township?: string(name='Township'),
        district?: string(name='District'),
        addressLine?: string(name='AddressLine'),
        country?: string(name='Country'),
        city?: string(name='City'),
        province?: string(name='Province'),
      }(name='Address'),
      externalId?: string(name='ExternalId'),
      sourceUri?: string(name='SourceUri'),
      modifyTime?: string(name='ModifyTime'),
      fileSize?: int32(name='FileSize'),
      sourcePosition?: string(name='SourcePosition'),
      faces?: [ 
        {
          gender?: string(name='Gender'),
          faceId?: string(name='FaceId'),
          genderConfidence?: float(name='GenderConfidence'),
          faceAttributes?: {
            glassesConfidence?: float(name='GlassesConfidence'),
            glasses?: string(name='Glasses'),
            mask?: string(name='Mask'),
            beardConfidence?: float(name='BeardConfidence'),
            maskConfidence?: float(name='MaskConfidence'),
            faceBoundary?: {
              top?: int32(name='Top'),
              width?: int32(name='Width'),
              height?: int32(name='Height'),
              left?: int32(name='Left'),
            }(name='FaceBoundary'),
            headPose?: {
              pitch?: float(name='Pitch'),
              roll?: float(name='Roll'),
              yaw?: float(name='Yaw'),
            }(name='HeadPose'),
            beard?: string(name='Beard'),
          }(name='FaceAttributes'),
          faceQuality?: float(name='FaceQuality'),
          emotion?: string(name='Emotion'),
          age?: int32(name='Age'),
          faceConfidence?: float(name='FaceConfidence'),
          emotionConfidence?: float(name='EmotionConfidence'),
          attractive?: float(name='Attractive'),
          groupId?: string(name='GroupId'),
          emotionDetails?: {
            HAPPY?: float(name='HAPPY'),
            SURPRISED?: float(name='SURPRISED'),
            CALM?: float(name='CALM'),
            DISGUSTED?: float(name='DISGUSTED'),
            ANGRY?: float(name='ANGRY'),
            SAD?: float(name='SAD'),
            SCARED?: float(name='SCARED'),
          }(name='EmotionDetails'),
        }
      ](name='Faces'),
      imageQualityStatus?: string(name='ImageQualityStatus'),
      OCRFailReason?: string(name='OCRFailReason'),
      addressFailReason?: string(name='AddressFailReason'),
      imageQuality?: {
        overallScore?: float(name='OverallScore'),
        color?: float(name='Color'),
        colorScore?: float(name='ColorScore'),
        contrastScore?: float(name='ContrastScore'),
        contrast?: float(name='Contrast'),
        exposureScore?: float(name='ExposureScore'),
        clarityScore?: float(name='ClarityScore'),
        clarity?: float(name='Clarity'),
        exposure?: float(name='Exposure'),
        compositionScore?: float(name='CompositionScore'),
      }(name='ImageQuality'),
      croppingSuggestionModifyTime?: string(name='CroppingSuggestionModifyTime'),
      imageFormat?: string(name='ImageFormat'),
      imageWidth?: int32(name='ImageWidth'),
      remarksArrayB?: string(name='RemarksArrayB'),
      croppingSuggestion?: [ 
        {
          score?: float(name='Score'),
          croppingBoundary?: {
            top?: int32(name='Top'),
            width?: int32(name='Width'),
            height?: int32(name='Height'),
            left?: int32(name='Left'),
          }(name='CroppingBoundary'),
          aspectRatio?: string(name='AspectRatio'),
        }
      ](name='CroppingSuggestion'),
      orientation?: string(name='Orientation'),
      remarksD?: string(name='RemarksD'),
      tagsStatus?: string(name='TagsStatus'),
      croppingSuggestionFailReason?: string(name='CroppingSuggestionFailReason'),
      remarksA?: string(name='RemarksA'),
      imageUri?: string(name='ImageUri'),
      tagsModifyTime?: string(name='TagsModifyTime'),
      OCRStatus?: string(name='OCRStatus'),
      addressStatus?: string(name='AddressStatus'),
      exif?: string(name='Exif'),
      location?: string(name='Location'),
      remarksB?: string(name='RemarksB'),
    }
  ](name='Images'),
  nextMarker?: string(name='NextMarker'),
  setId?: string(name='SetId'),
}

model FindImagesResponse = {
  headers: map[string]string(name='headers'),
  body: FindImagesResponseBody(name='body'),
}

async function findImagesWithOptions(request: FindImagesRequest, runtime: Util.RuntimeOptions): FindImagesResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["SetId"] = request.setId;
  query["ImageSizeRange"] = request.imageSizeRange;
  query["ImageTimeRange"] = request.imageTimeRange;
  query["CreateTimeRange"] = request.createTimeRange;
  query["ModifyTimeRange"] = request.modifyTimeRange;
  query["SourceType"] = request.sourceType;
  query["SourceUriPrefix"] = request.sourceUriPrefix;
  query["RemarksAPrefix"] = request.remarksAPrefix;
  query["RemarksBPrefix"] = request.remarksBPrefix;
  query["TagNames"] = request.tagNames;
  query["OCRContentsMatch"] = request.OCRContentsMatch;
  query["AgeRange"] = request.ageRange;
  query["Gender"] = request.gender;
  query["Emotion"] = request.emotion;
  query["OrderBy"] = request.orderBy;
  query["Order"] = request.order;
  query["Marker"] = request.marker;
  query["LocationBoundary"] = request.locationBoundary;
  query["RemarksCPrefix"] = request.remarksCPrefix;
  query["RemarksDPrefix"] = request.remarksDPrefix;
  query["ExternalId"] = request.externalId;
  query["GroupId"] = request.groupId;
  query["Limit"] = request.limit;
  query["FacesModifyTimeRange"] = request.facesModifyTimeRange;
  query["TagsModifyTimeRange"] = request.tagsModifyTimeRange;
  query["AddressLineContentsMatch"] = request.addressLineContentsMatch;
  query["RemarksArrayAIn"] = request.remarksArrayAIn;
  query["RemarksArrayBIn"] = request.remarksArrayBIn;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'FindImages',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function findImages(request: FindImagesRequest): FindImagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return findImagesWithOptions(request, runtime);
}

model FindSimilarFacesRequest {
  project?: string(name='Project'),
  setId?: string(name='SetId'),
  imageUri?: string(name='ImageUri'),
  faceId?: string(name='FaceId'),
  limit?: int32(name='Limit'),
  minSimilarity?: float(name='MinSimilarity'),
  responseFormat?: string(name='ResponseFormat'),
}

model FindSimilarFacesResponseBody = {
  requestId?: string(name='RequestId'),
  faces?: [ 
    {
      faceId?: string(name='FaceId'),
      imageUri?: string(name='ImageUri'),
      externalId?: string(name='ExternalId'),
      faceAttributes?: {
        faceBoundary?: {
          top?: int32(name='Top'),
          width?: int32(name='Width'),
          height?: int32(name='Height'),
          left?: int32(name='Left'),
        }(name='FaceBoundary'),
      }(name='FaceAttributes'),
      similarity?: float(name='Similarity'),
      similarFaces?: [ 
        {
          faceId?: string(name='FaceId'),
          imageUri?: string(name='ImageUri'),
          externalId?: string(name='ExternalId'),
          faceAttributes?: {
            faceBoundary?: {
              top?: int32(name='Top'),
              width?: int32(name='Width'),
              height?: int32(name='Height'),
              left?: int32(name='Left'),
            }(name='FaceBoundary'),
          }(name='FaceAttributes'),
          similarity?: float(name='Similarity'),
        }
      ](name='SimilarFaces'),
    }
  ](name='Faces'),
}

model FindSimilarFacesResponse = {
  headers: map[string]string(name='headers'),
  body: FindSimilarFacesResponseBody(name='body'),
}

async function findSimilarFacesWithOptions(request: FindSimilarFacesRequest, runtime: Util.RuntimeOptions): FindSimilarFacesResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["SetId"] = request.setId;
  query["ImageUri"] = request.imageUri;
  query["FaceId"] = request.faceId;
  query["Limit"] = request.limit;
  query["MinSimilarity"] = request.minSimilarity;
  query["ResponseFormat"] = request.responseFormat;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'FindSimilarFaces',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function findSimilarFaces(request: FindSimilarFacesRequest): FindSimilarFacesResponse {
  var runtime = new Util.RuntimeOptions{};
  return findSimilarFacesWithOptions(request, runtime);
}

model GetContentKeyRequest {
  project?: string(name='Project'),
  versionId?: string(name='VersionId'),
  DRMServerId?: string(name='DRMServerId'),
  keyIds?: string(name='KeyIds'),
}

model GetContentKeyResponseBody = {
  versionId?: string(name='VersionId'),
  requestId?: string(name='RequestId'),
  keyInfos?: string(name='KeyInfos'),
}

model GetContentKeyResponse = {
  headers: map[string]string(name='headers'),
  body: GetContentKeyResponseBody(name='body'),
}

async function getContentKeyWithOptions(request: GetContentKeyRequest, runtime: Util.RuntimeOptions): GetContentKeyResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["VersionId"] = request.versionId;
  query["DRMServerId"] = request.DRMServerId;
  query["KeyIds"] = request.keyIds;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetContentKey',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getContentKey(request: GetContentKeyRequest): GetContentKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return getContentKeyWithOptions(request, runtime);
}

model GetDRMLicenseRequest {
  project?: string(name='Project'),
  DRMType?: string(name='DRMType'),
  DRMLicense?: string(name='DRMLicense'),
}

model GetDRMLicenseResponseBody = {
  requestId?: string(name='RequestId'),
  deviceInfo?: string(name='DeviceInfo'),
  DRMData?: string(name='DRMData'),
}

model GetDRMLicenseResponse = {
  headers: map[string]string(name='headers'),
  body: GetDRMLicenseResponseBody(name='body'),
}

async function getDRMLicenseWithOptions(request: GetDRMLicenseRequest, runtime: Util.RuntimeOptions): GetDRMLicenseResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["DRMType"] = request.DRMType;
  query["DRMLicense"] = request.DRMLicense;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetDRMLicense',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDRMLicense(request: GetDRMLicenseRequest): GetDRMLicenseResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDRMLicenseWithOptions(request, runtime);
}

model GetImageRequest {
  project?: string(name='Project'),
  setId?: string(name='SetId'),
  imageUri?: string(name='ImageUri'),
}

model GetImageResponseBody = {
  imageQuality?: {
    overallScore?: float(name='OverallScore'),
    color?: float(name='Color'),
    colorScore?: float(name='ColorScore'),
    contrastScore?: float(name='ContrastScore'),
    contrast?: float(name='Contrast'),
    exposureScore?: float(name='ExposureScore'),
    clarityScore?: float(name='ClarityScore'),
    clarity?: float(name='Clarity'),
    exposure?: float(name='Exposure'),
    compositionScore?: float(name='CompositionScore'),
  }(name='ImageQuality'),
  modifyTime?: string(name='ModifyTime'),
  address?: {
    township?: string(name='Township'),
    district?: string(name='District'),
    addressLine?: string(name='AddressLine'),
    country?: string(name='Country'),
    city?: string(name='City'),
    province?: string(name='Province'),
  }(name='Address'),
  sourceType?: string(name='SourceType'),
  sourceUri?: string(name='SourceUri'),
  facesFailReason?: string(name='FacesFailReason'),
  croppingSuggestionStatus?: string(name='CroppingSuggestionStatus'),
  croppingSuggestionFailReason?: string(name='CroppingSuggestionFailReason'),
  addressFailReason?: string(name='AddressFailReason'),
  remarksA?: string(name='RemarksA'),
  addressModifyTime?: string(name='AddressModifyTime'),
  remarksB?: string(name='RemarksB'),
  imageFormat?: string(name='ImageFormat'),
  tagsFailReason?: string(name='TagsFailReason'),
  remarksArrayB?: string(name='RemarksArrayB'),
  facesModifyTime?: string(name='FacesModifyTime'),
  exif?: string(name='Exif'),
  remarksC?: string(name='RemarksC'),
  remarksD?: string(name='RemarksD'),
  imageWidth?: int32(name='ImageWidth'),
  remarksArrayA?: string(name='RemarksArrayA'),
  sourcePosition?: string(name='SourcePosition'),
  tags?: [ 
    {
      tagName?: string(name='TagName'),
      tagConfidence?: float(name='TagConfidence'),
      tagLevel?: int32(name='TagLevel'),
      parentTagName?: string(name='ParentTagName'),
    }
  ](name='Tags'),
  faces?: [ 
    {
      gender?: string(name='Gender'),
      genderConfidence?: float(name='GenderConfidence'),
      faceId?: string(name='FaceId'),
      faceAttributes?: {
        glassesConfidence?: float(name='GlassesConfidence'),
        glasses?: string(name='Glasses'),
        mask?: string(name='Mask'),
        beardConfidence?: float(name='BeardConfidence'),
        maskConfidence?: float(name='MaskConfidence'),
        faceBoundary?: {
          top?: int32(name='Top'),
          width?: int32(name='Width'),
          height?: int32(name='Height'),
          left?: int32(name='Left'),
        }(name='FaceBoundary'),
        headPose?: {
          pitch?: float(name='Pitch'),
          roll?: float(name='Roll'),
          yaw?: float(name='Yaw'),
        }(name='HeadPose'),
        beard?: string(name='Beard'),
      }(name='FaceAttributes'),
      faceQuality?: float(name='FaceQuality'),
      emotion?: string(name='Emotion'),
      age?: string(name='Age'),
      faceConfidence?: float(name='FaceConfidence'),
      emotionConfidence?: float(name='EmotionConfidence'),
      attractive?: float(name='Attractive'),
      groupId?: string(name='GroupId'),
      emotionDetails?: {
        HAPPY?: float(name='HAPPY'),
        CALM?: float(name='CALM'),
        SURPRISED?: float(name='SURPRISED'),
        DISGUSTED?: float(name='DISGUSTED'),
        ANGRY?: float(name='ANGRY'),
        SAD?: float(name='SAD'),
        SCARED?: float(name='SCARED'),
      }(name='EmotionDetails'),
    }
  ](name='Faces'),
  addressStatus?: string(name='AddressStatus'),
  facesStatus?: string(name='FacesStatus'),
  imageQualityModifyTime?: string(name='ImageQualityModifyTime'),
  croppingSuggestion?: [ 
    {
      score?: float(name='Score'),
      croppingBoundary?: {
        top?: int32(name='Top'),
        width?: int32(name='Width'),
        height?: int32(name='Height'),
        left?: int32(name='Left'),
      }(name='CroppingBoundary'),
      aspectRatio?: string(name='AspectRatio'),
    }
  ](name='CroppingSuggestion'),
  requestId?: string(name='RequestId'),
  createTime?: string(name='CreateTime'),
  externalId?: string(name='ExternalId'),
  tagsModifyTime?: string(name='TagsModifyTime'),
  imageQualityFailReason?: string(name='ImageQualityFailReason'),
  orientation?: string(name='Orientation'),
  imageUri?: string(name='ImageUri'),
  OCRStatus?: string(name='OCRStatus'),
  OCRModifyTime?: string(name='OCRModifyTime'),
  imageTime?: string(name='ImageTime'),
  croppingSuggestionModifyTime?: string(name='CroppingSuggestionModifyTime'),
  imageHeight?: int32(name='ImageHeight'),
  imageQualityStatus?: string(name='ImageQualityStatus'),
  tagsStatus?: string(name='TagsStatus'),
  OCRFailReason?: string(name='OCRFailReason'),
  setId?: string(name='SetId'),
  fileSize?: int32(name='FileSize'),
  location?: string(name='Location'),
  OCR?: [ 
    {
      OCRConfidence?: float(name='OCRConfidence'),
      OCRContents?: string(name='OCRContents'),
      OCRBoundary?: {
        top?: int32(name='Top'),
        width?: int32(name='Width'),
        height?: int32(name='Height'),
        left?: int32(name='Left'),
      }(name='OCRBoundary'),
    }
  ](name='OCR'),
}

model GetImageResponse = {
  headers: map[string]string(name='headers'),
  body: GetImageResponseBody(name='body'),
}

async function getImageWithOptions(request: GetImageRequest, runtime: Util.RuntimeOptions): GetImageResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["SetId"] = request.setId;
  query["ImageUri"] = request.imageUri;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetImage',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getImage(request: GetImageRequest): GetImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return getImageWithOptions(request, runtime);
}

model GetImageCroppingSuggestionsRequest {
  project?: string(name='Project'),
  imageUri?: string(name='ImageUri'),
  aspectRatios?: string(name='AspectRatios'),
}

model GetImageCroppingSuggestionsResponseBody = {
  requestId?: string(name='RequestId'),
  imageUri?: string(name='ImageUri'),
  croppingSuggestions?: [ 
    {
      score?: float(name='Score'),
      croppingBoundary?: {
        top?: int32(name='Top'),
        width?: int32(name='Width'),
        height?: int32(name='Height'),
        left?: int32(name='Left'),
      }(name='CroppingBoundary'),
      aspectRatio?: string(name='AspectRatio'),
    }
  ](name='CroppingSuggestions'),
}

model GetImageCroppingSuggestionsResponse = {
  headers: map[string]string(name='headers'),
  body: GetImageCroppingSuggestionsResponseBody(name='body'),
}

async function getImageCroppingSuggestionsWithOptions(request: GetImageCroppingSuggestionsRequest, runtime: Util.RuntimeOptions): GetImageCroppingSuggestionsResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["ImageUri"] = request.imageUri;
  query["AspectRatios"] = request.aspectRatios;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetImageCroppingSuggestions',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getImageCroppingSuggestions(request: GetImageCroppingSuggestionsRequest): GetImageCroppingSuggestionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getImageCroppingSuggestionsWithOptions(request, runtime);
}

model GetImageQualityRequest {
  project?: string(name='Project'),
  imageUri?: string(name='ImageUri'),
}

model GetImageQualityResponseBody = {
  imageQuality?: {
    overallScore?: float(name='OverallScore'),
    color?: float(name='Color'),
    colorScore?: float(name='ColorScore'),
    contrastScore?: float(name='ContrastScore'),
    contrast?: float(name='Contrast'),
    exposureScore?: float(name='ExposureScore'),
    clarityScore?: float(name='ClarityScore'),
    clarity?: float(name='Clarity'),
    exposure?: float(name='Exposure'),
    compositionScore?: float(name='CompositionScore'),
  }(name='ImageQuality'),
  requestId?: string(name='RequestId'),
  imageUri?: string(name='ImageUri'),
}

model GetImageQualityResponse = {
  headers: map[string]string(name='headers'),
  body: GetImageQualityResponseBody(name='body'),
}

async function getImageQualityWithOptions(request: GetImageQualityRequest, runtime: Util.RuntimeOptions): GetImageQualityResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["ImageUri"] = request.imageUri;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetImageQuality',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getImageQuality(request: GetImageQualityRequest): GetImageQualityResponse {
  var runtime = new Util.RuntimeOptions{};
  return getImageQualityWithOptions(request, runtime);
}

model GetMediaMetaRequest {
  project?: string(name='Project'),
  mediaUri?: string(name='MediaUri'),
}

model GetMediaMetaResponseBody = {
  mediaUri?: string(name='MediaUri'),
  requestId?: string(name='RequestId'),
  mediaMeta?: {
    mediaFormat?: {
      creationTime?: string(name='CreationTime'),
      numberPrograms?: int32(name='NumberPrograms'),
      numberStreams?: int32(name='NumberStreams'),
      tag?: {
        creationTime?: string(name='CreationTime'),
        album?: string(name='Album'),
        albumArtist?: string(name='AlbumArtist'),
        performer?: string(name='Performer'),
        composer?: string(name='Composer'),
        artist?: string(name='Artist'),
        title?: string(name='Title'),
        language?: string(name='Language'),
      }(name='Tag'),
      bitrate?: string(name='Bitrate'),
      startTime?: string(name='StartTime'),
      size?: string(name='Size'),
      address?: {
        township?: string(name='Township'),
        district?: string(name='District'),
        addressLine?: string(name='AddressLine'),
        country?: string(name='Country'),
        city?: string(name='City'),
        province?: string(name='Province'),
      }(name='Address'),
      formatLongName?: string(name='FormatLongName'),
      duration?: string(name='Duration'),
      formatName?: string(name='FormatName'),
      location?: string(name='Location'),
    }(name='MediaFormat'),
    mediaStreams?: {
      videoStreams?: [ 
        {
          index?: int32(name='Index'),
          codecLongName?: string(name='CodecLongName'),
          height?: int32(name='Height'),
          sampleAspectRatio?: string(name='SampleAspectRatio'),
          averageFrameRate?: string(name='AverageFrameRate'),
          bitrate?: string(name='Bitrate'),
          rotate?: string(name='Rotate'),
          codecTagString?: string(name='CodecTagString'),
          language?: string(name='Language'),
          hasBFrames?: int32(name='HasBFrames'),
          frameRrate?: string(name='FrameRrate'),
          profile?: string(name='Profile'),
          startTime?: string(name='StartTime'),
          frames?: string(name='Frames'),
          codecName?: string(name='CodecName'),
          width?: int32(name='Width'),
          duration?: string(name='Duration'),
          displayAspectRatio?: string(name='DisplayAspectRatio'),
          codecTag?: string(name='CodecTag'),
          codecTimeBase?: string(name='CodecTimeBase'),
          timeBase?: string(name='TimeBase'),
          level?: int32(name='Level'),
          pixelFormat?: string(name='PixelFormat'),
        }
      ](name='VideoStreams'),
      audioStreams?: [ 
        {
          index?: int32(name='Index'),
          sampleRate?: string(name='SampleRate'),
          channelLayout?: string(name='ChannelLayout'),
          codecLongName?: string(name='CodecLongName'),
          channels?: int32(name='Channels'),
          bitrate?: string(name='Bitrate'),
          codecTagString?: string(name='CodecTagString'),
          language?: string(name='Language'),
          startTime?: string(name='StartTime'),
          sampleFormat?: string(name='SampleFormat'),
          frames?: string(name='Frames'),
          codecName?: string(name='CodecName'),
          duration?: string(name='Duration'),
          codecTag?: string(name='CodecTag'),
          codecTimeBase?: string(name='CodecTimeBase'),
          timeBase?: string(name='TimeBase'),
        }
      ](name='AudioStreams'),
      subtitleStreams?: [ 
        {
          index?: int32(name='Index'),
          language?: string(name='Language'),
        }
      ](name='SubtitleStreams'),
    }(name='MediaStreams'),
  }(name='MediaMeta'),
}

model GetMediaMetaResponse = {
  headers: map[string]string(name='headers'),
  body: GetMediaMetaResponseBody(name='body'),
}

async function getMediaMetaWithOptions(request: GetMediaMetaRequest, runtime: Util.RuntimeOptions): GetMediaMetaResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["MediaUri"] = request.mediaUri;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetMediaMeta',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMediaMeta(request: GetMediaMetaRequest): GetMediaMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMediaMetaWithOptions(request, runtime);
}

model GetOfficeConversionTaskRequest {
  project?: string(name='Project'),
  taskId?: string(name='TaskId'),
}

model GetOfficeConversionTaskResponseBody = {
  status?: string(name='Status'),
  failDetail?: {
    code?: string(name='Code'),
  }(name='FailDetail'),
  tgtType?: string(name='TgtType'),
  taskId?: string(name='TaskId'),
  requestId?: string(name='RequestId'),
  percent?: int32(name='Percent'),
  createTime?: string(name='CreateTime'),
  externalID?: string(name='ExternalID'),
  imageSpec?: string(name='ImageSpec'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
  tgtUri?: string(name='TgtUri'),
  finishTime?: string(name='FinishTime'),
  pageCount?: int32(name='PageCount'),
  notifyTopicName?: string(name='NotifyTopicName'),
  srcUri?: string(name='SrcUri'),
}

model GetOfficeConversionTaskResponse = {
  headers: map[string]string(name='headers'),
  body: GetOfficeConversionTaskResponseBody(name='body'),
}

async function getOfficeConversionTaskWithOptions(request: GetOfficeConversionTaskRequest, runtime: Util.RuntimeOptions): GetOfficeConversionTaskResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["TaskId"] = request.taskId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetOfficeConversionTask',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getOfficeConversionTask(request: GetOfficeConversionTaskRequest): GetOfficeConversionTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return getOfficeConversionTaskWithOptions(request, runtime);
}

model GetOfficeEditURLRequest {
  project?: string(name='Project'),
  srcUri?: string(name='SrcUri'),
  srcType?: string(name='SrcType'),
  fileID?: string(name='FileID'),
  tgtUri?: string(name='TgtUri'),
  userID?: string(name='UserID'),
  userName?: string(name='UserName'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
  notifyTopicName?: string(name='NotifyTopicName'),
  fileName?: string(name='FileName'),
}

model GetOfficeEditURLResponseBody = {
  refreshToken?: string(name='RefreshToken'),
  requestId?: string(name='RequestId'),
  editURL?: string(name='EditURL'),
  accessToken?: string(name='AccessToken'),
  refreshTokenExpiredTime?: string(name='RefreshTokenExpiredTime'),
  accessTokenExpiredTime?: string(name='AccessTokenExpiredTime'),
}

model GetOfficeEditURLResponse = {
  headers: map[string]string(name='headers'),
  body: GetOfficeEditURLResponseBody(name='body'),
}

async function getOfficeEditURLWithOptions(request: GetOfficeEditURLRequest, runtime: Util.RuntimeOptions): GetOfficeEditURLResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["SrcUri"] = request.srcUri;
  query["SrcType"] = request.srcType;
  query["FileID"] = request.fileID;
  query["TgtUri"] = request.tgtUri;
  query["UserID"] = request.userID;
  query["UserName"] = request.userName;
  query["NotifyEndpoint"] = request.notifyEndpoint;
  query["NotifyTopicName"] = request.notifyTopicName;
  query["FileName"] = request.fileName;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetOfficeEditURL',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getOfficeEditURL(request: GetOfficeEditURLRequest): GetOfficeEditURLResponse {
  var runtime = new Util.RuntimeOptions{};
  return getOfficeEditURLWithOptions(request, runtime);
}

model GetOfficePreviewURLRequest {
  project?: string(name='Project'),
  srcUri?: string(name='SrcUri'),
  srcType?: string(name='SrcType'),
  watermarkType?: int32(name='WatermarkType'),
  watermarkValue?: string(name='WatermarkValue'),
  watermarkFillStyle?: string(name='WatermarkFillStyle'),
  watermarkFont?: string(name='WatermarkFont'),
  watermarkRotate?: float(name='WatermarkRotate'),
  watermarkHorizontal?: int32(name='WatermarkHorizontal'),
  watermarkVertical?: int32(name='WatermarkVertical'),
}

model GetOfficePreviewURLResponseBody = {
  previewURL?: string(name='PreviewURL'),
  refreshToken?: string(name='RefreshToken'),
  requestId?: string(name='RequestId'),
  accessToken?: string(name='AccessToken'),
  refreshTokenExpiredTime?: string(name='RefreshTokenExpiredTime'),
  accessTokenExpiredTime?: string(name='AccessTokenExpiredTime'),
}

model GetOfficePreviewURLResponse = {
  headers: map[string]string(name='headers'),
  body: GetOfficePreviewURLResponseBody(name='body'),
}

async function getOfficePreviewURLWithOptions(request: GetOfficePreviewURLRequest, runtime: Util.RuntimeOptions): GetOfficePreviewURLResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["SrcUri"] = request.srcUri;
  query["SrcType"] = request.srcType;
  query["WatermarkType"] = request.watermarkType;
  query["WatermarkValue"] = request.watermarkValue;
  query["WatermarkFillStyle"] = request.watermarkFillStyle;
  query["WatermarkFont"] = request.watermarkFont;
  query["WatermarkRotate"] = request.watermarkRotate;
  query["WatermarkHorizontal"] = request.watermarkHorizontal;
  query["WatermarkVertical"] = request.watermarkVertical;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetOfficePreviewURL',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getOfficePreviewURL(request: GetOfficePreviewURLRequest): GetOfficePreviewURLResponse {
  var runtime = new Util.RuntimeOptions{};
  return getOfficePreviewURLWithOptions(request, runtime);
}

model GetProjectRequest {
  project?: string(name='Project'),
}

model GetProjectResponseBody = {
  project?: string(name='Project'),
  modifyTime?: string(name='ModifyTime'),
  type?: string(name='Type'),
  CU?: int32(name='CU'),
  serviceRole?: string(name='ServiceRole'),
  requestId?: string(name='RequestId'),
  endpoint?: string(name='Endpoint'),
  createTime?: string(name='CreateTime'),
  regionId?: string(name='RegionId'),
  billingType?: string(name='BillingType'),
}

model GetProjectResponse = {
  headers: map[string]string(name='headers'),
  body: GetProjectResponseBody(name='body'),
}

async function getProjectWithOptions(request: GetProjectRequest, runtime: Util.RuntimeOptions): GetProjectResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetProject',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getProject(request: GetProjectRequest): GetProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return getProjectWithOptions(request, runtime);
}

model GetSetRequest {
  project?: string(name='Project'),
  setId?: string(name='SetId'),
}

model GetSetResponseBody = {
  modifyTime?: string(name='ModifyTime'),
  videoCount?: int32(name='VideoCount'),
  imageCount?: int32(name='ImageCount'),
  requestId?: string(name='RequestId'),
  createTime?: string(name='CreateTime'),
  setName?: string(name='SetName'),
  setId?: string(name='SetId'),
  videoLength?: int32(name='VideoLength'),
  faceCount?: int32(name='FaceCount'),
}

model GetSetResponse = {
  headers: map[string]string(name='headers'),
  body: GetSetResponseBody(name='body'),
}

async function getSetWithOptions(request: GetSetRequest, runtime: Util.RuntimeOptions): GetSetResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["SetId"] = request.setId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetSet',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSet(request: GetSetRequest): GetSetResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSetWithOptions(request, runtime);
}

model GetVideoRequest {
  project?: string(name='Project'),
  setId?: string(name='SetId'),
  videoUri?: string(name='VideoUri'),
}

model GetVideoResponseBody = {
  modifyTime?: string(name='ModifyTime'),
  processStatus?: string(name='ProcessStatus'),
  videoWidth?: int32(name='VideoWidth'),
  sourceType?: string(name='SourceType'),
  sourceUri?: string(name='SourceUri'),
  videoInfo?: string(name='VideoInfo'),
  videoFrameTagsModifyTime?: string(name='VideoFrameTagsModifyTime'),
  remarksA?: string(name='RemarksA'),
  videoFacesFailReason?: string(name='VideoFacesFailReason'),
  remarksB?: string(name='RemarksB'),
  videoFacesStatus?: string(name='VideoFacesStatus'),
  remarksC?: string(name='RemarksC'),
  videoOCRModifyTime?: string(name='VideoOCRModifyTime'),
  remarksD?: string(name='RemarksD'),
  videoHeight?: int32(name='VideoHeight'),
  sourcePosition?: string(name='SourcePosition'),
  videoOCRFailReason?: string(name='VideoOCRFailReason'),
  videoFrameTagsStatus?: string(name='VideoFrameTagsStatus'),
  videoTagsFailReason?: string(name='VideoTagsFailReason'),
  videoTagsModifyTime?: string(name='VideoTagsModifyTime'),
  videoOCRStatus?: string(name='VideoOCRStatus'),
  videoFrames?: int32(name='VideoFrames'),
  requestId?: string(name='RequestId'),
  processModifyTime?: string(name='ProcessModifyTime'),
  videoSTTModifyTime?: string(name='VideoSTTModifyTime'),
  processFailReason?: string(name='ProcessFailReason'),
  createTime?: string(name='CreateTime'),
  externalId?: string(name='ExternalId'),
  videoSTTFailReason?: string(name='VideoSTTFailReason'),
  videoUri?: string(name='VideoUri'),
  videoFrameTagsFailReason?: string(name='VideoFrameTagsFailReason'),
  videoFormat?: string(name='VideoFormat'),
  videoSTTStatus?: string(name='VideoSTTStatus'),
  videoFacesModifyTime?: string(name='VideoFacesModifyTime'),
  videoTags?: [ 
    {
      tagName?: string(name='TagName'),
      tagConfidence?: float(name='TagConfidence'),
      tagLevel?: int32(name='TagLevel'),
      parentTagName?: string(name='ParentTagName'),
    }
  ](name='VideoTags'),
  videoDuration?: float(name='VideoDuration'),
  setId?: string(name='SetId'),
  videoTagsStatus?: string(name='VideoTagsStatus'),
  fileSize?: int32(name='FileSize'),
}

model GetVideoResponse = {
  headers: map[string]string(name='headers'),
  body: GetVideoResponseBody(name='body'),
}

async function getVideoWithOptions(request: GetVideoRequest, runtime: Util.RuntimeOptions): GetVideoResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["SetId"] = request.setId;
  query["VideoUri"] = request.videoUri;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetVideo',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getVideo(request: GetVideoRequest): GetVideoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVideoWithOptions(request, runtime);
}

model GetVideoTaskRequest {
  project?: string(name='Project'),
  taskType?: string(name='TaskType'),
  taskId?: string(name='TaskId'),
}

model GetVideoTaskResponseBody = {
  status?: string(name='Status'),
  progress?: int32(name='Progress'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
  parameters?: string(name='Parameters'),
  taskId?: string(name='TaskId'),
  endTime?: string(name='EndTime'),
  requestId?: string(name='RequestId'),
  taskType?: string(name='TaskType'),
  startTime?: string(name='StartTime'),
  notifyTopicName?: string(name='NotifyTopicName'),
  errorMessage?: string(name='ErrorMessage'),
  result?: string(name='Result'),
}

model GetVideoTaskResponse = {
  headers: map[string]string(name='headers'),
  body: GetVideoTaskResponseBody(name='body'),
}

async function getVideoTaskWithOptions(request: GetVideoTaskRequest, runtime: Util.RuntimeOptions): GetVideoTaskResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["TaskType"] = request.taskType;
  query["TaskId"] = request.taskId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetVideoTask',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getVideoTask(request: GetVideoTaskRequest): GetVideoTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVideoTaskWithOptions(request, runtime);
}

model GetWebofficeURLRequest {
  project?: string(name='Project'),
  srcType?: string(name='SrcType'),
  fileID?: string(name='FileID'),
  user?: string(name='User'),
  permission?: string(name='Permission'),
  file?: string(name='File'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
  notifyTopicName?: string(name='NotifyTopicName'),
  watermark?: string(name='Watermark'),
  hidecmb?: boolean(name='Hidecmb'),
}

model GetWebofficeURLResponseBody = {
  refreshToken?: string(name='RefreshToken'),
  requestId?: string(name='RequestId'),
  accessToken?: string(name='AccessToken'),
  refreshTokenExpiredTime?: string(name='RefreshTokenExpiredTime'),
  webofficeURL?: string(name='WebofficeURL'),
  accessTokenExpiredTime?: string(name='AccessTokenExpiredTime'),
}

model GetWebofficeURLResponse = {
  headers: map[string]string(name='headers'),
  body: GetWebofficeURLResponseBody(name='body'),
}

async function getWebofficeURLWithOptions(request: GetWebofficeURLRequest, runtime: Util.RuntimeOptions): GetWebofficeURLResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["SrcType"] = request.srcType;
  query["FileID"] = request.fileID;
  query["User"] = request.user;
  query["Permission"] = request.permission;
  query["File"] = request.file;
  query["NotifyEndpoint"] = request.notifyEndpoint;
  query["NotifyTopicName"] = request.notifyTopicName;
  query["Watermark"] = request.watermark;
  query["Hidecmb"] = request.hidecmb;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetWebofficeURL',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getWebofficeURL(request: GetWebofficeURLRequest): GetWebofficeURLResponse {
  var runtime = new Util.RuntimeOptions{};
  return getWebofficeURLWithOptions(request, runtime);
}

model IndexImageRequest {
  project?: string(name='Project'),
  setId?: string(name='SetId'),
  imageUri?: string(name='ImageUri'),
  remarksA?: string(name='RemarksA'),
  remarksB?: string(name='RemarksB'),
  sourceType?: string(name='SourceType'),
  sourceUri?: string(name='SourceUri'),
  sourcePosition?: string(name='SourcePosition'),
  remarksC?: string(name='RemarksC'),
  remarksD?: string(name='RemarksD'),
  externalId?: string(name='ExternalId'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
  notifyTopicName?: string(name='NotifyTopicName'),
  remarksArrayA?: string(name='RemarksArrayA'),
  remarksArrayB?: string(name='RemarksArrayB'),
}

model IndexImageResponseBody = {
  remarksArrayB?: string(name='RemarksArrayB'),
  modifyTime?: string(name='ModifyTime'),
  remarksC?: string(name='RemarksC'),
  remarksD?: string(name='RemarksD'),
  requestId?: string(name='RequestId'),
  createTime?: string(name='CreateTime'),
  externalId?: string(name='ExternalId'),
  remarksArrayA?: string(name='RemarksArrayA'),
  remarksA?: string(name='RemarksA'),
  imageUri?: string(name='ImageUri'),
  setId?: string(name='SetId'),
  remarksB?: string(name='RemarksB'),
}

model IndexImageResponse = {
  headers: map[string]string(name='headers'),
  body: IndexImageResponseBody(name='body'),
}

async function indexImageWithOptions(request: IndexImageRequest, runtime: Util.RuntimeOptions): IndexImageResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["SetId"] = request.setId;
  query["ImageUri"] = request.imageUri;
  query["RemarksA"] = request.remarksA;
  query["RemarksB"] = request.remarksB;
  query["SourceType"] = request.sourceType;
  query["SourceUri"] = request.sourceUri;
  query["SourcePosition"] = request.sourcePosition;
  query["RemarksC"] = request.remarksC;
  query["RemarksD"] = request.remarksD;
  query["ExternalId"] = request.externalId;
  query["NotifyEndpoint"] = request.notifyEndpoint;
  query["NotifyTopicName"] = request.notifyTopicName;
  query["RemarksArrayA"] = request.remarksArrayA;
  query["RemarksArrayB"] = request.remarksArrayB;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'IndexImage',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function indexImage(request: IndexImageRequest): IndexImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return indexImageWithOptions(request, runtime);
}

model IndexVideoRequest {
  project?: string(name='Project'),
  setId?: string(name='SetId'),
  videoUri?: string(name='VideoUri'),
  remarksA?: string(name='RemarksA'),
  remarksB?: string(name='RemarksB'),
  tgtUri?: string(name='TgtUri'),
  remarksC?: string(name='RemarksC'),
  remarksD?: string(name='RemarksD'),
  externalId?: string(name='ExternalId'),
  notifyTopicName?: string(name='NotifyTopicName'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
}

model IndexVideoResponseBody = {
  modifyTime?: string(name='ModifyTime'),
  requestId?: string(name='RequestId'),
  createTime?: string(name='CreateTime'),
  externalId?: string(name='ExternalId'),
  videoUri?: string(name='VideoUri'),
  remarksA?: string(name='RemarksA'),
  remarksB?: string(name='RemarksB'),
  remarksC?: string(name='RemarksC'),
  remarksD?: string(name='RemarksD'),
  setId?: string(name='SetId'),
}

model IndexVideoResponse = {
  headers: map[string]string(name='headers'),
  body: IndexVideoResponseBody(name='body'),
}

async function indexVideoWithOptions(request: IndexVideoRequest, runtime: Util.RuntimeOptions): IndexVideoResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["SetId"] = request.setId;
  query["VideoUri"] = request.videoUri;
  query["RemarksA"] = request.remarksA;
  query["RemarksB"] = request.remarksB;
  query["TgtUri"] = request.tgtUri;
  query["RemarksC"] = request.remarksC;
  query["RemarksD"] = request.remarksD;
  query["ExternalId"] = request.externalId;
  query["NotifyTopicName"] = request.notifyTopicName;
  query["NotifyEndpoint"] = request.notifyEndpoint;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'IndexVideo',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function indexVideo(request: IndexVideoRequest): IndexVideoResponse {
  var runtime = new Util.RuntimeOptions{};
  return indexVideoWithOptions(request, runtime);
}

model ListFaceGroupsRequest {
  project?: string(name='Project'),
  setId?: string(name='SetId'),
  marker?: string(name='Marker'),
  limit?: int32(name='Limit'),
  order?: string(name='Order'),
  orderBy?: string(name='OrderBy'),
  remarksAQuery?: string(name='RemarksAQuery'),
  remarksBQuery?: string(name='RemarksBQuery'),
  remarksCQuery?: string(name='RemarksCQuery'),
  remarksDQuery?: string(name='RemarksDQuery'),
  remarksArrayAQuery?: string(name='RemarksArrayAQuery'),
  remarksArrayBQuery?: string(name='RemarksArrayBQuery'),
  externalId?: string(name='ExternalId'),
}

model ListFaceGroupsResponseBody = {
  requestId?: string(name='RequestId'),
  nextMarker?: string(name='NextMarker'),
  faceGroups?: [ 
    {
      gender?: string(name='Gender'),
      createTime?: string(name='CreateTime'),
      remarksC?: string(name='RemarksC'),
      groupCoverFace?: {
        faceId?: string(name='FaceId'),
        imageUri?: string(name='ImageUri'),
        faceBoundary?: {
          top?: int32(name='Top'),
          width?: int32(name='Width'),
          height?: int32(name='Height'),
          left?: int32(name='Left'),
        }(name='FaceBoundary'),
        externalId?: string(name='ExternalId'),
      }(name='GroupCoverFace'),
      faceCount?: int32(name='FaceCount'),
      remarksArrayB?: string(name='RemarksArrayB'),
      remarksD?: string(name='RemarksD'),
      maxAge?: float(name='MaxAge'),
      groupId?: string(name='GroupId'),
      groupName?: string(name='GroupName'),
      remarksA?: string(name='RemarksA'),
      averageAge?: float(name='AverageAge'),
      remarksArrayA?: string(name='RemarksArrayA'),
      minAge?: float(name='MinAge'),
      imageCount?: int32(name='ImageCount'),
      externalId?: string(name='ExternalId'),
      remarksB?: string(name='RemarksB'),
      modifyTime?: string(name='ModifyTime'),
    }
  ](name='FaceGroups'),
}

model ListFaceGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: ListFaceGroupsResponseBody(name='body'),
}

async function listFaceGroupsWithOptions(request: ListFaceGroupsRequest, runtime: Util.RuntimeOptions): ListFaceGroupsResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["SetId"] = request.setId;
  query["Marker"] = request.marker;
  query["Limit"] = request.limit;
  query["Order"] = request.order;
  query["OrderBy"] = request.orderBy;
  query["RemarksAQuery"] = request.remarksAQuery;
  query["RemarksBQuery"] = request.remarksBQuery;
  query["RemarksCQuery"] = request.remarksCQuery;
  query["RemarksDQuery"] = request.remarksDQuery;
  query["RemarksArrayAQuery"] = request.remarksArrayAQuery;
  query["RemarksArrayBQuery"] = request.remarksArrayBQuery;
  query["ExternalId"] = request.externalId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListFaceGroups',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFaceGroups(request: ListFaceGroupsRequest): ListFaceGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFaceGroupsWithOptions(request, runtime);
}

model ListImagesRequest {
  project?: string(name='Project'),
  setId?: string(name='SetId'),
  createTimeStart?: string(name='CreateTimeStart'),
  marker?: string(name='Marker'),
  limit?: int32(name='Limit'),
}

model ListImagesResponseBody = {
  requestId?: string(name='RequestId'),
  images?: [ 
    {
      croppingSuggestionStatus?: string(name='CroppingSuggestionStatus'),
      imageQualityModifyTime?: string(name='ImageQualityModifyTime'),
      tagsFailReason?: string(name='TagsFailReason'),
      remarksC?: string(name='RemarksC'),
      createTime?: string(name='CreateTime'),
      sourceType?: string(name='SourceType'),
      facesFailReason?: string(name='FacesFailReason'),
      tags?: [ 
        {
          tagConfidence?: float(name='TagConfidence'),
          tagName?: string(name='TagName'),
          tagLevel?: int32(name='TagLevel'),
          parentTagName?: string(name='ParentTagName'),
        }
      ](name='Tags'),
      facesModifyTime?: string(name='FacesModifyTime'),
      imageTime?: string(name='ImageTime'),
      OCRModifyTime?: string(name='OCRModifyTime'),
      addressModifyTime?: string(name='AddressModifyTime'),
      OCR?: [ 
        {
          OCRConfidence?: float(name='OCRConfidence'),
          OCRContents?: string(name='OCRContents'),
          OCRBoundary?: {
            top?: int32(name='Top'),
            width?: int32(name='Width'),
            height?: int32(name='Height'),
            left?: int32(name='Left'),
          }(name='OCRBoundary'),
        }
      ](name='OCR'),
      imageQualityFailReason?: string(name='ImageQualityFailReason'),
      facesStatus?: string(name='FacesStatus'),
      imageHeight?: int32(name='ImageHeight'),
      remarksArrayA?: string(name='RemarksArrayA'),
      address?: {
        township?: string(name='Township'),
        district?: string(name='District'),
        addressLine?: string(name='AddressLine'),
        country?: string(name='Country'),
        city?: string(name='City'),
        province?: string(name='Province'),
      }(name='Address'),
      externalId?: string(name='ExternalId'),
      sourceUri?: string(name='SourceUri'),
      modifyTime?: string(name='ModifyTime'),
      fileSize?: int32(name='FileSize'),
      sourcePosition?: string(name='SourcePosition'),
      faces?: [ 
        {
          gender?: string(name='Gender'),
          faceId?: string(name='FaceId'),
          genderConfidence?: float(name='GenderConfidence'),
          faceAttributes?: {
            glassesConfidence?: float(name='GlassesConfidence'),
            glasses?: string(name='Glasses'),
            mask?: string(name='Mask'),
            beardConfidence?: float(name='BeardConfidence'),
            maskConfidence?: float(name='MaskConfidence'),
            faceBoundary?: {
              top?: int32(name='Top'),
              width?: int32(name='Width'),
              height?: int32(name='Height'),
              left?: int32(name='Left'),
            }(name='FaceBoundary'),
            headPose?: {
              pitch?: float(name='Pitch'),
              roll?: float(name='Roll'),
              yaw?: float(name='Yaw'),
            }(name='HeadPose'),
            beard?: string(name='Beard'),
          }(name='FaceAttributes'),
          faceQuality?: float(name='FaceQuality'),
          emotion?: string(name='Emotion'),
          age?: int32(name='Age'),
          faceConfidence?: float(name='FaceConfidence'),
          emotionConfidence?: float(name='EmotionConfidence'),
          attractive?: float(name='Attractive'),
          groupId?: string(name='GroupId'),
          emotionDetails?: {
            HAPPY?: float(name='HAPPY'),
            SURPRISED?: float(name='SURPRISED'),
            CALM?: float(name='CALM'),
            DISGUSTED?: float(name='DISGUSTED'),
            ANGRY?: float(name='ANGRY'),
            SAD?: float(name='SAD'),
            SCARED?: float(name='SCARED'),
          }(name='EmotionDetails'),
        }
      ](name='Faces'),
      imageQualityStatus?: string(name='ImageQualityStatus'),
      OCRFailReason?: string(name='OCRFailReason'),
      addressFailReason?: string(name='AddressFailReason'),
      imageQuality?: {
        overallScore?: float(name='OverallScore'),
        color?: float(name='Color'),
        colorScore?: float(name='ColorScore'),
        contrastScore?: float(name='ContrastScore'),
        contrast?: float(name='Contrast'),
        exposureScore?: float(name='ExposureScore'),
        clarityScore?: float(name='ClarityScore'),
        clarity?: float(name='Clarity'),
        exposure?: float(name='Exposure'),
        compositionScore?: float(name='CompositionScore'),
      }(name='ImageQuality'),
      croppingSuggestionModifyTime?: string(name='CroppingSuggestionModifyTime'),
      imageFormat?: string(name='ImageFormat'),
      imageWidth?: int32(name='ImageWidth'),
      remarksArrayB?: string(name='RemarksArrayB'),
      croppingSuggestion?: [ 
        {
          score?: float(name='Score'),
          croppingBoundary?: {
            top?: int32(name='Top'),
            width?: int32(name='Width'),
            height?: int32(name='Height'),
            left?: int32(name='Left'),
          }(name='CroppingBoundary'),
          aspectRatio?: string(name='AspectRatio'),
        }
      ](name='CroppingSuggestion'),
      orientation?: string(name='Orientation'),
      remarksD?: string(name='RemarksD'),
      tagsStatus?: string(name='TagsStatus'),
      croppingSuggestionFailReason?: string(name='CroppingSuggestionFailReason'),
      remarksA?: string(name='RemarksA'),
      imageUri?: string(name='ImageUri'),
      tagsModifyTime?: string(name='TagsModifyTime'),
      OCRStatus?: string(name='OCRStatus'),
      addressStatus?: string(name='AddressStatus'),
      exif?: string(name='Exif'),
      location?: string(name='Location'),
      remarksB?: string(name='RemarksB'),
    }
  ](name='Images'),
  nextMarker?: string(name='NextMarker'),
  setId?: string(name='SetId'),
}

model ListImagesResponse = {
  headers: map[string]string(name='headers'),
  body: ListImagesResponseBody(name='body'),
}

async function listImagesWithOptions(request: ListImagesRequest, runtime: Util.RuntimeOptions): ListImagesResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["SetId"] = request.setId;
  query["CreateTimeStart"] = request.createTimeStart;
  query["Marker"] = request.marker;
  query["Limit"] = request.limit;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListImages',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listImages(request: ListImagesRequest): ListImagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listImagesWithOptions(request, runtime);
}

model ListOfficeConversionTaskRequest {
  project?: string(name='Project'),
  marker?: string(name='Marker'),
  maxKeys?: int32(name='MaxKeys'),
}

model ListOfficeConversionTaskResponseBody = {
  tasks?: [ 
    {
      status?: string(name='Status'),
      percent?: int32(name='Percent'),
      finishTime?: string(name='FinishTime'),
      createTime?: string(name='CreateTime'),
      pageCount?: int32(name='PageCount'),
      notifyTopicName?: string(name='NotifyTopicName'),
      notifyEndpoint?: string(name='NotifyEndpoint'),
      tgtUri?: string(name='TgtUri'),
      tgtType?: string(name='TgtType'),
      srcUri?: string(name='SrcUri'),
      imageSpec?: string(name='ImageSpec'),
      externalID?: string(name='ExternalID'),
      taskId?: string(name='TaskId'),
    }
  ](name='Tasks'),
  requestId?: string(name='RequestId'),
  nextMarker?: string(name='NextMarker'),
}

model ListOfficeConversionTaskResponse = {
  headers: map[string]string(name='headers'),
  body: ListOfficeConversionTaskResponseBody(name='body'),
}

async function listOfficeConversionTaskWithOptions(request: ListOfficeConversionTaskRequest, runtime: Util.RuntimeOptions): ListOfficeConversionTaskResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["Marker"] = request.marker;
  query["MaxKeys"] = request.maxKeys;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListOfficeConversionTask',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listOfficeConversionTask(request: ListOfficeConversionTaskRequest): ListOfficeConversionTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return listOfficeConversionTaskWithOptions(request, runtime);
}

model ListProjectAPIsRequest {
  project?: string(name='Project'),
}

model ListProjectAPIsResponseBody = {
  project?: string(name='Project'),
  requestId?: string(name='RequestId'),
  APIs?: [ string ](name='APIs'),
}

model ListProjectAPIsResponse = {
  headers: map[string]string(name='headers'),
  body: ListProjectAPIsResponseBody(name='body'),
}

async function listProjectAPIsWithOptions(request: ListProjectAPIsRequest, runtime: Util.RuntimeOptions): ListProjectAPIsResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListProjectAPIs',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listProjectAPIs(request: ListProjectAPIsRequest): ListProjectAPIsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listProjectAPIsWithOptions(request, runtime);
}

model ListProjectsRequest {
  marker?: string(name='Marker'),
  maxKeys?: int32(name='MaxKeys'),
}

model ListProjectsResponseBody = {
  requestId?: string(name='RequestId'),
  projects?: [ 
    {
      type?: string(name='Type'),
      CU?: int32(name='CU'),
      createTime?: string(name='CreateTime'),
      serviceRole?: string(name='ServiceRole'),
      endpoint?: string(name='Endpoint'),
      project?: string(name='Project'),
      regionId?: string(name='RegionId'),
      billingType?: string(name='BillingType'),
      modifyTime?: string(name='ModifyTime'),
    }
  ](name='Projects'),
  nextMarker?: string(name='NextMarker'),
}

model ListProjectsResponse = {
  headers: map[string]string(name='headers'),
  body: ListProjectsResponseBody(name='body'),
}

async function listProjectsWithOptions(request: ListProjectsRequest, runtime: Util.RuntimeOptions): ListProjectsResponse {
  Util.validateModel(request);
  var query = {};
  query["Marker"] = request.marker;
  query["MaxKeys"] = request.maxKeys;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListProjects',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listProjects(request: ListProjectsRequest): ListProjectsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listProjectsWithOptions(request, runtime);
}

model ListSetsRequest {
  project?: string(name='Project'),
  marker?: string(name='Marker'),
}

model ListSetsResponseBody = {
  requestId?: string(name='RequestId'),
  sets?: [ 
    {
      videoCount?: int32(name='VideoCount'),
      createTime?: string(name='CreateTime'),
      videoLength?: int32(name='VideoLength'),
      setId?: string(name='SetId'),
      imageCount?: int32(name='ImageCount'),
      faceCount?: int32(name='FaceCount'),
      setName?: string(name='SetName'),
      modifyTime?: string(name='ModifyTime'),
    }
  ](name='Sets'),
  nextMarker?: string(name='NextMarker'),
}

model ListSetsResponse = {
  headers: map[string]string(name='headers'),
  body: ListSetsResponseBody(name='body'),
}

async function listSetsWithOptions(request: ListSetsRequest, runtime: Util.RuntimeOptions): ListSetsResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["Marker"] = request.marker;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListSets',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSets(request: ListSetsRequest): ListSetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSetsWithOptions(request, runtime);
}

model ListSetTagsRequest {
  project?: string(name='Project'),
  setId?: string(name='SetId'),
}

model ListSetTagsResponseBody = {
  requestId?: string(name='RequestId'),
  setId?: string(name='SetId'),
  tags?: [ 
    {
      tagName?: string(name='TagName'),
      tagCount?: int32(name='TagCount'),
      tagLevel?: int32(name='TagLevel'),
    }
  ](name='Tags'),
}

model ListSetTagsResponse = {
  headers: map[string]string(name='headers'),
  body: ListSetTagsResponseBody(name='body'),
}

async function listSetTagsWithOptions(request: ListSetTagsRequest, runtime: Util.RuntimeOptions): ListSetTagsResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["SetId"] = request.setId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListSetTags',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSetTags(request: ListSetTagsRequest): ListSetTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSetTagsWithOptions(request, runtime);
}

model ListVideoAudiosRequest {
  project?: string(name='Project'),
  setId?: string(name='SetId'),
  videoUri?: string(name='VideoUri'),
  marker?: string(name='Marker'),
}

model ListVideoAudiosResponseBody = {
  requestId?: string(name='RequestId'),
  audios?: [ 
    {
      sourcePosition?: string(name='SourcePosition'),
      createTime?: string(name='CreateTime'),
      remarksC?: string(name='RemarksC'),
      audioDuration?: float(name='AudioDuration'),
      sourceType?: string(name='SourceType'),
      audioTextsStatus?: string(name='AudioTextsStatus'),
      audioFormat?: string(name='AudioFormat'),
      remarksD?: string(name='RemarksD'),
      processModifyTime?: string(name='ProcessModifyTime'),
      processFailReason?: string(name='ProcessFailReason'),
      audioUri?: string(name='AudioUri'),
      audioRate?: int32(name='AudioRate'),
      audioTextsModifyTime?: string(name='AudioTextsModifyTime'),
      remarksA?: string(name='RemarksA'),
      audioTexts?: [ 
        {
          endTime?: float(name='EndTime'),
          library?: string(name='Library'),
          confidence?: float(name='Confidence'),
          beginTime?: float(name='BeginTime'),
          channelId?: int32(name='ChannelId'),
          emotionValue?: float(name='EmotionValue'),
          speechRate?: int32(name='SpeechRate'),
          text?: string(name='Text'),
          person?: string(name='Person'),
          silenceDuration?: float(name='SilenceDuration'),
        }
      ](name='AudioTexts'),
      externalId?: string(name='ExternalId'),
      sourceUri?: string(name='SourceUri'),
      processStatus?: string(name='ProcessStatus'),
      audioTextsFailReason?: string(name='AudioTextsFailReason'),
      remarksB?: string(name='RemarksB'),
      fileSize?: int32(name='FileSize'),
      modifyTime?: string(name='ModifyTime'),
    }
  ](name='Audios'),
  videoUri?: string(name='VideoUri'),
  nextMarker?: string(name='NextMarker'),
  setId?: string(name='SetId'),
}

model ListVideoAudiosResponse = {
  headers: map[string]string(name='headers'),
  body: ListVideoAudiosResponseBody(name='body'),
}

async function listVideoAudiosWithOptions(request: ListVideoAudiosRequest, runtime: Util.RuntimeOptions): ListVideoAudiosResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["SetId"] = request.setId;
  query["VideoUri"] = request.videoUri;
  query["Marker"] = request.marker;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListVideoAudios',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listVideoAudios(request: ListVideoAudiosRequest): ListVideoAudiosResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVideoAudiosWithOptions(request, runtime);
}

model ListVideoFramesRequest {
  project?: string(name='Project'),
  setId?: string(name='SetId'),
  videoUri?: string(name='VideoUri'),
  marker?: string(name='Marker'),
}

model ListVideoFramesResponseBody = {
  frames?: [ 
    {
      tagsFailReason?: string(name='TagsFailReason'),
      remarksC?: string(name='RemarksC'),
      createTime?: string(name='CreateTime'),
      sourceType?: string(name='SourceType'),
      facesFailReason?: string(name='FacesFailReason'),
      tags?: [ 
        {
          tagConfidence?: float(name='TagConfidence'),
          tagName?: string(name='TagName'),
          tagLevel?: int32(name='TagLevel'),
          parentTagName?: string(name='ParentTagName'),
        }
      ](name='Tags'),
      facesModifyTime?: string(name='FacesModifyTime'),
      imageTime?: string(name='ImageTime'),
      OCRModifyTime?: string(name='OCRModifyTime'),
      OCR?: [ 
        {
          OCRConfidence?: float(name='OCRConfidence'),
          OCRContents?: string(name='OCRContents'),
          OCRBoundary?: {
            top?: int32(name='Top'),
            width?: int32(name='Width'),
            height?: int32(name='Height'),
            left?: int32(name='Left'),
          }(name='OCRBoundary'),
        }
      ](name='OCR'),
      facesStatus?: string(name='FacesStatus'),
      imageHeight?: int32(name='ImageHeight'),
      externalId?: string(name='ExternalId'),
      sourceUri?: string(name='SourceUri'),
      fileSize?: int32(name='FileSize'),
      modifyTime?: string(name='ModifyTime'),
      sourcePosition?: string(name='SourcePosition'),
      faces?: [ 
        {
          gender?: string(name='Gender'),
          faceId?: string(name='FaceId'),
          genderConfidence?: float(name='GenderConfidence'),
          faceAttributes?: {
            glassesConfidence?: float(name='GlassesConfidence'),
            glasses?: string(name='Glasses'),
            mask?: string(name='Mask'),
            beardConfidence?: float(name='BeardConfidence'),
            maskConfidence?: float(name='MaskConfidence'),
            faceBoundary?: {
              top?: int32(name='Top'),
              width?: int32(name='Width'),
              height?: int32(name='Height'),
              left?: int32(name='Left'),
            }(name='FaceBoundary'),
            headPose?: {
              pitch?: float(name='Pitch'),
              roll?: float(name='Roll'),
              yaw?: float(name='Yaw'),
            }(name='HeadPose'),
            beard?: string(name='Beard'),
          }(name='FaceAttributes'),
          faceQuality?: float(name='FaceQuality'),
          emotion?: string(name='Emotion'),
          age?: int32(name='Age'),
          faceConfidence?: float(name='FaceConfidence'),
          emotionConfidence?: float(name='EmotionConfidence'),
          attractive?: float(name='Attractive'),
          groupId?: string(name='GroupId'),
          emotionDetails?: {
            HAPPY?: float(name='HAPPY'),
            SURPRISED?: float(name='SURPRISED'),
            CALM?: float(name='CALM'),
            DISGUSTED?: float(name='DISGUSTED'),
            ANGRY?: float(name='ANGRY'),
            SAD?: float(name='SAD'),
            SCARED?: float(name='SCARED'),
          }(name='EmotionDetails'),
        }
      ](name='Faces'),
      OCRFailReason?: string(name='OCRFailReason'),
      imageFormat?: string(name='ImageFormat'),
      imageWidth?: int32(name='ImageWidth'),
      orientation?: string(name='Orientation'),
      remarksD?: string(name='RemarksD'),
      tagsStatus?: string(name='TagsStatus'),
      remarksA?: string(name='RemarksA'),
      imageUri?: string(name='ImageUri'),
      tagsModifyTime?: string(name='TagsModifyTime'),
      OCRStatus?: string(name='OCRStatus'),
      exif?: string(name='Exif'),
      location?: string(name='Location'),
      remarksB?: string(name='RemarksB'),
    }
  ](name='Frames'),
  requestId?: string(name='RequestId'),
  videoUri?: string(name='VideoUri'),
  nextMarker?: string(name='NextMarker'),
  setId?: string(name='SetId'),
}

model ListVideoFramesResponse = {
  headers: map[string]string(name='headers'),
  body: ListVideoFramesResponseBody(name='body'),
}

async function listVideoFramesWithOptions(request: ListVideoFramesRequest, runtime: Util.RuntimeOptions): ListVideoFramesResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["SetId"] = request.setId;
  query["VideoUri"] = request.videoUri;
  query["Marker"] = request.marker;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListVideoFrames',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listVideoFrames(request: ListVideoFramesRequest): ListVideoFramesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVideoFramesWithOptions(request, runtime);
}

model ListVideosRequest {
  project?: string(name='Project'),
  setId?: string(name='SetId'),
  createTimeStart?: string(name='CreateTimeStart'),
  marker?: string(name='Marker'),
}

model ListVideosResponseBody = {
  requestId?: string(name='RequestId'),
  nextMarker?: string(name='NextMarker'),
  setId?: string(name='SetId'),
  videos?: [ 
    {
      createTime?: string(name='CreateTime'),
      remarksC?: string(name='RemarksC'),
      videoTagsFailReason?: string(name='VideoTagsFailReason'),
      sourceType?: string(name='SourceType'),
      videoDuration?: float(name='VideoDuration'),
      videoTags?: [ 
        {
          tagName?: string(name='TagName'),
          tagConfidence?: float(name='TagConfidence'),
          tagLevel?: int32(name='TagLevel'),
          parentTagName?: string(name='ParentTagName'),
        }
      ](name='VideoTags'),
      processModifyTime?: string(name='ProcessModifyTime'),
      videoFrames?: int32(name='VideoFrames'),
      videoTagsStatus?: string(name='VideoTagsStatus'),
      externalId?: string(name='ExternalId'),
      sourceUri?: string(name='SourceUri'),
      fileSize?: int32(name='FileSize'),
      modifyTime?: string(name='ModifyTime'),
      sourcePosition?: string(name='SourcePosition'),
      videoWidth?: int32(name='VideoWidth'),
      videoFormat?: string(name='VideoFormat'),
      videoHeight?: int32(name='VideoHeight'),
      remarksD?: string(name='RemarksD'),
      videoUri?: string(name='VideoUri'),
      processFailReason?: string(name='ProcessFailReason'),
      videoTagsModifyTime?: string(name='VideoTagsModifyTime'),
      remarksA?: string(name='RemarksA'),
      processStatus?: string(name='ProcessStatus'),
      remarksB?: string(name='RemarksB'),
    }
  ](name='Videos'),
}

model ListVideosResponse = {
  headers: map[string]string(name='headers'),
  body: ListVideosResponseBody(name='body'),
}

async function listVideosWithOptions(request: ListVideosRequest, runtime: Util.RuntimeOptions): ListVideosResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["SetId"] = request.setId;
  query["CreateTimeStart"] = request.createTimeStart;
  query["Marker"] = request.marker;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListVideos',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listVideos(request: ListVideosRequest): ListVideosResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVideosWithOptions(request, runtime);
}

model ListVideoTasksRequest {
  project?: string(name='Project'),
  marker?: string(name='Marker'),
  maxKeys?: int32(name='MaxKeys'),
  taskType?: string(name='TaskType'),
}

model ListVideoTasksResponseBody = {
  tasks?: [ 
    {
      endTime?: string(name='EndTime'),
      status?: string(name='Status'),
      startTime?: string(name='StartTime'),
      taskType?: string(name='TaskType'),
      progress?: int32(name='Progress'),
      notifyEndpoint?: string(name='NotifyEndpoint'),
      errorMessage?: string(name='ErrorMessage'),
      parameters?: string(name='Parameters'),
      result?: string(name='Result'),
      taskId?: string(name='TaskId'),
      notifyTopicName?: string(name='NotifyTopicName'),
    }
  ](name='Tasks'),
  requestId?: string(name='RequestId'),
  nextMarker?: string(name='NextMarker'),
}

model ListVideoTasksResponse = {
  headers: map[string]string(name='headers'),
  body: ListVideoTasksResponseBody(name='body'),
}

async function listVideoTasksWithOptions(request: ListVideoTasksRequest, runtime: Util.RuntimeOptions): ListVideoTasksResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["Marker"] = request.marker;
  query["MaxKeys"] = request.maxKeys;
  query["TaskType"] = request.taskType;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListVideoTasks',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listVideoTasks(request: ListVideoTasksRequest): ListVideoTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVideoTasksWithOptions(request, runtime);
}

model OpenImmServiceRequest {
  ownerId?: long(name='OwnerId'),
}

model OpenImmServiceResponseBody = {
  requestId?: string(name='RequestId'),
  orderId?: string(name='OrderId'),
}

model OpenImmServiceResponse = {
  headers: map[string]string(name='headers'),
  body: OpenImmServiceResponseBody(name='body'),
}

async function openImmServiceWithOptions(request: OpenImmServiceRequest, runtime: Util.RuntimeOptions): OpenImmServiceResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerId"] = request.ownerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'OpenImmService',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function openImmService(request: OpenImmServiceRequest): OpenImmServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return openImmServiceWithOptions(request, runtime);
}

model PutProjectRequest {
  project?: string(name='Project'),
  serviceRole?: string(name='ServiceRole'),
  CU?: int32(name='CU'),
  type?: string(name='Type'),
  billingType?: string(name='BillingType'),
}

model PutProjectResponseBody = {
  project?: string(name='Project'),
  modifyTime?: string(name='ModifyTime'),
  type?: string(name='Type'),
  CU?: int32(name='CU'),
  serviceRole?: string(name='ServiceRole'),
  requestId?: string(name='RequestId'),
  endpoint?: string(name='Endpoint'),
  createTime?: string(name='CreateTime'),
  regionId?: string(name='RegionId'),
  billingType?: string(name='BillingType'),
}

model PutProjectResponse = {
  headers: map[string]string(name='headers'),
  body: PutProjectResponseBody(name='body'),
}

async function putProjectWithOptions(request: PutProjectRequest, runtime: Util.RuntimeOptions): PutProjectResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["ServiceRole"] = request.serviceRole;
  query["CU"] = request.CU;
  query["Type"] = request.type;
  query["BillingType"] = request.billingType;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'PutProject',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function putProject(request: PutProjectRequest): PutProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return putProjectWithOptions(request, runtime);
}

model RefreshOfficeEditTokenRequest {
  project?: string(name='Project'),
  accessToken?: string(name='AccessToken'),
  refreshToken?: string(name='RefreshToken'),
}

model RefreshOfficeEditTokenResponseBody = {
  refreshToken?: string(name='RefreshToken'),
  requestId?: string(name='RequestId'),
  accessToken?: string(name='AccessToken'),
  refreshTokenExpiredTime?: string(name='RefreshTokenExpiredTime'),
  accessTokenExpiredTime?: string(name='AccessTokenExpiredTime'),
}

model RefreshOfficeEditTokenResponse = {
  headers: map[string]string(name='headers'),
  body: RefreshOfficeEditTokenResponseBody(name='body'),
}

async function refreshOfficeEditTokenWithOptions(request: RefreshOfficeEditTokenRequest, runtime: Util.RuntimeOptions): RefreshOfficeEditTokenResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["AccessToken"] = request.accessToken;
  query["RefreshToken"] = request.refreshToken;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'RefreshOfficeEditToken',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function refreshOfficeEditToken(request: RefreshOfficeEditTokenRequest): RefreshOfficeEditTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return refreshOfficeEditTokenWithOptions(request, runtime);
}

model RefreshOfficePreviewTokenRequest {
  project?: string(name='Project'),
  accessToken?: string(name='AccessToken'),
  refreshToken?: string(name='RefreshToken'),
}

model RefreshOfficePreviewTokenResponseBody = {
  refreshToken?: string(name='RefreshToken'),
  requestId?: string(name='RequestId'),
  accessToken?: string(name='AccessToken'),
  refreshTokenExpiredTime?: string(name='RefreshTokenExpiredTime'),
  accessTokenExpiredTime?: string(name='AccessTokenExpiredTime'),
}

model RefreshOfficePreviewTokenResponse = {
  headers: map[string]string(name='headers'),
  body: RefreshOfficePreviewTokenResponseBody(name='body'),
}

async function refreshOfficePreviewTokenWithOptions(request: RefreshOfficePreviewTokenRequest, runtime: Util.RuntimeOptions): RefreshOfficePreviewTokenResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["AccessToken"] = request.accessToken;
  query["RefreshToken"] = request.refreshToken;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'RefreshOfficePreviewToken',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function refreshOfficePreviewToken(request: RefreshOfficePreviewTokenRequest): RefreshOfficePreviewTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return refreshOfficePreviewTokenWithOptions(request, runtime);
}

model RefreshWebofficeTokenRequest {
  project?: string(name='Project'),
  accessToken?: string(name='AccessToken'),
  refreshToken?: string(name='RefreshToken'),
}

model RefreshWebofficeTokenResponseBody = {
  refreshToken?: string(name='RefreshToken'),
  requestId?: string(name='RequestId'),
  accessToken?: string(name='AccessToken'),
  refreshTokenExpiredTime?: string(name='RefreshTokenExpiredTime'),
  accessTokenExpiredTime?: string(name='AccessTokenExpiredTime'),
}

model RefreshWebofficeTokenResponse = {
  headers: map[string]string(name='headers'),
  body: RefreshWebofficeTokenResponseBody(name='body'),
}

async function refreshWebofficeTokenWithOptions(request: RefreshWebofficeTokenRequest, runtime: Util.RuntimeOptions): RefreshWebofficeTokenResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["AccessToken"] = request.accessToken;
  query["RefreshToken"] = request.refreshToken;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'RefreshWebofficeToken',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function refreshWebofficeToken(request: RefreshWebofficeTokenRequest): RefreshWebofficeTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return refreshWebofficeTokenWithOptions(request, runtime);
}

model UpdateFaceGroupRequest {
  project?: string(name='Project'),
  setId?: string(name='SetId'),
  groupId?: string(name='GroupId'),
  groupName?: string(name='GroupName'),
  groupCoverFaceId?: string(name='GroupCoverFaceId'),
  remarksA?: string(name='RemarksA'),
  remarksB?: string(name='RemarksB'),
  remarksC?: string(name='RemarksC'),
  remarksD?: string(name='RemarksD'),
  remarksArrayA?: string(name='RemarksArrayA'),
  remarksArrayB?: string(name='RemarksArrayB'),
  externalId?: string(name='ExternalId'),
  resetItems?: string(name='ResetItems'),
}

model UpdateFaceGroupResponseBody = {
  requestId?: string(name='RequestId'),
  setId?: string(name='SetId'),
  groupId?: string(name='GroupId'),
}

model UpdateFaceGroupResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateFaceGroupResponseBody(name='body'),
}

async function updateFaceGroupWithOptions(request: UpdateFaceGroupRequest, runtime: Util.RuntimeOptions): UpdateFaceGroupResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["SetId"] = request.setId;
  query["GroupId"] = request.groupId;
  query["GroupName"] = request.groupName;
  query["GroupCoverFaceId"] = request.groupCoverFaceId;
  query["RemarksA"] = request.remarksA;
  query["RemarksB"] = request.remarksB;
  query["RemarksC"] = request.remarksC;
  query["RemarksD"] = request.remarksD;
  query["RemarksArrayA"] = request.remarksArrayA;
  query["RemarksArrayB"] = request.remarksArrayB;
  query["ExternalId"] = request.externalId;
  query["ResetItems"] = request.resetItems;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateFaceGroup',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateFaceGroup(request: UpdateFaceGroupRequest): UpdateFaceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateFaceGroupWithOptions(request, runtime);
}

model UpdateImageRequest {
  project?: string(name='Project'),
  setId?: string(name='SetId'),
  imageUri?: string(name='ImageUri'),
  remarksA?: string(name='RemarksA'),
  remarksB?: string(name='RemarksB'),
  sourceType?: string(name='SourceType'),
  sourceUri?: string(name='SourceUri'),
  sourcePosition?: string(name='SourcePosition'),
  remarksC?: string(name='RemarksC'),
  remarksD?: string(name='RemarksD'),
  externalId?: string(name='ExternalId'),
  remarksArrayA?: string(name='RemarksArrayA'),
  remarksArrayB?: string(name='RemarksArrayB'),
}

model UpdateImageResponseBody = {
  remarksArrayB?: string(name='RemarksArrayB'),
  modifyTime?: string(name='ModifyTime'),
  remarksC?: string(name='RemarksC'),
  remarksD?: string(name='RemarksD'),
  requestId?: string(name='RequestId'),
  createTime?: string(name='CreateTime'),
  externalId?: string(name='ExternalId'),
  remarksArrayA?: string(name='RemarksArrayA'),
  remarksA?: string(name='RemarksA'),
  imageUri?: string(name='ImageUri'),
  setId?: string(name='SetId'),
  remarksB?: string(name='RemarksB'),
}

model UpdateImageResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateImageResponseBody(name='body'),
}

async function updateImageWithOptions(request: UpdateImageRequest, runtime: Util.RuntimeOptions): UpdateImageResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["SetId"] = request.setId;
  query["ImageUri"] = request.imageUri;
  query["RemarksA"] = request.remarksA;
  query["RemarksB"] = request.remarksB;
  query["SourceType"] = request.sourceType;
  query["SourceUri"] = request.sourceUri;
  query["SourcePosition"] = request.sourcePosition;
  query["RemarksC"] = request.remarksC;
  query["RemarksD"] = request.remarksD;
  query["ExternalId"] = request.externalId;
  query["RemarksArrayA"] = request.remarksArrayA;
  query["RemarksArrayB"] = request.remarksArrayB;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateImage',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateImage(request: UpdateImageRequest): UpdateImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateImageWithOptions(request, runtime);
}

model UpdateProjectRequest {
  project?: string(name='Project'),
  newCU?: int32(name='NewCU'),
  newServiceRole?: string(name='NewServiceRole'),
}

model UpdateProjectResponseBody = {
  project?: string(name='Project'),
  modifyTime?: string(name='ModifyTime'),
  type?: string(name='Type'),
  CU?: int32(name='CU'),
  serviceRole?: string(name='ServiceRole'),
  requestId?: string(name='RequestId'),
  createTime?: string(name='CreateTime'),
  regionId?: string(name='RegionId'),
}

model UpdateProjectResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateProjectResponseBody(name='body'),
}

async function updateProjectWithOptions(request: UpdateProjectRequest, runtime: Util.RuntimeOptions): UpdateProjectResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["NewCU"] = request.newCU;
  query["NewServiceRole"] = request.newServiceRole;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateProject',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateProject(request: UpdateProjectRequest): UpdateProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateProjectWithOptions(request, runtime);
}

model UpdateSetRequest {
  project?: string(name='Project'),
  setId?: string(name='SetId'),
  setName?: string(name='SetName'),
}

model UpdateSetResponseBody = {
  modifyTime?: string(name='ModifyTime'),
  requestId?: string(name='RequestId'),
  createTime?: string(name='CreateTime'),
  setName?: string(name='SetName'),
  setId?: string(name='SetId'),
}

model UpdateSetResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateSetResponseBody(name='body'),
}

async function updateSetWithOptions(request: UpdateSetRequest, runtime: Util.RuntimeOptions): UpdateSetResponse {
  Util.validateModel(request);
  var query = {};
  query["Project"] = request.project;
  query["SetId"] = request.setId;
  query["SetName"] = request.setName;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSet',
    version = '2017-09-06',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateSet(request: UpdateSetRequest): UpdateSetResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSetWithOptions(request, runtime);
}

