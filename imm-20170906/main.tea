/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  @endpointMap = {
    cn-beijing-gov-1 = 'imm-vpc.cn-beijing-gov-1.aliyuncs.com',
  };
  checkConfig(config);
  @endpoint = getEndpoint('imm', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model CompareImageFacesRequest {
  project?: string(name='Project'),
  setId?: string(name='SetId'),
  imageUriA?: string(name='ImageUriA'),
  imageUriB?: string(name='ImageUriB'),
  faceIdA?: string(name='FaceIdA'),
  faceIdB?: string(name='FaceIdB'),
}

model CompareImageFacesResponseBody = {
  requestId?: string(name='RequestId'),
  similarity?: float(name='Similarity'),
  setId?: string(name='SetId'),
  faceA?: {
    faceId?: string(name='FaceId'),
    faceAttributes?: {
      faceBoundary?: {
        left?: int32(name='Left'),
        top?: int32(name='Top'),
        width?: int32(name='Width'),
        height?: int32(name='Height'),
      }(name='FaceBoundary'),
    }(name='FaceAttributes'),
  }(name='FaceA'),
  faceB?: {
    faceId?: string(name='FaceId'),
    faceAttributes?: {
      faceBoundary?: {
        left?: int32(name='Left'),
        top?: int32(name='Top'),
        width?: int32(name='Width'),
        height?: int32(name='Height'),
      }(name='FaceBoundary'),
    }(name='FaceAttributes'),
  }(name='FaceB'),
}

model CompareImageFacesResponse = {
  headers: map[string]string(name='headers'),
  body: CompareImageFacesResponseBody(name='body'),
}

async function compareImageFacesWithOptions(request: CompareImageFacesRequest, runtime: Util.RuntimeOptions): CompareImageFacesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CompareImageFaces', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function compareImageFaces(request: CompareImageFacesRequest): CompareImageFacesResponse {
  var runtime = new Util.RuntimeOptions{};
  return compareImageFacesWithOptions(request, runtime);
}

model ConvertOfficeFormatRequest {
  project?: string(name='Project'),
  srcUri?: string(name='SrcUri'),
  tgtType?: string(name='TgtType'),
  tgtUri?: string(name='TgtUri'),
  srcType?: string(name='SrcType'),
  startPage?: long(name='StartPage'),
  endPage?: long(name='EndPage'),
  maxSheetRow?: long(name='MaxSheetRow'),
  maxSheetCol?: long(name='MaxSheetCol'),
  maxSheetCount?: long(name='MaxSheetCount'),
  sheetOnePage?: boolean(name='SheetOnePage'),
  modelId?: string(name='ModelId'),
  password?: string(name='Password'),
  tgtFilePrefix?: string(name='TgtFilePrefix'),
  tgtFileSuffix?: string(name='TgtFileSuffix'),
  tgtFilePages?: string(name='TgtFilePages'),
  fitToPagesTall?: boolean(name='FitToPagesTall'),
  fitToPagesWide?: boolean(name='FitToPagesWide'),
  pdfVector?: boolean(name='PdfVector'),
  hidecomments?: boolean(name='Hidecomments'),
}

model ConvertOfficeFormatResponseBody = {
  pageCount?: int32(name='PageCount'),
  requestId?: string(name='RequestId'),
}

model ConvertOfficeFormatResponse = {
  headers: map[string]string(name='headers'),
  body: ConvertOfficeFormatResponseBody(name='body'),
}

async function convertOfficeFormatWithOptions(request: ConvertOfficeFormatRequest, runtime: Util.RuntimeOptions): ConvertOfficeFormatResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ConvertOfficeFormat', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function convertOfficeFormat(request: ConvertOfficeFormatRequest): ConvertOfficeFormatResponse {
  var runtime = new Util.RuntimeOptions{};
  return convertOfficeFormatWithOptions(request, runtime);
}

model CreateGrabFrameTaskRequest {
  project?: string(name='Project'),
  videoUri?: string(name='VideoUri'),
  notifyTopicName?: string(name='NotifyTopicName'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
  targetList?: string(name='TargetList'),
  customMessage?: string(name='CustomMessage'),
}

model CreateGrabFrameTaskResponseBody = {
  taskType?: string(name='TaskType'),
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model CreateGrabFrameTaskResponse = {
  headers: map[string]string(name='headers'),
  body: CreateGrabFrameTaskResponseBody(name='body'),
}

async function createGrabFrameTaskWithOptions(request: CreateGrabFrameTaskRequest, runtime: Util.RuntimeOptions): CreateGrabFrameTaskResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateGrabFrameTask', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createGrabFrameTask(request: CreateGrabFrameTaskRequest): CreateGrabFrameTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createGrabFrameTaskWithOptions(request, runtime);
}

model CreateGroupFacesJobRequest {
  project?: string(name='Project'),
  setId?: string(name='SetId'),
  notifyTopicName?: string(name='NotifyTopicName'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
}

model CreateGroupFacesJobResponseBody = {
  jobType?: string(name='JobType'),
  requestId?: string(name='RequestId'),
  setId?: string(name='SetId'),
  jobId?: string(name='JobId'),
}

model CreateGroupFacesJobResponse = {
  headers: map[string]string(name='headers'),
  body: CreateGroupFacesJobResponseBody(name='body'),
}

async function createGroupFacesJobWithOptions(request: CreateGroupFacesJobRequest, runtime: Util.RuntimeOptions): CreateGroupFacesJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateGroupFacesJob', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createGroupFacesJob(request: CreateGroupFacesJobRequest): CreateGroupFacesJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return createGroupFacesJobWithOptions(request, runtime);
}

model CreateImageProcessTaskRequest {
  project?: string(name='Project'),
  imageUri?: string(name='ImageUri'),
  notifyTopicName?: string(name='NotifyTopicName'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
  targetList?: string(name='TargetList'),
}

model CreateImageProcessTaskResponseBody = {
  taskType?: string(name='TaskType'),
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model CreateImageProcessTaskResponse = {
  headers: map[string]string(name='headers'),
  body: CreateImageProcessTaskResponseBody(name='body'),
}

async function createImageProcessTaskWithOptions(request: CreateImageProcessTaskRequest, runtime: Util.RuntimeOptions): CreateImageProcessTaskResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateImageProcessTask', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createImageProcessTask(request: CreateImageProcessTaskRequest): CreateImageProcessTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createImageProcessTaskWithOptions(request, runtime);
}

model CreateMediaComplexTaskRequest {
  project?: string(name='Project'),
  parameters?: string(name='Parameters'),
  notifyTopicName?: string(name='NotifyTopicName'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
}

model CreateMediaComplexTaskResponseBody = {
  taskType?: string(name='TaskType'),
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model CreateMediaComplexTaskResponse = {
  headers: map[string]string(name='headers'),
  body: CreateMediaComplexTaskResponseBody(name='body'),
}

async function createMediaComplexTaskWithOptions(request: CreateMediaComplexTaskRequest, runtime: Util.RuntimeOptions): CreateMediaComplexTaskResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateMediaComplexTask', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createMediaComplexTask(request: CreateMediaComplexTaskRequest): CreateMediaComplexTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMediaComplexTaskWithOptions(request, runtime);
}

model CreateMergeFaceGroupsJobRequest {
  project?: string(name='Project'),
  setId?: string(name='SetId'),
  notifyTopicName?: string(name='NotifyTopicName'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
  groupIdFrom?: string(name='GroupIdFrom'),
  groupIdTo?: string(name='GroupIdTo'),
  customMessage?: string(name='CustomMessage'),
}

model CreateMergeFaceGroupsJobResponseBody = {
  groupIdFrom?: string(name='GroupIdFrom'),
  jobType?: string(name='JobType'),
  requestId?: string(name='RequestId'),
  setId?: string(name='SetId'),
  groupIdTo?: string(name='GroupIdTo'),
  jobId?: string(name='JobId'),
}

model CreateMergeFaceGroupsJobResponse = {
  headers: map[string]string(name='headers'),
  body: CreateMergeFaceGroupsJobResponseBody(name='body'),
}

async function createMergeFaceGroupsJobWithOptions(request: CreateMergeFaceGroupsJobRequest, runtime: Util.RuntimeOptions): CreateMergeFaceGroupsJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateMergeFaceGroupsJob', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createMergeFaceGroupsJob(request: CreateMergeFaceGroupsJobRequest): CreateMergeFaceGroupsJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMergeFaceGroupsJobWithOptions(request, runtime);
}

model CreateOfficeConversionTaskRequest {
  project?: string(name='Project'),
  srcUri?: string(name='SrcUri'),
  tgtType?: string(name='TgtType'),
  tgtUri?: string(name='TgtUri'),
  notifyTopicName?: string(name='NotifyTopicName'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
  srcType?: string(name='SrcType'),
  startPage?: long(name='StartPage'),
  endPage?: long(name='EndPage'),
  maxSheetRow?: long(name='MaxSheetRow'),
  maxSheetCol?: long(name='MaxSheetCol'),
  maxSheetCount?: long(name='MaxSheetCount'),
  sheetOnePage?: boolean(name='SheetOnePage'),
  modelId?: string(name='ModelId'),
  password?: string(name='Password'),
  tgtFilePrefix?: string(name='TgtFilePrefix'),
  tgtFileSuffix?: string(name='TgtFileSuffix'),
  tgtFilePages?: string(name='TgtFilePages'),
  fitToPagesTall?: boolean(name='FitToPagesTall'),
  fitToPagesWide?: boolean(name='FitToPagesWide'),
  idempotentToken?: string(name='IdempotentToken'),
  pdfVector?: boolean(name='PdfVector'),
  hidecomments?: boolean(name='Hidecomments'),
  displayDpi?: int32(name='DisplayDpi'),
  userData?: string(name='UserData'),
}

model CreateOfficeConversionTaskResponseBody = {
  status?: string(name='Status'),
  taskId?: string(name='TaskId'),
  requestId?: string(name='RequestId'),
  percent?: int32(name='Percent'),
  createTime?: string(name='CreateTime'),
  tgtLoc?: string(name='TgtLoc'),
}

model CreateOfficeConversionTaskResponse = {
  headers: map[string]string(name='headers'),
  body: CreateOfficeConversionTaskResponseBody(name='body'),
}

async function createOfficeConversionTaskWithOptions(request: CreateOfficeConversionTaskRequest, runtime: Util.RuntimeOptions): CreateOfficeConversionTaskResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateOfficeConversionTask', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createOfficeConversionTask(request: CreateOfficeConversionTaskRequest): CreateOfficeConversionTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOfficeConversionTaskWithOptions(request, runtime);
}

model CreateSetRequest {
  project?: string(name='Project'),
  setId?: string(name='SetId'),
  setName?: string(name='SetName'),
}

model CreateSetResponseBody = {
  videoCount?: int32(name='VideoCount'),
  requestId?: string(name='RequestId'),
  createTime?: string(name='CreateTime'),
  videoLength?: int32(name='VideoLength'),
  setId?: string(name='SetId'),
  imageCount?: int32(name='ImageCount'),
  faceCount?: int32(name='FaceCount'),
  setName?: string(name='SetName'),
  modifyTime?: string(name='ModifyTime'),
}

model CreateSetResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSetResponseBody(name='body'),
}

async function createSetWithOptions(request: CreateSetRequest, runtime: Util.RuntimeOptions): CreateSetResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateSet', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createSet(request: CreateSetRequest): CreateSetResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSetWithOptions(request, runtime);
}

model CreateVideoAbstractTaskRequest {
  project?: string(name='Project'),
  videoUri?: string(name='VideoUri'),
  notifyTopicName?: string(name='NotifyTopicName'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
  targetVideoUri?: string(name='TargetVideoUri'),
  targetClipsUri?: string(name='TargetClipsUri'),
  abstractLength?: int32(name='AbstractLength'),
}

model CreateVideoAbstractTaskResponseBody = {
  taskType?: string(name='TaskType'),
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model CreateVideoAbstractTaskResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVideoAbstractTaskResponseBody(name='body'),
}

async function createVideoAbstractTaskWithOptions(request: CreateVideoAbstractTaskRequest, runtime: Util.RuntimeOptions): CreateVideoAbstractTaskResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateVideoAbstractTask', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createVideoAbstractTask(request: CreateVideoAbstractTaskRequest): CreateVideoAbstractTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVideoAbstractTaskWithOptions(request, runtime);
}

model CreateVideoAnalyseTaskRequest {
  project?: string(name='Project'),
  videoUri?: string(name='VideoUri'),
  tgtUri?: string(name='TgtUri'),
  notifyTopicName?: string(name='NotifyTopicName'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
}

model CreateVideoAnalyseTaskResponseBody = {
  taskType?: string(name='TaskType'),
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model CreateVideoAnalyseTaskResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVideoAnalyseTaskResponseBody(name='body'),
}

async function createVideoAnalyseTaskWithOptions(request: CreateVideoAnalyseTaskRequest, runtime: Util.RuntimeOptions): CreateVideoAnalyseTaskResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateVideoAnalyseTask', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createVideoAnalyseTask(request: CreateVideoAnalyseTaskRequest): CreateVideoAnalyseTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVideoAnalyseTaskWithOptions(request, runtime);
}

model CreateVideoCompressTaskRequest {
  project?: string(name='Project'),
  videoUri?: string(name='VideoUri'),
  notifyTopicName?: string(name='NotifyTopicName'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
  targetList?: string(name='TargetList'),
  customMessage?: string(name='CustomMessage'),
  targetContainer?: string(name='TargetContainer'),
  targetSegment?: string(name='TargetSegment'),
}

model CreateVideoCompressTaskResponseBody = {
  taskId?: string(name='TaskId'),
  requestId?: string(name='RequestId'),
  taskType?: string(name='TaskType'),
}

model CreateVideoCompressTaskResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVideoCompressTaskResponseBody(name='body'),
}

async function createVideoCompressTaskWithOptions(request: CreateVideoCompressTaskRequest, runtime: Util.RuntimeOptions): CreateVideoCompressTaskResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateVideoCompressTask', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createVideoCompressTask(request: CreateVideoCompressTaskRequest): CreateVideoCompressTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVideoCompressTaskWithOptions(request, runtime);
}

model CreateVideoProduceTaskRequest {
  project?: string(name='Project'),
  images?: string(name='Images'),
  notifyTopicName?: string(name='NotifyTopicName'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
  targetUri?: string(name='TargetUri'),
  customMessage?: string(name='CustomMessage'),
  music?: string(name='Music'),
  width?: int32(name='Width'),
  height?: int32(name='Height'),
  templateName?: string(name='TemplateName'),
}

model CreateVideoProduceTaskResponseBody = {
  taskType?: string(name='TaskType'),
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model CreateVideoProduceTaskResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVideoProduceTaskResponseBody(name='body'),
}

async function createVideoProduceTaskWithOptions(request: CreateVideoProduceTaskRequest, runtime: Util.RuntimeOptions): CreateVideoProduceTaskResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateVideoProduceTask', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createVideoProduceTask(request: CreateVideoProduceTaskRequest): CreateVideoProduceTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVideoProduceTaskWithOptions(request, runtime);
}

model DecodeBlindWatermarkRequest {
  project?: string(name='Project'),
  imageUri?: string(name='ImageUri'),
  originalImageUri?: string(name='OriginalImageUri'),
  targetUri?: string(name='TargetUri'),
  imageQuality?: int32(name='ImageQuality'),
  model?: string(name='Model'),
}

model DecodeBlindWatermarkResponseBody = {
  requestId?: string(name='RequestId'),
  targetUri?: string(name='TargetUri'),
  content?: string(name='Content'),
}

model DecodeBlindWatermarkResponse = {
  headers: map[string]string(name='headers'),
  body: DecodeBlindWatermarkResponseBody(name='body'),
}

async function decodeBlindWatermarkWithOptions(request: DecodeBlindWatermarkRequest, runtime: Util.RuntimeOptions): DecodeBlindWatermarkResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DecodeBlindWatermark', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function decodeBlindWatermark(request: DecodeBlindWatermarkRequest): DecodeBlindWatermarkResponse {
  var runtime = new Util.RuntimeOptions{};
  return decodeBlindWatermarkWithOptions(request, runtime);
}

model DeleteImageRequest {
  project?: string(name='Project'),
  setId?: string(name='SetId'),
  imageUri?: string(name='ImageUri'),
}

model DeleteImageResponseBody = {
  requestId?: string(name='RequestId'),
  setId?: string(name='SetId'),
  imageUri?: string(name='ImageUri'),
}

model DeleteImageResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteImageResponseBody(name='body'),
}

async function deleteImageWithOptions(request: DeleteImageRequest, runtime: Util.RuntimeOptions): DeleteImageResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteImage', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteImage(request: DeleteImageRequest): DeleteImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteImageWithOptions(request, runtime);
}

model DeleteImageJobRequest {
  project?: string(name='Project'),
  jobType?: string(name='JobType'),
  jobId?: string(name='JobId'),
}

model DeleteImageJobResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteImageJobResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteImageJobResponseBody(name='body'),
}

async function deleteImageJobWithOptions(request: DeleteImageJobRequest, runtime: Util.RuntimeOptions): DeleteImageJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteImageJob', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteImageJob(request: DeleteImageJobRequest): DeleteImageJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteImageJobWithOptions(request, runtime);
}

model DeleteOfficeConversionTaskRequest {
  project?: string(name='Project'),
  taskId?: string(name='TaskId'),
}

model DeleteOfficeConversionTaskResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteOfficeConversionTaskResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteOfficeConversionTaskResponseBody(name='body'),
}

async function deleteOfficeConversionTaskWithOptions(request: DeleteOfficeConversionTaskRequest, runtime: Util.RuntimeOptions): DeleteOfficeConversionTaskResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteOfficeConversionTask', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteOfficeConversionTask(request: DeleteOfficeConversionTaskRequest): DeleteOfficeConversionTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteOfficeConversionTaskWithOptions(request, runtime);
}

model DeleteProjectRequest {
  project?: string(name='Project'),
}

model DeleteProjectResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteProjectResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteProjectResponseBody(name='body'),
}

async function deleteProjectWithOptions(request: DeleteProjectRequest, runtime: Util.RuntimeOptions): DeleteProjectResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteProject', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteProject(request: DeleteProjectRequest): DeleteProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteProjectWithOptions(request, runtime);
}

model DeleteSetRequest {
  project?: string(name='Project'),
  setId?: string(name='SetId'),
}

model DeleteSetResponseBody = {
  setId?: string(name='SetId'),
  requestId?: string(name='RequestId'),
}

model DeleteSetResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSetResponseBody(name='body'),
}

async function deleteSetWithOptions(request: DeleteSetRequest, runtime: Util.RuntimeOptions): DeleteSetResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteSet', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteSet(request: DeleteSetRequest): DeleteSetResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSetWithOptions(request, runtime);
}

model DeleteVideoRequest {
  project?: string(name='Project'),
  setId?: string(name='SetId'),
  videoUri?: string(name='VideoUri'),
  resources?: boolean(name='Resources'),
}

model DeleteVideoResponseBody = {
  requestId?: string(name='RequestId'),
  videoUri?: string(name='VideoUri'),
  setId?: string(name='SetId'),
}

model DeleteVideoResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVideoResponseBody(name='body'),
}

async function deleteVideoWithOptions(request: DeleteVideoRequest, runtime: Util.RuntimeOptions): DeleteVideoResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteVideo', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteVideo(request: DeleteVideoRequest): DeleteVideoResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVideoWithOptions(request, runtime);
}

model DeleteVideoTaskRequest {
  project?: string(name='Project'),
  taskType?: string(name='TaskType'),
  taskId?: string(name='TaskId'),
}

model DeleteVideoTaskResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVideoTaskResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVideoTaskResponseBody(name='body'),
}

async function deleteVideoTaskWithOptions(request: DeleteVideoTaskRequest, runtime: Util.RuntimeOptions): DeleteVideoTaskResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteVideoTask', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteVideoTask(request: DeleteVideoTaskRequest): DeleteVideoTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVideoTaskWithOptions(request, runtime);
}

model DescribeRegionsResponseBody = {
  requestId?: string(name='RequestId'),
  regions?: {
    region?: [ 
      {
        regionId?: string(name='RegionId'),
        projectTypes?: [ string ](name='ProjectTypes'),
      }
    ](name='Region'),
  }(name='Regions'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegionsWithOptions(runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  var req = new OpenApi.OpenApiRequest{};
  return doRPCRequest('DescribeRegions', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeRegions(): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(runtime);
}

model DetectImageBodiesRequest {
  project?: string(name='Project'),
  imageUri?: string(name='ImageUri'),
}

model DetectImageBodiesResponseBody = {
  imageUri?: string(name='ImageUri'),
  requestId?: string(name='RequestId'),
  bodies?: [ 
    {
      bodyConfidence?: float(name='BodyConfidence'),
      bodyBoundary?: {
        left?: int32(name='Left'),
        top?: int32(name='Top'),
        width?: int32(name='Width'),
        height?: int32(name='Height'),
      }(name='BodyBoundary'),
    }
  ](name='Bodies'),
}

model DetectImageBodiesResponse = {
  headers: map[string]string(name='headers'),
  body: DetectImageBodiesResponseBody(name='body'),
}

async function detectImageBodiesWithOptions(request: DetectImageBodiesRequest, runtime: Util.RuntimeOptions): DetectImageBodiesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DetectImageBodies', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function detectImageBodies(request: DetectImageBodiesRequest): DetectImageBodiesResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectImageBodiesWithOptions(request, runtime);
}

model DetectImageFacesRequest {
  project?: string(name='Project'),
  imageUri?: string(name='ImageUri'),
}

model DetectImageFacesResponseBody = {
  imageUri?: string(name='ImageUri'),
  requestId?: string(name='RequestId'),
  faces?: [ 
    {
      emotionConfidence?: float(name='EmotionConfidence'),
      attractive?: float(name='Attractive'),
      attractiveConfidence?: float(name='AttractiveConfidence'),
      gender?: string(name='Gender'),
      ageConfidence?: float(name='AgeConfidence'),
      genderConfidence?: float(name='GenderConfidence'),
      faceId?: string(name='FaceId'),
      faceQuality?: float(name='FaceQuality'),
      emotion?: string(name='Emotion'),
      age?: int32(name='Age'),
      faceConfidence?: float(name='FaceConfidence'),
      faceAttributes?: {
        glassesConfidence?: float(name='GlassesConfidence'),
        glasses?: string(name='Glasses'),
        mask?: string(name='Mask'),
        beardConfidence?: float(name='BeardConfidence'),
        maskConfidence?: float(name='MaskConfidence'),
        beard?: string(name='Beard'),
        faceBoundary?: {
          left?: int32(name='Left'),
          top?: int32(name='Top'),
          width?: int32(name='Width'),
          height?: int32(name='Height'),
        }(name='FaceBoundary'),
        headPose?: {
          pitch?: float(name='Pitch'),
          roll?: float(name='Roll'),
          yaw?: float(name='Yaw'),
        }(name='HeadPose'),
      }(name='FaceAttributes'),
      emotionDetails?: {
        HAPPY?: float(name='HAPPY'),
        CALM?: float(name='CALM'),
        SURPRISED?: float(name='SURPRISED'),
        DISGUSTED?: float(name='DISGUSTED'),
        ANGRY?: float(name='ANGRY'),
        SAD?: float(name='SAD'),
        SCARED?: float(name='SCARED'),
      }(name='EmotionDetails'),
    }
  ](name='Faces'),
}

model DetectImageFacesResponse = {
  headers: map[string]string(name='headers'),
  body: DetectImageFacesResponseBody(name='body'),
}

async function detectImageFacesWithOptions(request: DetectImageFacesRequest, runtime: Util.RuntimeOptions): DetectImageFacesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DetectImageFaces', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function detectImageFaces(request: DetectImageFacesRequest): DetectImageFacesResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectImageFacesWithOptions(request, runtime);
}

model DetectImageLogosRequest {
  project?: string(name='Project'),
  imageUri?: string(name='ImageUri'),
}

model DetectImageLogosResponseBody = {
  imageUri?: string(name='ImageUri'),
  requestId?: string(name='RequestId'),
  logos?: [ 
    {
      logoConfidence?: float(name='LogoConfidence'),
      logoName?: string(name='LogoName'),
      logoBoundary?: {
        left?: int32(name='Left'),
        top?: int32(name='Top'),
        width?: int32(name='Width'),
        height?: int32(name='Height'),
      }(name='LogoBoundary'),
    }
  ](name='Logos'),
}

model DetectImageLogosResponse = {
  headers: map[string]string(name='headers'),
  body: DetectImageLogosResponseBody(name='body'),
}

async function detectImageLogosWithOptions(request: DetectImageLogosRequest, runtime: Util.RuntimeOptions): DetectImageLogosResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DetectImageLogos', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function detectImageLogos(request: DetectImageLogosRequest): DetectImageLogosResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectImageLogosWithOptions(request, runtime);
}

model DetectImageQRCodesRequest {
  project?: string(name='Project'),
  imageUri?: string(name='ImageUri'),
}

model DetectImageQRCodesResponseBody = {
  imageUri?: string(name='ImageUri'),
  requestId?: string(name='RequestId'),
  QRCodes?: [ 
    {
      content?: string(name='Content'),
      QRCodeBoundary?: {
        left?: int32(name='Left'),
        top?: int32(name='Top'),
        width?: int32(name='Width'),
        height?: int32(name='Height'),
      }(name='QRCodeBoundary'),
    }
  ](name='QRCodes'),
}

model DetectImageQRCodesResponse = {
  headers: map[string]string(name='headers'),
  body: DetectImageQRCodesResponseBody(name='body'),
}

async function detectImageQRCodesWithOptions(request: DetectImageQRCodesRequest, runtime: Util.RuntimeOptions): DetectImageQRCodesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DetectImageQRCodes', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function detectImageQRCodes(request: DetectImageQRCodesRequest): DetectImageQRCodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectImageQRCodesWithOptions(request, runtime);
}

model DetectImageTagsRequest {
  project?: string(name='Project'),
  imageUri?: string(name='ImageUri'),
}

model DetectImageTagsResponseBody = {
  imageUri?: string(name='ImageUri'),
  requestId?: string(name='RequestId'),
  tags?: [ 
    {
      parentTagEnName?: string(name='ParentTagEnName'),
      tagName?: string(name='TagName'),
      tagConfidence?: float(name='TagConfidence'),
      tagEnName?: string(name='TagEnName'),
      tagLevel?: int32(name='TagLevel'),
      parentTagName?: string(name='ParentTagName'),
    }
  ](name='Tags'),
}

model DetectImageTagsResponse = {
  headers: map[string]string(name='headers'),
  body: DetectImageTagsResponseBody(name='body'),
}

async function detectImageTagsWithOptions(request: DetectImageTagsRequest, runtime: Util.RuntimeOptions): DetectImageTagsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DetectImageTags', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function detectImageTags(request: DetectImageTagsRequest): DetectImageTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectImageTagsWithOptions(request, runtime);
}

model DetectQRCodesRequest {
  project?: string(name='Project'),
  srcUris?: string(name='SrcUris'),
}

model DetectQRCodesResponseBody = {
  requestId?: string(name='RequestId'),
  successDetails?: [ 
    {
      srcUri?: string(name='SrcUri'),
      QRCodes?: [ 
        {
          content?: string(name='Content'),
          QRCodesRectangle?: {
            left?: string(name='Left'),
            top?: string(name='Top'),
            width?: string(name='Width'),
            height?: string(name='Height'),
          }(name='QRCodesRectangle'),
        }
      ](name='QRCodes'),
    }
  ](name='SuccessDetails'),
  failDetails?: [ 
    {
      errorMessage?: string(name='ErrorMessage'),
      srcUri?: string(name='SrcUri'),
      errorCode?: string(name='ErrorCode'),
    }
  ](name='FailDetails'),
}

model DetectQRCodesResponse = {
  headers: map[string]string(name='headers'),
  body: DetectQRCodesResponseBody(name='body'),
}

async function detectQRCodesWithOptions(request: DetectQRCodesRequest, runtime: Util.RuntimeOptions): DetectQRCodesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DetectQRCodes', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function detectQRCodes(request: DetectQRCodesRequest): DetectQRCodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectQRCodesWithOptions(request, runtime);
}

model EncodeBlindWatermarkRequest {
  project?: string(name='Project'),
  imageUri?: string(name='ImageUri'),
  watermarkUri?: string(name='WatermarkUri'),
  targetUri?: string(name='TargetUri'),
  imageQuality?: string(name='ImageQuality'),
  content?: string(name='Content'),
  targetImageType?: string(name='TargetImageType'),
  model?: string(name='Model'),
}

model EncodeBlindWatermarkResponseBody = {
  requestId?: string(name='RequestId'),
  targetUri?: string(name='TargetUri'),
  content?: string(name='Content'),
}

model EncodeBlindWatermarkResponse = {
  headers: map[string]string(name='headers'),
  body: EncodeBlindWatermarkResponseBody(name='body'),
}

async function encodeBlindWatermarkWithOptions(request: EncodeBlindWatermarkRequest, runtime: Util.RuntimeOptions): EncodeBlindWatermarkResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('EncodeBlindWatermark', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function encodeBlindWatermark(request: EncodeBlindWatermarkRequest): EncodeBlindWatermarkResponse {
  var runtime = new Util.RuntimeOptions{};
  return encodeBlindWatermarkWithOptions(request, runtime);
}

model FindImagesRequest {
  project?: string(name='Project'),
  setId?: string(name='SetId'),
  imageSizeRange?: string(name='ImageSizeRange'),
  imageTimeRange?: string(name='ImageTimeRange'),
  createTimeRange?: string(name='CreateTimeRange'),
  modifyTimeRange?: string(name='ModifyTimeRange'),
  sourceType?: string(name='SourceType'),
  sourceUriPrefix?: string(name='SourceUriPrefix'),
  remarksAPrefix?: string(name='RemarksAPrefix'),
  remarksBPrefix?: string(name='RemarksBPrefix'),
  tagNames?: string(name='TagNames'),
  OCRContentsMatch?: string(name='OCRContentsMatch'),
  ageRange?: string(name='AgeRange'),
  gender?: string(name='Gender'),
  emotion?: string(name='Emotion'),
  orderBy?: string(name='OrderBy'),
  order?: string(name='Order'),
  marker?: string(name='Marker'),
  locationBoundary?: string(name='LocationBoundary'),
  remarksCPrefix?: string(name='RemarksCPrefix'),
  remarksDPrefix?: string(name='RemarksDPrefix'),
  externalId?: string(name='ExternalId'),
  groupId?: string(name='GroupId'),
  limit?: int32(name='Limit'),
  facesModifyTimeRange?: string(name='FacesModifyTimeRange'),
  tagsModifyTimeRange?: string(name='TagsModifyTimeRange'),
  addressLineContentsMatch?: string(name='AddressLineContentsMatch'),
  remarksArrayAIn?: string(name='RemarksArrayAIn'),
  remarksArrayBIn?: string(name='RemarksArrayBIn'),
}

model FindImagesResponseBody = {
  requestId?: string(name='RequestId'),
  nextMarker?: string(name='NextMarker'),
  setId?: string(name='SetId'),
  images?: [ 
    {
      croppingSuggestionStatus?: string(name='CroppingSuggestionStatus'),
      imageQualityModifyTime?: string(name='ImageQualityModifyTime'),
      tagsFailReason?: string(name='TagsFailReason'),
      remarksC?: string(name='RemarksC'),
      createTime?: string(name='CreateTime'),
      sourceType?: string(name='SourceType'),
      facesFailReason?: string(name='FacesFailReason'),
      facesModifyTime?: string(name='FacesModifyTime'),
      imageTime?: string(name='ImageTime'),
      OCRModifyTime?: string(name='OCRModifyTime'),
      addressModifyTime?: string(name='AddressModifyTime'),
      imageQualityFailReason?: string(name='ImageQualityFailReason'),
      facesStatus?: string(name='FacesStatus'),
      remarksArrayA?: string(name='RemarksArrayA'),
      imageHeight?: int32(name='ImageHeight'),
      externalId?: string(name='ExternalId'),
      sourceUri?: string(name='SourceUri'),
      fileSize?: int32(name='FileSize'),
      modifyTime?: string(name='ModifyTime'),
      sourcePosition?: string(name='SourcePosition'),
      imageQualityStatus?: string(name='ImageQualityStatus'),
      OCRFailReason?: string(name='OCRFailReason'),
      addressFailReason?: string(name='AddressFailReason'),
      croppingSuggestionModifyTime?: string(name='CroppingSuggestionModifyTime'),
      imageFormat?: string(name='ImageFormat'),
      imageWidth?: int32(name='ImageWidth'),
      remarksArrayB?: string(name='RemarksArrayB'),
      orientation?: string(name='Orientation'),
      remarksD?: string(name='RemarksD'),
      tagsStatus?: string(name='TagsStatus'),
      croppingSuggestionFailReason?: string(name='CroppingSuggestionFailReason'),
      remarksA?: string(name='RemarksA'),
      imageUri?: string(name='ImageUri'),
      tagsModifyTime?: string(name='TagsModifyTime'),
      OCRStatus?: string(name='OCRStatus'),
      addressStatus?: string(name='AddressStatus'),
      exif?: string(name='Exif'),
      location?: string(name='Location'),
      remarksB?: string(name='RemarksB'),
      croppingSuggestion?: [ 
        {
          score?: float(name='Score'),
          aspectRatio?: string(name='AspectRatio'),
          croppingBoundary?: {
            left?: int32(name='Left'),
            top?: int32(name='Top'),
            width?: int32(name='Width'),
            height?: int32(name='Height'),
          }(name='CroppingBoundary'),
        }
      ](name='CroppingSuggestion'),
      faces?: [ 
        {
          emotionConfidence?: float(name='EmotionConfidence'),
          attractive?: float(name='Attractive'),
          groupId?: string(name='GroupId'),
          gender?: string(name='Gender'),
          faceId?: string(name='FaceId'),
          genderConfidence?: float(name='GenderConfidence'),
          faceQuality?: float(name='FaceQuality'),
          emotion?: string(name='Emotion'),
          age?: int32(name='Age'),
          faceConfidence?: float(name='FaceConfidence'),
          emotionDetails?: {
            HAPPY?: float(name='HAPPY'),
            SURPRISED?: float(name='SURPRISED'),
            CALM?: float(name='CALM'),
            DISGUSTED?: float(name='DISGUSTED'),
            ANGRY?: float(name='ANGRY'),
            SAD?: float(name='SAD'),
            SCARED?: float(name='SCARED'),
          }(name='EmotionDetails'),
          faceAttributes?: {
            glassesConfidence?: float(name='GlassesConfidence'),
            glasses?: string(name='Glasses'),
            mask?: string(name='Mask'),
            beardConfidence?: float(name='BeardConfidence'),
            maskConfidence?: float(name='MaskConfidence'),
            beard?: string(name='Beard'),
            faceBoundary?: {
              left?: int32(name='Left'),
              top?: int32(name='Top'),
              width?: int32(name='Width'),
              height?: int32(name='Height'),
            }(name='FaceBoundary'),
            headPose?: {
              pitch?: float(name='Pitch'),
              roll?: float(name='Roll'),
              yaw?: float(name='Yaw'),
            }(name='HeadPose'),
          }(name='FaceAttributes'),
        }
      ](name='Faces'),
      tags?: [ 
        {
          tagLevel?: int32(name='TagLevel'),
          parentTagName?: string(name='ParentTagName'),
          tagConfidence?: float(name='TagConfidence'),
          tagName?: string(name='TagName'),
        }
      ](name='Tags'),
      OCR?: [ 
        {
          OCRConfidence?: float(name='OCRConfidence'),
          OCRContents?: string(name='OCRContents'),
          OCRBoundary?: {
            left?: int32(name='Left'),
            top?: int32(name='Top'),
            width?: int32(name='Width'),
            height?: int32(name='Height'),
          }(name='OCRBoundary'),
        }
      ](name='OCR'),
      imageQuality?: {
        overallScore?: float(name='OverallScore'),
        color?: float(name='Color'),
        colorScore?: float(name='ColorScore'),
        contrastScore?: float(name='ContrastScore'),
        contrast?: float(name='Contrast'),
        exposureScore?: float(name='ExposureScore'),
        clarityScore?: float(name='ClarityScore'),
        clarity?: float(name='Clarity'),
        exposure?: float(name='Exposure'),
        compositionScore?: float(name='CompositionScore'),
      }(name='ImageQuality'),
      address?: {
        township?: string(name='Township'),
        district?: string(name='District'),
        addressLine?: string(name='AddressLine'),
        country?: string(name='Country'),
        city?: string(name='City'),
        province?: string(name='Province'),
      }(name='Address'),
    }
  ](name='Images'),
}

model FindImagesResponse = {
  headers: map[string]string(name='headers'),
  body: FindImagesResponseBody(name='body'),
}

async function findImagesWithOptions(request: FindImagesRequest, runtime: Util.RuntimeOptions): FindImagesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('FindImages', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function findImages(request: FindImagesRequest): FindImagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return findImagesWithOptions(request, runtime);
}

model FindSimilarFacesRequest {
  project?: string(name='Project'),
  setId?: string(name='SetId'),
  imageUri?: string(name='ImageUri'),
  faceId?: string(name='FaceId'),
  limit?: int32(name='Limit'),
  minSimilarity?: float(name='MinSimilarity'),
  responseFormat?: string(name='ResponseFormat'),
}

model FindSimilarFacesResponseBody = {
  requestId?: string(name='RequestId'),
  faces?: [ 
    {
      externalId?: string(name='ExternalId'),
      similarity?: float(name='Similarity'),
      faceId?: string(name='FaceId'),
      imageUri?: string(name='ImageUri'),
      similarFaces?: [ 
        {
          externalId?: string(name='ExternalId'),
          similarity?: float(name='Similarity'),
          faceId?: string(name='FaceId'),
          imageUri?: string(name='ImageUri'),
          faceAttributes?: {
            faceBoundary?: {
              left?: int32(name='Left'),
              top?: int32(name='Top'),
              width?: int32(name='Width'),
              height?: int32(name='Height'),
            }(name='FaceBoundary'),
          }(name='FaceAttributes'),
        }
      ](name='SimilarFaces'),
      faceAttributes?: {
        faceBoundary?: {
          left?: int32(name='Left'),
          top?: int32(name='Top'),
          width?: int32(name='Width'),
          height?: int32(name='Height'),
        }(name='FaceBoundary'),
      }(name='FaceAttributes'),
    }
  ](name='Faces'),
}

model FindSimilarFacesResponse = {
  headers: map[string]string(name='headers'),
  body: FindSimilarFacesResponseBody(name='body'),
}

async function findSimilarFacesWithOptions(request: FindSimilarFacesRequest, runtime: Util.RuntimeOptions): FindSimilarFacesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('FindSimilarFaces', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function findSimilarFaces(request: FindSimilarFacesRequest): FindSimilarFacesResponse {
  var runtime = new Util.RuntimeOptions{};
  return findSimilarFacesWithOptions(request, runtime);
}

model GetContentKeyRequest {
  project?: string(name='Project'),
  versionId?: string(name='VersionId'),
  DRMServerId?: string(name='DRMServerId'),
  keyIds?: string(name='KeyIds'),
}

model GetContentKeyResponseBody = {
  versionId?: string(name='VersionId'),
  requestId?: string(name='RequestId'),
  keyInfos?: string(name='KeyInfos'),
}

model GetContentKeyResponse = {
  headers: map[string]string(name='headers'),
  body: GetContentKeyResponseBody(name='body'),
}

async function getContentKeyWithOptions(request: GetContentKeyRequest, runtime: Util.RuntimeOptions): GetContentKeyResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetContentKey', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getContentKey(request: GetContentKeyRequest): GetContentKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return getContentKeyWithOptions(request, runtime);
}

model GetDRMLicenseRequest {
  project?: string(name='Project'),
  DRMType?: string(name='DRMType'),
  DRMLicense?: string(name='DRMLicense'),
}

model GetDRMLicenseResponseBody = {
  requestId?: string(name='RequestId'),
  deviceInfo?: string(name='DeviceInfo'),
  DRMData?: string(name='DRMData'),
}

model GetDRMLicenseResponse = {
  headers: map[string]string(name='headers'),
  body: GetDRMLicenseResponseBody(name='body'),
}

async function getDRMLicenseWithOptions(request: GetDRMLicenseRequest, runtime: Util.RuntimeOptions): GetDRMLicenseResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetDRMLicense', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getDRMLicense(request: GetDRMLicenseRequest): GetDRMLicenseResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDRMLicenseWithOptions(request, runtime);
}

model GetImageRequest {
  project?: string(name='Project'),
  setId?: string(name='SetId'),
  imageUri?: string(name='ImageUri'),
}

model GetImageResponseBody = {
  imageQuality?: {
    overallScore?: float(name='OverallScore'),
    color?: float(name='Color'),
    colorScore?: float(name='ColorScore'),
    contrastScore?: float(name='ContrastScore'),
    contrast?: float(name='Contrast'),
    exposureScore?: float(name='ExposureScore'),
    clarityScore?: float(name='ClarityScore'),
    clarity?: float(name='Clarity'),
    exposure?: float(name='Exposure'),
    compositionScore?: float(name='CompositionScore'),
  }(name='ImageQuality'),
  modifyTime?: string(name='ModifyTime'),
  address?: {
    township?: string(name='Township'),
    district?: string(name='District'),
    addressLine?: string(name='AddressLine'),
    country?: string(name='Country'),
    city?: string(name='City'),
    province?: string(name='Province'),
  }(name='Address'),
  sourceType?: string(name='SourceType'),
  sourceUri?: string(name='SourceUri'),
  facesFailReason?: string(name='FacesFailReason'),
  croppingSuggestionStatus?: string(name='CroppingSuggestionStatus'),
  croppingSuggestionFailReason?: string(name='CroppingSuggestionFailReason'),
  addressFailReason?: string(name='AddressFailReason'),
  remarksA?: string(name='RemarksA'),
  addressModifyTime?: string(name='AddressModifyTime'),
  remarksB?: string(name='RemarksB'),
  imageFormat?: string(name='ImageFormat'),
  tagsFailReason?: string(name='TagsFailReason'),
  remarksArrayB?: string(name='RemarksArrayB'),
  facesModifyTime?: string(name='FacesModifyTime'),
  exif?: string(name='Exif'),
  remarksC?: string(name='RemarksC'),
  remarksD?: string(name='RemarksD'),
  imageWidth?: int32(name='ImageWidth'),
  remarksArrayA?: string(name='RemarksArrayA'),
  sourcePosition?: string(name='SourcePosition'),
  tags?: [ 
    {
      tagName?: string(name='TagName'),
      tagConfidence?: float(name='TagConfidence'),
      tagLevel?: int32(name='TagLevel'),
      parentTagName?: string(name='ParentTagName'),
    }
  ](name='Tags'),
  faces?: [ 
    {
      gender?: string(name='Gender'),
      genderConfidence?: float(name='GenderConfidence'),
      faceId?: string(name='FaceId'),
      faceAttributes?: {
        glassesConfidence?: float(name='GlassesConfidence'),
        glasses?: string(name='Glasses'),
        mask?: string(name='Mask'),
        beardConfidence?: float(name='BeardConfidence'),
        maskConfidence?: float(name='MaskConfidence'),
        faceBoundary?: {
          top?: int32(name='Top'),
          width?: int32(name='Width'),
          height?: int32(name='Height'),
          left?: int32(name='Left'),
        }(name='FaceBoundary'),
        headPose?: {
          pitch?: float(name='Pitch'),
          roll?: float(name='Roll'),
          yaw?: float(name='Yaw'),
        }(name='HeadPose'),
        beard?: string(name='Beard'),
      }(name='FaceAttributes'),
      faceQuality?: float(name='FaceQuality'),
      emotion?: string(name='Emotion'),
      age?: string(name='Age'),
      faceConfidence?: float(name='FaceConfidence'),
      emotionConfidence?: float(name='EmotionConfidence'),
      attractive?: float(name='Attractive'),
      groupId?: string(name='GroupId'),
      emotionDetails?: {
        HAPPY?: float(name='HAPPY'),
        CALM?: float(name='CALM'),
        SURPRISED?: float(name='SURPRISED'),
        DISGUSTED?: float(name='DISGUSTED'),
        ANGRY?: float(name='ANGRY'),
        SAD?: float(name='SAD'),
        SCARED?: float(name='SCARED'),
      }(name='EmotionDetails'),
    }
  ](name='Faces'),
  addressStatus?: string(name='AddressStatus'),
  facesStatus?: string(name='FacesStatus'),
  imageQualityModifyTime?: string(name='ImageQualityModifyTime'),
  croppingSuggestion?: [ 
    {
      score?: float(name='Score'),
      croppingBoundary?: {
        top?: int32(name='Top'),
        width?: int32(name='Width'),
        height?: int32(name='Height'),
        left?: int32(name='Left'),
      }(name='CroppingBoundary'),
      aspectRatio?: string(name='AspectRatio'),
    }
  ](name='CroppingSuggestion'),
  requestId?: string(name='RequestId'),
  createTime?: string(name='CreateTime'),
  externalId?: string(name='ExternalId'),
  tagsModifyTime?: string(name='TagsModifyTime'),
  imageQualityFailReason?: string(name='ImageQualityFailReason'),
  orientation?: string(name='Orientation'),
  imageUri?: string(name='ImageUri'),
  OCRStatus?: string(name='OCRStatus'),
  OCRModifyTime?: string(name='OCRModifyTime'),
  imageTime?: string(name='ImageTime'),
  croppingSuggestionModifyTime?: string(name='CroppingSuggestionModifyTime'),
  imageHeight?: int32(name='ImageHeight'),
  imageQualityStatus?: string(name='ImageQualityStatus'),
  tagsStatus?: string(name='TagsStatus'),
  OCRFailReason?: string(name='OCRFailReason'),
  setId?: string(name='SetId'),
  fileSize?: int32(name='FileSize'),
  location?: string(name='Location'),
  OCR?: [ 
    {
      OCRConfidence?: float(name='OCRConfidence'),
      OCRContents?: string(name='OCRContents'),
      OCRBoundary?: {
        top?: int32(name='Top'),
        width?: int32(name='Width'),
        height?: int32(name='Height'),
        left?: int32(name='Left'),
      }(name='OCRBoundary'),
    }
  ](name='OCR'),
}

model GetImageResponse = {
  headers: map[string]string(name='headers'),
  body: GetImageResponseBody(name='body'),
}

async function getImageWithOptions(request: GetImageRequest, runtime: Util.RuntimeOptions): GetImageResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetImage', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getImage(request: GetImageRequest): GetImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return getImageWithOptions(request, runtime);
}

model GetImageCroppingSuggestionsRequest {
  project?: string(name='Project'),
  imageUri?: string(name='ImageUri'),
  aspectRatios?: string(name='AspectRatios'),
}

model GetImageCroppingSuggestionsResponseBody = {
  imageUri?: string(name='ImageUri'),
  requestId?: string(name='RequestId'),
  croppingSuggestions?: [ 
    {
      score?: float(name='Score'),
      aspectRatio?: string(name='AspectRatio'),
      croppingBoundary?: {
        left?: int32(name='Left'),
        top?: int32(name='Top'),
        width?: int32(name='Width'),
        height?: int32(name='Height'),
      }(name='CroppingBoundary'),
    }
  ](name='CroppingSuggestions'),
}

model GetImageCroppingSuggestionsResponse = {
  headers: map[string]string(name='headers'),
  body: GetImageCroppingSuggestionsResponseBody(name='body'),
}

async function getImageCroppingSuggestionsWithOptions(request: GetImageCroppingSuggestionsRequest, runtime: Util.RuntimeOptions): GetImageCroppingSuggestionsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetImageCroppingSuggestions', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getImageCroppingSuggestions(request: GetImageCroppingSuggestionsRequest): GetImageCroppingSuggestionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getImageCroppingSuggestionsWithOptions(request, runtime);
}

model GetImageQualityRequest {
  project?: string(name='Project'),
  imageUri?: string(name='ImageUri'),
}

model GetImageQualityResponseBody = {
  imageUri?: string(name='ImageUri'),
  requestId?: string(name='RequestId'),
  imageQuality?: {
    overallScore?: float(name='OverallScore'),
    color?: float(name='Color'),
    colorScore?: float(name='ColorScore'),
    contrastScore?: float(name='ContrastScore'),
    contrast?: float(name='Contrast'),
    exposureScore?: float(name='ExposureScore'),
    clarityScore?: float(name='ClarityScore'),
    clarity?: float(name='Clarity'),
    exposure?: float(name='Exposure'),
    compositionScore?: float(name='CompositionScore'),
  }(name='ImageQuality'),
}

model GetImageQualityResponse = {
  headers: map[string]string(name='headers'),
  body: GetImageQualityResponseBody(name='body'),
}

async function getImageQualityWithOptions(request: GetImageQualityRequest, runtime: Util.RuntimeOptions): GetImageQualityResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetImageQuality', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getImageQuality(request: GetImageQualityRequest): GetImageQualityResponse {
  var runtime = new Util.RuntimeOptions{};
  return getImageQualityWithOptions(request, runtime);
}

model GetMediaMetaRequest {
  project?: string(name='Project'),
  mediaUri?: string(name='MediaUri'),
}

model GetMediaMetaResponseBody = {
  mediaUri?: string(name='MediaUri'),
  requestId?: string(name='RequestId'),
  mediaMeta?: {
    mediaFormat?: {
      creationTime?: string(name='CreationTime'),
      numberPrograms?: int32(name='NumberPrograms'),
      numberStreams?: int32(name='NumberStreams'),
      tag?: {
        creationTime?: string(name='CreationTime'),
        album?: string(name='Album'),
        albumArtist?: string(name='AlbumArtist'),
        performer?: string(name='Performer'),
        composer?: string(name='Composer'),
        artist?: string(name='Artist'),
        title?: string(name='Title'),
        language?: string(name='Language'),
      }(name='Tag'),
      bitrate?: string(name='Bitrate'),
      startTime?: string(name='StartTime'),
      size?: string(name='Size'),
      address?: {
        township?: string(name='Township'),
        district?: string(name='District'),
        addressLine?: string(name='AddressLine'),
        country?: string(name='Country'),
        city?: string(name='City'),
        province?: string(name='Province'),
      }(name='Address'),
      formatLongName?: string(name='FormatLongName'),
      duration?: string(name='Duration'),
      formatName?: string(name='FormatName'),
      location?: string(name='Location'),
    }(name='MediaFormat'),
    mediaStreams?: {
      videoStreams?: [ 
        {
          index?: int32(name='Index'),
          codecLongName?: string(name='CodecLongName'),
          height?: int32(name='Height'),
          sampleAspectRatio?: string(name='SampleAspectRatio'),
          averageFrameRate?: string(name='AverageFrameRate'),
          bitrate?: string(name='Bitrate'),
          rotate?: string(name='Rotate'),
          codecTagString?: string(name='CodecTagString'),
          language?: string(name='Language'),
          hasBFrames?: int32(name='HasBFrames'),
          frameRrate?: string(name='FrameRrate'),
          profile?: string(name='Profile'),
          startTime?: string(name='StartTime'),
          frames?: string(name='Frames'),
          codecName?: string(name='CodecName'),
          width?: int32(name='Width'),
          duration?: string(name='Duration'),
          displayAspectRatio?: string(name='DisplayAspectRatio'),
          codecTag?: string(name='CodecTag'),
          codecTimeBase?: string(name='CodecTimeBase'),
          timeBase?: string(name='TimeBase'),
          level?: int32(name='Level'),
          pixelFormat?: string(name='PixelFormat'),
        }
      ](name='VideoStreams'),
      audioStreams?: [ 
        {
          index?: int32(name='Index'),
          sampleRate?: string(name='SampleRate'),
          channelLayout?: string(name='ChannelLayout'),
          codecLongName?: string(name='CodecLongName'),
          channels?: int32(name='Channels'),
          bitrate?: string(name='Bitrate'),
          codecTagString?: string(name='CodecTagString'),
          language?: string(name='Language'),
          startTime?: string(name='StartTime'),
          sampleFormat?: string(name='SampleFormat'),
          frames?: string(name='Frames'),
          codecName?: string(name='CodecName'),
          duration?: string(name='Duration'),
          codecTag?: string(name='CodecTag'),
          codecTimeBase?: string(name='CodecTimeBase'),
          timeBase?: string(name='TimeBase'),
        }
      ](name='AudioStreams'),
      subtitleStreams?: [ 
        {
          index?: int32(name='Index'),
          language?: string(name='Language'),
        }
      ](name='SubtitleStreams'),
    }(name='MediaStreams'),
  }(name='MediaMeta'),
}

model GetMediaMetaResponse = {
  headers: map[string]string(name='headers'),
  body: GetMediaMetaResponseBody(name='body'),
}

async function getMediaMetaWithOptions(request: GetMediaMetaRequest, runtime: Util.RuntimeOptions): GetMediaMetaResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetMediaMeta', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getMediaMeta(request: GetMediaMetaRequest): GetMediaMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMediaMetaWithOptions(request, runtime);
}

model GetOfficeConversionTaskRequest {
  project?: string(name='Project'),
  taskId?: string(name='TaskId'),
}

model GetOfficeConversionTaskResponseBody = {
  status?: string(name='Status'),
  percent?: int32(name='Percent'),
  finishTime?: string(name='FinishTime'),
  createTime?: string(name='CreateTime'),
  pageCount?: int32(name='PageCount'),
  notifyTopicName?: string(name='NotifyTopicName'),
  requestId?: string(name='RequestId'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
  srcUri?: string(name='SrcUri'),
  tgtType?: string(name='TgtType'),
  tgtUri?: string(name='TgtUri'),
  imageSpec?: string(name='ImageSpec'),
  externalID?: string(name='ExternalID'),
  taskId?: string(name='TaskId'),
  failDetail?: {
    code?: string(name='Code'),
  }(name='FailDetail'),
}

model GetOfficeConversionTaskResponse = {
  headers: map[string]string(name='headers'),
  body: GetOfficeConversionTaskResponseBody(name='body'),
}

async function getOfficeConversionTaskWithOptions(request: GetOfficeConversionTaskRequest, runtime: Util.RuntimeOptions): GetOfficeConversionTaskResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetOfficeConversionTask', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getOfficeConversionTask(request: GetOfficeConversionTaskRequest): GetOfficeConversionTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return getOfficeConversionTaskWithOptions(request, runtime);
}

model GetOfficeEditURLRequest {
  project?: string(name='Project'),
  srcUri?: string(name='SrcUri'),
  srcType?: string(name='SrcType'),
  fileID?: string(name='FileID'),
  tgtUri?: string(name='TgtUri'),
  userID?: string(name='UserID'),
  userName?: string(name='UserName'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
  notifyTopicName?: string(name='NotifyTopicName'),
  fileName?: string(name='FileName'),
}

model GetOfficeEditURLResponseBody = {
  requestId?: string(name='RequestId'),
  accessTokenExpiredTime?: string(name='AccessTokenExpiredTime'),
  editURL?: string(name='EditURL'),
  accessToken?: string(name='AccessToken'),
  refreshToken?: string(name='RefreshToken'),
  refreshTokenExpiredTime?: string(name='RefreshTokenExpiredTime'),
}

model GetOfficeEditURLResponse = {
  headers: map[string]string(name='headers'),
  body: GetOfficeEditURLResponseBody(name='body'),
}

async function getOfficeEditURLWithOptions(request: GetOfficeEditURLRequest, runtime: Util.RuntimeOptions): GetOfficeEditURLResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetOfficeEditURL', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getOfficeEditURL(request: GetOfficeEditURLRequest): GetOfficeEditURLResponse {
  var runtime = new Util.RuntimeOptions{};
  return getOfficeEditURLWithOptions(request, runtime);
}

model GetOfficePreviewURLRequest {
  project?: string(name='Project'),
  srcUri?: string(name='SrcUri'),
  srcType?: string(name='SrcType'),
  watermarkType?: int32(name='WatermarkType'),
  watermarkValue?: string(name='WatermarkValue'),
  watermarkFillStyle?: string(name='WatermarkFillStyle'),
  watermarkFont?: string(name='WatermarkFont'),
  watermarkRotate?: float(name='WatermarkRotate'),
  watermarkHorizontal?: int32(name='WatermarkHorizontal'),
  watermarkVertical?: int32(name='WatermarkVertical'),
}

model GetOfficePreviewURLResponseBody = {
  requestId?: string(name='RequestId'),
  previewURL?: string(name='PreviewURL'),
  accessTokenExpiredTime?: string(name='AccessTokenExpiredTime'),
  accessToken?: string(name='AccessToken'),
  refreshToken?: string(name='RefreshToken'),
  refreshTokenExpiredTime?: string(name='RefreshTokenExpiredTime'),
}

model GetOfficePreviewURLResponse = {
  headers: map[string]string(name='headers'),
  body: GetOfficePreviewURLResponseBody(name='body'),
}

async function getOfficePreviewURLWithOptions(request: GetOfficePreviewURLRequest, runtime: Util.RuntimeOptions): GetOfficePreviewURLResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetOfficePreviewURL', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getOfficePreviewURL(request: GetOfficePreviewURLRequest): GetOfficePreviewURLResponse {
  var runtime = new Util.RuntimeOptions{};
  return getOfficePreviewURLWithOptions(request, runtime);
}

model GetProjectRequest {
  project?: string(name='Project'),
}

model GetProjectResponseBody = {
  type?: string(name='Type'),
  requestId?: string(name='RequestId'),
  CU?: int32(name='CU'),
  createTime?: string(name='CreateTime'),
  endpoint?: string(name='Endpoint'),
  serviceRole?: string(name='ServiceRole'),
  project?: string(name='Project'),
  regionId?: string(name='RegionId'),
  billingType?: string(name='BillingType'),
  modifyTime?: string(name='ModifyTime'),
}

model GetProjectResponse = {
  headers: map[string]string(name='headers'),
  body: GetProjectResponseBody(name='body'),
}

async function getProjectWithOptions(request: GetProjectRequest, runtime: Util.RuntimeOptions): GetProjectResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetProject', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getProject(request: GetProjectRequest): GetProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return getProjectWithOptions(request, runtime);
}

model GetSetRequest {
  project?: string(name='Project'),
  setId?: string(name='SetId'),
}

model GetSetResponseBody = {
  videoCount?: int32(name='VideoCount'),
  requestId?: string(name='RequestId'),
  createTime?: string(name='CreateTime'),
  videoLength?: int32(name='VideoLength'),
  setId?: string(name='SetId'),
  imageCount?: int32(name='ImageCount'),
  faceCount?: int32(name='FaceCount'),
  setName?: string(name='SetName'),
  modifyTime?: string(name='ModifyTime'),
}

model GetSetResponse = {
  headers: map[string]string(name='headers'),
  body: GetSetResponseBody(name='body'),
}

async function getSetWithOptions(request: GetSetRequest, runtime: Util.RuntimeOptions): GetSetResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetSet', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getSet(request: GetSetRequest): GetSetResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSetWithOptions(request, runtime);
}

model GetVideoRequest {
  project?: string(name='Project'),
  setId?: string(name='SetId'),
  videoUri?: string(name='VideoUri'),
}

model GetVideoResponseBody = {
  modifyTime?: string(name='ModifyTime'),
  processStatus?: string(name='ProcessStatus'),
  videoWidth?: int32(name='VideoWidth'),
  sourceType?: string(name='SourceType'),
  sourceUri?: string(name='SourceUri'),
  videoInfo?: string(name='VideoInfo'),
  videoFrameTagsModifyTime?: string(name='VideoFrameTagsModifyTime'),
  remarksA?: string(name='RemarksA'),
  videoFacesFailReason?: string(name='VideoFacesFailReason'),
  remarksB?: string(name='RemarksB'),
  videoFacesStatus?: string(name='VideoFacesStatus'),
  remarksC?: string(name='RemarksC'),
  videoOCRModifyTime?: string(name='VideoOCRModifyTime'),
  remarksD?: string(name='RemarksD'),
  videoHeight?: int32(name='VideoHeight'),
  sourcePosition?: string(name='SourcePosition'),
  videoOCRFailReason?: string(name='VideoOCRFailReason'),
  videoFrameTagsStatus?: string(name='VideoFrameTagsStatus'),
  videoTagsFailReason?: string(name='VideoTagsFailReason'),
  videoTagsModifyTime?: string(name='VideoTagsModifyTime'),
  videoOCRStatus?: string(name='VideoOCRStatus'),
  videoFrames?: int32(name='VideoFrames'),
  requestId?: string(name='RequestId'),
  processModifyTime?: string(name='ProcessModifyTime'),
  videoSTTModifyTime?: string(name='VideoSTTModifyTime'),
  processFailReason?: string(name='ProcessFailReason'),
  createTime?: string(name='CreateTime'),
  externalId?: string(name='ExternalId'),
  videoSTTFailReason?: string(name='VideoSTTFailReason'),
  videoUri?: string(name='VideoUri'),
  videoFrameTagsFailReason?: string(name='VideoFrameTagsFailReason'),
  videoFormat?: string(name='VideoFormat'),
  videoSTTStatus?: string(name='VideoSTTStatus'),
  videoFacesModifyTime?: string(name='VideoFacesModifyTime'),
  videoTags?: [ 
    {
      tagName?: string(name='TagName'),
      tagConfidence?: float(name='TagConfidence'),
      tagLevel?: int32(name='TagLevel'),
      parentTagName?: string(name='ParentTagName'),
    }
  ](name='VideoTags'),
  videoDuration?: float(name='VideoDuration'),
  setId?: string(name='SetId'),
  videoTagsStatus?: string(name='VideoTagsStatus'),
  fileSize?: int32(name='FileSize'),
}

model GetVideoResponse = {
  headers: map[string]string(name='headers'),
  body: GetVideoResponseBody(name='body'),
}

async function getVideoWithOptions(request: GetVideoRequest, runtime: Util.RuntimeOptions): GetVideoResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetVideo', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getVideo(request: GetVideoRequest): GetVideoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVideoWithOptions(request, runtime);
}

model GetVideoTaskRequest {
  project?: string(name='Project'),
  taskType?: string(name='TaskType'),
  taskId?: string(name='TaskId'),
}

model GetVideoTaskResponseBody = {
  status?: string(name='Status'),
  progress?: int32(name='Progress'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
  parameters?: string(name='Parameters'),
  taskId?: string(name='TaskId'),
  endTime?: string(name='EndTime'),
  requestId?: string(name='RequestId'),
  taskType?: string(name='TaskType'),
  startTime?: string(name='StartTime'),
  notifyTopicName?: string(name='NotifyTopicName'),
  errorMessage?: string(name='ErrorMessage'),
  result?: string(name='Result'),
}

model GetVideoTaskResponse = {
  headers: map[string]string(name='headers'),
  body: GetVideoTaskResponseBody(name='body'),
}

async function getVideoTaskWithOptions(request: GetVideoTaskRequest, runtime: Util.RuntimeOptions): GetVideoTaskResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetVideoTask', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getVideoTask(request: GetVideoTaskRequest): GetVideoTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVideoTaskWithOptions(request, runtime);
}

model GetWebofficeURLRequest {
  project?: string(name='Project'),
  srcType?: string(name='SrcType'),
  fileID?: string(name='FileID'),
  user?: string(name='User'),
  permission?: string(name='Permission'),
  file?: string(name='File'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
  notifyTopicName?: string(name='NotifyTopicName'),
  watermark?: string(name='Watermark'),
  hidecmb?: boolean(name='Hidecmb'),
}

model GetWebofficeURLResponseBody = {
  refreshToken?: string(name='RefreshToken'),
  requestId?: string(name='RequestId'),
  accessToken?: string(name='AccessToken'),
  refreshTokenExpiredTime?: string(name='RefreshTokenExpiredTime'),
  webofficeURL?: string(name='WebofficeURL'),
  accessTokenExpiredTime?: string(name='AccessTokenExpiredTime'),
}

model GetWebofficeURLResponse = {
  headers: map[string]string(name='headers'),
  body: GetWebofficeURLResponseBody(name='body'),
}

async function getWebofficeURLWithOptions(request: GetWebofficeURLRequest, runtime: Util.RuntimeOptions): GetWebofficeURLResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetWebofficeURL', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getWebofficeURL(request: GetWebofficeURLRequest): GetWebofficeURLResponse {
  var runtime = new Util.RuntimeOptions{};
  return getWebofficeURLWithOptions(request, runtime);
}

model IndexImageRequest {
  project?: string(name='Project'),
  setId?: string(name='SetId'),
  imageUri?: string(name='ImageUri'),
  remarksA?: string(name='RemarksA'),
  remarksB?: string(name='RemarksB'),
  sourceType?: string(name='SourceType'),
  sourceUri?: string(name='SourceUri'),
  sourcePosition?: string(name='SourcePosition'),
  remarksC?: string(name='RemarksC'),
  remarksD?: string(name='RemarksD'),
  externalId?: string(name='ExternalId'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
  notifyTopicName?: string(name='NotifyTopicName'),
  remarksArrayA?: string(name='RemarksArrayA'),
  remarksArrayB?: string(name='RemarksArrayB'),
}

model IndexImageResponseBody = {
  remarksArrayB?: string(name='RemarksArrayB'),
  modifyTime?: string(name='ModifyTime'),
  remarksC?: string(name='RemarksC'),
  remarksD?: string(name='RemarksD'),
  requestId?: string(name='RequestId'),
  createTime?: string(name='CreateTime'),
  externalId?: string(name='ExternalId'),
  remarksArrayA?: string(name='RemarksArrayA'),
  remarksA?: string(name='RemarksA'),
  imageUri?: string(name='ImageUri'),
  setId?: string(name='SetId'),
  remarksB?: string(name='RemarksB'),
}

model IndexImageResponse = {
  headers: map[string]string(name='headers'),
  body: IndexImageResponseBody(name='body'),
}

async function indexImageWithOptions(request: IndexImageRequest, runtime: Util.RuntimeOptions): IndexImageResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('IndexImage', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function indexImage(request: IndexImageRequest): IndexImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return indexImageWithOptions(request, runtime);
}

model IndexVideoRequest {
  project?: string(name='Project'),
  setId?: string(name='SetId'),
  videoUri?: string(name='VideoUri'),
  remarksA?: string(name='RemarksA'),
  remarksB?: string(name='RemarksB'),
  tgtUri?: string(name='TgtUri'),
  remarksC?: string(name='RemarksC'),
  remarksD?: string(name='RemarksD'),
  externalId?: string(name='ExternalId'),
  notifyTopicName?: string(name='NotifyTopicName'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
}

model IndexVideoResponseBody = {
  modifyTime?: string(name='ModifyTime'),
  requestId?: string(name='RequestId'),
  createTime?: string(name='CreateTime'),
  externalId?: string(name='ExternalId'),
  videoUri?: string(name='VideoUri'),
  remarksA?: string(name='RemarksA'),
  remarksB?: string(name='RemarksB'),
  remarksC?: string(name='RemarksC'),
  remarksD?: string(name='RemarksD'),
  setId?: string(name='SetId'),
}

model IndexVideoResponse = {
  headers: map[string]string(name='headers'),
  body: IndexVideoResponseBody(name='body'),
}

async function indexVideoWithOptions(request: IndexVideoRequest, runtime: Util.RuntimeOptions): IndexVideoResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('IndexVideo', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function indexVideo(request: IndexVideoRequest): IndexVideoResponse {
  var runtime = new Util.RuntimeOptions{};
  return indexVideoWithOptions(request, runtime);
}

model ListFaceGroupsRequest {
  project?: string(name='Project'),
  setId?: string(name='SetId'),
  marker?: string(name='Marker'),
  limit?: int32(name='Limit'),
  order?: string(name='Order'),
  orderBy?: string(name='OrderBy'),
  remarksAQuery?: string(name='RemarksAQuery'),
  remarksBQuery?: string(name='RemarksBQuery'),
  remarksCQuery?: string(name='RemarksCQuery'),
  remarksDQuery?: string(name='RemarksDQuery'),
  remarksArrayAQuery?: string(name='RemarksArrayAQuery'),
  remarksArrayBQuery?: string(name='RemarksArrayBQuery'),
  externalId?: string(name='ExternalId'),
}

model ListFaceGroupsResponseBody = {
  requestId?: string(name='RequestId'),
  nextMarker?: string(name='NextMarker'),
  faceGroups?: [ 
    {
      gender?: string(name='Gender'),
      createTime?: string(name='CreateTime'),
      remarksC?: string(name='RemarksC'),
      groupCoverFace?: {
        faceId?: string(name='FaceId'),
        imageUri?: string(name='ImageUri'),
        faceBoundary?: {
          top?: int32(name='Top'),
          width?: int32(name='Width'),
          height?: int32(name='Height'),
          left?: int32(name='Left'),
        }(name='FaceBoundary'),
        externalId?: string(name='ExternalId'),
        imageHeight?: long(name='ImageHeight'),
        imageWidth?: long(name='ImageWidth'),
      }(name='GroupCoverFace'),
      faceCount?: int32(name='FaceCount'),
      remarksArrayB?: string(name='RemarksArrayB'),
      remarksD?: string(name='RemarksD'),
      maxAge?: float(name='MaxAge'),
      groupId?: string(name='GroupId'),
      groupName?: string(name='GroupName'),
      remarksA?: string(name='RemarksA'),
      averageAge?: float(name='AverageAge'),
      remarksArrayA?: string(name='RemarksArrayA'),
      minAge?: float(name='MinAge'),
      imageCount?: int32(name='ImageCount'),
      externalId?: string(name='ExternalId'),
      remarksB?: string(name='RemarksB'),
      modifyTime?: string(name='ModifyTime'),
    }
  ](name='FaceGroups'),
}

model ListFaceGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: ListFaceGroupsResponseBody(name='body'),
}

async function listFaceGroupsWithOptions(request: ListFaceGroupsRequest, runtime: Util.RuntimeOptions): ListFaceGroupsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListFaceGroups', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listFaceGroups(request: ListFaceGroupsRequest): ListFaceGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFaceGroupsWithOptions(request, runtime);
}

model ListImagesRequest {
  project?: string(name='Project'),
  setId?: string(name='SetId'),
  createTimeStart?: string(name='CreateTimeStart'),
  marker?: string(name='Marker'),
  limit?: int32(name='Limit'),
}

model ListImagesResponseBody = {
  requestId?: string(name='RequestId'),
  nextMarker?: string(name='NextMarker'),
  setId?: string(name='SetId'),
  images?: [ 
    {
      croppingSuggestionStatus?: string(name='CroppingSuggestionStatus'),
      imageQualityModifyTime?: string(name='ImageQualityModifyTime'),
      tagsFailReason?: string(name='TagsFailReason'),
      remarksC?: string(name='RemarksC'),
      createTime?: string(name='CreateTime'),
      sourceType?: string(name='SourceType'),
      facesFailReason?: string(name='FacesFailReason'),
      facesModifyTime?: string(name='FacesModifyTime'),
      imageTime?: string(name='ImageTime'),
      OCRModifyTime?: string(name='OCRModifyTime'),
      addressModifyTime?: string(name='AddressModifyTime'),
      imageQualityFailReason?: string(name='ImageQualityFailReason'),
      facesStatus?: string(name='FacesStatus'),
      remarksArrayA?: string(name='RemarksArrayA'),
      imageHeight?: int32(name='ImageHeight'),
      externalId?: string(name='ExternalId'),
      sourceUri?: string(name='SourceUri'),
      fileSize?: int32(name='FileSize'),
      modifyTime?: string(name='ModifyTime'),
      sourcePosition?: string(name='SourcePosition'),
      imageQualityStatus?: string(name='ImageQualityStatus'),
      OCRFailReason?: string(name='OCRFailReason'),
      addressFailReason?: string(name='AddressFailReason'),
      croppingSuggestionModifyTime?: string(name='CroppingSuggestionModifyTime'),
      imageFormat?: string(name='ImageFormat'),
      imageWidth?: int32(name='ImageWidth'),
      remarksArrayB?: string(name='RemarksArrayB'),
      orientation?: string(name='Orientation'),
      remarksD?: string(name='RemarksD'),
      tagsStatus?: string(name='TagsStatus'),
      croppingSuggestionFailReason?: string(name='CroppingSuggestionFailReason'),
      remarksA?: string(name='RemarksA'),
      imageUri?: string(name='ImageUri'),
      tagsModifyTime?: string(name='TagsModifyTime'),
      OCRStatus?: string(name='OCRStatus'),
      addressStatus?: string(name='AddressStatus'),
      exif?: string(name='Exif'),
      location?: string(name='Location'),
      remarksB?: string(name='RemarksB'),
      croppingSuggestion?: [ 
        {
          score?: float(name='Score'),
          aspectRatio?: string(name='AspectRatio'),
          croppingBoundary?: {
            left?: int32(name='Left'),
            top?: int32(name='Top'),
            width?: int32(name='Width'),
            height?: int32(name='Height'),
          }(name='CroppingBoundary'),
        }
      ](name='CroppingSuggestion'),
      faces?: [ 
        {
          emotionConfidence?: float(name='EmotionConfidence'),
          attractive?: float(name='Attractive'),
          groupId?: string(name='GroupId'),
          gender?: string(name='Gender'),
          faceId?: string(name='FaceId'),
          genderConfidence?: float(name='GenderConfidence'),
          faceQuality?: float(name='FaceQuality'),
          emotion?: string(name='Emotion'),
          age?: int32(name='Age'),
          faceConfidence?: float(name='FaceConfidence'),
          emotionDetails?: {
            HAPPY?: float(name='HAPPY'),
            SURPRISED?: float(name='SURPRISED'),
            CALM?: float(name='CALM'),
            DISGUSTED?: float(name='DISGUSTED'),
            ANGRY?: float(name='ANGRY'),
            SAD?: float(name='SAD'),
            SCARED?: float(name='SCARED'),
          }(name='EmotionDetails'),
          faceAttributes?: {
            glassesConfidence?: float(name='GlassesConfidence'),
            glasses?: string(name='Glasses'),
            mask?: string(name='Mask'),
            beardConfidence?: float(name='BeardConfidence'),
            maskConfidence?: float(name='MaskConfidence'),
            beard?: string(name='Beard'),
            faceBoundary?: {
              left?: int32(name='Left'),
              top?: int32(name='Top'),
              width?: int32(name='Width'),
              height?: int32(name='Height'),
            }(name='FaceBoundary'),
            headPose?: {
              pitch?: float(name='Pitch'),
              roll?: float(name='Roll'),
              yaw?: float(name='Yaw'),
            }(name='HeadPose'),
          }(name='FaceAttributes'),
        }
      ](name='Faces'),
      tags?: [ 
        {
          tagLevel?: int32(name='TagLevel'),
          parentTagName?: string(name='ParentTagName'),
          tagConfidence?: float(name='TagConfidence'),
          tagName?: string(name='TagName'),
        }
      ](name='Tags'),
      OCR?: [ 
        {
          OCRConfidence?: float(name='OCRConfidence'),
          OCRContents?: string(name='OCRContents'),
          OCRBoundary?: {
            left?: int32(name='Left'),
            top?: int32(name='Top'),
            width?: int32(name='Width'),
            height?: int32(name='Height'),
          }(name='OCRBoundary'),
        }
      ](name='OCR'),
      imageQuality?: {
        overallScore?: float(name='OverallScore'),
        color?: float(name='Color'),
        colorScore?: float(name='ColorScore'),
        contrastScore?: float(name='ContrastScore'),
        contrast?: float(name='Contrast'),
        exposureScore?: float(name='ExposureScore'),
        clarityScore?: float(name='ClarityScore'),
        clarity?: float(name='Clarity'),
        exposure?: float(name='Exposure'),
        compositionScore?: float(name='CompositionScore'),
      }(name='ImageQuality'),
      address?: {
        township?: string(name='Township'),
        district?: string(name='District'),
        addressLine?: string(name='AddressLine'),
        country?: string(name='Country'),
        city?: string(name='City'),
        province?: string(name='Province'),
      }(name='Address'),
    }
  ](name='Images'),
}

model ListImagesResponse = {
  headers: map[string]string(name='headers'),
  body: ListImagesResponseBody(name='body'),
}

async function listImagesWithOptions(request: ListImagesRequest, runtime: Util.RuntimeOptions): ListImagesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListImages', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listImages(request: ListImagesRequest): ListImagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listImagesWithOptions(request, runtime);
}

model ListOfficeConversionTaskRequest {
  project?: string(name='Project'),
  marker?: string(name='Marker'),
  maxKeys?: int32(name='MaxKeys'),
}

model ListOfficeConversionTaskResponseBody = {
  nextMarker?: string(name='NextMarker'),
  requestId?: string(name='RequestId'),
  tasks?: [ 
    {
      status?: string(name='Status'),
      percent?: int32(name='Percent'),
      finishTime?: string(name='FinishTime'),
      createTime?: string(name='CreateTime'),
      pageCount?: int32(name='PageCount'),
      notifyTopicName?: string(name='NotifyTopicName'),
      notifyEndpoint?: string(name='NotifyEndpoint'),
      srcUri?: string(name='SrcUri'),
      tgtType?: string(name='TgtType'),
      tgtUri?: string(name='TgtUri'),
      imageSpec?: string(name='ImageSpec'),
      externalID?: string(name='ExternalID'),
      taskId?: string(name='TaskId'),
    }
  ](name='Tasks'),
}

model ListOfficeConversionTaskResponse = {
  headers: map[string]string(name='headers'),
  body: ListOfficeConversionTaskResponseBody(name='body'),
}

async function listOfficeConversionTaskWithOptions(request: ListOfficeConversionTaskRequest, runtime: Util.RuntimeOptions): ListOfficeConversionTaskResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListOfficeConversionTask', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listOfficeConversionTask(request: ListOfficeConversionTaskRequest): ListOfficeConversionTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return listOfficeConversionTaskWithOptions(request, runtime);
}

model ListProjectAPIsRequest {
  project?: string(name='Project'),
}

model ListProjectAPIsResponseBody = {
  project?: string(name='Project'),
  requestId?: string(name='RequestId'),
  APIs?: [ string ](name='APIs'),
}

model ListProjectAPIsResponse = {
  headers: map[string]string(name='headers'),
  body: ListProjectAPIsResponseBody(name='body'),
}

async function listProjectAPIsWithOptions(request: ListProjectAPIsRequest, runtime: Util.RuntimeOptions): ListProjectAPIsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListProjectAPIs', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listProjectAPIs(request: ListProjectAPIsRequest): ListProjectAPIsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listProjectAPIsWithOptions(request, runtime);
}

model ListProjectsRequest {
  marker?: string(name='Marker'),
  maxKeys?: int32(name='MaxKeys'),
}

model ListProjectsResponseBody = {
  nextMarker?: string(name='NextMarker'),
  requestId?: string(name='RequestId'),
  projects?: [ 
    {
      type?: string(name='Type'),
      CU?: int32(name='CU'),
      createTime?: string(name='CreateTime'),
      serviceRole?: string(name='ServiceRole'),
      endpoint?: string(name='Endpoint'),
      project?: string(name='Project'),
      regionId?: string(name='RegionId'),
      billingType?: string(name='BillingType'),
      modifyTime?: string(name='ModifyTime'),
    }
  ](name='Projects'),
}

model ListProjectsResponse = {
  headers: map[string]string(name='headers'),
  body: ListProjectsResponseBody(name='body'),
}

async function listProjectsWithOptions(request: ListProjectsRequest, runtime: Util.RuntimeOptions): ListProjectsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListProjects', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listProjects(request: ListProjectsRequest): ListProjectsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listProjectsWithOptions(request, runtime);
}

model ListSetsRequest {
  project?: string(name='Project'),
  marker?: string(name='Marker'),
}

model ListSetsResponseBody = {
  nextMarker?: string(name='NextMarker'),
  requestId?: string(name='RequestId'),
  sets?: [ 
    {
      videoCount?: int32(name='VideoCount'),
      createTime?: string(name='CreateTime'),
      videoLength?: int32(name='VideoLength'),
      setId?: string(name='SetId'),
      imageCount?: int32(name='ImageCount'),
      faceCount?: int32(name='FaceCount'),
      setName?: string(name='SetName'),
      modifyTime?: string(name='ModifyTime'),
    }
  ](name='Sets'),
}

model ListSetsResponse = {
  headers: map[string]string(name='headers'),
  body: ListSetsResponseBody(name='body'),
}

async function listSetsWithOptions(request: ListSetsRequest, runtime: Util.RuntimeOptions): ListSetsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListSets', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listSets(request: ListSetsRequest): ListSetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSetsWithOptions(request, runtime);
}

model ListSetTagsRequest {
  project?: string(name='Project'),
  setId?: string(name='SetId'),
}

model ListSetTagsResponseBody = {
  setId?: string(name='SetId'),
  requestId?: string(name='RequestId'),
  tags?: [ 
    {
      tagLevel?: int32(name='TagLevel'),
      tagName?: string(name='TagName'),
      tagCount?: int32(name='TagCount'),
    }
  ](name='Tags'),
}

model ListSetTagsResponse = {
  headers: map[string]string(name='headers'),
  body: ListSetTagsResponseBody(name='body'),
}

async function listSetTagsWithOptions(request: ListSetTagsRequest, runtime: Util.RuntimeOptions): ListSetTagsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListSetTags', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listSetTags(request: ListSetTagsRequest): ListSetTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSetTagsWithOptions(request, runtime);
}

model ListVideoAudiosRequest {
  project?: string(name='Project'),
  setId?: string(name='SetId'),
  videoUri?: string(name='VideoUri'),
  marker?: string(name='Marker'),
}

model ListVideoAudiosResponseBody = {
  videoUri?: string(name='VideoUri'),
  requestId?: string(name='RequestId'),
  nextMarker?: string(name='NextMarker'),
  setId?: string(name='SetId'),
  audios?: [ 
    {
      sourcePosition?: string(name='SourcePosition'),
      remarksC?: string(name='RemarksC'),
      createTime?: string(name='CreateTime'),
      sourceType?: string(name='SourceType'),
      audioDuration?: float(name='AudioDuration'),
      audioTextsStatus?: string(name='AudioTextsStatus'),
      audioFormat?: string(name='AudioFormat'),
      remarksD?: string(name='RemarksD'),
      processFailReason?: string(name='ProcessFailReason'),
      processModifyTime?: string(name='ProcessModifyTime'),
      audioRate?: int32(name='AudioRate'),
      audioUri?: string(name='AudioUri'),
      audioTextsModifyTime?: string(name='AudioTextsModifyTime'),
      remarksA?: string(name='RemarksA'),
      externalId?: string(name='ExternalId'),
      sourceUri?: string(name='SourceUri'),
      processStatus?: string(name='ProcessStatus'),
      audioTextsFailReason?: string(name='AudioTextsFailReason'),
      remarksB?: string(name='RemarksB'),
      fileSize?: int32(name='FileSize'),
      modifyTime?: string(name='ModifyTime'),
      audioTexts?: [ 
        {
          endTime?: float(name='EndTime'),
          library?: string(name='Library'),
          confidence?: float(name='Confidence'),
          beginTime?: float(name='BeginTime'),
          channelId?: int32(name='ChannelId'),
          emotionValue?: float(name='EmotionValue'),
          speechRate?: int32(name='SpeechRate'),
          text?: string(name='Text'),
          person?: string(name='Person'),
          silenceDuration?: float(name='SilenceDuration'),
        }
      ](name='AudioTexts'),
    }
  ](name='Audios'),
}

model ListVideoAudiosResponse = {
  headers: map[string]string(name='headers'),
  body: ListVideoAudiosResponseBody(name='body'),
}

async function listVideoAudiosWithOptions(request: ListVideoAudiosRequest, runtime: Util.RuntimeOptions): ListVideoAudiosResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListVideoAudios', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listVideoAudios(request: ListVideoAudiosRequest): ListVideoAudiosResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVideoAudiosWithOptions(request, runtime);
}

model ListVideoFramesRequest {
  project?: string(name='Project'),
  setId?: string(name='SetId'),
  videoUri?: string(name='VideoUri'),
  marker?: string(name='Marker'),
}

model ListVideoFramesResponseBody = {
  videoUri?: string(name='VideoUri'),
  requestId?: string(name='RequestId'),
  nextMarker?: string(name='NextMarker'),
  setId?: string(name='SetId'),
  frames?: [ 
    {
      tagsFailReason?: string(name='TagsFailReason'),
      remarksC?: string(name='RemarksC'),
      createTime?: string(name='CreateTime'),
      sourceType?: string(name='SourceType'),
      facesFailReason?: string(name='FacesFailReason'),
      facesModifyTime?: string(name='FacesModifyTime'),
      imageTime?: string(name='ImageTime'),
      OCRModifyTime?: string(name='OCRModifyTime'),
      facesStatus?: string(name='FacesStatus'),
      imageHeight?: int32(name='ImageHeight'),
      externalId?: string(name='ExternalId'),
      sourceUri?: string(name='SourceUri'),
      modifyTime?: string(name='ModifyTime'),
      fileSize?: int32(name='FileSize'),
      sourcePosition?: string(name='SourcePosition'),
      OCRFailReason?: string(name='OCRFailReason'),
      imageFormat?: string(name='ImageFormat'),
      imageWidth?: int32(name='ImageWidth'),
      orientation?: string(name='Orientation'),
      remarksD?: string(name='RemarksD'),
      tagsStatus?: string(name='TagsStatus'),
      remarksA?: string(name='RemarksA'),
      imageUri?: string(name='ImageUri'),
      tagsModifyTime?: string(name='TagsModifyTime'),
      OCRStatus?: string(name='OCRStatus'),
      exif?: string(name='Exif'),
      location?: string(name='Location'),
      remarksB?: string(name='RemarksB'),
      faces?: [ 
        {
          emotionConfidence?: float(name='EmotionConfidence'),
          attractive?: float(name='Attractive'),
          groupId?: string(name='GroupId'),
          gender?: string(name='Gender'),
          faceId?: string(name='FaceId'),
          genderConfidence?: float(name='GenderConfidence'),
          faceQuality?: float(name='FaceQuality'),
          emotion?: string(name='Emotion'),
          age?: int32(name='Age'),
          faceConfidence?: float(name='FaceConfidence'),
          emotionDetails?: {
            HAPPY?: float(name='HAPPY'),
            SURPRISED?: float(name='SURPRISED'),
            CALM?: float(name='CALM'),
            DISGUSTED?: float(name='DISGUSTED'),
            ANGRY?: float(name='ANGRY'),
            SAD?: float(name='SAD'),
            SCARED?: float(name='SCARED'),
          }(name='EmotionDetails'),
          faceAttributes?: {
            glassesConfidence?: float(name='GlassesConfidence'),
            glasses?: string(name='Glasses'),
            mask?: string(name='Mask'),
            beardConfidence?: float(name='BeardConfidence'),
            maskConfidence?: float(name='MaskConfidence'),
            beard?: string(name='Beard'),
            faceBoundary?: {
              left?: int32(name='Left'),
              top?: int32(name='Top'),
              width?: int32(name='Width'),
              height?: int32(name='Height'),
            }(name='FaceBoundary'),
            headPose?: {
              pitch?: float(name='Pitch'),
              roll?: float(name='Roll'),
              yaw?: float(name='Yaw'),
            }(name='HeadPose'),
          }(name='FaceAttributes'),
        }
      ](name='Faces'),
      tags?: [ 
        {
          tagLevel?: int32(name='TagLevel'),
          parentTagName?: string(name='ParentTagName'),
          tagConfidence?: float(name='TagConfidence'),
          tagName?: string(name='TagName'),
        }
      ](name='Tags'),
      OCR?: [ 
        {
          OCRConfidence?: float(name='OCRConfidence'),
          OCRContents?: string(name='OCRContents'),
          OCRBoundary?: {
            left?: int32(name='Left'),
            top?: int32(name='Top'),
            width?: int32(name='Width'),
            height?: int32(name='Height'),
          }(name='OCRBoundary'),
        }
      ](name='OCR'),
    }
  ](name='Frames'),
}

model ListVideoFramesResponse = {
  headers: map[string]string(name='headers'),
  body: ListVideoFramesResponseBody(name='body'),
}

async function listVideoFramesWithOptions(request: ListVideoFramesRequest, runtime: Util.RuntimeOptions): ListVideoFramesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListVideoFrames', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listVideoFrames(request: ListVideoFramesRequest): ListVideoFramesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVideoFramesWithOptions(request, runtime);
}

model ListVideosRequest {
  project?: string(name='Project'),
  setId?: string(name='SetId'),
  createTimeStart?: string(name='CreateTimeStart'),
  marker?: string(name='Marker'),
}

model ListVideosResponseBody = {
  requestId?: string(name='RequestId'),
  nextMarker?: string(name='NextMarker'),
  setId?: string(name='SetId'),
  videos?: [ 
    {
      createTime?: string(name='CreateTime'),
      remarksC?: string(name='RemarksC'),
      videoTagsFailReason?: string(name='VideoTagsFailReason'),
      sourceType?: string(name='SourceType'),
      videoDuration?: float(name='VideoDuration'),
      processModifyTime?: string(name='ProcessModifyTime'),
      videoFrames?: int32(name='VideoFrames'),
      videoTagsStatus?: string(name='VideoTagsStatus'),
      externalId?: string(name='ExternalId'),
      sourceUri?: string(name='SourceUri'),
      modifyTime?: string(name='ModifyTime'),
      fileSize?: int32(name='FileSize'),
      sourcePosition?: string(name='SourcePosition'),
      videoWidth?: int32(name='VideoWidth'),
      videoHeight?: int32(name='VideoHeight'),
      videoFormat?: string(name='VideoFormat'),
      remarksD?: string(name='RemarksD'),
      videoUri?: string(name='VideoUri'),
      videoTagsModifyTime?: string(name='VideoTagsModifyTime'),
      processFailReason?: string(name='ProcessFailReason'),
      remarksA?: string(name='RemarksA'),
      processStatus?: string(name='ProcessStatus'),
      remarksB?: string(name='RemarksB'),
      videoTags?: [ 
        {
          tagLevel?: int32(name='TagLevel'),
          parentTagName?: string(name='ParentTagName'),
          tagName?: string(name='TagName'),
          tagConfidence?: float(name='TagConfidence'),
        }
      ](name='VideoTags'),
    }
  ](name='Videos'),
}

model ListVideosResponse = {
  headers: map[string]string(name='headers'),
  body: ListVideosResponseBody(name='body'),
}

async function listVideosWithOptions(request: ListVideosRequest, runtime: Util.RuntimeOptions): ListVideosResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListVideos', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listVideos(request: ListVideosRequest): ListVideosResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVideosWithOptions(request, runtime);
}

model ListVideoTasksRequest {
  project?: string(name='Project'),
  marker?: string(name='Marker'),
  maxKeys?: int32(name='MaxKeys'),
  taskType?: string(name='TaskType'),
}

model ListVideoTasksResponseBody = {
  nextMarker?: string(name='NextMarker'),
  requestId?: string(name='RequestId'),
  tasks?: [ 
    {
      endTime?: string(name='EndTime'),
      status?: string(name='Status'),
      startTime?: string(name='StartTime'),
      taskType?: string(name='TaskType'),
      progress?: int32(name='Progress'),
      notifyEndpoint?: string(name='NotifyEndpoint'),
      errorMessage?: string(name='ErrorMessage'),
      parameters?: string(name='Parameters'),
      result?: string(name='Result'),
      taskId?: string(name='TaskId'),
      notifyTopicName?: string(name='NotifyTopicName'),
    }
  ](name='Tasks'),
}

model ListVideoTasksResponse = {
  headers: map[string]string(name='headers'),
  body: ListVideoTasksResponseBody(name='body'),
}

async function listVideoTasksWithOptions(request: ListVideoTasksRequest, runtime: Util.RuntimeOptions): ListVideoTasksResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListVideoTasks', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listVideoTasks(request: ListVideoTasksRequest): ListVideoTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVideoTasksWithOptions(request, runtime);
}

model OpenImmServiceRequest {
  ownerId?: long(name='OwnerId'),
}

model OpenImmServiceResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model OpenImmServiceResponse = {
  headers: map[string]string(name='headers'),
  body: OpenImmServiceResponseBody(name='body'),
}

async function openImmServiceWithOptions(request: OpenImmServiceRequest, runtime: Util.RuntimeOptions): OpenImmServiceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('OpenImmService', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function openImmService(request: OpenImmServiceRequest): OpenImmServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return openImmServiceWithOptions(request, runtime);
}

model PutProjectRequest {
  project?: string(name='Project'),
  serviceRole?: string(name='ServiceRole'),
}

model PutProjectResponseBody = {
  project?: string(name='Project'),
  modifyTime?: string(name='ModifyTime'),
  type?: string(name='Type'),
  CU?: int32(name='CU'),
  serviceRole?: string(name='ServiceRole'),
  requestId?: string(name='RequestId'),
  endpoint?: string(name='Endpoint'),
  createTime?: string(name='CreateTime'),
  regionId?: string(name='RegionId'),
  billingType?: string(name='BillingType'),
}

model PutProjectResponse = {
  headers: map[string]string(name='headers'),
  body: PutProjectResponseBody(name='body'),
}

async function putProjectWithOptions(request: PutProjectRequest, runtime: Util.RuntimeOptions): PutProjectResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('PutProject', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function putProject(request: PutProjectRequest): PutProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return putProjectWithOptions(request, runtime);
}

model RefreshOfficeEditTokenRequest {
  project?: string(name='Project'),
  accessToken?: string(name='AccessToken'),
  refreshToken?: string(name='RefreshToken'),
}

model RefreshOfficeEditTokenResponseBody = {
  requestId?: string(name='RequestId'),
  accessTokenExpiredTime?: string(name='AccessTokenExpiredTime'),
  refreshToken?: string(name='RefreshToken'),
  accessToken?: string(name='AccessToken'),
  refreshTokenExpiredTime?: string(name='RefreshTokenExpiredTime'),
}

model RefreshOfficeEditTokenResponse = {
  headers: map[string]string(name='headers'),
  body: RefreshOfficeEditTokenResponseBody(name='body'),
}

async function refreshOfficeEditTokenWithOptions(request: RefreshOfficeEditTokenRequest, runtime: Util.RuntimeOptions): RefreshOfficeEditTokenResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RefreshOfficeEditToken', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function refreshOfficeEditToken(request: RefreshOfficeEditTokenRequest): RefreshOfficeEditTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return refreshOfficeEditTokenWithOptions(request, runtime);
}

model RefreshOfficePreviewTokenRequest {
  project?: string(name='Project'),
  accessToken?: string(name='AccessToken'),
  refreshToken?: string(name='RefreshToken'),
}

model RefreshOfficePreviewTokenResponseBody = {
  requestId?: string(name='RequestId'),
  accessTokenExpiredTime?: string(name='AccessTokenExpiredTime'),
  refreshToken?: string(name='RefreshToken'),
  accessToken?: string(name='AccessToken'),
  refreshTokenExpiredTime?: string(name='RefreshTokenExpiredTime'),
}

model RefreshOfficePreviewTokenResponse = {
  headers: map[string]string(name='headers'),
  body: RefreshOfficePreviewTokenResponseBody(name='body'),
}

async function refreshOfficePreviewTokenWithOptions(request: RefreshOfficePreviewTokenRequest, runtime: Util.RuntimeOptions): RefreshOfficePreviewTokenResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RefreshOfficePreviewToken', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function refreshOfficePreviewToken(request: RefreshOfficePreviewTokenRequest): RefreshOfficePreviewTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return refreshOfficePreviewTokenWithOptions(request, runtime);
}

model RefreshWebofficeTokenRequest {
  project?: string(name='Project'),
  accessToken?: string(name='AccessToken'),
  refreshToken?: string(name='RefreshToken'),
}

model RefreshWebofficeTokenResponseBody = {
  requestId?: string(name='RequestId'),
  accessTokenExpiredTime?: string(name='AccessTokenExpiredTime'),
  refreshToken?: string(name='RefreshToken'),
  accessToken?: string(name='AccessToken'),
  refreshTokenExpiredTime?: string(name='RefreshTokenExpiredTime'),
}

model RefreshWebofficeTokenResponse = {
  headers: map[string]string(name='headers'),
  body: RefreshWebofficeTokenResponseBody(name='body'),
}

async function refreshWebofficeTokenWithOptions(request: RefreshWebofficeTokenRequest, runtime: Util.RuntimeOptions): RefreshWebofficeTokenResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RefreshWebofficeToken', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function refreshWebofficeToken(request: RefreshWebofficeTokenRequest): RefreshWebofficeTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return refreshWebofficeTokenWithOptions(request, runtime);
}

model UpdateFaceGroupRequest {
  project?: string(name='Project'),
  setId?: string(name='SetId'),
  groupId?: string(name='GroupId'),
  groupName?: string(name='GroupName'),
  groupCoverFaceId?: string(name='GroupCoverFaceId'),
  remarksA?: string(name='RemarksA'),
  remarksB?: string(name='RemarksB'),
  remarksC?: string(name='RemarksC'),
  remarksD?: string(name='RemarksD'),
  remarksArrayA?: string(name='RemarksArrayA'),
  remarksArrayB?: string(name='RemarksArrayB'),
  externalId?: string(name='ExternalId'),
  resetItems?: string(name='ResetItems'),
}

model UpdateFaceGroupResponseBody = {
  requestId?: string(name='RequestId'),
  groupId?: string(name='GroupId'),
  setId?: string(name='SetId'),
}

model UpdateFaceGroupResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateFaceGroupResponseBody(name='body'),
}

async function updateFaceGroupWithOptions(request: UpdateFaceGroupRequest, runtime: Util.RuntimeOptions): UpdateFaceGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateFaceGroup', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateFaceGroup(request: UpdateFaceGroupRequest): UpdateFaceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateFaceGroupWithOptions(request, runtime);
}

model UpdateImageRequest {
  project?: string(name='Project'),
  setId?: string(name='SetId'),
  imageUri?: string(name='ImageUri'),
  remarksA?: string(name='RemarksA'),
  remarksB?: string(name='RemarksB'),
  sourceType?: string(name='SourceType'),
  sourceUri?: string(name='SourceUri'),
  sourcePosition?: string(name='SourcePosition'),
  remarksC?: string(name='RemarksC'),
  remarksD?: string(name='RemarksD'),
  externalId?: string(name='ExternalId'),
  remarksArrayA?: string(name='RemarksArrayA'),
  remarksArrayB?: string(name='RemarksArrayB'),
  faces?: [ 
    {
      faceId?: string(name='FaceId'),
      groupId?: string(name='GroupId'),
    }
  ](name='Faces'),
}

model UpdateImageShrinkRequest {
  project?: string(name='Project'),
  setId?: string(name='SetId'),
  imageUri?: string(name='ImageUri'),
  remarksA?: string(name='RemarksA'),
  remarksB?: string(name='RemarksB'),
  sourceType?: string(name='SourceType'),
  sourceUri?: string(name='SourceUri'),
  sourcePosition?: string(name='SourcePosition'),
  remarksC?: string(name='RemarksC'),
  remarksD?: string(name='RemarksD'),
  externalId?: string(name='ExternalId'),
  remarksArrayA?: string(name='RemarksArrayA'),
  remarksArrayB?: string(name='RemarksArrayB'),
  facesShrink?: string(name='Faces'),
}

model UpdateImageResponseBody = {
  remarksArrayB?: string(name='RemarksArrayB'),
  modifyTime?: string(name='ModifyTime'),
  remarksC?: string(name='RemarksC'),
  remarksD?: string(name='RemarksD'),
  requestId?: string(name='RequestId'),
  createTime?: string(name='CreateTime'),
  externalId?: string(name='ExternalId'),
  remarksArrayA?: string(name='RemarksArrayA'),
  remarksA?: string(name='RemarksA'),
  imageUri?: string(name='ImageUri'),
  setId?: string(name='SetId'),
  remarksB?: string(name='RemarksB'),
}

model UpdateImageResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateImageResponseBody(name='body'),
}

async function updateImageWithOptions(tmpReq: UpdateImageRequest, runtime: Util.RuntimeOptions): UpdateImageResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateImageShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.faces)) {
    request.facesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.faces, 'Faces', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateImage', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateImage(request: UpdateImageRequest): UpdateImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateImageWithOptions(request, runtime);
}

model UpdateProjectRequest {
  project?: string(name='Project'),
  newCU?: int32(name='NewCU'),
  newServiceRole?: string(name='NewServiceRole'),
}

model UpdateProjectResponseBody = {
  type?: string(name='Type'),
  requestId?: string(name='RequestId'),
  CU?: int32(name='CU'),
  createTime?: string(name='CreateTime'),
  serviceRole?: string(name='ServiceRole'),
  project?: string(name='Project'),
  regionId?: string(name='RegionId'),
  modifyTime?: string(name='ModifyTime'),
}

model UpdateProjectResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateProjectResponseBody(name='body'),
}

async function updateProjectWithOptions(request: UpdateProjectRequest, runtime: Util.RuntimeOptions): UpdateProjectResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateProject', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateProject(request: UpdateProjectRequest): UpdateProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateProjectWithOptions(request, runtime);
}

model UpdateSetRequest {
  project?: string(name='Project'),
  setId?: string(name='SetId'),
  setName?: string(name='SetName'),
}

model UpdateSetResponseBody = {
  requestId?: string(name='RequestId'),
  createTime?: string(name='CreateTime'),
  setName?: string(name='SetName'),
  modifyTime?: string(name='ModifyTime'),
  setId?: string(name='SetId'),
}

model UpdateSetResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateSetResponseBody(name='body'),
}

async function updateSetWithOptions(request: UpdateSetRequest, runtime: Util.RuntimeOptions): UpdateSetResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateSet', '2017-09-06', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateSet(request: UpdateSetRequest): UpdateSetResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSetWithOptions(request, runtime);
}

