/**
 *
 */
import OpenApi;
import OpenApi.OpenApiUtil;

extends OpenApi;


init(config: OpenApiUtil.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    'cn-hangzhou' = 'mpaas.aliyuncs.com',
    'ap-northeast-1' = 'mpaas.aliyuncs.com',
    'ap-northeast-2-pop' = 'mpaas.aliyuncs.com',
    'ap-south-1' = 'mpaas.aliyuncs.com',
    'ap-southeast-1' = 'mpaas.aliyuncs.com',
    'ap-southeast-2' = 'mpaas.aliyuncs.com',
    'ap-southeast-3' = 'mpaas.aliyuncs.com',
    'ap-southeast-5' = 'mpaas.aliyuncs.com',
    'cn-beijing' = 'mpaas.aliyuncs.com',
    'cn-beijing-finance-1' = 'mpaas.aliyuncs.com',
    'cn-beijing-finance-pop' = 'mpaas.aliyuncs.com',
    'cn-beijing-gov-1' = 'mpaas.aliyuncs.com',
    'cn-beijing-nu16-b01' = 'mpaas.aliyuncs.com',
    'cn-chengdu' = 'mpaas.aliyuncs.com',
    'cn-edge-1' = 'mpaas.aliyuncs.com',
    'cn-fujian' = 'mpaas.aliyuncs.com',
    'cn-haidian-cm12-c01' = 'mpaas.aliyuncs.com',
    'cn-hangzhou-bj-b01' = 'mpaas.aliyuncs.com',
    'cn-hangzhou-finance' = 'mpaas.aliyuncs.com',
    'cn-hangzhou-internal-prod-1' = 'mpaas.aliyuncs.com',
    'cn-hangzhou-internal-test-1' = 'mpaas.aliyuncs.com',
    'cn-hangzhou-internal-test-2' = 'mpaas.aliyuncs.com',
    'cn-hangzhou-internal-test-3' = 'mpaas.aliyuncs.com',
    'cn-hangzhou-test-306' = 'mpaas.aliyuncs.com',
    'cn-hongkong' = 'mpaas.aliyuncs.com',
    'cn-hongkong-finance-pop' = 'mpaas.aliyuncs.com',
    'cn-huhehaote' = 'mpaas.aliyuncs.com',
    'cn-north-2-gov-1' = 'mpaas.aliyuncs.com',
    'cn-qingdao' = 'mpaas.aliyuncs.com',
    'cn-qingdao-nebula' = 'mpaas.aliyuncs.com',
    'cn-shanghai' = 'mpaas.aliyuncs.com',
    'cn-shanghai-et15-b01' = 'mpaas.aliyuncs.com',
    'cn-shanghai-et2-b01' = 'mpaas.aliyuncs.com',
    'cn-shanghai-finance-1' = 'mpaas.aliyuncs.com',
    'cn-shanghai-inner' = 'mpaas.aliyuncs.com',
    'cn-shanghai-internal-test-1' = 'mpaas.aliyuncs.com',
    'cn-shenzhen' = 'mpaas.aliyuncs.com',
    'cn-shenzhen-finance-1' = 'mpaas.aliyuncs.com',
    'cn-shenzhen-inner' = 'mpaas.aliyuncs.com',
    'cn-shenzhen-st4-d01' = 'mpaas.aliyuncs.com',
    'cn-shenzhen-su18-b01' = 'mpaas.aliyuncs.com',
    'cn-wuhan' = 'mpaas.aliyuncs.com',
    'cn-yushanfang' = 'mpaas.aliyuncs.com',
    'cn-zhangbei-na61-b01' = 'mpaas.aliyuncs.com',
    'cn-zhangjiakou' = 'mpaas.aliyuncs.com',
    'cn-zhangjiakou-na62-a01' = 'mpaas.aliyuncs.com',
    'cn-zhengzhou-nebula-1' = 'mpaas.aliyuncs.com',
    'eu-central-1' = 'mpaas.aliyuncs.com',
    'eu-west-1' = 'mpaas.aliyuncs.com',
    'eu-west-1-oxs' = 'mpaas.aliyuncs.com',
    'me-east-1' = 'mpaas.aliyuncs.com',
    'rus-west-1-pop' = 'mpaas.aliyuncs.com',
    'us-east-1' = 'mpaas.aliyuncs.com',
    'us-west-1' = 'mpaas.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('mpaas', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!$isNull(endpoint)) {
    return endpoint;
  }
  
  if (!$isNull(endpointMap) && !$isNull(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return OpenApiUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model CancelMpsSchedulerRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  type?: int32(name='Type'),
  uniqueIds?: string(name='UniqueIds', description='This parameter is required.'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model CancelMpsSchedulerResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: string(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model CancelMpsSchedulerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CancelMpsSchedulerResponseBody(name='body'),
}

/**
 * @summary 取消定时任务
 *
 * @param request CancelMpsSchedulerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CancelMpsSchedulerResponse
 */
@context("cancelMpsSchedulerWithContext")
async function cancelMpsSchedulerWithOptions(request: CancelMpsSchedulerRequest, runtime: $RuntimeOptions): CancelMpsSchedulerResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.type)) {
    body['Type'] = request.type;
  }
  if (!$isNull(request.uniqueIds)) {
    body['UniqueIds'] = request.uniqueIds;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CancelMpsScheduler',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 取消定时任务
 *
 * @param request CancelMpsSchedulerRequest
 * @return CancelMpsSchedulerResponse
 */
async function cancelMpsScheduler(request: CancelMpsSchedulerRequest): CancelMpsSchedulerResponse {
  var runtime = new $RuntimeOptions{};
  return cancelMpsSchedulerWithOptions(request, runtime);
}

model CancelPushSchedulerRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  tenantId?: string(name='TenantId'),
  type?: int32(name='Type'),
  uniqueIds?: string(name='UniqueIds', description='This parameter is required.'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model CancelPushSchedulerResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: string(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model CancelPushSchedulerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CancelPushSchedulerResponseBody(name='body'),
}

/**
 * @param request CancelPushSchedulerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CancelPushSchedulerResponse
 */
@context("cancelPushSchedulerWithContext")
async function cancelPushSchedulerWithOptions(request: CancelPushSchedulerRequest, runtime: $RuntimeOptions): CancelPushSchedulerResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.type)) {
    body['Type'] = request.type;
  }
  if (!$isNull(request.uniqueIds)) {
    body['UniqueIds'] = request.uniqueIds;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CancelPushScheduler',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CancelPushSchedulerRequest
 * @return CancelPushSchedulerResponse
 */
async function cancelPushScheduler(request: CancelPushSchedulerRequest): CancelPushSchedulerResponse {
  var runtime = new $RuntimeOptions{};
  return cancelPushSchedulerWithOptions(request, runtime);
}

model ChangeMcubeMiniTaskStatusRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  bizType?: string(name='BizType', description='This parameter is required.'),
  packageId?: long(name='PackageId', description='This parameter is required.'),
  taskId?: long(name='TaskId', description='This parameter is required.'),
  taskStatus?: long(name='TaskStatus', description='This parameter is required.'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model ChangeMcubeMiniTaskStatusResponseBody = {
  changeMiniTaskStatusResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='ChangeMiniTaskStatusResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ChangeMcubeMiniTaskStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ChangeMcubeMiniTaskStatusResponseBody(name='body'),
}

/**
 * @param request ChangeMcubeMiniTaskStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ChangeMcubeMiniTaskStatusResponse
 */
@context("changeMcubeMiniTaskStatusWithContext")
async function changeMcubeMiniTaskStatusWithOptions(request: ChangeMcubeMiniTaskStatusRequest, runtime: $RuntimeOptions): ChangeMcubeMiniTaskStatusResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.bizType)) {
    body['BizType'] = request.bizType;
  }
  if (!$isNull(request.packageId)) {
    body['PackageId'] = request.packageId;
  }
  if (!$isNull(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  if (!$isNull(request.taskStatus)) {
    body['TaskStatus'] = request.taskStatus;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ChangeMcubeMiniTaskStatus',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ChangeMcubeMiniTaskStatusRequest
 * @return ChangeMcubeMiniTaskStatusResponse
 */
async function changeMcubeMiniTaskStatus(request: ChangeMcubeMiniTaskStatusRequest): ChangeMcubeMiniTaskStatusResponse {
  var runtime = new $RuntimeOptions{};
  return changeMcubeMiniTaskStatusWithOptions(request, runtime);
}

model ChangeMcubeNebulaTaskStatusRequest {
  appId?: string(name='AppId'),
  bizType?: string(name='BizType'),
  packageId?: string(name='PackageId'),
  taskId?: string(name='TaskId'),
  taskStatus?: int32(name='TaskStatus'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model ChangeMcubeNebulaTaskStatusResponseBody = {
  changeMcubeNebulaTaskStatusResult?: {
    errorCode?: string(name='ErrorCode'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='ChangeMcubeNebulaTaskStatusResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ChangeMcubeNebulaTaskStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ChangeMcubeNebulaTaskStatusResponseBody(name='body'),
}

/**
 * @param request ChangeMcubeNebulaTaskStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ChangeMcubeNebulaTaskStatusResponse
 */
@context("changeMcubeNebulaTaskStatusWithContext")
async function changeMcubeNebulaTaskStatusWithOptions(request: ChangeMcubeNebulaTaskStatusRequest, runtime: $RuntimeOptions): ChangeMcubeNebulaTaskStatusResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.bizType)) {
    body['BizType'] = request.bizType;
  }
  if (!$isNull(request.packageId)) {
    body['PackageId'] = request.packageId;
  }
  if (!$isNull(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  if (!$isNull(request.taskStatus)) {
    body['TaskStatus'] = request.taskStatus;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ChangeMcubeNebulaTaskStatus',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ChangeMcubeNebulaTaskStatusRequest
 * @return ChangeMcubeNebulaTaskStatusResponse
 */
async function changeMcubeNebulaTaskStatus(request: ChangeMcubeNebulaTaskStatusRequest): ChangeMcubeNebulaTaskStatusResponse {
  var runtime = new $RuntimeOptions{};
  return changeMcubeNebulaTaskStatusWithOptions(request, runtime);
}

model ChangeMcubePublicTaskStatusRequest {
  appId?: string(name='AppId'),
  taskId?: string(name='TaskId'),
  taskStatus?: string(name='TaskStatus'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model ChangeMcubePublicTaskStatusResponseBody = {
  changeResult?: {
    errorCode?: string(name='ErrorCode'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='ChangeResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ChangeMcubePublicTaskStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ChangeMcubePublicTaskStatusResponseBody(name='body'),
}

/**
 * @param request ChangeMcubePublicTaskStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ChangeMcubePublicTaskStatusResponse
 */
@context("changeMcubePublicTaskStatusWithContext")
async function changeMcubePublicTaskStatusWithOptions(request: ChangeMcubePublicTaskStatusRequest, runtime: $RuntimeOptions): ChangeMcubePublicTaskStatusResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  if (!$isNull(request.taskStatus)) {
    body['TaskStatus'] = request.taskStatus;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ChangeMcubePublicTaskStatus',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ChangeMcubePublicTaskStatusRequest
 * @return ChangeMcubePublicTaskStatusResponse
 */
async function changeMcubePublicTaskStatus(request: ChangeMcubePublicTaskStatusRequest): ChangeMcubePublicTaskStatusResponse {
  var runtime = new $RuntimeOptions{};
  return changeMcubePublicTaskStatusWithOptions(request, runtime);
}

model CreateMcubeMiniAppRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  h5Id?: string(name='H5Id', description='This parameter is required.'),
  h5Name?: string(name='H5Name', description='This parameter is required.'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model CreateMcubeMiniAppResponseBody = {
  createMiniResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='CreateMiniResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcubeMiniAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMcubeMiniAppResponseBody(name='body'),
}

/**
 * @param request CreateMcubeMiniAppRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateMcubeMiniAppResponse
 */
@context("createMcubeMiniAppWithContext")
async function createMcubeMiniAppWithOptions(request: CreateMcubeMiniAppRequest, runtime: $RuntimeOptions): CreateMcubeMiniAppResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.h5Id)) {
    body['H5Id'] = request.h5Id;
  }
  if (!$isNull(request.h5Name)) {
    body['H5Name'] = request.h5Name;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateMcubeMiniApp',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateMcubeMiniAppRequest
 * @return CreateMcubeMiniAppResponse
 */
async function createMcubeMiniApp(request: CreateMcubeMiniAppRequest): CreateMcubeMiniAppResponse {
  var runtime = new $RuntimeOptions{};
  return createMcubeMiniAppWithOptions(request, runtime);
}

model CreateMcubeMiniTaskRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  greyConfigInfo?: string(name='GreyConfigInfo'),
  greyEndtimeData?: string(name='GreyEndtimeData'),
  greyNum?: long(name='GreyNum'),
  memo?: string(name='Memo', description='This parameter is required.'),
  packageId?: long(name='PackageId', description='This parameter is required.'),
  publishMode?: long(name='PublishMode', description='This parameter is required.'),
  publishType?: long(name='PublishType', description='This parameter is required.'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
  whitelistIds?: string(name='WhitelistIds'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model CreateMcubeMiniTaskResponseBody = {
  createMiniTaskResult?: {
    miniTaskId?: string(name='MiniTaskId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='CreateMiniTaskResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcubeMiniTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMcubeMiniTaskResponseBody(name='body'),
}

/**
 * @param request CreateMcubeMiniTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateMcubeMiniTaskResponse
 */
@context("createMcubeMiniTaskWithContext")
async function createMcubeMiniTaskWithOptions(request: CreateMcubeMiniTaskRequest, runtime: $RuntimeOptions): CreateMcubeMiniTaskResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.greyConfigInfo)) {
    body['GreyConfigInfo'] = request.greyConfigInfo;
  }
  if (!$isNull(request.greyEndtimeData)) {
    body['GreyEndtimeData'] = request.greyEndtimeData;
  }
  if (!$isNull(request.greyNum)) {
    body['GreyNum'] = request.greyNum;
  }
  if (!$isNull(request.memo)) {
    body['Memo'] = request.memo;
  }
  if (!$isNull(request.packageId)) {
    body['PackageId'] = request.packageId;
  }
  if (!$isNull(request.publishMode)) {
    body['PublishMode'] = request.publishMode;
  }
  if (!$isNull(request.publishType)) {
    body['PublishType'] = request.publishType;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.whitelistIds)) {
    body['WhitelistIds'] = request.whitelistIds;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateMcubeMiniTask',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateMcubeMiniTaskRequest
 * @return CreateMcubeMiniTaskResponse
 */
async function createMcubeMiniTask(request: CreateMcubeMiniTaskRequest): CreateMcubeMiniTaskResponse {
  var runtime = new $RuntimeOptions{};
  return createMcubeMiniTaskWithOptions(request, runtime);
}

model CreateMcubeNebulaAppRequest {
  appId?: string(name='AppId'),
  h5Id?: string(name='H5Id'),
  h5Name?: string(name='H5Name'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model CreateMcubeNebulaAppResponseBody = {
  createNebulaAppResult?: {
    errorCode?: string(name='ErrorCode'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='CreateNebulaAppResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcubeNebulaAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMcubeNebulaAppResponseBody(name='body'),
}

/**
 * @param request CreateMcubeNebulaAppRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateMcubeNebulaAppResponse
 */
@context("createMcubeNebulaAppWithContext")
async function createMcubeNebulaAppWithOptions(request: CreateMcubeNebulaAppRequest, runtime: $RuntimeOptions): CreateMcubeNebulaAppResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.h5Id)) {
    body['H5Id'] = request.h5Id;
  }
  if (!$isNull(request.h5Name)) {
    body['H5Name'] = request.h5Name;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateMcubeNebulaApp',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateMcubeNebulaAppRequest
 * @return CreateMcubeNebulaAppResponse
 */
async function createMcubeNebulaApp(request: CreateMcubeNebulaAppRequest): CreateMcubeNebulaAppResponse {
  var runtime = new $RuntimeOptions{};
  return createMcubeNebulaAppWithOptions(request, runtime);
}

model CreateMcubeNebulaResourceRequest {
  appId?: string(name='AppId'),
  autoInstall?: int32(name='AutoInstall'),
  clientVersionMax?: string(name='ClientVersionMax'),
  clientVersionMin?: string(name='ClientVersionMin'),
  customDomainName?: string(name='CustomDomainName'),
  extendInfo?: string(name='ExtendInfo'),
  fileUrl?: string(name='FileUrl'),
  h5Id?: string(name='H5Id'),
  h5Name?: string(name='H5Name'),
  h5Version?: string(name='H5Version'),
  installType?: int32(name='InstallType'),
  mainUrl?: string(name='MainUrl'),
  onexFlag?: boolean(name='OnexFlag'),
  platform?: string(name='Platform'),
  repeatNebula?: int32(name='RepeatNebula'),
  resourceType?: int32(name='ResourceType'),
  subUrl?: string(name='SubUrl'),
  tenantId?: string(name='TenantId'),
  vhost?: string(name='Vhost'),
  workspaceId?: string(name='WorkspaceId'),
}

model CreateMcubeNebulaResourceResponseBody = {
  createMcubeNebulaResourceReslult?: {
    errorCode?: string(name='ErrorCode'),
    nebulaResourceId?: string(name='NebulaResourceId'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='CreateMcubeNebulaResourceReslult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcubeNebulaResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMcubeNebulaResourceResponseBody(name='body'),
}

/**
 * @param request CreateMcubeNebulaResourceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateMcubeNebulaResourceResponse
 */
@context("createMcubeNebulaResourceWithContext")
async function createMcubeNebulaResourceWithOptions(request: CreateMcubeNebulaResourceRequest, runtime: $RuntimeOptions): CreateMcubeNebulaResourceResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.autoInstall)) {
    body['AutoInstall'] = request.autoInstall;
  }
  if (!$isNull(request.clientVersionMax)) {
    body['ClientVersionMax'] = request.clientVersionMax;
  }
  if (!$isNull(request.clientVersionMin)) {
    body['ClientVersionMin'] = request.clientVersionMin;
  }
  if (!$isNull(request.customDomainName)) {
    body['CustomDomainName'] = request.customDomainName;
  }
  if (!$isNull(request.extendInfo)) {
    body['ExtendInfo'] = request.extendInfo;
  }
  if (!$isNull(request.fileUrl)) {
    body['FileUrl'] = request.fileUrl;
  }
  if (!$isNull(request.h5Id)) {
    body['H5Id'] = request.h5Id;
  }
  if (!$isNull(request.h5Name)) {
    body['H5Name'] = request.h5Name;
  }
  if (!$isNull(request.h5Version)) {
    body['H5Version'] = request.h5Version;
  }
  if (!$isNull(request.installType)) {
    body['InstallType'] = request.installType;
  }
  if (!$isNull(request.mainUrl)) {
    body['MainUrl'] = request.mainUrl;
  }
  if (!$isNull(request.onexFlag)) {
    body['OnexFlag'] = request.onexFlag;
  }
  if (!$isNull(request.platform)) {
    body['Platform'] = request.platform;
  }
  if (!$isNull(request.repeatNebula)) {
    body['RepeatNebula'] = request.repeatNebula;
  }
  if (!$isNull(request.resourceType)) {
    body['ResourceType'] = request.resourceType;
  }
  if (!$isNull(request.subUrl)) {
    body['SubUrl'] = request.subUrl;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.vhost)) {
    body['Vhost'] = request.vhost;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateMcubeNebulaResource',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateMcubeNebulaResourceRequest
 * @return CreateMcubeNebulaResourceResponse
 */
async function createMcubeNebulaResource(request: CreateMcubeNebulaResourceRequest): CreateMcubeNebulaResourceResponse {
  var runtime = new $RuntimeOptions{};
  return createMcubeNebulaResourceWithOptions(request, runtime);
}

model CreateMcubeNebulaTaskRequest {
  appCode?: string(name='AppCode'),
  appId?: string(name='AppId'),
  bizType?: string(name='BizType'),
  creator?: string(name='Creator'),
  gmtCreate?: string(name='GmtCreate'),
  gmtModified?: string(name='GmtModified'),
  gmtModifiedStr?: string(name='GmtModifiedStr'),
  greyConfigInfo?: string(name='GreyConfigInfo'),
  greyEndtime?: string(name='GreyEndtime'),
  greyEndtimeData?: string(name='GreyEndtimeData'),
  greyEndtimeStr?: string(name='GreyEndtimeStr'),
  greyNum?: int32(name='GreyNum'),
  greyUrl?: string(name='GreyUrl'),
  id?: long(name='Id'),
  memo?: string(name='Memo'),
  modifier?: string(name='Modifier'),
  packageId?: long(name='PackageId'),
  percent?: int32(name='Percent'),
  platform?: string(name='Platform'),
  productId?: string(name='ProductId'),
  productVersion?: string(name='ProductVersion'),
  publishMode?: int32(name='PublishMode'),
  publishType?: int32(name='PublishType'),
  releaseVersion?: string(name='ReleaseVersion'),
  resIds?: string(name='ResIds'),
  serialVersionUID?: long(name='SerialVersionUID'),
  status?: int32(name='Status'),
  syncMode?: string(name='SyncMode'),
  syncResult?: string(name='SyncResult'),
  taskName?: string(name='TaskName'),
  taskStatus?: int32(name='TaskStatus'),
  taskType?: int32(name='TaskType'),
  taskVersion?: long(name='TaskVersion'),
  tenantId?: string(name='TenantId'),
  upgradeNoticeNum?: long(name='UpgradeNoticeNum'),
  upgradeProgress?: string(name='UpgradeProgress'),
  whitelistIds?: string(name='WhitelistIds'),
  workspaceId?: string(name='WorkspaceId'),
}

model CreateMcubeNebulaTaskResponseBody = {
  createMcubeNebulaTaskResult?: {
    errorCode?: string(name='ErrorCode'),
    nebulaTaskId?: string(name='NebulaTaskId'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='CreateMcubeNebulaTaskResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcubeNebulaTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMcubeNebulaTaskResponseBody(name='body'),
}

/**
 * @param request CreateMcubeNebulaTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateMcubeNebulaTaskResponse
 */
@context("createMcubeNebulaTaskWithContext")
async function createMcubeNebulaTaskWithOptions(request: CreateMcubeNebulaTaskRequest, runtime: $RuntimeOptions): CreateMcubeNebulaTaskResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appCode)) {
    body['AppCode'] = request.appCode;
  }
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.bizType)) {
    body['BizType'] = request.bizType;
  }
  if (!$isNull(request.creator)) {
    body['Creator'] = request.creator;
  }
  if (!$isNull(request.gmtCreate)) {
    body['GmtCreate'] = request.gmtCreate;
  }
  if (!$isNull(request.gmtModified)) {
    body['GmtModified'] = request.gmtModified;
  }
  if (!$isNull(request.gmtModifiedStr)) {
    body['GmtModifiedStr'] = request.gmtModifiedStr;
  }
  if (!$isNull(request.greyConfigInfo)) {
    body['GreyConfigInfo'] = request.greyConfigInfo;
  }
  if (!$isNull(request.greyEndtime)) {
    body['GreyEndtime'] = request.greyEndtime;
  }
  if (!$isNull(request.greyEndtimeData)) {
    body['GreyEndtimeData'] = request.greyEndtimeData;
  }
  if (!$isNull(request.greyEndtimeStr)) {
    body['GreyEndtimeStr'] = request.greyEndtimeStr;
  }
  if (!$isNull(request.greyNum)) {
    body['GreyNum'] = request.greyNum;
  }
  if (!$isNull(request.greyUrl)) {
    body['GreyUrl'] = request.greyUrl;
  }
  if (!$isNull(request.id)) {
    body['Id'] = request.id;
  }
  if (!$isNull(request.memo)) {
    body['Memo'] = request.memo;
  }
  if (!$isNull(request.modifier)) {
    body['Modifier'] = request.modifier;
  }
  if (!$isNull(request.packageId)) {
    body['PackageId'] = request.packageId;
  }
  if (!$isNull(request.percent)) {
    body['Percent'] = request.percent;
  }
  if (!$isNull(request.platform)) {
    body['Platform'] = request.platform;
  }
  if (!$isNull(request.productId)) {
    body['ProductId'] = request.productId;
  }
  if (!$isNull(request.productVersion)) {
    body['ProductVersion'] = request.productVersion;
  }
  if (!$isNull(request.publishMode)) {
    body['PublishMode'] = request.publishMode;
  }
  if (!$isNull(request.publishType)) {
    body['PublishType'] = request.publishType;
  }
  if (!$isNull(request.releaseVersion)) {
    body['ReleaseVersion'] = request.releaseVersion;
  }
  if (!$isNull(request.resIds)) {
    body['ResIds'] = request.resIds;
  }
  if (!$isNull(request.serialVersionUID)) {
    body['SerialVersionUID'] = request.serialVersionUID;
  }
  if (!$isNull(request.status)) {
    body['Status'] = request.status;
  }
  if (!$isNull(request.syncMode)) {
    body['SyncMode'] = request.syncMode;
  }
  if (!$isNull(request.syncResult)) {
    body['SyncResult'] = request.syncResult;
  }
  if (!$isNull(request.taskName)) {
    body['TaskName'] = request.taskName;
  }
  if (!$isNull(request.taskStatus)) {
    body['TaskStatus'] = request.taskStatus;
  }
  if (!$isNull(request.taskType)) {
    body['TaskType'] = request.taskType;
  }
  if (!$isNull(request.taskVersion)) {
    body['TaskVersion'] = request.taskVersion;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.upgradeNoticeNum)) {
    body['UpgradeNoticeNum'] = request.upgradeNoticeNum;
  }
  if (!$isNull(request.upgradeProgress)) {
    body['UpgradeProgress'] = request.upgradeProgress;
  }
  if (!$isNull(request.whitelistIds)) {
    body['WhitelistIds'] = request.whitelistIds;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateMcubeNebulaTask',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateMcubeNebulaTaskRequest
 * @return CreateMcubeNebulaTaskResponse
 */
async function createMcubeNebulaTask(request: CreateMcubeNebulaTaskRequest): CreateMcubeNebulaTaskResponse {
  var runtime = new $RuntimeOptions{};
  return createMcubeNebulaTaskWithOptions(request, runtime);
}

model CreateMcubeUpgradePackageRequest {
  appId?: string(name='AppId'),
  appVersion?: string(name='AppVersion'),
  appstoreUrl?: string(name='AppstoreUrl'),
  bundleId?: string(name='BundleId'),
  customDomainName?: string(name='CustomDomainName'),
  desc?: string(name='Desc'),
  downloadUrl?: string(name='DownloadUrl'),
  fileUrl?: string(name='FileUrl'),
  iconFileUrl?: string(name='IconFileUrl'),
  installAmount?: int32(name='InstallAmount'),
  iosSymbolfileUrl?: string(name='IosSymbolfileUrl'),
  isEnterprise?: int32(name='IsEnterprise'),
  needCheck?: int32(name='NeedCheck'),
  onexFlag?: boolean(name='OnexFlag'),
  platform?: string(name='Platform'),
  tenantId?: string(name='TenantId'),
  validDays?: int32(name='ValidDays'),
  workspaceId?: string(name='WorkspaceId'),
}

model CreateMcubeUpgradePackageResponseBody = {
  createUpgradePackageResult?: {
    errorCode?: string(name='ErrorCode'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
    upgradePackageId?: string(name='UpgradePackageId'),
  }(name='CreateUpgradePackageResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcubeUpgradePackageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMcubeUpgradePackageResponseBody(name='body'),
}

/**
 * @param request CreateMcubeUpgradePackageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateMcubeUpgradePackageResponse
 */
@context("createMcubeUpgradePackageWithContext")
async function createMcubeUpgradePackageWithOptions(request: CreateMcubeUpgradePackageRequest, runtime: $RuntimeOptions): CreateMcubeUpgradePackageResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.appVersion)) {
    body['AppVersion'] = request.appVersion;
  }
  if (!$isNull(request.appstoreUrl)) {
    body['AppstoreUrl'] = request.appstoreUrl;
  }
  if (!$isNull(request.bundleId)) {
    body['BundleId'] = request.bundleId;
  }
  if (!$isNull(request.customDomainName)) {
    body['CustomDomainName'] = request.customDomainName;
  }
  if (!$isNull(request.desc)) {
    body['Desc'] = request.desc;
  }
  if (!$isNull(request.downloadUrl)) {
    body['DownloadUrl'] = request.downloadUrl;
  }
  if (!$isNull(request.fileUrl)) {
    body['FileUrl'] = request.fileUrl;
  }
  if (!$isNull(request.iconFileUrl)) {
    body['IconFileUrl'] = request.iconFileUrl;
  }
  if (!$isNull(request.installAmount)) {
    body['InstallAmount'] = request.installAmount;
  }
  if (!$isNull(request.iosSymbolfileUrl)) {
    body['IosSymbolfileUrl'] = request.iosSymbolfileUrl;
  }
  if (!$isNull(request.isEnterprise)) {
    body['IsEnterprise'] = request.isEnterprise;
  }
  if (!$isNull(request.needCheck)) {
    body['NeedCheck'] = request.needCheck;
  }
  if (!$isNull(request.onexFlag)) {
    body['OnexFlag'] = request.onexFlag;
  }
  if (!$isNull(request.platform)) {
    body['Platform'] = request.platform;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.validDays)) {
    body['ValidDays'] = request.validDays;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateMcubeUpgradePackage',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateMcubeUpgradePackageRequest
 * @return CreateMcubeUpgradePackageResponse
 */
async function createMcubeUpgradePackage(request: CreateMcubeUpgradePackageRequest): CreateMcubeUpgradePackageResponse {
  var runtime = new $RuntimeOptions{};
  return createMcubeUpgradePackageWithOptions(request, runtime);
}

model CreateMcubeUpgradeTaskRequest {
  appId?: string(name='AppId'),
  greyConfigInfo?: string(name='GreyConfigInfo'),
  greyEndtimeData?: string(name='GreyEndtimeData'),
  greyNum?: int32(name='GreyNum'),
  historyForce?: int32(name='HistoryForce'),
  memo?: string(name='Memo'),
  packageInfoId?: long(name='PackageInfoId'),
  publishMode?: int32(name='PublishMode'),
  publishType?: int32(name='PublishType'),
  tenantId?: string(name='TenantId'),
  upgradeContent?: string(name='UpgradeContent'),
  upgradeType?: int32(name='UpgradeType'),
  whitelistIds?: string(name='WhitelistIds'),
  workspaceId?: string(name='WorkspaceId'),
}

model CreateMcubeUpgradeTaskResponseBody = {
  createTaskResult?: {
    errorCode?: string(name='ErrorCode'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
    upgradeTaskId?: string(name='UpgradeTaskId'),
  }(name='CreateTaskResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcubeUpgradeTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMcubeUpgradeTaskResponseBody(name='body'),
}

/**
 * @param request CreateMcubeUpgradeTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateMcubeUpgradeTaskResponse
 */
@context("createMcubeUpgradeTaskWithContext")
async function createMcubeUpgradeTaskWithOptions(request: CreateMcubeUpgradeTaskRequest, runtime: $RuntimeOptions): CreateMcubeUpgradeTaskResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.greyConfigInfo)) {
    body['GreyConfigInfo'] = request.greyConfigInfo;
  }
  if (!$isNull(request.greyEndtimeData)) {
    body['GreyEndtimeData'] = request.greyEndtimeData;
  }
  if (!$isNull(request.greyNum)) {
    body['GreyNum'] = request.greyNum;
  }
  if (!$isNull(request.historyForce)) {
    body['HistoryForce'] = request.historyForce;
  }
  if (!$isNull(request.memo)) {
    body['Memo'] = request.memo;
  }
  if (!$isNull(request.packageInfoId)) {
    body['PackageInfoId'] = request.packageInfoId;
  }
  if (!$isNull(request.publishMode)) {
    body['PublishMode'] = request.publishMode;
  }
  if (!$isNull(request.publishType)) {
    body['PublishType'] = request.publishType;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.upgradeContent)) {
    body['UpgradeContent'] = request.upgradeContent;
  }
  if (!$isNull(request.upgradeType)) {
    body['UpgradeType'] = request.upgradeType;
  }
  if (!$isNull(request.whitelistIds)) {
    body['WhitelistIds'] = request.whitelistIds;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateMcubeUpgradeTask',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateMcubeUpgradeTaskRequest
 * @return CreateMcubeUpgradeTaskResponse
 */
async function createMcubeUpgradeTask(request: CreateMcubeUpgradeTaskRequest): CreateMcubeUpgradeTaskResponse {
  var runtime = new $RuntimeOptions{};
  return createMcubeUpgradeTaskWithOptions(request, runtime);
}

model CreateMcubeVhostRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
  vhost?: string(name='Vhost', description='This parameter is required.'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model CreateMcubeVhostResponseBody = {
  createVhostResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='CreateVhostResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcubeVhostResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMcubeVhostResponseBody(name='body'),
}

/**
 * @param request CreateMcubeVhostRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateMcubeVhostResponse
 */
@context("createMcubeVhostWithContext")
async function createMcubeVhostWithOptions(request: CreateMcubeVhostRequest, runtime: $RuntimeOptions): CreateMcubeVhostResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.vhost)) {
    body['Vhost'] = request.vhost;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateMcubeVhost',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateMcubeVhostRequest
 * @return CreateMcubeVhostResponse
 */
async function createMcubeVhost(request: CreateMcubeVhostRequest): CreateMcubeVhostResponse {
  var runtime = new $RuntimeOptions{};
  return createMcubeVhostWithOptions(request, runtime);
}

model CreateMcubeWhitelistRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
  whiteListName?: string(name='WhiteListName', description='This parameter is required.'),
  whitelistType?: string(name='WhitelistType', description='This parameter is required.'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model CreateMcubeWhitelistResponseBody = {
  createWhitelistResult?: {
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
    whitelistId?: string(name='WhitelistId'),
  }(name='CreateWhitelistResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcubeWhitelistResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMcubeWhitelistResponseBody(name='body'),
}

/**
 * @param request CreateMcubeWhitelistRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateMcubeWhitelistResponse
 */
@context("createMcubeWhitelistWithContext")
async function createMcubeWhitelistWithOptions(request: CreateMcubeWhitelistRequest, runtime: $RuntimeOptions): CreateMcubeWhitelistResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.whiteListName)) {
    body['WhiteListName'] = request.whiteListName;
  }
  if (!$isNull(request.whitelistType)) {
    body['WhitelistType'] = request.whitelistType;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateMcubeWhitelist',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateMcubeWhitelistRequest
 * @return CreateMcubeWhitelistResponse
 */
async function createMcubeWhitelist(request: CreateMcubeWhitelistRequest): CreateMcubeWhitelistResponse {
  var runtime = new $RuntimeOptions{};
  return createMcubeWhitelistWithOptions(request, runtime);
}

model CreateMcubeWhitelistForIdeRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
  userId?: string(name='UserId', description='This parameter is required.'),
  whitelistValue?: string(name='WhitelistValue', description='This parameter is required.'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model CreateMcubeWhitelistForIdeResponseBody = {
  createWhitelistForIdeResult?: {
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
    whitelistId?: string(name='WhitelistId'),
  }(name='CreateWhitelistForIdeResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcubeWhitelistForIdeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMcubeWhitelistForIdeResponseBody(name='body'),
}

/**
 * @param request CreateMcubeWhitelistForIdeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateMcubeWhitelistForIdeResponse
 */
@context("createMcubeWhitelistForIdeWithContext")
async function createMcubeWhitelistForIdeWithOptions(request: CreateMcubeWhitelistForIdeRequest, runtime: $RuntimeOptions): CreateMcubeWhitelistForIdeResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.userId)) {
    body['UserId'] = request.userId;
  }
  if (!$isNull(request.whitelistValue)) {
    body['WhitelistValue'] = request.whitelistValue;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateMcubeWhitelistForIde',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateMcubeWhitelistForIdeRequest
 * @return CreateMcubeWhitelistForIdeResponse
 */
async function createMcubeWhitelistForIde(request: CreateMcubeWhitelistForIdeRequest): CreateMcubeWhitelistForIdeResponse {
  var runtime = new $RuntimeOptions{};
  return createMcubeWhitelistForIdeWithOptions(request, runtime);
}

model CreateOpenGlobalDataRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  appMaxVersion?: string(name='AppMaxVersion'),
  appMinVersion?: string(name='AppMinVersion'),
  bizType?: string(name='BizType', description='This parameter is required.'),
  extAttrStr?: string(name='ExtAttrStr'),
  maxUid?: long(name='MaxUid'),
  minUid?: long(name='MinUid'),
  osType?: string(name='OsType'),
  payload?: string(name='Payload', description='This parameter is required.'),
  tenantId?: string(name='TenantId'),
  thirdMsgId?: string(name='ThirdMsgId', description='This parameter is required.'),
  uids?: string(name='Uids'),
  validTimeEnd?: long(name='ValidTimeEnd'),
  validTimeStart?: long(name='ValidTimeStart'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model CreateOpenGlobalDataResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateOpenGlobalDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateOpenGlobalDataResponseBody(name='body'),
}

/**
 * @param request CreateOpenGlobalDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateOpenGlobalDataResponse
 */
@context("createOpenGlobalDataWithContext")
async function createOpenGlobalDataWithOptions(request: CreateOpenGlobalDataRequest, runtime: $RuntimeOptions): CreateOpenGlobalDataResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.appMaxVersion)) {
    body['AppMaxVersion'] = request.appMaxVersion;
  }
  if (!$isNull(request.appMinVersion)) {
    body['AppMinVersion'] = request.appMinVersion;
  }
  if (!$isNull(request.bizType)) {
    body['BizType'] = request.bizType;
  }
  if (!$isNull(request.extAttrStr)) {
    body['ExtAttrStr'] = request.extAttrStr;
  }
  if (!$isNull(request.maxUid)) {
    body['MaxUid'] = request.maxUid;
  }
  if (!$isNull(request.minUid)) {
    body['MinUid'] = request.minUid;
  }
  if (!$isNull(request.osType)) {
    body['OsType'] = request.osType;
  }
  if (!$isNull(request.payload)) {
    body['Payload'] = request.payload;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.thirdMsgId)) {
    body['ThirdMsgId'] = request.thirdMsgId;
  }
  if (!$isNull(request.uids)) {
    body['Uids'] = request.uids;
  }
  if (!$isNull(request.validTimeEnd)) {
    body['ValidTimeEnd'] = request.validTimeEnd;
  }
  if (!$isNull(request.validTimeStart)) {
    body['ValidTimeStart'] = request.validTimeStart;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateOpenGlobalData',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateOpenGlobalDataRequest
 * @return CreateOpenGlobalDataResponse
 */
async function createOpenGlobalData(request: CreateOpenGlobalDataRequest): CreateOpenGlobalDataResponse {
  var runtime = new $RuntimeOptions{};
  return createOpenGlobalDataWithOptions(request, runtime);
}

model CreateOpenSingleDataRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  appMaxVersion?: string(name='AppMaxVersion'),
  appMinVersion?: string(name='AppMinVersion'),
  bizType?: string(name='BizType', description='This parameter is required.'),
  checkOnline?: boolean(name='CheckOnline'),
  extAttrStr?: string(name='ExtAttrStr'),
  linkToken?: string(name='LinkToken', description='This parameter is required.'),
  osType?: string(name='OsType'),
  payload?: string(name='Payload', description='This parameter is required.'),
  tenantId?: string(name='TenantId'),
  thirdMsgId?: string(name='ThirdMsgId', description='This parameter is required.'),
  validTimeEnd?: long(name='ValidTimeEnd'),
  validTimeStart?: long(name='ValidTimeStart'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model CreateOpenSingleDataResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateOpenSingleDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateOpenSingleDataResponseBody(name='body'),
}

/**
 * @param request CreateOpenSingleDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateOpenSingleDataResponse
 */
@context("createOpenSingleDataWithContext")
async function createOpenSingleDataWithOptions(request: CreateOpenSingleDataRequest, runtime: $RuntimeOptions): CreateOpenSingleDataResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.appMaxVersion)) {
    body['AppMaxVersion'] = request.appMaxVersion;
  }
  if (!$isNull(request.appMinVersion)) {
    body['AppMinVersion'] = request.appMinVersion;
  }
  if (!$isNull(request.bizType)) {
    body['BizType'] = request.bizType;
  }
  if (!$isNull(request.checkOnline)) {
    body['CheckOnline'] = request.checkOnline;
  }
  if (!$isNull(request.extAttrStr)) {
    body['ExtAttrStr'] = request.extAttrStr;
  }
  if (!$isNull(request.linkToken)) {
    body['LinkToken'] = request.linkToken;
  }
  if (!$isNull(request.osType)) {
    body['OsType'] = request.osType;
  }
  if (!$isNull(request.payload)) {
    body['Payload'] = request.payload;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.thirdMsgId)) {
    body['ThirdMsgId'] = request.thirdMsgId;
  }
  if (!$isNull(request.validTimeEnd)) {
    body['ValidTimeEnd'] = request.validTimeEnd;
  }
  if (!$isNull(request.validTimeStart)) {
    body['ValidTimeStart'] = request.validTimeStart;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateOpenSingleData',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateOpenSingleDataRequest
 * @return CreateOpenSingleDataResponse
 */
async function createOpenSingleData(request: CreateOpenSingleDataRequest): CreateOpenSingleDataResponse {
  var runtime = new $RuntimeOptions{};
  return createOpenSingleDataWithOptions(request, runtime);
}

model CreateTemplateRequest {
  appId?: string(name='AppId', example='ALIPUB9A63274111812'),
  content?: string(name='Content', example='hh'),
  descInfo?: string(name='DescInfo'),
  iconUrls?: string(name='IconUrls', example='{"defaultUrl": "http://111"}'),
  imageUrls?: string(name='ImageUrls', example='{"defaultUrl": "http://111"}'),
  jumpAction?: int32(name='JumpAction', example='0'),
  pushStyle?: int32(name='PushStyle', example='0'),
  showStyle?: long(name='ShowStyle', example='0'),
  templateName?: string(name='TemplateName'),
  tenantId?: string(name='TenantId', example='NPHTGKNR'),
  title?: string(name='Title', example='OKOK'),
  uri?: string(name='Uri', example='https://jsonplaceholder.typicode.com/nonexistent'),
  variables?: string(name='Variables', example='title,content'),
  workspaceId?: string(name='WorkspaceId', example='default'),
}

model CreateTemplateResponseBody = {
  code?: string(name='Code', example='100'),
  data?: string(name='Data', example='null'),
  msg?: string(name='Msg', example='SUCCESS'),
  requestId?: string(name='RequestId', description='Id of the request', example='0CC8A9CB-9BA3-13FD-A404-6E2E7461881A'),
  success?: boolean(name='Success', example='True'),
}

model CreateTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateTemplateResponseBody(name='body'),
}

/**
 * @summary 创建模版
 *
 * @param request CreateTemplateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateTemplateResponse
 */
@context("createTemplateWithContext")
async function createTemplateWithOptions(request: CreateTemplateRequest, runtime: $RuntimeOptions): CreateTemplateResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.content)) {
    body['Content'] = request.content;
  }
  if (!$isNull(request.descInfo)) {
    body['DescInfo'] = request.descInfo;
  }
  if (!$isNull(request.iconUrls)) {
    body['IconUrls'] = request.iconUrls;
  }
  if (!$isNull(request.imageUrls)) {
    body['ImageUrls'] = request.imageUrls;
  }
  if (!$isNull(request.jumpAction)) {
    body['JumpAction'] = request.jumpAction;
  }
  if (!$isNull(request.pushStyle)) {
    body['PushStyle'] = request.pushStyle;
  }
  if (!$isNull(request.showStyle)) {
    body['ShowStyle'] = request.showStyle;
  }
  if (!$isNull(request.templateName)) {
    body['TemplateName'] = request.templateName;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.title)) {
    body['Title'] = request.title;
  }
  if (!$isNull(request.uri)) {
    body['Uri'] = request.uri;
  }
  if (!$isNull(request.variables)) {
    body['Variables'] = request.variables;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateTemplate',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 创建模版
 *
 * @param request CreateTemplateRequest
 * @return CreateTemplateResponse
 */
async function createTemplate(request: CreateTemplateRequest): CreateTemplateResponse {
  var runtime = new $RuntimeOptions{};
  return createTemplateWithOptions(request, runtime);
}

model DeleteCubecardWhitelistContentRequest {
  appId?: string(name='AppId'),
  tenantId?: string(name='TenantId'),
  whitelistId?: string(name='WhitelistId'),
  whitelistValue?: string(name='WhitelistValue'),
  workspaceId?: string(name='WorkspaceId'),
}

model DeleteCubecardWhitelistContentResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: {
      content?: string(name='Content'),
      errorCode?: string(name='ErrorCode'),
      resultMsg?: string(name='ResultMsg'),
      success?: boolean(name='Success'),
    }(name='Data'),
    requestId?: string(name='RequestId'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model DeleteCubecardWhitelistContentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteCubecardWhitelistContentResponseBody(name='body'),
}

/**
 * @param request DeleteCubecardWhitelistContentRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteCubecardWhitelistContentResponse
 */
@context("deleteCubecardWhitelistContentWithContext")
async function deleteCubecardWhitelistContentWithOptions(request: DeleteCubecardWhitelistContentRequest, runtime: $RuntimeOptions): DeleteCubecardWhitelistContentResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.whitelistId)) {
    body['WhitelistId'] = request.whitelistId;
  }
  if (!$isNull(request.whitelistValue)) {
    body['WhitelistValue'] = request.whitelistValue;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteCubecardWhitelistContent',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteCubecardWhitelistContentRequest
 * @return DeleteCubecardWhitelistContentResponse
 */
async function deleteCubecardWhitelistContent(request: DeleteCubecardWhitelistContentRequest): DeleteCubecardWhitelistContentResponse {
  var runtime = new $RuntimeOptions{};
  return deleteCubecardWhitelistContentWithOptions(request, runtime);
}

model DeleteMcubeMiniAppRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  h5Id?: string(name='H5Id', description='This parameter is required.'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model DeleteMcubeMiniAppResponseBody = {
  deleteMiniResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='DeleteMiniResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model DeleteMcubeMiniAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteMcubeMiniAppResponseBody(name='body'),
}

/**
 * @param request DeleteMcubeMiniAppRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteMcubeMiniAppResponse
 */
@context("deleteMcubeMiniAppWithContext")
async function deleteMcubeMiniAppWithOptions(request: DeleteMcubeMiniAppRequest, runtime: $RuntimeOptions): DeleteMcubeMiniAppResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.h5Id)) {
    body['H5Id'] = request.h5Id;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteMcubeMiniApp',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteMcubeMiniAppRequest
 * @return DeleteMcubeMiniAppResponse
 */
async function deleteMcubeMiniApp(request: DeleteMcubeMiniAppRequest): DeleteMcubeMiniAppResponse {
  var runtime = new $RuntimeOptions{};
  return deleteMcubeMiniAppWithOptions(request, runtime);
}

model DeleteMcubeNebulaAppRequest {
  appId?: string(name='AppId'),
  h5Id?: string(name='H5Id'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model DeleteMcubeNebulaAppResponseBody = {
  deleteMcubeNebulaAppResult?: {
    errorCode?: string(name='ErrorCode'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='DeleteMcubeNebulaAppResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model DeleteMcubeNebulaAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteMcubeNebulaAppResponseBody(name='body'),
}

/**
 * @param request DeleteMcubeNebulaAppRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteMcubeNebulaAppResponse
 */
@context("deleteMcubeNebulaAppWithContext")
async function deleteMcubeNebulaAppWithOptions(request: DeleteMcubeNebulaAppRequest, runtime: $RuntimeOptions): DeleteMcubeNebulaAppResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.h5Id)) {
    body['H5Id'] = request.h5Id;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteMcubeNebulaApp',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteMcubeNebulaAppRequest
 * @return DeleteMcubeNebulaAppResponse
 */
async function deleteMcubeNebulaApp(request: DeleteMcubeNebulaAppRequest): DeleteMcubeNebulaAppResponse {
  var runtime = new $RuntimeOptions{};
  return deleteMcubeNebulaAppWithOptions(request, runtime);
}

model DeleteMcubeUpgradeResourceRequest {
  appId?: string(name='AppId'),
  id?: string(name='Id'),
  platform?: string(name='Platform'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model DeleteMcubeUpgradeResourceResponseBody = {
  deleteResult?: {
    errorCode?: string(name='ErrorCode'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='DeleteResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model DeleteMcubeUpgradeResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteMcubeUpgradeResourceResponseBody(name='body'),
}

/**
 * @param request DeleteMcubeUpgradeResourceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteMcubeUpgradeResourceResponse
 */
@context("deleteMcubeUpgradeResourceWithContext")
async function deleteMcubeUpgradeResourceWithOptions(request: DeleteMcubeUpgradeResourceRequest, runtime: $RuntimeOptions): DeleteMcubeUpgradeResourceResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.id)) {
    body['Id'] = request.id;
  }
  if (!$isNull(request.platform)) {
    body['Platform'] = request.platform;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteMcubeUpgradeResource',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteMcubeUpgradeResourceRequest
 * @return DeleteMcubeUpgradeResourceResponse
 */
async function deleteMcubeUpgradeResource(request: DeleteMcubeUpgradeResourceRequest): DeleteMcubeUpgradeResourceResponse {
  var runtime = new $RuntimeOptions{};
  return deleteMcubeUpgradeResourceWithOptions(request, runtime);
}

model DeleteMcubeWhitelistRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  id?: long(name='Id', description='This parameter is required.'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model DeleteMcubeWhitelistResponseBody = {
  deleteWhitelistResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='DeleteWhitelistResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model DeleteMcubeWhitelistResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteMcubeWhitelistResponseBody(name='body'),
}

/**
 * @param request DeleteMcubeWhitelistRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteMcubeWhitelistResponse
 */
@context("deleteMcubeWhitelistWithContext")
async function deleteMcubeWhitelistWithOptions(request: DeleteMcubeWhitelistRequest, runtime: $RuntimeOptions): DeleteMcubeWhitelistResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.id)) {
    body['Id'] = request.id;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteMcubeWhitelist',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteMcubeWhitelistRequest
 * @return DeleteMcubeWhitelistResponse
 */
async function deleteMcubeWhitelist(request: DeleteMcubeWhitelistRequest): DeleteMcubeWhitelistResponse {
  var runtime = new $RuntimeOptions{};
  return deleteMcubeWhitelistWithOptions(request, runtime);
}

model DeleteMdsWhitelistContentRequest {
  appId?: string(name='AppId'),
  tenantId?: string(name='TenantId'),
  whitelistId?: string(name='WhitelistId'),
  whitelistValue?: string(name='WhitelistValue'),
  workspaceId?: string(name='WorkspaceId'),
}

model DeleteMdsWhitelistContentResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: {
      content?: string(name='Content'),
      errorCode?: string(name='ErrorCode'),
      resultMsg?: string(name='ResultMsg'),
      success?: boolean(name='Success'),
    }(name='Data'),
    requestId?: string(name='RequestId'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model DeleteMdsWhitelistContentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteMdsWhitelistContentResponseBody(name='body'),
}

/**
 * @param request DeleteMdsWhitelistContentRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteMdsWhitelistContentResponse
 */
@context("deleteMdsWhitelistContentWithContext")
async function deleteMdsWhitelistContentWithOptions(request: DeleteMdsWhitelistContentRequest, runtime: $RuntimeOptions): DeleteMdsWhitelistContentResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.whitelistId)) {
    body['WhitelistId'] = request.whitelistId;
  }
  if (!$isNull(request.whitelistValue)) {
    body['WhitelistValue'] = request.whitelistValue;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteMdsWhitelistContent',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteMdsWhitelistContentRequest
 * @return DeleteMdsWhitelistContentResponse
 */
async function deleteMdsWhitelistContent(request: DeleteMdsWhitelistContentRequest): DeleteMdsWhitelistContentResponse {
  var runtime = new $RuntimeOptions{};
  return deleteMdsWhitelistContentWithOptions(request, runtime);
}

model DeleteTemplateRequest {
  appId?: string(name='AppId', example='ALIPUBE5C3F6D091419'),
  templateId?: string(name='TemplateId', example='COEYM44ER0465E8G'),
  templateName?: string(name='TemplateName'),
  tenantId?: string(name='TenantId', example='NPHTGKNR'),
  workspaceId?: string(name='WorkspaceId', example='default'),
}

model DeleteTemplateResponseBody = {
  code?: string(name='Code', example='100'),
  msg?: string(name='Msg', example='SUCCESS'),
  requestId?: string(name='RequestId', description='Id of the request', example='11E66B29-9E5E-5C10-B64E-B5A0E0F26355'),
  success?: boolean(name='Success', example='true'),
}

model DeleteTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteTemplateResponseBody(name='body'),
}

/**
 * @summary 删除模版
 *
 * @param request DeleteTemplateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteTemplateResponse
 */
@context("deleteTemplateWithContext")
async function deleteTemplateWithOptions(request: DeleteTemplateRequest, runtime: $RuntimeOptions): DeleteTemplateResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.templateId)) {
    body['TemplateId'] = request.templateId;
  }
  if (!$isNull(request.templateName)) {
    body['TemplateName'] = request.templateName;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteTemplate',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 删除模版
 *
 * @param request DeleteTemplateRequest
 * @return DeleteTemplateResponse
 */
async function deleteTemplate(request: DeleteTemplateRequest): DeleteTemplateResponse {
  var runtime = new $RuntimeOptions{};
  return deleteTemplateWithOptions(request, runtime);
}

model ExistMcubeRsaKeyRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model ExistMcubeRsaKeyResponseBody = {
  checkRsaKeyResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='CheckRsaKeyResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ExistMcubeRsaKeyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ExistMcubeRsaKeyResponseBody(name='body'),
}

/**
 * @param request ExistMcubeRsaKeyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ExistMcubeRsaKeyResponse
 */
@context("existMcubeRsaKeyWithContext")
async function existMcubeRsaKeyWithOptions(request: ExistMcubeRsaKeyRequest, runtime: $RuntimeOptions): ExistMcubeRsaKeyResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ExistMcubeRsaKey',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ExistMcubeRsaKeyRequest
 * @return ExistMcubeRsaKeyResponse
 */
async function existMcubeRsaKey(request: ExistMcubeRsaKeyRequest): ExistMcubeRsaKeyResponse {
  var runtime = new $RuntimeOptions{};
  return existMcubeRsaKeyWithOptions(request, runtime);
}

model GetMcubeFileTokenRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  onexFlag?: boolean(name='OnexFlag', description='This parameter is required.'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model GetMcubeFileTokenResponseBody = {
  getFileTokenResult?: {
    fileToken?: {
      accessid?: string(name='Accessid'),
      dir?: string(name='Dir'),
      expire?: string(name='Expire'),
      host?: string(name='Host'),
      policy?: string(name='Policy'),
      signature?: string(name='Signature'),
    }(name='FileToken'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='GetFileTokenResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model GetMcubeFileTokenResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMcubeFileTokenResponseBody(name='body'),
}

/**
 * @param request GetMcubeFileTokenRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMcubeFileTokenResponse
 */
@context("getMcubeFileTokenWithContext")
async function getMcubeFileTokenWithOptions(request: GetMcubeFileTokenRequest, runtime: $RuntimeOptions): GetMcubeFileTokenResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.onexFlag)) {
    body['OnexFlag'] = request.onexFlag;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetMcubeFileToken',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetMcubeFileTokenRequest
 * @return GetMcubeFileTokenResponse
 */
async function getMcubeFileToken(request: GetMcubeFileTokenRequest): GetMcubeFileTokenResponse {
  var runtime = new $RuntimeOptions{};
  return getMcubeFileTokenWithOptions(request, runtime);
}

model GetMcubeNebulaResourceRequest {
  appId?: string(name='AppId'),
  id?: string(name='Id'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model GetMcubeNebulaResourceResponseBody = {
  getNebulaResourceResult?: {
    errorCode?: string(name='ErrorCode'),
    nebulaResourceInfo?: {
      appCode?: string(name='AppCode'),
      autoInstall?: int32(name='AutoInstall'),
      clientVersionMax?: string(name='ClientVersionMax'),
      clientVersionMin?: string(name='ClientVersionMin'),
      creator?: string(name='Creator'),
      downloadUrl?: string(name='DownloadUrl'),
      extendInfo?: string(name='ExtendInfo'),
      extraData?: string(name='ExtraData'),
      fallbackBaseUrl?: string(name='FallbackBaseUrl'),
      fileSize?: string(name='FileSize'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      h5Id?: string(name='H5Id'),
      h5Name?: string(name='H5Name'),
      h5Version?: string(name='H5Version'),
      id?: long(name='Id'),
      installType?: int32(name='InstallType'),
      mainUrl?: string(name='MainUrl'),
      memo?: string(name='Memo'),
      metaId?: long(name='MetaId'),
      modifier?: string(name='Modifier'),
      packageType?: int32(name='PackageType'),
      platform?: string(name='Platform'),
      publishPeriod?: int32(name='PublishPeriod'),
      resourceType?: string(name='ResourceType'),
      status?: int32(name='Status'),
      vhost?: string(name='Vhost'),
    }(name='NebulaResourceInfo'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='GetNebulaResourceResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model GetMcubeNebulaResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMcubeNebulaResourceResponseBody(name='body'),
}

/**
 * @param request GetMcubeNebulaResourceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMcubeNebulaResourceResponse
 */
@context("getMcubeNebulaResourceWithContext")
async function getMcubeNebulaResourceWithOptions(request: GetMcubeNebulaResourceRequest, runtime: $RuntimeOptions): GetMcubeNebulaResourceResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.id)) {
    body['Id'] = request.id;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetMcubeNebulaResource',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetMcubeNebulaResourceRequest
 * @return GetMcubeNebulaResourceResponse
 */
async function getMcubeNebulaResource(request: GetMcubeNebulaResourceRequest): GetMcubeNebulaResourceResponse {
  var runtime = new $RuntimeOptions{};
  return getMcubeNebulaResourceWithOptions(request, runtime);
}

model GetMcubeNebulaTaskDetailRequest {
  appId?: string(name='AppId'),
  taskId?: long(name='TaskId'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model GetMcubeNebulaTaskDetailResponseBody = {
  getMcubeNebulaTaskDetailResult?: {
    errorCode?: string(name='ErrorCode'),
    nebulaTaskDetail?: {
      appCode?: string(name='AppCode'),
      appId?: string(name='AppId'),
      atomic?: int32(name='Atomic'),
      baseInfoId?: long(name='BaseInfoId'),
      bizType?: string(name='BizType'),
      creator?: string(name='Creator'),
      cronexpress?: int32(name='Cronexpress'),
      downloadUrl?: string(name='DownloadUrl'),
      extraData?: string(name='ExtraData'),
      fileSize?: string(name='FileSize'),
      fullRepair?: int32(name='FullRepair'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      gmtModifiedStr?: string(name='GmtModifiedStr'),
      greyConfigInfo?: string(name='GreyConfigInfo'),
      greyEndtime?: string(name='GreyEndtime'),
      greyEndtimeData?: string(name='GreyEndtimeData'),
      greyEndtimeStr?: string(name='GreyEndtimeStr'),
      greyNum?: int32(name='GreyNum'),
      greyUrl?: string(name='GreyUrl'),
      id?: long(name='Id'),
      issueDesc?: string(name='IssueDesc'),
      memo?: string(name='Memo'),
      modifier?: string(name='Modifier'),
      ossPath?: string(name='OssPath'),
      packageId?: long(name='PackageId'),
      percent?: int32(name='Percent'),
      platform?: string(name='Platform'),
      productId?: string(name='ProductId'),
      productVersion?: string(name='ProductVersion'),
      publishMode?: int32(name='PublishMode'),
      publishPeriod?: int32(name='PublishPeriod'),
      publishType?: int32(name='PublishType'),
      quickRollback?: int32(name='QuickRollback'),
      releaseVersion?: string(name='ReleaseVersion'),
      ruleJsonList?: [ 
        {
          operation?: string(name='Operation'),
          ruleElement?: string(name='RuleElement'),
          ruleType?: string(name='RuleType'),
          value?: string(name='Value'),
        }
      ](name='RuleJsonList'),
      sourceId?: string(name='SourceId'),
      sourceName?: string(name='SourceName'),
      sourceType?: string(name='SourceType'),
      status?: int32(name='Status'),
      syncResult?: string(name='SyncResult'),
      syncType?: int32(name='SyncType'),
      taskName?: string(name='TaskName'),
      taskStatus?: int32(name='TaskStatus'),
      taskType?: int32(name='TaskType'),
      taskVersion?: long(name='TaskVersion'),
      upgradeNoticeNum?: long(name='UpgradeNoticeNum'),
      upgradeProgress?: string(name='UpgradeProgress'),
      whitelistIds?: string(name='WhitelistIds'),
      workspaceId?: string(name='WorkspaceId'),
    }(name='NebulaTaskDetail'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='GetMcubeNebulaTaskDetailResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model GetMcubeNebulaTaskDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMcubeNebulaTaskDetailResponseBody(name='body'),
}

/**
 * @param request GetMcubeNebulaTaskDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMcubeNebulaTaskDetailResponse
 */
@context("getMcubeNebulaTaskDetailWithContext")
async function getMcubeNebulaTaskDetailWithOptions(request: GetMcubeNebulaTaskDetailRequest, runtime: $RuntimeOptions): GetMcubeNebulaTaskDetailResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetMcubeNebulaTaskDetail',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetMcubeNebulaTaskDetailRequest
 * @return GetMcubeNebulaTaskDetailResponse
 */
async function getMcubeNebulaTaskDetail(request: GetMcubeNebulaTaskDetailRequest): GetMcubeNebulaTaskDetailResponse {
  var runtime = new $RuntimeOptions{};
  return getMcubeNebulaTaskDetailWithOptions(request, runtime);
}

model GetMcubeUpgradePackageInfoRequest {
  appId?: string(name='AppId'),
  packageId?: long(name='PackageId'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model GetMcubeUpgradePackageInfoResponseBody = {
  getPackageResult?: {
    errorCode?: string(name='ErrorCode'),
    packageInfo?: {
      mobileTestFlightConfigDO?: {
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        id?: long(name='Id'),
        installAmount?: int32(name='InstallAmount'),
        invalidTime?: string(name='InvalidTime'),
        upgradeId?: long(name='UpgradeId'),
      }(name='MobileTestFlightConfigDO'),
      upgradeBaseInfoDO?: {
        allowCreateTask?: boolean(name='AllowCreateTask'),
        appCode?: string(name='AppCode'),
        appstoreUrl?: string(name='AppstoreUrl'),
        changeLog?: string(name='ChangeLog'),
        creator?: string(name='Creator'),
        downloadUrl?: string(name='DownloadUrl'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        id?: long(name='Id'),
        isEnterprise?: int32(name='IsEnterprise'),
        modifier?: string(name='Modifier'),
        needCheck?: int32(name='NeedCheck'),
        packageType?: string(name='PackageType'),
        platform?: string(name='Platform'),
        productId?: string(name='ProductId'),
        productName?: string(name='ProductName'),
        productVersion?: string(name='ProductVersion'),
        publishPeriod?: int32(name='PublishPeriod'),
        verificationCode?: string(name='VerificationCode'),
      }(name='UpgradeBaseInfoDO'),
    }(name='PackageInfo'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='GetPackageResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model GetMcubeUpgradePackageInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMcubeUpgradePackageInfoResponseBody(name='body'),
}

/**
 * @param request GetMcubeUpgradePackageInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMcubeUpgradePackageInfoResponse
 */
@context("getMcubeUpgradePackageInfoWithContext")
async function getMcubeUpgradePackageInfoWithOptions(request: GetMcubeUpgradePackageInfoRequest, runtime: $RuntimeOptions): GetMcubeUpgradePackageInfoResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.packageId)) {
    body['PackageId'] = request.packageId;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetMcubeUpgradePackageInfo',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetMcubeUpgradePackageInfoRequest
 * @return GetMcubeUpgradePackageInfoResponse
 */
async function getMcubeUpgradePackageInfo(request: GetMcubeUpgradePackageInfoRequest): GetMcubeUpgradePackageInfoResponse {
  var runtime = new $RuntimeOptions{};
  return getMcubeUpgradePackageInfoWithOptions(request, runtime);
}

model GetMcubeUpgradeTaskInfoRequest {
  appId?: string(name='AppId'),
  taskId?: long(name='TaskId'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model GetMcubeUpgradeTaskInfoResponseBody = {
  getTaskResult?: {
    errorCode?: string(name='ErrorCode'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
    taskInfo?: {
      appCode?: string(name='AppCode'),
      appId?: string(name='AppId'),
      appstoreUrl?: string(name='AppstoreUrl'),
      creator?: string(name='Creator'),
      downloadUrl?: string(name='DownloadUrl'),
      greyConfigInfo?: string(name='GreyConfigInfo'),
      greyEndtimeData?: string(name='GreyEndtimeData'),
      greyNum?: int32(name='GreyNum'),
      historyForce?: int32(name='HistoryForce'),
      id?: long(name='Id'),
      isEnterprise?: int32(name='IsEnterprise'),
      memo?: string(name='Memo'),
      modifier?: string(name='Modifier'),
      packageInfoId?: long(name='PackageInfoId'),
      packageType?: string(name='PackageType'),
      platform?: string(name='Platform'),
      productId?: string(name='ProductId'),
      publishMode?: int32(name='PublishMode'),
      publishType?: int32(name='PublishType'),
      ruleJsonList?: [ 
        {
          operation?: string(name='Operation'),
          ruleElement?: string(name='RuleElement'),
          ruleType?: string(name='RuleType'),
          value?: string(name='Value'),
        }
      ](name='RuleJsonList'),
      silentType?: int32(name='SilentType'),
      taskStatus?: int32(name='TaskStatus'),
      upgradeContent?: string(name='UpgradeContent'),
      upgradeType?: int32(name='UpgradeType'),
      upgradeValidTime?: int32(name='UpgradeValidTime'),
      whitelist?: [ 
        {
          appCode?: string(name='AppCode'),
          id?: long(name='Id'),
          idType?: string(name='IdType'),
          platform?: string(name='Platform'),
          status?: int32(name='Status'),
          userType?: string(name='UserType'),
          whiteListCount?: long(name='WhiteListCount'),
          whiteListName?: string(name='WhiteListName'),
          whitelistType?: string(name='WhitelistType'),
        }
      ](name='Whitelist'),
      whitelistIds?: string(name='WhitelistIds'),
      workspaceId?: string(name='WorkspaceId'),
    }(name='TaskInfo'),
  }(name='GetTaskResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model GetMcubeUpgradeTaskInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMcubeUpgradeTaskInfoResponseBody(name='body'),
}

/**
 * @param request GetMcubeUpgradeTaskInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMcubeUpgradeTaskInfoResponse
 */
@context("getMcubeUpgradeTaskInfoWithContext")
async function getMcubeUpgradeTaskInfoWithOptions(request: GetMcubeUpgradeTaskInfoRequest, runtime: $RuntimeOptions): GetMcubeUpgradeTaskInfoResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetMcubeUpgradeTaskInfo',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetMcubeUpgradeTaskInfoRequest
 * @return GetMcubeUpgradeTaskInfoResponse
 */
async function getMcubeUpgradeTaskInfo(request: GetMcubeUpgradeTaskInfoRequest): GetMcubeUpgradeTaskInfoResponse {
  var runtime = new $RuntimeOptions{};
  return getMcubeUpgradeTaskInfoWithOptions(request, runtime);
}

model GetTemplateRequest {
  appId?: string(name='AppId', example='ALIPUBE5C3F6D091419'),
  templateId?: string(name='TemplateId', example='146552'),
  templateName?: string(name='TemplateName'),
  tenantId?: string(name='TenantId', example='CGAKLRCS'),
  workspaceId?: string(name='WorkspaceId', example='default'),
}

model GetTemplateResponseBody = {
  code?: string(name='Code', example='100'),
  data?: {
    action?: string(name='Action', example='1'),
    content?: string(name='Content'),
    descInfo?: string(name='DescInfo'),
    gmtCreate?: string(name='GmtCreate', example='1740479834'),
    gmtModified?: string(name='GmtModified', example='1745337419999'),
    iconUrls?: string(name='IconUrls', example='/'),
    id?: string(name='Id', example='123'),
    imageUrls?: string(name='ImageUrls', example='/'),
    name?: string(name='Name'),
    pushStyle?: string(name='PushStyle', example='0'),
    showStyle?: string(name='ShowStyle', example='0'),
    title?: string(name='Title'),
    uri?: string(name='Uri', example='/'),
    variables?: string(name='Variables', example='title,content'),
  }(name='Data'),
  msg?: string(name='Msg', example='success'),
  requestId?: string(name='RequestId', description='Id of the request', example='11E66B29-9E5E-5C10-B64E-B5A0E0F26355'),
  success?: boolean(name='Success', example='true'),
}

model GetTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetTemplateResponseBody(name='body'),
}

/**
 * @summary 获取模版
 *
 * @param request GetTemplateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetTemplateResponse
 */
@context("getTemplateWithContext")
async function getTemplateWithOptions(request: GetTemplateRequest, runtime: $RuntimeOptions): GetTemplateResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.templateId)) {
    body['TemplateId'] = request.templateId;
  }
  if (!$isNull(request.templateName)) {
    body['TemplateName'] = request.templateName;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetTemplate',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取模版
 *
 * @param request GetTemplateRequest
 * @return GetTemplateResponse
 */
async function getTemplate(request: GetTemplateRequest): GetTemplateResponse {
  var runtime = new $RuntimeOptions{};
  return getTemplateWithOptions(request, runtime);
}

model ListAnalysisCoreIndexRequest {
  appId?: string(name='AppId', example='ALIPUBE5C3F6D091419'),
  channel?: string(name='Channel', example='miui'),
  endTime?: long(name='EndTime', example='1756051200000'),
  platform?: string(name='Platform', example='Android'),
  startTime?: long(name='StartTime', example='1756051200000'),
  taskId?: string(name='TaskId', example='546797740032'),
  tenantId?: string(name='TenantId', example='CGAKLRCS'),
  type?: string(name='Type', example='2'),
  workspaceId?: string(name='WorkspaceId', example='dev'),
}

model ListAnalysisCoreIndexResponseBody = {
  requestId?: string(name='RequestId', example='11E66B29-9E5E-5C10-B64E-B5A0E0F26355'),
  resultCode?: string(name='ResultCode', example='100'),
  resultContent?: {
    data?: {
      arrivalNum?: string(name='ArrivalNum', example='0'),
      arrivalRate?: string(name='ArrivalRate', example='0'),
      ignoreNum?: string(name='IgnoreNum', example='0'),
      ignoreRate?: string(name='IgnoreRate', example='0'),
      openNum?: string(name='OpenNum', example='0'),
      openRate?: string(name='OpenRate', example='0'),
      pushNum?: string(name='PushNum', example='0'),
      pushTotalNum?: string(name='PushTotalNum', example='0'),
    }(name='Data'),
    resultMsg?: string(name='ResultMsg', example='“”'),
    success?: boolean(name='Success', example='true'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage', example='success'),
  success?: boolean(name='Success', example='true'),
}

model ListAnalysisCoreIndexResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAnalysisCoreIndexResponseBody(name='body'),
}

/**
 * @summary 查询报表
 *
 * @param request ListAnalysisCoreIndexRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAnalysisCoreIndexResponse
 */
@context("listAnalysisCoreIndexWithContext")
async function listAnalysisCoreIndexWithOptions(request: ListAnalysisCoreIndexRequest, runtime: $RuntimeOptions): ListAnalysisCoreIndexResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.channel)) {
    body['Channel'] = request.channel;
  }
  if (!$isNull(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!$isNull(request.platform)) {
    body['Platform'] = request.platform;
  }
  if (!$isNull(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  if (!$isNull(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.type)) {
    body['Type'] = request.type;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListAnalysisCoreIndex',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询报表
 *
 * @param request ListAnalysisCoreIndexRequest
 * @return ListAnalysisCoreIndexResponse
 */
async function listAnalysisCoreIndex(request: ListAnalysisCoreIndexRequest): ListAnalysisCoreIndexResponse {
  var runtime = new $RuntimeOptions{};
  return listAnalysisCoreIndexWithOptions(request, runtime);
}

model ListMcubeMiniAppsRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  keyword?: string(name='Keyword'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model ListMcubeMiniAppsResponseBody = {
  listMiniResult?: {
    currentPage?: int32(name='CurrentPage'),
    hasMore?: boolean(name='HasMore'),
    miniProgramList?: [ 
      {
        appCode?: string(name='AppCode'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        h5Id?: string(name='H5Id'),
        h5Name?: string(name='H5Name'),
      }
    ](name='MiniProgramList'),
    pageSize?: int32(name='PageSize'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
    totalCount?: long(name='TotalCount'),
  }(name='ListMiniResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMcubeMiniAppsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMcubeMiniAppsResponseBody(name='body'),
}

/**
 * @param request ListMcubeMiniAppsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListMcubeMiniAppsResponse
 */
@context("listMcubeMiniAppsWithContext")
async function listMcubeMiniAppsWithOptions(request: ListMcubeMiniAppsRequest, runtime: $RuntimeOptions): ListMcubeMiniAppsResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.keyword)) {
    body['Keyword'] = request.keyword;
  }
  if (!$isNull(request.pageNum)) {
    body['PageNum'] = request.pageNum;
  }
  if (!$isNull(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListMcubeMiniApps',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListMcubeMiniAppsRequest
 * @return ListMcubeMiniAppsResponse
 */
async function listMcubeMiniApps(request: ListMcubeMiniAppsRequest): ListMcubeMiniAppsResponse {
  var runtime = new $RuntimeOptions{};
  return listMcubeMiniAppsWithOptions(request, runtime);
}

model ListMcubeMiniPackagesRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  h5Id?: string(name='H5Id', description='This parameter is required.'),
  packageTypes?: string(name='PackageTypes', description='This parameter is required.'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model ListMcubeMiniPackagesResponseBody = {
  listMiniPackageResult?: {
    currentPage?: int32(name='CurrentPage'),
    hasMore?: boolean(name='HasMore'),
    miniPackageList?: [ 
      {
        appCode?: string(name='AppCode'),
        autoInstall?: long(name='AutoInstall'),
        clientVersionMax?: string(name='ClientVersionMax'),
        clientVersionMin?: string(name='ClientVersionMin'),
        downloadUrl?: string(name='DownloadUrl'),
        extendInfo?: string(name='ExtendInfo'),
        extraData?: string(name='ExtraData'),
        fallbackBaseUrl?: string(name='FallbackBaseUrl'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        h5Id?: string(name='H5Id'),
        h5Name?: string(name='H5Name'),
        h5Version?: string(name='H5Version'),
        id?: long(name='Id'),
        installType?: long(name='InstallType'),
        mainUrl?: string(name='MainUrl'),
        memo?: string(name='Memo'),
        packageType?: long(name='PackageType'),
        platform?: string(name='Platform'),
        publishPeriod?: long(name='PublishPeriod'),
        resourceType?: long(name='ResourceType'),
        status?: long(name='Status'),
      }
    ](name='MiniPackageList'),
    pageSize?: int32(name='PageSize'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
    totalCount?: long(name='TotalCount'),
  }(name='ListMiniPackageResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMcubeMiniPackagesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMcubeMiniPackagesResponseBody(name='body'),
}

/**
 * @param request ListMcubeMiniPackagesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListMcubeMiniPackagesResponse
 */
@context("listMcubeMiniPackagesWithContext")
async function listMcubeMiniPackagesWithOptions(request: ListMcubeMiniPackagesRequest, runtime: $RuntimeOptions): ListMcubeMiniPackagesResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.h5Id)) {
    body['H5Id'] = request.h5Id;
  }
  if (!$isNull(request.packageTypes)) {
    body['PackageTypes'] = request.packageTypes;
  }
  if (!$isNull(request.pageNum)) {
    body['PageNum'] = request.pageNum;
  }
  if (!$isNull(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListMcubeMiniPackages',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListMcubeMiniPackagesRequest
 * @return ListMcubeMiniPackagesResponse
 */
async function listMcubeMiniPackages(request: ListMcubeMiniPackagesRequest): ListMcubeMiniPackagesResponse {
  var runtime = new $RuntimeOptions{};
  return listMcubeMiniPackagesWithOptions(request, runtime);
}

model ListMcubeMiniTasksRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  id?: string(name='Id', description='This parameter is required.'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model ListMcubeMiniTasksResponseBody = {
  listMiniTaskResult?: {
    miniTaskList?: [ 
      {
        appCode?: string(name='AppCode'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        greyConfigInfo?: string(name='GreyConfigInfo'),
        greyEndtime?: string(name='GreyEndtime'),
        greyEndtimeData?: string(name='GreyEndtimeData'),
        greyNum?: long(name='GreyNum'),
        id?: long(name='Id'),
        memo?: string(name='Memo'),
        packageId?: long(name='PackageId'),
        platform?: string(name='Platform'),
        productVersion?: string(name='ProductVersion'),
        publishMode?: long(name='PublishMode'),
        publishType?: long(name='PublishType'),
        status?: string(name='Status'),
        taskStatus?: long(name='TaskStatus'),
        whitelistIds?: string(name='WhitelistIds'),
      }
    ](name='MiniTaskList'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='ListMiniTaskResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMcubeMiniTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMcubeMiniTasksResponseBody(name='body'),
}

/**
 * @param request ListMcubeMiniTasksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListMcubeMiniTasksResponse
 */
@context("listMcubeMiniTasksWithContext")
async function listMcubeMiniTasksWithOptions(request: ListMcubeMiniTasksRequest, runtime: $RuntimeOptions): ListMcubeMiniTasksResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.id)) {
    body['Id'] = request.id;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListMcubeMiniTasks',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListMcubeMiniTasksRequest
 * @return ListMcubeMiniTasksResponse
 */
async function listMcubeMiniTasks(request: ListMcubeMiniTasksRequest): ListMcubeMiniTasksResponse {
  var runtime = new $RuntimeOptions{};
  return listMcubeMiniTasksWithOptions(request, runtime);
}

model ListMcubeNebulaAppsRequest {
  appId?: string(name='AppId'),
  keyword?: string(name='Keyword'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model ListMcubeNebulaAppsResponseBody = {
  listMcubeNebulaAppsResult?: {
    currentPage?: int32(name='CurrentPage'),
    errorCode?: string(name='ErrorCode'),
    hasMore?: boolean(name='HasMore'),
    nebulaAppInfos?: [ 
      {
        h5Id?: string(name='H5Id'),
        h5Name?: string(name='H5Name'),
      }
    ](name='NebulaAppInfos'),
    pageSize?: int32(name='PageSize'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
    totalCount?: long(name='TotalCount'),
  }(name='ListMcubeNebulaAppsResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMcubeNebulaAppsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMcubeNebulaAppsResponseBody(name='body'),
}

/**
 * @param request ListMcubeNebulaAppsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListMcubeNebulaAppsResponse
 */
@context("listMcubeNebulaAppsWithContext")
async function listMcubeNebulaAppsWithOptions(request: ListMcubeNebulaAppsRequest, runtime: $RuntimeOptions): ListMcubeNebulaAppsResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.keyword)) {
    body['Keyword'] = request.keyword;
  }
  if (!$isNull(request.pageNum)) {
    body['PageNum'] = request.pageNum;
  }
  if (!$isNull(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListMcubeNebulaApps',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListMcubeNebulaAppsRequest
 * @return ListMcubeNebulaAppsResponse
 */
async function listMcubeNebulaApps(request: ListMcubeNebulaAppsRequest): ListMcubeNebulaAppsResponse {
  var runtime = new $RuntimeOptions{};
  return listMcubeNebulaAppsWithOptions(request, runtime);
}

model ListMcubeNebulaResourcesRequest {
  appId?: string(name='AppId'),
  h5Id?: string(name='H5Id'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model ListMcubeNebulaResourcesResponseBody = {
  listMcubeNebulaResourceResult?: {
    currentPage?: int32(name='CurrentPage'),
    errorCode?: string(name='ErrorCode'),
    hasMore?: boolean(name='HasMore'),
    nebulaResourceInfo?: [ 
      {
        appCode?: string(name='AppCode'),
        autoInstall?: int32(name='AutoInstall'),
        clientVersionMax?: string(name='ClientVersionMax'),
        clientVersionMin?: string(name='ClientVersionMin'),
        creator?: string(name='Creator'),
        debugUrl?: string(name='DebugUrl'),
        downloadUrl?: string(name='DownloadUrl'),
        extendInfo?: string(name='ExtendInfo'),
        extraData?: string(name='ExtraData'),
        fallbackBaseUrl?: string(name='FallbackBaseUrl'),
        fileSize?: string(name='FileSize'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        h5Id?: string(name='H5Id'),
        h5Name?: string(name='H5Name'),
        h5Version?: string(name='H5Version'),
        id?: long(name='Id'),
        installType?: int32(name='InstallType'),
        lazyLoad?: int32(name='LazyLoad'),
        mainUrl?: string(name='MainUrl'),
        md5?: string(name='Md5'),
        memo?: string(name='Memo'),
        metaId?: long(name='MetaId'),
        modifier?: string(name='Modifier'),
        packageType?: int32(name='PackageType'),
        platform?: string(name='Platform'),
        publishPeriod?: int32(name='PublishPeriod'),
        releaseVersion?: string(name='ReleaseVersion'),
        resourceType?: string(name='ResourceType'),
        status?: int32(name='Status'),
        vhost?: string(name='Vhost'),
      }
    ](name='NebulaResourceInfo'),
    pageSize?: int32(name='PageSize'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
    totalCount?: long(name='TotalCount'),
  }(name='ListMcubeNebulaResourceResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMcubeNebulaResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMcubeNebulaResourcesResponseBody(name='body'),
}

/**
 * @param request ListMcubeNebulaResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListMcubeNebulaResourcesResponse
 */
@context("listMcubeNebulaResourcesWithContext")
async function listMcubeNebulaResourcesWithOptions(request: ListMcubeNebulaResourcesRequest, runtime: $RuntimeOptions): ListMcubeNebulaResourcesResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.h5Id)) {
    body['H5Id'] = request.h5Id;
  }
  if (!$isNull(request.pageNum)) {
    body['PageNum'] = request.pageNum;
  }
  if (!$isNull(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListMcubeNebulaResources',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListMcubeNebulaResourcesRequest
 * @return ListMcubeNebulaResourcesResponse
 */
async function listMcubeNebulaResources(request: ListMcubeNebulaResourcesRequest): ListMcubeNebulaResourcesResponse {
  var runtime = new $RuntimeOptions{};
  return listMcubeNebulaResourcesWithOptions(request, runtime);
}

model ListMcubeNebulaTasksRequest {
  appId?: string(name='AppId'),
  id?: long(name='Id'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model ListMcubeNebulaTasksResponseBody = {
  listMcubeNebulaTaskResult?: {
    errorCode?: string(name='ErrorCode'),
    nebulaTaskInfo?: [ 
      {
        appCode?: string(name='AppCode'),
        bizType?: string(name='BizType'),
        creator?: string(name='Creator'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        gmtModifiedStr?: string(name='GmtModifiedStr'),
        greyConfigInfo?: string(name='GreyConfigInfo'),
        greyEndtime?: string(name='GreyEndtime'),
        greyEndtimeData?: string(name='GreyEndtimeData'),
        greyEndtimeStr?: string(name='GreyEndtimeStr'),
        greyNum?: int32(name='GreyNum'),
        greyUrl?: string(name='GreyUrl'),
        id?: long(name='Id'),
        memo?: string(name='Memo'),
        modifier?: string(name='Modifier'),
        packageId?: long(name='PackageId'),
        percent?: int32(name='Percent'),
        platform?: string(name='Platform'),
        productId?: string(name='ProductId'),
        productVersion?: string(name='ProductVersion'),
        publishMode?: int32(name='PublishMode'),
        publishType?: int32(name='PublishType'),
        releaseVersion?: string(name='ReleaseVersion'),
        status?: int32(name='Status'),
        syncResult?: string(name='SyncResult'),
        taskName?: string(name='TaskName'),
        taskStatus?: int32(name='TaskStatus'),
        taskType?: int32(name='TaskType'),
        taskVersion?: long(name='TaskVersion'),
        upgradeNoticeNum?: long(name='UpgradeNoticeNum'),
        upgradeProgress?: string(name='UpgradeProgress'),
        whitelistIds?: string(name='WhitelistIds'),
      }
    ](name='NebulaTaskInfo'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='ListMcubeNebulaTaskResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMcubeNebulaTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMcubeNebulaTasksResponseBody(name='body'),
}

/**
 * @param request ListMcubeNebulaTasksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListMcubeNebulaTasksResponse
 */
@context("listMcubeNebulaTasksWithContext")
async function listMcubeNebulaTasksWithOptions(request: ListMcubeNebulaTasksRequest, runtime: $RuntimeOptions): ListMcubeNebulaTasksResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.id)) {
    body['Id'] = request.id;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListMcubeNebulaTasks',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListMcubeNebulaTasksRequest
 * @return ListMcubeNebulaTasksResponse
 */
async function listMcubeNebulaTasks(request: ListMcubeNebulaTasksRequest): ListMcubeNebulaTasksResponse {
  var runtime = new $RuntimeOptions{};
  return listMcubeNebulaTasksWithOptions(request, runtime);
}

model ListMcubeUpgradePackagesRequest {
  appId?: string(name='AppId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model ListMcubeUpgradePackagesResponseBody = {
  currentPage?: int32(name='CurrentPage'),
  hasMore?: boolean(name='HasMore'),
  listPackagesResult?: {
    errorCode?: string(name='ErrorCode'),
    packages?: [ 
      {
        allowCreateTask?: boolean(name='AllowCreateTask'),
        appCode?: string(name='AppCode'),
        appstoreUrl?: string(name='AppstoreUrl'),
        changeLog?: string(name='ChangeLog'),
        creator?: string(name='Creator'),
        downloadUrl?: string(name='DownloadUrl'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        id?: long(name='Id'),
        isEnterprise?: int32(name='IsEnterprise'),
        md5?: string(name='Md5'),
        modifier?: string(name='Modifier'),
        needCheck?: int32(name='NeedCheck'),
        packageType?: string(name='PackageType'),
        platform?: string(name='Platform'),
        productId?: string(name='ProductId'),
        productVersion?: string(name='ProductVersion'),
        publishPeriod?: int32(name='PublishPeriod'),
        verificationCode?: string(name='VerificationCode'),
      }
    ](name='Packages'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='ListPackagesResult'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
  totalCount?: long(name='TotalCount'),
}

model ListMcubeUpgradePackagesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMcubeUpgradePackagesResponseBody(name='body'),
}

/**
 * @param request ListMcubeUpgradePackagesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListMcubeUpgradePackagesResponse
 */
@context("listMcubeUpgradePackagesWithContext")
async function listMcubeUpgradePackagesWithOptions(request: ListMcubeUpgradePackagesRequest, runtime: $RuntimeOptions): ListMcubeUpgradePackagesResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.pageNum)) {
    body['PageNum'] = request.pageNum;
  }
  if (!$isNull(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListMcubeUpgradePackages',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListMcubeUpgradePackagesRequest
 * @return ListMcubeUpgradePackagesResponse
 */
async function listMcubeUpgradePackages(request: ListMcubeUpgradePackagesRequest): ListMcubeUpgradePackagesResponse {
  var runtime = new $RuntimeOptions{};
  return listMcubeUpgradePackagesWithOptions(request, runtime);
}

model ListMcubeUpgradeTasksRequest {
  appId?: string(name='AppId'),
  packageId?: string(name='PackageId'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model ListMcubeUpgradeTasksResponseBody = {
  listTaskResult?: {
    errorCode?: string(name='ErrorCode'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
    taskInfo?: [ 
      {
        appCode?: string(name='AppCode'),
        creator?: string(name='Creator'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        greyConfigInfo?: string(name='GreyConfigInfo'),
        greyEndtime?: string(name='GreyEndtime'),
        greyNum?: int32(name='GreyNum'),
        historyForce?: int32(name='HistoryForce'),
        id?: long(name='Id'),
        isEnterprise?: int32(name='IsEnterprise'),
        memo?: string(name='Memo'),
        modifier?: string(name='Modifier'),
        packageInfoId?: long(name='PackageInfoId'),
        platform?: string(name='Platform'),
        productId?: string(name='ProductId'),
        productVersion?: string(name='ProductVersion'),
        publishMode?: int32(name='PublishMode'),
        publishType?: int32(name='PublishType'),
        pushContent?: string(name='PushContent'),
        taskStatus?: int32(name='TaskStatus'),
        upgradeContent?: string(name='UpgradeContent'),
        upgradeType?: int32(name='UpgradeType'),
        whitelistIds?: string(name='WhitelistIds'),
      }
    ](name='TaskInfo'),
  }(name='ListTaskResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMcubeUpgradeTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMcubeUpgradeTasksResponseBody(name='body'),
}

/**
 * @param request ListMcubeUpgradeTasksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListMcubeUpgradeTasksResponse
 */
@context("listMcubeUpgradeTasksWithContext")
async function listMcubeUpgradeTasksWithOptions(request: ListMcubeUpgradeTasksRequest, runtime: $RuntimeOptions): ListMcubeUpgradeTasksResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.packageId)) {
    body['PackageId'] = request.packageId;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListMcubeUpgradeTasks',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListMcubeUpgradeTasksRequest
 * @return ListMcubeUpgradeTasksResponse
 */
async function listMcubeUpgradeTasks(request: ListMcubeUpgradeTasksRequest): ListMcubeUpgradeTasksResponse {
  var runtime = new $RuntimeOptions{};
  return listMcubeUpgradeTasksWithOptions(request, runtime);
}

model ListMcubeWhitelistsRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
  whitelistName?: string(name='WhitelistName'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model ListMcubeWhitelistsResponseBody = {
  listWhitelistResult?: {
    currentPage?: int32(name='CurrentPage'),
    hasMore?: boolean(name='HasMore'),
    pageSize?: int32(name='PageSize'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
    totalCount?: long(name='TotalCount'),
    whitelists?: [ 
      {
        appCode?: string(name='AppCode'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        id?: long(name='Id'),
        whiteListCount?: long(name='WhiteListCount'),
        whiteListName?: string(name='WhiteListName'),
        whitelistType?: string(name='WhitelistType'),
      }
    ](name='Whitelists'),
  }(name='ListWhitelistResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMcubeWhitelistsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMcubeWhitelistsResponseBody(name='body'),
}

/**
 * @param request ListMcubeWhitelistsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListMcubeWhitelistsResponse
 */
@context("listMcubeWhitelistsWithContext")
async function listMcubeWhitelistsWithOptions(request: ListMcubeWhitelistsRequest, runtime: $RuntimeOptions): ListMcubeWhitelistsResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.pageNum)) {
    body['PageNum'] = request.pageNum;
  }
  if (!$isNull(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.whitelistName)) {
    body['WhitelistName'] = request.whitelistName;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListMcubeWhitelists',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListMcubeWhitelistsRequest
 * @return ListMcubeWhitelistsResponse
 */
async function listMcubeWhitelists(request: ListMcubeWhitelistsRequest): ListMcubeWhitelistsResponse {
  var runtime = new $RuntimeOptions{};
  return listMcubeWhitelistsWithOptions(request, runtime);
}

model ListTemplatePageRequest {
  appId?: string(name='AppId', example='ALIPUBC6E8EC1271137'),
  currentPage?: int32(name='CurrentPage', example='1'),
  pageSize?: int32(name='PageSize', example='10'),
  tenantId?: string(name='TenantId', example='CBIGWCFH'),
  workspaceId?: string(name='WorkspaceId', example='default'),
}

model ListTemplatePageResponseBody = {
  code?: string(name='Code', example='100'),
  currentPage?: int32(name='CurrentPage', example='1'),
  data?: [ 
    {
      action?: string(name='Action', example='1'),
      content?: string(name='Content'),
      descInfo?: string(name='DescInfo'),
      gmtCreate?: string(name='GmtCreate', example='1740479834'),
      gmtModified?: string(name='GmtModified', example='1722564835000'),
      iconUrls?: string(name='IconUrls', example='/'),
      id?: string(name='Id', example='10029984'),
      imageUrls?: string(name='ImageUrls', example='/'),
      name?: string(name='Name'),
      pushStyle?: string(name='PushStyle', example='0'),
      showStyle?: string(name='ShowStyle', example='0'),
      title?: string(name='Title'),
      uri?: string(name='Uri', example='/'),
      variables?: string(name='Variables', example='title,content'),
    }
  ](name='Data'),
  msg?: string(name='Msg', example='SUCCESS'),
  pageSize?: int32(name='PageSize', example='10'),
  requestId?: string(name='RequestId', description='Id of the request', example='11E66B29-9E5E-5C10-B64E-B5A0E0F26355'),
  success?: boolean(name='Success', example='true'),
  totalSize?: int32(name='TotalSize', example='20'),
}

model ListTemplatePageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTemplatePageResponseBody(name='body'),
}

/**
 * @summary 分页查询模版列表
 *
 * @param request ListTemplatePageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTemplatePageResponse
 */
@context("listTemplatePageWithContext")
async function listTemplatePageWithOptions(request: ListTemplatePageRequest, runtime: $RuntimeOptions): ListTemplatePageResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.currentPage)) {
    body['CurrentPage'] = request.currentPage;
  }
  if (!$isNull(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListTemplatePage',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 分页查询模版列表
 *
 * @param request ListTemplatePageRequest
 * @return ListTemplatePageResponse
 */
async function listTemplatePage(request: ListTemplatePageRequest): ListTemplatePageResponse {
  var runtime = new $RuntimeOptions{};
  return listTemplatePageWithOptions(request, runtime);
}

model PushBroadcastRequest {
  androidChannel?: long(name='AndroidChannel'),
  appId?: string(name='AppId', description='This parameter is required.'),
  bindEndTime?: long(name='BindEndTime'),
  bindStartTime?: long(name='BindStartTime'),
  channelId?: string(name='ChannelId'),
  classification?: string(name='Classification'),
  deliveryType?: long(name='DeliveryType', description='This parameter is required.'),
  expiredSeconds?: long(name='ExpiredSeconds', description='This parameter is required.'),
  extendedParams?: string(name='ExtendedParams'),
  miChannelId?: string(name='MiChannelId'),
  msgkey?: string(name='Msgkey', description='This parameter is required.'),
  notifyLevel?: map[string]any(name='NotifyLevel'),
  notifyType?: string(name='NotifyType'),
  pushAction?: long(name='PushAction'),
  pushStatus?: long(name='PushStatus'),
  silent?: long(name='Silent'),
  strategyContent?: string(name='StrategyContent'),
  strategyType?: int32(name='StrategyType'),
  taskName?: string(name='TaskName'),
  templateKeyValue?: string(name='TemplateKeyValue'),
  templateName?: string(name='TemplateName', description='This parameter is required.'),
  tenantId?: string(name='TenantId'),
  thirdChannelCategory?: map[string]any(name='ThirdChannelCategory'),
  timeMode?: int32(name='TimeMode'),
  transparentMessagePayload?: any(name='TransparentMessagePayload'),
  transparentMessageUrgency?: string(name='TransparentMessageUrgency'),
  unBindEndTime?: long(name='UnBindEndTime'),
  unBindPeriod?: long(name='UnBindPeriod'),
  unBindStartTime?: long(name='UnBindStartTime'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model PushBroadcastShrinkRequest {
  androidChannel?: long(name='AndroidChannel'),
  appId?: string(name='AppId', description='This parameter is required.'),
  bindEndTime?: long(name='BindEndTime'),
  bindStartTime?: long(name='BindStartTime'),
  channelId?: string(name='ChannelId'),
  classification?: string(name='Classification'),
  deliveryType?: long(name='DeliveryType', description='This parameter is required.'),
  expiredSeconds?: long(name='ExpiredSeconds', description='This parameter is required.'),
  extendedParams?: string(name='ExtendedParams'),
  miChannelId?: string(name='MiChannelId'),
  msgkey?: string(name='Msgkey', description='This parameter is required.'),
  notifyLevelShrink?: string(name='NotifyLevel'),
  notifyType?: string(name='NotifyType'),
  pushAction?: long(name='PushAction'),
  pushStatus?: long(name='PushStatus'),
  silent?: long(name='Silent'),
  strategyContent?: string(name='StrategyContent'),
  strategyType?: int32(name='StrategyType'),
  taskName?: string(name='TaskName'),
  templateKeyValue?: string(name='TemplateKeyValue'),
  templateName?: string(name='TemplateName', description='This parameter is required.'),
  tenantId?: string(name='TenantId'),
  thirdChannelCategoryShrink?: string(name='ThirdChannelCategory'),
  timeMode?: int32(name='TimeMode'),
  transparentMessagePayload?: any(name='TransparentMessagePayload'),
  transparentMessageUrgency?: string(name='TransparentMessageUrgency'),
  unBindEndTime?: long(name='UnBindEndTime'),
  unBindPeriod?: long(name='UnBindPeriod'),
  unBindStartTime?: long(name='UnBindStartTime'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model PushBroadcastResponseBody = {
  pushResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='PushResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model PushBroadcastResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PushBroadcastResponseBody(name='body'),
}

/**
 * @param tmpReq PushBroadcastRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PushBroadcastResponse
 */
@context("pushBroadcastWithContext")
async function pushBroadcastWithOptions(tmpReq: PushBroadcastRequest, runtime: $RuntimeOptions): PushBroadcastResponse {
  tmpReq.validate();
  var request = new PushBroadcastShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!$isNull(tmpReq.notifyLevel)) {
    request.notifyLevelShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.notifyLevel, 'NotifyLevel', 'json');
  }
  if (!$isNull(tmpReq.thirdChannelCategory)) {
    request.thirdChannelCategoryShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.thirdChannelCategory, 'ThirdChannelCategory', 'json');
  }
  var body : map[string]any = {};
  if (!$isNull(request.androidChannel)) {
    body['AndroidChannel'] = request.androidChannel;
  }
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.bindEndTime)) {
    body['BindEndTime'] = request.bindEndTime;
  }
  if (!$isNull(request.bindStartTime)) {
    body['BindStartTime'] = request.bindStartTime;
  }
  if (!$isNull(request.channelId)) {
    body['ChannelId'] = request.channelId;
  }
  if (!$isNull(request.classification)) {
    body['Classification'] = request.classification;
  }
  if (!$isNull(request.deliveryType)) {
    body['DeliveryType'] = request.deliveryType;
  }
  if (!$isNull(request.expiredSeconds)) {
    body['ExpiredSeconds'] = request.expiredSeconds;
  }
  if (!$isNull(request.extendedParams)) {
    body['ExtendedParams'] = request.extendedParams;
  }
  if (!$isNull(request.miChannelId)) {
    body['MiChannelId'] = request.miChannelId;
  }
  if (!$isNull(request.msgkey)) {
    body['Msgkey'] = request.msgkey;
  }
  if (!$isNull(request.notifyLevelShrink)) {
    body['NotifyLevel'] = request.notifyLevelShrink;
  }
  if (!$isNull(request.notifyType)) {
    body['NotifyType'] = request.notifyType;
  }
  if (!$isNull(request.pushAction)) {
    body['PushAction'] = request.pushAction;
  }
  if (!$isNull(request.pushStatus)) {
    body['PushStatus'] = request.pushStatus;
  }
  if (!$isNull(request.silent)) {
    body['Silent'] = request.silent;
  }
  if (!$isNull(request.strategyContent)) {
    body['StrategyContent'] = request.strategyContent;
  }
  if (!$isNull(request.strategyType)) {
    body['StrategyType'] = request.strategyType;
  }
  if (!$isNull(request.taskName)) {
    body['TaskName'] = request.taskName;
  }
  if (!$isNull(request.templateKeyValue)) {
    body['TemplateKeyValue'] = request.templateKeyValue;
  }
  if (!$isNull(request.templateName)) {
    body['TemplateName'] = request.templateName;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.thirdChannelCategoryShrink)) {
    body['ThirdChannelCategory'] = request.thirdChannelCategoryShrink;
  }
  if (!$isNull(request.timeMode)) {
    body['TimeMode'] = request.timeMode;
  }
  if (!$isNull(request.transparentMessagePayload)) {
    body['TransparentMessagePayload'] = request.transparentMessagePayload;
  }
  if (!$isNull(request.transparentMessageUrgency)) {
    body['TransparentMessageUrgency'] = request.transparentMessageUrgency;
  }
  if (!$isNull(request.unBindEndTime)) {
    body['UnBindEndTime'] = request.unBindEndTime;
  }
  if (!$isNull(request.unBindPeriod)) {
    body['UnBindPeriod'] = request.unBindPeriod;
  }
  if (!$isNull(request.unBindStartTime)) {
    body['UnBindStartTime'] = request.unBindStartTime;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'PushBroadcast',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request PushBroadcastRequest
 * @return PushBroadcastResponse
 */
async function pushBroadcast(request: PushBroadcastRequest): PushBroadcastResponse {
  var runtime = new $RuntimeOptions{};
  return pushBroadcastWithOptions(request, runtime);
}

model PushMultipleRequest {
  activityContentState?: any(name='ActivityContentState'),
  activityEvent?: string(name='ActivityEvent'),
  appId?: string(name='AppId', description='This parameter is required.'),
  channelId?: string(name='ChannelId'),
  classification?: string(name='Classification'),
  deliveryType?: long(name='DeliveryType', description='This parameter is required.'),
  dismissalDate?: long(name='DismissalDate'),
  expiredSeconds?: long(name='ExpiredSeconds', description='This parameter is required.'),
  extendedParams?: string(name='ExtendedParams'),
  miChannelId?: string(name='MiChannelId'),
  notifyLevel?: map[string]any(name='NotifyLevel'),
  notifyType?: string(name='NotifyType'),
  pushAction?: long(name='PushAction'),
  silent?: long(name='Silent'),
  strategyContent?: string(name='StrategyContent'),
  strategyType?: int32(name='StrategyType'),
  targetMsg?: [ 
    {
      extendedParams?: string(name='ExtendedParams'),
      msgKey?: string(name='MsgKey', description='This parameter is required.'),
      target?: string(name='Target', description='This parameter is required.'),
      templateKeyValue?: string(name='TemplateKeyValue'),
    }
  ](name='TargetMsg', description='This parameter is required.'),
  taskName?: string(name='TaskName'),
  templateName?: string(name='TemplateName', description='This parameter is required.'),
  tenantId?: string(name='TenantId'),
  thirdChannelCategory?: map[string]any(name='ThirdChannelCategory'),
  transparentMessagePayload?: any(name='TransparentMessagePayload'),
  transparentMessageUrgency?: string(name='TransparentMessageUrgency'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model PushMultipleShrinkRequest {
  activityContentState?: any(name='ActivityContentState'),
  activityEvent?: string(name='ActivityEvent'),
  appId?: string(name='AppId', description='This parameter is required.'),
  channelId?: string(name='ChannelId'),
  classification?: string(name='Classification'),
  deliveryType?: long(name='DeliveryType', description='This parameter is required.'),
  dismissalDate?: long(name='DismissalDate'),
  expiredSeconds?: long(name='ExpiredSeconds', description='This parameter is required.'),
  extendedParams?: string(name='ExtendedParams'),
  miChannelId?: string(name='MiChannelId'),
  notifyLevelShrink?: string(name='NotifyLevel'),
  notifyType?: string(name='NotifyType'),
  pushAction?: long(name='PushAction'),
  silent?: long(name='Silent'),
  strategyContent?: string(name='StrategyContent'),
  strategyType?: int32(name='StrategyType'),
  targetMsg?: [ 
    {
      extendedParams?: string(name='ExtendedParams'),
      msgKey?: string(name='MsgKey', description='This parameter is required.'),
      target?: string(name='Target', description='This parameter is required.'),
      templateKeyValue?: string(name='TemplateKeyValue'),
    }
  ](name='TargetMsg', description='This parameter is required.'),
  taskName?: string(name='TaskName'),
  templateName?: string(name='TemplateName', description='This parameter is required.'),
  tenantId?: string(name='TenantId'),
  thirdChannelCategoryShrink?: string(name='ThirdChannelCategory'),
  transparentMessagePayload?: any(name='TransparentMessagePayload'),
  transparentMessageUrgency?: string(name='TransparentMessageUrgency'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model PushMultipleResponseBody = {
  pushResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='PushResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model PushMultipleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PushMultipleResponseBody(name='body'),
}

/**
 * @param tmpReq PushMultipleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PushMultipleResponse
 */
@context("pushMultipleWithContext")
async function pushMultipleWithOptions(tmpReq: PushMultipleRequest, runtime: $RuntimeOptions): PushMultipleResponse {
  tmpReq.validate();
  var request = new PushMultipleShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!$isNull(tmpReq.notifyLevel)) {
    request.notifyLevelShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.notifyLevel, 'NotifyLevel', 'json');
  }
  if (!$isNull(tmpReq.thirdChannelCategory)) {
    request.thirdChannelCategoryShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.thirdChannelCategory, 'ThirdChannelCategory', 'json');
  }
  var body : map[string]any = {};
  if (!$isNull(request.activityContentState)) {
    body['ActivityContentState'] = request.activityContentState;
  }
  if (!$isNull(request.activityEvent)) {
    body['ActivityEvent'] = request.activityEvent;
  }
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.channelId)) {
    body['ChannelId'] = request.channelId;
  }
  if (!$isNull(request.classification)) {
    body['Classification'] = request.classification;
  }
  if (!$isNull(request.deliveryType)) {
    body['DeliveryType'] = request.deliveryType;
  }
  if (!$isNull(request.dismissalDate)) {
    body['DismissalDate'] = request.dismissalDate;
  }
  if (!$isNull(request.expiredSeconds)) {
    body['ExpiredSeconds'] = request.expiredSeconds;
  }
  if (!$isNull(request.extendedParams)) {
    body['ExtendedParams'] = request.extendedParams;
  }
  if (!$isNull(request.miChannelId)) {
    body['MiChannelId'] = request.miChannelId;
  }
  if (!$isNull(request.notifyLevelShrink)) {
    body['NotifyLevel'] = request.notifyLevelShrink;
  }
  if (!$isNull(request.notifyType)) {
    body['NotifyType'] = request.notifyType;
  }
  if (!$isNull(request.pushAction)) {
    body['PushAction'] = request.pushAction;
  }
  if (!$isNull(request.silent)) {
    body['Silent'] = request.silent;
  }
  if (!$isNull(request.strategyContent)) {
    body['StrategyContent'] = request.strategyContent;
  }
  if (!$isNull(request.strategyType)) {
    body['StrategyType'] = request.strategyType;
  }
  if (!$isNull(request.targetMsg)) {
    body['TargetMsg'] = request.targetMsg;
  }
  if (!$isNull(request.taskName)) {
    body['TaskName'] = request.taskName;
  }
  if (!$isNull(request.templateName)) {
    body['TemplateName'] = request.templateName;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.thirdChannelCategoryShrink)) {
    body['ThirdChannelCategory'] = request.thirdChannelCategoryShrink;
  }
  if (!$isNull(request.transparentMessagePayload)) {
    body['TransparentMessagePayload'] = request.transparentMessagePayload;
  }
  if (!$isNull(request.transparentMessageUrgency)) {
    body['TransparentMessageUrgency'] = request.transparentMessageUrgency;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'PushMultiple',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request PushMultipleRequest
 * @return PushMultipleResponse
 */
async function pushMultiple(request: PushMultipleRequest): PushMultipleResponse {
  var runtime = new $RuntimeOptions{};
  return pushMultipleWithOptions(request, runtime);
}

model PushQueryDeviceStateRequest {
  appId?: string(name='AppId', example='ALIPUB9A63274111812'),
  target?: string(name='Target', example='8985d1b78d135e10dc26703379369879'),
  targetType?: int32(name='TargetType', example='2'),
  tenantId?: string(name='TenantId', example='BJUVXFNW'),
  workspaceId?: string(name='WorkspaceId', example='default'),
}

model PushQueryDeviceStateResponseBody = {
  code?: string(name='Code', example='100'),
  data?: {
    deliveryToken?: string(name='DeliveryToken', example='ad-000f18w8vmqtzhvbopge-854'),
    deviceId?: string(name='DeviceId', example='ad-000f18w8vmqtzhvbopge-854'),
    manufacturer?: string(name='Manufacturer', example='miui'),
    platform?: string(name='Platform', example='android'),
    statue?: string(name='Statue', example='ONLINE'),
    thirdToken?: string(name='ThirdToken', example='IQAAAACy0f7tAABYiMwLEENtr0TKYJEsv7wyu4Ubt9XXwTJAlknnCb1LAzB3wJvoZIcT_nJdaMhEoXJaqQrObAGHLGoU1GOexlTcLWzja-0HfGHKBw'),
    userId?: string(name='UserId', example='push_test'),
  }(name='Data'),
  message?: string(name='Message', example='SUCCESS'),
  requestId?: string(name='RequestId', description='Id of the request', example='11E66B29-9E5E-5C10-B64E-B5A0E0F26355'),
  success?: boolean(name='Success', example='true'),
}

model PushQueryDeviceStateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PushQueryDeviceStateResponseBody(name='body'),
}

/**
 * @summary 查询设备状态信息
 *
 * @param request PushQueryDeviceStateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PushQueryDeviceStateResponse
 */
@context("pushQueryDeviceStateWithContext")
async function pushQueryDeviceStateWithOptions(request: PushQueryDeviceStateRequest, runtime: $RuntimeOptions): PushQueryDeviceStateResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.target)) {
    body['Target'] = request.target;
  }
  if (!$isNull(request.targetType)) {
    body['TargetType'] = request.targetType;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'PushQueryDeviceState',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询设备状态信息
 *
 * @param request PushQueryDeviceStateRequest
 * @return PushQueryDeviceStateResponse
 */
async function pushQueryDeviceState(request: PushQueryDeviceStateRequest): PushQueryDeviceStateResponse {
  var runtime = new $RuntimeOptions{};
  return pushQueryDeviceStateWithOptions(request, runtime);
}

model PushSimpleRequest {
  activityContentState?: any(name='ActivityContentState'),
  activityEvent?: string(name='ActivityEvent'),
  appId?: string(name='AppId', description='This parameter is required.'),
  channelId?: string(name='ChannelId'),
  classification?: string(name='Classification'),
  content?: string(name='Content', description='This parameter is required.'),
  deliveryType?: long(name='DeliveryType', description='This parameter is required.'),
  dismissalDate?: long(name='DismissalDate'),
  expiredSeconds?: long(name='ExpiredSeconds', description='This parameter is required.'),
  extendedParams?: string(name='ExtendedParams'),
  iconUrls?: string(name='IconUrls'),
  imageUrls?: string(name='ImageUrls'),
  miChannelId?: string(name='MiChannelId'),
  notifyLevel?: map[string]any(name='NotifyLevel'),
  notifyType?: string(name='NotifyType'),
  pushAction?: long(name='PushAction'),
  pushStyle?: int32(name='PushStyle'),
  silent?: long(name='Silent'),
  strategyContent?: string(name='StrategyContent'),
  strategyType?: int32(name='StrategyType'),
  targetMsgkey?: string(name='TargetMsgkey', description='This parameter is required.'),
  taskName?: string(name='TaskName'),
  tenantId?: string(name='TenantId'),
  thirdChannelCategory?: map[string]any(name='ThirdChannelCategory'),
  title?: string(name='Title', description='This parameter is required.'),
  transparentMessagePayload?: any(name='TransparentMessagePayload'),
  transparentMessageUrgency?: string(name='TransparentMessageUrgency'),
  uri?: string(name='Uri'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model PushSimpleShrinkRequest {
  activityContentState?: any(name='ActivityContentState'),
  activityEvent?: string(name='ActivityEvent'),
  appId?: string(name='AppId', description='This parameter is required.'),
  channelId?: string(name='ChannelId'),
  classification?: string(name='Classification'),
  content?: string(name='Content', description='This parameter is required.'),
  deliveryType?: long(name='DeliveryType', description='This parameter is required.'),
  dismissalDate?: long(name='DismissalDate'),
  expiredSeconds?: long(name='ExpiredSeconds', description='This parameter is required.'),
  extendedParams?: string(name='ExtendedParams'),
  iconUrls?: string(name='IconUrls'),
  imageUrls?: string(name='ImageUrls'),
  miChannelId?: string(name='MiChannelId'),
  notifyLevelShrink?: string(name='NotifyLevel'),
  notifyType?: string(name='NotifyType'),
  pushAction?: long(name='PushAction'),
  pushStyle?: int32(name='PushStyle'),
  silent?: long(name='Silent'),
  strategyContent?: string(name='StrategyContent'),
  strategyType?: int32(name='StrategyType'),
  targetMsgkey?: string(name='TargetMsgkey', description='This parameter is required.'),
  taskName?: string(name='TaskName'),
  tenantId?: string(name='TenantId'),
  thirdChannelCategoryShrink?: string(name='ThirdChannelCategory'),
  title?: string(name='Title', description='This parameter is required.'),
  transparentMessagePayload?: any(name='TransparentMessagePayload'),
  transparentMessageUrgency?: string(name='TransparentMessageUrgency'),
  uri?: string(name='Uri'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model PushSimpleResponseBody = {
  pushResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='PushResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model PushSimpleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PushSimpleResponseBody(name='body'),
}

/**
 * @param tmpReq PushSimpleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PushSimpleResponse
 */
@context("pushSimpleWithContext")
async function pushSimpleWithOptions(tmpReq: PushSimpleRequest, runtime: $RuntimeOptions): PushSimpleResponse {
  tmpReq.validate();
  var request = new PushSimpleShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!$isNull(tmpReq.notifyLevel)) {
    request.notifyLevelShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.notifyLevel, 'NotifyLevel', 'json');
  }
  if (!$isNull(tmpReq.thirdChannelCategory)) {
    request.thirdChannelCategoryShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.thirdChannelCategory, 'ThirdChannelCategory', 'json');
  }
  var body : map[string]any = {};
  if (!$isNull(request.activityContentState)) {
    body['ActivityContentState'] = request.activityContentState;
  }
  if (!$isNull(request.activityEvent)) {
    body['ActivityEvent'] = request.activityEvent;
  }
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.channelId)) {
    body['ChannelId'] = request.channelId;
  }
  if (!$isNull(request.classification)) {
    body['Classification'] = request.classification;
  }
  if (!$isNull(request.content)) {
    body['Content'] = request.content;
  }
  if (!$isNull(request.deliveryType)) {
    body['DeliveryType'] = request.deliveryType;
  }
  if (!$isNull(request.dismissalDate)) {
    body['DismissalDate'] = request.dismissalDate;
  }
  if (!$isNull(request.expiredSeconds)) {
    body['ExpiredSeconds'] = request.expiredSeconds;
  }
  if (!$isNull(request.extendedParams)) {
    body['ExtendedParams'] = request.extendedParams;
  }
  if (!$isNull(request.iconUrls)) {
    body['IconUrls'] = request.iconUrls;
  }
  if (!$isNull(request.imageUrls)) {
    body['ImageUrls'] = request.imageUrls;
  }
  if (!$isNull(request.miChannelId)) {
    body['MiChannelId'] = request.miChannelId;
  }
  if (!$isNull(request.notifyLevelShrink)) {
    body['NotifyLevel'] = request.notifyLevelShrink;
  }
  if (!$isNull(request.notifyType)) {
    body['NotifyType'] = request.notifyType;
  }
  if (!$isNull(request.pushAction)) {
    body['PushAction'] = request.pushAction;
  }
  if (!$isNull(request.pushStyle)) {
    body['PushStyle'] = request.pushStyle;
  }
  if (!$isNull(request.silent)) {
    body['Silent'] = request.silent;
  }
  if (!$isNull(request.strategyContent)) {
    body['StrategyContent'] = request.strategyContent;
  }
  if (!$isNull(request.strategyType)) {
    body['StrategyType'] = request.strategyType;
  }
  if (!$isNull(request.targetMsgkey)) {
    body['TargetMsgkey'] = request.targetMsgkey;
  }
  if (!$isNull(request.taskName)) {
    body['TaskName'] = request.taskName;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.thirdChannelCategoryShrink)) {
    body['ThirdChannelCategory'] = request.thirdChannelCategoryShrink;
  }
  if (!$isNull(request.title)) {
    body['Title'] = request.title;
  }
  if (!$isNull(request.transparentMessagePayload)) {
    body['TransparentMessagePayload'] = request.transparentMessagePayload;
  }
  if (!$isNull(request.transparentMessageUrgency)) {
    body['TransparentMessageUrgency'] = request.transparentMessageUrgency;
  }
  if (!$isNull(request.uri)) {
    body['Uri'] = request.uri;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'PushSimple',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request PushSimpleRequest
 * @return PushSimpleResponse
 */
async function pushSimple(request: PushSimpleRequest): PushSimpleResponse {
  var runtime = new $RuntimeOptions{};
  return pushSimpleWithOptions(request, runtime);
}

model PushTemplateRequest {
  activityContentState?: any(name='ActivityContentState'),
  activityEvent?: string(name='ActivityEvent'),
  appId?: string(name='AppId', description='This parameter is required.'),
  channelId?: string(name='ChannelId'),
  classification?: string(name='Classification'),
  deliveryType?: long(name='DeliveryType', description='This parameter is required.'),
  dismissalDate?: long(name='DismissalDate'),
  expiredSeconds?: long(name='ExpiredSeconds', description='This parameter is required.'),
  extendedParams?: string(name='ExtendedParams'),
  miChannelId?: string(name='MiChannelId'),
  notifyLevel?: map[string]any(name='NotifyLevel'),
  notifyType?: string(name='NotifyType'),
  pushAction?: long(name='PushAction'),
  silent?: long(name='Silent'),
  strategyContent?: string(name='StrategyContent'),
  strategyType?: int32(name='StrategyType'),
  targetMsgkey?: string(name='TargetMsgkey', description='This parameter is required.'),
  taskName?: string(name='TaskName'),
  templateKeyValue?: string(name='TemplateKeyValue'),
  templateName?: string(name='TemplateName', description='This parameter is required.'),
  tenantId?: string(name='TenantId'),
  thirdChannelCategory?: map[string]any(name='ThirdChannelCategory'),
  transparentMessagePayload?: any(name='TransparentMessagePayload'),
  transparentMessageUrgency?: string(name='TransparentMessageUrgency'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model PushTemplateShrinkRequest {
  activityContentState?: any(name='ActivityContentState'),
  activityEvent?: string(name='ActivityEvent'),
  appId?: string(name='AppId', description='This parameter is required.'),
  channelId?: string(name='ChannelId'),
  classification?: string(name='Classification'),
  deliveryType?: long(name='DeliveryType', description='This parameter is required.'),
  dismissalDate?: long(name='DismissalDate'),
  expiredSeconds?: long(name='ExpiredSeconds', description='This parameter is required.'),
  extendedParams?: string(name='ExtendedParams'),
  miChannelId?: string(name='MiChannelId'),
  notifyLevelShrink?: string(name='NotifyLevel'),
  notifyType?: string(name='NotifyType'),
  pushAction?: long(name='PushAction'),
  silent?: long(name='Silent'),
  strategyContent?: string(name='StrategyContent'),
  strategyType?: int32(name='StrategyType'),
  targetMsgkey?: string(name='TargetMsgkey', description='This parameter is required.'),
  taskName?: string(name='TaskName'),
  templateKeyValue?: string(name='TemplateKeyValue'),
  templateName?: string(name='TemplateName', description='This parameter is required.'),
  tenantId?: string(name='TenantId'),
  thirdChannelCategoryShrink?: string(name='ThirdChannelCategory'),
  transparentMessagePayload?: any(name='TransparentMessagePayload'),
  transparentMessageUrgency?: string(name='TransparentMessageUrgency'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model PushTemplateResponseBody = {
  pushResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='PushResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model PushTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PushTemplateResponseBody(name='body'),
}

/**
 * @param tmpReq PushTemplateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PushTemplateResponse
 */
@context("pushTemplateWithContext")
async function pushTemplateWithOptions(tmpReq: PushTemplateRequest, runtime: $RuntimeOptions): PushTemplateResponse {
  tmpReq.validate();
  var request = new PushTemplateShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!$isNull(tmpReq.notifyLevel)) {
    request.notifyLevelShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.notifyLevel, 'NotifyLevel', 'json');
  }
  if (!$isNull(tmpReq.thirdChannelCategory)) {
    request.thirdChannelCategoryShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.thirdChannelCategory, 'ThirdChannelCategory', 'json');
  }
  var body : map[string]any = {};
  if (!$isNull(request.activityContentState)) {
    body['ActivityContentState'] = request.activityContentState;
  }
  if (!$isNull(request.activityEvent)) {
    body['ActivityEvent'] = request.activityEvent;
  }
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.channelId)) {
    body['ChannelId'] = request.channelId;
  }
  if (!$isNull(request.classification)) {
    body['Classification'] = request.classification;
  }
  if (!$isNull(request.deliveryType)) {
    body['DeliveryType'] = request.deliveryType;
  }
  if (!$isNull(request.dismissalDate)) {
    body['DismissalDate'] = request.dismissalDate;
  }
  if (!$isNull(request.expiredSeconds)) {
    body['ExpiredSeconds'] = request.expiredSeconds;
  }
  if (!$isNull(request.extendedParams)) {
    body['ExtendedParams'] = request.extendedParams;
  }
  if (!$isNull(request.miChannelId)) {
    body['MiChannelId'] = request.miChannelId;
  }
  if (!$isNull(request.notifyLevelShrink)) {
    body['NotifyLevel'] = request.notifyLevelShrink;
  }
  if (!$isNull(request.notifyType)) {
    body['NotifyType'] = request.notifyType;
  }
  if (!$isNull(request.pushAction)) {
    body['PushAction'] = request.pushAction;
  }
  if (!$isNull(request.silent)) {
    body['Silent'] = request.silent;
  }
  if (!$isNull(request.strategyContent)) {
    body['StrategyContent'] = request.strategyContent;
  }
  if (!$isNull(request.strategyType)) {
    body['StrategyType'] = request.strategyType;
  }
  if (!$isNull(request.targetMsgkey)) {
    body['TargetMsgkey'] = request.targetMsgkey;
  }
  if (!$isNull(request.taskName)) {
    body['TaskName'] = request.taskName;
  }
  if (!$isNull(request.templateKeyValue)) {
    body['TemplateKeyValue'] = request.templateKeyValue;
  }
  if (!$isNull(request.templateName)) {
    body['TemplateName'] = request.templateName;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.thirdChannelCategoryShrink)) {
    body['ThirdChannelCategory'] = request.thirdChannelCategoryShrink;
  }
  if (!$isNull(request.transparentMessagePayload)) {
    body['TransparentMessagePayload'] = request.transparentMessagePayload;
  }
  if (!$isNull(request.transparentMessageUrgency)) {
    body['TransparentMessageUrgency'] = request.transparentMessageUrgency;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'PushTemplate',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request PushTemplateRequest
 * @return PushTemplateResponse
 */
async function pushTemplate(request: PushTemplateRequest): PushTemplateResponse {
  var runtime = new $RuntimeOptions{};
  return pushTemplateWithOptions(request, runtime);
}

model QueryMcubeMiniPackageRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  h5Id?: string(name='H5Id', description='This parameter is required.'),
  id?: string(name='Id', description='This parameter is required.'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model QueryMcubeMiniPackageResponseBody = {
  queryMiniPackageResult?: {
    miniPackageInfo?: {
      appCode?: string(name='AppCode'),
      autoInstall?: long(name='AutoInstall'),
      clientVersionMax?: string(name='ClientVersionMax'),
      clientVersionMin?: string(name='ClientVersionMin'),
      downloadUrl?: string(name='DownloadUrl'),
      extendInfo?: string(name='ExtendInfo'),
      extraData?: string(name='ExtraData'),
      fallbackBaseUrl?: string(name='FallbackBaseUrl'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      h5Id?: string(name='H5Id'),
      h5Name?: string(name='H5Name'),
      h5Version?: string(name='H5Version'),
      id?: long(name='Id'),
      installType?: long(name='InstallType'),
      mainUrl?: string(name='MainUrl'),
      memo?: string(name='Memo'),
      packageType?: long(name='PackageType'),
      platform?: string(name='Platform'),
      publishPeriod?: long(name='PublishPeriod'),
      resourceType?: long(name='ResourceType'),
      status?: long(name='Status'),
    }(name='MiniPackageInfo'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='QueryMiniPackageResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryMcubeMiniPackageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMcubeMiniPackageResponseBody(name='body'),
}

/**
 * @param request QueryMcubeMiniPackageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryMcubeMiniPackageResponse
 */
@context("queryMcubeMiniPackageWithContext")
async function queryMcubeMiniPackageWithOptions(request: QueryMcubeMiniPackageRequest, runtime: $RuntimeOptions): QueryMcubeMiniPackageResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.h5Id)) {
    body['H5Id'] = request.h5Id;
  }
  if (!$isNull(request.id)) {
    body['Id'] = request.id;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'QueryMcubeMiniPackage',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryMcubeMiniPackageRequest
 * @return QueryMcubeMiniPackageResponse
 */
async function queryMcubeMiniPackage(request: QueryMcubeMiniPackageRequest): QueryMcubeMiniPackageResponse {
  var runtime = new $RuntimeOptions{};
  return queryMcubeMiniPackageWithOptions(request, runtime);
}

model QueryMcubeMiniTaskRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  taskId?: long(name='TaskId', description='This parameter is required.'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model QueryMcubeMiniTaskResponseBody = {
  queryMiniTaskResult?: {
    miniTaskInfo?: {
      appCode?: string(name='AppCode'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      greyConfigInfo?: string(name='GreyConfigInfo'),
      greyEndtime?: string(name='GreyEndtime'),
      greyEndtimeData?: string(name='GreyEndtimeData'),
      greyNum?: long(name='GreyNum'),
      id?: long(name='Id'),
      memo?: string(name='Memo'),
      packageId?: long(name='PackageId'),
      platform?: string(name='Platform'),
      productVersion?: string(name='ProductVersion'),
      publishMode?: long(name='PublishMode'),
      publishType?: long(name='PublishType'),
      status?: string(name='Status'),
      taskStatus?: long(name='TaskStatus'),
      whitelistIds?: string(name='WhitelistIds'),
    }(name='MiniTaskInfo'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='QueryMiniTaskResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryMcubeMiniTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMcubeMiniTaskResponseBody(name='body'),
}

/**
 * @param request QueryMcubeMiniTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryMcubeMiniTaskResponse
 */
@context("queryMcubeMiniTaskWithContext")
async function queryMcubeMiniTaskWithOptions(request: QueryMcubeMiniTaskRequest, runtime: $RuntimeOptions): QueryMcubeMiniTaskResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'QueryMcubeMiniTask',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryMcubeMiniTaskRequest
 * @return QueryMcubeMiniTaskResponse
 */
async function queryMcubeMiniTask(request: QueryMcubeMiniTaskRequest): QueryMcubeMiniTaskResponse {
  var runtime = new $RuntimeOptions{};
  return queryMcubeMiniTaskWithOptions(request, runtime);
}

model QueryMcubeVhostRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model QueryMcubeVhostResponseBody = {
  queryVhostResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='QueryVhostResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryMcubeVhostResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMcubeVhostResponseBody(name='body'),
}

/**
 * @param request QueryMcubeVhostRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryMcubeVhostResponse
 */
@context("queryMcubeVhostWithContext")
async function queryMcubeVhostWithOptions(request: QueryMcubeVhostRequest, runtime: $RuntimeOptions): QueryMcubeVhostResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'QueryMcubeVhost',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryMcubeVhostRequest
 * @return QueryMcubeVhostResponse
 */
async function queryMcubeVhost(request: QueryMcubeVhostRequest): QueryMcubeVhostResponse {
  var runtime = new $RuntimeOptions{};
  return queryMcubeVhostWithOptions(request, runtime);
}

model QueryMpsSchedulerListRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  endTime?: long(name='EndTime'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  startTime?: long(name='StartTime'),
  type?: int32(name='Type'),
  uniqueId?: string(name='UniqueId'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model QueryMpsSchedulerListResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: {
      list?: [ 
        {
          createType?: int32(name='CreateType'),
          deliveryType?: int32(name='DeliveryType'),
          executedStatus?: string(name='ExecutedStatus'),
          gmtCreate?: long(name='GmtCreate'),
          parentId?: string(name='ParentId'),
          pushContent?: string(name='PushContent'),
          pushTime?: long(name='PushTime'),
          pushTitle?: string(name='PushTitle'),
          strategyType?: int32(name='StrategyType'),
          type?: int32(name='Type'),
          uniqueId?: string(name='UniqueId'),
        }
      ](name='List'),
      totalCount?: int32(name='TotalCount'),
    }(name='Data'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryMpsSchedulerListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMpsSchedulerListResponseBody(name='body'),
}

/**
 * @summary 查询定时任务列表
 *
 * @param request QueryMpsSchedulerListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryMpsSchedulerListResponse
 */
@context("queryMpsSchedulerListWithContext")
async function queryMpsSchedulerListWithOptions(request: QueryMpsSchedulerListRequest, runtime: $RuntimeOptions): QueryMpsSchedulerListResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!$isNull(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  if (!$isNull(request.type)) {
    body['Type'] = request.type;
  }
  if (!$isNull(request.uniqueId)) {
    body['UniqueId'] = request.uniqueId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'QueryMpsSchedulerList',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询定时任务列表
 *
 * @param request QueryMpsSchedulerListRequest
 * @return QueryMpsSchedulerListResponse
 */
async function queryMpsSchedulerList(request: QueryMpsSchedulerListRequest): QueryMpsSchedulerListResponse {
  var runtime = new $RuntimeOptions{};
  return queryMpsSchedulerListWithOptions(request, runtime);
}

model QueryPushAnalysisCoreIndexRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  channel?: string(name='Channel'),
  endTime?: long(name='EndTime', description='This parameter is required.'),
  platform?: string(name='Platform'),
  startTime?: long(name='StartTime', description='This parameter is required.'),
  taskId?: string(name='TaskId'),
  tenantId?: string(name='TenantId'),
  type?: string(name='Type'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model QueryPushAnalysisCoreIndexResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: {
      arrivalNum?: float(name='ArrivalNum'),
      arrivalRate?: float(name='ArrivalRate'),
      ignoreNum?: float(name='IgnoreNum'),
      ignoreRate?: float(name='IgnoreRate'),
      openNum?: float(name='OpenNum'),
      openRate?: float(name='OpenRate'),
      pushNum?: float(name='PushNum'),
      pushTotalNum?: float(name='PushTotalNum'),
    }(name='Data'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryPushAnalysisCoreIndexResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryPushAnalysisCoreIndexResponseBody(name='body'),
}

/**
 * @param request QueryPushAnalysisCoreIndexRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryPushAnalysisCoreIndexResponse
 */
@context("queryPushAnalysisCoreIndexWithContext")
async function queryPushAnalysisCoreIndexWithOptions(request: QueryPushAnalysisCoreIndexRequest, runtime: $RuntimeOptions): QueryPushAnalysisCoreIndexResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.channel)) {
    body['Channel'] = request.channel;
  }
  if (!$isNull(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!$isNull(request.platform)) {
    body['Platform'] = request.platform;
  }
  if (!$isNull(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  if (!$isNull(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.type)) {
    body['Type'] = request.type;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'QueryPushAnalysisCoreIndex',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryPushAnalysisCoreIndexRequest
 * @return QueryPushAnalysisCoreIndexResponse
 */
async function queryPushAnalysisCoreIndex(request: QueryPushAnalysisCoreIndexRequest): QueryPushAnalysisCoreIndexResponse {
  var runtime = new $RuntimeOptions{};
  return queryPushAnalysisCoreIndexWithOptions(request, runtime);
}

model QueryPushAnalysisTaskDetailRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  taskId?: string(name='TaskId', description='This parameter is required.'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model QueryPushAnalysisTaskDetailResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: {
      duration?: string(name='Duration'),
      endTime?: long(name='EndTime'),
      pushArrivalNum?: float(name='PushArrivalNum'),
      pushNum?: float(name='PushNum'),
      pushSuccessNum?: float(name='PushSuccessNum'),
      startTime?: long(name='StartTime'),
      taskId?: long(name='TaskId'),
    }(name='Data'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryPushAnalysisTaskDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryPushAnalysisTaskDetailResponseBody(name='body'),
}

/**
 * @param request QueryPushAnalysisTaskDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryPushAnalysisTaskDetailResponse
 */
@context("queryPushAnalysisTaskDetailWithContext")
async function queryPushAnalysisTaskDetailWithOptions(request: QueryPushAnalysisTaskDetailRequest, runtime: $RuntimeOptions): QueryPushAnalysisTaskDetailResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'QueryPushAnalysisTaskDetail',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryPushAnalysisTaskDetailRequest
 * @return QueryPushAnalysisTaskDetailResponse
 */
async function queryPushAnalysisTaskDetail(request: QueryPushAnalysisTaskDetailRequest): QueryPushAnalysisTaskDetailResponse {
  var runtime = new $RuntimeOptions{};
  return queryPushAnalysisTaskDetailWithOptions(request, runtime);
}

model QueryPushAnalysisTaskListRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  startTime?: long(name='StartTime', description='This parameter is required.'),
  taskId?: string(name='TaskId'),
  taskName?: string(name='TaskName'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model QueryPushAnalysisTaskListResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: [ 
      {
        gmtCreate?: long(name='GmtCreate'),
        list?: [ 
          {
            gmtCreate?: long(name='GmtCreate'),
            taskId?: string(name='TaskId'),
            taskName?: string(name='TaskName'),
            templateId?: string(name='TemplateId'),
            templateName?: string(name='TemplateName'),
            type?: long(name='Type'),
          }
        ](name='List'),
        taskId?: string(name='TaskId'),
        taskName?: string(name='TaskName'),
        templateId?: string(name='TemplateId'),
        templateName?: string(name='TemplateName'),
        type?: long(name='Type'),
      }
    ](name='Data'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryPushAnalysisTaskListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryPushAnalysisTaskListResponseBody(name='body'),
}

/**
 * @param request QueryPushAnalysisTaskListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryPushAnalysisTaskListResponse
 */
@context("queryPushAnalysisTaskListWithContext")
async function queryPushAnalysisTaskListWithOptions(request: QueryPushAnalysisTaskListRequest, runtime: $RuntimeOptions): QueryPushAnalysisTaskListResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  if (!$isNull(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  if (!$isNull(request.taskName)) {
    body['TaskName'] = request.taskName;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'QueryPushAnalysisTaskList',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryPushAnalysisTaskListRequest
 * @return QueryPushAnalysisTaskListResponse
 */
async function queryPushAnalysisTaskList(request: QueryPushAnalysisTaskListRequest): QueryPushAnalysisTaskListResponse {
  var runtime = new $RuntimeOptions{};
  return queryPushAnalysisTaskListWithOptions(request, runtime);
}

model QueryPushSchedulerListRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  endTime?: long(name='EndTime', description='This parameter is required.'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  startTime?: long(name='StartTime', description='This parameter is required.'),
  tenantId?: string(name='TenantId'),
  type?: int32(name='Type'),
  uniqueId?: string(name='UniqueId'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model QueryPushSchedulerListResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: {
      list?: [ 
        {
          createType?: int32(name='CreateType'),
          deliveryType?: int32(name='DeliveryType'),
          executedStatus?: string(name='ExecutedStatus'),
          gmtCreate?: long(name='GmtCreate'),
          parentId?: string(name='ParentId'),
          pushContent?: string(name='PushContent'),
          pushTime?: long(name='PushTime'),
          pushTitle?: string(name='PushTitle'),
          strategyType?: int32(name='StrategyType'),
          type?: int32(name='Type'),
          uniqueId?: string(name='UniqueId'),
        }
      ](name='List'),
      totalCount?: int32(name='TotalCount'),
    }(name='Data'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryPushSchedulerListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryPushSchedulerListResponseBody(name='body'),
}

/**
 * @param request QueryPushSchedulerListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryPushSchedulerListResponse
 */
@context("queryPushSchedulerListWithContext")
async function queryPushSchedulerListWithOptions(request: QueryPushSchedulerListRequest, runtime: $RuntimeOptions): QueryPushSchedulerListResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!$isNull(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.type)) {
    body['Type'] = request.type;
  }
  if (!$isNull(request.uniqueId)) {
    body['UniqueId'] = request.uniqueId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'QueryPushSchedulerList',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryPushSchedulerListRequest
 * @return QueryPushSchedulerListResponse
 */
async function queryPushSchedulerList(request: QueryPushSchedulerListRequest): QueryPushSchedulerListResponse {
  var runtime = new $RuntimeOptions{};
  return queryPushSchedulerListWithOptions(request, runtime);
}

model RevokePushMessageRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  messageId?: string(name='MessageId', description='This parameter is required.'),
  targetId?: string(name='TargetId', description='This parameter is required.'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model RevokePushMessageResponseBody = {
  pushResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='PushResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model RevokePushMessageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RevokePushMessageResponseBody(name='body'),
}

/**
 * @param request RevokePushMessageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RevokePushMessageResponse
 */
@context("revokePushMessageWithContext")
async function revokePushMessageWithOptions(request: RevokePushMessageRequest, runtime: $RuntimeOptions): RevokePushMessageResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.messageId)) {
    body['MessageId'] = request.messageId;
  }
  if (!$isNull(request.targetId)) {
    body['TargetId'] = request.targetId;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'RevokePushMessage',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request RevokePushMessageRequest
 * @return RevokePushMessageResponse
 */
async function revokePushMessage(request: RevokePushMessageRequest): RevokePushMessageResponse {
  var runtime = new $RuntimeOptions{};
  return revokePushMessageWithOptions(request, runtime);
}

model RevokePushTaskRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  taskId?: string(name='TaskId', description='This parameter is required.'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model RevokePushTaskResponseBody = {
  pushResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='PushResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model RevokePushTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RevokePushTaskResponseBody(name='body'),
}

/**
 * @param request RevokePushTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RevokePushTaskResponse
 */
@context("revokePushTaskWithContext")
async function revokePushTaskWithOptions(request: RevokePushTaskRequest, runtime: $RuntimeOptions): RevokePushTaskResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'RevokePushTask',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request RevokePushTaskRequest
 * @return RevokePushTaskResponse
 */
async function revokePushTask(request: RevokePushTaskRequest): RevokePushTaskResponse {
  var runtime = new $RuntimeOptions{};
  return revokePushTaskWithOptions(request, runtime);
}

model UpdateMcubeWhitelistRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  id?: string(name='Id', description='This parameter is required.'),
  keyIds?: string(name='KeyIds'),
  onexFlag?: boolean(name='OnexFlag', description='This parameter is required.'),
  ossUrl?: string(name='OssUrl'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model UpdateMcubeWhitelistResponseBody = {
  addWhitelistResult?: {
    addWhitelistInfo?: {
      failNum?: long(name='FailNum'),
      failUserIds?: string(name='FailUserIds'),
      successNum?: long(name='SuccessNum'),
    }(name='AddWhitelistInfo'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='AddWhitelistResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model UpdateMcubeWhitelistResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateMcubeWhitelistResponseBody(name='body'),
}

/**
 * @param request UpdateMcubeWhitelistRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateMcubeWhitelistResponse
 */
@context("updateMcubeWhitelistWithContext")
async function updateMcubeWhitelistWithOptions(request: UpdateMcubeWhitelistRequest, runtime: $RuntimeOptions): UpdateMcubeWhitelistResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.id)) {
    body['Id'] = request.id;
  }
  if (!$isNull(request.keyIds)) {
    body['KeyIds'] = request.keyIds;
  }
  if (!$isNull(request.onexFlag)) {
    body['OnexFlag'] = request.onexFlag;
  }
  if (!$isNull(request.ossUrl)) {
    body['OssUrl'] = request.ossUrl;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateMcubeWhitelist',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateMcubeWhitelistRequest
 * @return UpdateMcubeWhitelistResponse
 */
async function updateMcubeWhitelist(request: UpdateMcubeWhitelistRequest): UpdateMcubeWhitelistResponse {
  var runtime = new $RuntimeOptions{};
  return updateMcubeWhitelistWithOptions(request, runtime);
}

model UploadMcubeMiniPackageRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  autoInstall?: long(name='AutoInstall', description='This parameter is required.'),
  clientVersionMax?: string(name='ClientVersionMax'),
  clientVersionMin?: string(name='ClientVersionMin', description='This parameter is required.'),
  enableKeepAlive?: string(name='EnableKeepAlive', description='This parameter is required.'),
  enableOptionMenu?: string(name='EnableOptionMenu', description='This parameter is required.'),
  enableTabBar?: long(name='EnableTabBar', description='This parameter is required.'),
  extendInfo?: string(name='ExtendInfo'),
  h5Id?: string(name='H5Id', description='This parameter is required.'),
  h5Name?: string(name='H5Name', description='This parameter is required.'),
  h5Version?: string(name='H5Version', description='This parameter is required.'),
  iconFileUrl?: string(name='IconFileUrl', description='This parameter is required.'),
  installType?: long(name='InstallType', description='This parameter is required.'),
  mainUrl?: string(name='MainUrl', description='This parameter is required.'),
  onexFlag?: boolean(name='OnexFlag', description='This parameter is required.'),
  packageType?: long(name='PackageType', description='This parameter is required.'),
  platform?: string(name='Platform', description='This parameter is required.'),
  resourceFileUrl?: string(name='ResourceFileUrl', description='This parameter is required.'),
  resourceType?: long(name='ResourceType', description='This parameter is required.'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
  userId?: string(name='UserId', description='This parameter is required.'),
  uuid?: string(name='Uuid'),
  vhost?: string(name='Vhost', description='This parameter is required.'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model UploadMcubeMiniPackageResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
  uploadMiniPackageResult?: {
    resultMsg?: string(name='ResultMsg'),
    returnPackageResult?: {
      debugUrl?: string(name='DebugUrl'),
      packageId?: string(name='PackageId'),
      userId?: string(name='UserId'),
    }(name='ReturnPackageResult'),
    success?: boolean(name='Success'),
  }(name='UploadMiniPackageResult'),
}

model UploadMcubeMiniPackageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UploadMcubeMiniPackageResponseBody(name='body'),
}

/**
 * @param request UploadMcubeMiniPackageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UploadMcubeMiniPackageResponse
 */
@context("uploadMcubeMiniPackageWithContext")
async function uploadMcubeMiniPackageWithOptions(request: UploadMcubeMiniPackageRequest, runtime: $RuntimeOptions): UploadMcubeMiniPackageResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.autoInstall)) {
    body['AutoInstall'] = request.autoInstall;
  }
  if (!$isNull(request.clientVersionMax)) {
    body['ClientVersionMax'] = request.clientVersionMax;
  }
  if (!$isNull(request.clientVersionMin)) {
    body['ClientVersionMin'] = request.clientVersionMin;
  }
  if (!$isNull(request.enableKeepAlive)) {
    body['EnableKeepAlive'] = request.enableKeepAlive;
  }
  if (!$isNull(request.enableOptionMenu)) {
    body['EnableOptionMenu'] = request.enableOptionMenu;
  }
  if (!$isNull(request.enableTabBar)) {
    body['EnableTabBar'] = request.enableTabBar;
  }
  if (!$isNull(request.extendInfo)) {
    body['ExtendInfo'] = request.extendInfo;
  }
  if (!$isNull(request.h5Id)) {
    body['H5Id'] = request.h5Id;
  }
  if (!$isNull(request.h5Name)) {
    body['H5Name'] = request.h5Name;
  }
  if (!$isNull(request.h5Version)) {
    body['H5Version'] = request.h5Version;
  }
  if (!$isNull(request.iconFileUrl)) {
    body['IconFileUrl'] = request.iconFileUrl;
  }
  if (!$isNull(request.installType)) {
    body['InstallType'] = request.installType;
  }
  if (!$isNull(request.mainUrl)) {
    body['MainUrl'] = request.mainUrl;
  }
  if (!$isNull(request.onexFlag)) {
    body['OnexFlag'] = request.onexFlag;
  }
  if (!$isNull(request.packageType)) {
    body['PackageType'] = request.packageType;
  }
  if (!$isNull(request.platform)) {
    body['Platform'] = request.platform;
  }
  if (!$isNull(request.resourceFileUrl)) {
    body['ResourceFileUrl'] = request.resourceFileUrl;
  }
  if (!$isNull(request.resourceType)) {
    body['ResourceType'] = request.resourceType;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.userId)) {
    body['UserId'] = request.userId;
  }
  if (!$isNull(request.uuid)) {
    body['Uuid'] = request.uuid;
  }
  if (!$isNull(request.vhost)) {
    body['Vhost'] = request.vhost;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UploadMcubeMiniPackage',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UploadMcubeMiniPackageRequest
 * @return UploadMcubeMiniPackageResponse
 */
async function uploadMcubeMiniPackage(request: UploadMcubeMiniPackageRequest): UploadMcubeMiniPackageResponse {
  var runtime = new $RuntimeOptions{};
  return uploadMcubeMiniPackageWithOptions(request, runtime);
}

model UploadMcubeRsaKeyRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  fileUrl?: string(name='FileUrl', description='This parameter is required.'),
  onexFlag?: boolean(name='OnexFlag', description='This parameter is required.'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model UploadMcubeRsaKeyResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
  uploadRsaResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='UploadRsaResult'),
}

model UploadMcubeRsaKeyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UploadMcubeRsaKeyResponseBody(name='body'),
}

/**
 * @param request UploadMcubeRsaKeyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UploadMcubeRsaKeyResponse
 */
@context("uploadMcubeRsaKeyWithContext")
async function uploadMcubeRsaKeyWithOptions(request: UploadMcubeRsaKeyRequest, runtime: $RuntimeOptions): UploadMcubeRsaKeyResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.fileUrl)) {
    body['FileUrl'] = request.fileUrl;
  }
  if (!$isNull(request.onexFlag)) {
    body['OnexFlag'] = request.onexFlag;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UploadMcubeRsaKey',
    version = '2020-07-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UploadMcubeRsaKeyRequest
 * @return UploadMcubeRsaKeyResponse
 */
async function uploadMcubeRsaKey(request: UploadMcubeRsaKeyRequest): UploadMcubeRsaKeyResponse {
  var runtime = new $RuntimeOptions{};
  return uploadMcubeRsaKeyWithOptions(request, runtime);
}

