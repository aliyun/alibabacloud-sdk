/**
  *
  */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'mPaaS';
  @version = '2020-07-10';
  @endpointRule = 'regional';
  @endpointMap = {
    'cn-hangzhou' = 'mpaas.aliyuncs.com',
    'ap-northeast-1' = 'mpaas.aliyuncs.com',
    'ap-northeast-2-pop' = 'mpaas.aliyuncs.com',
    'ap-south-1' = 'mpaas.aliyuncs.com',
    'ap-southeast-1' = 'mpaas.aliyuncs.com',
    'ap-southeast-2' = 'mpaas.aliyuncs.com',
    'ap-southeast-3' = 'mpaas.aliyuncs.com',
    'ap-southeast-5' = 'mpaas.aliyuncs.com',
    'cn-beijing' = 'mpaas.aliyuncs.com',
    'cn-beijing-finance-1' = 'mpaas.aliyuncs.com',
    'cn-beijing-finance-pop' = 'mpaas.aliyuncs.com',
    'cn-beijing-gov-1' = 'mpaas.aliyuncs.com',
    'cn-beijing-nu16-b01' = 'mpaas.aliyuncs.com',
    'cn-chengdu' = 'mpaas.aliyuncs.com',
    'cn-edge-1' = 'mpaas.aliyuncs.com',
    'cn-fujian' = 'mpaas.aliyuncs.com',
    'cn-haidian-cm12-c01' = 'mpaas.aliyuncs.com',
    'cn-hangzhou-bj-b01' = 'mpaas.aliyuncs.com',
    'cn-hangzhou-finance' = 'mpaas.aliyuncs.com',
    'cn-hangzhou-internal-prod-1' = 'mpaas.aliyuncs.com',
    'cn-hangzhou-internal-test-1' = 'mpaas.aliyuncs.com',
    'cn-hangzhou-internal-test-2' = 'mpaas.aliyuncs.com',
    'cn-hangzhou-internal-test-3' = 'mpaas.aliyuncs.com',
    'cn-hangzhou-test-306' = 'mpaas.aliyuncs.com',
    'cn-hongkong' = 'mpaas.aliyuncs.com',
    'cn-hongkong-finance-pop' = 'mpaas.aliyuncs.com',
    'cn-huhehaote' = 'mpaas.aliyuncs.com',
    'cn-north-2-gov-1' = 'mpaas.aliyuncs.com',
    'cn-qingdao' = 'mpaas.aliyuncs.com',
    'cn-qingdao-nebula' = 'mpaas.aliyuncs.com',
    'cn-shanghai' = 'mpaas.aliyuncs.com',
    'cn-shanghai-et15-b01' = 'mpaas.aliyuncs.com',
    'cn-shanghai-et2-b01' = 'mpaas.aliyuncs.com',
    'cn-shanghai-finance-1' = 'mpaas.aliyuncs.com',
    'cn-shanghai-inner' = 'mpaas.aliyuncs.com',
    'cn-shanghai-internal-test-1' = 'mpaas.aliyuncs.com',
    'cn-shenzhen' = 'mpaas.aliyuncs.com',
    'cn-shenzhen-finance-1' = 'mpaas.aliyuncs.com',
    'cn-shenzhen-inner' = 'mpaas.aliyuncs.com',
    'cn-shenzhen-st4-d01' = 'mpaas.aliyuncs.com',
    'cn-shenzhen-su18-b01' = 'mpaas.aliyuncs.com',
    'cn-wuhan' = 'mpaas.aliyuncs.com',
    'cn-yushanfang' = 'mpaas.aliyuncs.com',
    'cn-zhangbei-na61-b01' = 'mpaas.aliyuncs.com',
    'cn-zhangjiakou' = 'mpaas.aliyuncs.com',
    'cn-zhangjiakou-na62-a01' = 'mpaas.aliyuncs.com',
    'cn-zhengzhou-nebula-1' = 'mpaas.aliyuncs.com',
    'eu-central-1' = 'mpaas.aliyuncs.com',
    'eu-west-1' = 'mpaas.aliyuncs.com',
    'eu-west-1-oxs' = 'mpaas.aliyuncs.com',
    'me-east-1' = 'mpaas.aliyuncs.com',
    'rus-west-1-pop' = 'mpaas.aliyuncs.com',
    'us-east-1' = 'mpaas.aliyuncs.com',
    'us-west-1' = 'mpaas.aliyuncs.com',
  };
}

function close(): void {
  @handler.close();
}

model CancelMpsSchedulerRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  type?: int32(name='Type', position='Body'),
  uniqueIds: string(name='UniqueIds', description='This parameter is required.', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model CancelMpsSchedulerResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: string(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model CancelMpsSchedulerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CancelMpsSchedulerResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CancelMpsScheduler  CancelMpsSchedulerRequest
  * @return CancelMpsSchedulerResponse
 */
async function cancelMpsScheduler(request: CancelMpsSchedulerRequest): CancelMpsSchedulerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CancelMpsScheduler', 'POST', '/', 'json', true, 'form', request);
}

model CancelPushSchedulerRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  type?: int32(name='Type', position='Body'),
  uniqueIds: string(name='UniqueIds', description='This parameter is required.', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model CancelPushSchedulerResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: string(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model CancelPushSchedulerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CancelPushSchedulerResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CancelPushScheduler  CancelPushSchedulerRequest
  * @return CancelPushSchedulerResponse
 */
async function cancelPushScheduler(request: CancelPushSchedulerRequest): CancelPushSchedulerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CancelPushScheduler', 'POST', '/', 'json', true, 'form', request);
}

model ChangeMcubeMiniTaskStatusRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  bizType: string(name='BizType', description='This parameter is required.', position='Body'),
  packageId: long(name='PackageId', description='This parameter is required.', position='Body'),
  taskId: long(name='TaskId', description='This parameter is required.', position='Body'),
  taskStatus: long(name='TaskStatus', description='This parameter is required.', position='Body'),
  tenantId: string(name='TenantId', description='This parameter is required.', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model ChangeMcubeMiniTaskStatusResponseBody = {
  changeMiniTaskStatusResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='ChangeMiniTaskStatusResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ChangeMcubeMiniTaskStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ChangeMcubeMiniTaskStatusResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ChangeMcubeMiniTaskStatus  ChangeMcubeMiniTaskStatusRequest
  * @return ChangeMcubeMiniTaskStatusResponse
 */
async function changeMcubeMiniTaskStatus(request: ChangeMcubeMiniTaskStatusRequest): ChangeMcubeMiniTaskStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ChangeMcubeMiniTaskStatus', 'POST', '/', 'json', true, 'form', request);
}

model ChangeMcubeNebulaTaskStatusRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  bizType?: string(name='BizType', position='Body'),
  packageId?: string(name='PackageId', position='Body'),
  taskId?: string(name='TaskId', position='Body'),
  taskStatus?: int32(name='TaskStatus', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model ChangeMcubeNebulaTaskStatusResponseBody = {
  changeMcubeNebulaTaskStatusResult?: {
    errorCode?: string(name='ErrorCode'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='ChangeMcubeNebulaTaskStatusResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ChangeMcubeNebulaTaskStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ChangeMcubeNebulaTaskStatusResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ChangeMcubeNebulaTaskStatus  ChangeMcubeNebulaTaskStatusRequest
  * @return ChangeMcubeNebulaTaskStatusResponse
 */
async function changeMcubeNebulaTaskStatus(request: ChangeMcubeNebulaTaskStatusRequest): ChangeMcubeNebulaTaskStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ChangeMcubeNebulaTaskStatus', 'POST', '/', 'json', true, 'form', request);
}

model ChangeMcubePublicTaskStatusRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  taskId?: string(name='TaskId', position='Body'),
  taskStatus?: string(name='TaskStatus', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model ChangeMcubePublicTaskStatusResponseBody = {
  changeResult?: {
    errorCode?: string(name='ErrorCode'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='ChangeResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ChangeMcubePublicTaskStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ChangeMcubePublicTaskStatusResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ChangeMcubePublicTaskStatus  ChangeMcubePublicTaskStatusRequest
  * @return ChangeMcubePublicTaskStatusResponse
 */
async function changeMcubePublicTaskStatus(request: ChangeMcubePublicTaskStatusRequest): ChangeMcubePublicTaskStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ChangeMcubePublicTaskStatus', 'POST', '/', 'json', true, 'form', request);
}

model CreateMcubeMiniAppRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  h5Id: string(name='H5Id', description='This parameter is required.', position='Body'),
  h5Name: string(name='H5Name', description='This parameter is required.', position='Body'),
  tenantId: string(name='TenantId', description='This parameter is required.', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model CreateMcubeMiniAppResponseBody = {
  createMiniResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='CreateMiniResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcubeMiniAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMcubeMiniAppResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateMcubeMiniApp  CreateMcubeMiniAppRequest
  * @return CreateMcubeMiniAppResponse
 */
async function createMcubeMiniApp(request: CreateMcubeMiniAppRequest): CreateMcubeMiniAppResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateMcubeMiniApp', 'POST', '/', 'json', true, 'form', request);
}

model CreateMcubeMiniTaskRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  greyConfigInfo?: string(name='GreyConfigInfo', position='Body'),
  greyEndtimeData?: string(name='GreyEndtimeData', position='Body'),
  greyNum?: long(name='GreyNum', position='Body'),
  memo: string(name='Memo', description='This parameter is required.', position='Body'),
  packageId: long(name='PackageId', description='This parameter is required.', position='Body'),
  publishMode: long(name='PublishMode', description='This parameter is required.', position='Body'),
  publishType: long(name='PublishType', description='This parameter is required.', position='Body'),
  tenantId: string(name='TenantId', description='This parameter is required.', position='Body'),
  whitelistIds?: string(name='WhitelistIds', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model CreateMcubeMiniTaskResponseBody = {
  createMiniTaskResult?: {
    miniTaskId?: string(name='MiniTaskId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='CreateMiniTaskResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcubeMiniTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMcubeMiniTaskResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateMcubeMiniTask  CreateMcubeMiniTaskRequest
  * @return CreateMcubeMiniTaskResponse
 */
async function createMcubeMiniTask(request: CreateMcubeMiniTaskRequest): CreateMcubeMiniTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateMcubeMiniTask', 'POST', '/', 'json', true, 'form', request);
}

model CreateMcubeNebulaAppRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  h5Id?: string(name='H5Id', position='Body'),
  h5Name?: string(name='H5Name', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model CreateMcubeNebulaAppResponseBody = {
  createNebulaAppResult?: {
    errorCode?: string(name='ErrorCode'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='CreateNebulaAppResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcubeNebulaAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMcubeNebulaAppResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateMcubeNebulaApp  CreateMcubeNebulaAppRequest
  * @return CreateMcubeNebulaAppResponse
 */
async function createMcubeNebulaApp(request: CreateMcubeNebulaAppRequest): CreateMcubeNebulaAppResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateMcubeNebulaApp', 'POST', '/', 'json', true, 'form', request);
}

model CreateMcubeNebulaResourceRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  autoInstall?: int32(name='AutoInstall', position='Body'),
  clientVersionMax?: string(name='ClientVersionMax', position='Body'),
  clientVersionMin?: string(name='ClientVersionMin', position='Body'),
  customDomainName?: string(name='CustomDomainName', position='Body'),
  extendInfo?: string(name='ExtendInfo', position='Body'),
  fileUrl?: string(name='FileUrl', position='Body'),
  h5Id?: string(name='H5Id', position='Body'),
  h5Name?: string(name='H5Name', position='Body'),
  h5Version?: string(name='H5Version', position='Body'),
  installType?: int32(name='InstallType', position='Body'),
  mainUrl?: string(name='MainUrl', position='Body'),
  onexFlag?: boolean(name='OnexFlag', position='Body'),
  platform?: string(name='Platform', position='Body'),
  repeatNebula?: int32(name='RepeatNebula', position='Body'),
  resourceType?: int32(name='ResourceType', position='Body'),
  subUrl?: string(name='SubUrl', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  vhost?: string(name='Vhost', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model CreateMcubeNebulaResourceResponseBody = {
  createMcubeNebulaResourceReslult?: {
    errorCode?: string(name='ErrorCode'),
    nebulaResourceId?: string(name='NebulaResourceId'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='CreateMcubeNebulaResourceReslult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcubeNebulaResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMcubeNebulaResourceResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateMcubeNebulaResource  CreateMcubeNebulaResourceRequest
  * @return CreateMcubeNebulaResourceResponse
 */
async function createMcubeNebulaResource(request: CreateMcubeNebulaResourceRequest): CreateMcubeNebulaResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateMcubeNebulaResource', 'POST', '/', 'json', true, 'form', request);
}

model CreateMcubeNebulaTaskRequest {
  regionId?: string(name='RegionId', position='Host'),
  appCode?: string(name='AppCode', position='Body'),
  appId?: string(name='AppId', position='Body'),
  bizType?: string(name='BizType', position='Body'),
  creator?: string(name='Creator', position='Body'),
  gmtCreate?: string(name='GmtCreate', position='Body'),
  gmtModified?: string(name='GmtModified', position='Body'),
  gmtModifiedStr?: string(name='GmtModifiedStr', position='Body'),
  greyConfigInfo?: string(name='GreyConfigInfo', position='Body'),
  greyEndtime?: string(name='GreyEndtime', position='Body'),
  greyEndtimeData?: string(name='GreyEndtimeData', position='Body'),
  greyEndtimeStr?: string(name='GreyEndtimeStr', position='Body'),
  greyNum?: int32(name='GreyNum', position='Body'),
  greyUrl?: string(name='GreyUrl', position='Body'),
  id?: long(name='Id', position='Body'),
  memo?: string(name='Memo', position='Body'),
  modifier?: string(name='Modifier', position='Body'),
  packageId?: long(name='PackageId', position='Body'),
  percent?: int32(name='Percent', position='Body'),
  platform?: string(name='Platform', position='Body'),
  productId?: string(name='ProductId', position='Body'),
  productVersion?: string(name='ProductVersion', position='Body'),
  publishMode?: int32(name='PublishMode', position='Body'),
  publishType?: int32(name='PublishType', position='Body'),
  releaseVersion?: string(name='ReleaseVersion', position='Body'),
  resIds?: string(name='ResIds', position='Body'),
  serialVersionUID?: long(name='SerialVersionUID', position='Body'),
  status?: int32(name='Status', position='Body'),
  syncMode?: string(name='SyncMode', position='Body'),
  syncResult?: string(name='SyncResult', position='Body'),
  taskName?: string(name='TaskName', position='Body'),
  taskStatus?: int32(name='TaskStatus', position='Body'),
  taskType?: int32(name='TaskType', position='Body'),
  taskVersion?: long(name='TaskVersion', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  upgradeNoticeNum?: long(name='UpgradeNoticeNum', position='Body'),
  upgradeProgress?: string(name='UpgradeProgress', position='Body'),
  whitelistIds?: string(name='WhitelistIds', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model CreateMcubeNebulaTaskResponseBody = {
  createMcubeNebulaTaskResult?: {
    errorCode?: string(name='ErrorCode'),
    nebulaTaskId?: string(name='NebulaTaskId'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='CreateMcubeNebulaTaskResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcubeNebulaTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMcubeNebulaTaskResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateMcubeNebulaTask  CreateMcubeNebulaTaskRequest
  * @return CreateMcubeNebulaTaskResponse
 */
async function createMcubeNebulaTask(request: CreateMcubeNebulaTaskRequest): CreateMcubeNebulaTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateMcubeNebulaTask', 'POST', '/', 'json', true, 'form', request);
}

model CreateMcubeUpgradePackageRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  appVersion?: string(name='AppVersion', position='Body'),
  appstoreUrl?: string(name='AppstoreUrl', position='Body'),
  bundleId?: string(name='BundleId', position='Body'),
  customDomainName?: string(name='CustomDomainName', position='Body'),
  desc?: string(name='Desc', position='Body'),
  downloadUrl?: string(name='DownloadUrl', position='Body'),
  fileUrl?: string(name='FileUrl', position='Body'),
  iconFileUrl?: string(name='IconFileUrl', position='Body'),
  installAmount?: int32(name='InstallAmount', position='Body'),
  iosSymbolfileUrl?: string(name='IosSymbolfileUrl', position='Body'),
  isEnterprise?: int32(name='IsEnterprise', position='Body'),
  needCheck?: int32(name='NeedCheck', position='Body'),
  onexFlag?: boolean(name='OnexFlag', position='Body'),
  platform?: string(name='Platform', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  validDays?: int32(name='ValidDays', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model CreateMcubeUpgradePackageResponseBody = {
  createUpgradePackageResult?: {
    errorCode?: string(name='ErrorCode'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
    upgradePackageId?: string(name='UpgradePackageId'),
  }(name='CreateUpgradePackageResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcubeUpgradePackageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMcubeUpgradePackageResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateMcubeUpgradePackage  CreateMcubeUpgradePackageRequest
  * @return CreateMcubeUpgradePackageResponse
 */
async function createMcubeUpgradePackage(request: CreateMcubeUpgradePackageRequest): CreateMcubeUpgradePackageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateMcubeUpgradePackage', 'POST', '/', 'json', true, 'form', request);
}

model CreateMcubeUpgradeTaskRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  greyConfigInfo?: string(name='GreyConfigInfo', position='Body'),
  greyEndtimeData?: string(name='GreyEndtimeData', position='Body'),
  greyNum?: int32(name='GreyNum', position='Body'),
  historyForce?: int32(name='HistoryForce', position='Body'),
  memo?: string(name='Memo', position='Body'),
  packageInfoId?: long(name='PackageInfoId', position='Body'),
  publishMode?: int32(name='PublishMode', position='Body'),
  publishType?: int32(name='PublishType', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  upgradeContent?: string(name='UpgradeContent', position='Body'),
  upgradeType?: int32(name='UpgradeType', position='Body'),
  whitelistIds?: string(name='WhitelistIds', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model CreateMcubeUpgradeTaskResponseBody = {
  createTaskResult?: {
    errorCode?: string(name='ErrorCode'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
    upgradeTaskId?: string(name='UpgradeTaskId'),
  }(name='CreateTaskResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcubeUpgradeTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMcubeUpgradeTaskResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateMcubeUpgradeTask  CreateMcubeUpgradeTaskRequest
  * @return CreateMcubeUpgradeTaskResponse
 */
async function createMcubeUpgradeTask(request: CreateMcubeUpgradeTaskRequest): CreateMcubeUpgradeTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateMcubeUpgradeTask', 'POST', '/', 'json', true, 'form', request);
}

model CreateMcubeVhostRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  tenantId: string(name='TenantId', description='This parameter is required.', position='Body'),
  vhost: string(name='Vhost', description='This parameter is required.', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model CreateMcubeVhostResponseBody = {
  createVhostResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='CreateVhostResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcubeVhostResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMcubeVhostResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateMcubeVhost  CreateMcubeVhostRequest
  * @return CreateMcubeVhostResponse
 */
async function createMcubeVhost(request: CreateMcubeVhostRequest): CreateMcubeVhostResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateMcubeVhost', 'POST', '/', 'json', true, 'form', request);
}

model CreateMcubeWhitelistRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  tenantId: string(name='TenantId', description='This parameter is required.', position='Body'),
  whiteListName: string(name='WhiteListName', description='This parameter is required.', position='Body'),
  whitelistType: string(name='WhitelistType', description='This parameter is required.', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model CreateMcubeWhitelistResponseBody = {
  createWhitelistResult?: {
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
    whitelistId?: string(name='WhitelistId'),
  }(name='CreateWhitelistResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcubeWhitelistResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMcubeWhitelistResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateMcubeWhitelist  CreateMcubeWhitelistRequest
  * @return CreateMcubeWhitelistResponse
 */
async function createMcubeWhitelist(request: CreateMcubeWhitelistRequest): CreateMcubeWhitelistResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateMcubeWhitelist', 'POST', '/', 'json', true, 'form', request);
}

model CreateMcubeWhitelistForIdeRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  tenantId: string(name='TenantId', description='This parameter is required.', position='Body'),
  userId: string(name='UserId', description='This parameter is required.', position='Body'),
  whitelistValue: string(name='WhitelistValue', description='This parameter is required.', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model CreateMcubeWhitelistForIdeResponseBody = {
  createWhitelistForIdeResult?: {
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
    whitelistId?: string(name='WhitelistId'),
  }(name='CreateWhitelistForIdeResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcubeWhitelistForIdeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMcubeWhitelistForIdeResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateMcubeWhitelistForIde  CreateMcubeWhitelistForIdeRequest
  * @return CreateMcubeWhitelistForIdeResponse
 */
async function createMcubeWhitelistForIde(request: CreateMcubeWhitelistForIdeRequest): CreateMcubeWhitelistForIdeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateMcubeWhitelistForIde', 'POST', '/', 'json', true, 'form', request);
}

model CreateOpenGlobalDataRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  appMaxVersion?: string(name='AppMaxVersion', position='Body'),
  appMinVersion?: string(name='AppMinVersion', position='Body'),
  bizType: string(name='BizType', description='This parameter is required.', position='Body'),
  extAttrStr?: string(name='ExtAttrStr', position='Body'),
  maxUid?: long(name='MaxUid', position='Body'),
  minUid?: long(name='MinUid', position='Body'),
  osType?: string(name='OsType', position='Body'),
  payload: string(name='Payload', description='This parameter is required.', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  thirdMsgId: string(name='ThirdMsgId', description='This parameter is required.', position='Body'),
  uids?: string(name='Uids', position='Body'),
  validTimeEnd?: long(name='ValidTimeEnd', position='Body'),
  validTimeStart?: long(name='ValidTimeStart', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model CreateOpenGlobalDataResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateOpenGlobalDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateOpenGlobalDataResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateOpenGlobalData  CreateOpenGlobalDataRequest
  * @return CreateOpenGlobalDataResponse
 */
async function createOpenGlobalData(request: CreateOpenGlobalDataRequest): CreateOpenGlobalDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateOpenGlobalData', 'POST', '/', 'json', true, 'form', request);
}

model CreateOpenSingleDataRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  appMaxVersion?: string(name='AppMaxVersion', position='Body'),
  appMinVersion?: string(name='AppMinVersion', position='Body'),
  bizType: string(name='BizType', description='This parameter is required.', position='Body'),
  checkOnline?: boolean(name='CheckOnline', position='Body'),
  extAttrStr?: string(name='ExtAttrStr', position='Body'),
  linkToken: string(name='LinkToken', description='This parameter is required.', position='Body'),
  osType?: string(name='OsType', position='Body'),
  payload: string(name='Payload', description='This parameter is required.', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  thirdMsgId: string(name='ThirdMsgId', description='This parameter is required.', position='Body'),
  validTimeEnd?: long(name='ValidTimeEnd', position='Body'),
  validTimeStart?: long(name='ValidTimeStart', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model CreateOpenSingleDataResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateOpenSingleDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateOpenSingleDataResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateOpenSingleData  CreateOpenSingleDataRequest
  * @return CreateOpenSingleDataResponse
 */
async function createOpenSingleData(request: CreateOpenSingleDataRequest): CreateOpenSingleDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateOpenSingleData', 'POST', '/', 'json', true, 'form', request);
}

model CreateTemplateRequest {
  appId?: string(name='AppId', example='ALIPUB9A63274111812', position='Body'),
  content?: string(name='Content', example='hh', position='Body'),
  descInfo?: string(name='DescInfo', position='Body'),
  iconUrls?: string(name='IconUrls', example='{"defaultUrl": "http://111"}', position='Body'),
  imageUrls?: string(name='ImageUrls', example='{"defaultUrl": "http://111"}', position='Body'),
  jumpAction?: int32(name='JumpAction', example='0', position='Body'),
  pushStyle?: int32(name='PushStyle', example='0', position='Body'),
  showStyle?: long(name='ShowStyle', example='0', position='Body'),
  templateName?: string(name='TemplateName', position='Body'),
  tenantId?: string(name='TenantId', example='NPHTGKNR', position='Body'),
  title?: string(name='Title', example='OKOK', position='Body'),
  uri?: string(name='Uri', example='https://jsonplaceholder.typicode.com/nonexistent', position='Body'),
  variables?: string(name='Variables', example='title,content', position='Body'),
  workspaceId?: string(name='WorkspaceId', example='default', position='Body'),
}

model CreateTemplateResponseBody = {
  code?: string(name='Code', example='100'),
  data?: string(name='Data', example='null'),
  msg?: string(name='Msg', example='SUCCESS'),
  requestId?: string(name='RequestId', description='Id of the request', example='0CC8A9CB-9BA3-13FD-A404-6E2E7461881A'),
  success?: boolean(name='Success', example='True'),
}

model CreateTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateTemplateResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateTemplate  CreateTemplateRequest
  * @return CreateTemplateResponse
 */
async function createTemplate(request: CreateTemplateRequest): CreateTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateTemplate', 'POST', '/', 'json', true, 'form', request);
}

model DeleteCubecardWhitelistContentRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  whitelistId?: string(name='WhitelistId', position='Body'),
  whitelistValue?: string(name='WhitelistValue', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model DeleteCubecardWhitelistContentResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: {
      content?: string(name='Content'),
      errorCode?: string(name='ErrorCode'),
      resultMsg?: string(name='ResultMsg'),
      success?: boolean(name='Success'),
    }(name='Data'),
    requestId?: string(name='RequestId'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model DeleteCubecardWhitelistContentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteCubecardWhitelistContentResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteCubecardWhitelistContent  DeleteCubecardWhitelistContentRequest
  * @return DeleteCubecardWhitelistContentResponse
 */
async function deleteCubecardWhitelistContent(request: DeleteCubecardWhitelistContentRequest): DeleteCubecardWhitelistContentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteCubecardWhitelistContent', 'POST', '/', 'json', true, 'form', request);
}

model DeleteMcubeMiniAppRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  h5Id: string(name='H5Id', description='This parameter is required.', position='Body'),
  tenantId: string(name='TenantId', description='This parameter is required.', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model DeleteMcubeMiniAppResponseBody = {
  deleteMiniResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='DeleteMiniResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model DeleteMcubeMiniAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteMcubeMiniAppResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteMcubeMiniApp  DeleteMcubeMiniAppRequest
  * @return DeleteMcubeMiniAppResponse
 */
async function deleteMcubeMiniApp(request: DeleteMcubeMiniAppRequest): DeleteMcubeMiniAppResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteMcubeMiniApp', 'POST', '/', 'json', true, 'form', request);
}

model DeleteMcubeNebulaAppRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  h5Id?: string(name='H5Id', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model DeleteMcubeNebulaAppResponseBody = {
  deleteMcubeNebulaAppResult?: {
    errorCode?: string(name='ErrorCode'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='DeleteMcubeNebulaAppResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model DeleteMcubeNebulaAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteMcubeNebulaAppResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteMcubeNebulaApp  DeleteMcubeNebulaAppRequest
  * @return DeleteMcubeNebulaAppResponse
 */
async function deleteMcubeNebulaApp(request: DeleteMcubeNebulaAppRequest): DeleteMcubeNebulaAppResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteMcubeNebulaApp', 'POST', '/', 'json', true, 'form', request);
}

model DeleteMcubeUpgradeResourceRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  id?: string(name='Id', position='Body'),
  platform?: string(name='Platform', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model DeleteMcubeUpgradeResourceResponseBody = {
  deleteResult?: {
    errorCode?: string(name='ErrorCode'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='DeleteResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model DeleteMcubeUpgradeResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteMcubeUpgradeResourceResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteMcubeUpgradeResource  DeleteMcubeUpgradeResourceRequest
  * @return DeleteMcubeUpgradeResourceResponse
 */
async function deleteMcubeUpgradeResource(request: DeleteMcubeUpgradeResourceRequest): DeleteMcubeUpgradeResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteMcubeUpgradeResource', 'POST', '/', 'json', true, 'form', request);
}

model DeleteMcubeWhitelistRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  id: long(name='Id', description='This parameter is required.', position='Body'),
  tenantId: string(name='TenantId', description='This parameter is required.', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model DeleteMcubeWhitelistResponseBody = {
  deleteWhitelistResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='DeleteWhitelistResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model DeleteMcubeWhitelistResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteMcubeWhitelistResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteMcubeWhitelist  DeleteMcubeWhitelistRequest
  * @return DeleteMcubeWhitelistResponse
 */
async function deleteMcubeWhitelist(request: DeleteMcubeWhitelistRequest): DeleteMcubeWhitelistResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteMcubeWhitelist', 'POST', '/', 'json', true, 'form', request);
}

model DeleteMdsWhitelistContentRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  whitelistId?: string(name='WhitelistId', position='Body'),
  whitelistValue?: string(name='WhitelistValue', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model DeleteMdsWhitelistContentResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: {
      content?: string(name='Content'),
      errorCode?: string(name='ErrorCode'),
      resultMsg?: string(name='ResultMsg'),
      success?: boolean(name='Success'),
    }(name='Data'),
    requestId?: string(name='RequestId'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model DeleteMdsWhitelistContentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteMdsWhitelistContentResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteMdsWhitelistContent  DeleteMdsWhitelistContentRequest
  * @return DeleteMdsWhitelistContentResponse
 */
async function deleteMdsWhitelistContent(request: DeleteMdsWhitelistContentRequest): DeleteMdsWhitelistContentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteMdsWhitelistContent', 'POST', '/', 'json', true, 'form', request);
}

model DeleteTemplateRequest {
  appId?: string(name='AppId', example='ALIPUBE5C3F6D091419', position='Body'),
  templateId?: string(name='TemplateId', example='COEYM44ER0465E8G', position='Body'),
  templateName?: string(name='TemplateName', position='Body'),
  tenantId?: string(name='TenantId', example='NPHTGKNR', position='Body'),
  workspaceId?: string(name='WorkspaceId', example='default', position='Body'),
}

model DeleteTemplateResponseBody = {
  code?: string(name='Code', example='100'),
  msg?: string(name='Msg', example='SUCCESS'),
  requestId?: string(name='RequestId', description='Id of the request', example='11E66B29-9E5E-5C10-B64E-B5A0E0F26355'),
  success?: boolean(name='Success', example='true'),
}

model DeleteTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteTemplateResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteTemplate  DeleteTemplateRequest
  * @return DeleteTemplateResponse
 */
async function deleteTemplate(request: DeleteTemplateRequest): DeleteTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteTemplate', 'POST', '/', 'json', true, 'form', request);
}

model ExistMcubeRsaKeyRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  tenantId: string(name='TenantId', description='This parameter is required.', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model ExistMcubeRsaKeyResponseBody = {
  checkRsaKeyResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='CheckRsaKeyResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ExistMcubeRsaKeyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ExistMcubeRsaKeyResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ExistMcubeRsaKey  ExistMcubeRsaKeyRequest
  * @return ExistMcubeRsaKeyResponse
 */
async function existMcubeRsaKey(request: ExistMcubeRsaKeyRequest): ExistMcubeRsaKeyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ExistMcubeRsaKey', 'POST', '/', 'json', true, 'form', request);
}

model GetMcubeFileTokenRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  onexFlag: boolean(name='OnexFlag', description='This parameter is required.', position='Body'),
  tenantId: string(name='TenantId', description='This parameter is required.', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model GetMcubeFileTokenResponseBody = {
  getFileTokenResult?: {
    fileToken?: {
      accessid?: string(name='Accessid'),
      dir?: string(name='Dir'),
      expire?: string(name='Expire'),
      host?: string(name='Host'),
      policy?: string(name='Policy'),
      signature?: string(name='Signature'),
    }(name='FileToken'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='GetFileTokenResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model GetMcubeFileTokenResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMcubeFileTokenResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetMcubeFileToken  GetMcubeFileTokenRequest
  * @return GetMcubeFileTokenResponse
 */
async function getMcubeFileToken(request: GetMcubeFileTokenRequest): GetMcubeFileTokenResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMcubeFileToken', 'POST', '/', 'json', true, 'form', request);
}

model GetMcubeNebulaResourceRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  id?: string(name='Id', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model GetMcubeNebulaResourceResponseBody = {
  getNebulaResourceResult?: {
    errorCode?: string(name='ErrorCode'),
    nebulaResourceInfo?: {
      appCode?: string(name='AppCode'),
      autoInstall?: int32(name='AutoInstall'),
      clientVersionMax?: string(name='ClientVersionMax'),
      clientVersionMin?: string(name='ClientVersionMin'),
      creator?: string(name='Creator'),
      downloadUrl?: string(name='DownloadUrl'),
      extendInfo?: string(name='ExtendInfo'),
      extraData?: string(name='ExtraData'),
      fallbackBaseUrl?: string(name='FallbackBaseUrl'),
      fileSize?: string(name='FileSize'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      h5Id?: string(name='H5Id'),
      h5Name?: string(name='H5Name'),
      h5Version?: string(name='H5Version'),
      id?: long(name='Id'),
      installType?: int32(name='InstallType'),
      mainUrl?: string(name='MainUrl'),
      memo?: string(name='Memo'),
      metaId?: long(name='MetaId'),
      modifier?: string(name='Modifier'),
      packageType?: int32(name='PackageType'),
      platform?: string(name='Platform'),
      publishPeriod?: int32(name='PublishPeriod'),
      resourceType?: string(name='ResourceType'),
      status?: int32(name='Status'),
      vhost?: string(name='Vhost'),
    }(name='NebulaResourceInfo'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='GetNebulaResourceResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model GetMcubeNebulaResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMcubeNebulaResourceResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetMcubeNebulaResource  GetMcubeNebulaResourceRequest
  * @return GetMcubeNebulaResourceResponse
 */
async function getMcubeNebulaResource(request: GetMcubeNebulaResourceRequest): GetMcubeNebulaResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMcubeNebulaResource', 'POST', '/', 'json', true, 'form', request);
}

model GetMcubeNebulaTaskDetailRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  taskId?: long(name='TaskId', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model GetMcubeNebulaTaskDetailResponseBody = {
  getMcubeNebulaTaskDetailResult?: {
    errorCode?: string(name='ErrorCode'),
    nebulaTaskDetail?: {
      appCode?: string(name='AppCode'),
      appId?: string(name='AppId'),
      atomic?: int32(name='Atomic'),
      baseInfoId?: long(name='BaseInfoId'),
      bizType?: string(name='BizType'),
      creator?: string(name='Creator'),
      cronexpress?: int32(name='Cronexpress'),
      downloadUrl?: string(name='DownloadUrl'),
      extraData?: string(name='ExtraData'),
      fileSize?: string(name='FileSize'),
      fullRepair?: int32(name='FullRepair'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      gmtModifiedStr?: string(name='GmtModifiedStr'),
      greyConfigInfo?: string(name='GreyConfigInfo'),
      greyEndtime?: string(name='GreyEndtime'),
      greyEndtimeData?: string(name='GreyEndtimeData'),
      greyEndtimeStr?: string(name='GreyEndtimeStr'),
      greyNum?: int32(name='GreyNum'),
      greyUrl?: string(name='GreyUrl'),
      id?: long(name='Id'),
      issueDesc?: string(name='IssueDesc'),
      memo?: string(name='Memo'),
      modifier?: string(name='Modifier'),
      ossPath?: string(name='OssPath'),
      packageId?: long(name='PackageId'),
      percent?: int32(name='Percent'),
      platform?: string(name='Platform'),
      productId?: string(name='ProductId'),
      productVersion?: string(name='ProductVersion'),
      publishMode?: int32(name='PublishMode'),
      publishPeriod?: int32(name='PublishPeriod'),
      publishType?: int32(name='PublishType'),
      quickRollback?: int32(name='QuickRollback'),
      releaseVersion?: string(name='ReleaseVersion'),
      ruleJsonList?: [ 
        {
          operation?: string(name='Operation'),
          ruleElement?: string(name='RuleElement'),
          ruleType?: string(name='RuleType'),
          value?: string(name='Value'),
        }
      ](name='RuleJsonList'),
      sourceId?: string(name='SourceId'),
      sourceName?: string(name='SourceName'),
      sourceType?: string(name='SourceType'),
      status?: int32(name='Status'),
      syncResult?: string(name='SyncResult'),
      syncType?: int32(name='SyncType'),
      taskName?: string(name='TaskName'),
      taskStatus?: int32(name='TaskStatus'),
      taskType?: int32(name='TaskType'),
      taskVersion?: long(name='TaskVersion'),
      upgradeNoticeNum?: long(name='UpgradeNoticeNum'),
      upgradeProgress?: string(name='UpgradeProgress'),
      whitelistIds?: string(name='WhitelistIds'),
      workspaceId?: string(name='WorkspaceId'),
    }(name='NebulaTaskDetail'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='GetMcubeNebulaTaskDetailResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model GetMcubeNebulaTaskDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMcubeNebulaTaskDetailResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetMcubeNebulaTaskDetail  GetMcubeNebulaTaskDetailRequest
  * @return GetMcubeNebulaTaskDetailResponse
 */
async function getMcubeNebulaTaskDetail(request: GetMcubeNebulaTaskDetailRequest): GetMcubeNebulaTaskDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMcubeNebulaTaskDetail', 'POST', '/', 'json', true, 'form', request);
}

model GetMcubeUpgradePackageInfoRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  packageId?: long(name='PackageId', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model GetMcubeUpgradePackageInfoResponseBody = {
  getPackageResult?: {
    errorCode?: string(name='ErrorCode'),
    packageInfo?: {
      mobileTestFlightConfigDO?: {
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        id?: long(name='Id'),
        installAmount?: int32(name='InstallAmount'),
        invalidTime?: string(name='InvalidTime'),
        upgradeId?: long(name='UpgradeId'),
      }(name='MobileTestFlightConfigDO'),
      upgradeBaseInfoDO?: {
        allowCreateTask?: boolean(name='AllowCreateTask'),
        appCode?: string(name='AppCode'),
        appstoreUrl?: string(name='AppstoreUrl'),
        changeLog?: string(name='ChangeLog'),
        creator?: string(name='Creator'),
        downloadUrl?: string(name='DownloadUrl'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        id?: long(name='Id'),
        isEnterprise?: int32(name='IsEnterprise'),
        modifier?: string(name='Modifier'),
        needCheck?: int32(name='NeedCheck'),
        packageType?: string(name='PackageType'),
        platform?: string(name='Platform'),
        productId?: string(name='ProductId'),
        productName?: string(name='ProductName'),
        productVersion?: string(name='ProductVersion'),
        publishPeriod?: int32(name='PublishPeriod'),
        verificationCode?: string(name='VerificationCode'),
      }(name='UpgradeBaseInfoDO'),
    }(name='PackageInfo'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='GetPackageResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model GetMcubeUpgradePackageInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMcubeUpgradePackageInfoResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetMcubeUpgradePackageInfo  GetMcubeUpgradePackageInfoRequest
  * @return GetMcubeUpgradePackageInfoResponse
 */
async function getMcubeUpgradePackageInfo(request: GetMcubeUpgradePackageInfoRequest): GetMcubeUpgradePackageInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMcubeUpgradePackageInfo', 'POST', '/', 'json', true, 'form', request);
}

model GetMcubeUpgradeTaskInfoRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  taskId?: long(name='TaskId', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model GetMcubeUpgradeTaskInfoResponseBody = {
  getTaskResult?: {
    errorCode?: string(name='ErrorCode'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
    taskInfo?: {
      appCode?: string(name='AppCode'),
      appId?: string(name='AppId'),
      appstoreUrl?: string(name='AppstoreUrl'),
      creator?: string(name='Creator'),
      downloadUrl?: string(name='DownloadUrl'),
      greyConfigInfo?: string(name='GreyConfigInfo'),
      greyEndtimeData?: string(name='GreyEndtimeData'),
      greyNum?: int32(name='GreyNum'),
      historyForce?: int32(name='HistoryForce'),
      id?: long(name='Id'),
      isEnterprise?: int32(name='IsEnterprise'),
      memo?: string(name='Memo'),
      modifier?: string(name='Modifier'),
      packageInfoId?: long(name='PackageInfoId'),
      packageType?: string(name='PackageType'),
      platform?: string(name='Platform'),
      productId?: string(name='ProductId'),
      publishMode?: int32(name='PublishMode'),
      publishType?: int32(name='PublishType'),
      ruleJsonList?: [ 
        {
          operation?: string(name='Operation'),
          ruleElement?: string(name='RuleElement'),
          ruleType?: string(name='RuleType'),
          value?: string(name='Value'),
        }
      ](name='RuleJsonList'),
      silentType?: int32(name='SilentType'),
      taskStatus?: int32(name='TaskStatus'),
      upgradeContent?: string(name='UpgradeContent'),
      upgradeType?: int32(name='UpgradeType'),
      upgradeValidTime?: int32(name='UpgradeValidTime'),
      whitelist?: [ 
        {
          appCode?: string(name='AppCode'),
          id?: long(name='Id'),
          idType?: string(name='IdType'),
          platform?: string(name='Platform'),
          status?: int32(name='Status'),
          userType?: string(name='UserType'),
          whiteListCount?: long(name='WhiteListCount'),
          whiteListName?: string(name='WhiteListName'),
          whitelistType?: string(name='WhitelistType'),
        }
      ](name='Whitelist'),
      whitelistIds?: string(name='WhitelistIds'),
      workspaceId?: string(name='WorkspaceId'),
    }(name='TaskInfo'),
  }(name='GetTaskResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model GetMcubeUpgradeTaskInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMcubeUpgradeTaskInfoResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetMcubeUpgradeTaskInfo  GetMcubeUpgradeTaskInfoRequest
  * @return GetMcubeUpgradeTaskInfoResponse
 */
async function getMcubeUpgradeTaskInfo(request: GetMcubeUpgradeTaskInfoRequest): GetMcubeUpgradeTaskInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMcubeUpgradeTaskInfo', 'POST', '/', 'json', true, 'form', request);
}

model GetTemplateRequest {
  appId?: string(name='AppId', example='ALIPUBE5C3F6D091419', position='Body'),
  templateId?: string(name='TemplateId', example='146552', position='Body'),
  templateName?: string(name='TemplateName', position='Body'),
  tenantId?: string(name='TenantId', example='CGAKLRCS', position='Body'),
  workspaceId?: string(name='WorkspaceId', example='default', position='Body'),
}

model GetTemplateResponseBody = {
  code?: string(name='Code', example='100'),
  data?: {
    action?: string(name='Action', example='1'),
    content?: string(name='Content'),
    descInfo?: string(name='DescInfo'),
    gmtCreate?: string(name='GmtCreate', example='1740479834'),
    gmtModified?: string(name='GmtModified', example='1745337419999'),
    iconUrls?: string(name='IconUrls', example='/'),
    id?: string(name='Id', example='123'),
    imageUrls?: string(name='ImageUrls', example='/'),
    name?: string(name='Name'),
    pushStyle?: string(name='PushStyle', example='0'),
    showStyle?: string(name='ShowStyle', example='0'),
    title?: string(name='Title'),
    uri?: string(name='Uri', example='/'),
    variables?: string(name='Variables', example='title,content'),
  }(name='Data'),
  msg?: string(name='Msg', example='success'),
  requestId?: string(name='RequestId', description='Id of the request', example='11E66B29-9E5E-5C10-B64E-B5A0E0F26355'),
  success?: boolean(name='Success', example='true'),
}

model GetTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetTemplateResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetTemplate  GetTemplateRequest
  * @return GetTemplateResponse
 */
async function getTemplate(request: GetTemplateRequest): GetTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetTemplate', 'POST', '/', 'json', true, 'form', request);
}

model ListAnalysisCoreIndexRequest {
  appId?: string(name='AppId', example='ALIPUBE5C3F6D091419', position='Body'),
  channel?: string(name='Channel', example='miui', position='Body'),
  endTime?: long(name='EndTime', example='1756051200000', position='Body'),
  platform?: string(name='Platform', example='Android', position='Body'),
  startTime?: long(name='StartTime', example='1756051200000', position='Body'),
  taskId?: string(name='TaskId', example='546797740032', position='Body'),
  tenantId?: string(name='TenantId', example='CGAKLRCS', position='Body'),
  type?: string(name='Type', example='2', position='Body'),
  workspaceId?: string(name='WorkspaceId', example='dev', position='Body'),
}

model ListAnalysisCoreIndexResponseBody = {
  requestId?: string(name='RequestId', example='11E66B29-9E5E-5C10-B64E-B5A0E0F26355'),
  resultCode?: string(name='ResultCode', example='100'),
  resultContent?: {
    data?: {
      arrivalNum?: string(name='ArrivalNum', example='0'),
      arrivalRate?: string(name='ArrivalRate', example='0'),
      ignoreNum?: string(name='IgnoreNum', example='0'),
      ignoreRate?: string(name='IgnoreRate', example='0'),
      openNum?: string(name='OpenNum', example='0'),
      openRate?: string(name='OpenRate', example='0'),
      pushNum?: string(name='PushNum', example='0'),
      pushTotalNum?: string(name='PushTotalNum', example='0'),
    }(name='Data'),
    resultMsg?: string(name='ResultMsg', example=''),
    success?: boolean(name='Success', example='true'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage', example='success'),
  success?: boolean(name='Success', example='true'),
}

model ListAnalysisCoreIndexResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAnalysisCoreIndexResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListAnalysisCoreIndex  ListAnalysisCoreIndexRequest
  * @return ListAnalysisCoreIndexResponse
 */
async function listAnalysisCoreIndex(request: ListAnalysisCoreIndexRequest): ListAnalysisCoreIndexResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListAnalysisCoreIndex', 'POST', '/', 'json', true, 'form', request);
}

model ListMcubeMiniAppsRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  keyword?: string(name='Keyword', position='Body'),
  pageNum?: int32(name='PageNum', position='Body'),
  pageSize?: int32(name='PageSize', position='Body'),
  tenantId: string(name='TenantId', description='This parameter is required.', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model ListMcubeMiniAppsResponseBody = {
  listMiniResult?: {
    currentPage?: int32(name='CurrentPage'),
    hasMore?: boolean(name='HasMore'),
    miniProgramList?: [ 
      {
        appCode?: string(name='AppCode'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        h5Id?: string(name='H5Id'),
        h5Name?: string(name='H5Name'),
      }
    ](name='MiniProgramList'),
    pageSize?: int32(name='PageSize'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
    totalCount?: long(name='TotalCount'),
  }(name='ListMiniResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMcubeMiniAppsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMcubeMiniAppsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListMcubeMiniApps  ListMcubeMiniAppsRequest
  * @return ListMcubeMiniAppsResponse
 */
async function listMcubeMiniApps(request: ListMcubeMiniAppsRequest): ListMcubeMiniAppsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListMcubeMiniApps', 'POST', '/', 'json', true, 'form', request);
}

model ListMcubeMiniPackagesRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  h5Id: string(name='H5Id', description='This parameter is required.', position='Body'),
  packageTypes: string(name='PackageTypes', description='This parameter is required.', position='Body'),
  pageNum?: int32(name='PageNum', position='Body'),
  pageSize?: int32(name='PageSize', position='Body'),
  tenantId: string(name='TenantId', description='This parameter is required.', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model ListMcubeMiniPackagesResponseBody = {
  listMiniPackageResult?: {
    currentPage?: int32(name='CurrentPage'),
    hasMore?: boolean(name='HasMore'),
    miniPackageList?: [ 
      {
        appCode?: string(name='AppCode'),
        autoInstall?: long(name='AutoInstall'),
        clientVersionMax?: string(name='ClientVersionMax'),
        clientVersionMin?: string(name='ClientVersionMin'),
        downloadUrl?: string(name='DownloadUrl'),
        extendInfo?: string(name='ExtendInfo'),
        extraData?: string(name='ExtraData'),
        fallbackBaseUrl?: string(name='FallbackBaseUrl'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        h5Id?: string(name='H5Id'),
        h5Name?: string(name='H5Name'),
        h5Version?: string(name='H5Version'),
        id?: long(name='Id'),
        installType?: long(name='InstallType'),
        mainUrl?: string(name='MainUrl'),
        memo?: string(name='Memo'),
        packageType?: long(name='PackageType'),
        platform?: string(name='Platform'),
        publishPeriod?: long(name='PublishPeriod'),
        resourceType?: long(name='ResourceType'),
        status?: long(name='Status'),
      }
    ](name='MiniPackageList'),
    pageSize?: int32(name='PageSize'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
    totalCount?: long(name='TotalCount'),
  }(name='ListMiniPackageResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMcubeMiniPackagesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMcubeMiniPackagesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListMcubeMiniPackages  ListMcubeMiniPackagesRequest
  * @return ListMcubeMiniPackagesResponse
 */
async function listMcubeMiniPackages(request: ListMcubeMiniPackagesRequest): ListMcubeMiniPackagesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListMcubeMiniPackages', 'POST', '/', 'json', true, 'form', request);
}

model ListMcubeMiniTasksRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  id: string(name='Id', description='This parameter is required.', position='Body'),
  tenantId: string(name='TenantId', description='This parameter is required.', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model ListMcubeMiniTasksResponseBody = {
  listMiniTaskResult?: {
    miniTaskList?: [ 
      {
        appCode?: string(name='AppCode'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        greyConfigInfo?: string(name='GreyConfigInfo'),
        greyEndtime?: string(name='GreyEndtime'),
        greyEndtimeData?: string(name='GreyEndtimeData'),
        greyNum?: long(name='GreyNum'),
        id?: long(name='Id'),
        memo?: string(name='Memo'),
        packageId?: long(name='PackageId'),
        platform?: string(name='Platform'),
        productVersion?: string(name='ProductVersion'),
        publishMode?: long(name='PublishMode'),
        publishType?: long(name='PublishType'),
        status?: string(name='Status'),
        taskStatus?: long(name='TaskStatus'),
        whitelistIds?: string(name='WhitelistIds'),
      }
    ](name='MiniTaskList'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='ListMiniTaskResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMcubeMiniTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMcubeMiniTasksResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListMcubeMiniTasks  ListMcubeMiniTasksRequest
  * @return ListMcubeMiniTasksResponse
 */
async function listMcubeMiniTasks(request: ListMcubeMiniTasksRequest): ListMcubeMiniTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListMcubeMiniTasks', 'POST', '/', 'json', true, 'form', request);
}

model ListMcubeNebulaAppsRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  keyword?: string(name='Keyword', position='Body'),
  pageNum?: int32(name='PageNum', position='Body'),
  pageSize?: int32(name='PageSize', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model ListMcubeNebulaAppsResponseBody = {
  listMcubeNebulaAppsResult?: {
    currentPage?: int32(name='CurrentPage'),
    errorCode?: string(name='ErrorCode'),
    hasMore?: boolean(name='HasMore'),
    nebulaAppInfos?: [ 
      {
        h5Id?: string(name='H5Id'),
        h5Name?: string(name='H5Name'),
      }
    ](name='NebulaAppInfos'),
    pageSize?: int32(name='PageSize'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
    totalCount?: long(name='TotalCount'),
  }(name='ListMcubeNebulaAppsResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMcubeNebulaAppsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMcubeNebulaAppsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListMcubeNebulaApps  ListMcubeNebulaAppsRequest
  * @return ListMcubeNebulaAppsResponse
 */
async function listMcubeNebulaApps(request: ListMcubeNebulaAppsRequest): ListMcubeNebulaAppsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListMcubeNebulaApps', 'POST', '/', 'json', true, 'form', request);
}

model ListMcubeNebulaResourcesRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  h5Id?: string(name='H5Id', position='Body'),
  pageNum?: int32(name='PageNum', position='Body'),
  pageSize?: int32(name='PageSize', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model ListMcubeNebulaResourcesResponseBody = {
  listMcubeNebulaResourceResult?: {
    currentPage?: int32(name='CurrentPage'),
    errorCode?: string(name='ErrorCode'),
    hasMore?: boolean(name='HasMore'),
    nebulaResourceInfo?: [ 
      {
        appCode?: string(name='AppCode'),
        autoInstall?: int32(name='AutoInstall'),
        clientVersionMax?: string(name='ClientVersionMax'),
        clientVersionMin?: string(name='ClientVersionMin'),
        creator?: string(name='Creator'),
        debugUrl?: string(name='DebugUrl'),
        downloadUrl?: string(name='DownloadUrl'),
        extendInfo?: string(name='ExtendInfo'),
        extraData?: string(name='ExtraData'),
        fallbackBaseUrl?: string(name='FallbackBaseUrl'),
        fileSize?: string(name='FileSize'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        h5Id?: string(name='H5Id'),
        h5Name?: string(name='H5Name'),
        h5Version?: string(name='H5Version'),
        id?: long(name='Id'),
        installType?: int32(name='InstallType'),
        lazyLoad?: int32(name='LazyLoad'),
        mainUrl?: string(name='MainUrl'),
        md5?: string(name='Md5'),
        memo?: string(name='Memo'),
        metaId?: long(name='MetaId'),
        modifier?: string(name='Modifier'),
        packageType?: int32(name='PackageType'),
        platform?: string(name='Platform'),
        publishPeriod?: int32(name='PublishPeriod'),
        releaseVersion?: string(name='ReleaseVersion'),
        resourceType?: string(name='ResourceType'),
        status?: int32(name='Status'),
        vhost?: string(name='Vhost'),
      }
    ](name='NebulaResourceInfo'),
    pageSize?: int32(name='PageSize'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
    totalCount?: long(name='TotalCount'),
  }(name='ListMcubeNebulaResourceResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMcubeNebulaResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMcubeNebulaResourcesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListMcubeNebulaResources  ListMcubeNebulaResourcesRequest
  * @return ListMcubeNebulaResourcesResponse
 */
async function listMcubeNebulaResources(request: ListMcubeNebulaResourcesRequest): ListMcubeNebulaResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListMcubeNebulaResources', 'POST', '/', 'json', true, 'form', request);
}

model ListMcubeNebulaTasksRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  id?: long(name='Id', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model ListMcubeNebulaTasksResponseBody = {
  listMcubeNebulaTaskResult?: {
    errorCode?: string(name='ErrorCode'),
    nebulaTaskInfo?: [ 
      {
        appCode?: string(name='AppCode'),
        bizType?: string(name='BizType'),
        creator?: string(name='Creator'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        gmtModifiedStr?: string(name='GmtModifiedStr'),
        greyConfigInfo?: string(name='GreyConfigInfo'),
        greyEndtime?: string(name='GreyEndtime'),
        greyEndtimeData?: string(name='GreyEndtimeData'),
        greyEndtimeStr?: string(name='GreyEndtimeStr'),
        greyNum?: int32(name='GreyNum'),
        greyUrl?: string(name='GreyUrl'),
        id?: long(name='Id'),
        memo?: string(name='Memo'),
        modifier?: string(name='Modifier'),
        packageId?: long(name='PackageId'),
        percent?: int32(name='Percent'),
        platform?: string(name='Platform'),
        productId?: string(name='ProductId'),
        productVersion?: string(name='ProductVersion'),
        publishMode?: int32(name='PublishMode'),
        publishType?: int32(name='PublishType'),
        releaseVersion?: string(name='ReleaseVersion'),
        status?: int32(name='Status'),
        syncResult?: string(name='SyncResult'),
        taskName?: string(name='TaskName'),
        taskStatus?: int32(name='TaskStatus'),
        taskType?: int32(name='TaskType'),
        taskVersion?: long(name='TaskVersion'),
        upgradeNoticeNum?: long(name='UpgradeNoticeNum'),
        upgradeProgress?: string(name='UpgradeProgress'),
        whitelistIds?: string(name='WhitelistIds'),
      }
    ](name='NebulaTaskInfo'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='ListMcubeNebulaTaskResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMcubeNebulaTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMcubeNebulaTasksResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListMcubeNebulaTasks  ListMcubeNebulaTasksRequest
  * @return ListMcubeNebulaTasksResponse
 */
async function listMcubeNebulaTasks(request: ListMcubeNebulaTasksRequest): ListMcubeNebulaTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListMcubeNebulaTasks', 'POST', '/', 'json', true, 'form', request);
}

model ListMcubeUpgradePackagesRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  pageNum?: int32(name='PageNum', position='Body'),
  pageSize?: int32(name='PageSize', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model ListMcubeUpgradePackagesResponseBody = {
  currentPage?: int32(name='CurrentPage'),
  hasMore?: boolean(name='HasMore'),
  listPackagesResult?: {
    errorCode?: string(name='ErrorCode'),
    packages?: [ 
      {
        allowCreateTask?: boolean(name='AllowCreateTask'),
        appCode?: string(name='AppCode'),
        appstoreUrl?: string(name='AppstoreUrl'),
        changeLog?: string(name='ChangeLog'),
        creator?: string(name='Creator'),
        downloadUrl?: string(name='DownloadUrl'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        id?: long(name='Id'),
        isEnterprise?: int32(name='IsEnterprise'),
        md5?: string(name='Md5'),
        modifier?: string(name='Modifier'),
        needCheck?: int32(name='NeedCheck'),
        packageType?: string(name='PackageType'),
        platform?: string(name='Platform'),
        productId?: string(name='ProductId'),
        productVersion?: string(name='ProductVersion'),
        publishPeriod?: int32(name='PublishPeriod'),
        verificationCode?: string(name='VerificationCode'),
      }
    ](name='Packages'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='ListPackagesResult'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
  totalCount?: long(name='TotalCount'),
}

model ListMcubeUpgradePackagesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMcubeUpgradePackagesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListMcubeUpgradePackages  ListMcubeUpgradePackagesRequest
  * @return ListMcubeUpgradePackagesResponse
 */
async function listMcubeUpgradePackages(request: ListMcubeUpgradePackagesRequest): ListMcubeUpgradePackagesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListMcubeUpgradePackages', 'POST', '/', 'json', true, 'form', request);
}

model ListMcubeUpgradeTasksRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  packageId?: string(name='PackageId', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model ListMcubeUpgradeTasksResponseBody = {
  listTaskResult?: {
    errorCode?: string(name='ErrorCode'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
    taskInfo?: [ 
      {
        appCode?: string(name='AppCode'),
        creator?: string(name='Creator'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        greyConfigInfo?: string(name='GreyConfigInfo'),
        greyEndtime?: string(name='GreyEndtime'),
        greyNum?: int32(name='GreyNum'),
        historyForce?: int32(name='HistoryForce'),
        id?: long(name='Id'),
        isEnterprise?: int32(name='IsEnterprise'),
        memo?: string(name='Memo'),
        modifier?: string(name='Modifier'),
        packageInfoId?: long(name='PackageInfoId'),
        platform?: string(name='Platform'),
        productId?: string(name='ProductId'),
        productVersion?: string(name='ProductVersion'),
        publishMode?: int32(name='PublishMode'),
        publishType?: int32(name='PublishType'),
        pushContent?: string(name='PushContent'),
        taskStatus?: int32(name='TaskStatus'),
        upgradeContent?: string(name='UpgradeContent'),
        upgradeType?: int32(name='UpgradeType'),
        whitelistIds?: string(name='WhitelistIds'),
      }
    ](name='TaskInfo'),
  }(name='ListTaskResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMcubeUpgradeTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMcubeUpgradeTasksResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListMcubeUpgradeTasks  ListMcubeUpgradeTasksRequest
  * @return ListMcubeUpgradeTasksResponse
 */
async function listMcubeUpgradeTasks(request: ListMcubeUpgradeTasksRequest): ListMcubeUpgradeTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListMcubeUpgradeTasks', 'POST', '/', 'json', true, 'form', request);
}

model ListMcubeWhitelistsRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  pageNum?: int32(name='PageNum', position='Body'),
  pageSize?: int32(name='PageSize', position='Body'),
  tenantId: string(name='TenantId', description='This parameter is required.', position='Body'),
  whitelistName?: string(name='WhitelistName', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model ListMcubeWhitelistsResponseBody = {
  listWhitelistResult?: {
    currentPage?: int32(name='CurrentPage'),
    hasMore?: boolean(name='HasMore'),
    pageSize?: int32(name='PageSize'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
    totalCount?: long(name='TotalCount'),
    whitelists?: [ 
      {
        appCode?: string(name='AppCode'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        id?: long(name='Id'),
        whiteListCount?: long(name='WhiteListCount'),
        whiteListName?: string(name='WhiteListName'),
        whitelistType?: string(name='WhitelistType'),
      }
    ](name='Whitelists'),
  }(name='ListWhitelistResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMcubeWhitelistsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMcubeWhitelistsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListMcubeWhitelists  ListMcubeWhitelistsRequest
  * @return ListMcubeWhitelistsResponse
 */
async function listMcubeWhitelists(request: ListMcubeWhitelistsRequest): ListMcubeWhitelistsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListMcubeWhitelists', 'POST', '/', 'json', true, 'form', request);
}

model ListTemplatePageRequest {
  appId?: string(name='AppId', example='ALIPUBC6E8EC1271137', position='Body'),
  currentPage?: int32(name='CurrentPage', example='1', position='Body'),
  pageSize?: int32(name='PageSize', example='10', position='Body'),
  tenantId?: string(name='TenantId', example='CBIGWCFH', position='Body'),
  workspaceId?: string(name='WorkspaceId', example='default', position='Body'),
}

model ListTemplatePageResponseBody = {
  code?: string(name='Code', example='100'),
  currentPage?: int32(name='CurrentPage', example='1'),
  data?: [ 
    {
      action?: string(name='Action', example='1'),
      content?: string(name='Content'),
      descInfo?: string(name='DescInfo'),
      gmtCreate?: string(name='GmtCreate', example='1740479834'),
      gmtModified?: string(name='GmtModified', example='1722564835000'),
      iconUrls?: string(name='IconUrls', example='/'),
      id?: string(name='Id', example='10029984'),
      imageUrls?: string(name='ImageUrls', example='/'),
      name?: string(name='Name'),
      pushStyle?: string(name='PushStyle', example='0'),
      showStyle?: string(name='ShowStyle', example='0'),
      title?: string(name='Title'),
      uri?: string(name='Uri', example='/'),
      variables?: string(name='Variables', example='title,content'),
    }
  ](name='Data'),
  msg?: string(name='Msg', example='SUCCESS'),
  pageSize?: int32(name='PageSize', example='10'),
  requestId?: string(name='RequestId', description='Id of the request', example='11E66B29-9E5E-5C10-B64E-B5A0E0F26355'),
  success?: boolean(name='Success', example='true'),
  totalSize?: int32(name='TotalSize', example='20'),
}

model ListTemplatePageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTemplatePageResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListTemplatePage  ListTemplatePageRequest
  * @return ListTemplatePageResponse
 */
async function listTemplatePage(request: ListTemplatePageRequest): ListTemplatePageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTemplatePage', 'POST', '/', 'json', true, 'form', request);
}

model PushBroadcastRequest {
  regionId?: string(name='RegionId', position='Host'),
  androidChannel?: long(name='AndroidChannel', position='Body'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  bindEndTime?: long(name='BindEndTime', position='Body'),
  bindStartTime?: long(name='BindStartTime', position='Body'),
  channelId?: string(name='ChannelId', position='Body'),
  classification?: string(name='Classification', position='Body'),
  deliveryType: long(name='DeliveryType', description='This parameter is required.', minimum=0, maximum=10, position='Body'),
  expiredSeconds: long(name='ExpiredSeconds', description='This parameter is required.', minimum=0, maximum=259200, position='Body'),
  extendedParams?: string(name='ExtendedParams', position='Body'),
  miChannelId?: string(name='MiChannelId', position='Body'),
  msgkey: string(name='Msgkey', description='This parameter is required.', position='Body'),
  notifyLevel?: map[string]any(name='NotifyLevel', shrink='json', position='Body'),
  notifyType?: string(name='NotifyType', position='Body'),
  pushAction?: long(name='PushAction', minimum=0, maximum=10, position='Body'),
  pushStatus?: long(name='PushStatus', minimum=0, maximum=10, position='Body'),
  silent?: long(name='Silent', minimum=-1, maximum=10, position='Body'),
  strategyContent?: string(name='StrategyContent', position='Body'),
  strategyType?: int32(name='StrategyType', position='Body'),
  taskName?: string(name='TaskName', position='Body'),
  templateKeyValue?: string(name='TemplateKeyValue', position='Body'),
  templateName: string(name='TemplateName', description='This parameter is required.', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  thirdChannelCategory?: map[string]any(name='ThirdChannelCategory', shrink='json', position='Body'),
  timeMode?: int32(name='TimeMode', position='Body'),
  transparentMessagePayload?: any(name='TransparentMessagePayload', position='Body'),
  transparentMessageUrgency?: string(name='TransparentMessageUrgency', position='Body'),
  unBindEndTime?: long(name='UnBindEndTime', position='Body'),
  unBindPeriod?: long(name='UnBindPeriod', minimum=0, maximum=10, position='Body'),
  unBindStartTime?: long(name='UnBindStartTime', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model PushBroadcastResponseBody = {
  pushResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='PushResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model PushBroadcastResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PushBroadcastResponseBody(name='body'),
}

/**
  * @param request  the request parameters of PushBroadcast  PushBroadcastRequest
  * @return PushBroadcastResponse
 */
async function pushBroadcast(request: PushBroadcastRequest): PushBroadcastResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PushBroadcast', 'POST', '/', 'json', true, 'form', request);
}

model PushMultipleRequest {
  regionId?: string(name='RegionId', position='Host'),
  activityContentState?: any(name='ActivityContentState', position='Body'),
  activityEvent?: string(name='ActivityEvent', position='Body'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  channelId?: string(name='ChannelId', position='Body'),
  classification?: string(name='Classification', position='Body'),
  deliveryType: long(name='DeliveryType', description='This parameter is required.', minimum=0, maximum=10, position='Body'),
  dismissalDate?: long(name='DismissalDate', position='Body'),
  expiredSeconds: long(name='ExpiredSeconds', description='This parameter is required.', minimum=0, maximum=259200, position='Body'),
  extendedParams?: string(name='ExtendedParams', position='Body'),
  miChannelId?: string(name='MiChannelId', position='Body'),
  notifyLevel?: map[string]any(name='NotifyLevel', shrink='json', position='Body'),
  notifyType?: string(name='NotifyType', position='Body'),
  pushAction?: long(name='PushAction', minimum=0, maximum=10, position='Body'),
  silent?: long(name='Silent', minimum=-1, maximum=10, position='Body'),
  strategyContent?: string(name='StrategyContent', position='Body'),
  strategyType?: int32(name='StrategyType', position='Body'),
  targetMsg: [ 
    {
      extendedParams?: string(name='ExtendedParams'),
      msgKey: string(name='MsgKey', description='This parameter is required.'),
      target: string(name='Target', description='This parameter is required.'),
      templateKeyValue?: string(name='TemplateKeyValue'),
    }
  ](name='TargetMsg', description='This parameter is required.', position='Body'),
  taskName?: string(name='TaskName', position='Body'),
  templateName: string(name='TemplateName', description='This parameter is required.', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  thirdChannelCategory?: map[string]any(name='ThirdChannelCategory', shrink='json', position='Body'),
  transparentMessagePayload?: any(name='TransparentMessagePayload', position='Body'),
  transparentMessageUrgency?: string(name='TransparentMessageUrgency', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model PushMultipleResponseBody = {
  pushResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='PushResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model PushMultipleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PushMultipleResponseBody(name='body'),
}

/**
  * @param request  the request parameters of PushMultiple  PushMultipleRequest
  * @return PushMultipleResponse
 */
async function pushMultiple(request: PushMultipleRequest): PushMultipleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PushMultiple', 'POST', '/', 'json', true, 'form', request);
}

model PushQueryDeviceStateRequest {
  appId?: string(name='AppId', example='ALIPUB9A63274111812', position='Body'),
  target?: string(name='Target', example='8985d1b78d135e10dc26703379369879', position='Body'),
  targetType?: int32(name='TargetType', example='2', position='Body'),
  tenantId?: string(name='TenantId', example='BJUVXFNW', position='Body'),
  workspaceId?: string(name='WorkspaceId', example='default', position='Body'),
}

model PushQueryDeviceStateResponseBody = {
  code?: string(name='Code', example='100'),
  data?: {
    deliveryToken?: string(name='DeliveryToken', example='ad-000f18w8vmqtzhvbopge-854'),
    deviceId?: string(name='DeviceId', example='ad-000f18w8vmqtzhvbopge-854'),
    manufacturer?: string(name='Manufacturer', example='miui'),
    platform?: string(name='Platform', example='android'),
    statue?: string(name='Statue', example='ONLINE'),
    thirdToken?: string(name='ThirdToken', example='IQAAAACy0f7tAABYiMwLEENtr0TKYJEsv7wyu4Ubt9XXwTJAlknnCb1LAzB3wJvoZIcT_nJdaMhEoXJaqQrObAGHLGoU1GOexlTcLWzja-0HfGHKBw'),
    userId?: string(name='UserId', example='push_test'),
  }(name='Data'),
  message?: string(name='Message', example='SUCCESS'),
  requestId?: string(name='RequestId', description='Id of the request', example='11E66B29-9E5E-5C10-B64E-B5A0E0F26355'),
  success?: boolean(name='Success', example='true'),
}

model PushQueryDeviceStateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PushQueryDeviceStateResponseBody(name='body'),
}

/**
  * @param request  the request parameters of PushQueryDeviceState  PushQueryDeviceStateRequest
  * @return PushQueryDeviceStateResponse
 */
async function pushQueryDeviceState(request: PushQueryDeviceStateRequest): PushQueryDeviceStateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PushQueryDeviceState', 'POST', '/', 'json', true, 'form', request);
}

model PushSimpleRequest {
  regionId?: string(name='RegionId', position='Host'),
  activityContentState?: any(name='ActivityContentState', position='Body'),
  activityEvent?: string(name='ActivityEvent', position='Body'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  channelId?: string(name='ChannelId', position='Body'),
  classification?: string(name='Classification', position='Body'),
  content: string(name='Content', description='This parameter is required.', position='Body'),
  deliveryType: long(name='DeliveryType', description='This parameter is required.', minimum=0, maximum=10, position='Body'),
  dismissalDate?: long(name='DismissalDate', position='Body'),
  expiredSeconds: long(name='ExpiredSeconds', description='This parameter is required.', minimum=0, maximum=259200, position='Body'),
  extendedParams?: string(name='ExtendedParams', position='Body'),
  iconUrls?: string(name='IconUrls', position='Body'),
  imageUrls?: string(name='ImageUrls', position='Body'),
  miChannelId?: string(name='MiChannelId', position='Body'),
  notifyLevel?: map[string]any(name='NotifyLevel', shrink='json', position='Body'),
  notifyType?: string(name='NotifyType', position='Body'),
  pushAction?: long(name='PushAction', minimum=0, maximum=10, position='Body'),
  pushStyle?: int32(name='PushStyle', position='Body'),
  silent?: long(name='Silent', minimum=-1, maximum=10, position='Body'),
  strategyContent?: string(name='StrategyContent', position='Body'),
  strategyType?: int32(name='StrategyType', position='Body'),
  targetMsgkey: string(name='TargetMsgkey', description='This parameter is required.', position='Body'),
  taskName?: string(name='TaskName', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  thirdChannelCategory?: map[string]any(name='ThirdChannelCategory', shrink='json', position='Body'),
  title: string(name='Title', description='This parameter is required.', position='Body'),
  transparentMessagePayload?: any(name='TransparentMessagePayload', position='Body'),
  transparentMessageUrgency?: string(name='TransparentMessageUrgency', position='Body'),
  uri?: string(name='Uri', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model PushSimpleResponseBody = {
  pushResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='PushResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model PushSimpleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PushSimpleResponseBody(name='body'),
}

/**
  * @param request  the request parameters of PushSimple  PushSimpleRequest
  * @return PushSimpleResponse
 */
async function pushSimple(request: PushSimpleRequest): PushSimpleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PushSimple', 'POST', '/', 'json', true, 'form', request);
}

model PushTemplateRequest {
  regionId?: string(name='RegionId', position='Host'),
  activityContentState?: any(name='ActivityContentState', position='Body'),
  activityEvent?: string(name='ActivityEvent', position='Body'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  channelId?: string(name='ChannelId', position='Body'),
  classification?: string(name='Classification', position='Body'),
  deliveryType: long(name='DeliveryType', description='This parameter is required.', minimum=0, maximum=10, position='Body'),
  dismissalDate?: long(name='DismissalDate', position='Body'),
  expiredSeconds: long(name='ExpiredSeconds', description='This parameter is required.', minimum=0, maximum=259200, position='Body'),
  extendedParams?: string(name='ExtendedParams', position='Body'),
  miChannelId?: string(name='MiChannelId', position='Body'),
  notifyLevel?: map[string]any(name='NotifyLevel', shrink='json', position='Body'),
  notifyType?: string(name='NotifyType', position='Body'),
  pushAction?: long(name='PushAction', minimum=0, maximum=10, position='Body'),
  silent?: long(name='Silent', minimum=0, maximum=10, position='Body'),
  strategyContent?: string(name='StrategyContent', position='Body'),
  strategyType?: int32(name='StrategyType', position='Body'),
  targetMsgkey: string(name='TargetMsgkey', description='This parameter is required.', position='Body'),
  taskName?: string(name='TaskName', position='Body'),
  templateKeyValue?: string(name='TemplateKeyValue', position='Body'),
  templateName: string(name='TemplateName', description='This parameter is required.', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  thirdChannelCategory?: map[string]any(name='ThirdChannelCategory', shrink='json', position='Body'),
  transparentMessagePayload?: any(name='TransparentMessagePayload', position='Body'),
  transparentMessageUrgency?: string(name='TransparentMessageUrgency', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model PushTemplateResponseBody = {
  pushResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='PushResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model PushTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PushTemplateResponseBody(name='body'),
}

/**
  * @param request  the request parameters of PushTemplate  PushTemplateRequest
  * @return PushTemplateResponse
 */
async function pushTemplate(request: PushTemplateRequest): PushTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PushTemplate', 'POST', '/', 'json', true, 'form', request);
}

model QueryMcubeMiniPackageRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  h5Id: string(name='H5Id', description='This parameter is required.', position='Body'),
  id: string(name='Id', description='This parameter is required.', position='Body'),
  tenantId: string(name='TenantId', description='This parameter is required.', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model QueryMcubeMiniPackageResponseBody = {
  queryMiniPackageResult?: {
    miniPackageInfo?: {
      appCode?: string(name='AppCode'),
      autoInstall?: long(name='AutoInstall'),
      clientVersionMax?: string(name='ClientVersionMax'),
      clientVersionMin?: string(name='ClientVersionMin'),
      downloadUrl?: string(name='DownloadUrl'),
      extendInfo?: string(name='ExtendInfo'),
      extraData?: string(name='ExtraData'),
      fallbackBaseUrl?: string(name='FallbackBaseUrl'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      h5Id?: string(name='H5Id'),
      h5Name?: string(name='H5Name'),
      h5Version?: string(name='H5Version'),
      id?: long(name='Id'),
      installType?: long(name='InstallType'),
      mainUrl?: string(name='MainUrl'),
      memo?: string(name='Memo'),
      packageType?: long(name='PackageType'),
      platform?: string(name='Platform'),
      publishPeriod?: long(name='PublishPeriod'),
      resourceType?: long(name='ResourceType'),
      status?: long(name='Status'),
    }(name='MiniPackageInfo'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='QueryMiniPackageResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryMcubeMiniPackageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMcubeMiniPackageResponseBody(name='body'),
}

/**
  * @param request  the request parameters of QueryMcubeMiniPackage  QueryMcubeMiniPackageRequest
  * @return QueryMcubeMiniPackageResponse
 */
async function queryMcubeMiniPackage(request: QueryMcubeMiniPackageRequest): QueryMcubeMiniPackageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryMcubeMiniPackage', 'POST', '/', 'json', true, 'form', request);
}

model QueryMcubeMiniTaskRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  taskId: long(name='TaskId', description='This parameter is required.', position='Body'),
  tenantId: string(name='TenantId', description='This parameter is required.', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model QueryMcubeMiniTaskResponseBody = {
  queryMiniTaskResult?: {
    miniTaskInfo?: {
      appCode?: string(name='AppCode'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      greyConfigInfo?: string(name='GreyConfigInfo'),
      greyEndtime?: string(name='GreyEndtime'),
      greyEndtimeData?: string(name='GreyEndtimeData'),
      greyNum?: long(name='GreyNum'),
      id?: long(name='Id'),
      memo?: string(name='Memo'),
      packageId?: long(name='PackageId'),
      platform?: string(name='Platform'),
      productVersion?: string(name='ProductVersion'),
      publishMode?: long(name='PublishMode'),
      publishType?: long(name='PublishType'),
      status?: string(name='Status'),
      taskStatus?: long(name='TaskStatus'),
      whitelistIds?: string(name='WhitelistIds'),
    }(name='MiniTaskInfo'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='QueryMiniTaskResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryMcubeMiniTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMcubeMiniTaskResponseBody(name='body'),
}

/**
  * @param request  the request parameters of QueryMcubeMiniTask  QueryMcubeMiniTaskRequest
  * @return QueryMcubeMiniTaskResponse
 */
async function queryMcubeMiniTask(request: QueryMcubeMiniTaskRequest): QueryMcubeMiniTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryMcubeMiniTask', 'POST', '/', 'json', true, 'form', request);
}

model QueryMcubeVhostRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  tenantId: string(name='TenantId', description='This parameter is required.', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model QueryMcubeVhostResponseBody = {
  queryVhostResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='QueryVhostResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryMcubeVhostResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMcubeVhostResponseBody(name='body'),
}

/**
  * @param request  the request parameters of QueryMcubeVhost  QueryMcubeVhostRequest
  * @return QueryMcubeVhostResponse
 */
async function queryMcubeVhost(request: QueryMcubeVhostRequest): QueryMcubeVhostResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryMcubeVhost', 'POST', '/', 'json', true, 'form', request);
}

model QueryMpsSchedulerListRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  endTime?: long(name='EndTime', minimum=0, maximum=99999999999999999, position='Body'),
  pageNumber?: int32(name='PageNumber', position='Body'),
  pageSize?: int32(name='PageSize', position='Body'),
  startTime?: long(name='StartTime', minimum=0, maximum=99999999999999999, position='Body'),
  type?: int32(name='Type', position='Body'),
  uniqueId?: string(name='UniqueId', maxLength=100000000000000000, position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model QueryMpsSchedulerListResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: {
      list?: [ 
        {
          createType?: int32(name='CreateType'),
          deliveryType?: int32(name='DeliveryType'),
          executedStatus?: string(name='ExecutedStatus'),
          gmtCreate?: long(name='GmtCreate'),
          parentId?: string(name='ParentId'),
          pushContent?: string(name='PushContent'),
          pushTime?: long(name='PushTime'),
          pushTitle?: string(name='PushTitle'),
          strategyType?: int32(name='StrategyType'),
          type?: int32(name='Type'),
          uniqueId?: string(name='UniqueId'),
        }
      ](name='List'),
      totalCount?: int32(name='TotalCount'),
    }(name='Data'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryMpsSchedulerListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMpsSchedulerListResponseBody(name='body'),
}

/**
  * @param request  the request parameters of QueryMpsSchedulerList  QueryMpsSchedulerListRequest
  * @return QueryMpsSchedulerListResponse
 */
async function queryMpsSchedulerList(request: QueryMpsSchedulerListRequest): QueryMpsSchedulerListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryMpsSchedulerList', 'POST', '/', 'json', true, 'form', request);
}

model QueryPushAnalysisCoreIndexRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  channel?: string(name='Channel', position='Body'),
  endTime: long(name='EndTime', description='This parameter is required.', minimum=0, maximum=99999999999999999, position='Body'),
  platform?: string(name='Platform', position='Body'),
  startTime: long(name='StartTime', description='This parameter is required.', minimum=0, maximum=99999999999999999, position='Body'),
  taskId?: string(name='TaskId', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  type?: string(name='Type', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model QueryPushAnalysisCoreIndexResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: {
      arrivalNum?: float(name='ArrivalNum'),
      arrivalRate?: float(name='ArrivalRate'),
      ignoreNum?: float(name='IgnoreNum'),
      ignoreRate?: float(name='IgnoreRate'),
      openNum?: float(name='OpenNum'),
      openRate?: float(name='OpenRate'),
      pushNum?: float(name='PushNum'),
      pushTotalNum?: float(name='PushTotalNum'),
    }(name='Data'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryPushAnalysisCoreIndexResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryPushAnalysisCoreIndexResponseBody(name='body'),
}

/**
  * @param request  the request parameters of QueryPushAnalysisCoreIndex  QueryPushAnalysisCoreIndexRequest
  * @return QueryPushAnalysisCoreIndexResponse
 */
async function queryPushAnalysisCoreIndex(request: QueryPushAnalysisCoreIndexRequest): QueryPushAnalysisCoreIndexResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryPushAnalysisCoreIndex', 'POST', '/', 'json', true, 'form', request);
}

model QueryPushAnalysisTaskDetailRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  taskId: string(name='TaskId', description='This parameter is required.', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model QueryPushAnalysisTaskDetailResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: {
      duration?: string(name='Duration'),
      endTime?: long(name='EndTime'),
      pushArrivalNum?: float(name='PushArrivalNum'),
      pushNum?: float(name='PushNum'),
      pushSuccessNum?: float(name='PushSuccessNum'),
      startTime?: long(name='StartTime'),
      taskId?: long(name='TaskId'),
    }(name='Data'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryPushAnalysisTaskDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryPushAnalysisTaskDetailResponseBody(name='body'),
}

/**
  * @param request  the request parameters of QueryPushAnalysisTaskDetail  QueryPushAnalysisTaskDetailRequest
  * @return QueryPushAnalysisTaskDetailResponse
 */
async function queryPushAnalysisTaskDetail(request: QueryPushAnalysisTaskDetailRequest): QueryPushAnalysisTaskDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryPushAnalysisTaskDetail', 'POST', '/', 'json', true, 'form', request);
}

model QueryPushAnalysisTaskListRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  pageNumber?: int32(name='PageNumber', position='Body'),
  pageSize?: int32(name='PageSize', position='Body'),
  startTime: long(name='StartTime', description='This parameter is required.', minimum=1, maximum=99999999999999999, position='Body'),
  taskId?: string(name='TaskId', position='Body'),
  taskName?: string(name='TaskName', maxLength=100000000000000000, position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model QueryPushAnalysisTaskListResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: [ 
      {
        gmtCreate?: long(name='GmtCreate'),
        list?: [ 
          {
            gmtCreate?: long(name='GmtCreate'),
            taskId?: string(name='TaskId'),
            taskName?: string(name='TaskName'),
            templateId?: string(name='TemplateId'),
            templateName?: string(name='TemplateName'),
            type?: long(name='Type'),
          }
        ](name='List'),
        taskId?: string(name='TaskId'),
        taskName?: string(name='TaskName'),
        templateId?: string(name='TemplateId'),
        templateName?: string(name='TemplateName'),
        type?: long(name='Type'),
      }
    ](name='Data'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryPushAnalysisTaskListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryPushAnalysisTaskListResponseBody(name='body'),
}

/**
  * @param request  the request parameters of QueryPushAnalysisTaskList  QueryPushAnalysisTaskListRequest
  * @return QueryPushAnalysisTaskListResponse
 */
async function queryPushAnalysisTaskList(request: QueryPushAnalysisTaskListRequest): QueryPushAnalysisTaskListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryPushAnalysisTaskList', 'POST', '/', 'json', true, 'form', request);
}

model QueryPushSchedulerListRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  endTime: long(name='EndTime', description='This parameter is required.', minimum=0, maximum=99999999999999999, position='Body'),
  pageNumber?: int32(name='PageNumber', position='Body'),
  pageSize?: int32(name='PageSize', position='Body'),
  startTime: long(name='StartTime', description='This parameter is required.', minimum=0, maximum=99999999999999999, position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  type?: int32(name='Type', position='Body'),
  uniqueId?: string(name='UniqueId', maxLength=100000000000000000, position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model QueryPushSchedulerListResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: {
      list?: [ 
        {
          createType?: int32(name='CreateType'),
          deliveryType?: int32(name='DeliveryType'),
          executedStatus?: string(name='ExecutedStatus'),
          gmtCreate?: long(name='GmtCreate'),
          parentId?: string(name='ParentId'),
          pushContent?: string(name='PushContent'),
          pushTime?: long(name='PushTime'),
          pushTitle?: string(name='PushTitle'),
          strategyType?: int32(name='StrategyType'),
          type?: int32(name='Type'),
          uniqueId?: string(name='UniqueId'),
        }
      ](name='List'),
      totalCount?: int32(name='TotalCount'),
    }(name='Data'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryPushSchedulerListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryPushSchedulerListResponseBody(name='body'),
}

/**
  * @param request  the request parameters of QueryPushSchedulerList  QueryPushSchedulerListRequest
  * @return QueryPushSchedulerListResponse
 */
async function queryPushSchedulerList(request: QueryPushSchedulerListRequest): QueryPushSchedulerListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryPushSchedulerList', 'POST', '/', 'json', true, 'form', request);
}

model RevokePushMessageRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  messageId: string(name='MessageId', description='This parameter is required.', position='Body'),
  targetId: string(name='TargetId', description='This parameter is required.', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model RevokePushMessageResponseBody = {
  pushResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='PushResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model RevokePushMessageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RevokePushMessageResponseBody(name='body'),
}

/**
  * @param request  the request parameters of RevokePushMessage  RevokePushMessageRequest
  * @return RevokePushMessageResponse
 */
async function revokePushMessage(request: RevokePushMessageRequest): RevokePushMessageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RevokePushMessage', 'POST', '/', 'json', true, 'form', request);
}

model RevokePushTaskRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  taskId: string(name='TaskId', description='This parameter is required.', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model RevokePushTaskResponseBody = {
  pushResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='PushResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model RevokePushTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RevokePushTaskResponseBody(name='body'),
}

/**
  * @param request  the request parameters of RevokePushTask  RevokePushTaskRequest
  * @return RevokePushTaskResponse
 */
async function revokePushTask(request: RevokePushTaskRequest): RevokePushTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RevokePushTask', 'POST', '/', 'json', true, 'form', request);
}

model UpdateMcubeWhitelistRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  id: string(name='Id', description='This parameter is required.', position='Body'),
  keyIds?: string(name='KeyIds', position='Body'),
  onexFlag: boolean(name='OnexFlag', description='This parameter is required.', position='Body'),
  ossUrl?: string(name='OssUrl', position='Body'),
  tenantId: string(name='TenantId', description='This parameter is required.', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model UpdateMcubeWhitelistResponseBody = {
  addWhitelistResult?: {
    addWhitelistInfo?: {
      failNum?: long(name='FailNum'),
      failUserIds?: string(name='FailUserIds'),
      successNum?: long(name='SuccessNum'),
    }(name='AddWhitelistInfo'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='AddWhitelistResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model UpdateMcubeWhitelistResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateMcubeWhitelistResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateMcubeWhitelist  UpdateMcubeWhitelistRequest
  * @return UpdateMcubeWhitelistResponse
 */
async function updateMcubeWhitelist(request: UpdateMcubeWhitelistRequest): UpdateMcubeWhitelistResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateMcubeWhitelist', 'POST', '/', 'json', true, 'form', request);
}

model UploadMcubeMiniPackageRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  autoInstall: long(name='AutoInstall', description='This parameter is required.', position='Body'),
  clientVersionMax?: string(name='ClientVersionMax', position='Body'),
  clientVersionMin: string(name='ClientVersionMin', description='This parameter is required.', position='Body'),
  enableKeepAlive: string(name='EnableKeepAlive', description='This parameter is required.', position='Body'),
  enableOptionMenu: string(name='EnableOptionMenu', description='This parameter is required.', position='Body'),
  enableTabBar: long(name='EnableTabBar', description='This parameter is required.', position='Body'),
  extendInfo?: string(name='ExtendInfo', position='Body'),
  h5Id: string(name='H5Id', description='This parameter is required.', position='Body'),
  h5Name: string(name='H5Name', description='This parameter is required.', position='Body'),
  h5Version: string(name='H5Version', description='This parameter is required.', position='Body'),
  iconFileUrl: string(name='IconFileUrl', description='This parameter is required.', position='Body'),
  installType: long(name='InstallType', description='This parameter is required.', position='Body'),
  mainUrl: string(name='MainUrl', description='This parameter is required.', position='Body'),
  onexFlag: boolean(name='OnexFlag', description='This parameter is required.', position='Body'),
  packageType: long(name='PackageType', description='This parameter is required.', position='Body'),
  platform: string(name='Platform', description='This parameter is required.', position='Body'),
  resourceFileUrl: string(name='ResourceFileUrl', description='This parameter is required.', position='Body'),
  resourceType: long(name='ResourceType', description='This parameter is required.', position='Body'),
  tenantId: string(name='TenantId', description='This parameter is required.', position='Body'),
  userId: string(name='UserId', description='This parameter is required.', position='Body'),
  uuid?: string(name='Uuid', position='Body'),
  vhost: string(name='Vhost', description='This parameter is required.', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model UploadMcubeMiniPackageResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
  uploadMiniPackageResult?: {
    resultMsg?: string(name='ResultMsg'),
    returnPackageResult?: {
      debugUrl?: string(name='DebugUrl'),
      packageId?: string(name='PackageId'),
      userId?: string(name='UserId'),
    }(name='ReturnPackageResult'),
    success?: boolean(name='Success'),
  }(name='UploadMiniPackageResult'),
}

model UploadMcubeMiniPackageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UploadMcubeMiniPackageResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UploadMcubeMiniPackage  UploadMcubeMiniPackageRequest
  * @return UploadMcubeMiniPackageResponse
 */
async function uploadMcubeMiniPackage(request: UploadMcubeMiniPackageRequest): UploadMcubeMiniPackageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UploadMcubeMiniPackage', 'POST', '/', 'json', true, 'form', request);
}

model UploadMcubeRsaKeyRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  fileUrl: string(name='FileUrl', description='This parameter is required.', position='Body'),
  onexFlag: boolean(name='OnexFlag', description='This parameter is required.', position='Body'),
  tenantId: string(name='TenantId', description='This parameter is required.', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model UploadMcubeRsaKeyResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
  uploadRsaResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='UploadRsaResult'),
}

model UploadMcubeRsaKeyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UploadMcubeRsaKeyResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UploadMcubeRsaKey  UploadMcubeRsaKeyRequest
  * @return UploadMcubeRsaKeyResponse
 */
async function uploadMcubeRsaKey(request: UploadMcubeRsaKeyRequest): UploadMcubeRsaKeyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UploadMcubeRsaKey', 'POST', '/', 'json', true, 'form', request);
}

