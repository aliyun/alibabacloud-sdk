/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('ververica', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model CreateConnectorRequest {
  paramsJson?: string(name='paramsJson'),
}

model CreateConnectorResponseBody = {
  data?: string(name='data'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model CreateConnectorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateConnectorResponseBody(name='body'),
}

async function createConnector(workspace: string, namespace: string, request: CreateConnectorRequest): CreateConnectorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createConnectorWithOptions(workspace, namespace, request, headers, runtime);
}

async function createConnectorWithOptions(workspace: string, namespace: string, request: CreateConnectorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateConnectorResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.paramsJson)) {
    body['paramsJson'] = request.paramsJson;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateConnector',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/sql/v1beta1/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/connectors`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateDeploymentRequest {
  paramsJson?: string(name='paramsJson'),
}

model CreateDeploymentResponseBody = {
  data?: string(name='data'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model CreateDeploymentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDeploymentResponseBody(name='body'),
}

async function createDeployment(namespace: string, workspace: string, request: CreateDeploymentRequest): CreateDeploymentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createDeploymentWithOptions(namespace, workspace, request, headers, runtime);
}

async function createDeploymentWithOptions(namespace: string, workspace: string, request: CreateDeploymentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateDeploymentResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.paramsJson)) {
    body['paramsJson'] = request.paramsJson;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDeployment',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/api/v1/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/deployments`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateFormatRequest {
  paramsJson?: string(name='paramsJson'),
}

model CreateFormatResponseBody = {
  data?: string(name='data'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model CreateFormatResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateFormatResponseBody(name='body'),
}

async function createFormat(workspace: string, namespace: string, request: CreateFormatRequest): CreateFormatResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createFormatWithOptions(workspace, namespace, request, headers, runtime);
}

async function createFormatWithOptions(workspace: string, namespace: string, request: CreateFormatRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateFormatResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.paramsJson)) {
    body['paramsJson'] = request.paramsJson;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateFormat',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/sql/v1beta1/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/formats`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateMemberRequest {
  paramsJson?: string(name='paramsJson'),
}

model CreateMemberResponseBody = {
  data?: string(name='data'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model CreateMemberResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateMemberResponseBody(name='body'),
}

async function createMember(workspace: string, namespace: string, request: CreateMemberRequest): CreateMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createMemberWithOptions(workspace, namespace, request, headers, runtime);
}

async function createMemberWithOptions(workspace: string, namespace: string, request: CreateMemberRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateMemberResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.paramsJson)) {
    body['paramsJson'] = request.paramsJson;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateMember',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/members/v1/namespaces/${OpenApiUtil.getEncodeParam(namespace)}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateSavepointHeaders {
  commonHeaders?: map[string]string,
  regionId?: string(name='RegionId'),
}

model CreateSavepointRequest {
  paramsJson?: string(name='paramsJson'),
}

model CreateSavepointResponseBody = {
  data?: string(name='data'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model CreateSavepointResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSavepointResponseBody(name='body'),
}

async function createSavepoint(namespace: string, workspace: string, request: CreateSavepointRequest): CreateSavepointResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new CreateSavepointHeaders{};
  return createSavepointWithOptions(namespace, workspace, request, headers, runtime);
}

async function createSavepointWithOptions(namespace: string, workspace: string, request: CreateSavepointRequest, headers: CreateSavepointHeaders, runtime: Util.RuntimeOptions): CreateSavepointResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.paramsJson)) {
    body['paramsJson'] = request.paramsJson;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.regionId)) {
    realHeaders['RegionId'] = Util.toJSONString(headers.regionId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateSavepoint',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/api/v1/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/savepoints`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateSecretValueRequest {
  paramsJson?: string(name='paramsJson'),
}

model CreateSecretValueResponseBody = {
  data?: string(name='data'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model CreateSecretValueResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSecretValueResponseBody(name='body'),
}

async function createSecretValue(workspace: string, namespace: string, request: CreateSecretValueRequest): CreateSecretValueResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createSecretValueWithOptions(workspace, namespace, request, headers, runtime);
}

async function createSecretValueWithOptions(workspace: string, namespace: string, request: CreateSecretValueRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateSecretValueResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.paramsJson)) {
    body['paramsJson'] = request.paramsJson;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateSecretValue',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/api/v1/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/secret-values`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateUdfArtifactRequest {
  paramsJson?: string(name='paramsJson'),
}

model CreateUdfArtifactResponseBody = {
  data?: string(name='data'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model CreateUdfArtifactResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateUdfArtifactResponseBody(name='body'),
}

async function createUdfArtifact(workspace: string, namespace: string, request: CreateUdfArtifactRequest): CreateUdfArtifactResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createUdfArtifactWithOptions(workspace, namespace, request, headers, runtime);
}

async function createUdfArtifactWithOptions(workspace: string, namespace: string, request: CreateUdfArtifactRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateUdfArtifactResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.paramsJson)) {
    body['paramsJson'] = request.paramsJson;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateUdfArtifact',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/sql/v1beta1/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/udfartifacts`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DatabaseExistsRequest {
  database?: string(name='database'),
}

model DatabaseExistsResponseBody = {
  data?: string(name='data'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model DatabaseExistsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DatabaseExistsResponseBody(name='body'),
}

async function databaseExists(namespace: string, workspace: string, cat: string, request: DatabaseExistsRequest): DatabaseExistsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return databaseExistsWithOptions(namespace, workspace, cat, request, headers, runtime);
}

async function databaseExistsWithOptions(namespace: string, workspace: string, cat: string, request: DatabaseExistsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DatabaseExistsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.database)) {
    query['database'] = request.database;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DatabaseExists',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/catalog/v1beta2/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/catalogs/${OpenApiUtil.getEncodeParam(cat)}%3AdatabaseExists`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteArtifactRequest {
  filename?: string(name='filename'),
}

model DeleteArtifactResponseBody = {
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model DeleteArtifactResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteArtifactResponseBody(name='body'),
}

async function deleteArtifact(namespace: string, workspace: string, request: DeleteArtifactRequest): DeleteArtifactResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteArtifactWithOptions(namespace, workspace, request, headers, runtime);
}

async function deleteArtifactWithOptions(namespace: string, workspace: string, request: DeleteArtifactRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteArtifactResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.filename)) {
    query['filename'] = request.filename;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteArtifact',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/artifacts/v1/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/artifacts%3Adelete`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteConnectorResponseBody = {
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model DeleteConnectorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteConnectorResponseBody(name='body'),
}

async function deleteConnector(workspace: string, name: string, namespace: string): DeleteConnectorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteConnectorWithOptions(workspace, name, namespace, headers, runtime);
}

async function deleteConnectorWithOptions(workspace: string, name: string, namespace: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteConnectorResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteConnector',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/sql/v1beta1/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/connectors/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteDeploymentResponseBody = {
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model DeleteDeploymentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDeploymentResponseBody(name='body'),
}

async function deleteDeployment(namespace: string, deploymentId: string, workspace: string): DeleteDeploymentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteDeploymentWithOptions(namespace, deploymentId, workspace, headers, runtime);
}

async function deleteDeploymentWithOptions(namespace: string, deploymentId: string, workspace: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteDeploymentResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteDeployment',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/api/v1/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/deployments/${OpenApiUtil.getEncodeParam(deploymentId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteFormatResponseBody = {
  requestId?: string(name='requestId'),
}

model DeleteFormatResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteFormatResponseBody(name='body'),
}

async function deleteFormat(workspace: string, name: string, namespace: string): DeleteFormatResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteFormatWithOptions(workspace, name, namespace, headers, runtime);
}

async function deleteFormatWithOptions(workspace: string, name: string, namespace: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteFormatResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteFormat',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/sql/v1beta1/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/formats/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteMemberResponseBody = {
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model DeleteMemberResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteMemberResponseBody(name='body'),
}

async function deleteMember(workspace: string, namespace: string, member: string): DeleteMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteMemberWithOptions(workspace, namespace, member, headers, runtime);
}

async function deleteMemberWithOptions(workspace: string, namespace: string, member: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteMemberResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteMember',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/members/v1/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/members/${OpenApiUtil.getEncodeParam(member)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteSecretValueResponseBody = {
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model DeleteSecretValueResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSecretValueResponseBody(name='body'),
}

async function deleteSecretValue(namespace: string, workspace: string, name: string): DeleteSecretValueResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteSecretValueWithOptions(namespace, workspace, name, headers, runtime);
}

async function deleteSecretValueWithOptions(namespace: string, workspace: string, name: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteSecretValueResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteSecretValue',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/api/v1/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/secret-values/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteUdfArtifactResponseBody = {
  data?: string(name='data'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model DeleteUdfArtifactResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteUdfArtifactResponseBody(name='body'),
}

async function deleteUdfArtifact(workspace: string, namespace: string, udfArtifactName: string): DeleteUdfArtifactResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteUdfArtifactWithOptions(workspace, namespace, udfArtifactName, headers, runtime);
}

async function deleteUdfArtifactWithOptions(workspace: string, namespace: string, udfArtifactName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteUdfArtifactResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteUdfArtifact',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/sql/v1beta1/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/udfartifacts/${OpenApiUtil.getEncodeParam(udfArtifactName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ExecuteSqlScriptRequest {
  paramsJson?: string(name='paramsJson'),
}

model ExecuteSqlScriptResponseBody = {
  data?: string(name='data'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model ExecuteSqlScriptResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ExecuteSqlScriptResponseBody(name='body'),
}

async function executeSqlScript(namespace: string, workspace: string, request: ExecuteSqlScriptRequest): ExecuteSqlScriptResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return executeSqlScriptWithOptions(namespace, workspace, request, headers, runtime);
}

async function executeSqlScriptWithOptions(namespace: string, workspace: string, request: ExecuteSqlScriptRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ExecuteSqlScriptResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.paramsJson)) {
    body['paramsJson'] = request.paramsJson;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ExecuteSqlScript',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/sql/v1beta1/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/sqlscripts%3Aexecute`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ExecuteSqlscriptsStatementsRequest {
  paramsJson?: string(name='paramsJson'),
}

model ExecuteSqlscriptsStatementsResponseBody = {
  data?: string(name='data'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model ExecuteSqlscriptsStatementsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ExecuteSqlscriptsStatementsResponseBody(name='body'),
}

async function executeSqlscriptsStatements(workspace: string, namespace: string, request: ExecuteSqlscriptsStatementsRequest): ExecuteSqlscriptsStatementsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return executeSqlscriptsStatementsWithOptions(workspace, namespace, request, headers, runtime);
}

async function executeSqlscriptsStatementsWithOptions(workspace: string, namespace: string, request: ExecuteSqlscriptsStatementsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ExecuteSqlscriptsStatementsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.paramsJson)) {
    body['paramsJson'] = request.paramsJson;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ExecuteSqlscriptsStatements',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/sql/v1beta1/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/sqlscripts%3Aexecute-multi`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ForcefullyCreateLockRequest {
  resourceId?: string(name='resourceId'),
  resourceType?: string(name='resourceType'),
}

model ForcefullyCreateLockResponseBody = {
  data?: string(name='data'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model ForcefullyCreateLockResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ForcefullyCreateLockResponseBody(name='body'),
}

async function forcefullyCreateLock(namespace: string, workspace: string, request: ForcefullyCreateLockRequest): ForcefullyCreateLockResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return forcefullyCreateLockWithOptions(namespace, workspace, request, headers, runtime);
}

async function forcefullyCreateLockWithOptions(namespace: string, workspace: string, request: ForcefullyCreateLockRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ForcefullyCreateLockResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.resourceId)) {
    query['resourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['resourceType'] = request.resourceType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ForcefullyCreateLock',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/api/v1/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/locks`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model FunctionExistsRequest {
  database?: string(name='database'),
  function?: string(name='function'),
}

model FunctionExistsResponseBody = {
  data?: string(name='data'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model FunctionExistsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: FunctionExistsResponseBody(name='body'),
}

async function functionExists(namespace: string, workspace: string, cat: string, request: FunctionExistsRequest): FunctionExistsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return functionExistsWithOptions(namespace, workspace, cat, request, headers, runtime);
}

async function functionExistsWithOptions(namespace: string, workspace: string, cat: string, request: FunctionExistsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): FunctionExistsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.database)) {
    query['database'] = request.database;
  }
  if (!Util.isUnset(request.function)) {
    query['function'] = request.function;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'FunctionExists',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/catalog/v1beta2/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/catalogs/${OpenApiUtil.getEncodeParam(cat)}%3AfunctionExists`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GenerateResourcePlanResponseBody = {
  data?: string(name='data'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model GenerateResourcePlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GenerateResourcePlanResponseBody(name='body'),
}

async function generateResourcePlan(workspace: string, namespace: string, deploymentId: string): GenerateResourcePlanResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return generateResourcePlanWithOptions(workspace, namespace, deploymentId, headers, runtime);
}

async function generateResourcePlanWithOptions(workspace: string, namespace: string, deploymentId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GenerateResourcePlanResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GenerateResourcePlan',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/api/v1/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/deployments/${OpenApiUtil.getEncodeParam(deploymentId)}/resource_plan%3Agenerate`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetArtifactMetadataRequest {
  filename?: string(name='filename'),
}

model GetArtifactMetadataResponseBody = {
  data?: string(name='data'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model GetArtifactMetadataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetArtifactMetadataResponseBody(name='body'),
}

async function getArtifactMetadata(namespace: string, workspace: string, request: GetArtifactMetadataRequest): GetArtifactMetadataResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getArtifactMetadataWithOptions(namespace, workspace, request, headers, runtime);
}

async function getArtifactMetadataWithOptions(namespace: string, workspace: string, request: GetArtifactMetadataRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetArtifactMetadataResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.filename)) {
    query['filename'] = request.filename;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetArtifactMetadata',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/artifacts/v1/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/artifacts%3AgetMetadata`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetCatalogResponseBody = {
  data?: string(name='data'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model GetCatalogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetCatalogResponseBody(name='body'),
}

async function getCatalog(namespace: string, workspace: string, cat: string): GetCatalogResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getCatalogWithOptions(namespace, workspace, cat, headers, runtime);
}

async function getCatalogWithOptions(namespace: string, workspace: string, cat: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetCatalogResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetCatalog',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/catalog/v1beta2/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/catalogs/${OpenApiUtil.getEncodeParam(cat)}%3AgetCatalog`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetDatabaseRequest {
  database?: string(name='database'),
}

model GetDatabaseResponseBody = {
  data?: string(name='data'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model GetDatabaseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDatabaseResponseBody(name='body'),
}

async function getDatabase(namespace: string, workspace: string, cat: string, request: GetDatabaseRequest): GetDatabaseResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getDatabaseWithOptions(namespace, workspace, cat, request, headers, runtime);
}

async function getDatabaseWithOptions(namespace: string, workspace: string, cat: string, request: GetDatabaseRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetDatabaseResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.database)) {
    query['database'] = request.database;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDatabase',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/catalog/v1beta2/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/catalogs/${OpenApiUtil.getEncodeParam(cat)}%3AgetDatabase`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetDefaultDatabaseResponseBody = {
  data?: string(name='data'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model GetDefaultDatabaseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDefaultDatabaseResponseBody(name='body'),
}

async function getDefaultDatabase(namespace: string, workspace: string, cat: string): GetDefaultDatabaseResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getDefaultDatabaseWithOptions(namespace, workspace, cat, headers, runtime);
}

async function getDefaultDatabaseWithOptions(namespace: string, workspace: string, cat: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetDefaultDatabaseResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetDefaultDatabase',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/catalog/v1beta2/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/catalogs/${OpenApiUtil.getEncodeParam(cat)}%3AgetDefaultDatabase`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetDeploymentResponseBody = {
  data?: string(name='data'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model GetDeploymentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDeploymentResponseBody(name='body'),
}

async function getDeployment(namespace: string, deploymentId: string, workspace: string): GetDeploymentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getDeploymentWithOptions(namespace, deploymentId, workspace, headers, runtime);
}

async function getDeploymentWithOptions(namespace: string, deploymentId: string, workspace: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetDeploymentResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetDeployment',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/api/v1/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/deployments/${OpenApiUtil.getEncodeParam(deploymentId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetDeploymentDefaultsResponseBody = {
  data?: string(name='data'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model GetDeploymentDefaultsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDeploymentDefaultsResponseBody(name='body'),
}

async function getDeploymentDefaults(namespace: string, workspace: string): GetDeploymentDefaultsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getDeploymentDefaultsWithOptions(namespace, workspace, headers, runtime);
}

async function getDeploymentDefaultsWithOptions(namespace: string, workspace: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetDeploymentDefaultsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetDeploymentDefaults',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/api/v1/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/deployment-defaults`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetFunctionRequest {
  database?: string(name='database'),
  function?: string(name='function'),
}

model GetFunctionResponseBody = {
  data?: string(name='data'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model GetFunctionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetFunctionResponseBody(name='body'),
}

async function getFunction(namespace: string, workspace: string, cat: string, request: GetFunctionRequest): GetFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getFunctionWithOptions(namespace, workspace, cat, request, headers, runtime);
}

async function getFunctionWithOptions(namespace: string, workspace: string, cat: string, request: GetFunctionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetFunctionResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.database)) {
    query['database'] = request.database;
  }
  if (!Util.isUnset(request.function)) {
    query['function'] = request.function;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetFunction',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/catalog/v1beta2/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/catalogs/${OpenApiUtil.getEncodeParam(cat)}%3AgetFunction`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetGlobalDeploymentDefaultsHeaders {
  commonHeaders?: map[string]string,
  namespace?: string(name='namespace'),
}

model GetGlobalDeploymentDefaultsResponseBody = {
  data?: string(name='data'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model GetGlobalDeploymentDefaultsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetGlobalDeploymentDefaultsResponseBody(name='body'),
}

async function getGlobalDeploymentDefaults(workspace: string): GetGlobalDeploymentDefaultsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new GetGlobalDeploymentDefaultsHeaders{};
  return getGlobalDeploymentDefaultsWithOptions(workspace, headers, runtime);
}

async function getGlobalDeploymentDefaultsWithOptions(workspace: string, headers: GetGlobalDeploymentDefaultsHeaders, runtime: Util.RuntimeOptions): GetGlobalDeploymentDefaultsResponse {
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.namespace)) {
    realHeaders['namespace'] = Util.toJSONString(headers.namespace);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
  };
  var params = new OpenApi.Params{
    action = 'GetGlobalDeploymentDefaults',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/api/v1/global-deployment-defaults`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetResourcePlanResponseBody = {
  data?: string(name='data'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model GetResourcePlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetResourcePlanResponseBody(name='body'),
}

async function getResourcePlan(workspace: string, namespace: string, deploymentId: string): GetResourcePlanResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getResourcePlanWithOptions(workspace, namespace, deploymentId, headers, runtime);
}

async function getResourcePlanWithOptions(workspace: string, namespace: string, deploymentId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetResourcePlanResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetResourcePlan',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/api/v1/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/deployments/${OpenApiUtil.getEncodeParam(deploymentId)}/resource_plan`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetTableRequest {
  database?: string(name='database'),
  table?: string(name='table'),
}

model GetTableResponseBody = {
  data?: string(name='data'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model GetTableResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTableResponseBody(name='body'),
}

async function getTable(namespace: string, workspace: string, cat: string, request: GetTableRequest): GetTableResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTableWithOptions(namespace, workspace, cat, request, headers, runtime);
}

async function getTableWithOptions(namespace: string, workspace: string, cat: string, request: GetTableRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetTableResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.database)) {
    query['database'] = request.database;
  }
  if (!Util.isUnset(request.table)) {
    query['table'] = request.table;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTable',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/catalog/v1beta2/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/catalogs/${OpenApiUtil.getEncodeParam(cat)}%3AgetTable`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetUdfArtifactRequest {
  requireFunctionNames?: boolean(name='requireFunctionNames'),
}

model GetUdfArtifactResponseBody = {
  data?: string(name='data'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model GetUdfArtifactResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetUdfArtifactResponseBody(name='body'),
}

async function getUdfArtifact(workspace: string, namespace: string, udfArtifactName: string, request: GetUdfArtifactRequest): GetUdfArtifactResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getUdfArtifactWithOptions(workspace, namespace, udfArtifactName, request, headers, runtime);
}

async function getUdfArtifactWithOptions(workspace: string, namespace: string, udfArtifactName: string, request: GetUdfArtifactRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetUdfArtifactResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.requireFunctionNames)) {
    query['requireFunctionNames'] = request.requireFunctionNames;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetUdfArtifact',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/sql/v1beta1/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/udfartifacts/${OpenApiUtil.getEncodeParam(udfArtifactName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListArtifactsResponseBody = {
  data?: string(name='data'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model ListArtifactsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListArtifactsResponseBody(name='body'),
}

async function listArtifacts(namespace: string, workspace: string): ListArtifactsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listArtifactsWithOptions(namespace, workspace, headers, runtime);
}

async function listArtifactsWithOptions(namespace: string, workspace: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListArtifactsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListArtifacts',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/artifacts/v1/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/artifacts%3Alist`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListCatalogsResponseBody = {
  data?: string(name='data'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model ListCatalogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListCatalogsResponseBody(name='body'),
}

async function listCatalogs(namespace: string, workspace: string): ListCatalogsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listCatalogsWithOptions(namespace, workspace, headers, runtime);
}

async function listCatalogsWithOptions(namespace: string, workspace: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListCatalogsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListCatalogs',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/catalog/v1beta2/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/catalogs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListConnectorsResponseBody = {
  data?: string(name='data'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model ListConnectorsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListConnectorsResponseBody(name='body'),
}

async function listConnectors(workspace: string, namespace: string): ListConnectorsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listConnectorsWithOptions(workspace, namespace, headers, runtime);
}

async function listConnectorsWithOptions(workspace: string, namespace: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListConnectorsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListConnectors',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/sql/v1beta1/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/connectors`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListDatabasesResponseBody = {
  data?: string(name='data'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model ListDatabasesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDatabasesResponseBody(name='body'),
}

async function listDatabases(namespace: string, workspace: string, cat: string): ListDatabasesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDatabasesWithOptions(namespace, workspace, cat, headers, runtime);
}

async function listDatabasesWithOptions(namespace: string, workspace: string, cat: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListDatabasesResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListDatabases',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/catalog/v1beta2/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/catalogs/${OpenApiUtil.getEncodeParam(cat)}%3AlistDatabases`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListDeploymentTargetsResponseBody = {
  data?: string(name='data'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model ListDeploymentTargetsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDeploymentTargetsResponseBody(name='body'),
}

async function listDeploymentTargets(namespace: string, workspace: string): ListDeploymentTargetsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDeploymentTargetsWithOptions(namespace, workspace, headers, runtime);
}

async function listDeploymentTargetsWithOptions(namespace: string, workspace: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListDeploymentTargetsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListDeploymentTargets',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/api/v1/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/deployment-targets`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListDeploymentsRequest {
  batchMode?: boolean(name='batchMode'),
  creator?: string(name='creator'),
  deploymentId?: string(name='deploymentId'),
  modifier?: string(name='modifier'),
  name?: string(name='name'),
  pageIndex?: string(name='pageIndex'),
  pageSize?: string(name='pageSize'),
  priority?: string(name='priority'),
  sortName?: string(name='sortName'),
  sortOrder?: string(name='sortOrder'),
  state?: string(name='state'),
  status?: string(name='status'),
}

model ListDeploymentsResponseBody = {
  data?: string(name='data'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model ListDeploymentsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDeploymentsResponseBody(name='body'),
}

async function listDeployments(namespace: string, workspace: string, request: ListDeploymentsRequest): ListDeploymentsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDeploymentsWithOptions(namespace, workspace, request, headers, runtime);
}

async function listDeploymentsWithOptions(namespace: string, workspace: string, request: ListDeploymentsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDeploymentsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.batchMode)) {
    query['batchMode'] = request.batchMode;
  }
  if (!Util.isUnset(request.creator)) {
    query['creator'] = request.creator;
  }
  if (!Util.isUnset(request.deploymentId)) {
    query['deploymentId'] = request.deploymentId;
  }
  if (!Util.isUnset(request.modifier)) {
    query['modifier'] = request.modifier;
  }
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.pageIndex)) {
    query['pageIndex'] = request.pageIndex;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.priority)) {
    query['priority'] = request.priority;
  }
  if (!Util.isUnset(request.sortName)) {
    query['sortName'] = request.sortName;
  }
  if (!Util.isUnset(request.sortOrder)) {
    query['sortOrder'] = request.sortOrder;
  }
  if (!Util.isUnset(request.state)) {
    query['state'] = request.state;
  }
  if (!Util.isUnset(request.status)) {
    query['status'] = request.status;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDeployments',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/api/v1/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/deployments`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListFlinkVersionsResponseBody = {
  data?: string(name='data'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model ListFlinkVersionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListFlinkVersionsResponseBody(name='body'),
}

async function listFlinkVersions(workspace: string): ListFlinkVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listFlinkVersionsWithOptions(workspace, headers, runtime);
}

async function listFlinkVersionsWithOptions(workspace: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListFlinkVersionsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListFlinkVersions',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/api/v1/flink-version-meta.json`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListFormatsResponseBody = {
  data?: string(name='data'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model ListFormatsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListFormatsResponseBody(name='body'),
}

async function listFormats(workspace: string, namespace: string): ListFormatsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listFormatsWithOptions(workspace, namespace, headers, runtime);
}

async function listFormatsWithOptions(workspace: string, namespace: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListFormatsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListFormats',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/sql/v1beta1/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/formats`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListFunctionsRequest {
  database?: string(name='database'),
}

model ListFunctionsResponseBody = {
  data?: string(name='data'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model ListFunctionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListFunctionsResponseBody(name='body'),
}

async function listFunctions(namespace: string, workspace: string, cat: string, request: ListFunctionsRequest): ListFunctionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listFunctionsWithOptions(namespace, workspace, cat, request, headers, runtime);
}

async function listFunctionsWithOptions(namespace: string, workspace: string, cat: string, request: ListFunctionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListFunctionsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.database)) {
    query['database'] = request.database;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFunctions',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/catalog/v1beta2/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/catalogs/${OpenApiUtil.getEncodeParam(cat)}%3AlistFunctions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListJobsRequest {
  deploymentId?: string(name='deploymentId'),
}

model ListJobsResponseBody = {
  data?: string(name='data'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model ListJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListJobsResponseBody(name='body'),
}

async function listJobs(namespace: string, workspace: string, request: ListJobsRequest): ListJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listJobsWithOptions(namespace, workspace, request, headers, runtime);
}

async function listJobsWithOptions(namespace: string, workspace: string, request: ListJobsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListJobsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.deploymentId)) {
    query['deploymentId'] = request.deploymentId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListJobs',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/api/v1/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/jobs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListNamespacesResponseBody = {
  data?: string(name='data'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model ListNamespacesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListNamespacesResponseBody(name='body'),
}

async function listNamespaces(): ListNamespacesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listNamespacesWithOptions(headers, runtime);
}

async function listNamespacesWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): ListNamespacesResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListNamespaces',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/namespaces/v1/namespaces`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListSavepointsRequest {
  deploymentId?: string(name='deploymentId'),
  jobId?: string(name='jobId'),
}

model ListSavepointsResponseBody = {
  data?: string(name='data'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model ListSavepointsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSavepointsResponseBody(name='body'),
}

async function listSavepoints(namespace: string, workspace: string, request: ListSavepointsRequest): ListSavepointsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listSavepointsWithOptions(namespace, workspace, request, headers, runtime);
}

async function listSavepointsWithOptions(namespace: string, workspace: string, request: ListSavepointsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListSavepointsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.deploymentId)) {
    query['deploymentId'] = request.deploymentId;
  }
  if (!Util.isUnset(request.jobId)) {
    query['jobId'] = request.jobId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSavepoints',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/api/v1/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/savepoints`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListSecretValuesResponseBody = {
  data?: string(name='data'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model ListSecretValuesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSecretValuesResponseBody(name='body'),
}

async function listSecretValues(namespace: string, workspace: string): ListSecretValuesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listSecretValuesWithOptions(namespace, workspace, headers, runtime);
}

async function listSecretValuesWithOptions(namespace: string, workspace: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListSecretValuesResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListSecretValues',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/api/v1/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/secret-values`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListSessionClustersResponseBody = {
  data?: string(name='data'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model ListSessionClustersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSessionClustersResponseBody(name='body'),
}

async function listSessionClusters(workspace: string, namespace: string): ListSessionClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listSessionClustersWithOptions(workspace, namespace, headers, runtime);
}

async function listSessionClustersWithOptions(workspace: string, namespace: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListSessionClustersResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListSessionClusters',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/api/v1/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/sessionclusters`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListTablesRequest {
  database?: string(name='database'),
}

model ListTablesResponseBody = {
  data?: string(name='data'),
  requestId?: string(name='requestId'),
}

model ListTablesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTablesResponseBody(name='body'),
}

async function listTables(workspace: string, namespace: string, cat: string, request: ListTablesRequest): ListTablesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTablesWithOptions(workspace, namespace, cat, request, headers, runtime);
}

async function listTablesWithOptions(workspace: string, namespace: string, cat: string, request: ListTablesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTablesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.database)) {
    query['database'] = request.database;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTables',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/catalog/v1beta2/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/catalogs/${OpenApiUtil.getEncodeParam(cat)}%3AlistTables`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ParseConnectorRequest {
  paramsJson?: string(name='paramsJson'),
}

model ParseConnectorResponseBody = {
  data?: string(name='data'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model ParseConnectorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ParseConnectorResponseBody(name='body'),
}

async function parseConnector(workspace: string, namespace: string, request: ParseConnectorRequest): ParseConnectorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return parseConnectorWithOptions(workspace, namespace, request, headers, runtime);
}

async function parseConnectorWithOptions(workspace: string, namespace: string, request: ParseConnectorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ParseConnectorResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.paramsJson)) {
    body['paramsJson'] = request.paramsJson;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ParseConnector',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/sql/v1beta1/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/connectors%3Aanalyze-jars`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ParseFormatRequest {
  paramsJson?: string(name='paramsJson'),
}

model ParseFormatResponseBody = {
  data?: string(name='data'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model ParseFormatResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ParseFormatResponseBody(name='body'),
}

async function parseFormat(workspace: string, namespace: string, request: ParseFormatRequest): ParseFormatResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return parseFormatWithOptions(workspace, namespace, request, headers, runtime);
}

async function parseFormatWithOptions(workspace: string, namespace: string, request: ParseFormatRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ParseFormatResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.paramsJson)) {
    body['paramsJson'] = request.paramsJson;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ParseFormat',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/sql/v1beta1/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/formats%3Aanalyze-jars`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ReplaceDeploymentRequest {
  paramsJson?: string(name='paramsJson'),
}

model ReplaceDeploymentResponseBody = {
  data?: int32(name='data'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model ReplaceDeploymentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ReplaceDeploymentResponseBody(name='body'),
}

async function replaceDeployment(namespace: string, deploymentId: string, workspace: string, request: ReplaceDeploymentRequest): ReplaceDeploymentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return replaceDeploymentWithOptions(namespace, deploymentId, workspace, request, headers, runtime);
}

async function replaceDeploymentWithOptions(namespace: string, deploymentId: string, workspace: string, request: ReplaceDeploymentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ReplaceDeploymentResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.paramsJson)) {
    body['paramsJson'] = request.paramsJson;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ReplaceDeployment',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/api/v1/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/deployments/${OpenApiUtil.getEncodeParam(deploymentId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model SetDeploymentResourceModeRequest {
  paramsJson?: string(name='paramsJson'),
}

model SetDeploymentResourceModeResponseBody = {
  data?: string(name='data'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model SetDeploymentResourceModeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetDeploymentResourceModeResponseBody(name='body'),
}

async function setDeploymentResourceMode(workspace: string, namespace: string, deploymentId: string, request: SetDeploymentResourceModeRequest): SetDeploymentResourceModeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return setDeploymentResourceModeWithOptions(workspace, namespace, deploymentId, request, headers, runtime);
}

async function setDeploymentResourceModeWithOptions(workspace: string, namespace: string, deploymentId: string, request: SetDeploymentResourceModeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SetDeploymentResourceModeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.paramsJson)) {
    body['paramsJson'] = request.paramsJson;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SetDeploymentResourceMode',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/api/v1/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/deployments/${OpenApiUtil.getEncodeParam(deploymentId)}/set-resource`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model TableExistsRequest {
  database?: string(name='database'),
  table?: string(name='table'),
}

model TableExistsResponseBody = {
  data?: string(name='data'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model TableExistsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TableExistsResponseBody(name='body'),
}

async function tableExists(namespace: string, workspace: string, cat: string, request: TableExistsRequest): TableExistsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return tableExistsWithOptions(namespace, workspace, cat, request, headers, runtime);
}

async function tableExistsWithOptions(namespace: string, workspace: string, cat: string, request: TableExistsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): TableExistsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.database)) {
    query['database'] = request.database;
  }
  if (!Util.isUnset(request.table)) {
    query['table'] = request.table;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TableExists',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/catalog/v1beta2/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/catalogs/${OpenApiUtil.getEncodeParam(cat)}%3AtableExists`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateConnectorRequest {
  paramsJson?: string(name='paramsJson'),
}

model UpdateConnectorResponseBody = {
  data?: string(name='data'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model UpdateConnectorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateConnectorResponseBody(name='body'),
}

async function updateConnector(workspace: string, name: string, namespace: string, request: UpdateConnectorRequest): UpdateConnectorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateConnectorWithOptions(workspace, name, namespace, request, headers, runtime);
}

async function updateConnectorWithOptions(workspace: string, name: string, namespace: string, request: UpdateConnectorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateConnectorResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.paramsJson)) {
    body['paramsJson'] = request.paramsJson;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateConnector',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/sql/v1beta1/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/connectors/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateDeploymentRequest {
  paramsJson?: string(name='paramsJson'),
}

model UpdateDeploymentResponseBody = {
  data?: int32(name='data'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model UpdateDeploymentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDeploymentResponseBody(name='body'),
}

async function updateDeployment(namespace: string, deploymentId: string, workspace: string, request: UpdateDeploymentRequest): UpdateDeploymentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateDeploymentWithOptions(namespace, deploymentId, workspace, request, headers, runtime);
}

async function updateDeploymentWithOptions(namespace: string, deploymentId: string, workspace: string, request: UpdateDeploymentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateDeploymentResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.paramsJson)) {
    body['paramsJson'] = request.paramsJson;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDeployment',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/api/v1/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/deployments/${OpenApiUtil.getEncodeParam(deploymentId)}/patch`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateDeploymentDesiredStateRequest {
  paramsJson?: string(name='paramsJson'),
}

model UpdateDeploymentDesiredStateResponseBody = {
  data?: string(name='data'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model UpdateDeploymentDesiredStateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDeploymentDesiredStateResponseBody(name='body'),
}

async function updateDeploymentDesiredState(namespace: string, deploymentId: string, workspace: string, request: UpdateDeploymentDesiredStateRequest): UpdateDeploymentDesiredStateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateDeploymentDesiredStateWithOptions(namespace, deploymentId, workspace, request, headers, runtime);
}

async function updateDeploymentDesiredStateWithOptions(namespace: string, deploymentId: string, workspace: string, request: UpdateDeploymentDesiredStateRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateDeploymentDesiredStateResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.paramsJson)) {
    body['paramsJson'] = request.paramsJson;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDeploymentDesiredState',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/api/v1/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/deployments/${OpenApiUtil.getEncodeParam(deploymentId)}/state`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateFormatRequest {
  paramsJson?: string(name='paramsJson'),
}

model UpdateFormatResponseBody = {
  data?: string(name='data'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model UpdateFormatResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateFormatResponseBody(name='body'),
}

async function updateFormat(workspace: string, name: string, namespace: string, request: UpdateFormatRequest): UpdateFormatResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateFormatWithOptions(workspace, name, namespace, request, headers, runtime);
}

async function updateFormatWithOptions(workspace: string, name: string, namespace: string, request: UpdateFormatRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateFormatResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.paramsJson)) {
    body['paramsJson'] = request.paramsJson;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateFormat',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/sql/v1beta1/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/formats/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateMemberRequest {
  paramsJson?: string(name='paramsJson'),
}

model UpdateMemberResponseBody = {
  data?: string(name='data'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model UpdateMemberResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateMemberResponseBody(name='body'),
}

async function updateMember(workspace: string, namespace: string, request: UpdateMemberRequest): UpdateMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateMemberWithOptions(workspace, namespace, request, headers, runtime);
}

async function updateMemberWithOptions(workspace: string, namespace: string, request: UpdateMemberRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateMemberResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.paramsJson)) {
    body['paramsJson'] = request.paramsJson;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMember',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/members/v1/namespaces/${OpenApiUtil.getEncodeParam(namespace)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateUdfArtifactRequest {
  paramsJson?: string(name='paramsJson'),
}

model UpdateUdfArtifactResponseBody = {
  data?: string(name='data'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model UpdateUdfArtifactResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateUdfArtifactResponseBody(name='body'),
}

async function updateUdfArtifact(workspace: string, namespace: string, udfArtifactName: string, request: UpdateUdfArtifactRequest): UpdateUdfArtifactResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateUdfArtifactWithOptions(workspace, namespace, udfArtifactName, request, headers, runtime);
}

async function updateUdfArtifactWithOptions(workspace: string, namespace: string, udfArtifactName: string, request: UpdateUdfArtifactRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateUdfArtifactResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.paramsJson)) {
    body['paramsJson'] = request.paramsJson;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateUdfArtifact',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/sql/v1beta1/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/udfartifacts/${OpenApiUtil.getEncodeParam(udfArtifactName)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ValidateSqlScriptRequest {
  paramsJson?: string(name='paramsJson'),
}

model ValidateSqlScriptResponseBody = {
  data?: string(name='data'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model ValidateSqlScriptResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ValidateSqlScriptResponseBody(name='body'),
}

async function validateSqlScript(namespace: string, workspace: string, request: ValidateSqlScriptRequest): ValidateSqlScriptResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return validateSqlScriptWithOptions(namespace, workspace, request, headers, runtime);
}

async function validateSqlScriptWithOptions(namespace: string, workspace: string, request: ValidateSqlScriptRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ValidateSqlScriptResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.paramsJson)) {
    body['paramsJson'] = request.paramsJson;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ValidateSqlScript',
    version = '2020-05-01',
    protocol = 'HTTPS',
    pathname = `/pop/workspaces/${OpenApiUtil.getEncodeParam(workspace)}/sql/v1beta1/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/sqlscripts%3Avalidate`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

