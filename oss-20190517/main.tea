/**
 *
 */
import Util;
import SPI;
import GatewayClient;
import OpenApi;
import OpenApiUtil;

extends OpenApi;

type @client = SPI

init(config: OpenApi.Config){
  super(config);
  @client = new GatewayClient();
  @spi = @client;
  @endpointRule = '';
  }

model AccessControlList {
  grant?: string(name='Grant'),
}

model AccessControlPolicy {
  accessControlList?: AccessControlList(name='AccessControlList'),
  owner?: Owner(name='Owner'),
}

model ApplyServerSideEncryptionByDefault {
  KMSDataEncryption?: string(name='KMSDataEncryption'),
  KMSMasterKeyID?: string(name='KMSMasterKeyID'),
  SSEAlgorithm?: string(name='SSEAlgorithm'),
}

model Bucket {
  creationDate?: string(name='CreationDate'),
  extranetEndpoint?: string(name='ExtranetEndpoint'),
  intranetEndpoint?: string(name='IntranetEndpoint'),
  location?: string(name='Location'),
  name?: string(name='Name'),
  region?: string(name='Region'),
  storageClass?: string(name='StorageClass'),
}

model BucketLoggingStatus {
  loggingEnabled?: LoggingEnabled(name='LoggingEnabled'),
}

model CORSConfiguration {
  CORSRule?: [
    CORSRule
  ](name='CORSRule'),
  responseVary?: boolean(name='ResponseVary'),
}

model CORSRule {
  allowedHeader?: string(name='AllowedHeader'),
  allowedMethod?: [ string ](name='AllowedMethod'),
  allowedOrigin?: [ string ](name='AllowedOrigin'),
  exposeHeader?: [ string ](name='ExposeHeader'),
  maxAgeSeconds?: long(name='MaxAgeSeconds'),
}

model CSVInput {
  allowQuotedRecordDelimiter?: boolean(name='AllowQuotedRecordDelimiter'),
  commentCharacter?: string(name='CommentCharacter'),
  fieldDelimiter?: string(name='FieldDelimiter'),
  fileHeaderInfo?: string(name='FileHeaderInfo'),
  quoteCharacter?: string(name='QuoteCharacter'),
  range?: string(name='Range'),
  recordDelimiter?: string(name='RecordDelimiter'),
}

model CSVOutput {
  fieldDelimiter?: string(name='FieldDelimiter'),
  recordDelimiter?: string(name='RecordDelimiter'),
}

model CommonPrefix {
  prefix?: string(name='Prefix'),
}

model CompleteMultipartUpload {
  part?: [
    Part
  ](name='Part'),
}

model CopyObjectResult {
  ETag?: string(name='ETag'),
  lastModified?: string(name='LastModified'),
}

model CopyPartResult {
  ETag?: string(name='ETag'),
  lastModified?: string(name='LastModified'),
}

model CreateBucketConfiguration {
  dataRedundancyType?: string(name='DataRedundancyType'),
  storageClass?: string(name='StorageClass'),
}

model Delete {
  objects?: [
    ObjectIdentifier
  ](name='Object'),
  quiet?: boolean(name='Quiet'),
}

model DeleteMarkerEntry {
  isLatest?: boolean(name='IsLatest'),
  key?: string(name='Key'),
  lastModified?: string(name='LastModified'),
  owner?: Owner(name='Owner'),
  versionId?: string(name='VersionId'),
}

model DeletedObject {
  deleteMarker?: boolean(name='DeleteMarker'),
  deleteMarkerVersionId?: string(name='DeleteMarkerVersionId'),
  key?: string(name='Key'),
  versionId?: string(name='VersionId'),
}

model Error {
  code?: string(name='Code'),
  hostId?: string(name='HostId'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ErrorDocument {
  httpStatus?: string(name='HttpStatus'),
  key?: string(name='Key'),
}

model ExtendWormConfiguration {
  retentionPeriodInDays?: int32(name='RetentionPeriodInDays'),
}

model IndexDocument {
  suffix?: string(name='Suffix'),
  supportSubDir?: boolean(name='SupportSubDir'),
  type?: string(name='Type'),
}

model InitiateWormConfiguration {
  retentionPeriodInDays?: int32(name='RetentionPeriodInDays'),
}

model InputSerialization {
  csv?: CSVInput(name='CSV'),
  compressionType?: string(name='CompressionType'),
  json?: JSONInput(name='JSON'),
}

model InventoryConfiguration {
  destination?: InventoryDestination(name='Destination'),
  filter?: InventoryFilter(name='Filter'),
  id?: string(name='Id'),
  includedObjectVersions?: string(name='IncludedObjectVersions'),
  isEnabled?: boolean(name='IsEnabled'),
  optionalFields?: {
    fields?: [
      string
    ](name='Field'),
  }(name='OptionalFields'),
  schedule?: InventorySchedule(name='Schedule'),
}

model InventoryDestination {
  OSSBucketDestination?: InventoryOSSBucketDestination(name='OSSBucketDestination'),
}

model InventoryEncryption {
  SSEKMS?: SSEKMS(name='SSE-KMS'),
  SSEOSS?: SSEOSS(name='SSE-OSS'),
}

model InventoryFilter {
  prefix?: string(name='Prefix'),
}

model InventoryOSSBucketDestination {
  accountId?: string(name='AccountId'),
  bucket?: string(name='Bucket'),
  encryption?: InventoryEncryption(name='Encryption'),
  format?: string(name='Format'),
  prefix?: string(name='Prefix'),
  roleArn?: string(name='RoleArn'),
}

model InventorySchedule {
  frequency?: string(name='Frequency'),
}

model JSONInput {
  parseJsonNumberAsString?: boolean(name='ParseJsonNumberAsString'),
  range?: string(name='Range'),
  type?: string(name='Type'),
}

model JSONOutput {
  recordDelimiter?: string(name='RecordDelimiter'),
}

model LifecycleConfiguration {
  rule?: [
    LifecycleRule
  ](name='Rule'),
}

model LifecycleRule {
  lifecycleAbortMultipartUpload?: {
    createdBeforeDate?: string(name='CreatedBeforeDate'),
    days?: int32(name='Days'),
  }(name='AbortMultipartUpload'),
  lifecycleExpiration?: {
    createdBeforeDate?: string(name='CreatedBeforeDate'),
    days?: int32(name='Days'),
    expiredObjectDeleteMarker?: boolean(name='ExpiredObjectDeleteMarker'),
  }(name='Expiration'),
  ID?: string(name='ID'),
  noncurrentVersionExpiration?: {
    noncurrentDays?: int32(name='NoncurrentDays'),
  }(name='NoncurrentVersionExpiration'),
  noncurrentVersionTransition?: [ 
    {
      noncurrentDays?: int32(name='NoncurrentDays'),
      storageClass?: string(name='StorageClass'),
    }
  ](name='NoncurrentVersionTransition'),
  prefix?: string(name='Prefix'),
  status?: string(name='Status'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  lifecycleTransition?: [ 
    {
      createdBeforeDate?: string(name='CreatedBeforeDate'),
      days?: int32(name='Days'),
      storageClass?: string(name='StorageClass'),
    }
  ](name='Transition'),
}

model LiveChannel {
  description?: string(name='Description'),
  lastModified?: string(name='LastModified'),
  name?: string(name='Name'),
  playUrls?: LiveChannelPlayUrls(name='PlayUrls'),
  publishUrls?: LiveChannelPublishUrls(name='PublishUrls'),
  status?: string(name='Status'),
}

model LiveChannelAudio {
  bandwidth?: long(name='Bandwidth'),
  codec?: string(name='Codec'),
  sampleRate?: long(name='SampleRate'),
}

model LiveChannelConfiguration {
  description?: string(name='Description'),
  snapshot?: LiveChannelSnapshot(name='Snapshot'),
  status?: string(name='Status'),
  target?: LiveChannelTarget(name='Target'),
}

model LiveChannelPlayUrls {
  url?: string(name='Url'),
}

model LiveChannelPublishUrls {
  url?: string(name='Url'),
}

model LiveChannelSnapshot {
  destBucket?: string(name='DestBucket'),
  interval?: long(name='Interval'),
  notifyTopic?: string(name='NotifyTopic'),
  roleName?: string(name='RoleName'),
}

model LiveChannelTarget {
  fragCount?: long(name='FragCount'),
  fragDuration?: long(name='FragDuration'),
  playlistName?: string(name='PlaylistName'),
  type?: string(name='Type'),
}

model LiveChannelVideo {
  bandwidth?: long(name='Bandwidth'),
  codec?: string(name='Codec'),
  frameRate?: long(name='FrameRate'),
  height?: long(name='Height'),
  width?: long(name='Width'),
}

model LiveRecord {
  endTime?: string(name='EndTime'),
  remoteAddr?: string(name='RemoteAddr'),
  startTime?: string(name='StartTime'),
}

model LocationTransferType {
  location?: string(name='Location'),
  transferTypes?: {
    type?: string(name='Type'),
  }(name='TransferTypes'),
}

model LoggingEnabled {
  targetBucket?: string(name='TargetBucket'),
  targetPrefix?: string(name='TargetPrefix'),
}

model ObjectIdentifier {
  key?: string(name='Key'),
  versionId?: string(name='VersionId'),
}

model ObjectSummary {
  ETag?: string(name='ETag'),
  key?: string(name='Key'),
  lastModified?: string(name='LastModified'),
  owner?: Owner(name='Owner'),
  size?: long(name='Size'),
  storageClass?: string(name='StorageClass'),
  type?: string(name='Type'),
}

model ObjectVersion {
  ETag?: string(name='ETag'),
  isLatest?: boolean(name='IsLatest'),
  key?: string(name='Key'),
  lastModified?: string(name='LastModified'),
  owner?: Owner(name='Owner'),
  size?: long(name='Size'),
  storageClass?: string(name='StorageClass'),
  versionId?: string(name='VersionId'),
}

model OutputSerialization {
  csv?: CSVOutput(name='CSV'),
  enablePayloadCrc?: boolean(name='EnablePayloadCrc'),
  json?: JSONOutput(name='JSON'),
  keepAllColumns?: boolean(name='KeepAllColumns'),
  outputHeader?: boolean(name='OutputHeader'),
  outputRawData?: boolean(name='OutputRawData'),
}

model Owner {
  displayName?: string(name='DisplayName'),
  ID?: string(name='ID'),
}

model Part {
  ETag?: string(name='ETag'),
  lastModified?: string(name='LastModified'),
  partNumber?: long(name='PartNumber'),
  size?: long(name='Size'),
}

model RefererConfiguration {
  allowEmptyReferer?: boolean(name='AllowEmptyReferer'),
  allowTruncateQueryString?: boolean(name='AllowTruncateQueryString'),
  refererList?: {
    referer?: [ string ](name='Referer'),
  }(name='RefererList'),
}

model RegionInfo {
  accelerateEndpoint?: string(name='AccelerateEndpoint'),
  internalEndpoint?: string(name='InternalEndpoint'),
  internetEndpoint?: string(name='InternetEndpoint'),
  region?: string(name='Region'),
}

model ReplicationConfiguration {
  rule?: ReplicationRule(name='Rule'),
}

model ReplicationDestination {
  bucket?: string(name='Bucket'),
  location?: string(name='Location'),
  transferType?: string(name='TransferType'),
}

model ReplicationPrefixSet {
  prefixs?: [ string ](name='Prefix'),
}

model ReplicationProgressRule {
  action?: string(name='Action'),
  destination?: ReplicationDestination(name='Destination'),
  historicalObjectReplication?: string(name='HistoricalObjectReplication'),
  ID?: string(name='ID'),
  prefixSet?: ReplicationPrefixSet(name='PrefixSet'),
  progress?: {
    historicalObject?: string(name='HistoricalObject'),
    newObject?: string(name='NewObject'),
  }(name='Progress'),
  status?: string(name='Status'),
}

model ReplicationRule {
  action?: string(name='Action'),
  destination?: ReplicationDestination(name='Destination'),
  encryptionConfiguration?: {
    replicaKmsKeyID?: string(name='ReplicaKmsKeyID'),
  }(name='EncryptionConfiguration'),
  historicalObjectReplication?: string(name='HistoricalObjectReplication'),
  ID?: string(name='ID'),
  prefixSet?: ReplicationPrefixSet(name='PrefixSet'),
  sourceSelectionCriteria?: ReplicationSourceSelectionCriteria(name='SourceSelectionCriteria'),
  status?: string(name='Status'),
  syncRole?: string(name='SyncRole'),
}

model ReplicationRuleProgress {
  action?: string(name='Action'),
  ID?: string(name='ID'),
  prefixSet?: ReplicationPrefixSet(name='PrefixSet'),
}

model ReplicationRules {
  ids?: [ string ](name='ID'),
}

model ReplicationSourceSelectionCriteria {
  sseKmsEncryptedObjects?: {
    status?: string(name='Status'),
  }(name='SseKmsEncryptedObjects'),
}

model RequestPaymentConfiguration {
  payer?: string(name='Payer'),
}

model RestoreRequest {
  days?: long(name='Days'),
  jobParameters?: {
    tier?: string(name='Tier'),
  }(name='JobParameters'),
}

model RoutingRule {
  condition?: RoutingRuleCondition(name='Condition'),
  redirect?: RoutingRuleRedirect(name='Redirect'),
  ruleNumber?: long(name='RuleNumber'),
}

model RoutingRuleCondition {
  httpErrorCodeReturnedEquals?: long(name='HttpErrorCodeReturnedEquals'),
  keyPrefixEquals?: string(name='KeyPrefixEquals'),
}

model RoutingRuleRedirect {
  enableReplacePrefix?: boolean(name='EnableReplacePrefix'),
  hostName?: string(name='HostName'),
  httpRedirectCode?: long(name='HttpRedirectCode'),
  mirrorCheckMd5?: boolean(name='MirrorCheckMd5'),
  mirrorFollowRedirect?: boolean(name='MirrorFollowRedirect'),
  mirrorHeaders?: {
    pass?: [ string ](name='Pass'),
    passAll?: boolean(name='PassAll'),
    remove?: [ string ](name='Remove'),
    set?: [ 
      {
        key?: string(name='Key'),
        value?: string(name='Value'),
      }
    ](name='Set'),
  }(name='MirrorHeaders'),
  mirrorPassQueryString?: boolean(name='MirrorPassQueryString'),
  mirrorURL?: string(name='MirrorURL'),
  passQueryString?: boolean(name='PassQueryString'),
  protocol?: string(name='Protocol'),
  redirectType?: string(name='RedirectType'),
  replaceKeyPrefixWith?: string(name='ReplaceKeyPrefixWith'),
  replaceKeyWith?: string(name='ReplaceKeyWith'),
  transparentMirrorResponseCodes?: string(name='TransparentMirrorResponseCodes'),
}

model SSEKMS {
  keyId?: string(name='KeyId'),
}

model SSEOSS {
}

model SelectMetaRequest {
  inputSerialization?: InputSerialization(name='InputSerialization'),
  overwriteIfExists?: boolean(name='OverwriteIfExists'),
}

model SelectMetaStatus {
  colsCount?: long(name='ColsCount'),
  errorMessage?: string(name='ErrorMessage'),
  offset?: long(name='Offset'),
  rowsCount?: long(name='RowsCount'),
  splitsCount?: long(name='SplitsCount'),
  status?: long(name='Status'),
  totalScannedBytes?: long(name='TotalScannedBytes'),
}

model SelectRequest {
  expression?: string(name='Expression'),
  inputSerialization?: InputSerialization(name='InputSerialization'),
  options?: SelectRequestOptions(name='Options'),
  outputSerialization?: OutputSerialization(name='OutputSerialization'),
}

model SelectRequestOptions {
  maxSkippedRecordsAllowed?: long(name='MaxSkippedRecordsAllowed'),
  skipPartialDataRecord?: boolean(name='SkipPartialDataRecord'),
}

model ServerSideEncryptionRule {
  applyServerSideEncryptionByDefault?: ApplyServerSideEncryptionByDefault(name='ApplyServerSideEncryptionByDefault'),
}

model Tag {
  key?: string(name='Key'),
  value?: string(name='Value'),
}

model TagSet {
  tags?: [
    Tag
  ](name='Tag'),
}

model Tagging {
  tagSet?: TagSet(name='TagSet'),
}

model TransferAccelerationConfiguration {
  enabled?: boolean(name='Enabled'),
}

model Upload {
  initiated?: string(name='Initiated'),
  key?: string(name='Key'),
  uploadId?: string(name='UploadId'),
}

model VersioningConfiguration {
  status?: string(name='Status'),
}

model WebsiteConfiguration {
  errorDocument?: ErrorDocument(name='ErrorDocument'),
  indexDocument?: IndexDocument(name='IndexDocument'),
  routingRules?: {
    routingRule?: [
      RoutingRule
    ](name='RoutingRule'),
  }(name='RoutingRules'),
}

model AbortBucketWormResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function abortBucketWorm(bucket: string): AbortBucketWormResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return abortBucketWormWithOptions(bucket, headers, runtime);
}

async function abortBucketWormWithOptions(bucket: string, headers: map[string]string, runtime: Util.RuntimeOptions): AbortBucketWormResponse {
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'AbortBucketWorm',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/?worm`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

model AbortMultipartUploadRequest {
  uploadId?: string(name='uploadId'),
}

model AbortMultipartUploadResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function abortMultipartUpload(bucket: string, key: string, request: AbortMultipartUploadRequest): AbortMultipartUploadResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return abortMultipartUploadWithOptions(bucket, key, request, headers, runtime);
}

async function abortMultipartUploadWithOptions(bucket: string, key: string, request: AbortMultipartUploadRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AbortMultipartUploadResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  key = OpenApiUtil.getEncodeParam(key);
  var query : map[string]any = {};
  if (!Util.isUnset(request.uploadId)) {
    query['uploadId'] = request.uploadId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AbortMultipartUpload',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/${key}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

model AppendObjectHeaders {
  commonHeaders?: map[string]string,
  cacheControl?: string(name='Cache-Control'),
  contentDisposition?: string(name='Content-Disposition'),
  contentEncoding?: string(name='Content-Encoding'),
  contentMD5?: string(name='Content-MD5'),
  expires?: string(name='Expires'),
  metaData?: map[string]string(name='x-oss-meta-*'),
  acl?: string(name='x-oss-object-acl'),
  serverSideEncryption	?: string(name='x-oss-server-side-encryption'),
  storageClass?: string(name='x-oss-storage-class'),
}

model AppendObjectRequest {
  body?: readable(name='body'),
  position?: long(name='position'),
}

model AppendObjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function appendObject(bucket: string, key: string, request: AppendObjectRequest): AppendObjectResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new AppendObjectHeaders{};
  return appendObjectWithOptions(bucket, key, request, headers, runtime);
}

async function appendObjectWithOptions(bucket: string, key: string, request: AppendObjectRequest, headers: AppendObjectHeaders, runtime: Util.RuntimeOptions): AppendObjectResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  key = OpenApiUtil.getEncodeParam(key);
  var query : map[string]any = {};
  if (!Util.isUnset(request.position)) {
    query['position'] = request.position;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.cacheControl)) {
    realHeaders['Cache-Control'] = Util.toJSONString(headers.cacheControl);
  }
  if (!Util.isUnset(headers.contentDisposition)) {
    realHeaders['Content-Disposition'] = Util.toJSONString(headers.contentDisposition);
  }
  if (!Util.isUnset(headers.contentEncoding)) {
    realHeaders['Content-Encoding'] = Util.toJSONString(headers.contentEncoding);
  }
  if (!Util.isUnset(headers.contentMD5)) {
    realHeaders['Content-MD5'] = Util.toJSONString(headers.contentMD5);
  }
  if (!Util.isUnset(headers.expires)) {
    realHeaders['Expires'] = Util.toJSONString(headers.expires);
  }
  if (!Util.isUnset(headers.metaData)) {
    realHeaders['x-oss-meta-*'] = Util.toJSONString(headers.metaData);
  }
  if (!Util.isUnset(headers.acl)) {
    realHeaders['x-oss-object-acl'] = Util.toJSONString(headers.acl);
  }
  if (!Util.isUnset(headers.serverSideEncryption	)) {
    realHeaders['x-oss-server-side-encryption'] = Util.toJSONString(headers.serverSideEncryption	);
  }
  if (!Util.isUnset(headers.storageClass)) {
    realHeaders['x-oss-storage-class'] = Util.toJSONString(headers.storageClass);
  }
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = realHeaders,
    query = OpenApiUtil.query(query),
    body = request.body,
    stream = request.body,
  };
  var params = new OpenApi.Params{
    action = 'AppendObject',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/${key}?append`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'binary',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

model CompleteBucketWormRequest {
  wormId?: string(name='wormId'),
}

model CompleteBucketWormResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function completeBucketWorm(bucket: string, request: CompleteBucketWormRequest): CompleteBucketWormResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return completeBucketWormWithOptions(bucket, request, headers, runtime);
}

async function completeBucketWormWithOptions(bucket: string, request: CompleteBucketWormRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CompleteBucketWormResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var query : map[string]any = {};
  if (!Util.isUnset(request.wormId)) {
    query['wormId'] = request.wormId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CompleteBucketWorm',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

model CompleteMultipartUploadHeaders {
  commonHeaders?: map[string]string,
  completeAll?: string(name='x-oss-complete-all'),
  forbidOverwrite?: string(name='x-oss-forbid-overwrite'),
}

model CompleteMultipartUploadRequest {
  completeMultipartUpload?: CompleteMultipartUpload(name='completeMultipartUpload'),
  encodingType?: string(name='encoding-type'),
  uploadId?: string(name='uploadId'),
}

model CompleteMultipartUploadResponseBody = {
  bucket?: string(name='Bucket'),
  ETag?: string(name='ETag'),
  encodingType?: string(name='EncodingType'),
  key?: string(name='Key'),
  location?: string(name='Location'),
}

model CompleteMultipartUploadResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CompleteMultipartUploadResponseBody(name='body'),
}

async function completeMultipartUpload(bucket: string, key: string, request: CompleteMultipartUploadRequest): CompleteMultipartUploadResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new CompleteMultipartUploadHeaders{};
  return completeMultipartUploadWithOptions(bucket, key, request, headers, runtime);
}

async function completeMultipartUploadWithOptions(bucket: string, key: string, request: CompleteMultipartUploadRequest, headers: CompleteMultipartUploadHeaders, runtime: Util.RuntimeOptions): CompleteMultipartUploadResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  key = OpenApiUtil.getEncodeParam(key);
  var query : map[string]any = {};
  if (!Util.isUnset(request.encodingType)) {
    query['encoding-type'] = request.encodingType;
  }
  if (!Util.isUnset(request.uploadId)) {
    query['uploadId'] = request.uploadId;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.completeMultipartUpload)) {
    body['completeMultipartUpload'] = request.completeMultipartUpload;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.completeAll)) {
    realHeaders['x-oss-complete-all'] = Util.toJSONString(headers.completeAll);
  }
  if (!Util.isUnset(headers.forbidOverwrite)) {
    realHeaders['x-oss-forbid-overwrite'] = Util.toJSONString(headers.forbidOverwrite);
  }
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = realHeaders,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CompleteMultipartUpload',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/${key}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',  };
  return execute(params, req, runtime);
}

model CopyObjectHeaders {
  commonHeaders?: map[string]string,
  copySource?: string(name='x-oss-copy-source'),
  copySourceIfMatch?: string(name='x-oss-copy-source-if-match'),
  copySourceIfModifiedSince?: string(name='x-oss-copy-source-if-modified-since'),
  copySourceIfNoneMatch?: string(name='x-oss-copy-source-if-none-match'),
  copySourceIfUnmodifiedSince?: string(name='x-oss-copy-source-if-unmodified-since'),
  forbidOverwrite?: string(name='x-oss-forbid-overwrite'),
  metaData?: map[string]string(name='x-oss-meta-*'),
  metadataDirective?: string(name='x-oss-metadata-directive'),
  acl?: string(name='x-oss-object-acl'),
  serverSideEncryption?: string(name='x-oss-server-side-encryption'),
  sseKeyId?: string(name='x-oss-server-side-encryption-key-id'),
  storageClass?: string(name='x-oss-storage-class'),
  tagging?: string(name='x-oss-tagging'),
  taggingDirective?: string(name='x-oss-tagging-directive'),
}

model CopyObjectResponseBody = {
  ETag?: string(name='ETag'),
  lastModified?: string(name='LastModified'),
}

model CopyObjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CopyObjectResponseBody(name='body'),
}

async function copyObject(bucket: string, key: string): CopyObjectResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new CopyObjectHeaders{};
  return copyObjectWithOptions(bucket, key, headers, runtime);
}

async function copyObjectWithOptions(bucket: string, key: string, headers: CopyObjectHeaders, runtime: Util.RuntimeOptions): CopyObjectResponse {
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  key = OpenApiUtil.getEncodeParam(key);
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.copySource)) {
    realHeaders['x-oss-copy-source'] = Util.toJSONString(headers.copySource);
  }
  if (!Util.isUnset(headers.copySourceIfMatch)) {
    realHeaders['x-oss-copy-source-if-match'] = Util.toJSONString(headers.copySourceIfMatch);
  }
  if (!Util.isUnset(headers.copySourceIfModifiedSince)) {
    realHeaders['x-oss-copy-source-if-modified-since'] = Util.toJSONString(headers.copySourceIfModifiedSince);
  }
  if (!Util.isUnset(headers.copySourceIfNoneMatch)) {
    realHeaders['x-oss-copy-source-if-none-match'] = Util.toJSONString(headers.copySourceIfNoneMatch);
  }
  if (!Util.isUnset(headers.copySourceIfUnmodifiedSince)) {
    realHeaders['x-oss-copy-source-if-unmodified-since'] = Util.toJSONString(headers.copySourceIfUnmodifiedSince);
  }
  if (!Util.isUnset(headers.forbidOverwrite)) {
    realHeaders['x-oss-forbid-overwrite'] = Util.toJSONString(headers.forbidOverwrite);
  }
  if (!Util.isUnset(headers.metaData)) {
    realHeaders['x-oss-meta-*'] = Util.toJSONString(headers.metaData);
  }
  if (!Util.isUnset(headers.metadataDirective)) {
    realHeaders['x-oss-metadata-directive'] = Util.toJSONString(headers.metadataDirective);
  }
  if (!Util.isUnset(headers.acl)) {
    realHeaders['x-oss-object-acl'] = Util.toJSONString(headers.acl);
  }
  if (!Util.isUnset(headers.serverSideEncryption)) {
    realHeaders['x-oss-server-side-encryption'] = Util.toJSONString(headers.serverSideEncryption);
  }
  if (!Util.isUnset(headers.sseKeyId)) {
    realHeaders['x-oss-server-side-encryption-key-id'] = Util.toJSONString(headers.sseKeyId);
  }
  if (!Util.isUnset(headers.storageClass)) {
    realHeaders['x-oss-storage-class'] = Util.toJSONString(headers.storageClass);
  }
  if (!Util.isUnset(headers.tagging)) {
    realHeaders['x-oss-tagging'] = Util.toJSONString(headers.tagging);
  }
  if (!Util.isUnset(headers.taggingDirective)) {
    realHeaders['x-oss-tagging-directive'] = Util.toJSONString(headers.taggingDirective);
  }
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = realHeaders,
  };
  var params = new OpenApi.Params{
    action = 'CopyObject',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/${key}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',  };
  return execute(params, req, runtime);
}

model CreateSelectObjectMetaRequest {
  selectMetaRequest?: SelectMetaRequest(name='body'),
}

model CreateSelectObjectMetaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SelectMetaStatus  
}

async function createSelectObjectMeta(bucket: string, key: string, request: CreateSelectObjectMetaRequest): CreateSelectObjectMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createSelectObjectMetaWithOptions(bucket, key, request, headers, runtime);
}

async function createSelectObjectMetaWithOptions(bucket: string, key: string, request: CreateSelectObjectMetaRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateSelectObjectMetaResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  key = OpenApiUtil.getEncodeParam(key);
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(request.selectMetaRequest),
  };
  var params = new OpenApi.Params{
    action = 'CreateSelectObjectMeta',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/${key}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model DeleteBucketResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteBucket(bucket: string): DeleteBucketResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteBucketWithOptions(bucket, headers, runtime);
}

async function deleteBucketWithOptions(bucket: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteBucketResponse {
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteBucket',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

model DeleteBucketCorsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteBucketCors(bucket: string): DeleteBucketCorsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteBucketCorsWithOptions(bucket, headers, runtime);
}

async function deleteBucketCorsWithOptions(bucket: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteBucketCorsResponse {
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteBucketCors',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/?cors`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

model DeleteBucketEncryptionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteBucketEncryption(bucket: string): DeleteBucketEncryptionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteBucketEncryptionWithOptions(bucket, headers, runtime);
}

async function deleteBucketEncryptionWithOptions(bucket: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteBucketEncryptionResponse {
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteBucketEncryption',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/?encryption`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

model DeleteBucketInventoryRequest {
  inventoryId?: string(name='inventoryId'),
}

model DeleteBucketInventoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteBucketInventory(bucket: string, request: DeleteBucketInventoryRequest): DeleteBucketInventoryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteBucketInventoryWithOptions(bucket, request, headers, runtime);
}

async function deleteBucketInventoryWithOptions(bucket: string, request: DeleteBucketInventoryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteBucketInventoryResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var query : map[string]any = {};
  if (!Util.isUnset(request.inventoryId)) {
    query['inventoryId'] = request.inventoryId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteBucketInventory',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/?inventory`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

model DeleteBucketLifecycleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteBucketLifecycle(bucket: string): DeleteBucketLifecycleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteBucketLifecycleWithOptions(bucket, headers, runtime);
}

async function deleteBucketLifecycleWithOptions(bucket: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteBucketLifecycleResponse {
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteBucketLifecycle',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/?lifecycle`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

model DeleteBucketLoggingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteBucketLogging(bucket: string): DeleteBucketLoggingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteBucketLoggingWithOptions(bucket, headers, runtime);
}

async function deleteBucketLoggingWithOptions(bucket: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteBucketLoggingResponse {
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteBucketLogging',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/?logging`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

model DeleteBucketPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteBucketPolicy(bucket: string): DeleteBucketPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteBucketPolicyWithOptions(bucket, headers, runtime);
}

async function deleteBucketPolicyWithOptions(bucket: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteBucketPolicyResponse {
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteBucketPolicy',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/?policy`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

model DeleteBucketReplicationRequest {
  body?: ReplicationRules(name='ReplicationRules'),
}

model DeleteBucketReplicationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteBucketReplication(bucket: string, request: DeleteBucketReplicationRequest): DeleteBucketReplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteBucketReplicationWithOptions(bucket, request, headers, runtime);
}

async function deleteBucketReplicationWithOptions(bucket: string, request: DeleteBucketReplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteBucketReplicationResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteBucketReplication',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/?replication&comp=delete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

model DeleteBucketTagsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteBucketTags(bucket: string): DeleteBucketTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteBucketTagsWithOptions(bucket, headers, runtime);
}

async function deleteBucketTagsWithOptions(bucket: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteBucketTagsResponse {
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteBucketTags',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/?tagging`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

model DeleteBucketWebsiteResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteBucketWebsite(bucket: string): DeleteBucketWebsiteResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteBucketWebsiteWithOptions(bucket, headers, runtime);
}

async function deleteBucketWebsiteWithOptions(bucket: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteBucketWebsiteResponse {
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteBucketWebsite',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/?website`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

model DeleteLiveChannelResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteLiveChannel(bucket: string, channel: string): DeleteLiveChannelResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteLiveChannelWithOptions(bucket, channel, headers, runtime);
}

async function deleteLiveChannelWithOptions(bucket: string, channel: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteLiveChannelResponse {
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  channel = OpenApiUtil.getEncodeParam(channel);
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteLiveChannel',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/${channel}?live`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

model DeleteMultipleObjectsRequest {
  delete?: Delete(name='Delete'),
  encodingType?: string(name='encoding-type'),
}

model DeleteMultipleObjectsResponseBody = {
  deleted?: [
    DeletedObject
  ](name='Deleted'),
  encodingType?: string(name='EncodingType'),
}

model DeleteMultipleObjectsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteMultipleObjectsResponseBody(name='body'),
}

async function deleteMultipleObjects(bucket: string, request: DeleteMultipleObjectsRequest): DeleteMultipleObjectsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteMultipleObjectsWithOptions(bucket, request, headers, runtime);
}

async function deleteMultipleObjectsWithOptions(bucket: string, request: DeleteMultipleObjectsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteMultipleObjectsResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var query : map[string]any = {};
  if (!Util.isUnset(request.encodingType)) {
    query['encoding-type'] = request.encodingType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(request.delete),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMultipleObjects',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/?delete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',  };
  return execute(params, req, runtime);
}

model DeleteObjectRequest {
  versionId?: string(name='versionId'),
}

model DeleteObjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteObject(bucket: string, key: string, request: DeleteObjectRequest): DeleteObjectResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteObjectWithOptions(bucket, key, request, headers, runtime);
}

async function deleteObjectWithOptions(bucket: string, key: string, request: DeleteObjectRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteObjectResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  key = OpenApiUtil.getEncodeParam(key);
  var query : map[string]any = {};
  if (!Util.isUnset(request.versionId)) {
    query['versionId'] = request.versionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteObject',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/${key}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model DeleteObjectTaggingRequest {
  versionId?: string(name='versionId'),
}

model DeleteObjectTaggingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteObjectTagging(bucket: string, key: string, request: DeleteObjectTaggingRequest): DeleteObjectTaggingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteObjectTaggingWithOptions(bucket, key, request, headers, runtime);
}

async function deleteObjectTaggingWithOptions(bucket: string, key: string, request: DeleteObjectTaggingRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteObjectTaggingResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  key = OpenApiUtil.getEncodeParam(key);
  var query : map[string]any = {};
  if (!Util.isUnset(request.versionId)) {
    query['versionId'] = request.versionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteObjectTagging',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/${key}?tagging`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

model DescribeRegionsRequest {
  regions?: string(name='regions'),
}

model DescribeRegionsResponseBody = {
  regionInfos?: [
    RegionInfo
  ](name='RegionInfo'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeRegionsWithOptions(request, headers, runtime);
}

async function describeRegionsWithOptions(request: DescribeRegionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.regions)) {
    query['regions'] = request.regions;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRegions',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/?regions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',  };
  return execute(params, req, runtime);
}

model ExtendBucketWormRequest {
  extendWormConfiguration?: ExtendWormConfiguration(name='extendWormConfiguration'),
  wormId?: string(name='wormId'),
}

model ExtendBucketWormResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function extendBucketWorm(bucket: string, request: ExtendBucketWormRequest): ExtendBucketWormResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return extendBucketWormWithOptions(bucket, request, headers, runtime);
}

async function extendBucketWormWithOptions(bucket: string, request: ExtendBucketWormRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ExtendBucketWormResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var query : map[string]any = {};
  if (!Util.isUnset(request.wormId)) {
    query['wormId'] = request.wormId;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.extendWormConfiguration)) {
    body['extendWormConfiguration'] = request.extendWormConfiguration;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ExtendBucketWorm',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/?wormExtend`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

model GetBucketAclResponseBody = {
  accessControlList?: {
    grant?: string(name='Grant'),
  }(name='AccessControlList'),
  owner?: Owner(name='Owner'),
}

model GetBucketAclResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetBucketAclResponseBody(name='body'),
}

async function getBucketAcl(bucket: string): GetBucketAclResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getBucketAclWithOptions(bucket, headers, runtime);
}

async function getBucketAclWithOptions(bucket: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetBucketAclResponse {
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetBucketAcl',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/?acl`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',  };
  return execute(params, req, runtime);
}

model GetBucketCorsResponseBody = {
  CORSRule?: [
    CORSRule
  ](name='CORSRule'),
  responseVary?: boolean(name='ResponseVary'),
}

model GetBucketCorsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetBucketCorsResponseBody(name='body'),
}

async function getBucketCors(bucket: string): GetBucketCorsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getBucketCorsWithOptions(bucket, headers, runtime);
}

async function getBucketCorsWithOptions(bucket: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetBucketCorsResponse {
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetBucketCors',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/?cors`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',  };
  return execute(params, req, runtime);
}

model GetBucketEncryptionResponseBody = {
  applyServerSideEncryptionByDefault?: ApplyServerSideEncryptionByDefault(name='ApplyServerSideEncryptionByDefault'),
}

model GetBucketEncryptionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetBucketEncryptionResponseBody(name='body'),
}

async function getBucketEncryption(bucket: string): GetBucketEncryptionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getBucketEncryptionWithOptions(bucket, headers, runtime);
}

async function getBucketEncryptionWithOptions(bucket: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetBucketEncryptionResponse {
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetBucketEncryption',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/?encryption`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',  };
  return execute(params, req, runtime);
}

model GetBucketInfoResponseBody = {
  bucketInfo?: {
    accessControlList?: {
      grant?: string(name='Grant'),
    }(name='AccessControlList'),
    comment?: string(name='Comment'),
    creationDate?: string(name='CreationDate'),
    crossRegionReplication?: string(name='CrossRegionReplication'),
    extranetEndpoint?: string(name='ExtranetEndpoint'),
    intranetEndpoint?: string(name='IntranetEndpoint'),
    location?: string(name='Location'),
    name?: string(name='Name'),
    owner?: Owner(name='Owner'),
    storageClass?: string(name='StorageClass'),
    transferAcceleration?: string(name='TransferAcceleration'),
  }(name='Bucket'),
}

model GetBucketInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetBucketInfoResponseBody(name='body'),
}

async function getBucketInfo(bucket: string): GetBucketInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getBucketInfoWithOptions(bucket, headers, runtime);
}

async function getBucketInfoWithOptions(bucket: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetBucketInfoResponse {
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetBucketInfo',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/?bucketInfo`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',  };
  return execute(params, req, runtime);
}

model GetBucketInventoryRequest {
  inventoryId?: string(name='inventoryId'),
}

model GetBucketInventoryResponseBody = {
  destination?: InventoryDestination(name='Destination'),
  filter?: InventoryFilter(name='Filter'),
  id?: string(name='Id'),
  includedObjectVersions?: string(name='IncludedObjectVersions'),
  isEnabled?: boolean(name='IsEnabled'),
  optionalFields?: {
    field?: [
      string
    ](name='Field'),
  }(name='OptionalFields'),
  schedule?: InventorySchedule(name='Schedule'),
}

model GetBucketInventoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetBucketInventoryResponseBody(name='body'),
}

async function getBucketInventory(bucket: string, request: GetBucketInventoryRequest): GetBucketInventoryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getBucketInventoryWithOptions(bucket, request, headers, runtime);
}

async function getBucketInventoryWithOptions(bucket: string, request: GetBucketInventoryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetBucketInventoryResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var query : map[string]any = {};
  if (!Util.isUnset(request.inventoryId)) {
    query['inventoryId'] = request.inventoryId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetBucketInventory',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/?inventory`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',  };
  return execute(params, req, runtime);
}

model GetBucketLifecycleResponseBody = {
  rules?: [
    LifecycleRule
  ](name='Rule'),
}

model GetBucketLifecycleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetBucketLifecycleResponseBody(name='body'),
}

async function getBucketLifecycle(bucket: string): GetBucketLifecycleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getBucketLifecycleWithOptions(bucket, headers, runtime);
}

async function getBucketLifecycleWithOptions(bucket: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetBucketLifecycleResponse {
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetBucketLifecycle',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/?lifecycle`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',  };
  return execute(params, req, runtime);
}

model GetBucketLocationResponseBody = {
  locationConstraint?: string(name='LocationConstraint'),
}

model GetBucketLocationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetBucketLocationResponseBody(name='body'),
}

async function getBucketLocation(bucket: string): GetBucketLocationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getBucketLocationWithOptions(bucket, headers, runtime);
}

async function getBucketLocationWithOptions(bucket: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetBucketLocationResponse {
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetBucketLocation',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/?location`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',  };
  return execute(params, req, runtime);
}

model GetBucketLoggingResponseBody = {
  loggingEnabled?: LoggingEnabled(name='LoggingEnabled'),
}

model GetBucketLoggingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetBucketLoggingResponseBody(name='body'),
}

async function getBucketLogging(bucket: string): GetBucketLoggingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getBucketLoggingWithOptions(bucket, headers, runtime);
}

async function getBucketLoggingWithOptions(bucket: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetBucketLoggingResponse {
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetBucketLogging',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/?logging`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',  };
  return execute(params, req, runtime);
}

model GetBucketPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: string(name='body'),
}

async function getBucketPolicy(bucket: string): GetBucketPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getBucketPolicyWithOptions(bucket, headers, runtime);
}

async function getBucketPolicyWithOptions(bucket: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetBucketPolicyResponse {
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetBucketPolicy',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/?policy`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'string',
  };
  return execute(params, req, runtime);
}

model GetBucketRefererResponseBody = {
  allowEmptyReferer?: boolean(name='AllowEmptyReferer'),
  refererList?: {
    referer?: [ string ](name='Referer'),
  }(name='RefererList'),
}

model GetBucketRefererResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetBucketRefererResponseBody(name='body'),
}

async function getBucketReferer(bucket: string): GetBucketRefererResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getBucketRefererWithOptions(bucket, headers, runtime);
}

async function getBucketRefererWithOptions(bucket: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetBucketRefererResponse {
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetBucketReferer',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/?referer`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',  };
  return execute(params, req, runtime);
}

model GetBucketReplicationResponseBody = {
  rules?: [
    ReplicationRule
  ](name='Rule'),
}

model GetBucketReplicationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetBucketReplicationResponseBody(name='body'),
}

async function getBucketReplication(bucket: string): GetBucketReplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getBucketReplicationWithOptions(bucket, headers, runtime);
}

async function getBucketReplicationWithOptions(bucket: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetBucketReplicationResponse {
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetBucketReplication',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/?replication`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',  };
  return execute(params, req, runtime);
}

model GetBucketReplicationLocationResponseBody = {
  locations?: [ string ](name='Location'),
  locationTransferTypeConstraint?: {
    locationTransferTypes?: [
      LocationTransferType
    ](name='LocationTransferType'),
  }(name='LocationTransferTypeConstraint'),
}

model GetBucketReplicationLocationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetBucketReplicationLocationResponseBody(name='body'),
}

async function getBucketReplicationLocation(bucket: string): GetBucketReplicationLocationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getBucketReplicationLocationWithOptions(bucket, headers, runtime);
}

async function getBucketReplicationLocationWithOptions(bucket: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetBucketReplicationLocationResponse {
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetBucketReplicationLocation',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/?replicationLocation`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',  };
  return execute(params, req, runtime);
}

model GetBucketReplicationProgressRequest {
  ruleId?: string(name='rule-id'),
}

model GetBucketReplicationProgressResponseBody = {
  rule?: ReplicationProgressRule(name='Rule'),
}

model GetBucketReplicationProgressResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetBucketReplicationProgressResponseBody(name='body'),
}

async function getBucketReplicationProgress(bucket: string, request: GetBucketReplicationProgressRequest): GetBucketReplicationProgressResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getBucketReplicationProgressWithOptions(bucket, request, headers, runtime);
}

async function getBucketReplicationProgressWithOptions(bucket: string, request: GetBucketReplicationProgressRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetBucketReplicationProgressResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var query : map[string]any = {};
  if (!Util.isUnset(request.ruleId)) {
    query['rule-id'] = request.ruleId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetBucketReplicationProgress',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/?replicationProgress`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',  };
  return execute(params, req, runtime);
}

model GetBucketRequestPaymentResponseBody = {
  payer?: string(name='Payer'),
}

model GetBucketRequestPaymentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetBucketRequestPaymentResponseBody(name='body'),
}

async function getBucketRequestPayment(bucket: string): GetBucketRequestPaymentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getBucketRequestPaymentWithOptions(bucket, headers, runtime);
}

async function getBucketRequestPaymentWithOptions(bucket: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetBucketRequestPaymentResponse {
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetBucketRequestPayment',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/?requestPayment`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',  };
  return execute(params, req, runtime);
}

model GetBucketTagsResponseBody = {
  tagSet?: TagSet(name='TagSet'),
}

model GetBucketTagsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetBucketTagsResponseBody(name='body'),
}

async function getBucketTags(bucket: string): GetBucketTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getBucketTagsWithOptions(bucket, headers, runtime);
}

async function getBucketTagsWithOptions(bucket: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetBucketTagsResponse {
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetBucketTags',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/?tagging`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',  };
  return execute(params, req, runtime);
}

model GetBucketTransferAccelerationResponseBody = {
  enabled?: boolean(name='Enabled'),
}

model GetBucketTransferAccelerationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetBucketTransferAccelerationResponseBody(name='body'),
}

async function getBucketTransferAcceleration(bucket: string): GetBucketTransferAccelerationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getBucketTransferAccelerationWithOptions(bucket, headers, runtime);
}

async function getBucketTransferAccelerationWithOptions(bucket: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetBucketTransferAccelerationResponse {
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetBucketTransferAcceleration',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/?transferAcceleration`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',  };
  return execute(params, req, runtime);
}

model GetBucketVersioningResponseBody = {
  status?: string(name='Status'),
}

model GetBucketVersioningResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetBucketVersioningResponseBody(name='body'),
}

async function getBucketVersioning(bucket: string): GetBucketVersioningResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getBucketVersioningWithOptions(bucket, headers, runtime);
}

async function getBucketVersioningWithOptions(bucket: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetBucketVersioningResponse {
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetBucketVersioning',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/?versioning`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',  };
  return execute(params, req, runtime);
}

model GetBucketWebsiteResponseBody = {
  errorDocument?: ErrorDocument(name='ErrorDocument'),
  indexDocument?: IndexDocument(name='IndexDocument'),
  routingRules?: {
    routingRules?: [
      RoutingRule
    ](name='RoutingRule'),
  }(name='RoutingRules'),
}

model GetBucketWebsiteResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetBucketWebsiteResponseBody(name='body'),
}

async function getBucketWebsite(bucket: string): GetBucketWebsiteResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getBucketWebsiteWithOptions(bucket, headers, runtime);
}

async function getBucketWebsiteWithOptions(bucket: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetBucketWebsiteResponse {
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetBucketWebsite',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/?website`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',  };
  return execute(params, req, runtime);
}

model GetBucketWormResponseBody = {
  creationDate?: string(name='CreationDate'),
  retentionPeriodInDays?: int32(name='RetentionPeriodInDays'),
  state?: string(name='State'),
  wormId?: string(name='WormId'),
}

model GetBucketWormResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetBucketWormResponseBody(name='body'),
}

async function getBucketWorm(bucket: string): GetBucketWormResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getBucketWormWithOptions(bucket, headers, runtime);
}

async function getBucketWormWithOptions(bucket: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetBucketWormResponse {
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetBucketWorm',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/?worm`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',  };
  return execute(params, req, runtime);
}

model GetLiveChannelHistoryResponseBody = {
  liveRecords?: [
    LiveRecord
  ](name='LiveRecord'),
}

model GetLiveChannelHistoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetLiveChannelHistoryResponseBody(name='body'),
}

async function getLiveChannelHistory(bucket: string, channel: string): GetLiveChannelHistoryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLiveChannelHistoryWithOptions(bucket, channel, headers, runtime);
}

async function getLiveChannelHistoryWithOptions(bucket: string, channel: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetLiveChannelHistoryResponse {
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  channel = OpenApiUtil.getEncodeParam(channel);
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetLiveChannelHistory',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/${channel}?live&comp=history`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',  };
  return execute(params, req, runtime);
}

model GetLiveChannelInfoResponseBody = {
  description?: string(name='Description'),
  status?: string(name='Status'),
  target?: LiveChannelTarget(name='Target'),
}

model GetLiveChannelInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetLiveChannelInfoResponseBody(name='body'),
}

async function getLiveChannelInfo(bucket: string, channel: string): GetLiveChannelInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLiveChannelInfoWithOptions(bucket, channel, headers, runtime);
}

async function getLiveChannelInfoWithOptions(bucket: string, channel: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetLiveChannelInfoResponse {
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  channel = OpenApiUtil.getEncodeParam(channel);
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetLiveChannelInfo',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/${channel}?live`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',  };
  return execute(params, req, runtime);
}

model GetLiveChannelStatResponseBody = {
  audio?: LiveChannelAudio(name='Audio'),
  connectedTime?: string(name='ConnectedTime'),
  remoteAddr?: string(name='RemoteAddr'),
  status?: string(name='Status'),
  video?: LiveChannelVideo(name='Video'),
}

model GetLiveChannelStatResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetLiveChannelStatResponseBody(name='body'),
}

async function getLiveChannelStat(bucket: string, channel: string): GetLiveChannelStatResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLiveChannelStatWithOptions(bucket, channel, headers, runtime);
}

async function getLiveChannelStatWithOptions(bucket: string, channel: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetLiveChannelStatResponse {
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  channel = OpenApiUtil.getEncodeParam(channel);
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetLiveChannelStat',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/${channel}?live&comp=stat`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',  };
  return execute(params, req, runtime);
}

model GetObjectHeaders {
  commonHeaders?: map[string]string,
  acceptEncoding?: string(name='Accept-Encoding'),
  ifMatch?: string(name='If-Match'),
  ifModifiedSince?: string(name='If-Modified-Since'),
  ifNoneMatch?: string(name='If-None-Match'),
  ifUnmodifiedSince?: string(name='If-Unmodified-Since'),
  range?: string(name='Range'),
}

model GetObjectRequest {
  responseCacheControl?: string(name='response-cache-control'),
  responseContentDisposition?: string(name='response-content-disposition'),
  responseContentEncoding?: string(name='response-content-encoding'),
  responseContentLanguage?: string(name='response-content-language'),
  responseContentType?: string(name='response-content-type'),
  responseExpires?: string(name='response-expires'),
}

model GetObjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: readable(name='body'),
}

async function getObject(bucket: string, key: string, request: GetObjectRequest): GetObjectResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new GetObjectHeaders{};
  return getObjectWithOptions(bucket, key, request, headers, runtime);
}

async function getObjectWithOptions(bucket: string, key: string, request: GetObjectRequest, headers: GetObjectHeaders, runtime: Util.RuntimeOptions): GetObjectResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  key = OpenApiUtil.getEncodeParam(key);
  var query : map[string]any = {};
  if (!Util.isUnset(request.responseCacheControl)) {
    query['response-cache-control'] = request.responseCacheControl;
  }
  if (!Util.isUnset(request.responseContentDisposition)) {
    query['response-content-disposition'] = request.responseContentDisposition;
  }
  if (!Util.isUnset(request.responseContentEncoding)) {
    query['response-content-encoding'] = request.responseContentEncoding;
  }
  if (!Util.isUnset(request.responseContentLanguage)) {
    query['response-content-language'] = request.responseContentLanguage;
  }
  if (!Util.isUnset(request.responseContentType)) {
    query['response-content-type'] = request.responseContentType;
  }
  if (!Util.isUnset(request.responseExpires)) {
    query['response-expires'] = request.responseExpires;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.acceptEncoding)) {
    realHeaders['Accept-Encoding'] = Util.toJSONString(headers.acceptEncoding);
  }
  if (!Util.isUnset(headers.ifMatch)) {
    realHeaders['If-Match'] = Util.toJSONString(headers.ifMatch);
  }
  if (!Util.isUnset(headers.ifModifiedSince)) {
    realHeaders['If-Modified-Since'] = Util.toJSONString(headers.ifModifiedSince);
  }
  if (!Util.isUnset(headers.ifNoneMatch)) {
    realHeaders['If-None-Match'] = Util.toJSONString(headers.ifNoneMatch);
  }
  if (!Util.isUnset(headers.ifUnmodifiedSince)) {
    realHeaders['If-Unmodified-Since'] = Util.toJSONString(headers.ifUnmodifiedSince);
  }
  if (!Util.isUnset(headers.range)) {
    realHeaders['Range'] = Util.toJSONString(headers.range);
  }
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetObject',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/${key}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'binary',
  };
  return execute(params, req, runtime);
}

model GetObjectAclRequest {
  versionId?: string(name='versionId'),
}

model GetObjectAclResponseBody = {
  accessControlList?: {
    ACL?: string(name='Grant'),
  }(name='AccessControlList'),
  owner?: Owner(name='Owner'),
}

model GetObjectAclResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetObjectAclResponseBody(name='body'),
}

async function getObjectAcl(bucket: string, key: string, request: GetObjectAclRequest): GetObjectAclResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getObjectAclWithOptions(bucket, key, request, headers, runtime);
}

async function getObjectAclWithOptions(bucket: string, key: string, request: GetObjectAclRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetObjectAclResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  key = OpenApiUtil.getEncodeParam(key);
  var query : map[string]any = {};
  if (!Util.isUnset(request.versionId)) {
    query['versionId'] = request.versionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetObjectAcl',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/${key}?acl`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',  };
  return execute(params, req, runtime);
}

model GetObjectMetaRequest {
  versionId?: string(name='versionId'),
}

model GetObjectMetaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function getObjectMeta(bucket: string, key: string, request: GetObjectMetaRequest): GetObjectMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getObjectMetaWithOptions(bucket, key, request, headers, runtime);
}

async function getObjectMetaWithOptions(bucket: string, key: string, request: GetObjectMetaRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetObjectMetaResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  key = OpenApiUtil.getEncodeParam(key);
  var query : map[string]any = {};
  if (!Util.isUnset(request.versionId)) {
    query['versionId'] = request.versionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetObjectMeta',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/${key}?objectMeta`,
    method = 'HEAD',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model GetObjectTaggingRequest {
  versionId?: string(name='versionId'),
}

model GetObjectTaggingResponseBody = {
  tagSet?: TagSet(name='TagSet'),
}

model GetObjectTaggingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetObjectTaggingResponseBody(name='body'),
}

async function getObjectTagging(bucket: string, key: string, request: GetObjectTaggingRequest): GetObjectTaggingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getObjectTaggingWithOptions(bucket, key, request, headers, runtime);
}

async function getObjectTaggingWithOptions(bucket: string, key: string, request: GetObjectTaggingRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetObjectTaggingResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  key = OpenApiUtil.getEncodeParam(key);
  var query : map[string]any = {};
  if (!Util.isUnset(request.versionId)) {
    query['versionId'] = request.versionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetObjectTagging',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/${key}?tagging`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',  };
  return execute(params, req, runtime);
}

model GetSymlinkRequest {
  versionId?: string(name='versionId'),
}

model GetSymlinkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function getSymlink(bucket: string, key: string, request: GetSymlinkRequest): GetSymlinkResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getSymlinkWithOptions(bucket, key, request, headers, runtime);
}

async function getSymlinkWithOptions(bucket: string, key: string, request: GetSymlinkRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetSymlinkResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  key = OpenApiUtil.getEncodeParam(key);
  var query : map[string]any = {};
  if (!Util.isUnset(request.versionId)) {
    query['versionId'] = request.versionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSymlink',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/${key}?symlink`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

model GetVodPlaylistRequest {
  endTime?: string(name='endTime'),
  startTime?: string(name='startTime'),
}

model GetVodPlaylistResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: readable(name='body'),
}

async function getVodPlaylist(bucket: string, channel: string, request: GetVodPlaylistRequest): GetVodPlaylistResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getVodPlaylistWithOptions(bucket, channel, request, headers, runtime);
}

async function getVodPlaylistWithOptions(bucket: string, channel: string, request: GetVodPlaylistRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetVodPlaylistResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  channel = OpenApiUtil.getEncodeParam(channel);
  var query : map[string]any = {};
  if (!Util.isUnset(request.endTime)) {
    query['endTime'] = request.endTime;
  }
  if (!Util.isUnset(request.startTime)) {
    query['startTime'] = request.startTime;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetVodPlaylist',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/${channel}?vod`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'binary',
  };
  return execute(params, req, runtime);
}

model HeadObjectHeaders {
  commonHeaders?: map[string]string,
  ifMatch?: string(name='If-Match'),
  ifModifiedSince?: string(name='If-Modified-Since'),
  ifNoneMatch?: string(name='If-None-Match'),
  ifUnmodifiedSince?: string(name='If-Unmodified-Since'),
}

model HeadObjectRequest {
  versionId?: string(name='versionId'),
}

model HeadObjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function headObject(bucket: string, key: string, request: HeadObjectRequest): HeadObjectResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new HeadObjectHeaders{};
  return headObjectWithOptions(bucket, key, request, headers, runtime);
}

async function headObjectWithOptions(bucket: string, key: string, request: HeadObjectRequest, headers: HeadObjectHeaders, runtime: Util.RuntimeOptions): HeadObjectResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  key = OpenApiUtil.getEncodeParam(key);
  var query : map[string]any = {};
  if (!Util.isUnset(request.versionId)) {
    query['versionId'] = request.versionId;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.ifMatch)) {
    realHeaders['If-Match'] = Util.toJSONString(headers.ifMatch);
  }
  if (!Util.isUnset(headers.ifModifiedSince)) {
    realHeaders['If-Modified-Since'] = Util.toJSONString(headers.ifModifiedSince);
  }
  if (!Util.isUnset(headers.ifNoneMatch)) {
    realHeaders['If-None-Match'] = Util.toJSONString(headers.ifNoneMatch);
  }
  if (!Util.isUnset(headers.ifUnmodifiedSince)) {
    realHeaders['If-Unmodified-Since'] = Util.toJSONString(headers.ifUnmodifiedSince);
  }
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'HeadObject',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/${key}`,
    method = 'HEAD',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model InitiateBucketWormRequest {
  initiateWormConfiguration?: InitiateWormConfiguration(name='InitiateWormConfiguration'),
}

model InitiateBucketWormResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function initiateBucketWorm(bucket: string, request: InitiateBucketWormRequest): InitiateBucketWormResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return initiateBucketWormWithOptions(bucket, request, headers, runtime);
}

async function initiateBucketWormWithOptions(bucket: string, request: InitiateBucketWormRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InitiateBucketWormResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(request.initiateWormConfiguration),
  };
  var params = new OpenApi.Params{
    action = 'InitiateBucketWorm',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/?worm`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

model InitiateMultipartUploadHeaders {
  commonHeaders?: map[string]string,
  cacheControl?: string(name='Cache-Control'),
  contentDisposition?: string(name='Content-Disposition'),
  contentEncoding?: string(name='Content-Encoding'),
  expires?: string(name='Expires'),
  forbidOverwrite?: string(name='x-oss-forbid-overwrite'),
  sseDataEncryption?: string(name='x-oss-server-side-data-encryption'),
  serverSideEncryption?: string(name='x-oss-server-side-encryption'),
  sseKeyId?: string(name='x-oss-server-side-encryption-key-id'),
  storageClass?: string(name='x-oss-storage-class'),
  tagging?: string(name='x-oss-tagging'),
}

model InitiateMultipartUploadRequest {
  encodingType?: string(name='encoding-type'),
}

model InitiateMultipartUploadResponseBody = {
  bucket?: string(name='Bucket'),
  encodingType?: string(name='EncodingType'),
  key?: string(name='Key'),
  uploadId?: string(name='UploadId'),
}

model InitiateMultipartUploadResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InitiateMultipartUploadResponseBody(name='body'),
}

async function initiateMultipartUpload(bucket: string, key: string, request: InitiateMultipartUploadRequest): InitiateMultipartUploadResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new InitiateMultipartUploadHeaders{};
  return initiateMultipartUploadWithOptions(bucket, key, request, headers, runtime);
}

async function initiateMultipartUploadWithOptions(bucket: string, key: string, request: InitiateMultipartUploadRequest, headers: InitiateMultipartUploadHeaders, runtime: Util.RuntimeOptions): InitiateMultipartUploadResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  key = OpenApiUtil.getEncodeParam(key);
  var query : map[string]any = {};
  if (!Util.isUnset(request.encodingType)) {
    query['encoding-type'] = request.encodingType;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.cacheControl)) {
    realHeaders['Cache-Control'] = Util.toJSONString(headers.cacheControl);
  }
  if (!Util.isUnset(headers.contentDisposition)) {
    realHeaders['Content-Disposition'] = Util.toJSONString(headers.contentDisposition);
  }
  if (!Util.isUnset(headers.contentEncoding)) {
    realHeaders['Content-Encoding'] = Util.toJSONString(headers.contentEncoding);
  }
  if (!Util.isUnset(headers.expires)) {
    realHeaders['Expires'] = Util.toJSONString(headers.expires);
  }
  if (!Util.isUnset(headers.forbidOverwrite)) {
    realHeaders['x-oss-forbid-overwrite'] = Util.toJSONString(headers.forbidOverwrite);
  }
  if (!Util.isUnset(headers.sseDataEncryption)) {
    realHeaders['x-oss-server-side-data-encryption'] = Util.toJSONString(headers.sseDataEncryption);
  }
  if (!Util.isUnset(headers.serverSideEncryption)) {
    realHeaders['x-oss-server-side-encryption'] = Util.toJSONString(headers.serverSideEncryption);
  }
  if (!Util.isUnset(headers.sseKeyId)) {
    realHeaders['x-oss-server-side-encryption-key-id'] = Util.toJSONString(headers.sseKeyId);
  }
  if (!Util.isUnset(headers.storageClass)) {
    realHeaders['x-oss-storage-class'] = Util.toJSONString(headers.storageClass);
  }
  if (!Util.isUnset(headers.tagging)) {
    realHeaders['x-oss-tagging'] = Util.toJSONString(headers.tagging);
  }
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InitiateMultipartUpload',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/${key}?uploads`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',  };
  return execute(params, req, runtime);
}

model ListBucketInventoryRequest {
  continuationToken?: string(name='continuation-token'),
}

model ListBucketInventoryResponseBody = {
  inventoryConfigurations?: [
    InventoryConfiguration
  ](name='InventoryConfiguration'),
  isTruncated?: boolean(name='IsTruncated'),
  nextContinuationToken?: string(name='NextContinuationToken'),
}

model ListBucketInventoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListBucketInventoryResponseBody(name='body'),
}

async function listBucketInventory(bucket: string, request: ListBucketInventoryRequest): ListBucketInventoryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listBucketInventoryWithOptions(bucket, request, headers, runtime);
}

async function listBucketInventoryWithOptions(bucket: string, request: ListBucketInventoryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListBucketInventoryResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var query : map[string]any = {};
  if (!Util.isUnset(request.continuationToken)) {
    query['continuation-token'] = request.continuationToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListBucketInventory',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/?inventory`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',  };
  return execute(params, req, runtime);
}

model ListBucketsRequest {
  marker?: string(name='marker'),
  maxKeys?: long(name='max-keys'),
  prefix?: string(name='prefix'),
}

model ListBucketsResponseBody = {
  buckets?: {
    buckets?: [
      Bucket
    ](name='Bucket'),
  }(name='Buckets'),
  isTruncated?: boolean(name='IsTruncated'),
  marker?: string(name='Marker'),
  maxKeys?: long(name='MaxKeys'),
  nextMarker?: string(name='NextMarker'),
  owner?: Owner(name='Owner'),
  prefix?: string(name='Prefix'),
}

model ListBucketsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListBucketsResponseBody(name='body'),
}

async function listBuckets(request: ListBucketsRequest): ListBucketsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listBucketsWithOptions(request, headers, runtime);
}

async function listBucketsWithOptions(request: ListBucketsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListBucketsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.marker)) {
    query['marker'] = request.marker;
  }
  if (!Util.isUnset(request.maxKeys)) {
    query['max-keys'] = request.maxKeys;
  }
  if (!Util.isUnset(request.prefix)) {
    query['prefix'] = request.prefix;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListBuckets',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',  };
  return execute(params, req, runtime);
}

model ListLiveChannelRequest {
  marker?: string(name='marker'),
  maxKeys?: long(name='max-keys'),
  prefix?: string(name='prefix'),
}

model ListLiveChannelResponseBody = {
  isTruncated?: boolean(name='IsTruncated'),
  liveChannels?: [
    LiveChannel
  ](name='LiveChannel'),
  marker?: string(name='Marker'),
  maxKeys?: long(name='MaxKeys'),
  nextMarker?: string(name='NextMarker'),
  prefix?: string(name='Prefix'),
}

model ListLiveChannelResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListLiveChannelResponseBody(name='body'),
}

async function listLiveChannel(bucket: string, request: ListLiveChannelRequest): ListLiveChannelResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listLiveChannelWithOptions(bucket, request, headers, runtime);
}

async function listLiveChannelWithOptions(bucket: string, request: ListLiveChannelRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListLiveChannelResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var query : map[string]any = {};
  if (!Util.isUnset(request.marker)) {
    query['marker'] = request.marker;
  }
  if (!Util.isUnset(request.maxKeys)) {
    query['max-keys'] = request.maxKeys;
  }
  if (!Util.isUnset(request.prefix)) {
    query['prefix'] = request.prefix;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLiveChannel',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/?live`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',  };
  return execute(params, req, runtime);
}

model ListMultipartUploadsRequest {
  delimiter?: string(name='delimiter'),
  encodingType?: string(name='encoding-type'),
  keyMarker?: string(name='key-marker'),
  maxUploads?: long(name='max-uploads'),
  prefix?: string(name='prefix'),
  uploadIdMarker?: string(name='upload-id-marker'),
}

model ListMultipartUploadsResponseBody = {
  bucket?: string(name='Bucket'),
  commonPrefixes?: [
    CommonPrefix
  ](name='CommonPrefixes'),
  delimiter?: string(name='Delimiter'),
  encodingType?: string(name='EncodingType'),
  isTruncated?: boolean(name='IsTruncated'),
  keyMarker?: string(name='KeyMarker'),
  maxUploads?: long(name='MaxUploads'),
  nextKeyMarker?: string(name='NextKeyMarker'),
  nextUploadIdMarker?: string(name='NextUploadIdMarker'),
  prefix?: string(name='Prefix'),
  uploads?: [
    Upload
  ](name='Upload'),
  uploadIdMarker?: string(name='UploadIdMarker'),
}

model ListMultipartUploadsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListMultipartUploadsResponseBody(name='body'),
}

async function listMultipartUploads(bucket: string, request: ListMultipartUploadsRequest): ListMultipartUploadsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listMultipartUploadsWithOptions(bucket, request, headers, runtime);
}

async function listMultipartUploadsWithOptions(bucket: string, request: ListMultipartUploadsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListMultipartUploadsResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var query : map[string]any = {};
  if (!Util.isUnset(request.delimiter)) {
    query['delimiter'] = request.delimiter;
  }
  if (!Util.isUnset(request.encodingType)) {
    query['encoding-type'] = request.encodingType;
  }
  if (!Util.isUnset(request.keyMarker)) {
    query['key-marker'] = request.keyMarker;
  }
  if (!Util.isUnset(request.maxUploads)) {
    query['max-uploads'] = request.maxUploads;
  }
  if (!Util.isUnset(request.prefix)) {
    query['prefix'] = request.prefix;
  }
  if (!Util.isUnset(request.uploadIdMarker)) {
    query['upload-id-marker'] = request.uploadIdMarker;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListMultipartUploads',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/?uploads`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',  };
  return execute(params, req, runtime);
}

model ListObjectVersionsRequest {
  delimiter?: string(name='delimiter'),
  encodingType?: string(name='encoding-type'),
  keyMarker?: string(name='key-marker'),
  maxKeys?: long(name='max-keys'),
  prefix?: string(name='prefix'),
  versionIdMarker?: string(name='version-id-marker'),
}

model ListObjectVersionsResponseBody = {
  commonPrefixes?: [
    CommonPrefix
  ](name='CommonPrefixes'),
  deleteMarkers?: [
    DeleteMarkerEntry
  ](name='DeleteMarker'),
  delimiter?: string(name='Delimiter'),
  encodingType?: string(name='EncodingType'),
  isTruncated?: boolean(name='IsTruncated'),
  keyMarker?: string(name='KeyMarker'),
  maxKeys?: long(name='MaxKeys'),
  name?: string(name='Name'),
  nextKeyMarker?: string(name='NextKeyMarker'),
  nextVersionIdMarker?: string(name='NextVersionIdMarker'),
  prefix?: string(name='Prefix'),
  versions?: [
    ObjectVersion
  ](name='Version'),
  versionIdMarker?: string(name='VersionIdMarker'),
}

model ListObjectVersionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListObjectVersionsResponseBody(name='body'),
}

async function listObjectVersions(bucket: string, request: ListObjectVersionsRequest): ListObjectVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listObjectVersionsWithOptions(bucket, request, headers, runtime);
}

async function listObjectVersionsWithOptions(bucket: string, request: ListObjectVersionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListObjectVersionsResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var query : map[string]any = {};
  if (!Util.isUnset(request.delimiter)) {
    query['delimiter'] = request.delimiter;
  }
  if (!Util.isUnset(request.encodingType)) {
    query['encoding-type'] = request.encodingType;
  }
  if (!Util.isUnset(request.keyMarker)) {
    query['key-marker'] = request.keyMarker;
  }
  if (!Util.isUnset(request.maxKeys)) {
    query['max-keys'] = request.maxKeys;
  }
  if (!Util.isUnset(request.prefix)) {
    query['prefix'] = request.prefix;
  }
  if (!Util.isUnset(request.versionIdMarker)) {
    query['version-id-marker'] = request.versionIdMarker;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListObjectVersions',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/?versions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',  };
  return execute(params, req, runtime);
}

model ListObjectsRequest {
  delimiter?: string(name='delimiter'),
  encodingType?: string(name='encoding-type'),
  marker?: string(name='marker'),
  maxKeys?: long(name='max-keys'),
  prefix?: string(name='prefix'),
}

model ListObjectsResponseBody = {
  commonPrefixes?: [
    CommonPrefix
  ](name='CommonPrefixes'),
  contents?: [
    ObjectSummary
  ](name='Contents'),
  delimiter?: string(name='Delimiter'),
  encodingType?: string(name='EncodingType'),
  isTruncated?: boolean(name='IsTruncated'),
  marker?: string(name='Marker'),
  maxKeys?: int32(name='MaxKeys'),
  name?: string(name='Name'),
  nextMarker?: string(name='NextMarker'),
  prefix?: string(name='Prefix'),
}

model ListObjectsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListObjectsResponseBody(name='body'),
}

async function listObjects(bucket: string, request: ListObjectsRequest): ListObjectsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listObjectsWithOptions(bucket, request, headers, runtime);
}

async function listObjectsWithOptions(bucket: string, request: ListObjectsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListObjectsResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var query : map[string]any = {};
  if (!Util.isUnset(request.delimiter)) {
    query['delimiter'] = request.delimiter;
  }
  if (!Util.isUnset(request.encodingType)) {
    query['encoding-type'] = request.encodingType;
  }
  if (!Util.isUnset(request.marker)) {
    query['marker'] = request.marker;
  }
  if (!Util.isUnset(request.maxKeys)) {
    query['max-keys'] = request.maxKeys;
  }
  if (!Util.isUnset(request.prefix)) {
    query['prefix'] = request.prefix;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListObjects',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',  };
  return execute(params, req, runtime);
}

model ListObjectsV2Request {
  continuationToken?: string(name='continuation-token'),
  delimiter?: string(name='delimiter'),
  encodingType?: string(name='encoding-type'),
  fetchOwner?: boolean(name='fetch-owner'),
  maxKeys?: long(name='max-keys'),
  prefix?: string(name='prefix'),
  startAfter?: string(name='start-after'),
}

model ListObjectsV2ResponseBody = {
  commonPrefixes?: [
    CommonPrefix
  ](name='CommonPrefixes'),
  contents?: [
    ObjectSummary
  ](name='Contents'),
  continuationToken?: string(name='ContinuationToken'),
  delimiter?: string(name='Delimiter'),
  encodingType?: string(name='EncodingType'),
  isTruncated?: boolean(name='IsTruncated'),
  keyCount?: int32(name='KeyCount'),
  maxKeys?: int32(name='MaxKeys'),
  name?: string(name='Name'),
  nextContinuationToken?: string(name='NextContinuationToken'),
  prefix?: string(name='Prefix'),
  startAfter?: string(name='StartAfter'),
}

model ListObjectsV2Response = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListObjectsV2ResponseBody(name='body'),
}

async function listObjectsV2(bucket: string, request: ListObjectsV2Request): ListObjectsV2Response {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listObjectsV2WithOptions(bucket, request, headers, runtime);
}

async function listObjectsV2WithOptions(bucket: string, request: ListObjectsV2Request, headers: map[string]string, runtime: Util.RuntimeOptions): ListObjectsV2Response {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var query : map[string]any = {};
  if (!Util.isUnset(request.continuationToken)) {
    query['continuation-token'] = request.continuationToken;
  }
  if (!Util.isUnset(request.delimiter)) {
    query['delimiter'] = request.delimiter;
  }
  if (!Util.isUnset(request.encodingType)) {
    query['encoding-type'] = request.encodingType;
  }
  if (!Util.isUnset(request.fetchOwner)) {
    query['fetch-owner'] = request.fetchOwner;
  }
  if (!Util.isUnset(request.maxKeys)) {
    query['max-keys'] = request.maxKeys;
  }
  if (!Util.isUnset(request.prefix)) {
    query['prefix'] = request.prefix;
  }
  if (!Util.isUnset(request.startAfter)) {
    query['start-after'] = request.startAfter;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListObjectsV2',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/?list-type=2`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',  };
  return execute(params, req, runtime);
}

model ListPartsRequest {
  encodingType?: string(name='encoding-type'),
  maxParts?: long(name='max-parts'),
  partNumberMarker?: long(name='part-number-marker'),
  uploadId?: string(name='uploadId'),
}

model ListPartsShrinkRequest {
  encodingTypeShrink?: string(name='encoding-type'),
  maxParts?: long(name='max-parts'),
  partNumberMarker?: long(name='part-number-marker'),
  uploadId?: string(name='uploadId'),
}

model ListPartsResponseBody = {
  bucket?: string(name='Bucket'),
  isTruncated?: boolean(name='IsTruncated'),
  key?: string(name='Key'),
  maxParts?: long(name='MaxParts'),
  nextPartNumberMarker?: long(name='NextPartNumberMarker'),
  part?: [
    Part
  ](name='Part'),
  partNumberMarker?: long(name='PartNumberMarker'),
  uploadId?: string(name='UploadId'),
}

model ListPartsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPartsResponseBody(name='body'),
}

async function listParts(bucket: string, key: string, request: ListPartsRequest): ListPartsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPartsWithOptions(bucket, key, request, headers, runtime);
}

async function listPartsWithOptions(bucket: string, key: string, tmpReq: ListPartsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPartsResponse {
  Util.validateModel(tmpReq);
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  key = OpenApiUtil.getEncodeParam(key);
  var request = new ListPartsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.encodingType)) {
    request.encodingTypeShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.encodingType, 'encoding-type', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.encodingTypeShrink)) {
    query['encoding-type'] = request.encodingTypeShrink;
  }
  if (!Util.isUnset(request.maxParts)) {
    query['max-parts'] = request.maxParts;
  }
  if (!Util.isUnset(request.partNumberMarker)) {
    query['part-number-marker'] = request.partNumberMarker;
  }
  if (!Util.isUnset(request.uploadId)) {
    query['uploadId'] = request.uploadId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListParts',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/${key}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',  };
  return execute(params, req, runtime);
}

model OptionObjectHeaders {
  commonHeaders?: map[string]string,
  accessControlRequestHeaders?: string(name='Access-Control-Request-Headers'),
  accessControlRequestMethod	?: string(name='Access-Control-Request-Method'),
  origin?: string(name='Origin'),
}

model OptionObjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function optionObject(bucket: string, key: string): OptionObjectResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new OptionObjectHeaders{};
  return optionObjectWithOptions(bucket, key, headers, runtime);
}

async function optionObjectWithOptions(bucket: string, key: string, headers: OptionObjectHeaders, runtime: Util.RuntimeOptions): OptionObjectResponse {
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  key = OpenApiUtil.getEncodeParam(key);
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.accessControlRequestHeaders)) {
    realHeaders['Access-Control-Request-Headers'] = Util.toJSONString(headers.accessControlRequestHeaders);
  }
  if (!Util.isUnset(headers.accessControlRequestMethod	)) {
    realHeaders['Access-Control-Request-Method'] = Util.toJSONString(headers.accessControlRequestMethod	);
  }
  if (!Util.isUnset(headers.origin)) {
    realHeaders['Origin'] = Util.toJSONString(headers.origin);
  }
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = realHeaders,
  };
  var params = new OpenApi.Params{
    action = 'OptionObject',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/${key}`,
    method = 'OPTIONS',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

model PostObjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function postObject(bucket: string): PostObjectResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return postObjectWithOptions(bucket, headers, runtime);
}

async function postObjectWithOptions(bucket: string, headers: map[string]string, runtime: Util.RuntimeOptions): PostObjectResponse {
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'PostObject',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'multiFormData',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

model PostVodPlaylistRequest {
  endTime?: string(name='endTime'),
  startTime?: string(name='startTime'),
}

model PostVodPlaylistResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function postVodPlaylist(bucket: string, channel: string, playlist: string, request: PostVodPlaylistRequest): PostVodPlaylistResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return postVodPlaylistWithOptions(bucket, channel, playlist, request, headers, runtime);
}

async function postVodPlaylistWithOptions(bucket: string, channel: string, playlist: string, request: PostVodPlaylistRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PostVodPlaylistResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  channel = OpenApiUtil.getEncodeParam(channel);
  playlist = OpenApiUtil.getEncodeParam(playlist);
  var query : map[string]any = {};
  if (!Util.isUnset(request.endTime)) {
    query['endTime'] = request.endTime;
  }
  if (!Util.isUnset(request.startTime)) {
    query['startTime'] = request.startTime;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PostVodPlaylist',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/${channel}/${playlist}?vod`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

model PutBucketHeaders {
  commonHeaders?: map[string]string,
  acl?: string(name='x-oss-acl'),
}

model PutBucketRequest {
  createBucketConfiguration?: CreateBucketConfiguration(name='CreateBucketConfiguration'),
}

model PutBucketResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function putBucket(bucket: string, request: PutBucketRequest): PutBucketResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new PutBucketHeaders{};
  return putBucketWithOptions(bucket, request, headers, runtime);
}

async function putBucketWithOptions(bucket: string, request: PutBucketRequest, headers: PutBucketHeaders, runtime: Util.RuntimeOptions): PutBucketResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.acl)) {
    realHeaders['x-oss-acl'] = Util.toJSONString(headers.acl);
  }
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(request.createBucketConfiguration),
  };
  var params = new OpenApi.Params{
    action = 'PutBucket',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

model PutBucketAclHeaders {
  commonHeaders?: map[string]string,
  acl?: string(name='x-oss-acl'),
}

model PutBucketAclResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function putBucketAcl(bucket: string): PutBucketAclResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new PutBucketAclHeaders{};
  return putBucketAclWithOptions(bucket, headers, runtime);
}

async function putBucketAclWithOptions(bucket: string, headers: PutBucketAclHeaders, runtime: Util.RuntimeOptions): PutBucketAclResponse {
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.acl)) {
    realHeaders['x-oss-acl'] = Util.toJSONString(headers.acl);
  }
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = realHeaders,
  };
  var params = new OpenApi.Params{
    action = 'PutBucketAcl',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/?acl`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

model PutBucketCorsRequest {
  cORSConfiguration?: CORSConfiguration(name='CORSConfiguration'),
}

model PutBucketCorsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function putBucketCors(bucket: string, request: PutBucketCorsRequest): PutBucketCorsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putBucketCorsWithOptions(bucket, request, headers, runtime);
}

async function putBucketCorsWithOptions(bucket: string, request: PutBucketCorsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutBucketCorsResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(request.cORSConfiguration),
  };
  var params = new OpenApi.Params{
    action = 'PutBucketCors',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/?cors`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

model PutBucketEncryptionRequest {
  serverSideEncryptionRule?: ServerSideEncryptionRule(name='ServerSideEncryptionRule'),
}

model PutBucketEncryptionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function putBucketEncryption(bucket: string, request: PutBucketEncryptionRequest): PutBucketEncryptionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putBucketEncryptionWithOptions(bucket, request, headers, runtime);
}

async function putBucketEncryptionWithOptions(bucket: string, request: PutBucketEncryptionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutBucketEncryptionResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(request.serverSideEncryptionRule),
  };
  var params = new OpenApi.Params{
    action = 'PutBucketEncryption',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/?encryption`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

model PutBucketInventoryRequest {
  inventoryConfiguration?: InventoryConfiguration(name='InventoryConfiguration'),
  inventoryId?: string(name='inventoryId'),
}

model PutBucketInventoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function putBucketInventory(bucket: string, request: PutBucketInventoryRequest): PutBucketInventoryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putBucketInventoryWithOptions(bucket, request, headers, runtime);
}

async function putBucketInventoryWithOptions(bucket: string, request: PutBucketInventoryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutBucketInventoryResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var query : map[string]any = {};
  if (!Util.isUnset(request.inventoryId)) {
    query['inventoryId'] = request.inventoryId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(request.inventoryConfiguration),
  };
  var params = new OpenApi.Params{
    action = 'PutBucketInventory',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/?inventory`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

model PutBucketLifecycleRequest {
  lifecycleConfiguration?: LifecycleConfiguration(name='LifecycleConfiguration'),
}

model PutBucketLifecycleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function putBucketLifecycle(bucket: string, request: PutBucketLifecycleRequest): PutBucketLifecycleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putBucketLifecycleWithOptions(bucket, request, headers, runtime);
}

async function putBucketLifecycleWithOptions(bucket: string, request: PutBucketLifecycleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutBucketLifecycleResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(request.lifecycleConfiguration),
  };
  var params = new OpenApi.Params{
    action = 'PutBucketLifecycle',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/?lifecycle`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

model PutBucketLoggingRequest {
  bucketLoggingStatus?: BucketLoggingStatus(name='BucketLoggingStatus'),
}

model PutBucketLoggingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function putBucketLogging(bucket: string, request: PutBucketLoggingRequest): PutBucketLoggingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putBucketLoggingWithOptions(bucket, request, headers, runtime);
}

async function putBucketLoggingWithOptions(bucket: string, request: PutBucketLoggingRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutBucketLoggingResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(request.bucketLoggingStatus),
  };
  var params = new OpenApi.Params{
    action = 'PutBucketLogging',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/?logging`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

model PutBucketPolicyRequest {
  policy?: string(name='body'),
}

model PutBucketPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function putBucketPolicy(bucket: string, request: PutBucketPolicyRequest): PutBucketPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putBucketPolicyWithOptions(bucket, request, headers, runtime);
}

async function putBucketPolicyWithOptions(bucket: string, request: PutBucketPolicyRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutBucketPolicyResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = request.policy,
  };
  var params = new OpenApi.Params{
    action = 'PutBucketPolicy',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/?policy`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model PutBucketRefererRequest {
  refererConfiguration?: RefererConfiguration(name='RefererConfiguration'),
}

model PutBucketRefererResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function putBucketReferer(bucket: string, request: PutBucketRefererRequest): PutBucketRefererResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putBucketRefererWithOptions(bucket, request, headers, runtime);
}

async function putBucketRefererWithOptions(bucket: string, request: PutBucketRefererRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutBucketRefererResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(request.refererConfiguration),
  };
  var params = new OpenApi.Params{
    action = 'PutBucketReferer',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/?referer`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

model PutBucketReplicationRequest {
  replicationConfiguration?: ReplicationConfiguration(name='ReplicationConfiguration'),
}

model PutBucketReplicationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function putBucketReplication(bucket: string, request: PutBucketReplicationRequest): PutBucketReplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putBucketReplicationWithOptions(bucket, request, headers, runtime);
}

async function putBucketReplicationWithOptions(bucket: string, request: PutBucketReplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutBucketReplicationResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(request.replicationConfiguration),
  };
  var params = new OpenApi.Params{
    action = 'PutBucketReplication',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/?replication&comp=add`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

model PutBucketRequestPaymentRequest {
  requestPaymentConfiguration?: RequestPaymentConfiguration(name='RequestPaymentConfiguration'),
}

model PutBucketRequestPaymentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function putBucketRequestPayment(bucket: string, request: PutBucketRequestPaymentRequest): PutBucketRequestPaymentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putBucketRequestPaymentWithOptions(bucket, request, headers, runtime);
}

async function putBucketRequestPaymentWithOptions(bucket: string, request: PutBucketRequestPaymentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutBucketRequestPaymentResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(request.requestPaymentConfiguration),
  };
  var params = new OpenApi.Params{
    action = 'PutBucketRequestPayment',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/?requestPayment`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

model PutBucketTagsRequest {
  tagging?: Tagging(name='Tagging'),
}

model PutBucketTagsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function putBucketTags(bucket: string, request: PutBucketTagsRequest): PutBucketTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putBucketTagsWithOptions(bucket, request, headers, runtime);
}

async function putBucketTagsWithOptions(bucket: string, request: PutBucketTagsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutBucketTagsResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(request.tagging),
  };
  var params = new OpenApi.Params{
    action = 'PutBucketTags',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/?tagging`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

model PutBucketTransferAccelerationRequest {
  transferAccelerationConfiguration?: TransferAccelerationConfiguration(name='TransferAccelerationConfiguration'),
}

model PutBucketTransferAccelerationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function putBucketTransferAcceleration(bucket: string, request: PutBucketTransferAccelerationRequest): PutBucketTransferAccelerationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putBucketTransferAccelerationWithOptions(bucket, request, headers, runtime);
}

async function putBucketTransferAccelerationWithOptions(bucket: string, request: PutBucketTransferAccelerationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutBucketTransferAccelerationResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(request.transferAccelerationConfiguration),
  };
  var params = new OpenApi.Params{
    action = 'PutBucketTransferAcceleration',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/?transferAcceleration`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

model PutBucketVersioningRequest {
  versioningConfiguration?: VersioningConfiguration(name='VersioningConfiguration'),
}

model PutBucketVersioningResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function putBucketVersioning(bucket: string, request: PutBucketVersioningRequest): PutBucketVersioningResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putBucketVersioningWithOptions(bucket, request, headers, runtime);
}

async function putBucketVersioningWithOptions(bucket: string, request: PutBucketVersioningRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutBucketVersioningResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(request.versioningConfiguration),
  };
  var params = new OpenApi.Params{
    action = 'PutBucketVersioning',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/?versioning`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

model PutBucketWebsiteRequest {
  websiteConfiguration?: WebsiteConfiguration(name='WebsiteConfiguration'),
}

model PutBucketWebsiteResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function putBucketWebsite(bucket: string, request: PutBucketWebsiteRequest): PutBucketWebsiteResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putBucketWebsiteWithOptions(bucket, request, headers, runtime);
}

async function putBucketWebsiteWithOptions(bucket: string, request: PutBucketWebsiteRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutBucketWebsiteResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(request.websiteConfiguration),
  };
  var params = new OpenApi.Params{
    action = 'PutBucketWebsite',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/?website`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

model PutLiveChannelRequest {
  liveChannelConfiguration?: LiveChannelConfiguration(name='LiveChannelConfiguration'),
}

model PutLiveChannelResponseBody = {
  playUrls?: LiveChannelPlayUrls(name='PlayUrls'),
  publishUrls?: LiveChannelPublishUrls(name='PublishUrls'),
}

model PutLiveChannelResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PutLiveChannelResponseBody(name='body'),
}

async function putLiveChannel(bucket: string, channel: string, request: PutLiveChannelRequest): PutLiveChannelResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putLiveChannelWithOptions(bucket, channel, request, headers, runtime);
}

async function putLiveChannelWithOptions(bucket: string, channel: string, request: PutLiveChannelRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutLiveChannelResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  channel = OpenApiUtil.getEncodeParam(channel);
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(request.liveChannelConfiguration),
  };
  var params = new OpenApi.Params{
    action = 'PutLiveChannel',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/${channel}?live`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',  };
  return execute(params, req, runtime);
}

model PutLiveChannelStatusRequest {
  status?: string(name='status'),
}

model PutLiveChannelStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function putLiveChannelStatus(bucket: string, channel: string, request: PutLiveChannelStatusRequest): PutLiveChannelStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putLiveChannelStatusWithOptions(bucket, channel, request, headers, runtime);
}

async function putLiveChannelStatusWithOptions(bucket: string, channel: string, request: PutLiveChannelStatusRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutLiveChannelStatusResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  channel = OpenApiUtil.getEncodeParam(channel);
  var query : map[string]any = {};
  if (!Util.isUnset(request.status)) {
    query['status'] = request.status;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PutLiveChannelStatus',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/${channel}?live`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

model PutObjectHeaders {
  commonHeaders?: map[string]string,
  forbidOverwrite?: boolean(name='x-oss-forbid-overwrite'),
  metaData?: map[string]string(name='x-oss-meta-*'),
  acl?: string(name='x-oss-object-acl'),
  sseDataEncryption?: string(name='x-oss-server-side-data-encryption'),
  serverSideEncryption?: string(name='x-oss-server-side-encryption'),
  sseKeyId?: string(name='x-oss-server-side-encryption-key-id'),
  storageClass?: string(name='x-oss-storage-class'),
  tagging?: string(name='x-oss-tagging'),
}

model PutObjectRequest {
  body?: readable(name='body'),
}

model PutObjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function putObject(bucket: string, key: string, request: PutObjectRequest): PutObjectResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new PutObjectHeaders{};
  return putObjectWithOptions(bucket, key, request, headers, runtime);
}

async function putObjectWithOptions(bucket: string, key: string, request: PutObjectRequest, headers: PutObjectHeaders, runtime: Util.RuntimeOptions): PutObjectResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  key = OpenApiUtil.getEncodeParam(key);
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.forbidOverwrite)) {
    realHeaders['x-oss-forbid-overwrite'] = Util.toJSONString(headers.forbidOverwrite);
  }
  if (!Util.isUnset(headers.metaData)) {
    realHeaders['x-oss-meta-*'] = Util.toJSONString(headers.metaData);
  }
  if (!Util.isUnset(headers.acl)) {
    realHeaders['x-oss-object-acl'] = Util.toJSONString(headers.acl);
  }
  if (!Util.isUnset(headers.sseDataEncryption)) {
    realHeaders['x-oss-server-side-data-encryption'] = Util.toJSONString(headers.sseDataEncryption);
  }
  if (!Util.isUnset(headers.serverSideEncryption)) {
    realHeaders['x-oss-server-side-encryption'] = Util.toJSONString(headers.serverSideEncryption);
  }
  if (!Util.isUnset(headers.sseKeyId)) {
    realHeaders['x-oss-server-side-encryption-key-id'] = Util.toJSONString(headers.sseKeyId);
  }
  if (!Util.isUnset(headers.storageClass)) {
    realHeaders['x-oss-storage-class'] = Util.toJSONString(headers.storageClass);
  }
  if (!Util.isUnset(headers.tagging)) {
    realHeaders['x-oss-tagging'] = Util.toJSONString(headers.tagging);
  }
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = realHeaders,
    body = request.body,
    stream = request.body,
  };
  var params = new OpenApi.Params{
    action = 'PutObject',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/${key}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'binary',
    bodyType = 'none',
  };
  return execute(params, req, runtime);
}

model PutObjectAclHeaders {
  commonHeaders?: map[string]string,
  acl?: string(name='x-oss-object-acl'),
}

model PutObjectAclRequest {
  versionId?: string(name='versionId'),
}

model PutObjectAclResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function putObjectAcl(bucket: string, key: string, request: PutObjectAclRequest): PutObjectAclResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new PutObjectAclHeaders{};
  return putObjectAclWithOptions(bucket, key, request, headers, runtime);
}

async function putObjectAclWithOptions(bucket: string, key: string, request: PutObjectAclRequest, headers: PutObjectAclHeaders, runtime: Util.RuntimeOptions): PutObjectAclResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  key = OpenApiUtil.getEncodeParam(key);
  var query : map[string]any = {};
  if (!Util.isUnset(request.versionId)) {
    query['versionId'] = request.versionId;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.acl)) {
    realHeaders['x-oss-object-acl'] = Util.toJSONString(headers.acl);
  }
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PutObjectAcl',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/${key}?acl`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

model PutObjectTaggingRequest {
  tagging?: Tagging(name='Tagging'),
  versionId?: string(name='versionId'),
}

model PutObjectTaggingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function putObjectTagging(bucket: string, key: string, request: PutObjectTaggingRequest): PutObjectTaggingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putObjectTaggingWithOptions(bucket, key, request, headers, runtime);
}

async function putObjectTaggingWithOptions(bucket: string, key: string, request: PutObjectTaggingRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutObjectTaggingResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  key = OpenApiUtil.getEncodeParam(key);
  var query : map[string]any = {};
  if (!Util.isUnset(request.versionId)) {
    query['versionId'] = request.versionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(request.tagging),
  };
  var params = new OpenApi.Params{
    action = 'PutObjectTagging',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/${key}?tagging`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

model PutSymlinkHeaders {
  commonHeaders?: map[string]string,
  forbidOverwrite?: string(name='x-oss-forbid-overwrite'),
  acl?: string(name='x-oss-object-acl'),
  storageClass?: string(name='x-oss-storage-class'),
  symlinkTargetKey?: string(name='x-oss-symlink-target'),
}

model PutSymlinkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function putSymlink(bucket: string, key: string): PutSymlinkResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new PutSymlinkHeaders{};
  return putSymlinkWithOptions(bucket, key, headers, runtime);
}

async function putSymlinkWithOptions(bucket: string, key: string, headers: PutSymlinkHeaders, runtime: Util.RuntimeOptions): PutSymlinkResponse {
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  key = OpenApiUtil.getEncodeParam(key);
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.forbidOverwrite)) {
    realHeaders['x-oss-forbid-overwrite'] = Util.toJSONString(headers.forbidOverwrite);
  }
  if (!Util.isUnset(headers.acl)) {
    realHeaders['x-oss-object-acl'] = Util.toJSONString(headers.acl);
  }
  if (!Util.isUnset(headers.storageClass)) {
    realHeaders['x-oss-storage-class'] = Util.toJSONString(headers.storageClass);
  }
  if (!Util.isUnset(headers.symlinkTargetKey)) {
    realHeaders['x-oss-symlink-target'] = Util.toJSONString(headers.symlinkTargetKey);
  }
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = realHeaders,
  };
  var params = new OpenApi.Params{
    action = 'PutSymlink',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/${key}?symlink`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

model RestoreObjectRequest {
  restoreRequest?: RestoreRequest(name='RestoreRequest'),
  versionId?: string(name='versionId'),
}

model RestoreObjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function restoreObject(bucket: string, key: string, request: RestoreObjectRequest): RestoreObjectResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return restoreObjectWithOptions(bucket, key, request, headers, runtime);
}

async function restoreObjectWithOptions(bucket: string, key: string, request: RestoreObjectRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RestoreObjectResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  key = OpenApiUtil.getEncodeParam(key);
  var query : map[string]any = {};
  if (!Util.isUnset(request.versionId)) {
    query['versionId'] = request.versionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(request.restoreRequest),
  };
  var params = new OpenApi.Params{
    action = 'RestoreObject',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/${key}?restore`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

model SelectObjectRequest {
  selectRequest?: SelectRequest(name='SelectRequest'),
}

model SelectObjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: readable(name='body'),
}

async function selectObject(bucket: string, key: string, request: SelectObjectRequest): SelectObjectResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return selectObjectWithOptions(bucket, key, request, headers, runtime);
}

async function selectObjectWithOptions(bucket: string, key: string, request: SelectObjectRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SelectObjectResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  key = OpenApiUtil.getEncodeParam(key);
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(request.selectRequest),
  };
  var params = new OpenApi.Params{
    action = 'SelectObject',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/${key}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'binary',
  };
  return execute(params, req, runtime);
}

model UploadPartRequest {
  body?: readable(name='body'),
  partNumber?: long(name='partNumber'),
  uploadId?: string(name='uploadId'),
}

model UploadPartResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function uploadPart(bucket: string, key: string, request: UploadPartRequest): UploadPartResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return uploadPartWithOptions(bucket, key, request, headers, runtime);
}

async function uploadPartWithOptions(bucket: string, key: string, request: UploadPartRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UploadPartResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  key = OpenApiUtil.getEncodeParam(key);
  var query : map[string]any = {};
  if (!Util.isUnset(request.partNumber)) {
    query['partNumber'] = request.partNumber;
  }
  if (!Util.isUnset(request.uploadId)) {
    query['uploadId'] = request.uploadId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
    stream = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UploadPart',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/${key}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'binary',
    bodyType = 'xml',
  };
  return execute(params, req, runtime);
}

model UploadPartCopyHeaders {
  commonHeaders?: map[string]string,
  copySource?: string(name='x-oss-copy-source'),
  copySourceIfMatch?: string(name='x-oss-copy-source-if-match'),
  copySourceIfModifiedSince?: string(name='x-oss-copy-source-if-modified-since'),
  copySourceIfNoneMatch?: string(name='x-oss-copy-source-if-none-match'),
  copySourceIfUnmodifiedSince?: string(name='x-oss-copy-source-if-unmodified-since'),
  copySourceRange?: string(name='x-oss-copy-source-range'),
}

model UploadPartCopyRequest {
  partNumber?: long(name='partNumber'),
  uploadId?: string(name='uploadId'),
}

model UploadPartCopyResponseBody = {
  ETag?: string(name='ETag'),
  lastModified?: string(name='LastModified'),
}

model UploadPartCopyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UploadPartCopyResponseBody(name='body'),
}

async function uploadPartCopy(bucket: string, key: string, request: UploadPartCopyRequest): UploadPartCopyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new UploadPartCopyHeaders{};
  return uploadPartCopyWithOptions(bucket, key, request, headers, runtime);
}

async function uploadPartCopyWithOptions(bucket: string, key: string, request: UploadPartCopyRequest, headers: UploadPartCopyHeaders, runtime: Util.RuntimeOptions): UploadPartCopyResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['bucket'] = bucket;
  key = OpenApiUtil.getEncodeParam(key);
  var query : map[string]any = {};
  if (!Util.isUnset(request.partNumber)) {
    query['partNumber'] = request.partNumber;
  }
  if (!Util.isUnset(request.uploadId)) {
    query['uploadId'] = request.uploadId;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.copySource)) {
    realHeaders['x-oss-copy-source'] = Util.toJSONString(headers.copySource);
  }
  if (!Util.isUnset(headers.copySourceIfMatch)) {
    realHeaders['x-oss-copy-source-if-match'] = Util.toJSONString(headers.copySourceIfMatch);
  }
  if (!Util.isUnset(headers.copySourceIfModifiedSince)) {
    realHeaders['x-oss-copy-source-if-modified-since'] = Util.toJSONString(headers.copySourceIfModifiedSince);
  }
  if (!Util.isUnset(headers.copySourceIfNoneMatch)) {
    realHeaders['x-oss-copy-source-if-none-match'] = Util.toJSONString(headers.copySourceIfNoneMatch);
  }
  if (!Util.isUnset(headers.copySourceIfUnmodifiedSince)) {
    realHeaders['x-oss-copy-source-if-unmodified-since'] = Util.toJSONString(headers.copySourceIfUnmodifiedSince);
  }
  if (!Util.isUnset(headers.copySourceRange)) {
    realHeaders['x-oss-copy-source-range'] = Util.toJSONString(headers.copySourceRange);
  }
  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UploadPartCopy',
    version = '2019-05-17',
    protocol = 'HTTPS',
    pathname = `/${key}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'xml',
    bodyType = 'xml',  };
  return execute(params, req, runtime);
}

