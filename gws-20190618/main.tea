/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
@endpointMap = {
    ap-southeast-3 = 'gws.ap-northeast-3.aliyuncs.com',
    cn-hangzhou-finance = 'ecd.cn-hangzhou-finance.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('gws', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model CreateClusterRequest {
  vpcId?: string(name='VpcId'),
  clusterType?: string(name='ClusterType'),
  vSwitchId?: string(name='VSwitchId'),
}

model CreateClusterResponseBody = {
  requestId?: string(name='RequestId'),
  clusterId?: string(name='ClusterId'),
}

model CreateClusterResponse = {
  headers: map[string]string(name='headers'),
  body: CreateClusterResponseBody(name='body'),
}

async function createClusterWithOptions(request: CreateClusterRequest, runtime: Util.RuntimeOptions): CreateClusterResponse {
  Util.validateModel(request);
  var query = {};
  query["VpcId"] = request.vpcId;
  query["ClusterType"] = request.clusterType;
  query["VSwitchId"] = request.vSwitchId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateCluster',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createCluster(request: CreateClusterRequest): CreateClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return createClusterWithOptions(request, runtime);
}

model CreateImageRequest {
  instanceId?: string(name='InstanceId'),
  name?: string(name='Name'),
}

model CreateImageResponseBody = {
  requestId?: string(name='RequestId'),
  imageId?: string(name='ImageId'),
}

model CreateImageResponse = {
  headers: map[string]string(name='headers'),
  body: CreateImageResponseBody(name='body'),
}

async function createImageWithOptions(request: CreateImageRequest, runtime: Util.RuntimeOptions): CreateImageResponse {
  Util.validateModel(request);
  var query = {};
  query["InstanceId"] = request.instanceId;
  query["Name"] = request.name;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateImage',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createImage(request: CreateImageRequest): CreateImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return createImageWithOptions(request, runtime);
}

model CreateInstanceRequest {
  clusterId?: string(name='ClusterId'),
  vSwitchId?: string(name='VSwitchId'),
  name?: string(name='Name'),
  imageId?: string(name='ImageId'),
  systemDiskSize?: int32(name='SystemDiskSize'),
  systemDiskCategory?: string(name='SystemDiskCategory'),
  allocatePublicAddress?: string(name='AllocatePublicAddress'),
  internetChargeType?: string(name='InternetChargeType'),
  internetMaxBandwidthIn?: int32(name='InternetMaxBandwidthIn'),
  internetMaxBandwidthOut?: int32(name='InternetMaxBandwidthOut'),
  instanceType?: string(name='InstanceType'),
  instanceChargeType?: string(name='InstanceChargeType'),
  autoRenew?: string(name='AutoRenew'),
  period?: int32(name='Period'),
  periodUnit?: string(name='PeriodUnit'),
  workMode?: string(name='WorkMode'),
  appList?: [ 
    {
      appName?: string(name='AppName'),
      appPath?: string(name='AppPath'),
      appArgs?: string(name='AppArgs'),
    }
  ](name='AppList'),
}

model CreateInstanceResponseBody = {
  requestId?: string(name='RequestId'),
  instanceId?: string(name='InstanceId'),
}

model CreateInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateInstanceResponseBody(name='body'),
}

async function createInstanceWithOptions(request: CreateInstanceRequest, runtime: Util.RuntimeOptions): CreateInstanceResponse {
  Util.validateModel(request);
  var query = {};
  query["ClusterId"] = request.clusterId;
  query["VSwitchId"] = request.vSwitchId;
  query["Name"] = request.name;
  query["ImageId"] = request.imageId;
  query["SystemDiskSize"] = request.systemDiskSize;
  query["SystemDiskCategory"] = request.systemDiskCategory;
  query["AllocatePublicAddress"] = request.allocatePublicAddress;
  query["InternetChargeType"] = request.internetChargeType;
  query["InternetMaxBandwidthIn"] = request.internetMaxBandwidthIn;
  query["InternetMaxBandwidthOut"] = request.internetMaxBandwidthOut;
  query["InstanceType"] = request.instanceType;
  query["InstanceChargeType"] = request.instanceChargeType;
  query["AutoRenew"] = request.autoRenew;
  query["Period"] = request.period;
  query["PeriodUnit"] = request.periodUnit;
  query["WorkMode"] = request.workMode;
  query["AppList"] = request.appList;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateInstance',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createInstance(request: CreateInstanceRequest): CreateInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createInstanceWithOptions(request, runtime);
}

model CreateServiceLinkedRoleResponseBody = {
  requestId?: string(name='RequestId'),
  alreadyExists?: boolean(name='AlreadyExists'),
}

model CreateServiceLinkedRoleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateServiceLinkedRoleResponseBody(name='body'),
}

async function createServiceLinkedRoleWithOptions(runtime: Util.RuntimeOptions): CreateServiceLinkedRoleResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'CreateServiceLinkedRole',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createServiceLinkedRole(): CreateServiceLinkedRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createServiceLinkedRoleWithOptions(runtime);
}

model DeleteClusterRequest {
  clusterId?: string(name='ClusterId'),
}

model DeleteClusterResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteClusterResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteClusterResponseBody(name='body'),
}

async function deleteClusterWithOptions(request: DeleteClusterRequest, runtime: Util.RuntimeOptions): DeleteClusterResponse {
  Util.validateModel(request);
  var query = {};
  query["ClusterId"] = request.clusterId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCluster',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteCluster(request: DeleteClusterRequest): DeleteClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteClusterWithOptions(request, runtime);
}

model DeleteImageRequest {
  imageId?: string(name='ImageId'),
}

model DeleteImageResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteImageResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteImageResponseBody(name='body'),
}

async function deleteImageWithOptions(request: DeleteImageRequest, runtime: Util.RuntimeOptions): DeleteImageResponse {
  Util.validateModel(request);
  var query = {};
  query["ImageId"] = request.imageId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteImage',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteImage(request: DeleteImageRequest): DeleteImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteImageWithOptions(request, runtime);
}

model DeleteInstanceRequest {
  instanceId?: string(name='InstanceId'),
}

model DeleteInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteInstanceResponseBody(name='body'),
}

async function deleteInstanceWithOptions(request: DeleteInstanceRequest, runtime: Util.RuntimeOptions): DeleteInstanceResponse {
  Util.validateModel(request);
  var query = {};
  query["InstanceId"] = request.instanceId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteInstance',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteInstance(request: DeleteInstanceRequest): DeleteInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteInstanceWithOptions(request, runtime);
}

model DescribeAvailableResourceResponseBody = {
  requestId?: string(name='RequestId'),
  availableResources?: [ 
    {
      clusterType?: string(name='ClusterType'),
      zone?: string(name='Zone'),
    }
  ](name='AvailableResources'),
}

model DescribeAvailableResourceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAvailableResourceResponseBody(name='body'),
}

async function describeAvailableResourceWithOptions(runtime: Util.RuntimeOptions): DescribeAvailableResourceResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeAvailableResource',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAvailableResource(): DescribeAvailableResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAvailableResourceWithOptions(runtime);
}

model DescribeClusterADDomainRequest {
  clusterId?: string(name='ClusterId'),
  taskId?: string(name='TaskId'),
}

model DescribeClusterADDomainResponseBody = {
  taskId?: string(name='TaskId'),
  requestId?: string(name='RequestId'),
  domainName?: string(name='DomainName'),
  taskFinished?: boolean(name='TaskFinished'),
  isSupported?: boolean(name='IsSupported'),
  domainDnsIp?: string(name='DomainDnsIp'),
}

model DescribeClusterADDomainResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeClusterADDomainResponseBody(name='body'),
}

async function describeClusterADDomainWithOptions(request: DescribeClusterADDomainRequest, runtime: Util.RuntimeOptions): DescribeClusterADDomainResponse {
  Util.validateModel(request);
  var query = {};
  query["ClusterId"] = request.clusterId;
  query["TaskId"] = request.taskId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterADDomain',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeClusterADDomain(request: DescribeClusterADDomainRequest): DescribeClusterADDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterADDomainWithOptions(request, runtime);
}

model DescribeClusterConnectionsRequest {
  clusterId?: string(name='ClusterId'),
  startTime?: string(name='StartTime'),
  endTime?: string(name='EndTime'),
  taskId?: string(name='TaskId'),
}

model DescribeClusterConnectionsResponseBody = {
  connections?: [ 
    {
      logoffStatus?: string(name='LogoffStatus'),
      instanceName?: string(name='InstanceName'),
      logonTime?: string(name='LogonTime'),
      hostName?: string(name='HostName'),
      logoffTime?: string(name='LogoffTime'),
      instanceId?: string(name='InstanceId'),
      clientName?: string(name='ClientName'),
    }
  ](name='Connections'),
  totalCount?: long(name='TotalCount'),
  taskId?: string(name='TaskId'),
  requestId?: string(name='RequestId'),
  taskFinished?: boolean(name='TaskFinished'),
}

model DescribeClusterConnectionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeClusterConnectionsResponseBody(name='body'),
}

async function describeClusterConnectionsWithOptions(request: DescribeClusterConnectionsRequest, runtime: Util.RuntimeOptions): DescribeClusterConnectionsResponse {
  Util.validateModel(request);
  var query = {};
  query["ClusterId"] = request.clusterId;
  query["StartTime"] = request.startTime;
  query["EndTime"] = request.endTime;
  query["TaskId"] = request.taskId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterConnections',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeClusterConnections(request: DescribeClusterConnectionsRequest): DescribeClusterConnectionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterConnectionsWithOptions(request, runtime);
}

model DescribeClusterPolicyRequest {
  taskId?: string(name='TaskId'),
  asyncMode?: boolean(name='AsyncMode'),
  clusterId?: string(name='ClusterId'),
}

model DescribeClusterPolicyResponseBody = {
  taskId?: string(name='TaskId'),
  udpPort?: string(name='UdpPort'),
  requestId?: string(name='RequestId'),
  localDrive?: string(name='LocalDrive'),
  usbRedirect?: string(name='UsbRedirect'),
  taskFinished?: boolean(name='TaskFinished'),
  clipboard?: string(name='Clipboard'),
  domainList?: string(name='DomainList'),
  audio?: string(name='Audio'),
  watermark?: string(name='Watermark'),
}

model DescribeClusterPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeClusterPolicyResponseBody(name='body'),
}

async function describeClusterPolicyWithOptions(request: DescribeClusterPolicyRequest, runtime: Util.RuntimeOptions): DescribeClusterPolicyResponse {
  Util.validateModel(request);
  var query = {};
  query["TaskId"] = request.taskId;
  query["AsyncMode"] = request.asyncMode;
  query["ClusterId"] = request.clusterId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterPolicy',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeClusterPolicy(request: DescribeClusterPolicyRequest): DescribeClusterPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterPolicyWithOptions(request, runtime);
}

model DescribeClustersRequest {
  clusterId?: string(name='ClusterId'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
}

model DescribeClustersResponseBody = {
  totalCount?: long(name='TotalCount'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: long(name='PageNumber'),
  clusters?: [ 
    {
      vpcId?: string(name='VpcId'),
      status?: string(name='Status'),
      natId?: string(name='NatId'),
      instanceCount?: long(name='InstanceCount'),
      createTime?: string(name='CreateTime'),
      natEip?: string(name='NatEip'),
      securityGroup?: string(name='SecurityGroup'),
      name?: string(name='Name'),
      domainName?: string(name='DomainName'),
      clusterId?: string(name='ClusterId'),
    }
  ](name='Clusters'),
}

model DescribeClustersResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeClustersResponseBody(name='body'),
}

async function describeClustersWithOptions(request: DescribeClustersRequest, runtime: Util.RuntimeOptions): DescribeClustersResponse {
  Util.validateModel(request);
  var query = {};
  query["ClusterId"] = request.clusterId;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusters',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeClusters(request: DescribeClustersRequest): DescribeClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClustersWithOptions(request, runtime);
}

model DescribeImagesRequest {
  instanceType?: string(name='InstanceType'),
}

model DescribeImagesResponseBody = {
  totalCount?: long(name='TotalCount'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: long(name='PageNumber'),
  images?: [ 
    {
      status?: string(name='Status'),
      imageType?: string(name='ImageType'),
      progress?: string(name='Progress'),
      size?: long(name='Size'),
      createTime?: string(name='CreateTime'),
      name?: string(name='Name'),
      imageId?: string(name='ImageId'),
      productCode?: string(name='ProductCode'),
    }
  ](name='Images'),
}

model DescribeImagesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeImagesResponseBody(name='body'),
}

async function describeImagesWithOptions(request: DescribeImagesRequest, runtime: Util.RuntimeOptions): DescribeImagesResponse {
  Util.validateModel(request);
  var query = {};
  query["InstanceType"] = request.instanceType;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImages',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeImages(request: DescribeImagesRequest): DescribeImagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImagesWithOptions(request, runtime);
}

model DescribeInstancePolicyRequest {
  instanceId?: string(name='InstanceId'),
  taskId?: string(name='TaskId'),
  asyncMode?: boolean(name='AsyncMode'),
}

model DescribeInstancePolicyResponseBody = {
  taskId?: string(name='TaskId'),
  requestId?: string(name='RequestId'),
  taskFinished?: boolean(name='TaskFinished'),
  visualLossless?: string(name='VisualLossless'),
  optimizeFor3d?: string(name='OptimizeFor3d'),
}

model DescribeInstancePolicyResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstancePolicyResponseBody(name='body'),
}

async function describeInstancePolicyWithOptions(request: DescribeInstancePolicyRequest, runtime: Util.RuntimeOptions): DescribeInstancePolicyResponse {
  Util.validateModel(request);
  var query = {};
  query["InstanceId"] = request.instanceId;
  query["TaskId"] = request.taskId;
  query["AsyncMode"] = request.asyncMode;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstancePolicy',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeInstancePolicy(request: DescribeInstancePolicyRequest): DescribeInstancePolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstancePolicyWithOptions(request, runtime);
}

model DescribeInstancesRequest {
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  clusterId?: string(name='ClusterId'),
  instanceId?: string(name='InstanceId'),
  userUid?: long(name='UserUid'),
  userName?: string(name='UserName'),
}

model DescribeInstancesResponseBody = {
  instances?: [ 
    {
      status?: string(name='Status'),
      workMode?: string(name='WorkMode'),
      expireTime?: string(name='ExpireTime'),
      createTime?: string(name='CreateTime'),
      stoppedMode?: string(name='StoppedMode'),
      hostName?: string(name='HostName'),
      userUid?: long(name='UserUid'),
      instanceId?: string(name='InstanceId'),
      instanceType?: string(name='InstanceType'),
      domainName?: string(name='DomainName'),
      instanceChargeType?: string(name='InstanceChargeType'),
      appList?: [ 
        {
          appName?: string(name='AppName'),
          appPath?: string(name='AppPath'),
          appArgs?: string(name='AppArgs'),
        }
      ](name='AppList'),
      maxBandwidthIn?: long(name='MaxBandwidthIn'),
      isBoundUser?: boolean(name='IsBoundUser'),
      maxBandwidthOut?: long(name='MaxBandwidthOut'),
      name?: string(name='Name'),
      userName?: string(name='UserName'),
      imageId?: string(name='ImageId'),
      clusterId?: string(name='ClusterId'),
    }
  ](name='Instances'),
  totalCount?: long(name='TotalCount'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: long(name='PageNumber'),
}

model DescribeInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstancesResponseBody(name='body'),
}

async function describeInstancesWithOptions(request: DescribeInstancesRequest, runtime: Util.RuntimeOptions): DescribeInstancesResponse {
  Util.validateModel(request);
  var query = {};
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  query["ClusterId"] = request.clusterId;
  query["InstanceId"] = request.instanceId;
  query["UserUid"] = request.userUid;
  query["UserName"] = request.userName;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstances',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeInstances(request: DescribeInstancesRequest): DescribeInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstancesWithOptions(request, runtime);
}

model GetConnectTicketRequest {
  instanceId?: string(name='InstanceId'),
  appName?: string(name='AppName'),
  userName?: string(name='UserName'),
  password?: string(name='Password'),
  taskId?: string(name='TaskId'),
  asyncMode?: boolean(name='AsyncMode'),
  usePrivateIp?: boolean(name='UsePrivateIp'),
}

model GetConnectTicketResponseBody = {
  ticket?: string(name='Ticket'),
  taskId?: string(name='TaskId'),
  requestId?: string(name='RequestId'),
  taskFinished?: boolean(name='TaskFinished'),
}

model GetConnectTicketResponse = {
  headers: map[string]string(name='headers'),
  body: GetConnectTicketResponseBody(name='body'),
}

async function getConnectTicketWithOptions(request: GetConnectTicketRequest, runtime: Util.RuntimeOptions): GetConnectTicketResponse {
  Util.validateModel(request);
  var query = {};
  query["InstanceId"] = request.instanceId;
  query["AppName"] = request.appName;
  query["UserName"] = request.userName;
  query["Password"] = request.password;
  query["TaskId"] = request.taskId;
  query["AsyncMode"] = request.asyncMode;
  query["UsePrivateIp"] = request.usePrivateIp;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetConnectTicket',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getConnectTicket(request: GetConnectTicketRequest): GetConnectTicketResponse {
  var runtime = new Util.RuntimeOptions{};
  return getConnectTicketWithOptions(request, runtime);
}

model IsUserAdminResponseBody = {
  isAdmin?: boolean(name='IsAdmin'),
  requestId?: string(name='RequestId'),
  isAllow?: boolean(name='IsAllow'),
}

model IsUserAdminResponse = {
  headers: map[string]string(name='headers'),
  body: IsUserAdminResponseBody(name='body'),
}

async function isUserAdminWithOptions(runtime: Util.RuntimeOptions): IsUserAdminResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'IsUserAdmin',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function isUserAdmin(): IsUserAdminResponse {
  var runtime = new Util.RuntimeOptions{};
  return isUserAdminWithOptions(runtime);
}

model RestartInstanceRequest {
  instanceId?: string(name='InstanceId'),
}

model RestartInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model RestartInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: RestartInstanceResponseBody(name='body'),
}

async function restartInstanceWithOptions(request: RestartInstanceRequest, runtime: Util.RuntimeOptions): RestartInstanceResponse {
  Util.validateModel(request);
  var query = {};
  query["InstanceId"] = request.instanceId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'RestartInstance',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function restartInstance(request: RestartInstanceRequest): RestartInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return restartInstanceWithOptions(request, runtime);
}

model SetClusterADDomainRequest {
  clusterId?: string(name='ClusterId'),
  domainDnsIp?: string(name='DomainDnsIp'),
  domainName?: string(name='DomainName'),
  domainPassword?: string(name='DomainPassword'),
  domainAdmin?: string(name='DomainAdmin'),
  domainDelete?: boolean(name='DomainDelete'),
}

model SetClusterADDomainResponseBody = {
  taskId?: string(name='TaskId'),
  requestId?: string(name='RequestId'),
}

model SetClusterADDomainResponse = {
  headers: map[string]string(name='headers'),
  body: SetClusterADDomainResponseBody(name='body'),
}

async function setClusterADDomainWithOptions(request: SetClusterADDomainRequest, runtime: Util.RuntimeOptions): SetClusterADDomainResponse {
  Util.validateModel(request);
  var query = {};
  query["ClusterId"] = request.clusterId;
  query["DomainDnsIp"] = request.domainDnsIp;
  query["DomainName"] = request.domainName;
  query["DomainPassword"] = request.domainPassword;
  query["DomainAdmin"] = request.domainAdmin;
  query["DomainDelete"] = request.domainDelete;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SetClusterADDomain',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setClusterADDomain(request: SetClusterADDomainRequest): SetClusterADDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return setClusterADDomainWithOptions(request, runtime);
}

model SetClusterDnatRequest {
  clusterId?: string(name='ClusterId'),
  natId?: string(name='NatId'),
  natEip?: string(name='NatEip'),
}

model SetClusterDnatResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetClusterDnatResponse = {
  headers: map[string]string(name='headers'),
  body: SetClusterDnatResponseBody(name='body'),
}

async function setClusterDnatWithOptions(request: SetClusterDnatRequest, runtime: Util.RuntimeOptions): SetClusterDnatResponse {
  Util.validateModel(request);
  var query = {};
  query["ClusterId"] = request.clusterId;
  query["NatId"] = request.natId;
  query["NatEip"] = request.natEip;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SetClusterDnat',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setClusterDnat(request: SetClusterDnatRequest): SetClusterDnatResponse {
  var runtime = new Util.RuntimeOptions{};
  return setClusterDnatWithOptions(request, runtime);
}

model SetClusterNameRequest {
  clusterId?: string(name='ClusterId'),
  name?: string(name='Name'),
}

model SetClusterNameResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetClusterNameResponse = {
  headers: map[string]string(name='headers'),
  body: SetClusterNameResponseBody(name='body'),
}

async function setClusterNameWithOptions(request: SetClusterNameRequest, runtime: Util.RuntimeOptions): SetClusterNameResponse {
  Util.validateModel(request);
  var query = {};
  query["ClusterId"] = request.clusterId;
  query["Name"] = request.name;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SetClusterName',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setClusterName(request: SetClusterNameRequest): SetClusterNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return setClusterNameWithOptions(request, runtime);
}

model SetClusterPolicyRequest {
  clusterId?: string(name='ClusterId'),
  usbRedirect?: string(name='UsbRedirect'),
  watermark?: string(name='Watermark'),
  localDrive?: string(name='LocalDrive'),
  clipboard?: string(name='Clipboard'),
  udpPort?: string(name='UdpPort'),
  audio?: string(name='Audio'),
  domainList?: string(name='DomainList'),
  asyncMode?: boolean(name='AsyncMode'),
}

model SetClusterPolicyResponseBody = {
  taskId?: string(name='TaskId'),
  requestId?: string(name='RequestId'),
}

model SetClusterPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: SetClusterPolicyResponseBody(name='body'),
}

async function setClusterPolicyWithOptions(request: SetClusterPolicyRequest, runtime: Util.RuntimeOptions): SetClusterPolicyResponse {
  Util.validateModel(request);
  var query = {};
  query["ClusterId"] = request.clusterId;
  query["UsbRedirect"] = request.usbRedirect;
  query["Watermark"] = request.watermark;
  query["LocalDrive"] = request.localDrive;
  query["Clipboard"] = request.clipboard;
  query["UdpPort"] = request.udpPort;
  query["Audio"] = request.audio;
  query["DomainList"] = request.domainList;
  query["AsyncMode"] = request.asyncMode;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SetClusterPolicy',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setClusterPolicy(request: SetClusterPolicyRequest): SetClusterPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return setClusterPolicyWithOptions(request, runtime);
}

model SetImageNameRequest {
  imageId?: string(name='ImageId'),
  name?: string(name='Name'),
}

model SetImageNameResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetImageNameResponse = {
  headers: map[string]string(name='headers'),
  body: SetImageNameResponseBody(name='body'),
}

async function setImageNameWithOptions(request: SetImageNameRequest, runtime: Util.RuntimeOptions): SetImageNameResponse {
  Util.validateModel(request);
  var query = {};
  query["ImageId"] = request.imageId;
  query["Name"] = request.name;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SetImageName',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setImageName(request: SetImageNameRequest): SetImageNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return setImageNameWithOptions(request, runtime);
}

model SetInstanceNameRequest {
  instanceId?: string(name='InstanceId'),
  name?: string(name='Name'),
}

model SetInstanceNameResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetInstanceNameResponse = {
  headers: map[string]string(name='headers'),
  body: SetInstanceNameResponseBody(name='body'),
}

async function setInstanceNameWithOptions(request: SetInstanceNameRequest, runtime: Util.RuntimeOptions): SetInstanceNameResponse {
  Util.validateModel(request);
  var query = {};
  query["InstanceId"] = request.instanceId;
  query["Name"] = request.name;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SetInstanceName',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setInstanceName(request: SetInstanceNameRequest): SetInstanceNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return setInstanceNameWithOptions(request, runtime);
}

model SetInstancePolicyRequest {
  instanceId?: string(name='InstanceId'),
  visualLossless?: string(name='VisualLossless'),
  optimizeFor3d?: string(name='OptimizeFor3d'),
  asyncMode?: boolean(name='AsyncMode'),
}

model SetInstancePolicyResponseBody = {
  taskId?: string(name='TaskId'),
  requestId?: string(name='RequestId'),
}

model SetInstancePolicyResponse = {
  headers: map[string]string(name='headers'),
  body: SetInstancePolicyResponseBody(name='body'),
}

async function setInstancePolicyWithOptions(request: SetInstancePolicyRequest, runtime: Util.RuntimeOptions): SetInstancePolicyResponse {
  Util.validateModel(request);
  var query = {};
  query["InstanceId"] = request.instanceId;
  query["VisualLossless"] = request.visualLossless;
  query["OptimizeFor3d"] = request.optimizeFor3d;
  query["AsyncMode"] = request.asyncMode;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SetInstancePolicy',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setInstancePolicy(request: SetInstancePolicyRequest): SetInstancePolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return setInstancePolicyWithOptions(request, runtime);
}

model SetInstanceUserRequest {
  instanceId?: string(name='InstanceId'),
  userUid?: long(name='UserUid'),
  userName?: string(name='UserName'),
}

model SetInstanceUserResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetInstanceUserResponse = {
  headers: map[string]string(name='headers'),
  body: SetInstanceUserResponseBody(name='body'),
}

async function setInstanceUserWithOptions(request: SetInstanceUserRequest, runtime: Util.RuntimeOptions): SetInstanceUserResponse {
  Util.validateModel(request);
  var query = {};
  query["InstanceId"] = request.instanceId;
  query["UserUid"] = request.userUid;
  query["UserName"] = request.userName;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SetInstanceUser',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setInstanceUser(request: SetInstanceUserRequest): SetInstanceUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return setInstanceUserWithOptions(request, runtime);
}

model StartInstanceRequest {
  instanceId?: string(name='InstanceId'),
}

model StartInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model StartInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: StartInstanceResponseBody(name='body'),
}

async function startInstanceWithOptions(request: StartInstanceRequest, runtime: Util.RuntimeOptions): StartInstanceResponse {
  Util.validateModel(request);
  var query = {};
  query["InstanceId"] = request.instanceId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'StartInstance',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startInstance(request: StartInstanceRequest): StartInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return startInstanceWithOptions(request, runtime);
}

model StopInstanceRequest {
  instanceId?: string(name='InstanceId'),
}

model StopInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model StopInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: StopInstanceResponseBody(name='body'),
}

async function stopInstanceWithOptions(request: StopInstanceRequest, runtime: Util.RuntimeOptions): StopInstanceResponse {
  Util.validateModel(request);
  var query = {};
  query["InstanceId"] = request.instanceId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'StopInstance',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopInstance(request: StopInstanceRequest): StopInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopInstanceWithOptions(request, runtime);
}

