/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    ap-southeast-3 = 'gws.ap-northeast-3.aliyuncs.com',
    cn-hangzhou-finance = 'ecd.cn-hangzhou-finance.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('gws', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model CreateClusterRequest {
  clusterType?: string(name='ClusterType'),
  vSwitchId?: string(name='VSwitchId'),
  vpcId?: string(name='VpcId'),
}

model CreateClusterResponseBody = {
  clusterId?: string(name='ClusterId'),
  requestId?: string(name='RequestId'),
}

model CreateClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateClusterResponseBody(name='body'),
}

async function createClusterWithOptions(request: CreateClusterRequest, runtime: Util.RuntimeOptions): CreateClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterType)) {
    query['ClusterType'] = request.clusterType;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateCluster',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createCluster(request: CreateClusterRequest): CreateClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return createClusterWithOptions(request, runtime);
}

model CreateImageRequest {
  instanceId?: string(name='InstanceId'),
  name?: string(name='Name'),
}

model CreateImageResponseBody = {
  imageId?: string(name='ImageId'),
  requestId?: string(name='RequestId'),
}

model CreateImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateImageResponseBody(name='body'),
}

async function createImageWithOptions(request: CreateImageRequest, runtime: Util.RuntimeOptions): CreateImageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateImage',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createImage(request: CreateImageRequest): CreateImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return createImageWithOptions(request, runtime);
}

model CreateInstanceRequest {
  allocatePublicAddress?: string(name='AllocatePublicAddress'),
  appList?: [ 
    {
      appArgs?: string(name='AppArgs'),
      appName?: string(name='AppName'),
      appPath?: string(name='AppPath'),
    }
  ](name='AppList'),
  autoRenew?: string(name='AutoRenew'),
  clusterId?: string(name='ClusterId'),
  imageId?: string(name='ImageId'),
  instanceChargeType?: string(name='InstanceChargeType'),
  instanceType?: string(name='InstanceType'),
  internetChargeType?: string(name='InternetChargeType'),
  internetMaxBandwidthIn?: int32(name='InternetMaxBandwidthIn'),
  internetMaxBandwidthOut?: int32(name='InternetMaxBandwidthOut'),
  name?: string(name='Name'),
  period?: int32(name='Period'),
  periodUnit?: string(name='PeriodUnit'),
  systemDiskCategory?: string(name='SystemDiskCategory'),
  systemDiskSize?: int32(name='SystemDiskSize'),
  vSwitchId?: string(name='VSwitchId'),
  workMode?: string(name='WorkMode'),
}

model CreateInstanceResponseBody = {
  instanceId?: string(name='InstanceId'),
  requestId?: string(name='RequestId'),
}

model CreateInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateInstanceResponseBody(name='body'),
}

async function createInstanceWithOptions(request: CreateInstanceRequest, runtime: Util.RuntimeOptions): CreateInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.allocatePublicAddress)) {
    query['AllocatePublicAddress'] = request.allocatePublicAddress;
  }
  if (!Util.isUnset(request.appList)) {
    query['AppList'] = request.appList;
  }
  if (!Util.isUnset(request.autoRenew)) {
    query['AutoRenew'] = request.autoRenew;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.imageId)) {
    query['ImageId'] = request.imageId;
  }
  if (!Util.isUnset(request.instanceChargeType)) {
    query['InstanceChargeType'] = request.instanceChargeType;
  }
  if (!Util.isUnset(request.instanceType)) {
    query['InstanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.internetChargeType)) {
    query['InternetChargeType'] = request.internetChargeType;
  }
  if (!Util.isUnset(request.internetMaxBandwidthIn)) {
    query['InternetMaxBandwidthIn'] = request.internetMaxBandwidthIn;
  }
  if (!Util.isUnset(request.internetMaxBandwidthOut)) {
    query['InternetMaxBandwidthOut'] = request.internetMaxBandwidthOut;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.periodUnit)) {
    query['PeriodUnit'] = request.periodUnit;
  }
  if (!Util.isUnset(request.systemDiskCategory)) {
    query['SystemDiskCategory'] = request.systemDiskCategory;
  }
  if (!Util.isUnset(request.systemDiskSize)) {
    query['SystemDiskSize'] = request.systemDiskSize;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.workMode)) {
    query['WorkMode'] = request.workMode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateInstance',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createInstance(request: CreateInstanceRequest): CreateInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createInstanceWithOptions(request, runtime);
}

model CreateServiceLinkedRoleResponseBody = {
  alreadyExists?: boolean(name='AlreadyExists'),
  requestId?: string(name='RequestId'),
}

model CreateServiceLinkedRoleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateServiceLinkedRoleResponseBody(name='body'),
}

async function createServiceLinkedRoleWithOptions(runtime: Util.RuntimeOptions): CreateServiceLinkedRoleResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'CreateServiceLinkedRole',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createServiceLinkedRole(): CreateServiceLinkedRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createServiceLinkedRoleWithOptions(runtime);
}

model DeleteClusterRequest {
  clusterId?: string(name='ClusterId'),
}

model DeleteClusterResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteClusterResponseBody(name='body'),
}

async function deleteClusterWithOptions(request: DeleteClusterRequest, runtime: Util.RuntimeOptions): DeleteClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCluster',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteCluster(request: DeleteClusterRequest): DeleteClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteClusterWithOptions(request, runtime);
}

model DeleteImageRequest {
  imageId?: string(name='ImageId'),
}

model DeleteImageResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteImageResponseBody(name='body'),
}

async function deleteImageWithOptions(request: DeleteImageRequest, runtime: Util.RuntimeOptions): DeleteImageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.imageId)) {
    query['ImageId'] = request.imageId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteImage',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteImage(request: DeleteImageRequest): DeleteImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteImageWithOptions(request, runtime);
}

model DeleteInstanceRequest {
  instanceId?: string(name='InstanceId'),
}

model DeleteInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteInstanceResponseBody(name='body'),
}

async function deleteInstanceWithOptions(request: DeleteInstanceRequest, runtime: Util.RuntimeOptions): DeleteInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteInstance',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteInstance(request: DeleteInstanceRequest): DeleteInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteInstanceWithOptions(request, runtime);
}

model DescribeAvailableResourceResponseBody = {
  availableResources?: [ 
    {
      clusterType?: string(name='ClusterType'),
      zone?: string(name='Zone'),
    }
  ](name='AvailableResources'),
  requestId?: string(name='RequestId'),
}

model DescribeAvailableResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAvailableResourceResponseBody(name='body'),
}

async function describeAvailableResourceWithOptions(runtime: Util.RuntimeOptions): DescribeAvailableResourceResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeAvailableResource',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAvailableResource(): DescribeAvailableResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAvailableResourceWithOptions(runtime);
}

model DescribeClusterADDomainRequest {
  clusterId?: string(name='ClusterId'),
  taskId?: string(name='TaskId'),
}

model DescribeClusterADDomainResponseBody = {
  domainDnsIp?: string(name='DomainDnsIp'),
  domainName?: string(name='DomainName'),
  isSupported?: boolean(name='IsSupported'),
  requestId?: string(name='RequestId'),
  taskFinished?: boolean(name='TaskFinished'),
  taskId?: string(name='TaskId'),
}

model DescribeClusterADDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeClusterADDomainResponseBody(name='body'),
}

async function describeClusterADDomainWithOptions(request: DescribeClusterADDomainRequest, runtime: Util.RuntimeOptions): DescribeClusterADDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterADDomain',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeClusterADDomain(request: DescribeClusterADDomainRequest): DescribeClusterADDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterADDomainWithOptions(request, runtime);
}

model DescribeClusterConnectionsRequest {
  clusterId?: string(name='ClusterId'),
  endTime?: string(name='EndTime'),
  startTime?: string(name='StartTime'),
  taskId?: string(name='TaskId'),
}

model DescribeClusterConnectionsResponseBody = {
  connections?: [ 
    {
      clientName?: string(name='ClientName'),
      hostName?: string(name='HostName'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      logoffStatus?: string(name='LogoffStatus'),
      logoffTime?: string(name='LogoffTime'),
      logonTime?: string(name='LogonTime'),
    }
  ](name='Connections'),
  requestId?: string(name='RequestId'),
  taskFinished?: boolean(name='TaskFinished'),
  taskId?: string(name='TaskId'),
  totalCount?: long(name='TotalCount'),
}

model DescribeClusterConnectionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeClusterConnectionsResponseBody(name='body'),
}

async function describeClusterConnectionsWithOptions(request: DescribeClusterConnectionsRequest, runtime: Util.RuntimeOptions): DescribeClusterConnectionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterConnections',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeClusterConnections(request: DescribeClusterConnectionsRequest): DescribeClusterConnectionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterConnectionsWithOptions(request, runtime);
}

model DescribeClusterPolicyRequest {
  asyncMode?: boolean(name='AsyncMode'),
  clusterId?: string(name='ClusterId'),
  taskId?: string(name='TaskId'),
}

model DescribeClusterPolicyResponseBody = {
  audio?: string(name='Audio'),
  clipboard?: string(name='Clipboard'),
  domainList?: string(name='DomainList'),
  localDrive?: string(name='LocalDrive'),
  requestId?: string(name='RequestId'),
  taskFinished?: boolean(name='TaskFinished'),
  taskId?: string(name='TaskId'),
  udpPort?: string(name='UdpPort'),
  usbRedirect?: string(name='UsbRedirect'),
  watermark?: string(name='Watermark'),
}

model DescribeClusterPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeClusterPolicyResponseBody(name='body'),
}

async function describeClusterPolicyWithOptions(request: DescribeClusterPolicyRequest, runtime: Util.RuntimeOptions): DescribeClusterPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.asyncMode)) {
    query['AsyncMode'] = request.asyncMode;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterPolicy',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeClusterPolicy(request: DescribeClusterPolicyRequest): DescribeClusterPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterPolicyWithOptions(request, runtime);
}

model DescribeClustersRequest {
  clusterId?: string(name='ClusterId'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
}

model DescribeClustersResponseBody = {
  clusters?: [ 
    {
      clusterId?: string(name='ClusterId'),
      createTime?: string(name='CreateTime'),
      domainName?: string(name='DomainName'),
      instanceCount?: long(name='InstanceCount'),
      name?: string(name='Name'),
      natEip?: string(name='NatEip'),
      natId?: string(name='NatId'),
      securityGroup?: string(name='SecurityGroup'),
      status?: string(name='Status'),
      vpcId?: string(name='VpcId'),
    }
  ](name='Clusters'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribeClustersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeClustersResponseBody(name='body'),
}

async function describeClustersWithOptions(request: DescribeClustersRequest, runtime: Util.RuntimeOptions): DescribeClustersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusters',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeClusters(request: DescribeClustersRequest): DescribeClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClustersWithOptions(request, runtime);
}

model DescribeImagesRequest {
  instanceType?: string(name='InstanceType'),
}

model DescribeImagesResponseBody = {
  images?: [ 
    {
      createTime?: string(name='CreateTime'),
      imageId?: string(name='ImageId'),
      imageType?: string(name='ImageType'),
      name?: string(name='Name'),
      productCode?: string(name='ProductCode'),
      progress?: string(name='Progress'),
      size?: long(name='Size'),
      status?: string(name='Status'),
    }
  ](name='Images'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribeImagesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeImagesResponseBody(name='body'),
}

async function describeImagesWithOptions(request: DescribeImagesRequest, runtime: Util.RuntimeOptions): DescribeImagesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceType)) {
    query['InstanceType'] = request.instanceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImages',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeImages(request: DescribeImagesRequest): DescribeImagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImagesWithOptions(request, runtime);
}

model DescribeInstancePolicyRequest {
  asyncMode?: boolean(name='AsyncMode'),
  instanceId?: string(name='InstanceId'),
  taskId?: string(name='TaskId'),
}

model DescribeInstancePolicyResponseBody = {
  optimizeFor3d?: string(name='OptimizeFor3d'),
  requestId?: string(name='RequestId'),
  taskFinished?: boolean(name='TaskFinished'),
  taskId?: string(name='TaskId'),
  visualLossless?: string(name='VisualLossless'),
}

model DescribeInstancePolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeInstancePolicyResponseBody(name='body'),
}

async function describeInstancePolicyWithOptions(request: DescribeInstancePolicyRequest, runtime: Util.RuntimeOptions): DescribeInstancePolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.asyncMode)) {
    query['AsyncMode'] = request.asyncMode;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstancePolicy',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeInstancePolicy(request: DescribeInstancePolicyRequest): DescribeInstancePolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstancePolicyWithOptions(request, runtime);
}

model DescribeInstancesRequest {
  clusterId?: string(name='ClusterId'),
  instanceId?: string(name='InstanceId'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  userName?: string(name='UserName'),
  userUid?: long(name='UserUid'),
}

model DescribeInstancesResponseBody = {
  instances?: [ 
    {
      appList?: [ 
        {
          appArgs?: string(name='AppArgs'),
          appName?: string(name='AppName'),
          appPath?: string(name='AppPath'),
        }
      ](name='AppList'),
      clusterId?: string(name='ClusterId'),
      createTime?: string(name='CreateTime'),
      domainName?: string(name='DomainName'),
      expireTime?: string(name='ExpireTime'),
      hostName?: string(name='HostName'),
      imageId?: string(name='ImageId'),
      instanceChargeType?: string(name='InstanceChargeType'),
      instanceId?: string(name='InstanceId'),
      instanceType?: string(name='InstanceType'),
      isBoundUser?: boolean(name='IsBoundUser'),
      maxBandwidthIn?: long(name='MaxBandwidthIn'),
      maxBandwidthOut?: long(name='MaxBandwidthOut'),
      name?: string(name='Name'),
      status?: string(name='Status'),
      stoppedMode?: string(name='StoppedMode'),
      userName?: string(name='UserName'),
      userUid?: long(name='UserUid'),
      workMode?: string(name='WorkMode'),
    }
  ](name='Instances'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribeInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeInstancesResponseBody(name='body'),
}

async function describeInstancesWithOptions(request: DescribeInstancesRequest, runtime: Util.RuntimeOptions): DescribeInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }
  if (!Util.isUnset(request.userUid)) {
    query['UserUid'] = request.userUid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstances',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeInstances(request: DescribeInstancesRequest): DescribeInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstancesWithOptions(request, runtime);
}

model GetConnectTicketRequest {
  appName?: string(name='AppName'),
  asyncMode?: boolean(name='AsyncMode'),
  instanceId?: string(name='InstanceId'),
  password?: string(name='Password'),
  taskId?: string(name='TaskId'),
  usePrivateIp?: boolean(name='UsePrivateIp'),
  userName?: string(name='UserName'),
}

model GetConnectTicketResponseBody = {
  requestId?: string(name='RequestId'),
  taskFinished?: boolean(name='TaskFinished'),
  taskId?: string(name='TaskId'),
  ticket?: string(name='Ticket'),
}

model GetConnectTicketResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetConnectTicketResponseBody(name='body'),
}

async function getConnectTicketWithOptions(request: GetConnectTicketRequest, runtime: Util.RuntimeOptions): GetConnectTicketResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.asyncMode)) {
    query['AsyncMode'] = request.asyncMode;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.usePrivateIp)) {
    query['UsePrivateIp'] = request.usePrivateIp;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetConnectTicket',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getConnectTicket(request: GetConnectTicketRequest): GetConnectTicketResponse {
  var runtime = new Util.RuntimeOptions{};
  return getConnectTicketWithOptions(request, runtime);
}

model IsUserAdminResponseBody = {
  isAdmin?: boolean(name='IsAdmin'),
  isAllow?: boolean(name='IsAllow'),
  requestId?: string(name='RequestId'),
}

model IsUserAdminResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: IsUserAdminResponseBody(name='body'),
}

async function isUserAdminWithOptions(runtime: Util.RuntimeOptions): IsUserAdminResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'IsUserAdmin',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function isUserAdmin(): IsUserAdminResponse {
  var runtime = new Util.RuntimeOptions{};
  return isUserAdminWithOptions(runtime);
}

model RestartInstanceRequest {
  instanceId?: string(name='InstanceId'),
}

model RestartInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model RestartInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RestartInstanceResponseBody(name='body'),
}

async function restartInstanceWithOptions(request: RestartInstanceRequest, runtime: Util.RuntimeOptions): RestartInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RestartInstance',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function restartInstance(request: RestartInstanceRequest): RestartInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return restartInstanceWithOptions(request, runtime);
}

model SetClusterADDomainRequest {
  clusterId?: string(name='ClusterId'),
  domainAdmin?: string(name='DomainAdmin'),
  domainDelete?: boolean(name='DomainDelete'),
  domainDnsIp?: string(name='DomainDnsIp'),
  domainName?: string(name='DomainName'),
  domainPassword?: string(name='DomainPassword'),
}

model SetClusterADDomainResponseBody = {
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model SetClusterADDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetClusterADDomainResponseBody(name='body'),
}

async function setClusterADDomainWithOptions(request: SetClusterADDomainRequest, runtime: Util.RuntimeOptions): SetClusterADDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.domainAdmin)) {
    query['DomainAdmin'] = request.domainAdmin;
  }
  if (!Util.isUnset(request.domainDelete)) {
    query['DomainDelete'] = request.domainDelete;
  }
  if (!Util.isUnset(request.domainDnsIp)) {
    query['DomainDnsIp'] = request.domainDnsIp;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.domainPassword)) {
    query['DomainPassword'] = request.domainPassword;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetClusterADDomain',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setClusterADDomain(request: SetClusterADDomainRequest): SetClusterADDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return setClusterADDomainWithOptions(request, runtime);
}

model SetClusterDnatRequest {
  clusterId?: string(name='ClusterId'),
  natEip?: string(name='NatEip'),
  natId?: string(name='NatId'),
}

model SetClusterDnatResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetClusterDnatResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetClusterDnatResponseBody(name='body'),
}

async function setClusterDnatWithOptions(request: SetClusterDnatRequest, runtime: Util.RuntimeOptions): SetClusterDnatResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.natEip)) {
    query['NatEip'] = request.natEip;
  }
  if (!Util.isUnset(request.natId)) {
    query['NatId'] = request.natId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetClusterDnat',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setClusterDnat(request: SetClusterDnatRequest): SetClusterDnatResponse {
  var runtime = new Util.RuntimeOptions{};
  return setClusterDnatWithOptions(request, runtime);
}

model SetClusterNameRequest {
  clusterId?: string(name='ClusterId'),
  name?: string(name='Name'),
}

model SetClusterNameResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetClusterNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetClusterNameResponseBody(name='body'),
}

async function setClusterNameWithOptions(request: SetClusterNameRequest, runtime: Util.RuntimeOptions): SetClusterNameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetClusterName',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setClusterName(request: SetClusterNameRequest): SetClusterNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return setClusterNameWithOptions(request, runtime);
}

model SetClusterPolicyRequest {
  asyncMode?: boolean(name='AsyncMode'),
  audio?: string(name='Audio'),
  clipboard?: string(name='Clipboard'),
  clusterId?: string(name='ClusterId'),
  domainList?: string(name='DomainList'),
  localDrive?: string(name='LocalDrive'),
  udpPort?: string(name='UdpPort'),
  usbRedirect?: string(name='UsbRedirect'),
  watermark?: string(name='Watermark'),
}

model SetClusterPolicyResponseBody = {
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model SetClusterPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetClusterPolicyResponseBody(name='body'),
}

async function setClusterPolicyWithOptions(request: SetClusterPolicyRequest, runtime: Util.RuntimeOptions): SetClusterPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.asyncMode)) {
    query['AsyncMode'] = request.asyncMode;
  }
  if (!Util.isUnset(request.audio)) {
    query['Audio'] = request.audio;
  }
  if (!Util.isUnset(request.clipboard)) {
    query['Clipboard'] = request.clipboard;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.domainList)) {
    query['DomainList'] = request.domainList;
  }
  if (!Util.isUnset(request.localDrive)) {
    query['LocalDrive'] = request.localDrive;
  }
  if (!Util.isUnset(request.udpPort)) {
    query['UdpPort'] = request.udpPort;
  }
  if (!Util.isUnset(request.usbRedirect)) {
    query['UsbRedirect'] = request.usbRedirect;
  }
  if (!Util.isUnset(request.watermark)) {
    query['Watermark'] = request.watermark;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetClusterPolicy',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setClusterPolicy(request: SetClusterPolicyRequest): SetClusterPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return setClusterPolicyWithOptions(request, runtime);
}

model SetImageNameRequest {
  imageId?: string(name='ImageId'),
  name?: string(name='Name'),
}

model SetImageNameResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetImageNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetImageNameResponseBody(name='body'),
}

async function setImageNameWithOptions(request: SetImageNameRequest, runtime: Util.RuntimeOptions): SetImageNameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.imageId)) {
    query['ImageId'] = request.imageId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetImageName',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setImageName(request: SetImageNameRequest): SetImageNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return setImageNameWithOptions(request, runtime);
}

model SetInstanceNameRequest {
  instanceId?: string(name='InstanceId'),
  name?: string(name='Name'),
}

model SetInstanceNameResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetInstanceNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetInstanceNameResponseBody(name='body'),
}

async function setInstanceNameWithOptions(request: SetInstanceNameRequest, runtime: Util.RuntimeOptions): SetInstanceNameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetInstanceName',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setInstanceName(request: SetInstanceNameRequest): SetInstanceNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return setInstanceNameWithOptions(request, runtime);
}

model SetInstancePolicyRequest {
  asyncMode?: boolean(name='AsyncMode'),
  instanceId?: string(name='InstanceId'),
  optimizeFor3d?: string(name='OptimizeFor3d'),
  visualLossless?: string(name='VisualLossless'),
}

model SetInstancePolicyResponseBody = {
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model SetInstancePolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetInstancePolicyResponseBody(name='body'),
}

async function setInstancePolicyWithOptions(request: SetInstancePolicyRequest, runtime: Util.RuntimeOptions): SetInstancePolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.asyncMode)) {
    query['AsyncMode'] = request.asyncMode;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.optimizeFor3d)) {
    query['OptimizeFor3d'] = request.optimizeFor3d;
  }
  if (!Util.isUnset(request.visualLossless)) {
    query['VisualLossless'] = request.visualLossless;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetInstancePolicy',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setInstancePolicy(request: SetInstancePolicyRequest): SetInstancePolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return setInstancePolicyWithOptions(request, runtime);
}

model SetInstanceUserRequest {
  instanceId?: string(name='InstanceId'),
  userName?: string(name='UserName'),
  userUid?: long(name='UserUid'),
}

model SetInstanceUserResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetInstanceUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetInstanceUserResponseBody(name='body'),
}

async function setInstanceUserWithOptions(request: SetInstanceUserRequest, runtime: Util.RuntimeOptions): SetInstanceUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }
  if (!Util.isUnset(request.userUid)) {
    query['UserUid'] = request.userUid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetInstanceUser',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setInstanceUser(request: SetInstanceUserRequest): SetInstanceUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return setInstanceUserWithOptions(request, runtime);
}

model StartInstanceRequest {
  instanceId?: string(name='InstanceId'),
}

model StartInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model StartInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartInstanceResponseBody(name='body'),
}

async function startInstanceWithOptions(request: StartInstanceRequest, runtime: Util.RuntimeOptions): StartInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartInstance',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startInstance(request: StartInstanceRequest): StartInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return startInstanceWithOptions(request, runtime);
}

model StopInstanceRequest {
  instanceId?: string(name='InstanceId'),
}

model StopInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model StopInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopInstanceResponseBody(name='body'),
}

async function stopInstanceWithOptions(request: StopInstanceRequest, runtime: Util.RuntimeOptions): StopInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopInstance',
    version = '2019-06-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopInstance(request: StopInstanceRequest): StopInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopInstanceWithOptions(request, runtime);
}

