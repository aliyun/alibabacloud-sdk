import Util;

import RPC;
import EndpointUtil;

extends RPC;

init(config: RPC.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    cn-hangzhou = 'mpaas.aliyuncs.com',
    ap-northeast-1 = 'mpaas.aliyuncs.com',
    ap-northeast-2-pop = 'mpaas.aliyuncs.com',
    ap-south-1 = 'mpaas.aliyuncs.com',
    ap-southeast-1 = 'mpaas.aliyuncs.com',
    ap-southeast-2 = 'mpaas.aliyuncs.com',
    ap-southeast-3 = 'mpaas.aliyuncs.com',
    ap-southeast-5 = 'mpaas.aliyuncs.com',
    cn-beijing = 'mpaas.aliyuncs.com',
    cn-beijing-finance-1 = 'mpaas.aliyuncs.com',
    cn-beijing-finance-pop = 'mpaas.aliyuncs.com',
    cn-beijing-gov-1 = 'mpaas.aliyuncs.com',
    cn-beijing-nu16-b01 = 'mpaas.aliyuncs.com',
    cn-chengdu = 'mpaas.aliyuncs.com',
    cn-edge-1 = 'mpaas.aliyuncs.com',
    cn-fujian = 'mpaas.aliyuncs.com',
    cn-haidian-cm12-c01 = 'mpaas.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'mpaas.aliyuncs.com',
    cn-hangzhou-finance = 'mpaas.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'mpaas.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'mpaas.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'mpaas.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'mpaas.aliyuncs.com',
    cn-hangzhou-test-306 = 'mpaas.aliyuncs.com',
    cn-hongkong = 'mpaas.aliyuncs.com',
    cn-hongkong-finance-pop = 'mpaas.aliyuncs.com',
    cn-huhehaote = 'mpaas.aliyuncs.com',
    cn-north-2-gov-1 = 'mpaas.aliyuncs.com',
    cn-qingdao = 'mpaas.aliyuncs.com',
    cn-qingdao-nebula = 'mpaas.aliyuncs.com',
    cn-shanghai = 'mpaas.aliyuncs.com',
    cn-shanghai-et15-b01 = 'mpaas.aliyuncs.com',
    cn-shanghai-et2-b01 = 'mpaas.aliyuncs.com',
    cn-shanghai-finance-1 = 'mpaas.aliyuncs.com',
    cn-shanghai-inner = 'mpaas.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'mpaas.aliyuncs.com',
    cn-shenzhen = 'mpaas.aliyuncs.com',
    cn-shenzhen-finance-1 = 'mpaas.aliyuncs.com',
    cn-shenzhen-inner = 'mpaas.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'mpaas.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'mpaas.aliyuncs.com',
    cn-wuhan = 'mpaas.aliyuncs.com',
    cn-yushanfang = 'mpaas.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'mpaas.aliyuncs.com',
    cn-zhangjiakou = 'mpaas.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'mpaas.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'mpaas.aliyuncs.com',
    eu-central-1 = 'mpaas.aliyuncs.com',
    eu-west-1 = 'mpaas.aliyuncs.com',
    eu-west-1-oxs = 'mpaas.aliyuncs.com',
    me-east-1 = 'mpaas.aliyuncs.com',
    rus-west-1-pop = 'mpaas.aliyuncs.com',
    us-east-1 = 'mpaas.aliyuncs.com',
    us-west-1 = 'mpaas.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('mpaas', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

model UpdateMpaasAppInfoRequest = {
  appId?: string(name='AppId'),
  appName?: string(name='AppName'),
  iconFileUrl?: string(name='IconFileUrl'),
  identifier?: string(name='Identifier'),
  onexFlag?: boolean(name='OnexFlag'),
  systemType?: string(name='SystemType'),
  tenantId?: string(name='TenantId'),
}

model UpdateMpaasAppInfoResponse = {
  requestId: string(name='RequestId'),
  resultCode: string(name='ResultCode'),
  resultMessage: string(name='ResultMessage'),
  resultContent: {
    requestId: string(name='RequestId'),
    data: {
      appId: string(name='AppId'),
      code: string(name='Code'),
      data: string(name='Data'),
      message: string(name='Message'),
      success: boolean(name='Success'),
    }(name='Data'),
  }(name='ResultContent'),
}

async function updateMpaasAppInfoWithOptions(request: UpdateMpaasAppInfoRequest, runtime: Util.RuntimeOptions): UpdateMpaasAppInfoResponse {
  Util.validateModel(request);
  return doRequest('UpdateMpaasAppInfo', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function updateMpaasAppInfo(request: UpdateMpaasAppInfoRequest): UpdateMpaasAppInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMpaasAppInfoWithOptions(request, runtime);
}

model RunMsaDiffRequest = {
  appId: string(name='AppId'),
  mpaasMappcenterMsaDiffRunJsonStr: string(name='MpaasMappcenterMsaDiffRunJsonStr'),
  tenantId: string(name='TenantId'),
  workspaceId: string(name='WorkspaceId'),
}

model RunMsaDiffResponse = {
  requestId: string(name='RequestId'),
  resultCode: string(name='ResultCode'),
  resultMessage: string(name='ResultMessage'),
  resultContent: {
    code: string(name='Code'),
    data: string(name='Data'),
    message: string(name='Message'),
    success: boolean(name='Success'),
  }(name='ResultContent'),
}

async function runMsaDiffWithOptions(request: RunMsaDiffRequest, runtime: Util.RuntimeOptions): RunMsaDiffResponse {
  Util.validateModel(request);
  return doRequest('RunMsaDiff', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function runMsaDiff(request: RunMsaDiffRequest): RunMsaDiffResponse {
  var runtime = new Util.RuntimeOptions{};
  return runMsaDiffWithOptions(request, runtime);
}

model CreateMsaEnhanceRequest = {
  appId: string(name='AppId'),
  mpaasMappcenterMsaEnhanceCreateJsonStr: string(name='MpaasMappcenterMsaEnhanceCreateJsonStr'),
  tenantId: string(name='TenantId'),
  workspaceId: string(name='WorkspaceId'),
}

model CreateMsaEnhanceResponse = {
  requestId: string(name='RequestId'),
  resultCode: string(name='ResultCode'),
  resultMessage: string(name='ResultMessage'),
  resultContent: {
    code: string(name='Code'),
    data: string(name='Data'),
    message: string(name='Message'),
    success: boolean(name='Success'),
  }(name='ResultContent'),
}

async function createMsaEnhanceWithOptions(request: CreateMsaEnhanceRequest, runtime: Util.RuntimeOptions): CreateMsaEnhanceResponse {
  Util.validateModel(request);
  return doRequest('CreateMsaEnhance', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function createMsaEnhance(request: CreateMsaEnhanceRequest): CreateMsaEnhanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMsaEnhanceWithOptions(request, runtime);
}

model QueryMPaaSMasTinyAppDailyDataRequest = {
  appId: string(name='AppId'),
  date: string(name='Date'),
  tenantId: string(name='TenantId'),
  tinyAppId: string(name='TinyAppId'),
  workspaceId: string(name='WorkspaceId'),
}

model QueryMPaaSMasTinyAppDailyDataResponse = {
  requestId: string(name='RequestId'),
  resultCode: string(name='ResultCode'),
  resultMessage: string(name='ResultMessage'),
  resultContent: {
    code: long(name='Code'),
    data: string(name='Data'),
    msg: string(name='Msg'),
  }(name='ResultContent'),
}

async function queryMPaaSMasTinyAppDailyDataWithOptions(request: QueryMPaaSMasTinyAppDailyDataRequest, runtime: Util.RuntimeOptions): QueryMPaaSMasTinyAppDailyDataResponse {
  Util.validateModel(request);
  return doRequest('QueryMPaaSMasTinyAppDailyData', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function queryMPaaSMasTinyAppDailyData(request: QueryMPaaSMasTinyAppDailyDataRequest): QueryMPaaSMasTinyAppDailyDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMPaaSMasTinyAppDailyDataWithOptions(request, runtime);
}

model QueryMPaaSMasTinyAppHistoryDataRequest = {
  appId: string(name='AppId'),
  date: string(name='Date'),
  tenantId: string(name='TenantId'),
  tinyAppId: string(name='TinyAppId'),
  workspaceId: string(name='WorkspaceId'),
}

model QueryMPaaSMasTinyAppHistoryDataResponse = {
  requestId: string(name='RequestId'),
  resultCode: string(name='ResultCode'),
  resultMessage: string(name='ResultMessage'),
  resultContent: {
    code: long(name='Code'),
    data: string(name='Data'),
    msg: string(name='Msg'),
  }(name='ResultContent'),
}

async function queryMPaaSMasTinyAppHistoryDataWithOptions(request: QueryMPaaSMasTinyAppHistoryDataRequest, runtime: Util.RuntimeOptions): QueryMPaaSMasTinyAppHistoryDataResponse {
  Util.validateModel(request);
  return doRequest('QueryMPaaSMasTinyAppHistoryData', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function queryMPaaSMasTinyAppHistoryData(request: QueryMPaaSMasTinyAppHistoryDataRequest): QueryMPaaSMasTinyAppHistoryDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMPaaSMasTinyAppHistoryDataWithOptions(request, runtime);
}

model QueryMPaaSMasTinyAppDailyPageViewRequest = {
  appId: string(name='AppId'),
  date: string(name='Date'),
  keyword?: string(name='Keyword'),
  order: string(name='Order'),
  orderCol: string(name='OrderCol'),
  pageLen: string(name='PageLen'),
  pageNum: string(name='PageNum'),
  tenantId: string(name='TenantId'),
  tinyAppId: string(name='TinyAppId'),
  workspaceId: string(name='WorkspaceId'),
}

model QueryMPaaSMasTinyAppDailyPageViewResponse = {
  requestId: string(name='RequestId'),
  resultCode: string(name='ResultCode'),
  resultMessage: string(name='ResultMessage'),
  resultContent: {
    code: long(name='Code'),
    data: string(name='Data'),
    msg: string(name='Msg'),
  }(name='ResultContent'),
}

async function queryMPaaSMasTinyAppDailyPageViewWithOptions(request: QueryMPaaSMasTinyAppDailyPageViewRequest, runtime: Util.RuntimeOptions): QueryMPaaSMasTinyAppDailyPageViewResponse {
  Util.validateModel(request);
  return doRequest('QueryMPaaSMasTinyAppDailyPageView', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function queryMPaaSMasTinyAppDailyPageView(request: QueryMPaaSMasTinyAppDailyPageViewRequest): QueryMPaaSMasTinyAppDailyPageViewResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMPaaSMasTinyAppDailyPageViewWithOptions(request, runtime);
}

model ListMPaaSMasTinyAppRequest = {
  appId: string(name='AppId'),
  tenantId: string(name='TenantId'),
  workspaceId: string(name='WorkspaceId'),
}

model ListMPaaSMasTinyAppResponse = {
  requestId: string(name='RequestId'),
  resultCode: string(name='ResultCode'),
  resultMessage: string(name='ResultMessage'),
  resultContent: {
    code: long(name='Code'),
    data: string(name='Data'),
    msg: string(name='Msg'),
  }(name='ResultContent'),
}

async function listMPaaSMasTinyAppWithOptions(request: ListMPaaSMasTinyAppRequest, runtime: Util.RuntimeOptions): ListMPaaSMasTinyAppResponse {
  Util.validateModel(request);
  return doRequest('ListMPaaSMasTinyApp', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function listMPaaSMasTinyApp(request: ListMPaaSMasTinyAppRequest): ListMPaaSMasTinyAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMPaaSMasTinyAppWithOptions(request, runtime);
}

model ListMappCenterAppsRequest = {
}

model ListMappCenterAppsResponse = {
  requestId: string(name='RequestId'),
  resultCode: string(name='ResultCode'),
  resultMessage: string(name='ResultMessage'),
  listMappCenterAppResult: {
    resultMsg: string(name='ResultMsg'),
    success: boolean(name='Success'),
    mappCenterAppList: [
      {
        appDesc: string(name='AppDesc'),
        appIcon: string(name='AppIcon'),
        appId: string(name='AppId'),
        appName: string(name='AppName'),
        appSecret: string(name='AppSecret'),
        creator: string(name='Creator'),
        gmtCreate: string(name='GmtCreate'),
        gmtModified: string(name='GmtModified'),
        id: long(name='Id'),
        modifier: string(name='Modifier'),
        monitorJson: string(name='MonitorJson'),
        status: long(name='Status'),
        tenantId: string(name='TenantId'),
        type: long(name='Type'),
        androidConfig: {
          certRSA: string(name='CertRSA'),
          packageName: string(name='PackageName'),
        }(name='AndroidConfig'),
        iosConfig: {
          bundleId: string(name='BundleId'),
        }(name='IosConfig'),
      }
    ](name='MappCenterAppList'),
  }(name='ListMappCenterAppResult'),
}

async function listMappCenterAppsWithOptions(request: ListMappCenterAppsRequest, runtime: Util.RuntimeOptions): ListMappCenterAppsResponse {
  Util.validateModel(request);
  return doRequest('ListMappCenterApps', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function listMappCenterApps(request: ListMappCenterAppsRequest): ListMappCenterAppsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMappCenterAppsWithOptions(request, runtime);
}

model ListMappCenterWorkspacesRequest = {
}

model ListMappCenterWorkspacesResponse = {
  requestId: string(name='RequestId'),
  resultCode: string(name='ResultCode'),
  resultMessage: string(name='ResultMessage'),
  listMappCenterWorkspaceResult: {
    resultMsg: string(name='ResultMsg'),
    success: boolean(name='Success'),
    userId: string(name='UserId'),
    mappCenterWorkspaceList: [
      {
        compatibleId: string(name='CompatibleId'),
        createTime: string(name='CreateTime'),
        displayName: string(name='DisplayName'),
        id: string(name='Id'),
        region: string(name='Region'),
        status: string(name='Status'),
        tenantId: string(name='TenantId'),
        type: string(name='Type'),
        uid: long(name='Uid'),
        updateTime: string(name='UpdateTime'),
        workspaceId: string(name='WorkspaceId'),
        zones: string(name='Zones'),
      }
    ](name='MappCenterWorkspaceList'),
  }(name='ListMappCenterWorkspaceResult'),
}

async function listMappCenterWorkspacesWithOptions(request: ListMappCenterWorkspacesRequest, runtime: Util.RuntimeOptions): ListMappCenterWorkspacesResponse {
  Util.validateModel(request);
  return doRequest('ListMappCenterWorkspaces', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function listMappCenterWorkspaces(request: ListMappCenterWorkspacesRequest): ListMappCenterWorkspacesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMappCenterWorkspacesWithOptions(request, runtime);
}

model QueryMappCenterAppRequest = {
  appId: string(name='AppId'),
  workspaceId: string(name='WorkspaceId'),
}

model QueryMappCenterAppResponse = {
  requestId: string(name='RequestId'),
  resultCode: string(name='ResultCode'),
  resultMessage: string(name='ResultMessage'),
  queryMappCenterAppResult: {
    resultMsg: string(name='ResultMsg'),
    success: boolean(name='Success'),
    mappCenterApp: {
      appDesc: string(name='AppDesc'),
      appIcon: string(name='AppIcon'),
      appId: string(name='AppId'),
      appName: string(name='AppName'),
      appSecret: string(name='AppSecret'),
      creator: string(name='Creator'),
      gmtCreate: string(name='GmtCreate'),
      gmtModified: string(name='GmtModified'),
      id: long(name='Id'),
      modifier: string(name='Modifier'),
      monitorJson: string(name='MonitorJson'),
      status: long(name='Status'),
      tenantId: string(name='TenantId'),
      type: long(name='Type'),
      androidConfig: {
        certRSA: string(name='CertRSA'),
        packageName: string(name='PackageName'),
      }(name='AndroidConfig'),
      iosConfig: {
        bundleId: string(name='BundleId'),
      }(name='IosConfig'),
    }(name='MappCenterApp'),
  }(name='QueryMappCenterAppResult'),
}

async function queryMappCenterAppWithOptions(request: QueryMappCenterAppRequest, runtime: Util.RuntimeOptions): QueryMappCenterAppResponse {
  Util.validateModel(request);
  return doRequest('QueryMappCenterApp', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function queryMappCenterApp(request: QueryMappCenterAppRequest): QueryMappCenterAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMappCenterAppWithOptions(request, runtime);
}

model ExportMappCenterAppConfigRequest = {
  appId?: string(name='AppId'),
  certRsaBase64?: string(name='CertRsaBase64'),
  identifier: string(name='Identifier'),
  onexFlag: boolean(name='OnexFlag'),
  systemType: string(name='SystemType'),
  workspaceId?: string(name='WorkspaceId'),
}

model ExportMappCenterAppConfigResponse = {
  requestId: string(name='RequestId'),
  resultCode: string(name='ResultCode'),
  resultMessage: string(name='ResultMessage'),
  exportMappCenterAppConfigResult: {
    configDownloadUrl: string(name='ConfigDownloadUrl'),
    resultMsg: string(name='ResultMsg'),
    success: boolean(name='Success'),
  }(name='ExportMappCenterAppConfigResult'),
}

async function exportMappCenterAppConfigWithOptions(request: ExportMappCenterAppConfigRequest, runtime: Util.RuntimeOptions): ExportMappCenterAppConfigResponse {
  Util.validateModel(request);
  return doRequest('ExportMappCenterAppConfig', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function exportMappCenterAppConfig(request: ExportMappCenterAppConfigRequest): ExportMappCenterAppConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return exportMappCenterAppConfigWithOptions(request, runtime);
}

model DeleteMpaasMrtcArtvcRecordfileRequest = {
  appId?: string(name='AppId'),
  bizAppCode?: string(name='BizAppCode'),
  bizName?: string(name='BizName'),
  bizRequestId?: string(name='BizRequestId'),
  mediaType?: string(name='MediaType'),
  recordId?: string(name='RecordId'),
  roomId?: string(name='RoomId'),
  s?: string(name='S'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model DeleteMpaasMrtcArtvcRecordfileResponse = {
  requestId: string(name='RequestId'),
  resultCode: string(name='ResultCode'),
  resultMessage: string(name='ResultMessage'),
  mrtcApiRecordFileQueryWrapResp: {
    code: string(name='Code'),
    msg: string(name='Msg'),
    data: {
      bizRequestId: string(name='BizRequestId'),
      filePath: string(name='FilePath'),
      fileType: string(name='FileType'),
      recordStartTime: string(name='RecordStartTime'),
      status: string(name='Status'),
    }(name='Data'),
  }(name='MrtcApiRecordFileQueryWrapResp'),
}

async function deleteMpaasMrtcArtvcRecordfileWithOptions(request: DeleteMpaasMrtcArtvcRecordfileRequest, runtime: Util.RuntimeOptions): DeleteMpaasMrtcArtvcRecordfileResponse {
  Util.validateModel(request);
  return doRequest('DeleteMpaasMrtcArtvcRecordfile', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function deleteMpaasMrtcArtvcRecordfile(request: DeleteMpaasMrtcArtvcRecordfileRequest): DeleteMpaasMrtcArtvcRecordfileResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMpaasMrtcArtvcRecordfileWithOptions(request, runtime);
}

model QueryMpaasMrtcArtvcRecordfileRequest = {
  appId?: string(name='AppId'),
  bizAppCode?: string(name='BizAppCode'),
  bizName?: string(name='BizName'),
  bizRequestId?: string(name='BizRequestId'),
  mediaType?: string(name='MediaType'),
  recordId?: string(name='RecordId'),
  roomId?: string(name='RoomId'),
  s?: string(name='S'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model QueryMpaasMrtcArtvcRecordfileResponse = {
  requestId: string(name='RequestId'),
  resultCode: string(name='ResultCode'),
  resultMessage: string(name='ResultMessage'),
  mrtcApiRecordFileQueryWrapResp: {
    code: string(name='Code'),
    msg: string(name='Msg'),
    data: {
      bizRequestId: string(name='BizRequestId'),
      filePath: string(name='FilePath'),
      fileType: string(name='FileType'),
      recordStartTime: string(name='RecordStartTime'),
      status: string(name='Status'),
    }(name='Data'),
  }(name='MrtcApiRecordFileQueryWrapResp'),
}

async function queryMpaasMrtcArtvcRecordfileWithOptions(request: QueryMpaasMrtcArtvcRecordfileRequest, runtime: Util.RuntimeOptions): QueryMpaasMrtcArtvcRecordfileResponse {
  Util.validateModel(request);
  return doRequest('QueryMpaasMrtcArtvcRecordfile', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function queryMpaasMrtcArtvcRecordfile(request: QueryMpaasMrtcArtvcRecordfileRequest): QueryMpaasMrtcArtvcRecordfileResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMpaasMrtcArtvcRecordfileWithOptions(request, runtime);
}

model ListMcubeMiniTasksRequest = {
  appId: string(name='AppId'),
  id: string(name='Id'),
  tenantId: string(name='TenantId'),
  workspaceId: string(name='WorkspaceId'),
}

model ListMcubeMiniTasksResponse = {
  requestId: string(name='RequestId'),
  resultCode: string(name='ResultCode'),
  resultMessage: string(name='ResultMessage'),
  listMiniTaskResult: {
    resultMsg: string(name='ResultMsg'),
    success: boolean(name='Success'),
    miniTaskList: [
      {
        appCode: string(name='AppCode'),
        gmtCreate: string(name='GmtCreate'),
        gmtModified: string(name='GmtModified'),
        greyConfigInfo: string(name='GreyConfigInfo'),
        greyEndtime: string(name='GreyEndtime'),
        greyEndtimeData: string(name='GreyEndtimeData'),
        greyNum: long(name='GreyNum'),
        id: long(name='Id'),
        memo: string(name='Memo'),
        packageId: long(name='PackageId'),
        platform: string(name='Platform'),
        productVersion: string(name='ProductVersion'),
        publishMode: long(name='PublishMode'),
        publishType: long(name='PublishType'),
        status: string(name='Status'),
        taskStatus: long(name='TaskStatus'),
        whitelistIds: string(name='WhitelistIds'),
      }
    ](name='MiniTaskList'),
  }(name='ListMiniTaskResult'),
}

async function listMcubeMiniTasksWithOptions(request: ListMcubeMiniTasksRequest, runtime: Util.RuntimeOptions): ListMcubeMiniTasksResponse {
  Util.validateModel(request);
  return doRequest('ListMcubeMiniTasks', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function listMcubeMiniTasks(request: ListMcubeMiniTasksRequest): ListMcubeMiniTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMcubeMiniTasksWithOptions(request, runtime);
}

model ListMcubeMiniPackagesRequest = {
  appId: string(name='AppId'),
  h5Id: string(name='H5Id'),
  packageTypes: string(name='PackageTypes'),
  tenantId: string(name='TenantId'),
  workspaceId: string(name='WorkspaceId'),
}

model ListMcubeMiniPackagesResponse = {
  requestId: string(name='RequestId'),
  resultCode: string(name='ResultCode'),
  resultMessage: string(name='ResultMessage'),
  listMiniPackageResult: {
    resultMsg: string(name='ResultMsg'),
    success: boolean(name='Success'),
    miniPackageList: [
      {
        appCode: string(name='AppCode'),
        autoInstall: long(name='AutoInstall'),
        clientVersionMax: string(name='ClientVersionMax'),
        clientVersionMin: string(name='ClientVersionMin'),
        downloadUrl: string(name='DownloadUrl'),
        extendInfo: string(name='ExtendInfo'),
        extraData: string(name='ExtraData'),
        fallbackBaseUrl: string(name='FallbackBaseUrl'),
        gmtCreate: string(name='GmtCreate'),
        gmtModified: string(name='GmtModified'),
        h5Id: string(name='H5Id'),
        h5Name: string(name='H5Name'),
        h5Version: string(name='H5Version'),
        id: long(name='Id'),
        installType: long(name='InstallType'),
        mainUrl: string(name='MainUrl'),
        memo: string(name='Memo'),
        packageType: long(name='PackageType'),
        platform: string(name='Platform'),
        publishPeriod: long(name='PublishPeriod'),
        resourceType: long(name='ResourceType'),
        status: long(name='Status'),
      }
    ](name='MiniPackageList'),
  }(name='ListMiniPackageResult'),
}

async function listMcubeMiniPackagesWithOptions(request: ListMcubeMiniPackagesRequest, runtime: Util.RuntimeOptions): ListMcubeMiniPackagesResponse {
  Util.validateModel(request);
  return doRequest('ListMcubeMiniPackages', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function listMcubeMiniPackages(request: ListMcubeMiniPackagesRequest): ListMcubeMiniPackagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMcubeMiniPackagesWithOptions(request, runtime);
}

model GetMcubeFileTokenRequest = {
  appId: string(name='AppId'),
  onexFlag: boolean(name='OnexFlag'),
  tenantId: string(name='TenantId'),
  workspaceId: string(name='WorkspaceId'),
}

model GetMcubeFileTokenResponse = {
  requestId: string(name='RequestId'),
  resultCode: string(name='ResultCode'),
  resultMessage: string(name='ResultMessage'),
  getFileTokenResult: {
    resultMsg: string(name='ResultMsg'),
    success: boolean(name='Success'),
    fileToken: {
      accessid: string(name='Accessid'),
      dir: string(name='Dir'),
      expire: string(name='Expire'),
      host: string(name='Host'),
      policy: string(name='Policy'),
      signature: string(name='Signature'),
    }(name='FileToken'),
  }(name='GetFileTokenResult'),
}

async function getMcubeFileTokenWithOptions(request: GetMcubeFileTokenRequest, runtime: Util.RuntimeOptions): GetMcubeFileTokenResponse {
  Util.validateModel(request);
  return doRequest('GetMcubeFileToken', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function getMcubeFileToken(request: GetMcubeFileTokenRequest): GetMcubeFileTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMcubeFileTokenWithOptions(request, runtime);
}

model UpdateMcubeWhitelistRequest = {
  appId: string(name='AppId'),
  id: string(name='Id'),
  keyIds?: string(name='KeyIds'),
  onexFlag: boolean(name='OnexFlag'),
  ossUrl?: string(name='OssUrl'),
  tenantId: string(name='TenantId'),
  workspaceId: string(name='WorkspaceId'),
}

model UpdateMcubeWhitelistResponse = {
  requestId: string(name='RequestId'),
  resultCode: string(name='ResultCode'),
  resultMessage: string(name='ResultMessage'),
  addWhitelistResult: {
    resultMsg: string(name='ResultMsg'),
    success: boolean(name='Success'),
    addWhitelistInfo: {
      failNum: long(name='FailNum'),
      failUserIds: string(name='FailUserIds'),
      successNum: long(name='SuccessNum'),
    }(name='AddWhitelistInfo'),
  }(name='AddWhitelistResult'),
}

async function updateMcubeWhitelistWithOptions(request: UpdateMcubeWhitelistRequest, runtime: Util.RuntimeOptions): UpdateMcubeWhitelistResponse {
  Util.validateModel(request);
  return doRequest('UpdateMcubeWhitelist', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function updateMcubeWhitelist(request: UpdateMcubeWhitelistRequest): UpdateMcubeWhitelistResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMcubeWhitelistWithOptions(request, runtime);
}

model DeleteMcubeWhitelistRequest = {
  appId: string(name='AppId'),
  id: long(name='Id'),
  tenantId: string(name='TenantId'),
  workspaceId: string(name='WorkspaceId'),
}

model DeleteMcubeWhitelistResponse = {
  requestId: string(name='RequestId'),
  resultCode: string(name='ResultCode'),
  resultMessage: string(name='ResultMessage'),
  deleteWhitelistResult: {
    data: string(name='Data'),
    resultMsg: string(name='ResultMsg'),
    success: boolean(name='Success'),
  }(name='DeleteWhitelistResult'),
}

async function deleteMcubeWhitelistWithOptions(request: DeleteMcubeWhitelistRequest, runtime: Util.RuntimeOptions): DeleteMcubeWhitelistResponse {
  Util.validateModel(request);
  return doRequest('DeleteMcubeWhitelist', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function deleteMcubeWhitelist(request: DeleteMcubeWhitelistRequest): DeleteMcubeWhitelistResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMcubeWhitelistWithOptions(request, runtime);
}

model CreateMcubeMiniTaskRequest = {
  appId: string(name='AppId'),
  greyConfigInfo?: string(name='GreyConfigInfo'),
  greyEndtimeData?: string(name='GreyEndtimeData'),
  greyNum?: long(name='GreyNum'),
  memo: string(name='Memo'),
  packageId: long(name='PackageId'),
  publishMode: long(name='PublishMode'),
  publishType: long(name='PublishType'),
  tenantId: string(name='TenantId'),
  whitelistIds?: string(name='WhitelistIds'),
  workspaceId: string(name='WorkspaceId'),
}

model CreateMcubeMiniTaskResponse = {
  requestId: string(name='RequestId'),
  resultCode: string(name='ResultCode'),
  resultMessage: string(name='ResultMessage'),
  createMiniTaskResult: {
    miniTaskId: string(name='MiniTaskId'),
    resultMsg: string(name='ResultMsg'),
    success: boolean(name='Success'),
  }(name='CreateMiniTaskResult'),
}

async function createMcubeMiniTaskWithOptions(request: CreateMcubeMiniTaskRequest, runtime: Util.RuntimeOptions): CreateMcubeMiniTaskResponse {
  Util.validateModel(request);
  return doRequest('CreateMcubeMiniTask', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function createMcubeMiniTask(request: CreateMcubeMiniTaskRequest): CreateMcubeMiniTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMcubeMiniTaskWithOptions(request, runtime);
}

model ExistMcubeRsaKeyRequest = {
  appId: string(name='AppId'),
  tenantId: string(name='TenantId'),
  workspaceId: string(name='WorkspaceId'),
}

model ExistMcubeRsaKeyResponse = {
  requestId: string(name='RequestId'),
  resultCode: string(name='ResultCode'),
  resultMessage: string(name='ResultMessage'),
  checkRsaKeyResult: {
    data: string(name='Data'),
    resultMsg: string(name='ResultMsg'),
    success: boolean(name='Success'),
  }(name='CheckRsaKeyResult'),
}

async function existMcubeRsaKeyWithOptions(request: ExistMcubeRsaKeyRequest, runtime: Util.RuntimeOptions): ExistMcubeRsaKeyResponse {
  Util.validateModel(request);
  return doRequest('ExistMcubeRsaKey', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function existMcubeRsaKey(request: ExistMcubeRsaKeyRequest): ExistMcubeRsaKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return existMcubeRsaKeyWithOptions(request, runtime);
}

model UploadMcubeMiniPackageRequest = {
  appId: string(name='AppId'),
  autoInstall: long(name='AutoInstall'),
  clientVersionMax?: string(name='ClientVersionMax'),
  clientVersionMin: string(name='ClientVersionMin'),
  enableKeepAlive: string(name='EnableKeepAlive'),
  enableOptionMenu: string(name='EnableOptionMenu'),
  enableTabBar: long(name='EnableTabBar'),
  extendInfo?: string(name='ExtendInfo'),
  h5Id: string(name='H5Id'),
  h5Name: string(name='H5Name'),
  h5Version: string(name='H5Version'),
  iconFileUrl: string(name='IconFileUrl'),
  installType: long(name='InstallType'),
  mainUrl: string(name='MainUrl'),
  onexFlag: boolean(name='OnexFlag'),
  packageType: long(name='PackageType'),
  platform: string(name='Platform'),
  resourceFileUrl: string(name='ResourceFileUrl'),
  resourceType: long(name='ResourceType'),
  tenantId: string(name='TenantId'),
  userId: string(name='UserId'),
  uuid?: string(name='Uuid'),
  vhost: string(name='Vhost'),
  workspaceId: string(name='WorkspaceId'),
}

model UploadMcubeMiniPackageResponse = {
  requestId: string(name='RequestId'),
  resultCode: string(name='ResultCode'),
  resultMessage: string(name='ResultMessage'),
  uploadMiniPackageResult: {
    resultMsg: string(name='ResultMsg'),
    success: boolean(name='Success'),
    returnPackageResult: {
      debugUrl: string(name='DebugUrl'),
      packageId: string(name='PackageId'),
      userId: string(name='UserId'),
    }(name='ReturnPackageResult'),
  }(name='UploadMiniPackageResult'),
}

async function uploadMcubeMiniPackageWithOptions(request: UploadMcubeMiniPackageRequest, runtime: Util.RuntimeOptions): UploadMcubeMiniPackageResponse {
  Util.validateModel(request);
  return doRequest('UploadMcubeMiniPackage', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function uploadMcubeMiniPackage(request: UploadMcubeMiniPackageRequest): UploadMcubeMiniPackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return uploadMcubeMiniPackageWithOptions(request, runtime);
}

model QueryMcubeMiniTaskRequest = {
  appId: string(name='AppId'),
  taskId: long(name='TaskId'),
  tenantId: string(name='TenantId'),
  workspaceId: string(name='WorkspaceId'),
}

model QueryMcubeMiniTaskResponse = {
  requestId: string(name='RequestId'),
  resultCode: string(name='ResultCode'),
  resultMessage: string(name='ResultMessage'),
  queryMiniTaskResult: {
    resultMsg: string(name='ResultMsg'),
    success: boolean(name='Success'),
    miniTaskInfo: {
      appCode: string(name='AppCode'),
      gmtCreate: string(name='GmtCreate'),
      gmtModified: string(name='GmtModified'),
      greyConfigInfo: string(name='GreyConfigInfo'),
      greyEndtime: string(name='GreyEndtime'),
      greyEndtimeData: string(name='GreyEndtimeData'),
      greyNum: long(name='GreyNum'),
      id: long(name='Id'),
      memo: string(name='Memo'),
      packageId: long(name='PackageId'),
      platform: string(name='Platform'),
      productVersion: string(name='ProductVersion'),
      publishMode: long(name='PublishMode'),
      publishType: long(name='PublishType'),
      status: string(name='Status'),
      taskStatus: long(name='TaskStatus'),
      whitelistIds: string(name='WhitelistIds'),
    }(name='MiniTaskInfo'),
  }(name='QueryMiniTaskResult'),
}

async function queryMcubeMiniTaskWithOptions(request: QueryMcubeMiniTaskRequest, runtime: Util.RuntimeOptions): QueryMcubeMiniTaskResponse {
  Util.validateModel(request);
  return doRequest('QueryMcubeMiniTask', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function queryMcubeMiniTask(request: QueryMcubeMiniTaskRequest): QueryMcubeMiniTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMcubeMiniTaskWithOptions(request, runtime);
}

model QueryMcubeMiniPackageRequest = {
  appId: string(name='AppId'),
  h5Id: string(name='H5Id'),
  id: string(name='Id'),
  tenantId: string(name='TenantId'),
  workspaceId: string(name='WorkspaceId'),
}

model QueryMcubeMiniPackageResponse = {
  requestId: string(name='RequestId'),
  resultCode: string(name='ResultCode'),
  resultMessage: string(name='ResultMessage'),
  queryMiniPackageResult: {
    resultMsg: string(name='ResultMsg'),
    success: boolean(name='Success'),
    miniPackageInfo: {
      appCode: string(name='AppCode'),
      autoInstall: long(name='AutoInstall'),
      clientVersionMax: string(name='ClientVersionMax'),
      clientVersionMin: string(name='ClientVersionMin'),
      downloadUrl: string(name='DownloadUrl'),
      extendInfo: string(name='ExtendInfo'),
      extraData: string(name='ExtraData'),
      fallbackBaseUrl: string(name='FallbackBaseUrl'),
      gmtCreate: string(name='GmtCreate'),
      gmtModified: string(name='GmtModified'),
      h5Id: string(name='H5Id'),
      h5Name: string(name='H5Name'),
      h5Version: string(name='H5Version'),
      id: long(name='Id'),
      installType: long(name='InstallType'),
      mainUrl: string(name='MainUrl'),
      memo: string(name='Memo'),
      packageType: long(name='PackageType'),
      platform: string(name='Platform'),
      publishPeriod: long(name='PublishPeriod'),
      resourceType: long(name='ResourceType'),
      status: long(name='Status'),
    }(name='MiniPackageInfo'),
  }(name='QueryMiniPackageResult'),
}

async function queryMcubeMiniPackageWithOptions(request: QueryMcubeMiniPackageRequest, runtime: Util.RuntimeOptions): QueryMcubeMiniPackageResponse {
  Util.validateModel(request);
  return doRequest('QueryMcubeMiniPackage', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function queryMcubeMiniPackage(request: QueryMcubeMiniPackageRequest): QueryMcubeMiniPackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMcubeMiniPackageWithOptions(request, runtime);
}

model UploadMcubeRsaKeyRequest = {
  appId: string(name='AppId'),
  fileUrl: string(name='FileUrl'),
  onexFlag: boolean(name='OnexFlag'),
  tenantId: string(name='TenantId'),
  workspaceId: string(name='WorkspaceId'),
}

model UploadMcubeRsaKeyResponse = {
  requestId: string(name='RequestId'),
  resultCode: string(name='ResultCode'),
  resultMessage: string(name='ResultMessage'),
  uploadRsaResult: {
    data: string(name='Data'),
    resultMsg: string(name='ResultMsg'),
    success: boolean(name='Success'),
  }(name='UploadRsaResult'),
}

async function uploadMcubeRsaKeyWithOptions(request: UploadMcubeRsaKeyRequest, runtime: Util.RuntimeOptions): UploadMcubeRsaKeyResponse {
  Util.validateModel(request);
  return doRequest('UploadMcubeRsaKey', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function uploadMcubeRsaKey(request: UploadMcubeRsaKeyRequest): UploadMcubeRsaKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return uploadMcubeRsaKeyWithOptions(request, runtime);
}

model DeleteMcubeMiniAppRequest = {
  appId: string(name='AppId'),
  h5Id: string(name='H5Id'),
  tenantId: string(name='TenantId'),
  workspaceId: string(name='WorkspaceId'),
}

model DeleteMcubeMiniAppResponse = {
  requestId: string(name='RequestId'),
  resultCode: string(name='ResultCode'),
  resultMessage: string(name='ResultMessage'),
  deleteMiniResult: {
    data: string(name='Data'),
    resultMsg: string(name='ResultMsg'),
    success: boolean(name='Success'),
  }(name='DeleteMiniResult'),
}

async function deleteMcubeMiniAppWithOptions(request: DeleteMcubeMiniAppRequest, runtime: Util.RuntimeOptions): DeleteMcubeMiniAppResponse {
  Util.validateModel(request);
  return doRequest('DeleteMcubeMiniApp', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function deleteMcubeMiniApp(request: DeleteMcubeMiniAppRequest): DeleteMcubeMiniAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMcubeMiniAppWithOptions(request, runtime);
}

model CreateMcubeWhitelistRequest = {
  appId: string(name='AppId'),
  tenantId: string(name='TenantId'),
  whitelistType: string(name='WhitelistType'),
  whiteListName: string(name='WhiteListName'),
  workspaceId: string(name='WorkspaceId'),
}

model CreateMcubeWhitelistResponse = {
  requestId: string(name='RequestId'),
  resultCode: string(name='ResultCode'),
  resultMessage: string(name='ResultMessage'),
  createWhitelistResult: {
    resultMsg: string(name='ResultMsg'),
    success: boolean(name='Success'),
    whitelistId: string(name='WhitelistId'),
  }(name='CreateWhitelistResult'),
}

async function createMcubeWhitelistWithOptions(request: CreateMcubeWhitelistRequest, runtime: Util.RuntimeOptions): CreateMcubeWhitelistResponse {
  Util.validateModel(request);
  return doRequest('CreateMcubeWhitelist', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function createMcubeWhitelist(request: CreateMcubeWhitelistRequest): CreateMcubeWhitelistResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMcubeWhitelistWithOptions(request, runtime);
}

model CreateMcubeWhitelistForIdeRequest = {
  appId: string(name='AppId'),
  tenantId: string(name='TenantId'),
  userId: string(name='UserId'),
  whitelistValue: string(name='WhitelistValue'),
  workspaceId: string(name='WorkspaceId'),
}

model CreateMcubeWhitelistForIdeResponse = {
  requestId: string(name='RequestId'),
  resultCode: string(name='ResultCode'),
  resultMessage: string(name='ResultMessage'),
  createWhitelistForIdeResult: {
    resultMsg: string(name='ResultMsg'),
    success: boolean(name='Success'),
    whitelistId: string(name='WhitelistId'),
  }(name='CreateWhitelistForIdeResult'),
}

async function createMcubeWhitelistForIdeWithOptions(request: CreateMcubeWhitelistForIdeRequest, runtime: Util.RuntimeOptions): CreateMcubeWhitelistForIdeResponse {
  Util.validateModel(request);
  return doRequest('CreateMcubeWhitelistForIde', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function createMcubeWhitelistForIde(request: CreateMcubeWhitelistForIdeRequest): CreateMcubeWhitelistForIdeResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMcubeWhitelistForIdeWithOptions(request, runtime);
}

model ChangeMcubeMiniTaskStatusRequest = {
  appId: string(name='AppId'),
  bizType: string(name='BizType'),
  packageId: long(name='PackageId'),
  taskId: long(name='TaskId'),
  taskStatus: long(name='TaskStatus'),
  tenantId: string(name='TenantId'),
  workspaceId: string(name='WorkspaceId'),
}

model ChangeMcubeMiniTaskStatusResponse = {
  requestId: string(name='RequestId'),
  resultCode: string(name='ResultCode'),
  resultMessage: string(name='ResultMessage'),
  changeMiniTaskStatusResult: {
    data: string(name='Data'),
    resultMsg: string(name='ResultMsg'),
    success: boolean(name='Success'),
  }(name='ChangeMiniTaskStatusResult'),
}

async function changeMcubeMiniTaskStatusWithOptions(request: ChangeMcubeMiniTaskStatusRequest, runtime: Util.RuntimeOptions): ChangeMcubeMiniTaskStatusResponse {
  Util.validateModel(request);
  return doRequest('ChangeMcubeMiniTaskStatus', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function changeMcubeMiniTaskStatus(request: ChangeMcubeMiniTaskStatusRequest): ChangeMcubeMiniTaskStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return changeMcubeMiniTaskStatusWithOptions(request, runtime);
}

model CreateMcubeVhostRequest = {
  appId: string(name='AppId'),
  tenantId: string(name='TenantId'),
  vhost: string(name='Vhost'),
  workspaceId: string(name='WorkspaceId'),
}

model CreateMcubeVhostResponse = {
  requestId: string(name='RequestId'),
  resultCode: string(name='ResultCode'),
  resultMessage: string(name='ResultMessage'),
  createVhostResult: {
    data: string(name='Data'),
    resultMsg: string(name='ResultMsg'),
    success: boolean(name='Success'),
  }(name='CreateVhostResult'),
}

async function createMcubeVhostWithOptions(request: CreateMcubeVhostRequest, runtime: Util.RuntimeOptions): CreateMcubeVhostResponse {
  Util.validateModel(request);
  return doRequest('CreateMcubeVhost', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function createMcubeVhost(request: CreateMcubeVhostRequest): CreateMcubeVhostResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMcubeVhostWithOptions(request, runtime);
}

model CreateMcubeMiniAppRequest = {
  appId: string(name='AppId'),
  h5Id: string(name='H5Id'),
  h5Name: string(name='H5Name'),
  tenantId: string(name='TenantId'),
  workspaceId: string(name='WorkspaceId'),
}

model CreateMcubeMiniAppResponse = {
  requestId: string(name='RequestId'),
  resultCode: string(name='ResultCode'),
  resultMessage: string(name='ResultMessage'),
  createMiniResult: {
    data: string(name='Data'),
    resultMsg: string(name='ResultMsg'),
    success: boolean(name='Success'),
  }(name='CreateMiniResult'),
}

async function createMcubeMiniAppWithOptions(request: CreateMcubeMiniAppRequest, runtime: Util.RuntimeOptions): CreateMcubeMiniAppResponse {
  Util.validateModel(request);
  return doRequest('CreateMcubeMiniApp', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function createMcubeMiniApp(request: CreateMcubeMiniAppRequest): CreateMcubeMiniAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMcubeMiniAppWithOptions(request, runtime);
}

model QueryMcubeVhostRequest = {
  appId: string(name='AppId'),
  tenantId: string(name='TenantId'),
  workspaceId: string(name='WorkspaceId'),
}

model QueryMcubeVhostResponse = {
  requestId: string(name='RequestId'),
  resultCode: string(name='ResultCode'),
  resultMessage: string(name='ResultMessage'),
  queryVhostResult: {
    data: string(name='Data'),
    resultMsg: string(name='ResultMsg'),
    success: boolean(name='Success'),
  }(name='QueryVhostResult'),
}

async function queryMcubeVhostWithOptions(request: QueryMcubeVhostRequest, runtime: Util.RuntimeOptions): QueryMcubeVhostResponse {
  Util.validateModel(request);
  return doRequest('QueryMcubeVhost', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function queryMcubeVhost(request: QueryMcubeVhostRequest): QueryMcubeVhostResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMcubeVhostWithOptions(request, runtime);
}

model ListMcubeMiniAppsRequest = {
  appId: string(name='AppId'),
  tenantId: string(name='TenantId'),
  workspaceId: string(name='WorkspaceId'),
}

model ListMcubeMiniAppsResponse = {
  requestId: string(name='RequestId'),
  resultCode: string(name='ResultCode'),
  resultMessage: string(name='ResultMessage'),
  listMiniResult: {
    resultMsg: string(name='ResultMsg'),
    success: boolean(name='Success'),
    miniProgramList: [
      {
        appCode: string(name='AppCode'),
        gmtCreate: string(name='GmtCreate'),
        gmtModified: string(name='GmtModified'),
        h5Id: string(name='H5Id'),
        h5Name: string(name='H5Name'),
      }
    ](name='MiniProgramList'),
  }(name='ListMiniResult'),
}

async function listMcubeMiniAppsWithOptions(request: ListMcubeMiniAppsRequest, runtime: Util.RuntimeOptions): ListMcubeMiniAppsResponse {
  Util.validateModel(request);
  return doRequest('ListMcubeMiniApps', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function listMcubeMiniApps(request: ListMcubeMiniAppsRequest): ListMcubeMiniAppsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMcubeMiniAppsWithOptions(request, runtime);
}

model ListMcubeWhitelistsRequest = {
  appId: string(name='AppId'),
  tenantId: string(name='TenantId'),
  workspaceId: string(name='WorkspaceId'),
}

model ListMcubeWhitelistsResponse = {
  requestId: string(name='RequestId'),
  resultCode: string(name='ResultCode'),
  resultMessage: string(name='ResultMessage'),
  listWhitelistResult: {
    resultMsg: string(name='ResultMsg'),
    success: boolean(name='Success'),
    whitelists: [
      {
        appCode: string(name='AppCode'),
        gmtCreate: string(name='GmtCreate'),
        gmtModified: string(name='GmtModified'),
        id: long(name='Id'),
        whitelistType: string(name='WhitelistType'),
        whiteListCount: long(name='WhiteListCount'),
        whiteListName: string(name='WhiteListName'),
      }
    ](name='Whitelists'),
  }(name='ListWhitelistResult'),
}

async function listMcubeWhitelistsWithOptions(request: ListMcubeWhitelistsRequest, runtime: Util.RuntimeOptions): ListMcubeWhitelistsResponse {
  Util.validateModel(request);
  return doRequest('ListMcubeWhitelists', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function listMcubeWhitelists(request: ListMcubeWhitelistsRequest): ListMcubeWhitelistsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMcubeWhitelistsWithOptions(request, runtime);
}

model CreateOpenSingleDataRequest = {
  appId: string(name='AppId'),
  appMaxVersion?: string(name='AppMaxVersion'),
  appMinVersion?: string(name='AppMinVersion'),
  bizType: string(name='BizType'),
  checkOnline?: boolean(name='CheckOnline'),
  extAttrStr?: string(name='ExtAttrStr'),
  linkToken: string(name='LinkToken'),
  osType?: string(name='OsType'),
  payload: string(name='Payload'),
  thirdMsgId: string(name='ThirdMsgId'),
  validTimeEnd?: long(name='ValidTimeEnd'),
  validTimeStart?: long(name='ValidTimeStart'),
  workspaceId: string(name='WorkspaceId'),
}

model CreateOpenSingleDataResponse = {
  requestId: string(name='RequestId'),
  resultCode: string(name='ResultCode'),
  resultMessage: string(name='ResultMessage'),
}

async function createOpenSingleDataWithOptions(request: CreateOpenSingleDataRequest, runtime: Util.RuntimeOptions): CreateOpenSingleDataResponse {
  Util.validateModel(request);
  return doRequest('CreateOpenSingleData', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function createOpenSingleData(request: CreateOpenSingleDataRequest): CreateOpenSingleDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOpenSingleDataWithOptions(request, runtime);
}

model CreateOpenGlobalDataRequest = {
  appId: string(name='AppId'),
  appMaxVersion?: string(name='AppMaxVersion'),
  appMinVersion?: string(name='AppMinVersion'),
  bizType: string(name='BizType'),
  extAttrStr?: string(name='ExtAttrStr'),
  maxUid?: long(name='MaxUid'),
  minUid?: long(name='MinUid'),
  osType?: string(name='OsType'),
  payload: string(name='Payload'),
  thirdMsgId: string(name='ThirdMsgId'),
  uids?: string(name='Uids'),
  validTimeEnd?: long(name='ValidTimeEnd'),
  validTimeStart?: long(name='ValidTimeStart'),
  workspaceId: string(name='WorkspaceId'),
}

model CreateOpenGlobalDataResponse = {
  requestId: string(name='RequestId'),
  resultCode: string(name='ResultCode'),
  resultMessage: string(name='ResultMessage'),
}

async function createOpenGlobalDataWithOptions(request: CreateOpenGlobalDataRequest, runtime: Util.RuntimeOptions): CreateOpenGlobalDataResponse {
  Util.validateModel(request);
  return doRequest('CreateOpenGlobalData', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function createOpenGlobalData(request: CreateOpenGlobalDataRequest): CreateOpenGlobalDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOpenGlobalDataWithOptions(request, runtime);
}

model PushSimpleRequest = {
  appId: string(name='AppId'),
  content: string(name='Content'),
  deliveryType: long(name='DeliveryType'),
  expiredSeconds: long(name='ExpiredSeconds'),
  extendedParams?: string(name='ExtendedParams'),
  notifyType?: string(name='NotifyType'),
  pushAction?: long(name='PushAction'),
  silent?: long(name='Silent'),
  targetMsgkey: string(name='TargetMsgkey'),
  taskName?: string(name='TaskName'),
  title: string(name='Title'),
  uri?: string(name='Uri'),
  workspaceId: string(name='WorkspaceId'),
}

model PushSimpleResponse = {
  requestId: string(name='RequestId'),
  resultCode: string(name='ResultCode'),
  resultMessage: string(name='ResultMessage'),
}

async function pushSimpleWithOptions(request: PushSimpleRequest, runtime: Util.RuntimeOptions): PushSimpleResponse {
  Util.validateModel(request);
  return doRequest('PushSimple', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function pushSimple(request: PushSimpleRequest): PushSimpleResponse {
  var runtime = new Util.RuntimeOptions{};
  return pushSimpleWithOptions(request, runtime);
}

model PushBroadcastRequest = {
  appId: string(name='AppId'),
  deliveryType: long(name='DeliveryType'),
  expiredSeconds: long(name='ExpiredSeconds'),
  extendedParams?: string(name='ExtendedParams'),
  msgkey: string(name='Msgkey'),
  notifyType?: string(name='NotifyType'),
  pushAction?: long(name='PushAction'),
  pushStatus?: long(name='PushStatus'),
  silent?: long(name='Silent'),
  taskName?: string(name='TaskName'),
  templateKeyValue?: string(name='TemplateKeyValue'),
  templateName: string(name='TemplateName'),
  unBindPeriod?: long(name='UnBindPeriod'),
  workspaceId: string(name='WorkspaceId'),
}

model PushBroadcastResponse = {
  requestId: string(name='RequestId'),
  resultCode: string(name='ResultCode'),
  resultMessage: string(name='ResultMessage'),
}

async function pushBroadcastWithOptions(request: PushBroadcastRequest, runtime: Util.RuntimeOptions): PushBroadcastResponse {
  Util.validateModel(request);
  return doRequest('PushBroadcast', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function pushBroadcast(request: PushBroadcastRequest): PushBroadcastResponse {
  var runtime = new Util.RuntimeOptions{};
  return pushBroadcastWithOptions(request, runtime);
}

model PushTemplateRequest = {
  appId: string(name='AppId'),
  deliveryType: long(name='DeliveryType'),
  expiredSeconds: long(name='ExpiredSeconds'),
  extendedParams?: string(name='ExtendedParams'),
  notifyType?: string(name='NotifyType'),
  pushAction?: long(name='PushAction'),
  silent?: long(name='Silent'),
  targetMsgkey: string(name='TargetMsgkey'),
  taskName?: string(name='TaskName'),
  templateKeyValue?: string(name='TemplateKeyValue'),
  templateName: string(name='TemplateName'),
  workspaceId: string(name='WorkspaceId'),
}

model PushTemplateResponse = {
  requestId: string(name='RequestId'),
  resultCode: string(name='ResultCode'),
  resultMessage: string(name='ResultMessage'),
}

async function pushTemplateWithOptions(request: PushTemplateRequest, runtime: Util.RuntimeOptions): PushTemplateResponse {
  Util.validateModel(request);
  return doRequest('PushTemplate', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function pushTemplate(request: PushTemplateRequest): PushTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return pushTemplateWithOptions(request, runtime);
}

model PushMultipleRequest = {
  appId: string(name='AppId'),
  deliveryType: long(name='DeliveryType'),
  expiredSeconds: long(name='ExpiredSeconds'),
  extendedParams?: string(name='ExtendedParams'),
  notifyType?: string(name='NotifyType'),
  pushAction?: long(name='PushAction'),
  silent?: long(name='Silent'),
  targetMsg: [
    {
      extendedParams?: string(name='ExtendedParams'),
      msgKey: string(name='MsgKey'),
      target: string(name='Target'),
      templateKeyValue?: string(name='TemplateKeyValue'),
    }
  ](name='TargetMsg'),
  taskName?: string(name='TaskName'),
  templateName: string(name='TemplateName'),
  workspaceId: string(name='WorkspaceId'),
}

model PushMultipleResponse = {
  requestId: string(name='RequestId'),
  resultCode: string(name='ResultCode'),
  resultMessage: string(name='ResultMessage'),
}

async function pushMultipleWithOptions(request: PushMultipleRequest, runtime: Util.RuntimeOptions): PushMultipleResponse {
  Util.validateModel(request);
  return doRequest('PushMultiple', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function pushMultiple(request: PushMultipleRequest): PushMultipleResponse {
  var runtime = new Util.RuntimeOptions{};
  return pushMultipleWithOptions(request, runtime);
}

model ListMcdpAimRequest = {
  appId?: string(name='AppId'),
  emptyTag?: string(name='EmptyTag'),
  keyword?: string(name='Keyword'),
  name?: string(name='Name'),
  pageNo?: long(name='PageNo'),
  pageSize?: long(name='PageSize'),
  sort?: string(name='Sort'),
  sortField?: string(name='SortField'),
  tenantId?: string(name='TenantId'),
  type?: string(name='Type'),
  workspaceId?: string(name='WorkspaceId'),
}

model ListMcdpAimResponse = {
  requestId: string(name='RequestId'),
  resultCode: string(name='ResultCode'),
  resultMessage: string(name='ResultMessage'),
  resultContent: {
    code: string(name='Code'),
    data: string(name='Data'),
    message: string(name='Message'),
    success: boolean(name='Success'),
  }(name='ResultContent'),
}

async function listMcdpAimWithOptions(request: ListMcdpAimRequest, runtime: Util.RuntimeOptions): ListMcdpAimResponse {
  Util.validateModel(request);
  return doRequest('ListMcdpAim', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function listMcdpAim(request: ListMcdpAimRequest): ListMcdpAimResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMcdpAimWithOptions(request, runtime);
}

model SaveMgsApirestRequest = {
  appId?: string(name='AppId'),
  mpaasMappcenterMgsApirestSaveJsonStr?: string(name='MpaasMappcenterMgsApirestSaveJsonStr'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model SaveMgsApirestResponse = {
  requestId: string(name='RequestId'),
  resultCode: string(name='ResultCode'),
  resultMessage: string(name='ResultMessage'),
  resultContent: {
    errorMessage: string(name='ErrorMessage'),
    success: boolean(name='Success'),
    value: boolean(name='Value'),
  }(name='ResultContent'),
}

async function saveMgsApirestWithOptions(request: SaveMgsApirestRequest, runtime: Util.RuntimeOptions): SaveMgsApirestResponse {
  Util.validateModel(request);
  return doRequest('SaveMgsApirest', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function saveMgsApirest(request: SaveMgsApirestRequest): SaveMgsApirestResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveMgsApirestWithOptions(request, runtime);
}

model QueryMgsTestreqbodyautogenRequest = {
  appId?: string(name='AppId'),
  format?: string(name='Format'),
  mpaasMappcenterMgsTestreqbodyautogenQueryJsonStr?: string(name='MpaasMappcenterMgsTestreqbodyautogenQueryJsonStr'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model QueryMgsTestreqbodyautogenResponse = {
  requestId: string(name='RequestId'),
  resultCode: string(name='ResultCode'),
  resultMessage: string(name='ResultMessage'),
  resultContent: string(name='ResultContent'),
}

async function queryMgsTestreqbodyautogenWithOptions(request: QueryMgsTestreqbodyautogenRequest, runtime: Util.RuntimeOptions): QueryMgsTestreqbodyautogenResponse {
  Util.validateModel(request);
  return doRequest('QueryMgsTestreqbodyautogen', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function queryMgsTestreqbodyautogen(request: QueryMgsTestreqbodyautogenRequest): QueryMgsTestreqbodyautogenResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMgsTestreqbodyautogenWithOptions(request, runtime);
}

model QueryMgsApirestRequest = {
  appId?: string(name='AppId'),
  format?: string(name='Format'),
  id?: long(name='Id'),
  tenantId?: string(name='TenantId'),
  type?: string(name='Type'),
  workspaceId?: string(name='WorkspaceId'),
}

model QueryMgsApirestResponse = {
  requestId: string(name='RequestId'),
  resultCode: string(name='ResultCode'),
  resultMessage: string(name='ResultMessage'),
  resultContent: {
    errorMessage: string(name='ErrorMessage'),
    success: boolean(name='Success'),
    value: {
      apiName: string(name='ApiName'),
      apiStatus: string(name='ApiStatus'),
      apiType: string(name='ApiType'),
      appId: string(name='AppId'),
      authRuleName: string(name='AuthRuleName'),
      charset: string(name='Charset'),
      contentType: string(name='ContentType'),
      description: string(name='Description'),
      gmtCreate: string(name='GmtCreate'),
      gmtModified: string(name='GmtModified'),
      host: string(name='Host'),
      id: long(name='Id'),
      interfaceType: string(name='InterfaceType'),
      method: string(name='Method'),
      methodName: string(name='MethodName'),
      needEncrypt: string(name='NeedEncrypt'),
      needETag: string(name='NeedETag'),
      needJsonp: string(name='NeedJsonp'),
      needSign: string(name='NeedSign'),
      operationType: string(name='OperationType'),
      paramGetMethod: string(name='ParamGetMethod'),
      path: string(name='Path'),
      requestBodyModel: string(name='RequestBodyModel'),
      responseBodyModel: string(name='ResponseBodyModel'),
      sysId: long(name='SysId'),
      sysName: string(name='SysName'),
      timeout: string(name='Timeout'),
      workspaceId: string(name='WorkspaceId'),
      headerRule: [
        {
          headerKey: string(name='HeaderKey'),
          location: string(name='Location'),
          type: string(name='Type'),
          value: string(name='Value'),
        }
      ](name='HeaderRule'),
      headerRules: [
        {
          headerKey: string(name='HeaderKey'),
          location: string(name='Location'),
          type: string(name='Type'),
          value: string(name='Value'),
        }
      ](name='HeaderRules'),
      requestParams: [
        {
          apiId: string(name='ApiId'),
          appId: string(name='AppId'),
          defaultValue: string(name='DefaultValue'),
          description: string(name='Description'),
          id: long(name='Id'),
          location: string(name='Location'),
          name: string(name='Name'),
          refType: string(name='RefType'),
          type: string(name='Type'),
          workspaceId: string(name='WorkspaceId'),
        }
      ](name='RequestParams'),
      apiInvoker: {
        rpcInvoker: string(name='RpcInvoker'),
        httpInvoker: {
          charset: string(name='Charset'),
          contentType: string(name='ContentType'),
          host: string(name='Host'),
          method: string(name='Method'),
          path: string(name='Path'),
        }(name='HttpInvoker'),
      }(name='ApiInvoker'),
      cacheRule: {
        cacheKey: string(name='CacheKey'),
        needCache: boolean(name='NeedCache'),
        ttl: long(name='Ttl'),
      }(name='CacheRule'),
      limitRule: {
        defaultResponse: string(name='DefaultResponse'),
        i18nResponse: string(name='I18nResponse'),
        interval: long(name='Interval'),
        limit: long(name='Limit'),
        mode: string(name='Mode'),
      }(name='LimitRule'),
      migrateRule: {
        flowPercent: long(name='FlowPercent'),
        needMigrate: boolean(name='NeedMigrate'),
        needSwitchCompletely: boolean(name='NeedSwitchCompletely'),
        sysId: long(name='SysId'),
        sysName: string(name='SysName'),
        upstreamType: string(name='UpstreamType'),
      }(name='MigrateRule'),
      mockRule: {
        mockData: string(name='MockData'),
        needMock: boolean(name='NeedMock'),
        percentage: long(name='Percentage'),
        type: string(name='Type'),
      }(name='MockRule'),
    }(name='Value'),
  }(name='ResultContent'),
}

async function queryMgsApirestWithOptions(request: QueryMgsApirestRequest, runtime: Util.RuntimeOptions): QueryMgsApirestResponse {
  Util.validateModel(request);
  return doRequest('QueryMgsApirest', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function queryMgsApirest(request: QueryMgsApirestRequest): QueryMgsApirestResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMgsApirestWithOptions(request, runtime);
}

model ListMgsApiRequest = {
  apiStatus?: string(name='ApiStatus'),
  apiType?: string(name='ApiType'),
  appId?: string(name='AppId'),
  format?: string(name='Format'),
  host?: string(name='Host'),
  needEncrypt?: string(name='NeedEncrypt'),
  needEtag?: string(name='NeedEtag'),
  needSign?: string(name='NeedSign'),
  operationType?: string(name='OperationType'),
  optFuzzy?: string(name='OptFuzzy'),
  pageIndex?: long(name='PageIndex'),
  pageSize?: long(name='PageSize'),
  sysId?: long(name='SysId'),
  sysName?: string(name='SysName'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model ListMgsApiResponse = {
  requestId: string(name='RequestId'),
  resultCode: string(name='ResultCode'),
  resultMessage: string(name='ResultMessage'),
  resultContent: {
    errorMessage: string(name='ErrorMessage'),
    success: boolean(name='Success'),
    value: [
      {
        apiName: string(name='ApiName'),
        apiStatus: string(name='ApiStatus'),
        apiType: string(name='ApiType'),
        appId: string(name='AppId'),
        authRuleName: string(name='AuthRuleName'),
        charset: string(name='Charset'),
        contentType: string(name='ContentType'),
        description: string(name='Description'),
        gmtCreate: string(name='GmtCreate'),
        gmtModified: string(name='GmtModified'),
        host: string(name='Host'),
        id: long(name='Id'),
        interfaceType: string(name='InterfaceType'),
        method: string(name='Method'),
        methodName: string(name='MethodName'),
        needEncrypt: string(name='NeedEncrypt'),
        needETag: string(name='NeedETag'),
        needJsonp: string(name='NeedJsonp'),
        needSign: string(name='NeedSign'),
        operationType: string(name='OperationType'),
        paramGetMethod: string(name='ParamGetMethod'),
        path: string(name='Path'),
        requestBodyModel: string(name='RequestBodyModel'),
        responseBodyModel: string(name='ResponseBodyModel'),
        sysId: long(name='SysId'),
        sysName: string(name='SysName'),
        timeout: string(name='Timeout'),
        workspaceId: string(name='WorkspaceId'),
        headerRule: [
          {
            headerKey: string(name='HeaderKey'),
            location: string(name='Location'),
            type: string(name='Type'),
            value: string(name='Value'),
          }
        ](name='HeaderRule'),
        headerRules: [
          {
            headerKey: string(name='HeaderKey'),
            location: string(name='Location'),
            type: string(name='Type'),
            value: string(name='Value'),
          }
        ](name='HeaderRules'),
        requestParams: [
          {
            apiId: string(name='ApiId'),
            appId: string(name='AppId'),
            defaultValue: string(name='DefaultValue'),
            description: string(name='Description'),
            id: long(name='Id'),
            location: string(name='Location'),
            name: string(name='Name'),
            refType: string(name='RefType'),
            type: string(name='Type'),
            workspaceId: string(name='WorkspaceId'),
          }
        ](name='RequestParams'),
        apiInvoker: {
          rpcInvoker: string(name='RpcInvoker'),
          httpInvoker: {
            charset: string(name='Charset'),
            contentType: string(name='ContentType'),
            host: string(name='Host'),
            method: string(name='Method'),
            path: string(name='Path'),
          }(name='HttpInvoker'),
        }(name='ApiInvoker'),
        cacheRule: {
          cacheKey: string(name='CacheKey'),
          needCache: boolean(name='NeedCache'),
          ttl: long(name='Ttl'),
        }(name='CacheRule'),
        limitRule: {
          defaultResponse: string(name='DefaultResponse'),
          i18nResponse: string(name='I18nResponse'),
          interval: long(name='Interval'),
          limit: long(name='Limit'),
          mode: string(name='Mode'),
        }(name='LimitRule'),
        migrateRule: {
          flowPercent: long(name='FlowPercent'),
          needMigrate: boolean(name='NeedMigrate'),
          needSwitchCompletely: boolean(name='NeedSwitchCompletely'),
          sysId: long(name='SysId'),
          sysName: string(name='SysName'),
          upstreamType: string(name='UpstreamType'),
        }(name='MigrateRule'),
        mockRule: {
          mockData: string(name='MockData'),
          needMock: boolean(name='NeedMock'),
          percentage: long(name='Percentage'),
          type: string(name='Type'),
        }(name='MockRule'),
      }
    ](name='Value'),
  }(name='ResultContent'),
}

async function listMgsApiWithOptions(request: ListMgsApiRequest, runtime: Util.RuntimeOptions): ListMgsApiResponse {
  Util.validateModel(request);
  return doRequest('ListMgsApi', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function listMgsApi(request: ListMgsApiRequest): ListMgsApiResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMgsApiWithOptions(request, runtime);
}

model QueryMgsApipageRequest = {
  apiStatus?: string(name='ApiStatus'),
  apiType?: string(name='ApiType'),
  appId?: string(name='AppId'),
  format?: string(name='Format'),
  host?: string(name='Host'),
  needEncrypt?: string(name='NeedEncrypt'),
  needEtag?: string(name='NeedEtag'),
  needSign?: string(name='NeedSign'),
  operationType?: string(name='OperationType'),
  optFuzzy?: string(name='OptFuzzy'),
  pageIndex?: long(name='PageIndex'),
  pageSize?: long(name='PageSize'),
  sysId?: long(name='SysId'),
  sysName?: string(name='SysName'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model QueryMgsApipageResponse = {
  requestId: string(name='RequestId'),
  resultCode: string(name='ResultCode'),
  resultMessage: string(name='ResultMessage'),
  resultContent: {
    current: long(name='Current'),
    pageSize: long(name='PageSize'),
    total: long(name='Total'),
    list: [
      {
        apiName: string(name='ApiName'),
        apiStatus: string(name='ApiStatus'),
        apiType: string(name='ApiType'),
        appId: string(name='AppId'),
        authRuleName: string(name='AuthRuleName'),
        charset: string(name='Charset'),
        contentType: string(name='ContentType'),
        description: string(name='Description'),
        gmtCreate: string(name='GmtCreate'),
        gmtModified: string(name='GmtModified'),
        host: string(name='Host'),
        id: long(name='Id'),
        interfaceType: string(name='InterfaceType'),
        method: string(name='Method'),
        methodName: string(name='MethodName'),
        needEncrypt: string(name='NeedEncrypt'),
        needETag: string(name='NeedETag'),
        needJsonp: string(name='NeedJsonp'),
        needSign: string(name='NeedSign'),
        operationType: string(name='OperationType'),
        paramGetMethod: string(name='ParamGetMethod'),
        path: string(name='Path'),
        requestBodyModel: string(name='RequestBodyModel'),
        responseBodyModel: string(name='ResponseBodyModel'),
        sysId: long(name='SysId'),
        sysName: string(name='SysName'),
        timeout: string(name='Timeout'),
        workspaceId: string(name='WorkspaceId'),
        headerRule: [
          {
            headerKey: string(name='HeaderKey'),
            location: string(name='Location'),
            type: string(name='Type'),
            value: string(name='Value'),
          }
        ](name='HeaderRule'),
        headerRules: [
          {
            headerKey: string(name='HeaderKey'),
            location: string(name='Location'),
            type: string(name='Type'),
            value: string(name='Value'),
          }
        ](name='HeaderRules'),
        requestParams: [
          {
            apiId: string(name='ApiId'),
            appId: string(name='AppId'),
            defaultValue: string(name='DefaultValue'),
            description: string(name='Description'),
            id: long(name='Id'),
            location: string(name='Location'),
            name: string(name='Name'),
            refType: string(name='RefType'),
            type: string(name='Type'),
            workspaceId: string(name='WorkspaceId'),
          }
        ](name='RequestParams'),
        apiInvoker: {
          rpcInvoker: string(name='RpcInvoker'),
          httpInvoker: {
            charset: string(name='Charset'),
            contentType: string(name='ContentType'),
            host: string(name='Host'),
            method: string(name='Method'),
            path: string(name='Path'),
          }(name='HttpInvoker'),
        }(name='ApiInvoker'),
        cacheRule: {
          cacheKey: string(name='CacheKey'),
          needCache: boolean(name='NeedCache'),
          ttl: long(name='Ttl'),
        }(name='CacheRule'),
        limitRule: {
          defaultResponse: string(name='DefaultResponse'),
          i18nResponse: string(name='I18nResponse'),
          interval: long(name='Interval'),
          limit: long(name='Limit'),
          mode: string(name='Mode'),
        }(name='LimitRule'),
        migrateRule: {
          flowPercent: long(name='FlowPercent'),
          needMigrate: boolean(name='NeedMigrate'),
          needSwitchCompletely: boolean(name='NeedSwitchCompletely'),
          sysId: long(name='SysId'),
          sysName: string(name='SysName'),
          upstreamType: string(name='UpstreamType'),
        }(name='MigrateRule'),
        mockRule: {
          mockData: string(name='MockData'),
          needMock: boolean(name='NeedMock'),
          percentage: long(name='Percentage'),
          type: string(name='Type'),
        }(name='MockRule'),
      }
    ](name='List'),
  }(name='ResultContent'),
}

async function queryMgsApipageWithOptions(request: QueryMgsApipageRequest, runtime: Util.RuntimeOptions): QueryMgsApipageResponse {
  Util.validateModel(request);
  return doRequest('QueryMgsApipage', 'HTTPS', 'POST', '2019-08-21', 'AK', null, request, runtime);
}

async function queryMgsApipage(request: QueryMgsApipageRequest): QueryMgsApipageResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMgsApipageWithOptions(request, runtime);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
