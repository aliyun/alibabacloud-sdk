/**
  *
  */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'wuying-personal-pc';
  @version = '2025-11-11';
  @endpointRule = '';
  @endpointMap = {
  };
}

function close(): void {
  @handler.close();
}

model CreateDesktopImageRequest {
  apiKey: string(name='ApiKey', description='This parameter is required.', position='Query'),
  autoCleanUserData?: boolean(name='AutoCleanUserData', position='Query'),
  description?: string(name='Description', position='Query'),
  desktopId: string(name='DesktopId', description='This parameter is required.', position='Query'),
  diskType: string(name='DiskType', description='This parameter is required.', position='Query'),
  enableStartUpConfig?: boolean(name='EnableStartUpConfig', position='Query'),
  imageName: string(name='ImageName', description='This parameter is required.', position='Query'),
  sessionId?: string(name='SessionId', position='Query'),
  startUpFilePathList?: [ string ](name='StartUpFilePathList', shrink='json', position='Query'),
}

model CreateDesktopImageResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  traceId?: string(name='TraceId'),
}

model CreateDesktopImageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDesktopImageResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateDesktopImage  CreateDesktopImageRequest
  * @return CreateDesktopImageResponse
 */
async function createDesktopImage(request: CreateDesktopImageRequest): CreateDesktopImageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDesktopImage', 'POST', '/', 'json', false, 'json', request);
}

model CreateOrderRequest {
  apiKey: string(name='ApiKey', description='This parameter is required.', position='Query'),
  autoPay?: boolean(name='AutoPay', position='Query'),
  dynamicProductParams: [ 
    {
      amount?: int32(name='Amount'),
      deliveryAddress?: string(name='DeliveryAddress'),
      dynamicAttributes?: map[string]string(name='DynamicAttributes'),
      inputActivateConfig?: {
        cityName?: string(name='CityName'),
        desktopName?: string(name='DesktopName'),
        imageId?: string(name='ImageId'),
      }(name='InputActivateConfig'),
      instanceIdList?: [ string ](name='InstanceIdList'),
      linkedResourceId?: string(name='LinkedResourceId'),
      packageCode?: string(name='PackageCode'),
      productCode?: string(name='ProductCode'),
      productSkuCode?: string(name='ProductSkuCode'),
      resourceId?: string(name='ResourceId'),
    }
  ](name='DynamicProductParams', description='This parameter is required.', shrink='json', position='Query'),
  operationType: string(name='OperationType', description='This parameter is required.', position='Query'),
  orderFrom?: string(name='OrderFrom', position='Query'),
  sessionId?: string(name='SessionId', position='Query'),
}

model CreateOrderResponseBody = {
  code?: string(name='Code'),
  data?: {
    orderDetailList?: [ 
      {
        instanceIds?: [ string ](name='InstanceIds'),
        orderId?: long(name='OrderId'),
      }
    ](name='OrderDetailList'),
    orderId?: string(name='OrderId'),
    payLink?: string(name='PayLink'),
    resourceId?: string(name='ResourceId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  traceId?: string(name='TraceId'),
}

model CreateOrderResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateOrderResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateOrder  CreateOrderRequest
  * @return CreateOrderResponse
 */
async function createOrder(request: CreateOrderRequest): CreateOrderResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateOrder', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDesktopRequest {
  apiKey: string(name='ApiKey', description='This parameter is required.', position='Query'),
  desktopId: string(name='DesktopId', description='This parameter is required.', position='Query'),
  sessionId?: string(name='SessionId', position='Query'),
}

model DeleteDesktopResponseBody = {
  code?: string(name='Code'),
  requestId?: string(name='RequestId'),
  traceId?: string(name='TraceId'),
}

model DeleteDesktopResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDesktopResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteDesktop  DeleteDesktopRequest
  * @return DeleteDesktopResponse
 */
async function deleteDesktop(request: DeleteDesktopRequest): DeleteDesktopResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDesktop', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDesktopImageRequest {
  apiKey: string(name='ApiKey', description='This parameter is required.', position='Query'),
  imageId: string(name='ImageId', description='This parameter is required.', position='Query'),
  isCleanImageCode?: boolean(name='IsCleanImageCode', position='Query'),
  sessionId?: string(name='SessionId', position='Query'),
}

model DeleteDesktopImageResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  traceId?: string(name='TraceId'),
}

model DeleteDesktopImageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDesktopImageResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteDesktopImage  DeleteDesktopImageRequest
  * @return DeleteDesktopImageResponse
 */
async function deleteDesktopImage(request: DeleteDesktopImageRequest): DeleteDesktopImageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDesktopImage', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAccessibleImagesRequest {
  apiKey: string(name='ApiKey', description='This parameter is required.', position='Query'),
  bizSource?: string(name='BizSource', position='Query'),
  desktopId?: string(name='DesktopId', position='Query'),
  desktopType?: string(name='DesktopType', position='Query'),
  imageType?: string(name='ImageType', position='Query'),
  resourceId?: string(name='ResourceId', position='Query'),
  scene?: string(name='Scene', position='Query'),
  searchKey?: string(name='SearchKey', position='Query'),
  sessionId?: string(name='SessionId', position='Query'),
}

model DescribeAccessibleImagesResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      activityType?: string(name='ActivityType'),
      authTime?: string(name='AuthTime'),
      canUpdate?: boolean(name='CanUpdate'),
      currentImageCodeInfo?: {
        currentPassword?: string(name='CurrentPassword'),
        expireTime?: string(name='ExpireTime'),
        gmtCreated?: string(name='GmtCreated'),
        gmtModified?: string(name='GmtModified'),
        imageCode?: string(name='ImageCode'),
        imageId?: string(name='ImageId'),
        isCopyPassword?: boolean(name='IsCopyPassword'),
        isEncrypted?: boolean(name='IsEncrypted'),
        isFree?: boolean(name='IsFree'),
        periodDays?: int32(name='PeriodDays'),
        redeemCount?: int32(name='RedeemCount'),
        redeemQuota?: int32(name='RedeemQuota'),
      }(name='CurrentImageCodeInfo'),
      dataDiskSize?: int32(name='DataDiskSize'),
      deployMode?: string(name='DeployMode'),
      description?: string(name='Description'),
      dockerImageSize?: int32(name='DockerImageSize'),
      enableStartUpConfig?: boolean(name='EnableStartUpConfig'),
      gmtCreated?: string(name='GmtCreated'),
      imageId?: string(name='ImageId'),
      imageScope?: string(name='ImageScope'),
      imageSource?: string(name='ImageSource'),
      imageType?: string(name='ImageType'),
      isGpu?: boolean(name='IsGpu'),
      isLinggou?: string(name='IsLinggou'),
      isWorkstation?: boolean(name='IsWorkstation'),
      name?: string(name='Name'),
      operationSystem?: string(name='OperationSystem'),
      osType?: string(name='OsType'),
      permission?: string(name='Permission'),
      platform?: string(name='Platform'),
      progress?: string(name='Progress'),
      receiverType?: string(name='ReceiverType'),
      shareCodes?: [ string ](name='ShareCodes'),
      shareCodesIncludeDisable?: [ string ](name='ShareCodesIncludeDisable'),
      shared?: boolean(name='Shared'),
      sharedBy?: string(name='SharedBy'),
      sourceDesktopId?: string(name='SourceDesktopId'),
      sourceDesktopType?: string(name='SourceDesktopType'),
      sourceImageId?: string(name='SourceImageId'),
      sourceImageName?: string(name='SourceImageName'),
      startUpFileList?: [ string ](name='StartUpFileList'),
      status?: string(name='Status'),
      supportPublish?: boolean(name='SupportPublish'),
      systemDiskSize?: int32(name='SystemDiskSize'),
      validationCode?: string(name='ValidationCode'),
    }
  ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  traceId?: string(name='TraceId'),
}

model DescribeAccessibleImagesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAccessibleImagesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeAccessibleImages  DescribeAccessibleImagesRequest
  * @return DescribeAccessibleImagesResponse
 */
async function describeAccessibleImages(request: DescribeAccessibleImagesRequest): DescribeAccessibleImagesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAccessibleImages', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCorePackageListRequest {
  apiKey: string(name='ApiKey', description='This parameter is required.', position='Query'),
  queryDeductionInstances?: boolean(name='QueryDeductionInstances', position='Query'),
  queryScenario?: string(name='QueryScenario', position='Query'),
}

model DescribeCorePackageListResponseBody = {
  code?: string(name='Code'),
  corePackageInfo?: {
    corePackageList?: [ 
      {
        assignedCoreHours?: float(name='AssignedCoreHours'),
        deductionInstanceList?: [ any ](name='DeductionInstanceList'),
        expireTime?: string(name='ExpireTime'),
        instanceId?: string(name='InstanceId'),
        periodEndTime?: string(name='PeriodEndTime'),
        periodStartTime?: string(name='PeriodStartTime'),
        productType?: string(name='ProductType'),
        remainingCoreHours?: float(name='RemainingCoreHours'),
        remainingPeriods?: [ 
          {
            periodEndTime?: string(name='PeriodEndTime'),
            periodStartTime?: string(name='PeriodStartTime'),
            remainingCoreHours?: float(name='RemainingCoreHours'),
            status?: string(name='Status'),
            totalCoreHours?: float(name='TotalCoreHours'),
            usedCoreHours?: float(name='UsedCoreHours'),
          }
        ](name='RemainingPeriods'),
        startTime?: string(name='StartTime'),
        status?: string(name='Status'),
        totalCoreHours?: float(name='TotalCoreHours'),
        unassignedCoreHours?: float(name='UnassignedCoreHours'),
        usedCoreHours?: float(name='UsedCoreHours'),
      }
    ](name='CorePackageList'),
    summaryRemainingCoreHours?: float(name='SummaryRemainingCoreHours'),
  }(name='CorePackageInfo'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  traceId?: string(name='TraceId'),
}

model DescribeCorePackageListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCorePackageListResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeCorePackageList  DescribeCorePackageListRequest
  * @return DescribeCorePackageListResponse
 */
async function describeCorePackageList(request: DescribeCorePackageListRequest): DescribeCorePackageListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCorePackageList', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDesktopsRequest {
  apiKey: string(name='ApiKey', description='This parameter is required.', position='Query'),
  displayType?: string(name='DisplayType', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
}

model DescribeDesktopsResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  result?: any(name='Result'),
  traceId?: string(name='TraceId'),
}

model DescribeDesktopsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDesktopsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeDesktops  DescribeDesktopsRequest
  * @return DescribeDesktopsResponse
 */
async function describeDesktops(request: DescribeDesktopsRequest): DescribeDesktopsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDesktops', 'POST', '/', 'json', false, 'json', request);
}

model DescribeImageDetailRequest {
  apiKey: string(name='ApiKey', description='This parameter is required.', position='Query'),
  imageId?: string(name='ImageId', position='Query'),
  sessionId?: string(name='SessionId', position='Query'),
  shareCode?: string(name='ShareCode', position='Query'),
}

model DescribeImageDetailResponseBody = {
  code?: string(name='Code'),
  data?: {
    currentImageCodeInfo?: {
      currentPassword?: string(name='CurrentPassword'),
      expireTime?: string(name='ExpireTime'),
      gmtCreated?: string(name='GmtCreated'),
      gmtModified?: string(name='GmtModified'),
      imageCode?: string(name='ImageCode'),
      isCopyPassword?: boolean(name='IsCopyPassword'),
      isEncrypted?: boolean(name='IsEncrypted'),
      isFree?: boolean(name='IsFree'),
      periodDays?: int32(name='PeriodDays'),
      redeemCount?: int32(name='RedeemCount'),
      redeemQuota?: int32(name='RedeemQuota'),
    }(name='CurrentImageCodeInfo'),
    dataDiskSize?: int32(name='DataDiskSize'),
    description?: string(name='Description'),
    enableStartUpConfig?: boolean(name='EnableStartUpConfig'),
    gmtCreated?: string(name='GmtCreated'),
    imageId?: string(name='ImageId'),
    imageScope?: string(name='ImageScope'),
    isGpu?: boolean(name='IsGpu'),
    name?: string(name='Name'),
    osType?: string(name='OsType'),
    permission?: string(name='Permission'),
    platform?: string(name='Platform'),
    progress?: string(name='Progress'),
    shareCodes?: [ string ](name='ShareCodes'),
    shareCodesIncludeDisable?: [ string ](name='ShareCodesIncludeDisable'),
    shared?: boolean(name='Shared'),
    sourceDesktopType?: string(name='SourceDesktopType'),
    startUpFileList?: [ string ](name='StartUpFileList'),
    status?: string(name='Status'),
    systemDiskSize?: int32(name='SystemDiskSize'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  traceId?: string(name='TraceId'),
}

model DescribeImageDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeImageDetailResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeImageDetail  DescribeImageDetailRequest
  * @return DescribeImageDetailResponse
 */
async function describeImageDetail(request: DescribeImageDetailRequest): DescribeImageDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeImageDetail', 'POST', '/', 'json', false, 'json', request);
}

model DescribePackageOrdersRequest {
  apiKey: string(name='ApiKey', description='This parameter is required.', position='Query'),
  currentPage?: long(name='CurrentPage', position='Query'),
  desktopIdList?: [ string ](name='DesktopIdList', shrink='json', position='Query'),
  orderIdList?: [ string ](name='OrderIdList', shrink='json', position='Query'),
  orderStatusList?: [ string ](name='OrderStatusList', shrink='json', position='Query'),
  pageSize?: long(name='PageSize', minimum=10, maximum=100, position='Query'),
  productTypeList?: [ string ](name='ProductTypeList', shrink='json', position='Query'),
  resourceIdList?: [ string ](name='ResourceIdList', shrink='json', position='Query'),
  sessionId?: string(name='SessionId', position='Query'),
}

model DescribePackageOrdersResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  page?: {
    currentPage?: long(name='CurrentPage'),
    orderList?: [ 
      {
        amount?: int32(name='Amount'),
        creatorAliUid?: long(name='CreatorAliUid'),
        deliveryAddress?: string(name='DeliveryAddress'),
        desktopId?: string(name='DesktopId'),
        gmtCanceledTime?: string(name='GmtCanceledTime', description='Use the UTC time format: yyyy-MM-ddTHH:mm:ssZ'),
        gmtCreateTime?: string(name='GmtCreateTime', description='Use the UTC time format: yyyy-MM-ddTHH:mm:ssZ'),
        gmtPaidTime?: string(name='GmtPaidTime', description='Use the UTC time format: yyyy-MM-ddTHH:mm:ssZ'),
        instanceId?: string(name='InstanceId'),
        orderId?: string(name='OrderId'),
        orderStatus?: string(name='OrderStatus'),
        orderType?: string(name='OrderType'),
        productCode?: string(name='ProductCode'),
        productSkuCode?: string(name='ProductSkuCode'),
        productType?: string(name='ProductType'),
        tradePrice?: string(name='TradePrice'),
      }
    ](name='OrderList'),
    pageSize?: long(name='PageSize'),
    totalCount?: long(name='TotalCount'),
  }(name='Page'),
  requestId?: string(name='RequestId'),
  traceId?: string(name='TraceId'),
}

model DescribePackageOrdersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePackageOrdersResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribePackageOrders  DescribePackageOrdersRequest
  * @return DescribePackageOrdersResponse
 */
async function describePackageOrders(request: DescribePackageOrdersRequest): DescribePackageOrdersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePackageOrders', 'POST', '/', 'json', false, 'json', request);
}

model GenerateWuyingServerSceneUrlRequest {
  clientId?: string(name='ClientId', position='Body'),
  clientIp?: string(name='ClientIp', position='Body'),
  clientOS?: string(name='ClientOS', position='Body'),
  clientType?: string(name='ClientType', position='Body'),
  clientVersion?: string(name='ClientVersion', position='Body'),
  endUserId?: string(name='EndUserId', position='Body'),
  loginRegionId?: string(name='LoginRegionId', position='Body'),
  loginToken: string(name='LoginToken', description='This parameter is required.', position='Body'),
  productType: string(name='ProductType', description='This parameter is required.', position='Body'),
  scene: string(name='Scene', description='This parameter is required.', position='Body'),
  sessionId: string(name='SessionId', description='This parameter is required.', position='Body'),
  uuid?: string(name='Uuid', position='Body'),
  wuyingServerId: string(name='WuyingServerId', description='This parameter is required.', position='Body'),
}

model GenerateWuyingServerSceneUrlResponseBody = {
  expireDurationHours?: int32(name='ExpireDurationHours'),
  expireTime?: string(name='ExpireTime'),
  requestId?: string(name='RequestId'),
  url?: string(name='Url'),
}

model GenerateWuyingServerSceneUrlResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GenerateWuyingServerSceneUrlResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GenerateWuyingServerSceneUrl  GenerateWuyingServerSceneUrlRequest
  * @return GenerateWuyingServerSceneUrlResponse
 */
async function generateWuyingServerSceneUrl(request: GenerateWuyingServerSceneUrlRequest): GenerateWuyingServerSceneUrlResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GenerateWuyingServerSceneUrl', 'POST', '/', 'json', true, 'form', request);
}

model GetProductListRequest {
  apiKey: string(name='ApiKey', description='This parameter is required.', position='Query'),
  configVersion?: string(name='ConfigVersion', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  sessionId?: string(name='SessionId', position='Query'),
  type: string(name='Type', description='This parameter is required.', position='Query'),
}

model GetProductListResponseBody = {
  code?: string(name='Code'),
  displayInfo?: {
    productList?: [ 
      {
        displayAttribute?: string(name='DisplayAttribute'),
        displayConfig?: string(name='DisplayConfig'),
        dynamicAttribute?: string(name='DynamicAttribute'),
        isEnable?: boolean(name='IsEnable'),
        modificationLevel?: int32(name='ModificationLevel'),
        productCode?: string(name='ProductCode'),
        productDesc?: string(name='ProductDesc'),
        productGroup?: string(name='ProductGroup'),
        productName?: string(name='ProductName'),
        productType?: string(name='ProductType'),
        skuList?: [ 
          {
            appleSkuCode?: string(name='AppleSkuCode'),
            attribute?: string(name='Attribute'),
            purchaseMode?: string(name='PurchaseMode'),
            skuCode?: string(name='SkuCode'),
            skuDesc?: string(name='SkuDesc'),
            skuName?: string(name='SkuName'),
          }
        ](name='SkuList'),
      }
    ](name='ProductList'),
  }(name='DisplayInfo'),
  maxResults?: int32(name='MaxResults'),
  message?: string(name='Message'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  traceId?: string(name='TraceId'),
}

model GetProductListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetProductListResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetProductList  GetProductListRequest
  * @return GetProductListResponse
 */
async function getProductList(request: GetProductListRequest): GetProductListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetProductList', 'POST', '/', 'json', false, 'json', request);
}

model GetUserInfoRequest {
  apiKey: string(name='ApiKey', description='This parameter is required.', position='Query'),
}

model GetUserInfoResponseBody = {
  aliyunId?: string(name='AliyunId'),
  nickName?: string(name='NickName'),
  phone?: string(name='Phone'),
  requestId?: string(name='RequestId'),
  unionId?: string(name='UnionId'),
}

model GetUserInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetUserInfoResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetUserInfo  GetUserInfoRequest
  * @return GetUserInfoResponse
 */
async function getUserInfo(request: GetUserInfoRequest): GetUserInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetUserInfo', 'POST', '/', 'json', false, 'json', request);
}

model StartDesktopRequest {
  apiKey: string(name='ApiKey', description='This parameter is required.', position='Query'),
  desktopId: string(name='DesktopId', description='This parameter is required.', position='Query'),
  sessionId?: string(name='SessionId', position='Query'),
}

model StartDesktopResponseBody = {
  code?: string(name='Code'),
  requestId?: string(name='RequestId'),
  traceId?: string(name='TraceId'),
}

model StartDesktopResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StartDesktopResponseBody(name='body'),
}

/**
  * @param request  the request parameters of StartDesktop  StartDesktopRequest
  * @return StartDesktopResponse
 */
async function startDesktop(request: StartDesktopRequest): StartDesktopResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StartDesktop', 'POST', '/', 'json', false, 'json', request);
}

model StopDesktopRequest {
  apiKey: string(name='ApiKey', description='This parameter is required.', position='Query'),
  desktopId: string(name='DesktopId', description='This parameter is required.', position='Query'),
  sessionId?: string(name='SessionId', position='Query'),
}

model StopDesktopResponseBody = {
  code?: string(name='Code'),
  requestId?: string(name='RequestId'),
  traceId?: string(name='TraceId'),
}

model StopDesktopResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StopDesktopResponseBody(name='body'),
}

/**
  * @param request  the request parameters of StopDesktop  StopDesktopRequest
  * @return StopDesktopResponse
 */
async function stopDesktop(request: StopDesktopRequest): StopDesktopResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StopDesktop', 'POST', '/', 'json', false, 'json', request);
}

