/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'Ons';
  @version = '2019-02-14';
  @endpointRule = 'regional';
  @endpointMap = {
    ap-northeast-2-pop = 'ons.ap-northeast-1.aliyuncs.com',
    cn-beijing-finance-1 = 'ons.aliyuncs.com',
    cn-beijing-finance-pop = 'ons.aliyuncs.com',
    cn-beijing-gov-1 = 'ons.aliyuncs.com',
    cn-beijing-nu16-b01 = 'ons.aliyuncs.com',
    cn-edge-1 = 'ons.aliyuncs.com',
    cn-fujian = 'ons.aliyuncs.com',
    cn-haidian-cm12-c01 = 'ons.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'ons.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'ons.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'ons.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'ons.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'ons.aliyuncs.com',
    cn-hangzhou-test-306 = 'ons.aliyuncs.com',
    cn-hongkong-finance-pop = 'ons.aliyuncs.com',
    cn-qingdao-nebula = 'ons.aliyuncs.com',
    cn-shanghai-et15-b01 = 'ons.aliyuncs.com',
    cn-shanghai-et2-b01 = 'ons.aliyuncs.com',
    cn-shanghai-inner = 'ons.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'ons.aliyuncs.com',
    cn-shenzhen-inner = 'ons.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'ons.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'ons.aliyuncs.com',
    cn-wuhan = 'ons.aliyuncs.com',
    cn-yushanfang = 'ons.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'ons.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'ons.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'ons.aliyuncs.com',
    eu-west-1-oxs = 'ons.ap-northeast-1.aliyuncs.com',
    rus-west-1-pop = 'ons.ap-northeast-1.aliyuncs.com',
  };
}

function close(): void {
  @handler.close();
}

model ListTagResourcesRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance to which the resource whose tags you want to query belongs.

> : This parameter is required when you query the tags of a topic or a group.', example='MQ_INST_188077086902****_BXSuW61e', position='Query'),
  nextToken?: string(name='NextToken', description='The token that determines the start point of the query.', example='caeba0****be03f84eb48b699f0a4883', position='Query'),
  resourceId?: [ string ](name='ResourceId', description='The list of resource IDs.', example='TopicA', position='Query'),
  resourceType: string(name='ResourceType', description='The type of the resource to which you want to attach tags. Valid values:

*   **INSTANCE**
*   **TOPIC**
*   **GROUP**', example='TOPIC', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key', description='The key of the tag that you want to attach to the specified resource.

*   If you include this parameter in a request, the value of this parameter cannot be an empty string.
*   The tag key can be up to 128 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.', example='CartService'),
      value?: string(name='Value', description='The value of the tag that you want to attach to the specified resource.

*   The value of this parameter can be an empty string.
*   The tag key can be up to 128 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.', example='ServiceA'),
    }
  ](name='Tag', description='The list of tags that are attached to the resources. A maximum of 20 tags can be included in the list.', position='Query'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken', description='The token that determines the start point of the query.', example='caeba0****be03f84eb48b699f0a4883'),
  requestId?: string(name='RequestId', description='The ID of the request. This parameter is a common parameter. Each request has a unique ID. You can use this ID to troubleshoot issues.', example='301D2CBE-66F8-403D-AEC0-82582478****'),
  tagResources?: [ 
    {
      instanceId?: string(name='InstanceId', description='The ID of the instance.', example='MQ_INST_188077086902****_BXSuW61e'),
      resourceId?: string(name='ResourceId', description='The ID of the resource.', example='TopicA'),
      resourceType?: string(name='ResourceType', description='The type of the resource to which you want to attach tags.

*   ALIYUN::MQ::INSTANCE: indicates that the resource is an instance.
*   ALIYUN::MQ::TOPIC: indicates that the resource is a topic.
*   ALIYUN::MQ::GROUP: indicates that the resource is a group.', example='ALIYUN::MQ::TOPIC'),
      tagKey?: string(name='TagKey', description='The key of the tag.', example='CartService'),
      tagValue?: string(name='TagValue', description='The value of the tag.', example='ServiceA'),
    }
  ](name='TagResources', description='Details of the resource and tags, including the resource ID, the resource type, and the keys and values of tags.'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagResourcesResponseBody(name='body'),
}

/**
  * > : The API operations that are provided by Alibaba Cloud are used to manage and query resources of Alibaba Cloud services. We recommend that you integrate these API operations only in management systems. Do not use these API operations in the core system of messaging services. Otherwise, system risks may occur.
  * When you call the **ListTagResources** operation, specify at least one of the following parameters in the request: **Tag.N.Key** and **ResourceId.N**. You can specify a resource ID to query all tags that are attached to the specified resource. You can also specify a tag key to query the tag value and the resource to which the tag is attached.
  * *   If you include the **Tag.N.Key** parameter in a request, you can obtain the tag value and the ID of the resource to which the tag is attached.********
  * *   If you include the **ResourceId.N** parameter in a request, you can obtain the keys and values of all tags that are attached to the specified resource.
  *
 */
async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTagResources', 'POST', '/', 'json', false, 'json', request);
}

model OnsConsumerAccumulateRequest {
  detail?: boolean(name='Detail', description='Specifies whether to query the details of each topic to which the consumer group subscribes. Valid values:

*   **true**: The details of each topic are queried. You can obtain the details from the **DetailInTopicList** response parameter.
*   **false**: The details of each topic are not queried. This is the default value. If you use this value, the value of the **DetailInTopicList** response parameter is empty.', example='true', position='Query'),
  groupId: string(name='GroupId', description='The ID of the consumer group whose message accumulation you want to query.', example='GID_test_consumer_id', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='MQ_INST_111111111111_DOxxxxxx', position='Query'),
}

model OnsConsumerAccumulateResponseBody = {
  data?: {
    consumeTps?: float(name='ConsumeTps', description='The transactions per second (TPS) for message consumption performed by consumers in the group.', example='10'),
    delayTime?: long(name='DelayTime', description='The consumption latency.', example='10000'),
    detailInTopicList?: {
      detailInTopicDo?: [ 
      {
        delayTime?: long(name='DelayTime', description='The maximum latency of message consumption in the topic.', example='10000'),
        lastTimestamp?: long(name='LastTimestamp', description='The point in time when the latest consumed message in the topic was produced.', example='1566231000000'),
        topic?: string(name='Topic', description='The name of the topic.', example='test-mq-topic'),
        totalDiff?: long(name='TotalDiff', description='The number of accumulated messages in the topic.', example='100'),
      }
    ](name='DetailInTopicDo')
    }(name='DetailInTopicList', description='The information about each topic to which the consumer group subscribes. If the **Detail** parameter in the request is set to **false**, the value of this parameter is empty.'),
    lastTimestamp?: long(name='LastTimestamp', description='The point in time when the latest message that was consumed by a consumer in the consumer group was produced.', example='1566231000000'),
    online?: boolean(name='Online', description='Indicates whether the consumer group is online. The group is online if one of the consumers in the group is online. Valid values:

*   **true**: The consumer group is online.
*   **false**: The consumer group is offline.', example='true'),
    totalDiff?: long(name='TotalDiff', description='The total number of accumulated messages in all topics to which the consumer group subscribes.', example='100'),
  }(name='Data', description='The information about message accumulation of topics to which the consumer group subscribes.'),
  requestId?: string(name='RequestId', description='The ID of the request. This parameter is a common parameter. Each request has a unique ID. You can use this ID to troubleshoot issues.', example='CE817BFF-B389-43CD-9419-95011AC9****'),
}

model OnsConsumerAccumulateResponse = {
  headers: map[string]string(name='headers'),
  body: OnsConsumerAccumulateResponseBody(name='body'),
}

/**
  * > : The API operations that are provided by Alibaba Cloud are used to manage and query resources of Alibaba Cloud services. We recommend that you integrate these API operations only in management systems. Do not use these API operations in the core system of messaging services. Otherwise, system risks may occur.
  * You can call this operation in scenarios in which you want to know the message consumption progress of a specified consumer group in production environments. You can obtain the information about message consumption and consumption latency based on the returned information. This operation returns the total number of accumulated messages in all topics to which the specified consumer group subscribes and the number of accumulated messages in each topic.
  *
 */
async function onsConsumerAccumulate(request: OnsConsumerAccumulateRequest): OnsConsumerAccumulateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OnsConsumerAccumulate', 'POST', '/', 'json', false, 'json', request);
}

model OnsConsumerGetConnectionRequest {
  groupId: string(name='GroupId', description='The ID of the consumer group whose client connection status you want to query.', example='GID_test_consumer_id', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance to which the consumer group belongs.', example='MQ_INST_111111111111_DOxxxxxx', position='Query'),
}

model OnsConsumerGetConnectionResponseBody = {
  data?: {
    connectionList?: {
      connectionDo?: [ 
      {
        clientAddr?: string(name='ClientAddr', description='The IP address and port number of the consumer instance.', example='30.5.121.**'),
        clientId?: string(name='ClientId', description='The ID of the consumer instance.', example='30.5.121.**@24813#-1999745829#-1737591554#453111174894656'),
        language?: string(name='Language', description='The programming language in which the consumer application was developed.', example='JAVA'),
        version?: string(name='Version', description='The version of the consumer client.', example='V4_3_6'),
      }
    ](name='ConnectionDo')
    }(name='ConnectionList', description='The connection information about the consumers in the specified group.'),
  }(name='Data', description='The data that is returned.'),
  requestId?: string(name='RequestId', description='The ID of the request. This parameter is a common parameter. Each request has a unique ID. You can use this ID to troubleshoot issues.', example='DE4140C7-F42D-473D-A5FF-B1E31692****'),
}

model OnsConsumerGetConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: OnsConsumerGetConnectionResponseBody(name='body'),
}

/**
  * > : The API operations that are provided by Alibaba Cloud are used to manage and query resources of Alibaba Cloud services. We recommend that you integrate these API operations only in management systems. Do not use these API operations in the core system of messaging services. Otherwise, system risks may occur.
  * When messages are accumulated in a topic, you can call this operation to check whether a consumer is online.
  *
 */
async function onsConsumerGetConnection(request: OnsConsumerGetConnectionRequest): OnsConsumerGetConnectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OnsConsumerGetConnection', 'POST', '/', 'json', false, 'json', request);
}

model OnsConsumerResetOffsetRequest {
  groupId: string(name='GroupId', description='The ID of the consumer group for which you want to reset the consumer offset.', example='GID_test_consumer_id', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance to which the consumer group belongs.', example='MQ_INST_111111111111_DOxxxxxx', position='Query'),
  resetTimestamp?: long(name='ResetTimestamp', description='The timestamp to which you want to reset the consumer offset. This parameter takes effect only when the **Type** parameter is set to **1**. Unit: milliseconds.', example='1591153871000', position='Query'),
  topic: string(name='Topic', description='The name of the topic for which you want to reset the consumer offset.', example='test-mq-topic', position='Query'),
  type: int32(name='Type', description='The method that you want to use to clear accumulated messages. Valid values:

*   **0:** All accumulated messages are cleared. Messages that are not consumed are ignored. Consumers in the specified consumer group consume only messages that are published to the topic after the current point in time.

If "reconsumeLater" is returned, the accumulated messages are not cleared because the system is retrying to send the messages to consumers.

*   **1:** The messages that were published to the topic before a specified point in time are cleared. You must specify a point in time. Consumers in the specified consumer group consume only the messages that are published to the topic after the specified point in time.

You can specify a point in time within the time range that is from the earliest point in time when a message was published to the topic to the most recent point in time when a message was published to the topic. Points in time that are not within the allowed time range are invalid.', example='1', position='Query'),
}

model OnsConsumerResetOffsetResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request. This parameter is a common parameter. Each request has a unique ID. You can use this ID to troubleshoot issues.', example='D52C68F8-EC5D-4294-BFFF-1A6A25AF****'),
}

model OnsConsumerResetOffsetResponse = {
  headers: map[string]string(name='headers'),
  body: OnsConsumerResetOffsetResponseBody(name='body'),
}

/**
  * > : The API operations that are provided by Alibaba Cloud are used to manage and query resources of Alibaba Cloud services. We recommend that you integrate these API operations only in management systems. Do not use these API operations in the core system of messaging services. Otherwise, system risks may occur.
  * You can call this operation to clear accumulated messages or reset the consumption progress. You can use one of the following methods to clear accumulated messages:
  * *   Clear all accumulated messages in a specified topic.
  * *   Clear the messages that were published to the specified topic before a specified point in time.
  *
 */
async function onsConsumerResetOffset(request: OnsConsumerResetOffsetRequest): OnsConsumerResetOffsetResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OnsConsumerResetOffset', 'POST', '/', 'json', false, 'json', request);
}

model OnsConsumerStatusRequest {
  detail?: boolean(name='Detail', description='Specifies whether to query the details of the consumer group. Valid values:

*   **true**: The details of the consumer group are queried. You can obtain details from the **ConsumerConnectionInfoList** and **DetailInTopicList** response parameters.
*   **false**: The details of the consumer group are not queried. The values of the **ConsumerConnectionInfoList** and **DetailInTopicList** response parameters are empty. This value is the default value of the Detail parameter.', example='true', position='Query'),
  groupId: string(name='GroupId', description='The ID of the consumer group whose details you want to query.', example='GID_test_group_id', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance to which the consumer group belongs.', example='MQ_INST_111111111111_DOxxxxxx', position='Query'),
  needJstack?: boolean(name='NeedJstack', description='Specifies whether to query the information about thread stack traces. Valid values:

*   **true**: The information about thread stack traces is queried. You can obtain the information from the **Jstack** response parameter.

>  If you want to obtain the information about thread stack traces, make sure that the **Detail** parameter in the request is set to **true**.

*   **false**: The information about thread stack traces is not queried. The value of the **Jstack** response parameter is empty. This value is the default value of the NeedJstack parameter.', example='true', position='Query'),
}

model OnsConsumerStatusResponseBody = {
  data?: {
    connectionSet?: {
      connectionDo?: [ 
      {
        clientAddr?: string(name='ClientAddr', description='The IP address and port number of the consumer instance.', example='30.5.121.**'),
        clientId?: string(name='ClientId', description='The ID of the consumer instance.', example='30.5.121.**@25560#-1999745829#-1737591554#458773089270275'),
        language?: string(name='Language', description='The programming language that the consumer client supports.', example='JAVA'),
        remoteIP?: string(name='RemoteIP', description='The private or public IP address of the host.', example='42.120.74.**'),
        version?: string(name='Version', description='The version of the consumer client.', example='V4_3_6_SNAPSHOT'),
      }
    ](name='ConnectionDo')
    }(name='ConnectionSet', description='The information about online consumers in the consumer group.'),
    consumeModel?: string(name='ConsumeModel', description='The consumption mode. Valid values:

*   **CLUSTERING:** the clustering consumption mode
*   **BROADCASTING:** the broadcasting consumption mode

For more information about consumption modes, see [Clustering consumption and broadcasting consumption](~~43163~~).', example='CLUSTERING'),
    consumeTps?: float(name='ConsumeTps', description='The TPS for message consumption.', example='0'),
    consumerConnectionInfoList?: {
      consumerConnectionInfoDo?: [ 
      {
        clientId?: string(name='ClientId', description='The ID of the consumer instance.', example='30.5.**.**@25560#-1999745829#-1737591554#458773089270275'),
        connection?: string(name='Connection', description='The connection information.', example='**'),
        consumeModel?: string(name='ConsumeModel', description='The consumption mode. Valid values:

*   **CLUSTERING:** the clustering consumption mode
*   **BROADCASTING:** the broadcasting consumption mode

For more information about consumption modes, see [Clustering consumption and broadcasting consumption](~~43163~~).', example='CLUSTERING'),
        consumeType?: string(name='ConsumeType', description='The mode in which the consumer consumes messages. Valid values:

*   **PUSH:** The Message Queue for Apache RocketMQ broker pushes messages to the consumer.
*   **PULL:** The consumer pulls messages from the Message Queue for Apache RocketMQ broker.', example='PUSH'),
        jstack?: {
          threadTrackDo?: [ 
          {
            thread?: string(name='Thread', description='The name of the thread.', example='ConsumeMessageThread_0'),
            trackList?: {
              track?: [ string ](name='Track')
            }(name='TrackList', description='The details of thread stack traces.'),
          }
        ](name='ThreadTrackDo')
        }(name='Jstack', description='The information about thread stack traces. If you want to obtain the information about thread stack traces, make sure that the **NeedJstack** parameter in the request is set to **true**. If the NeedJstack parameter is not set to true, the value of this parameter is empty.'),
        language?: string(name='Language', description='The programming language that the consumer supports.', example='JAVA'),
        lastTimeStamp?: long(name='LastTimeStamp', description='The most recent point in time when a message was consumed.

The value of this parameter is a UNIX timestamp in milliseconds.', example='1570701368114'),
        runningDataList?: {
          consumerRunningDataDo?: [ 
          {
            failedCountPerHour?: long(name='FailedCountPerHour', description='The number of messages that failed to be consumed each hour.', example='0'),
            failedTps?: float(name='FailedTps', description='The TPS for failed message consumption.', example='0'),
            groupId?: string(name='GroupId', description='The ID of the consumer group.', example='0'),
            okTps?: float(name='OkTps', description='The TPS for successful message consumption.', example='0'),
            rt?: float(name='Rt', description='The consumption RT. Unit: milliseconds.', example='0'),
            topic?: string(name='Topic', description='The name of the topic to which the consumer subscribes.', example='test-mq_topic'),
          }
        ](name='ConsumerRunningDataDo')
        }(name='RunningDataList', description='The real-time statistics.'),
        startTimeStamp?: long(name='StartTimeStamp', description='The earliest point in time when a message was consumed.

The value of this parameter is a UNIX timestamp in milliseconds.', example='1570701361528'),
        subscriptionSet?: {
          subscriptionData?: [ 
          {
            subString?: string(name='SubString', description='The expression that is used to specify the tags of messages in the subscribed topic.', example='*'),
            subVersion?: long(name='SubVersion', description='The subscription version. The value is of the LONG type and is automatically incremented.', example='1570701364301'),
            tagsSet?: {
              tag?: [ string ](name='Tag')
            }(name='TagsSet', description='The information about the tags of the topic to which the consumer subscribes.'),
            topic?: string(name='Topic', description='The name of the topic to which the consumer subscribes.', example='test-mq_topic'),
          }
        ](name='SubscriptionData')
        }(name='SubscriptionSet', description='The information about subscriptions.'),
        threadCount?: int32(name='ThreadCount', description='The number of consumer threads.', example='20'),
        version?: string(name='Version', description='The version of the consumer client.', example='V4_3_6'),
      }
    ](name='ConsumerConnectionInfoDo')
    }(name='ConsumerConnectionInfoList', description='The details of online consumers in the consumer group, including the information about the thread stack traces and the consumption response time (RT). If you want to obtain the details of online consumers in the consumer group, make sure that the **Detail** parameter in the request is set to **true**. If the Detail parameter is not set to true, the value of this parameter is empty.'),
    delayTime?: long(name='DelayTime', description='The maximum latency of message consumption in all topics to which the consumer group subscribe. Unit: milliseconds.', example='100857'),
    detailInTopicList?: {
      detailInTopicDo?: [ 
      {
        delayTime?: long(name='DelayTime', description='The latency of message consumption in the topic. Unit: milliseconds.', example='0'),
        lastTimestamp?: long(name='LastTimestamp', description='The most recent point in time when a message was consumed.

The value of this parameter is a UNIX timestamp in milliseconds.', example='1570701259403'),
        topic?: string(name='Topic', description='The name of the topic.', example='test-mq_topic'),
        totalDiff?: long(name='TotalDiff', description='The number of accumulated messages in the topic.', example='0'),
      }
    ](name='DetailInTopicDo')
    }(name='DetailInTopicList', description='The information about message consumption by topic. If you want to obtain the information about the consumption status of each topic, make sure that the **Detail** parameter in the request is set to **true**. If the Detail parameter is not set to true, the value of this parameter is empty.'),
    instanceId?: string(name='InstanceId', description='The ID of the instance.', example='MQ_INST_111111111111_DOxxxxxx'),
    lastTimestamp?: long(name='LastTimestamp', description='The most recent point in time when a message was consumed.

The value of this parameter is a UNIX timestamp in milliseconds.', example='1566883844954'),
    online?: boolean(name='Online', description='Indicates whether the consumer group is online.', example='true'),
    rebalanceOK?: boolean(name='RebalanceOK', description='Indicates whether load balancing is performed as expected. Valid values:

*   **true:** Load balancing is performed as expected.
*   **false:** Load balancing is not performed as expected.', example='true'),
    subscriptionSame?: boolean(name='SubscriptionSame', description='Indicates whether all consumers in the consumer group subscribe to the same topics and tags.', example='true'),
    totalDiff?: long(name='TotalDiff', description='The total number of accumulated messages.', example='197'),
  }(name='Data', description='The query results.'),
  requestId?: string(name='RequestId', description='The ID of the request. This parameter is a common parameter. Each request has a unique ID. You can use this ID to troubleshoot issues.', example='10EDC518-10E7-4B34-92FB-171235FA****'),
}

model OnsConsumerStatusResponse = {
  headers: map[string]string(name='headers'),
  body: OnsConsumerStatusResponseBody(name='body'),
}

/**
  * > : The API operations that are provided by Alibaba Cloud are used to manage and query resources of Alibaba Cloud services. We recommend that you integrate these API operations only in management systems. Do not use these API operations in the core system of messaging services. Otherwise, system risks may occur.
  * *   You can call this operation in scenarios in which consumers are online and messages are accumulated. You can troubleshoot errors based on the information that is returned by this operation. You can check whether all consumers in the consumer group subscribe to the same topics and tags, and whether load balancing is performed as expected. You can also obtain the information about thread stack traces of online consumers.
  * *   This operation uses multiple backend operations to query and aggregate data. The system requires a long period of time to process a request. We recommend that you do not frequently call this operation.
  *
 */
async function onsConsumerStatus(request: OnsConsumerStatusRequest): OnsConsumerStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OnsConsumerStatus', 'POST', '/', 'json', false, 'json', request);
}

model OnsConsumerTimeSpanRequest {
  groupId: string(name='GroupId', description='The ID of the consumer group whose reset time range you want to query.', example='GID_test_group_id', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance to which the consumer group belongs.', example='MQ_INST_111111111111_DOxxxxxx', position='Query'),
  topic: string(name='Topic', description='The topic to which the consumer group subscribes.', example='test-mq_topic', position='Query'),
}

model OnsConsumerTimeSpanResponseBody = {
  data?: {
    consumeTimeStamp?: long(name='ConsumeTimeStamp', description='The most recent point in time when a message in the topic was consumed by the customer group.', example='1570761026400'),
    instanceId?: string(name='InstanceId', description='The ID of the instance to which the consumer group belongs.', example='MQ_INST_111111111111_DOxxxxxx'),
    maxTimeStamp?: long(name='MaxTimeStamp', description='The earliest point in time when a message was published to the topic.', example='1570761026804'),
    minTimeStamp?: long(name='MinTimeStamp', description='The most recent point in time when a message was published to the topic.', example='1570701231122'),
    topic?: string(name='Topic', description='The name of the topic that you want to query.', example='test-mq_topic'),
  }(name='Data', description='The query results.'),
  requestId?: string(name='RequestId', description='The ID of the request. This parameter is a common parameter. Each request has a unique ID. You can use this ID to troubleshoot issues.', example='A07E3902-B92E-44A6-B6C5-6AA111111****'),
}

model OnsConsumerTimeSpanResponse = {
  headers: map[string]string(name='headers'),
  body: OnsConsumerTimeSpanResponseBody(name='body'),
}

/**
  * > : The API operations that are provided by Alibaba Cloud are used to manage and query resources of Alibaba Cloud services. We recommend that you integrate these API operations only in management systems. Do not use these API operations in the core system of messaging services. Otherwise, system risks may occur.
  * You can call this operation to query the earliest point in time when a message was published to a specified topic and the most recent point in time when a message was published to the specified topic. You can also obtain the most recent point in time when a message in the topic was consumed. This operation is usually used with the \\*\\*OnsConsumerAccumulate\\*\\* operation to display the overview of the consumption progress.
  *
 */
async function onsConsumerTimeSpan(request: OnsConsumerTimeSpanRequest): OnsConsumerTimeSpanResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OnsConsumerTimeSpan', 'POST', '/', 'json', false, 'json', request);
}

model OnsDLQMessageGetByIdRequest {
  groupId: string(name='GroupId', description='The ID of the consumer group whose dead-letter messages you want to query.', example='GID_test_group_id', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance to which the message you want to query belongs.', example='MQ_INST_111111111111_DOxxxxxx', position='Query'),
  msgId: string(name='MsgId', description='The ID of the dead-letter message that you want to query.', example='0BC16699165C03B925DB8A404E2D****', position='Query'),
}

model OnsDLQMessageGetByIdResponseBody = {
  data?: {
    bodyCRC?: int32(name='BodyCRC', description='The cyclic redundancy check (CRC) value of the message body.', example='914112295'),
    bornHost?: string(name='BornHost', description='The producer instance that generated the message.', example='42.120.**.**:64646'),
    bornTimestamp?: long(name='BornTimestamp', description='The timestamp that indicates the point in time when the dead-letter message was generated. Unit: milliseconds.', example='1570761026630'),
    instanceId?: string(name='InstanceId', description='The ID of the instance.', example='MQ_INST_111111111111_DOxxxxxx'),
    msgId?: string(name='MsgId', description='The ID of the dead-letter message.', example='0BC16699165C03B925DB8A404E2D****'),
    propertyList?: {
      messageProperty?: [ 
      {
        name?: string(name='Name', description='The name of the attribute. Valid values:

*   **TRACE_ON**: indicates whether a trace of the message exists.
*   **KEYS**: indicates the message key of the message.
*   **TAGS**: indicates the tag that is attached to the message.
*   **INSTANCE_ID**: indicates the ID of the instance that contains the dead-letter message.

For more information about the terms that are used in Message Queue for Apache RocketMQ, see [Terms](~~29533~~).', example='TAGS'),
        value?: string(name='Value', description='The value of the attribute.', example='TagA'),
      }
    ](name='MessageProperty')
    }(name='PropertyList', description='The attributes of the message.'),
    reconsumeTimes?: int32(name='ReconsumeTimes', description='The number of retries that Message Queue for Apache RocketMQ performed to send the message to consumers.', example='1'),
    storeHost?: string(name='StoreHost', description='The Message Queue for Apache RocketMQ broker that stores the message.', example='11.220.***.***:10911'),
    storeSize?: int32(name='StoreSize', description='The size of the message. Unit: KB.', example='407'),
    storeTimestamp?: long(name='StoreTimestamp', description='The timestamp when the Message Queue for Apache RocketMQ broker stored the message. Unit: milliseconds.', example='1570761026708'),
    topic?: string(name='Topic', description='The topic to which the message belongs.', example='test-mq_topic'),
  }(name='Data', description='The returned results.'),
  requestId?: string(name='RequestId', description='The ID of the request. This parameter is a common parameter. Each request has a unique ID.', example='A07E3902-B92E-44A6-B6C5-6AA111111****'),
}

model OnsDLQMessageGetByIdResponse = {
  headers: map[string]string(name='headers'),
  body: OnsDLQMessageGetByIdResponseBody(name='body'),
}

/**
  * > : The API operations that are provided by Alibaba Cloud are used to manage and query resources of Alibaba Cloud services. We recommend that you integrate these API operations only in management systems. Do not use these API operations in the core system of messaging services. Otherwise, system risks may occur.
  * This operation uses the exact match method to query a dead-letter message based on the message ID. You can obtain the message ID that is required to query the information about a dead-letter message from the SendResult parameter that is returned after the message is sent. You can also obtain the message ID by calling the OnsDLQMessagePageQueryByGroupId operation to query multiple messages at a time. The queried information about the dead-letter message includes the point in time when the message is stored, the message body, and attributes such as the message tag and the message key.
  *
 */
async function onsDLQMessageGetById(request: OnsDLQMessageGetByIdRequest): OnsDLQMessageGetByIdResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OnsDLQMessageGetById', 'POST', '/', 'json', false, 'json', request);
}

model OnsDLQMessagePageQueryByGroupIdRequest {
  beginTime: long(name='BeginTime', description='The beginning of the time range to query. The value of this parameter is a UNIX timestamp in milliseconds. If you specify a valid value for the **TaskId** parameter in the request, this parameter does not take effect. The system uses the value of the BeginTime parameter that you specified in the request when you created the specified query task.', example='1570723200000', position='Query'),
  currentPage: int32(name='CurrentPage', description='The number of the page to return. Pages start from page 1. Valid values: 1 to 50.', example='2', position='Query'),
  endTime: long(name='EndTime', description='The end of the time range to query. The value of this parameter is a UNIX timestamp in milliseconds. If you specify a valid value for the **TaskId** parameter in the request, this parameter does not take effect. The system uses the value of the EndTime parameter that you specified in the request when you created the specified query task.', example='1570809600000', position='Query'),
  groupId: string(name='GroupId', description='The ID of the consumer group whose dead-letter messages you want to query.', example='GID_test_group_id', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance to which the dead-letter messages you want to query belong.', example='MQ_INST_111111111111_DOxxxxxx', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of dead-letter messages to return on each page. Valid values: 5 to 50. Default value: 20. If you specify a valid value for the **TaskId** parameter in the request, this parameter does not take effect. The system uses the value of the PageSize parameter that you specified in the request when you created the specified query task.', example='5', position='Query'),
  taskId?: string(name='TaskId', description='The ID of the query task. The first time you call this operation to query dead-letter messages that are sent to a specified consumer group within a specified time range, this parameter is not required. This parameter is required in subsequent queries for dead-letter messages on a specified page. You can obtain the task ID from the returned result of the first query.', example='0BC1310300002A9F000021E4D7A48346', position='Query'),
}

model OnsDLQMessagePageQueryByGroupIdResponseBody = {
  msgFoundDo?: {
    currentPage?: long(name='CurrentPage', description='The page number of the returned page.', example='1'),
    maxPageCount?: long(name='MaxPageCount', description='The total number of returned pages.', example='400'),
    msgFoundList?: {
      onsRestMessageDo?: [ 
      {
        bodyCRC?: int32(name='BodyCRC', description='The cyclic redundancy check (CRC) value of the message body.', example='914112295'),
        bornHost?: string(name='BornHost', description='The producer instance that generated the message.', example='42.120.***.***:59270'),
        bornTimestamp?: long(name='BornTimestamp', description='The timestamp when the message was produced.', example='1570760999721'),
        instanceId?: string(name='InstanceId', description='The ID of the instance.', example='MQ_INST_111111111111_DOxxxxxx'),
        msgId?: string(name='MsgId', description='The ID of the message.', example='1E0578FE110F18B4AAC235C05F2*****'),
        propertyList?: {
          messageProperty?: [ 
          {
            name?: string(name='Name', description='The name of the attribute. Valid values:

*   **TRACE_ON**: indicates whether a trace of the message exists.
*   **KEYS**: indicates the message key of the message.
*   **TAGS**: indicates the tag of the message.
*   **INSTANCE_ID**: indicates the ID of the instance that contains the message.

For more information about the terms that are used in Message Queue for Apache RocketMQ, see [Terms](~~29533~~).', example='TAGS'),
            value?: string(name='Value', description='The value of the attribute.', example='TagA'),
          }
        ](name='MessageProperty')
        }(name='PropertyList', description='The attributes of the message.'),
        reconsumeTimes?: int32(name='ReconsumeTimes', description='The number of retries that Message Queue for Apache RocketMQ performed to send the message to consumers.', example='1'),
        storeHost?: string(name='StoreHost', description='The Message Queue for Apache RocketMQ broker that stores the message.', example='11.193.***.***:10911'),
        storeSize?: int32(name='StoreSize', description='The size of the message. Unit: KB.', example='406'),
        storeTimestamp?: long(name='StoreTimestamp', description='The timestamp when the Message Queue for Apache RocketMQ broker stored the message.', example='1570760999811'),
        topic?: string(name='Topic', description='The topic to which the message belongs.', example='test-mq_topic'),
      }
    ](name='OnsRestMessageDo')
    }(name='MsgFoundList', description='The information about dead-letter messages that are returned on the current page. The information that is contained in this parameter is the same as the information that is returned by the [OnsDLQMessageGetById](~~112667~~) operation.'),
    taskId?: string(name='TaskId', description='The ID of the query task. The first time you call this operation to query the dead-letter messages that are sent to a specified consumer group within a specified time range, this parameter is returned. You can use the task ID to query the details of dead-letter messages on other returned pages.', example='0BC1310300002A9F000021E4D7A48346'),
  }(name='MsgFoundDo', description='The returned results.'),
  requestId?: string(name='RequestId', description='The ID of the request. This parameter is a common parameter. Each request has a unique ID. You can use this ID to troubleshoot issues.', example='B00CD3C8-D81E-4A41-85E2-38F19252****'),
}

model OnsDLQMessagePageQueryByGroupIdResponse = {
  headers: map[string]string(name='headers'),
  body: OnsDLQMessagePageQueryByGroupIdResponseBody(name='body'),
}

/**
  * > : The API operations that are provided by Alibaba Cloud are used to manage and query resources of Alibaba Cloud services. We recommend that you integrate these API operations only in management systems. Do not use these API operations in the core system of messaging services. Otherwise, system risks may occur.
  * *   If you do not know the ID of the dead-letter message that you want to query, you can call this operation to query all dead-letter messages that are sent to a specified consumer group within a specified time range. The results are returned by page.
  * *   We recommend that you specify a short time range to query dead-letter messages in this method. If you specify a long time range, a large number of dead-letter messages are returned. In this case, you cannot find the dead-letter message that you want to query in an efficient manner. You can perform the following steps to query dead-letter messages:
  *     1.  Perform a paged query by specifying the group ID, start time, end time, and number of entries to return on each page. If matched messages are found, the information about the dead-letter messages on the first page, total number of pages, and task ID are returned by default.
  *     2.  Specify the task ID and a page number to call this operation again to query the dead-letter messages on the specified page. In this query, the BeginTime, EndTime, and PageSize parameters do not take effect. By default, the system uses the values of these parameters that you specified in the request when you created the specified query task.
  *
 */
async function onsDLQMessagePageQueryByGroupId(request: OnsDLQMessagePageQueryByGroupIdRequest): OnsDLQMessagePageQueryByGroupIdResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OnsDLQMessagePageQueryByGroupId', 'POST', '/', 'json', false, 'json', request);
}

model OnsDLQMessageResendByIdRequest {
  groupId: string(name='GroupId', description='The ID of the consumer group whose dead-letter messages you want to query.', example='GID_test_group_id', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance to which the message you want to query belongs.', example='MQ_INST_188077086902****_BXSuW61e', position='Query'),
  msgId: string(name='MsgId', description='The ID of the dead-letter message that you want to query.', example='0BC16699343051CD9F1D798E7734****', position='Query'),
}

model OnsDLQMessageResendByIdResponseBody = {
  data?: {
    msgId?: [ string ](name='MsgId')
  }(name='Data', description='The returned messages.'),
  requestId?: string(name='RequestId', description='The ID of the request. This parameter is a common parameter. Each request has a unique ID. You can use this ID to troubleshoot issues.', example='D94CC769-4DC3-4690-A868-9D0631B1****'),
}

model OnsDLQMessageResendByIdResponse = {
  headers: map[string]string(name='headers'),
  body: OnsDLQMessageResendByIdResponseBody(name='body'),
}

/**
  * > : The API operations that are provided by Alibaba Cloud are used to manage and query resources of Alibaba Cloud services. We recommend that you integrate these API operations only in management systems. Do not use these API operations in the core system of messaging services. Otherwise, system risks may occur.
  * *   After the number of retries to send a message to a consumer group for consumption reaches the upper limit and the message is not consumed by a consumer in the group, the message is added to the dead-letter queue of the consumer group. The message is a dead-letter message. After you resend the dead-letter message to the consumer group for consumption and the message fails to be consumed again after the maximum number of retries, a dead-letter message with the same message ID is added to the dead-letter queue. You can view the details of the dead-letter message on the Dead-letter Queues page in the Message Queue for Apache RocketMQ console or by calling the API operations that are used to query dead-letter messages. You can obtain the number of consumption failures for a message based on the number of dead-letter messages with the same message ID in the dead-letter queue.
  * *   A dead-letter message is a message that fails to be consumed after the number of consumption retries reaches the upper limit. Generally, dead-letter messages are produced because of incorrect consumption logic. We recommend that you troubleshoot the consumption failures and then call this operation to send the message to the consumer group for consumption again.
  * *   Message Queue for Apache RocketMQ does not manage the status of dead-letter messages based on the consumption status of the dead-letter messages. After you call this operation to send a dead-letter message to a consumer group and the message is consumed, Message Queue for Apache RocketMQ does not remove the dead-letter message from the dead-letter queue. You must manage dead-letter messages and determine whether to send a dead-letter message to a consumer group for consumption. This way, you do not resend and reconsume the messages that are consumed.
  *
 */
async function onsDLQMessageResendById(request: OnsDLQMessageResendByIdRequest): OnsDLQMessageResendByIdResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OnsDLQMessageResendById', 'POST', '/', 'json', false, 'json', request);
}

model OnsGroupConsumerUpdateRequest {
  groupId: string(name='GroupId', description='The ID of the consumer group for which you want to configure the read permissions.', example='GID_test_groupId', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance to which the consumer group you want to configure belongs.', example='MQ_INST_111111111111_DOxxxxxx', position='Query'),
  readEnable: boolean(name='ReadEnable', description='Specifies whether to authorize the consumer group with the specified ID to read messages. Valid values:

*   **true**: Authorize the consumer group with the specified ID to read messages.
*   **false**: Do not authorize the consumer group with the specified group ID to read messages.

Default value: **true**.', example='true', position='Query'),
}

model OnsGroupConsumerUpdateResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request. This parameter is a common parameter. Each request has a unique ID. You can use this ID to troubleshoot issues.', example='A07E3902-B92E-44A6-B6C5-6AA111111****'),
}

model OnsGroupConsumerUpdateResponse = {
  headers: map[string]string(name='headers'),
  body: OnsGroupConsumerUpdateResponseBody(name='body'),
}

/**
  * > : The API operations that are provided by Alibaba Cloud are used to manage and query resources of Alibaba Cloud services. We recommend that you integrate these API operations only in management systems. Do not use these API operations in the core system of messaging services. Otherwise, system risks may occur.
  * You can call this operation to configure the permissions for a consumer group to read messages based on a specified region of Message Queue for Apache RocketMQ and a specified group ID. You can call this operation in scenarios in which you want to forbid consumers in a specific group from reading messages.
  *
 */
async function onsGroupConsumerUpdate(request: OnsGroupConsumerUpdateRequest): OnsGroupConsumerUpdateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OnsGroupConsumerUpdate', 'POST', '/', 'json', false, 'json', request);
}

model OnsGroupCreateRequest {
  groupId: string(name='GroupId', description='The ID of the consumer group that you want to create. Specify the group ID based on the following rules:

*   The group ID must be 2 to 64 characters in length and can contain only letters, digits, hyphens (-), and underscores (\\_).
*   If the Message Queue for Apache RocketMQ instance in which you want to create the consumer group uses a namespace, the group ID must be unique in the instance. The group ID cannot be the same as an existing group ID or a topic name in the instance. The group ID can be the same as a group ID or a topic name in another instance that uses a different namespace. For example, if Instance A and Instance B use different namespaces, a group ID in Instance A can be the same as a group ID or a topic name in Instance B.
*   If the instance does not use a namespace, the group ID must be globally unique across instances and regions. The group ID cannot be the same as an existing group ID or topic name in Message Queue for Apache RocketMQ instances that belong to your Alibaba Cloud account.

> 

*   After the consumer group is created, the group ID cannot be changed.

*   To check whether an instance uses a namespace, log on to the Message Queue for Apache RocketMQ console, go to the **Instance Details** page, and then view the value of the Namespace field in the **Basic Information** section.', example='GID_test_groupId', position='Query'),
  groupType?: string(name='GroupType', description='The protocol over which clients in the consumer group communicate with the Message Queue for Apache RocketMQ broker. All clients in a consumer group communicate with the Message Queue for Apache RocketMQ broker over the same protocol. You must create different groups for TCP clients and HTTP clients. Valid values:

*   **tcp**: Clients in the consumer group consume messages over TCP. This is the default value.
*   **http**: Clients in the consumer group consume messages over HTTP.', example='tcp', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance in which you want to create the consumer group.', example='MQ_INST_111111111111_DOxxxxxx', position='Query'),
  remark?: string(name='Remark', description='The description of the consumer group.', example='test', position='Query'),
}

model OnsGroupCreateResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request. This parameter is a common parameter. Each request has a unique ID. You can use this ID to troubleshoot issues.', example='A07E3902-B92E-44A6-B6C5-6AA111111****'),
}

model OnsGroupCreateResponse = {
  headers: map[string]string(name='headers'),
  body: OnsGroupCreateResponseBody(name='body'),
}

/**
  * > : The API operations that are provided by Alibaba Cloud are used to manage and query resources of Alibaba Cloud services. We recommend that you integrate these API operations only in management systems. Do not use these API operations in the core system of messaging services. Otherwise, system risks may occur.
  * When you release a new application or implement new business logic, you need new consumer groups. You can call this operation to create a consumer group.
  *
 */
async function onsGroupCreate(request: OnsGroupCreateRequest): OnsGroupCreateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OnsGroupCreate', 'POST', '/', 'json', false, 'json', request);
}

model OnsGroupDeleteRequest {
  groupId: string(name='GroupId', description='The ID of the consumer group that you want to delete.', example='GID_test_groupId', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the Message Queue for Apache RocketMQ instance that contains the specified group.', example='MQ_INST_111111111111_DOxxxxxx', position='Query'),
}

model OnsGroupDeleteResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request. This parameter is a common parameter. Each request has a unique ID. You can use this ID to troubleshoot issues.', example='A07E3902-B92E-44A6-B6C5-6AA111111****'),
}

model OnsGroupDeleteResponse = {
  headers: map[string]string(name='headers'),
  body: OnsGroupDeleteResponseBody(name='body'),
}

/**
  * > 
  * *   The API operations that are provided by Alibaba Cloud are used to manage and query resources of Alibaba Cloud services. We recommend that you integrate these API operations only in management systems. Do not use these API operations in the core system of messaging services. Otherwise, system risks may occur.
  * *   After you delete a group, the consumers in the group immediately stop receiving messages. Exercise caution when you call this operation.
  * You can call this operation to delete a group when you need to deallocate the resources of the group. For example, after an application is brought offline, you can delete the groups that are used for the application. After you delete a group, the backend of Message Queue for Apache RocketMQ deallocates the resources of the group. The system requires a long period of time to deallocate the resources. We recommend that you do not create a group that uses the same name as a deleted group immediately after you delete the group. If the system fails to delete the specified group, troubleshoot the issue based on the error code.
  *
 */
async function onsGroupDelete(request: OnsGroupDeleteRequest): OnsGroupDeleteResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OnsGroupDelete', 'POST', '/', 'json', false, 'json', request);
}

model OnsGroupListRequest {
  groupId?: string(name='GroupId', description='This parameter is required only when you query specific consumer groups by using the fuzzy query method. If this parameter is not configured, the system queries all consumer groups that can be accessed by the current account.

If you set this parameter to GID_ABC, the information about the consumer groups whose IDs contain GID_ABC is returned. For example, the information about the GID_test_GID_ABC\\_123 and GID_ABC\\_356 consumer groups is returned.', example='GID_test_group_id', position='Query'),
  groupType?: string(name='GroupType', description='The protocol over which the queried consumer groups consume messages. All clients in a consumer group communicate with the Message Queue for Apache RocketMQ broker over the same protocol. A consumer group cannot contain TCP clients and HTTP clients at the same time. You must create different consumer groups for TCP clients and HTTP clients. Valid values:

*   **tcp**: specifies the consumer groups that consume messages over TCP. This is the default value.
*   **http**: indicates that the consumer group consumes messages over HTTP.', example='tcp', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance to which the consumer group you want to query belongs.', example='MQ_INST_111111111111_DOxxxxxx', position='Query'),
  tag?: [ 
    {
      key: string(name='Key', description='The key of a tag that is attached to the consumer group. This parameter is not required. If you configure this parameter, you must configure the **Tag.N.Value** parameter.**** If you configure both the Tag.N.Key and Tag.N.Value parameters, the group IDs are filtered based on the specified tag. If you do not configure these parameters, all group IDs are queried.

*   The value of this parameter cannot be an empty string.
*   The tag key can be up to 128 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.', example='CartService'),
      value: string(name='Value', description='The value of the tag that is attached to the group. This parameter is not required. If you configure this parameter, you must configure the **Tag.N.Value** parameter.**** If you configure both the Tag.N.Key and Tag.N.Value parameters, the group IDs are filtered based on the specified tag. If you do not configure these parameters, all group IDs are queried.

*   The value of this parameter can be an empty string.
*   The tag key can be up to 128 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.', example='ServiceA'),
    }
  ](name='Tag', description='The list of tags that are attached to the consumer group. A maximum of 20 tags can be included in the list.', position='Query'),
}

model OnsGroupListResponseBody = {
  data?: {
    subscribeInfoDo?: [ 
    {
      createTime?: long(name='CreateTime', description='The time when the group was created.', example='1568896605000'),
      groupId?: string(name='GroupId', description='The ID of the consumer group.', example='GID_test_group_id'),
      groupType?: string(name='GroupType', description='The protocol over which the queried consumer groups consume messages. All clients in a consumer group communicate with the Message Queue for Apache RocketMQ broker over the same protocol. A consumer group cannot contain TCP clients and HTTP clients at the same time. You must create different consumer groups for TCP clients and HTTP clients. Valid values:

*   **tcp**: indicates that the consumer group consumes messages over TCP.
*   **http**: indicates that the consumer group consumes messages over HTTP.', example='tcp'),
      independentNaming?: boolean(name='IndependentNaming', description='Indicates whether the instance uses a namespace. Valid values:

*   **true**: The instance uses a separate namespace. The name of each resource must be unique in the instance. The names of resources in different instances can be the same.
*   **false**: The instance does not use a separate namespace. The name of each resource must be globally unique within and across all instances.', example='true'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.', example='MQ_INST_111111111111_DOxxxxxx'),
      owner?: string(name='Owner', description='The ID of the user who created the consumer group.', example='138015630679****'),
      remark?: string(name='Remark', description='The description of the consumer group.', example='test'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key', description='The key of the tag.', example='CartService'),
          value?: string(name='Value', description='The value of the tag.', example='ServiceA'),
        }
      ](name='Tag')
      }(name='Tags', description='The tags that are attached to the consumer group.'),
      updateTime?: long(name='UpdateTime', description='The time when the group ID was updated.', example='1570700979000'),
    }
  ](name='SubscribeInfoDo')
  }(name='Data', description='The returned list of subscriptions.'),
  requestId?: string(name='RequestId', description='The ID of the request. This parameter is a common parameter. Each request has a unique ID. You can use this ID to troubleshoot issues.', example='16996623-AC4A-43AF-9248-FD9D2D75****'),
}

model OnsGroupListResponse = {
  headers: map[string]string(name='headers'),
  body: OnsGroupListResponseBody(name='body'),
}

/**
  * > : The API operations that are provided by Alibaba Cloud are used to manage and query resources of Alibaba Cloud services. We recommend that you integrate these API operations only in management systems. Do not use these API operations in the core system of messaging services. Otherwise, system risks may occur.
  *
 */
async function onsGroupList(request: OnsGroupListRequest): OnsGroupListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OnsGroupList', 'POST', '/', 'json', false, 'json', request);
}

model OnsGroupSubDetailRequest {
  groupId: string(name='GroupId', description='The ID of the consumer group that you want to query.', example='GID_test_group_id', position='Query'),
  instanceId: string(name='InstanceId', description='The ID of the instance to which the consumer group you want to query belongs.', example='MQ_INST_111111111111_DOxxxxxx', position='Query'),
}

model OnsGroupSubDetailResponseBody = {
  data?: {
    groupId?: string(name='GroupId', description='The ID of the consumer group that you want to query.', example='GID_test_group_id'),
    messageModel?: string(name='MessageModel', description='The consumption mode. Valid values:

*   **CLUSTERING**: the clustering consumption mode
*   **BROADCASTING**: the broadcasting consumption mode

For more information about consumption modes, see [Clustering consumption and broadcasting consumption](~~43163~~).', example='CLUSTERING'),
    online?: boolean(name='Online', description='Indicates whether consumers in the group are online.', example='true'),
    subscriptionDataList?: {
      subscriptionDataList?: [ 
      {
        subString?: string(name='SubString', description='The expression based on which consumers in the consumer group subscribe to the topic.', example='*'),
        topic?: string(name='Topic', description='The name of the topic to which consumers in the consumer group subscribe.', example='test-mq_topic'),
      }
    ](name='SubscriptionDataList')
    }(name='SubscriptionDataList', description='The topics to which consumers in the consumer group subscribe. If all consumers in the specified group are offline, no topics are returned.'),
  }(name='Data', description='The data that is returned.'),
  requestId?: string(name='RequestId', description='The ID of the request. This parameter is a common parameter. Each request has a unique ID. You can use this ID to troubleshoot issues.', example='3364E875-013B-442A-BC3C-C1A84DC6****'),
}

model OnsGroupSubDetailResponse = {
  headers: map[string]string(name='headers'),
  body: OnsGroupSubDetailResponseBody(name='body'),
}

/**
  * > : The API operations that are provided by Alibaba Cloud are used to manage and query resources of Alibaba Cloud services. We recommend that you integrate these API operations only in management systems. Do not use these API operations in the core system of messaging services. Otherwise, system risks may occur.
  *
 */
async function onsGroupSubDetail(request: OnsGroupSubDetailRequest): OnsGroupSubDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OnsGroupSubDetail', 'POST', '/', 'json', false, 'json', request);
}

model OnsInstanceBaseInfoRequest {
  instanceId: string(name='InstanceId', description='The ID of the instance that you want to query.', example='MQ_INST_138015630679****_BAAy1Hac', position='Query'),
}

model OnsInstanceBaseInfoResponseBody = {
  instanceBaseInfo?: {
    createTime?: string(name='CreateTime', example='1570701259403'),
    endpoints?: {
      httpInternalEndpoint?: string(name='HttpInternalEndpoint', description='The private HTTP endpoint of the instance.', example='http://138015630679****.mqrest.cn-chengdu-internal.aliyuncs.com'),
      httpInternetEndpoint?: string(name='HttpInternetEndpoint', description='The public HTTP endpoint of the instance.', example='http://138015630679****.mqrest.cn-chengdu.aliyuncs.com'),
      httpInternetSecureEndpoint?: string(name='HttpInternetSecureEndpoint', description='The public HTTPS endpoint of the instance.', example='https://138015630679****.mqrest.cn-chengdu.aliyuncs.com'),
      tcpEndpoint?: string(name='TcpEndpoint', description='The private TCP endpoint of the instance.', example='http://MQ_INST_138015630679****_BAAy1Hac.cn-chengdu.mq-internal.aliyuncs.com:8080'),
      tcpInternetEndpoint?: string(name='TcpInternetEndpoint', description='The public TCP endpoint of the instance.

*   Only instances that are deployed in the China (Chengdu), China (Qingdao), or China (Shenzhen) region can be accessed by using public TCP endpoints.

*   Before you use a public TCP endpoint, make sure that your client SDK meets the following requirements:

    *   TCP client SDK for Java: V2.0.0.Final or later For more information, see [Release notes for the SDK for Java](~~325569~~).
    *   TCP client SDK for C++: V3.0.0 or later For more information, see [Release notes for the SDK for C++](~~325570~~).

*   You must pay the data transfer cost when you use a public TCP endpoint. For more information, see [Internet traffic fee](~~325571~~).', example='http://MQ_INST_138015630679****_BAAy1Hac.mq.cn-chengdu.aliyuncs.com:80'),
    }(name='Endpoints', description='The endpoints that correspond to different protocols.'),
    independentNaming?: boolean(name='IndependentNaming', description='Indicates whether the instance uses a namespace. Valid values:

*   **true**: The instance uses a separate namespace. The name of each resource must be unique in the instance. The names of resources in different instances can be the same.
*   **false**: The instance does not use a separate namespace. The name of each resource must be globally unique within and across all instances.', example='true'),
    instanceId?: string(name='InstanceId', description='The ID of the instance.', example='MQ_INST_138015630679****_BAAy1Hac'),
    instanceName?: string(name='InstanceName', description='The name of the instance.

The name must be 3 to 64 characters in length and can contain letters, digits, hyphens (-), and underscores (\\_).', example='test'),
    instanceStatus?: int32(name='InstanceStatus', description='The status of the instance. Valid values:

*   **0**: The instance is being deployed. This value is valid only for Enterprise Platinum Edition instances.
*   **2**: The instance has overdue payments. This value is valid only for Standard Edition instances.
*   **5**: The instance is running. This value is valid for Standard Edition instances and Enterprise Platinum Edition instances.
*   **7**: The instance is being upgraded and is running. This value is valid only for Enterprise Platinum Edition instances.', example='5'),
    instanceType?: int32(name='InstanceType', description='The instance type. Valid values:

*   **1**: The instance is a Standard Edition instance that uses the pay-as-you-go billing method.
*   **2**: The instance is an Enterprise Platinum Edition instance that uses the subscription billing method.

For information about the editions and specifications of Message Queue for Apache RocketMQ instances, see [Instance editions](~~185261~~).', example='2'),
    maxTps?: long(name='MaxTps', description='The maximum transactions per second (TPS) for sending and receiving messages. Valid values: 5000, 10000, 20000, 50000, 100000, 200000, 300000, 500000, 800000, and 1000000.

For more information, see the description on the buy page.

>  This parameter is available only for Message Queue for Apache RocketMQ instances of the Enterprise Platinum Edition.', example='10000'),
    releaseTime?: long(name='ReleaseTime', description='The point in time when the Enterprise Platinum Edition instance expires.', example='1603555200000'),
    remark?: string(name='Remark', description='The description of the instance.', example='onspre-cn-m7r1r5f****'),
    topicCapacity?: int32(name='TopicCapacity', description='The maximum number of topics that can be created on the instance. Valid values: 25, 50, 100, 300, and 500.

>  This parameter is available only for Message Queue for Apache RocketMQ instances of the Enterprise Platinum Edition.', example='50'),
    spInstanceId?: string(name='spInstanceId', example='ons-cn-m7r1r5f****'),
    spInstanceType?: int32(name='spInstanceType', example='1'),
  }(name='InstanceBaseInfo', description='The information about the instance.'),
  requestId?: string(name='RequestId', description='The ID of the request. This parameter is a common parameter. Each request has a unique ID. You can use this ID to troubleshoot issues.', example='6CC46974-65E8-4C20-AB07-D20D102E****'),
}

model OnsInstanceBaseInfoResponse = {
  headers: map[string]string(name='headers'),
  body: OnsInstanceBaseInfoResponseBody(name='body'),
}

/**
  * > : The API operations that are provided by Alibaba Cloud are used to manage and query resources of Alibaba Cloud services. We recommend that you integrate these API operations only in management systems. Do not use these API operations in the core system of messaging services. Otherwise, system risks may occur.
  * To send and receive messages, a client must be connected to a Message Queue for Apache RocketMQ instance by using an endpoint. You can call this operation to query the endpoints of the instance.
  *
 */
async function onsInstanceBaseInfo(request: OnsInstanceBaseInfoRequest): OnsInstanceBaseInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OnsInstanceBaseInfo', 'POST', '/', 'json', false, 'json', request);
}

model OnsInstanceCreateRequest {
  instanceName: string(name='InstanceName', description='The name of the instance. Valid values:

*   The name of the instance must be unique in the region where the instance is deployed.
*   The name must be 3 to 64 characters in length and can contain letters, digits, hyphens (-), and underscores (\\_).', example='Test', position='Query'),
  remark?: string(name='Remark', description='The description of the instance.', example='Description', position='Query'),
}

model OnsInstanceCreateResponseBody = {
  data?: {
    instanceId?: string(name='InstanceId', description='The ID of the instance that you created.', example='MQ_INST_188077086902****_BXSuW61e'),
    instanceType?: int32(name='InstanceType', description='The edition of the instance. Valid value:

*   **1**: Standard Edition', example='1'),
  }(name='Data', description='The results that are returned.'),
  requestId?: string(name='RequestId', description='The ID of the request. This parameter is a common parameter. Each request has a unique ID. You can use this ID to troubleshoot issues.', example='A07E3902-B92E-44A6-B6C5-6AA111111****'),
}

model OnsInstanceCreateResponse = {
  headers: map[string]string(name='headers'),
  body: OnsInstanceCreateResponseBody(name='body'),
}

/**
  * > : The API operations that are provided by Alibaba Cloud are used to manage and query resources of Alibaba Cloud services. We recommend that you integrate these API operations only in management systems. Do not use these API operations in the core system of messaging services. Otherwise, system risks may occur.
  * An instance is a virtual machine (VM) that can be used to store information about the topics and groups of Message Queue for Apache RocketMQ. You can call this operation when you need to create service resources for the business that you want to launch. Take note of the following points when you call this operation:
  * *   A maximum of eight Message Queue for Apache RocketMQ instances can be deployed in each region.
  * *   This operation can be called to create only a Standard Edition instance. You can use the Message Queue for Apache RocketMQ console to create Standard Edition instances and Enterprise Platinum Edition instances. For information about how to create Message Queue for Apache RocketMQ instances, see [Manage instances](~~200153~~).
  *
 */
async function onsInstanceCreate(request: OnsInstanceCreateRequest): OnsInstanceCreateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OnsInstanceCreate', 'POST', '/', 'json', false, 'json', request);
}

model OnsInstanceDeleteRequest {
  instanceId: string(name='InstanceId', description='The ID of the instance.', example='MQ_INST_188077086902****_BXSuW61e', position='Query'),
}

model OnsInstanceDeleteResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request. This parameter is a common parameter. Each request has a unique ID. You can use this ID to troubleshoot issues.', example='A07E3902-B92E-44A6-B6C5-6AA111111****'),
}

model OnsInstanceDeleteResponse = {
  headers: map[string]string(name='headers'),
  body: OnsInstanceDeleteResponseBody(name='body'),
}

/**
  * > : The API operations that are provided by Alibaba Cloud are used to manage and query resources of Alibaba Cloud services. We recommend that you integrate these API operations only in management systems. Do not use these API operations in the core system of messaging services. Otherwise, system risks may occur.
  * *   You can call this operation when you need to reclaim resources. For example, after you unpublish an application, you can reclaim the resources that were used for the application. An instance can be deleted only when the instance does not contain topics and groups.
  * *   After an instance is deleted, the instance cannot be recovered. Exercise caution when you call this operation.
  *
 */
async function onsInstanceDelete(request: OnsInstanceDeleteRequest): OnsInstanceDeleteResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OnsInstanceDelete', 'POST', '/', 'json', false, 'json', request);
}

model OnsInstanceInServiceListRequest {
  tag?: [ 
    {
      key: string(name='Key', description='The key of a tag that is attached to the instances you want to query. This parameter is not required. If you configure this parameter, you must also configure the **Tag.N.Key** parameter.**** If you include the Key and Value parameters in a request, this operation queries only the instances that use the specified tags. If you do not include these parameters in a request, this operation queries all instances that you can access.

*   The value of this parameter cannot be an empty string.
*   The tag key can be up to 128 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.', example='CartService'),
      value: string(name='Value', description='The value of a tag that is attached to the instances you want to query. This parameter is not required. If you configure this parameter, you must also configure the **Tag.N.Key** parameter.**** If you include the Key and Value parameters in a request, this operation queries only the instances that use the specified tags. If you do not include these parameters in a request, this operation queries all instances that you can access.

*   The value of this parameter can be an empty string.
*   The tag key can be up to 128 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.', example='SericeA'),
    }
  ](name='Tag', description='The list of tags that are attached to the instance. A maximum of 20 tags can be included in a list.', position='Query'),
}

model OnsInstanceInServiceListResponseBody = {
  data?: {
    instanceVO?: [ 
    {
      createTime?: long(name='CreateTime', example='1640847284000'),
      independentNaming?: boolean(name='IndependentNaming', description='Indicates whether the instance uses a namespace. Valid values:

*   **true**: The instance uses a separate namespace. The name of each resource must be unique in the instance. The names of resources in different instances can be the same.
*   **false**: The instance does not use a separate namespace. The name of each resource must be globally unique within and across all instances.', example='true'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.', example='MQ_INST_188077086902****_BXSuW61e'),
      instanceName?: string(name='InstanceName', description='The name of the instance.

The name must be 3 to 64 characters in length and can contain letters, digits, hyphens (-), and underscores (\\_).', example='test1'),
      instanceStatus?: int32(name='InstanceStatus', description='The status of the instance. Valid values:

*   **0**: The instance is being deployed. This value is valid only for Enterprise Platinum Edition instances.
*   **2**: The instance has overdue payments. This value is valid only for Standard Edition instances.
*   **5**: The instance is running. This value is valid for Standard Edition instances and Enterprise Platinum Edition instances.
*   **7**: The instance is being upgraded and is running. This value is valid only for Enterprise Platinum Edition instances.', example='5'),
      instanceType?: int32(name='InstanceType', description='The instance type. Valid values:

*   **1**: Standard Edition
*   **2**: Enterprise Platinum Edition

For more information about the instance editions and differences between the editions, see [Instance editions](~~185261~~).', example='2'),
      releaseTime?: long(name='ReleaseTime', description='The point in time when the instance expires. If the instance is an Enterprise Platinum Edition instance, this parameter is returned.', example='1551024000000'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key', description='The key of the tag.', example='CartService'),
          value?: string(name='Value', description='The value of the tag.', example='ServiceA'),
        }
      ](name='Tag')
      }(name='Tags', description='The tags that are attached to the instance.'),
    }
  ](name='InstanceVO')
  }(name='Data', description='The returned list of all published instances.'),
  requestId?: string(name='RequestId', description='The ID of the request. This parameter is a common parameter. Each request has a unique ID. You can use this ID to troubleshoot issues.', example='0598E46F-DB06-40E2-AD7B-C45923EE****'),
}

model OnsInstanceInServiceListResponse = {
  headers: map[string]string(name='headers'),
  body: OnsInstanceInServiceListResponseBody(name='body'),
}

/**
  * > : The API operations that are provided by Alibaba Cloud are used to manage and query resources of Alibaba Cloud services. We recommend that you integrate these API operations only in management systems. Do not use these API operations in the core system of messaging services. Otherwise, system risks may occur.
  *
 */
async function onsInstanceInServiceList(request: OnsInstanceInServiceListRequest): OnsInstanceInServiceListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OnsInstanceInServiceList', 'POST', '/', 'json', false, 'json', request);
}

model OnsInstanceUpdateRequest {
  instanceId: string(name='InstanceId', description='The ID of the instance whose name or description you want to update.', example='MQ_INST_188077086902****_BXSuW61e', position='Query'),
  instanceName?: string(name='InstanceName', description='The new name of the instance. The name must meet the following rules:

*   The name of the instance must be unique in the region where the instance is deployed.
*   The name must be 3 to 64 characters in length and can contain letters, digits, hyphens (-), and underscores (\\_).
*   If you do not configure this parameter, the instance name remains unchanged.', example='Updatedname', position='Query'),
  remark?: string(name='Remark', description='The updated description of the instance. If you do not configure this parameter, the instance description remains unchanged.', example='Updateddescription', position='Query'),
}

model OnsInstanceUpdateResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request. This parameter is a common parameter. Each request has a unique ID. You can use this ID to troubleshoot issues.', example='A07E3902-B92E-44A6-B6C5-6AA111111****'),
}

model OnsInstanceUpdateResponse = {
  headers: map[string]string(name='headers'),
  body: OnsInstanceUpdateResponseBody(name='body'),
}

/**
  * > : The API operations that are provided by Alibaba Cloud are used to manage and query resources of Alibaba Cloud services. We recommend that you integrate these API operations only in management systems. Do not use these API operations in the core system of messaging services. Otherwise, system risks may occur.
  * A maximum of eight Message Queue for Apache RocketMQ instances can be deployed in each region.
  *
 */
async function onsInstanceUpdate(request: OnsInstanceUpdateRequest): OnsInstanceUpdateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OnsInstanceUpdate', 'POST', '/', 'json', false, 'json', request);
}

model OnsMessageDetailRequest {
  instanceId: string(name='InstanceId', description='The ID of the Message Queue for Apache RocketMQ Instance.', example='MQ_INST_184681981******_BXig0x6A', position='Query'),
  msgId: string(name='MsgId', description='The ID of the message that you want to query.', example='1E0578FE110F18B4AAC235C0******', position='Query'),
  topic: string(name='Topic', description='The name of the topic in which the message you want to query is stored.', example='test-mq_topic', position='Query'),
}

model OnsMessageDetailResponseBody = {
  data?: {
    body?: string(name='Body', description='The body of the message.', example='hello,mq'),
    bodyCRC?: int32(name='BodyCRC', description='The cyclic redundancy check (CRC) value of the message body.', example='914112295'),
    bodyStr?: string(name='BodyStr', description='', example='hello'),
    bornHost?: string(name='BornHost', description='The producer instance that generated the message.', example='42.120.**.**:64646'),
    bornTimestamp?: long(name='BornTimestamp', description='The timestamp that indicates the point in time when the message was generated. Unit: milliseconds.', example='1570761026630'),
    instanceId?: string(name='InstanceId', description='The ID of the Message Queue for Apache RocketMQ Instance.', example='MQ_INST_184681981******_BXig0x6A'),
    msgId?: string(name='MsgId', description='The ID of the message.', example='1E0578FE110F18B4AAC235C05F2*****'),
    propertyList?: [ 
      {
        name?: string(name='Name', description='The name of the attribute. Valid values:

*   **BODY**: indicates the message body
*   **TRACE_ON**: indicates whether the trace of the message exists.
*   **KEYS**: indicates the key of the message.
*   **TAGS**: indicates the tag that is attached to the message.
*   **INSTANCE_ID**: indicates the ID of the instance that contains the message.

For more information about the terms that are used in Message Queue for Apache RocketMQ, see [Terms](~~29533~~).', example='TAGS'),
        value?: string(name='Value', description='The value of the attribute.', example='TagA'),
      }
    ](name='PropertyList', description='The attributes of the message.'),
    reconsumeTimes?: int32(name='ReconsumeTimes', description='The number of retries that Message Queue for Apache RocketMQ performed to send the message to consumers.', example='0'),
    storeHost?: string(name='StoreHost', description='The Message Queue for Apache RocketMQ broker that stores the message.', example='11.220.***.***:10911'),
    storeSize?: int32(name='StoreSize', description='The size of the message. Unit: KB.', example='2'),
    storeTimestamp?: long(name='StoreTimestamp', description='The timestamp that indicates the point in time when the Message Queue for Apache RocketMQ broker stored the message. Unit: milliseconds.', example='1570761026708'),
    topic?: string(name='Topic', description='The topic to which the message belongs.', example='test-mq_topic'),
  }(name='Data', description='The data returned.'),
  requestId?: string(name='RequestId', description='The ID of the request. This parameter is a common parameter. Each request has a unique ID. You can use this ID to troubleshoot issues.', example='EAE5BE23-37A1-4354-94D6-E44AE17E****'),
}

model OnsMessageDetailResponse = {
  headers: map[string]string(name='headers'),
  body: OnsMessageDetailResponseBody(name='body'),
}

async function onsMessageDetail(request: OnsMessageDetailRequest): OnsMessageDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OnsMessageDetail', 'GET', '/', 'json', false, 'json', request);
}

model OnsMessageGetByKeyRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance where the message that you want to query resides.', example='MQ_INST_111111111111_DOxxxxxx', position='Query'),
  key: string(name='Key', description='The key of the message that you want to query.', example='messageKey1', position='Query'),
  topic: string(name='Topic', description='The topic that contains the message that you want to query.', example='test-mq_topic', position='Query'),
}

model OnsMessageGetByKeyResponseBody = {
  data?: {
    onsRestMessageDo?: [ 
    {
      bodyCRC?: int32(name='BodyCRC', description='The cyclic redundancy check (CRC) value of the message body.', example='914112295'),
      bornHost?: string(name='BornHost', description='The producer client that generated the message.', example='42.120.***.***:59270'),
      bornTimestamp?: long(name='BornTimestamp', description='The timestamp when the message was produced.', example='1570760999721'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.', example='MQ_INST_111111111111_DOxxxxxx'),
      msgId?: string(name='MsgId', description='The ID of the message.', example='1E0578FE110F18B4AAC235C05F2*****'),
      propertyList?: {
        messageProperty?: [ 
        {
          name?: string(name='Name', description='The name of the attribute. Valid values:

*   **TRACE_ON**: indicates whether a trace of the message exists.

\\-\\*\\* KEYS\\*\\*: indicates the key of the message.

*   **TAGS**: indicates the tag that is attached to the message.
*   **INSTANCE_ID**: indicates the ID of the instance that contains the message.

For more information about the terms that are used in Message Queue for Apache RocketMQ, see [Terms](~~29533~~).', example='TAGS'),
          value?: string(name='Value', description='The value of the attribute.', example='TagA'),
        }
      ](name='MessageProperty')
      }(name='PropertyList', description='The attributes of the message.'),
      reconsumeTimes?: int32(name='ReconsumeTimes', description='The number of retries that Message Queue for Apache RocketMQ performed to send the message to consumers.', example='1'),
      storeHost?: string(name='StoreHost', description='The Message Queue for Apache RocketMQ broker that stores the message.', example='11.193.***.***:10911'),
      storeSize?: int32(name='StoreSize', description='The size of the message.', example='406'),
      storeTimestamp?: long(name='StoreTimestamp', description='The timestamp when the Message Queue for Apache RocketMQ broker stored the message.', example='1570760999811'),
      topic?: string(name='Topic', description='The topic to which the message belongs.', example='test-mq_topic'),
    }
  ](name='OnsRestMessageDo')
  }(name='Data', description='The information about the message that is queried.'),
  requestId?: string(name='RequestId', description='The ID of the request. This parameter is a common parameter. Each request has a unique ID. You can use this ID to troubleshoot issues.', example='A07E3902-B92E-44A6-B6C5-6AA111111****'),
}

model OnsMessageGetByKeyResponse = {
  headers: map[string]string(name='headers'),
  body: OnsMessageGetByKeyResponseBody(name='body'),
}

/**
  * > : The API operations that are provided by Alibaba Cloud are used to manage and query resources of Alibaba Cloud services. We recommend that you integrate these API operations only in management systems. Do not use these API operations in the core system of messaging services. Otherwise, system risks may occur.
  * *   This operation uses the fuzzy match method to query messages based on a specified message key. The same message key may be used by multiple messages. Therefore, the returned result may contain the information about multiple messages.
  * *   This operation can be used in scenarios in which you cannot obtain the IDs of the messages that you want to query. You can perform the following steps to query the information about messages:
  *     1.  Call this operation to query message IDs.
  *     2.  Call the **OnsMessageGetByMsgId** operation to query the details of a specified message. The OnsMessageGetByMsgId operation uses the exact match method. For more information about the **OnsMessageGetByMsgId** operation, see [OnsMessageGetByMsgId](~~29607~~).
  *
 */
async function onsMessageGetByKey(request: OnsMessageGetByKeyRequest): OnsMessageGetByKeyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OnsMessageGetByKey', 'POST', '/', 'json', false, 'json', request);
}

model OnsMessageGetByMsgIdRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance where the message that you want to query resides.', example='MQ_INST_111111111111_DOxxxxxx', position='Query'),
  msgId: string(name='MsgId', description='The ID of the message that you want to query.', example='1E0578FE110F18B4AAC235C05F2*****', position='Query'),
  topic: string(name='Topic', description='The topic that contains the message that you want to query.', example='test-mq_topic', position='Query'),
}

model OnsMessageGetByMsgIdResponseBody = {
  data?: {
    bodyCRC?: int32(name='BodyCRC', description='The cyclic redundancy check (CRC) value of the message body.', example='914112295'),
    bornHost?: string(name='BornHost', description='The producer client that generated the message.', example='42.120.**.**:64646'),
    bornTimestamp?: long(name='BornTimestamp', description='The timestamp when the message was produced.', example='1570761026630'),
    instanceId?: string(name='InstanceId', description='The ID of the instance.', example='MQ_INST_111111111111_DOxxxxxx'),
    msgId?: string(name='MsgId', description='The ID of the message.', example='1E0578FE110F18B4AAC235C0C8460BA2'),
    propertyList?: {
      messageProperty?: [ 
      {
        name?: string(name='Name', description='The name of the attribute. Valid values:

*   **TRACE_ON**: indicates whether a trace of the message exists.
*   **KEYS**: indicates the key of the message.
*   **TAGS**: indicates the tag that is attached to the message.
*   **INSTANCE_ID**: indicates the ID of the instance that contains the message.

For more information about the terms that are used in Message Queue for Apache RocketMQ, see [Terms](~~29533~~).', example='TAGS'),
        value?: string(name='Value', description='The value of the attribute.', example='TagA'),
      }
    ](name='MessageProperty')
    }(name='PropertyList', description='The attributes of the message.'),
    reconsumeTimes?: int32(name='ReconsumeTimes', description='The number of retries that Message Queue for Apache RocketMQ performed to send the message to consumers.', example='1'),
    storeHost?: string(name='StoreHost', description='The Message Queue for Apache RocketMQ broker that stores the message.', example='11.220.***.***:10911'),
    storeSize?: int32(name='StoreSize', description='The size of the message.', example='407'),
    storeTimestamp?: long(name='StoreTimestamp', description='The timestamp when the Message Queue for Apache RocketMQ broker stored the message.', example='1570761026708'),
    topic?: string(name='Topic', description='The topic to which the message belongs.', example='test-mq_topic'),
  }(name='Data', description='The information about the message that is queried.'),
  requestId?: string(name='RequestId', description='The ID of the request. This parameter is a common parameter. Each request has a unique ID. You can use this ID to troubleshoot issues.', example='A07E3902-B92E-44A6-B6C5-6AA111111****'),
}

model OnsMessageGetByMsgIdResponse = {
  headers: map[string]string(name='headers'),
  body: OnsMessageGetByMsgIdResponseBody(name='body'),
}

/**
  * > : The API operations that are provided by Alibaba Cloud are used to manage and query resources of Alibaba Cloud services. We recommend that you integrate these API operations only in management systems. Do not use these API operations in the core system of messaging services. Otherwise, system risks may occur.
  * *   If a message is not consumed as expected, you can call this operation to query the information about the message for troubleshooting.
  * *   This operation uses the exact match method to query a message based on the message ID. You can obtain the message ID from the SendResult parameter that is returned after the message is sent. You must store the returned information after each message is sent. The queried information about a message includes the point in time when the message was sent, the broker on which the message is stored, and the attributes of the message such as the message key and tag.
  *
 */
async function onsMessageGetByMsgId(request: OnsMessageGetByMsgIdRequest): OnsMessageGetByMsgIdResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OnsMessageGetByMsgId', 'POST', '/', 'json', false, 'json', request);
}

model OnsMessagePageQueryByTopicRequest {
  beginTime: long(name='BeginTime', description='The beginning of the time range to query. Set the value to a UNIX timestamp that represents the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC. If you specify a valid value for the **TaskId** parameter in the request, this parameter does not take effect. The system uses the value of the BeginTime parameter that you specified in the request when you created the specified query task.', example='1570723200000', position='Query'),
  currentPage: int32(name='CurrentPage', description='The number of the page to return. Pages start from page 1. Valid values: 1 to 50.', example='2', position='Query'),
  endTime: long(name='EndTime', description='The end of the time range to query. Set the value to a UNIX timestamp that represents the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC. If you specify a valid value for the **TaskId** parameter in the request, this parameter does not take effect. The system uses the value of the EndTime parameter that you specified in the request when you created the specified query task.', example='1570809600000', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance where the message that you want to query resides.', example='MQ_INST_111111111111_DOxxxxxx', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 5 to 50. Default value: 20. If you specify a valid value for the **TaskId** parameter in the request, this parameter does not take effect. The system uses the value of the PageSize parameter that you specified in the request for creating the query task.', example='5', position='Query'),
  taskId?: string(name='TaskId', description='The ID of the query task. The first time you call this operation to query dead-letter messages that are sent to a specified consumer group within a specified time range, this parameter is not required. This parameter is required in subsequent queries for dead-letter messages on a specified page. You can obtain the task ID from the returned result of the first query.', example='0BC1310300002A9F000021E4D7A48346', position='Query'),
  topic: string(name='Topic', description='The topic in which the messages you want to query are stored.', example='test-mq_topic', position='Query'),
}

model OnsMessagePageQueryByTopicResponseBody = {
  msgFoundDo?: {
    currentPage?: long(name='CurrentPage', description='The page number of the returned page.', example='1'),
    maxPageCount?: long(name='MaxPageCount', description='The total number of returned pages.', example='400'),
    msgFoundList?: {
      onsRestMessageDo?: [ 
      {
        bodyCRC?: int32(name='BodyCRC', description='The cyclic redundancy check (CRC) value of the message body.', example='914112295'),
        bornHost?: string(name='BornHost', description='The producer client that generated the message.', example='42.120.***.***:59270'),
        bornTimestamp?: long(name='BornTimestamp', description='The timestamp when the message was generated. The value is a UNIX timestamp that represents the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.', example='1570760999721'),
        instanceId?: string(name='InstanceId', description='The ID of the instance.', example='MQ_INST_111111111111_DOxxxxxx'),
        msgId?: string(name='MsgId', description='The ID of the message.', example='1E0578FE110F18B4AAC235C05F2*****'),
        propertyList?: {
          messageProperty?: [ 
          {
            name?: string(name='Name', description='The name of the attribute. Valid values:

*   **TRACE_ON**: indicates whether a trace of the message exists.
*   **KEYS**: indicates the key of the message.
*   **TAGS**: indicates the tag that is attached to the message.
*   **INSTANCE_ID**: indicates the ID of the instance that contains the message.

For more information about the terms that are used in Message Queue for Apache RocketMQ, see [Terms](~~29533~~).', example='TAGS'),
            value?: string(name='Value', description='The value of the attribute.', example='TagA'),
          }
        ](name='MessageProperty')
        }(name='PropertyList', description='The attributes of the message.'),
        reconsumeTimes?: int32(name='ReconsumeTimes', description='The number of retries that Message Queue for Apache RocketMQ performed to send the message to consumers.', example='1'),
        storeHost?: string(name='StoreHost', description='The Message Queue for Apache RocketMQ broker that stores the message.', example='11.193.***.***:10911'),
        storeSize?: int32(name='StoreSize', description='The size of the message. Unit: KB.', example='406'),
        storeTimestamp?: long(name='StoreTimestamp', description='The timestamp when the Message Queue for Apache RocketMQ broker stored the message. The value is a UNIX timestamp that represents the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.', example='1570760999811'),
        topic?: string(name='Topic', description='The topic to which the message belongs.', example='test-mq_topic'),
      }
    ](name='OnsRestMessageDo')
    }(name='MsgFoundList', description='The information about messages on the returned page. The information that is contained in this parameter is the same as the information that is returned by the [OnsMessageGetByMsgId](~~29607~~) operation.'),
    taskId?: string(name='TaskId', description='The ID of the query task. The first time you call this operation to query the dead-letter messages that are sent to a specified consumer group within a specified time range, this parameter is returned. You can use the task ID to query the details of dead-letter messages on other returned pages.', example='0BC1310300002A9F000021E4D7A48346'),
  }(name='MsgFoundDo', description='The information about the message that is queried.'),
  requestId?: string(name='RequestId', description='The ID of the request. This parameter is a common parameter. Each request has a unique ID. You can use this ID to troubleshoot issues.', example='5DC2A47E-2B31-4722-96C8-FA59C9*****'),
}

model OnsMessagePageQueryByTopicResponse = {
  headers: map[string]string(name='headers'),
  body: OnsMessagePageQueryByTopicResponseBody(name='body'),
}

/**
  * > : The API operations that are provided by Alibaba Cloud are used to manage and query resources of Alibaba Cloud services. We recommend that you integrate these API operations only in management systems. Do not use these API operations in the core system of messaging services. Otherwise, system risks may occur.
  * *   If you do not know the message ID or message key of a message that you want to query, you can call this operation to query all messages that are stored in a topic within a specified time range. The results are displayed by page.
  * *   We recommend that you specify a short time range to query messages. If you specify a long time range, a large number of messages are returned. In this case, you cannot find the message that you want to query in an efficient manner. You can perform the following steps to query messages:
  *     1.  Perform a paged query by specifying the topic, start time, end time, and number of entries to return on each page. If the topic contains messages, the information about the messages on the first page, total number of pages, and task ID are returned by default.
  *     2.  Specify the task ID and a page number to call this operation again to query the messages on the specified page. In this query, the BeginTime, EndTime, and PageSize parameters do not take effect. By default, the system uses the values of these parameters that you specified in the request when you created the specified query task.
  *
 */
async function onsMessagePageQueryByTopic(request: OnsMessagePageQueryByTopicRequest): OnsMessagePageQueryByTopicResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OnsMessagePageQueryByTopic', 'POST', '/', 'json', false, 'json', request);
}

model OnsMessagePushRequest {
  clientId: string(name='ClientId', description='The ID of the consumer. You can call the [OnsConsumerGetConnection](~~29598~~) operation to query the ID of each consumer in a consumer group.', example='30.5.121.**@24813#-1999745829#-1737591554#453111174894656', position='Query'),
  groupId: string(name='GroupId', description='The ID of the consumer group. For information about what a consumer group is, see [Terms](~~29533~~).', example='GID_test_group_id', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the Message Queue for Apache RocketMQ instance to which the specified consumer group belongs.', example='MQ_INST_111111111111_DOxxxxxx', position='Query'),
  msgId: string(name='MsgId', description='The ID of the message.', example='0BC1669963053CF68F733BB70396****', position='Query'),
  topic: string(name='Topic', description='The topic to which the message is pushed.', example='test-mq_topic', position='Query'),
}

model OnsMessagePushResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request. The system generates a unique ID for each request. You can troubleshoot issues based on the request ID.', example='B8EDC90D-F726-4B9E-8BEF-F0DD25EC****'),
}

model OnsMessagePushResponse = {
  headers: map[string]string(name='headers'),
  body: OnsMessagePushResponseBody(name='body'),
}

/**
  * ## Note
  * This operation can be used to check whether messages in a specified topic can be consumed by consumers in a specified consumer group. This operation obtains the body of the message that is specified by the MsgId parameter, re-encapsulates the message body to produce a new message, and then pushes the new message to a specified consumer. The content of the message that is sent to the consumer is the same as the content of the original message. They are not the same message because they use different message IDs.
  *
 */
async function onsMessagePush(request: OnsMessagePushRequest): OnsMessagePushResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OnsMessagePush', 'POST', '/', 'json', false, 'json', request);
}

model OnsMessageTraceRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance where the message that you want to query resides.', example='MQ_INST_111111111111_DOxxxxxx', position='Query'),
  msgId: string(name='MsgId', description='The ID of the message that you want to query.', example='1E05791C117818B4AAC23B1BB0CE****', position='Query'),
  topic: string(name='Topic', description='The topic to which the message belongs.', example='test-mq_topic', position='Query'),
}

model OnsMessageTraceResponseBody = {
  data?: {
    messageTrack?: [ 
    {
      consumerGroup?: string(name='ConsumerGroup', description='The ID of the consumer group that subscribes to the topic.', example='GID_test_group_id'),
      instanceId?: string(name='InstanceId', description='The ID of the instance where the message that you want to query resides.', example='MQ_INST_111111111111_DOxxxxxx'),
      trackType?: string(name='TrackType', description='The status of the message. Valid values:

*   **CONSUMED**: The message is consumed.
*   **CONSUMED_BUT_FILTERED:** No consumer groups subscribe to the message. The message is filtered out and not consumed.
*   **NOT_CONSUME_YET**: The message is pending to be consumed.
*   **NOT_ONLINE**: The consumer group is offline.
*   **UNKNOWN**: The message is not consumed due to unknown reasons.', example='CONSUMED'),
    }
  ](name='MessageTrack')
  }(name='Data', description='The information about the message that is queried.'),
  requestId?: string(name='RequestId', description='The ID of the request. This parameter is a common parameter. Each request has a unique ID. You can use this ID to troubleshoot issues.', example='EAE5BE23-37A1-4354-94D6-E44AE17E****'),
}

model OnsMessageTraceResponse = {
  headers: map[string]string(name='headers'),
  body: OnsMessageTraceResponseBody(name='body'),
}

/**
  * > : The API operations that are provided by Alibaba Cloud are used to manage and query resources of Alibaba Cloud services. We recommend that you integrate these API operations only in management systems. Do not use these API operations in the core system of messaging services. Otherwise, system risks may occur.
  * *   You can call this operation to check whether a specified message is consumed. If the message is not consumed, you can troubleshoot the issue based on the returned information.
  * *   This operation queries information based on the built-in offset mechanism of Message Queue for Apache RocketMQ. In most cases, the results are correct. If you have reset the consumer offset or cleared accumulated messages, the results may not be correct.
  *
 */
async function onsMessageTrace(request: OnsMessageTraceRequest): OnsMessageTraceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OnsMessageTrace', 'POST', '/', 'json', false, 'json', request);
}

model OnsRegionListRequest {
}

model OnsRegionListResponseBody = {
  data?: {
    regionDo?: [ 
    {
      onsRegionId?: string(name='OnsRegionId', description='The ID of the region.', example='cn-hangzhou'),
      regionName?: string(name='RegionName', description='The ID of the region.', example='China (Hangzhou)'),
    }
  ](name='RegionDo')
  }(name='Data', description='The information about the message that is queried.'),
  requestId?: string(name='RequestId', description='The ID of the request. This parameter is a common parameter. Each request has a unique ID. You can use this ID to troubleshoot issues.', example='72D14A84-45E5-4E01-A6DB-F63C4721****'),
}

model OnsRegionListResponse = {
  headers: map[string]string(name='headers'),
  body: OnsRegionListResponseBody(name='body'),
}

/**
  * > : The API operations that are provided by Alibaba Cloud are used to manage and query resources of Alibaba Cloud services. We recommend that you integrate these API operations only in management systems. Do not use these API operations in the core system of messaging services. Otherwise, system risks may occur.
  * When you use an SDK to access and manage a Message Queue for Apache RocketMQ instance, you must sequentially specify the information about two regions. You can query the information about the second region by calling the \\*\\*OnsRegionList\\*\\* operation. You must apply for a public endpoint in the following scenarios:
  * *   Connect your application to Message Queue for Apache RocketMQ: Select the nearest API gateway endpoint based on the region where your application is deployed, and enter the corresponding **region ID**. The **regionId** is used to access Alibaba Cloud API Gateway because Message Queue for Apache RocketMQ instances provide API services by using the OpenAPI Explorer platform, which is also called POP.
  * *   Access a region to manage its resources: Specify a region where you want to manage Message Queue for Apache RocketMQ resources and enter the region ID. You can query the region ID by calling the **OnsRegionList** operation.
  *
 */
async function onsRegionList(request: OnsRegionListRequest): OnsRegionListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OnsRegionList', 'POST', '/', 'json', false, 'json', request);
}

model OnsTopicCreateRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance in which you want to create the topic.', example='MQ_INST_188077086902****_BXSuW61e', position='Query'),
  messageType: int32(name='MessageType', description='The type of the message. Valid values:

*   **0**: normal messages
*   **1**: partitionally ordered messages
*   **2**: globally ordered messages
*   **4**: transactional messages
*   **5**: scheduled or delayed messages

For more information about message types, see [Message types](~~155952~~).', example='0', position='Query'),
  remark?: string(name='Remark', description='The description of the topic that you want to create.', example='Test', position='Query'),
  topic: string(name='Topic', description='The name of the topic that you want to create. The name must meet the following rules:

*   The name must be 3 to 64 characters in length and can contain letters, digits, hyphens (-), and underscores (\\_).
*   The topic name cannot start with CID or GID because CID and GID are reserved prefixes for group IDs.
*   If the Message Queue for Apache RocketMQ instance in which you want to create the topic uses a namespace, the topic name must be unique in the instance. The topic name cannot be the same as an existing topic name or a group ID in the instance. The topic name can be the same as a topic name or a group ID in another instance that uses a different namespace. For example, if Instance A and Instance B use different namespaces, a topic name in Instance A can be the same as a topic name or a group ID in Instance B.
*   If the instance in which you want to create the topic does not use a namespace, the topic name must be globally unique across instances and regions. The topic name cannot be the same as an existing topic name or group ID in Message Queue for Apache RocketMQ instances that belong to your Alibaba Cloud account.

>  To check whether an instance uses a namespace, log on to the Message Queue for Apache RocketMQ console, go to the **Instance Details** page, and then view the value of the Namespace field in the **Basic Information** section.', example='test', position='Query'),
}

model OnsTopicCreateResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request. This parameter is a common parameter. Each request has a unique ID. You can use this ID to troubleshoot issues.', example='B6949B58-223E-4B75-B4FE-7797C15E****'),
}

model OnsTopicCreateResponse = {
  headers: map[string]string(name='headers'),
  body: OnsTopicCreateResponseBody(name='body'),
}

/**
  * > : The API operations that are provided by Alibaba Cloud are used to manage and query resources of Alibaba Cloud services. We recommend that you integrate these API operations only in management systems. Do not use these API operations in the core system of messaging services. Otherwise, system risks may occur.
  * When you want to release a new application or expand your business, you can call this operation to create a topic based on your business requirements.
  *
 */
async function onsTopicCreate(request: OnsTopicCreateRequest): OnsTopicCreateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OnsTopicCreate', 'POST', '/', 'json', false, 'json', request);
}

model OnsTopicDeleteRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance that contains the topic you want to delete.', example='MQ_INST_188077086902****_BXSuW61e', position='Query'),
  topic: string(name='Topic', description='The name of the topic that you want to delete.', example='test', position='Query'),
}

model OnsTopicDeleteResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request. This parameter is a common parameter. Each request has a unique ID. You can use this ID to troubleshoot issues.', example='4189D4A6-231A-4028-8D89-F66A76C1****'),
}

model OnsTopicDeleteResponse = {
  headers: map[string]string(name='headers'),
  body: OnsTopicDeleteResponseBody(name='body'),
}

/**
  * >  The API operations that are provided by Alibaba Cloud are used to manage and query resources of Alibaba Cloud services. We recommend that you integrate these API operations only in management systems. Do not use these API operations in the core system of messaging services. Otherwise, system risks may occur. - After you delete the topic, the publishing and subscription relationships that are constructed based on the topic are cleared. Exercise caution when you call this operation.
  * You can call this operation to delete a topic when you need to reclaim the resources from the topic. For example, after an application is brought offline, you can delete the topics that are used for the application. After you delete a topic, the backend of Message Queue for Apache RocketMQ reclaims the resources from the topic. The system requires a long period of time to reclaim the resources. After you delete a topic, we recommend that you do not create a topic that uses the same name as the deleted topic within a short period of time. If the system fails to delete the specified topic, troubleshoot the issue based on the error code.
  *
 */
async function onsTopicDelete(request: OnsTopicDeleteRequest): OnsTopicDeleteResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OnsTopicDelete', 'POST', '/', 'json', false, 'json', request);
}

model OnsTopicListRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance that contains the topics you want to query.', example='MQ_INST_188077086902****_BXSuW61e', position='Query'),
  tag?: [ 
    {
      key: string(name='Key', description='The key of a tag that is attached to the topics you want to query. This parameter is not required. If you configure this parameter, you must also configure the **Tag.N.Value** parameter.**** If you include the Key and Value parameters in a request, this operation queries only the topics that use the specified tags. If you do not include these parameters in a request, this operation queries all topics that you can access.

*   The value of this parameter cannot be an empty string.
*   The tag value can be up to 128 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.', example='CartService'),
      value: string(name='Value', description='The value of a tag that is attached to the topics you want to query. This parameter is not required. If you configure this parameter, you must also configure the **Tag.N.Key** parameter.**** If you include the Key and Value parameters in a request, this operation queries only the topics that use the specified tags. If you do not include these parameters in a request, this operation queries all topics that you can access.

*   The value of this parameter can be an empty string.
*   The tag value can be up to 128 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.', example='ServiceA'),
    }
  ](name='Tag', description='The list of tags that are attached to the topic. A maximum of 20 tags can be included in the list.', position='Query'),
  topic?: string(name='Topic', description='The name of the topic that you want to query. This parameter is required when you want to query a specific topic. If you do not include this parameter in a request, all topics that you can access are queried.', example='test', position='Query'),
  userId?: string(name='UserId', example='138015630679****', position='Query'),
}

model OnsTopicListResponseBody = {
  data?: {
    publishInfoDo?: [ 
    {
      createTime?: long(name='CreateTime', description='The point in time when the topic was created.', example='1570700947000'),
      independentNaming?: boolean(name='IndependentNaming', description='Indicates whether the instance that contains the topic uses a namespace. Valid values:

*   **true**: The instance uses a separate namespace. The name of each resource must be unique in the instance. The names of resources in different instances can be the same.
*   **false**: The instance does not use a separate namespace. The name of each resource must be globally unique within and across all instances.', example='true'),
      instanceId?: string(name='InstanceId', description='The ID of the instance that contains the topic.', example='MQ_INST_188077086902****_BXSuW61e'),
      messageType?: int32(name='MessageType', description='The type of the messages. Valid values:

*   **0**: normal messages
*   **1**: partitionally ordered messages
*   **2**: globally ordered messages
*   **4**: transactional messages
*   **5**: scheduled or delayed messages', example='0'),
      owner?: string(name='Owner', description='The user ID of the topic owner.', example='138015630679****'),
      relation?: int32(name='Relation', description='The code of the relationship between the current account and the topic. Valid values:

*   **1**: The current account is the owner of the topic.
*   **2**: The current account can publish messages to the topic.
*   **4**: The current account can subscribe to the topic.
*   **6**: The current account can publish messages to and subscribe to the topic.', example='6'),
      relationName?: string(name='RelationName', description='The name of the relationship between the current account and the topic. The value of this parameter indicates that the current account is the owner of the topic, the current account can publish messages to the topic, the current account can subscribe to the topic, or the current account can publish messages to and subscribe to the topic.', example='Publish and subscribe'),
      remark?: string(name='Remark', description='The description of the topic.', example='Test'),
      serviceStatus?: int32(name='ServiceStatus', description='The status of the topic. Valid values:

*   **0**: The topic is being created.
*   **1**: The topic is being used.', example='0'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key', description='The key of the tag.', example='CartService'),
          value?: string(name='Value', description='The value of the tag.', example='SrviceA'),
        }
      ](name='Tag')
      }(name='Tags', description='The tags that are attached to the topic.'),
      topic?: string(name='Topic', description='The name of the topic.', example='test'),
    }
  ](name='PublishInfoDo')
  }(name='Data', description='The information about the topics.'),
  requestId?: string(name='RequestId', description='The ID of the request. This is a common parameter. Each request has a unique ID. You can use this ID to troubleshoot issues.', example='4A978869-7681-4529-B470-107E1379****'),
}

model OnsTopicListResponse = {
  headers: map[string]string(name='headers'),
  body: OnsTopicListResponseBody(name='body'),
}

/**
  * > : The API operations that are provided by Alibaba Cloud are used to manage and query resources of Alibaba Cloud services. We recommend that you integrate these API operations only in management systems. Do not use these API operations in the core system of messaging services. Otherwise, system risks may occur.
  * This operation returns the basic information about topics and does not return the details of topics.
  *
 */
async function onsTopicList(request: OnsTopicListRequest): OnsTopicListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OnsTopicList', 'POST', '/', 'json', false, 'json', request);
}

model OnsTopicStatusRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance that contains the topic you want to query.', example='MQ_INST_188077086902****_BXSuW61e', position='Query'),
  topic: string(name='Topic', description='The name of the topic that you want to query.', example='test', position='Query'),
}

model OnsTopicStatusResponseBody = {
  data?: {
    lastTimeStamp?: long(name='LastTimeStamp', description='The point in time when the latest message is ready in the topic. If no message exists in the topic, the return value of this parameter is 0.

The value of this parameter is a UNIX timestamp in milliseconds.

For information about the definition of ready messages and ready time, see [Terms](~~29533~~).', example='1570864984364'),
    perm?: int32(name='Perm', description='Indicates the operations that you can perform on the topic. Valid values:

*   **2**: You can publish messages to the topic.
*   **4**: You can subscribe to the topic.
*   **6**: You can publish messages to and subscribe to the topic.', example='6'),
    totalCount?: long(name='TotalCount', description='The total number of messages in all partitions of the topic.', example='2310'),
  }(name='Data', description='The data structure of the queried topic.'),
  requestId?: string(name='RequestId', description='The ID of the request. This parameter is a common parameter. Each request has a unique ID. You can use this ID to troubleshoot issues.', example='427EE49D-D762-41FB-8F3D-9BAC96C3****'),
}

model OnsTopicStatusResponse = {
  headers: map[string]string(name='headers'),
  body: OnsTopicStatusResponseBody(name='body'),
}

/**
  * > : The API operations that are provided by Alibaba Cloud are used to manage and query resources of Alibaba Cloud services. We recommend that you integrate these API operations only in management systems. Do not use these API operations in the core system of messaging services. Otherwise, system risks may occur.
  * You can determine the resource usage of a topic based on the information that is returned by this operation. The returned information includes the total number of messages in the topic and the most recent point in time when a message was published to the topic.
  *
 */
async function onsTopicStatus(request: OnsTopicStatusRequest): OnsTopicStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OnsTopicStatus', 'POST', '/', 'json', false, 'json', request);
}

model OnsTopicSubDetailRequest {
  instanceId: string(name='InstanceId', description='The ID of the instance that contains the topic you want to query.', example='MQ_INST_111111111111_DOxxxxxx', position='Query'),
  topic: string(name='Topic', description='The name of the topic that you want to query.', example='test', position='Query'),
}

model OnsTopicSubDetailResponseBody = {
  data?: {
    subscriptionDataList?: {
      subscriptionDataList?: [ 
      {
        groupId?: string(name='GroupId', description='The ID of the consumer group.', example='GID_test'),
        messageModel?: string(name='MessageModel', description='The consumption mode. Valid values:

*   **CLUSTERING**: the clustering consumption mode
*   **BROADCASTING**: the broadcasting consumption mode

For more information about consumption modes, see [Clustering consumption and broadcasting consumption](~~43163~~).', example='CLUSTERING'),
        subString?: string(name='SubString', description='The expression based on which consumers in the consumer group subscribe to the topic.', example='*'),
      }
    ](name='SubscriptionDataList')
    }(name='SubscriptionDataList', description='The information about the online consumer groups that subscribe to the topic.'),
    topic?: string(name='Topic', description='The name of the topic.', example='test'),
  }(name='Data', description='The returned data.'),
  requestId?: string(name='RequestId', description='The ID of the request. This parameter is a common parameter. Each request has a unique ID. You can use this ID to troubleshoot issues.', example='87B6207F-2908-42B5-A134-84956DCA****'),
}

model OnsTopicSubDetailResponse = {
  headers: map[string]string(name='headers'),
  body: OnsTopicSubDetailResponseBody(name='body'),
}

/**
  * > : The API operations that are provided by Alibaba Cloud are used to manage and query resources of Alibaba Cloud services. We recommend that you integrate these API operations only in management systems. Do not use these API operations in the core system of messaging services. Otherwise, system risks may occur.
  * You can call this operation to query the online consumer groups that subscribe to a specified topic. If all consumers in a group are offline, the information about the group is not returned.
  *
 */
async function onsTopicSubDetail(request: OnsTopicSubDetailRequest): OnsTopicSubDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OnsTopicSubDetail', 'POST', '/', 'json', false, 'json', request);
}

model OnsTopicUpdateRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance to which the topic belongs.', example='MQ_INST_111111111111_DOxxxxxx', position='Query'),
  perm: int32(name='Perm', description='The read/write mode that you want to configure for the topic. Valid values:

*   **6:** Both read and write operations are allowed.
*   **4:** Write operations are forbidden.
*   **2:** Read operations are forbidden.', example='6', position='Query'),
  topic: string(name='Topic', description='The name of the topic that you want to manage.', example='test', position='Query'),
}

model OnsTopicUpdateResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request. This parameter is a common parameter. Each request has a unique ID. You can use this ID to troubleshoot issues.', example='81979ADA-4A78-4F64-9DEC-5700446D****'),
}

model OnsTopicUpdateResponse = {
  headers: map[string]string(name='headers'),
  body: OnsTopicUpdateResponseBody(name='body'),
}

/**
  * @deprecated
  * > : The API operations that are provided by Alibaba Cloud are used to manage and query resources of Alibaba Cloud services. We recommend that you integrate these API operations only in management systems. Do not use these API operations in the core system of messaging services. Otherwise system risks may occur.
  * You can call this operation to forbid read or write operations on a specific topic.
  *
 */
// Deprecated
async function onsTopicUpdate(request: OnsTopicUpdateRequest): OnsTopicUpdateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OnsTopicUpdate', 'POST', '/', 'json', false, 'json', request);
}

model OnsTraceGetResultRequest {
  queryId: string(name='QueryId', description='The ID of the task that was created to query the trace of the message.', example='272967562652883649157096685****', position='Query'),
}

model OnsTraceGetResultResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request. The system generates a unique ID for each request. You can troubleshoot issues based on the request ID.', example='84EE24D2-851F-40D6-B99E-4D6AB909****'),
  traceData?: {
    createTime?: long(name='CreateTime', description='The point in time when the task was created.', example='1570966857000'),
    instanceId?: string(name='InstanceId', description='The ID of the instance that contains the message.', example='MQ_INST_111111111111_DOxxxxxx'),
    msgId?: string(name='MsgId', description='The ID of the message that is queried.', example='1E05791C117818B4AAC23B1BB0CE****'),
    msgKey?: string(name='MsgKey', description='The key of the message that is queried.', example='ORDERID_100'),
    queryId?: string(name='QueryId', description='The ID of the task.', example='272967562652883649157096685****'),
    status?: string(name='Status', description='The status of the task. Valid values:

*   **finish**: The task is complete.
*   **working**: The task is in progress.
*   **removed**: The task is deleted.', example='finish'),
    topic?: string(name='Topic', description='The topic in which the message is stored.', example='test'),
    traceList?: {
      traceMapDo?: [ 
      {
        bornHost?: string(name='BornHost', description='The address of the producer that generated the message.', example='30.5.**.**'),
        costTime?: int32(name='CostTime', description='The period of time that the system took to send the message. Unit: milliseconds.', example='24'),
        msgId?: string(name='MsgId', description='The ID of the message.', example='0BC1F01800002A9F000000531246****'),
        msgKey?: string(name='MsgKey', description='The key of the message.', example='ORDERID_100'),
        pubGroupName?: string(name='PubGroupName', description='The ID of the group that contains the producer.', example='GID_test'),
        pubTime?: long(name='PubTime', description='The point in time when the message was sent.', example='1570850870478'),
        status?: string(name='Status', description='Indicates whether the message is sent. Valid values:

*   **SEND_SUCCESS**: The message is sent.
*   **SEND_FAILED**: The message failed to be sent.
*   **SEND_ROLLBACK:** The message is a transactional message and is rolled back.
*   **SEND_UNKNOWN:** The message is a transactional message and is not committed.
*   **SEND_DELAY:** The message is a scheduled or delayed message and is waiting to be sent at the specified point in time.', example='SEND_SUCCESS'),
        subList?: {
          subMapDo?: [ 
          {
            clientList?: {
              subClientInfoDo?: [ 
              {
                clientHost?: string(name='ClientHost', description='The address of the consumer.', example='30.5.**.**'),
                costTime?: int32(name='CostTime', description='The period of time that the system took to consume the message. Unit: milliseconds.', example='43'),
                reconsumeTimes?: int32(name='ReconsumeTimes', description='The number of attempts that the Message Queue for Apache RocketMQ broker tried to send the message to the consumer.', example='1'),
                status?: string(name='Status', description='Indicates whether the message is consumed. Valid values:

*   **CONSUME_FAILED**: The message failed to be consumed.
*   **CONSUME_SUCCESS**: The message is consumed.
*   **CONSUME_NOT_RETURN:** No responses are returned.
*   **SEND_UNKNOWN:** The message is a transactional message and is not committed.
*   **SEND_DELAY:** The message is a scheduled or delayed message and is waiting to be consumed at the specified point in time.', example='CONSUME_SUCCESS'),
                subGroupName?: string(name='SubGroupName', description='The ID of the group that contains the consumer.', example='GID_test'),
                subTime?: long(name='SubTime', description='The earliest point in time when the message was consumed.', example='1570851590511'),
              }
            ](name='SubClientInfoDo')
            }(name='ClientList', description='The information about message consumption by consumers in the group.'),
            failCount?: int32(name='FailCount', description='The number of consumption failures.', example='0'),
            subGroupName?: string(name='SubGroupName', description='The ID of the consumer group.', example='GID_test'),
            successCount?: int32(name='SuccessCount', description='The number of successful consumptions.', example='1'),
          }
        ](name='SubMapDo')
        }(name='SubList', description='The consumption traces of the message.'),
        tag?: string(name='Tag', description='The tag of the message.', example='TagA'),
        topic?: string(name='Topic', description='The topic in which the message is stored.', example='test'),
      }
    ](name='TraceMapDo')
    }(name='TraceList', description='The details of the message trace.'),
    updateTime?: long(name='UpdateTime', description='The most recent point in time when the task was updated.', example='1570966877000'),
    userId?: string(name='UserId', description='The ID of the user who created the task.', example='27296756265288****'),
  }(name='TraceData', description='The details of the message trace.'),
}

model OnsTraceGetResultResponse = {
  headers: map[string]string(name='headers'),
  body: OnsTraceGetResultResponseBody(name='body'),
}

/**
  * ## Usage notes
  * *   Before you call this operation to query the details of the trace of a message, you must create a task to query the trace of the message based on the message ID or message key and obtains the task ID. Then, you can call this operation to query the details of the message trace based on the task ID. You can call the [OnsTraceQueryByMsgId](~~59830~~) operation or the [OnsTraceQueryByMsgKey](~~59831~~) operation to create a task to query the trace of the message and obtain the task ID from the **QueryId** response parameter.
  * *   A trace query task is time-consuming. If you call this operation to query the details immediately after you create a trace query task, the results may be empty. In this case, we recommend that you try again later.
  *
 */
async function onsTraceGetResult(request: OnsTraceGetResultRequest): OnsTraceGetResultResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OnsTraceGetResult', 'POST', '/', 'json', false, 'json', request);
}

model OnsTraceQueryByMsgIdRequest {
  beginTime: long(name='BeginTime', description='The beginning of the time range to query. The value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.', example='1570852800000', position='Query'),
  endTime: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.', example='1570968000000', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the Message Queue for Apache RocketMQ instance which contains the specified topic.', example='MQ_INST_111111111111_DOxxxxxx', position='Query'),
  msgId: string(name='MsgId', description='The ID of the message that you want to query.', example='1E05791C117818B4AAC23B1BB0CE****', position='Query'),
  topic: string(name='Topic', description='The topic in which the message you want to query is stored.', example='test', position='Query'),
}

model OnsTraceQueryByMsgIdResponseBody = {
  queryId?: string(name='QueryId', description='The ID of the query task. You can call the [OnsTraceGetResult](~~59832~~) operation to query the details of the message trace based on the task ID.', example='272967562652883649157096685****'),
  requestId?: string(name='RequestId', description='The ID of the request. The system generates a unique ID for each request. You can troubleshoot issues based on the request ID.', example='B93332A3-160D-404F-880F-1F8736D1****'),
}

model OnsTraceQueryByMsgIdResponse = {
  headers: map[string]string(name='headers'),
  body: OnsTraceQueryByMsgIdResponseBody(name='body'),
}

/**
  * ## Note
  * If you want to query the trace of a message based on the message ID, you can call this operation to create a query task. After you obtain the task ID, you can call the [OnsTraceGetResult](~~59832~~) operation to query the details of the message trace based on the task ID.
  *
 */
async function onsTraceQueryByMsgId(request: OnsTraceQueryByMsgIdRequest): OnsTraceQueryByMsgIdResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OnsTraceQueryByMsgId', 'POST', '/', 'json', false, 'json', request);
}

model OnsTraceQueryByMsgKeyRequest {
  beginTime: long(name='BeginTime', description='The beginning of the time range to query. The value of this parameter is a UNIX timestamp in milliseconds.', example='1570852800000', position='Query'),
  endTime: long(name='EndTime', description='The end of the time range to query. The value of this parameter is a UNIX timestamp in milliseconds.', example='1570968000000', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the Message Queue for Apache RocketMQ instance that contains the specified topic.', example='MQ_INST_111111111111_DOxxxxxx', position='Query'),
  msgKey: string(name='MsgKey', description='The key of the messages that you want to query.', example='ORDERID_100', position='Query'),
  topic: string(name='Topic', description='The topic that contains the messages you want to query.', example='test', position='Query'),
}

model OnsTraceQueryByMsgKeyResponseBody = {
  queryId?: string(name='QueryId', description='The ID of the query task. You can call the [OnsTraceGetResult](~~59832~~) operation to query the details of the message trace based on the task ID.', example='272967562652883649157096685****'),
  requestId?: string(name='RequestId', description='The ID of the request. This parameter is a common parameter. Each request has a unique ID. You can use this ID to troubleshoot issues.', example='F8654231-122A-4DBD-801F-38E35538****'),
}

model OnsTraceQueryByMsgKeyResponse = {
  headers: map[string]string(name='headers'),
  body: OnsTraceQueryByMsgKeyResponseBody(name='body'),
}

/**
  * > : The API operations that are provided by Alibaba Cloud are used to manage and query resources of Alibaba Cloud services. We recommend that you integrate these API operations only in management systems. Do not use these API operations in the core system of messaging services. Otherwise, system risks may occur.
  * If you obtain the key of a message and want to query the trace of the message, you can call this operation to create a query task. After you obtain the task ID, you can call the OnsTraceGetResult operation to query the details of the message trace based on the task ID.
  *
 */
async function onsTraceQueryByMsgKey(request: OnsTraceQueryByMsgKeyRequest): OnsTraceQueryByMsgKeyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OnsTraceQueryByMsgKey', 'POST', '/', 'json', false, 'json', request);
}

model OnsTrendGroupOutputTpsRequest {
  beginTime: long(name='BeginTime', description='The beginning of the time range to query. The value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.', example='1570852800000', position='Query'),
  endTime: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.', example='1570868400000', position='Query'),
  groupId: string(name='GroupId', description='The ID of the consumer group that you want to query.', example='GID_test', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the Message Queue for Apache RocketMQ instance which contains the specified consumer group.', example='MQ_INST_111111111111_DOxxxxxx', position='Query'),
  period?: long(name='Period', description='The sampling period. Unit: minutes. Valid values: 1, 5, and 10.', example='10', position='Query'),
  topic: string(name='Topic', description='The name of the topic that you want to query.', example='test', position='Query'),
  type: int32(name='Type', description='The type of information that you want to query. Valid values:

*   **0**: the number of messages that are consumed during each sampling period.
*   **1**: the TPS for message consumption during each sampling period.', example='0', position='Query'),
}

model OnsTrendGroupOutputTpsResponseBody = {
  data?: {
    records?: {
      statsDataDo?: [ 
      {
        x?: long(name='X', description='Indicates the timestamp. The value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.', example='1570867800000'),
        y?: float(name='Y', description='Indicates the TPS for message consumption or the number of messages that are consumed.', example='0'),
      }
    ](name='StatsDataDo')
    }(name='Records', description='The data set that is returned based on sampling period.'),
    title?: string(name='Title', description='The name of the table that stores the data.', example='MQ_INST_111111111111_DOxxxxxx%test@MQ_INST_111111111111_DOxxxxxx%GID_test trend of received messages'),
    xUnit?: string(name='XUnit', description='The unit of the timestamp. Unit: milliseconds.', example='time'),
    yUnit?: string(name='YUnit', description='The unit of the value of the Y parameter.', example='msg'),
  }(name='Data', description='The data that is returned.'),
  requestId?: string(name='RequestId', description='The ID of the request. The system generates a unique ID for each request. You can troubleshoot issues based on the request ID.', example='CE57AEDC-8FD2-43ED-8E3B-1F878077****'),
}

model OnsTrendGroupOutputTpsResponse = {
  headers: map[string]string(name='headers'),
  body: OnsTrendGroupOutputTpsResponseBody(name='body'),
}

/**
  * ## Note
  * You can call this operation to query the following statistics that are collected in the production environment:
  * *   The number of messages that are consumed during each sampling period
  * *   The transactions per second (TPS) for message consumption during each sampling period
  * >  If your application publishes a small number of messages and does not publish messages at a specific interval, we recommend that you query the number of messages that are consumed during each sampling period because the statistics of TPS may not show a clear change trend.
  *
 */
async function onsTrendGroupOutputTps(request: OnsTrendGroupOutputTpsRequest): OnsTrendGroupOutputTpsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OnsTrendGroupOutputTps', 'POST', '/', 'json', false, 'json', request);
}

model OnsTrendTopicInputTpsRequest {
  beginTime: long(name='BeginTime', description='The beginning of the time range to query. The value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.', example='1570852800000', position='Query'),
  endTime: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.', example='1570868400000', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the Message Queue for Apache RocketMQ instance which contains the topic you want to query.', example='MQ_INST_111111111111_DOxxxxxx', position='Query'),
  period?: long(name='Period', description='The sampling period. Unit: minutes. Valid values: 1, 5, and 10.', example='10', position='Query'),
  topic: string(name='Topic', description='The name of the topic that you want to query.', example='test', position='Query'),
  type: int32(name='Type', description='The type of information that you want to query. Valid values:

*   **0**: the number of the messages that are published to the specified topic during each sampling period.
*   **1**: the TPS for message publishing to the specified topic during each sampling period.', example='0', position='Query'),
}

model OnsTrendTopicInputTpsResponseBody = {
  data?: {
    records?: {
      statsDataDo?: [ 
      {
        x?: long(name='X', description='Indicates the timestamp. The value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.', example='1570852800000'),
        y?: float(name='Y', description='Indicates the TPS for message publishing or the number of messages that are published to the topic.', example='0'),
      }
    ](name='StatsDataDo')
    }(name='Records', description='The data set that is returned based on each sampling period.'),
    title?: string(name='Title', description='The name of the table that stores the data.', example='MQ_INST_111111111111_DOxxxxxx%test trend of received messages'),
    xUnit?: string(name='XUnit', description='The unit of the timestamp. Unit: milliseconds.', example='time'),
    yUnit?: string(name='YUnit', description='The unit of the value of the Y parameter.', example='msg'),
  }(name='Data', description='The data that is returned.'),
  requestId?: string(name='RequestId', description='The ID of the request. The system generates a unique ID for each request. You can troubleshoot issues based on the request ID.', example='E213AD8A-0730-4B3D-A35A-340DA47D****'),
}

model OnsTrendTopicInputTpsResponse = {
  headers: map[string]string(name='headers'),
  body: OnsTrendTopicInputTpsResponseBody(name='body'),
}

/**
  * ## Note
  * You can call this operation to query the statistics of messages that are published to a specified topic in the production environment. You can obtain the number of messages that are published to the topic or the transactions per second (TPS) for message publishing during each sampling period within a specified time range.
  * >  If your application publishes a small number of messages and does not publish messages at a specific interval, we recommend that you query the number of messages that are published to the topic during each sampling period because the statistics of TPS may not show a clear change trend.
  *
 */
async function onsTrendTopicInputTps(request: OnsTrendTopicInputTpsRequest): OnsTrendTopicInputTpsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OnsTrendTopicInputTps', 'POST', '/', 'json', false, 'json', request);
}

model OpenOnsServiceRequest {
}

model OpenOnsServiceResponseBody = {
  orderId?: string(name='OrderId', description='The ID of the order.', example='2068689****0272'),
  requestId?: string(name='RequestId', description='The ID of the request. This parameter is a common parameter. Each request has a unique ID. You can use this ID to troubleshoot issues.', example='8C5B4603-8977-4513-AB60-9C3E2F88****'),
}

model OpenOnsServiceResponse = {
  headers: map[string]string(name='headers'),
  body: OpenOnsServiceResponseBody(name='body'),
}

/**
  * > : The API operations that are provided by Alibaba Cloud are used to manage and query resources of Alibaba Cloud services. We recommend that you integrate these API operations only in management systems. Do not use these API operations in the core system of messaging services. Otherwise, system risks may occur.
  * You can call this operation when you use Message Queue for Apache RocketMQ for the first time. You can use Message Queue for Apache RocketMQ only after this service is activated.
  * The Message Queue for Apache RocketMQ service can be activated only in the China (Hangzhou) region. Service activation is not billed.
  *
 */
async function openOnsService(request: OpenOnsServiceRequest): OpenOnsServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OpenOnsService', 'POST', '/', 'json', false, 'json', request);
}

model TagResourcesRequest {
  instanceId?: string(name='InstanceId', description='The ID of the Message Queue for Apache RocketMQ instance which contains the resource to which you want to attach tags.

> : This parameter is required when you attach tags to a topic or a group.', example='MQ_INST_188077086902****_BXSuW61e', position='Query'),
  resourceId: [ string ](name='ResourceId', description='The list of resource IDs.', example='TopicA', position='Query'),
  resourceType: string(name='ResourceType', description='The type of the resource to which you want to attach tags. Valid values:

*   **INSTANCE**
*   **TOPIC**
*   **GROUP**', example='TOPIC', position='Query'),
  tag: [ 
    {
      key: string(name='Key', description='The key of the tag that you want to attach to the specified resource. If you configure this parameter, you must also configure the **Tag.N.Key** parameter.****

*   The value of N can be an integer value from 1 to 20.
*   The value of this parameter cannot be an empty string.
*   The tag key can be up to 128 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.', example='FinanceDept'),
      value: string(name='Value', description='The value of the tag that you want to attach to the specified resource. If you configure this parameter, you must also configure the **Tag.N.Key** parameter.****

*   The value of N can be an integer value from 1 to 20.
*   The value of this parameter can be an empty string.
*   The tag key can be up to 128 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.', example='FinanceJoshua'),
    }
  ](name='Tag', description='The list of tags that are attached to the resources.', position='Query'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request. This parameter is a common parameter. Each request has a unique ID. You can use this ID to troubleshoot issues.', example='301D2CBE-66F8-403D-AEC0-82582478****'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: TagResourcesResponseBody(name='body'),
}

/**
  * > : The API operations that are provided by Alibaba Cloud are used to manage and query resources of Alibaba Cloud services. We recommend that you integrate these API operations only in management systems. Do not use these API operations in the core system of messaging services. Otherwise, system risks may occur.
  * You can call this operation to attach tags to a source. You can use tags to classify resources in Message Queue for Apache RocketMQ. This can help you aggregate and search resources in an efficient manner.
  *
 */
async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'TagResources', 'POST', '/', 'json', false, 'json', request);
}

model UntagResourcesRequest {
  all?: boolean(name='All', description='Specifies whether to remove all tags that are attached to the specified resource. This parameter takes effect only when the **TagKey.N** parameter is not configured. Default value: **false**.', example='false', position='Query'),
  instanceId?: string(name='InstanceId', description='This parameter is required when you detach tags from a topic or a group.', example='MQ_INST_188077086902****_BX4jvZZG', position='Query'),
  resourceId: [ string ](name='ResourceId', description='The list of resource IDs.', example='TopicA', position='Query'),
  resourceType: string(name='ResourceType', description='The type of the resources from which you want to detach tags. Valid values:

*   **INSTANCE**
*   **TOPIC**
*   **GROUP**', example='TOPIC', position='Query'),
  tagKey?: [ string ](name='TagKey', description='The tag keys of the resource.', example='CartService', position='Query'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request. This parameter is a common parameter. Each request has a unique ID. You can use this ID to troubleshoot issues.', example='19780F2E-7841-4E0F-A5D9-C64A0530****'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: UntagResourcesResponseBody(name='body'),
}

/**
  * > : The API operations that are provided by Alibaba Cloud are used to manage and query resources of Alibaba Cloud services. We recommend that you integrate these API operations only in management systems. Do not use these API operations in the core system of messaging services. Otherwise, system risks may occur.
  *
 */
async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UntagResources', 'POST', '/', 'json', false, 'json', request);
}

