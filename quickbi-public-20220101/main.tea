/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('quickbi-public', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AddDataLevelPermissionRuleUsersRequest {
  addUserModel?: string(name='AddUserModel'),
}

model AddDataLevelPermissionRuleUsersResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model AddDataLevelPermissionRuleUsersResponse = {
  headers: map[string]string(name='headers'),
  body: AddDataLevelPermissionRuleUsersResponseBody(name='body'),
}

async function addDataLevelPermissionRuleUsersWithOptions(request: AddDataLevelPermissionRuleUsersRequest, runtime: Util.RuntimeOptions): AddDataLevelPermissionRuleUsersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addUserModel)) {
    query['AddUserModel'] = request.addUserModel;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddDataLevelPermissionRuleUsers',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addDataLevelPermissionRuleUsers(request: AddDataLevelPermissionRuleUsersRequest): AddDataLevelPermissionRuleUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return addDataLevelPermissionRuleUsersWithOptions(request, runtime);
}

model AddDataLevelPermissionWhiteListRequest {
  cubeId?: string(name='CubeId'),
  operateType?: string(name='OperateType'),
  ruleType?: string(name='RuleType'),
  targetIds?: string(name='TargetIds'),
  targetType?: string(name='TargetType'),
}

model AddDataLevelPermissionWhiteListResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model AddDataLevelPermissionWhiteListResponse = {
  headers: map[string]string(name='headers'),
  body: AddDataLevelPermissionWhiteListResponseBody(name='body'),
}

async function addDataLevelPermissionWhiteListWithOptions(request: AddDataLevelPermissionWhiteListRequest, runtime: Util.RuntimeOptions): AddDataLevelPermissionWhiteListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cubeId)) {
    query['CubeId'] = request.cubeId;
  }
  if (!Util.isUnset(request.operateType)) {
    query['OperateType'] = request.operateType;
  }
  if (!Util.isUnset(request.ruleType)) {
    query['RuleType'] = request.ruleType;
  }
  if (!Util.isUnset(request.targetIds)) {
    query['TargetIds'] = request.targetIds;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddDataLevelPermissionWhiteList',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addDataLevelPermissionWhiteList(request: AddDataLevelPermissionWhiteListRequest): AddDataLevelPermissionWhiteListResponse {
  var runtime = new Util.RuntimeOptions{};
  return addDataLevelPermissionWhiteListWithOptions(request, runtime);
}

model AddShareReportRequest {
  authPoint?: int32(name='AuthPoint'),
  expireDate?: long(name='ExpireDate'),
  shareToId?: string(name='ShareToId'),
  shareToType?: int32(name='ShareToType'),
  worksId?: string(name='WorksId'),
}

model AddShareReportResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model AddShareReportResponse = {
  headers: map[string]string(name='headers'),
  body: AddShareReportResponseBody(name='body'),
}

async function addShareReportWithOptions(request: AddShareReportRequest, runtime: Util.RuntimeOptions): AddShareReportResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.authPoint)) {
    query['AuthPoint'] = request.authPoint;
  }
  if (!Util.isUnset(request.expireDate)) {
    query['ExpireDate'] = request.expireDate;
  }
  if (!Util.isUnset(request.shareToId)) {
    query['ShareToId'] = request.shareToId;
  }
  if (!Util.isUnset(request.shareToType)) {
    query['ShareToType'] = request.shareToType;
  }
  if (!Util.isUnset(request.worksId)) {
    query['WorksId'] = request.worksId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddShareReport',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addShareReport(request: AddShareReportRequest): AddShareReportResponse {
  var runtime = new Util.RuntimeOptions{};
  return addShareReportWithOptions(request, runtime);
}

model AddUserRequest {
  accountName?: string(name='AccountName'),
  adminUser?: boolean(name='AdminUser'),
  authAdminUser?: boolean(name='AuthAdminUser'),
  nickName?: string(name='NickName'),
  userType?: int32(name='UserType'),
}

model AddUserResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    accountName?: string(name='AccountName'),
    adminUser?: boolean(name='AdminUser'),
    authAdminUser?: boolean(name='AuthAdminUser'),
    nickName?: string(name='NickName'),
    userId?: string(name='UserId'),
    userType?: int32(name='UserType'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model AddUserResponse = {
  headers: map[string]string(name='headers'),
  body: AddUserResponseBody(name='body'),
}

async function addUserWithOptions(request: AddUserRequest, runtime: Util.RuntimeOptions): AddUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.adminUser)) {
    query['AdminUser'] = request.adminUser;
  }
  if (!Util.isUnset(request.authAdminUser)) {
    query['AuthAdminUser'] = request.authAdminUser;
  }
  if (!Util.isUnset(request.nickName)) {
    query['NickName'] = request.nickName;
  }
  if (!Util.isUnset(request.userType)) {
    query['UserType'] = request.userType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddUser',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addUser(request: AddUserRequest): AddUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return addUserWithOptions(request, runtime);
}

model AddUserGroupMemberRequest {
  userGroupId?: string(name='UserGroupId'),
  userIdList?: string(name='UserIdList'),
}

model AddUserGroupMemberResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model AddUserGroupMemberResponse = {
  headers: map[string]string(name='headers'),
  body: AddUserGroupMemberResponseBody(name='body'),
}

async function addUserGroupMemberWithOptions(request: AddUserGroupMemberRequest, runtime: Util.RuntimeOptions): AddUserGroupMemberResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.userGroupId)) {
    query['UserGroupId'] = request.userGroupId;
  }
  if (!Util.isUnset(request.userIdList)) {
    query['UserIdList'] = request.userIdList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddUserGroupMember',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addUserGroupMember(request: AddUserGroupMemberRequest): AddUserGroupMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  return addUserGroupMemberWithOptions(request, runtime);
}

model AddUserGroupMembersRequest {
  userGroupIds?: string(name='UserGroupIds'),
  userId?: string(name='UserId'),
}

model AddUserGroupMembersResponseBody = {
  requestId?: string(name='RequestId', description='请求ID。'),
  result?: boolean(name='Result', description='接口执行结果。取值范围：true：请求成功false：请求失败'),
  success?: boolean(name='Success', description='是否请求成功。取值范围：true：请求成功false：请求失败'),
}

model AddUserGroupMembersResponse = {
  headers: map[string]string(name='headers'),
  body: AddUserGroupMembersResponseBody(name='body'),
}

async function addUserGroupMembersWithOptions(request: AddUserGroupMembersRequest, runtime: Util.RuntimeOptions): AddUserGroupMembersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.userGroupIds)) {
    query['UserGroupIds'] = request.userGroupIds;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddUserGroupMembers',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addUserGroupMembers(request: AddUserGroupMembersRequest): AddUserGroupMembersResponse {
  var runtime = new Util.RuntimeOptions{};
  return addUserGroupMembersWithOptions(request, runtime);
}

model AddUserTagMetaRequest {
  tagDescription?: string(name='TagDescription'),
  tagName?: string(name='TagName'),
}

model AddUserTagMetaResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
  success?: boolean(name='Success'),
}

model AddUserTagMetaResponse = {
  headers: map[string]string(name='headers'),
  body: AddUserTagMetaResponseBody(name='body'),
}

async function addUserTagMetaWithOptions(request: AddUserTagMetaRequest, runtime: Util.RuntimeOptions): AddUserTagMetaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.tagDescription)) {
    query['TagDescription'] = request.tagDescription;
  }
  if (!Util.isUnset(request.tagName)) {
    query['TagName'] = request.tagName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddUserTagMeta',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addUserTagMeta(request: AddUserTagMetaRequest): AddUserTagMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  return addUserTagMetaWithOptions(request, runtime);
}

model AddUserToWorkspaceRequest {
  roleId?: long(name='RoleId'),
  userId?: string(name='UserId'),
  workspaceId?: string(name='WorkspaceId'),
}

model AddUserToWorkspaceResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model AddUserToWorkspaceResponse = {
  headers: map[string]string(name='headers'),
  body: AddUserToWorkspaceResponseBody(name='body'),
}

async function addUserToWorkspaceWithOptions(request: AddUserToWorkspaceRequest, runtime: Util.RuntimeOptions): AddUserToWorkspaceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.roleId)) {
    query['RoleId'] = request.roleId;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddUserToWorkspace',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addUserToWorkspace(request: AddUserToWorkspaceRequest): AddUserToWorkspaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return addUserToWorkspaceWithOptions(request, runtime);
}

model AddWorkspaceUsersRequest {
  roleId?: long(name='RoleId'),
  userIds?: string(name='UserIds'),
  workspaceId?: string(name='WorkspaceId'),
}

model AddWorkspaceUsersResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    failure?: int32(name='Failure'),
    failureDetail?: map[string]any(name='FailureDetail'),
    success?: int32(name='Success'),
    total?: int32(name='Total'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model AddWorkspaceUsersResponse = {
  headers: map[string]string(name='headers'),
  body: AddWorkspaceUsersResponseBody(name='body'),
}

async function addWorkspaceUsersWithOptions(request: AddWorkspaceUsersRequest, runtime: Util.RuntimeOptions): AddWorkspaceUsersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.roleId)) {
    query['RoleId'] = request.roleId;
  }
  if (!Util.isUnset(request.userIds)) {
    query['UserIds'] = request.userIds;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddWorkspaceUsers',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addWorkspaceUsers(request: AddWorkspaceUsersRequest): AddWorkspaceUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return addWorkspaceUsersWithOptions(request, runtime);
}

model AuthorizeMenuRequest {
  authPointsValue?: int32(name='AuthPointsValue'),
  dataPortalId?: string(name='DataPortalId'),
  menuIds?: string(name='MenuIds'),
  userGroupIds?: string(name='UserGroupIds'),
  userIds?: string(name='UserIds'),
}

model AuthorizeMenuResponseBody = {
  requestId?: string(name='RequestId'),
  result?: int32(name='Result'),
  success?: boolean(name='Success'),
}

model AuthorizeMenuResponse = {
  headers: map[string]string(name='headers'),
  body: AuthorizeMenuResponseBody(name='body'),
}

async function authorizeMenuWithOptions(request: AuthorizeMenuRequest, runtime: Util.RuntimeOptions): AuthorizeMenuResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.authPointsValue)) {
    query['AuthPointsValue'] = request.authPointsValue;
  }
  if (!Util.isUnset(request.dataPortalId)) {
    query['DataPortalId'] = request.dataPortalId;
  }
  if (!Util.isUnset(request.menuIds)) {
    query['MenuIds'] = request.menuIds;
  }
  if (!Util.isUnset(request.userGroupIds)) {
    query['UserGroupIds'] = request.userGroupIds;
  }
  if (!Util.isUnset(request.userIds)) {
    query['UserIds'] = request.userIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AuthorizeMenu',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function authorizeMenu(request: AuthorizeMenuRequest): AuthorizeMenuResponse {
  var runtime = new Util.RuntimeOptions{};
  return authorizeMenuWithOptions(request, runtime);
}

model CancelAuthorizationMenuRequest {
  dataPortalId?: string(name='DataPortalId'),
  menuIds?: string(name='MenuIds'),
  userGroupIds?: string(name='UserGroupIds'),
  userIds?: string(name='UserIds'),
}

model CancelAuthorizationMenuResponseBody = {
  requestId?: string(name='RequestId'),
  result?: int32(name='Result'),
  success?: boolean(name='Success'),
}

model CancelAuthorizationMenuResponse = {
  headers: map[string]string(name='headers'),
  body: CancelAuthorizationMenuResponseBody(name='body'),
}

async function cancelAuthorizationMenuWithOptions(request: CancelAuthorizationMenuRequest, runtime: Util.RuntimeOptions): CancelAuthorizationMenuResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dataPortalId)) {
    query['DataPortalId'] = request.dataPortalId;
  }
  if (!Util.isUnset(request.menuIds)) {
    query['MenuIds'] = request.menuIds;
  }
  if (!Util.isUnset(request.userGroupIds)) {
    query['UserGroupIds'] = request.userGroupIds;
  }
  if (!Util.isUnset(request.userIds)) {
    query['UserIds'] = request.userIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelAuthorizationMenu',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cancelAuthorizationMenu(request: CancelAuthorizationMenuRequest): CancelAuthorizationMenuResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelAuthorizationMenuWithOptions(request, runtime);
}

model CancelCollectionRequest {
  userId?: string(name='UserId'),
  worksId?: string(name='WorksId'),
}

model CancelCollectionResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model CancelCollectionResponse = {
  headers: map[string]string(name='headers'),
  body: CancelCollectionResponseBody(name='body'),
}

async function cancelCollectionWithOptions(request: CancelCollectionRequest, runtime: Util.RuntimeOptions): CancelCollectionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  if (!Util.isUnset(request.worksId)) {
    query['WorksId'] = request.worksId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelCollection',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cancelCollection(request: CancelCollectionRequest): CancelCollectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelCollectionWithOptions(request, runtime);
}

model CancelReportShareRequest {
  reportId?: string(name='ReportId'),
  shareToIds?: string(name='ShareToIds'),
  shareToType?: int32(name='ShareToType'),
}

model CancelReportShareResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model CancelReportShareResponse = {
  headers: map[string]string(name='headers'),
  body: CancelReportShareResponseBody(name='body'),
}

async function cancelReportShareWithOptions(request: CancelReportShareRequest, runtime: Util.RuntimeOptions): CancelReportShareResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.reportId)) {
    query['ReportId'] = request.reportId;
  }
  if (!Util.isUnset(request.shareToIds)) {
    query['ShareToIds'] = request.shareToIds;
  }
  if (!Util.isUnset(request.shareToType)) {
    query['ShareToType'] = request.shareToType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelReportShare',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cancelReportShare(request: CancelReportShareRequest): CancelReportShareResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelReportShareWithOptions(request, runtime);
}

model ChangeVisibilityModelRequest {
  dataPortalId?: string(name='DataPortalId'),
  menuIds?: string(name='MenuIds'),
  showOnlyWithAccess?: boolean(name='ShowOnlyWithAccess'),
}

model ChangeVisibilityModelResponseBody = {
  requestId?: string(name='RequestId'),
  result?: int32(name='Result'),
  success?: boolean(name='Success'),
}

model ChangeVisibilityModelResponse = {
  headers: map[string]string(name='headers'),
  body: ChangeVisibilityModelResponseBody(name='body'),
}

async function changeVisibilityModelWithOptions(request: ChangeVisibilityModelRequest, runtime: Util.RuntimeOptions): ChangeVisibilityModelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dataPortalId)) {
    query['DataPortalId'] = request.dataPortalId;
  }
  if (!Util.isUnset(request.menuIds)) {
    query['MenuIds'] = request.menuIds;
  }
  if (!Util.isUnset(request.showOnlyWithAccess)) {
    query['ShowOnlyWithAccess'] = request.showOnlyWithAccess;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ChangeVisibilityModel',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function changeVisibilityModel(request: ChangeVisibilityModelRequest): ChangeVisibilityModelResponse {
  var runtime = new Util.RuntimeOptions{};
  return changeVisibilityModelWithOptions(request, runtime);
}

model CheckReadableRequest {
  userId?: string(name='UserId'),
  worksId?: string(name='WorksId'),
}

model CheckReadableResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model CheckReadableResponse = {
  headers: map[string]string(name='headers'),
  body: CheckReadableResponseBody(name='body'),
}

async function checkReadableWithOptions(request: CheckReadableRequest, runtime: Util.RuntimeOptions): CheckReadableResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  if (!Util.isUnset(request.worksId)) {
    query['WorksId'] = request.worksId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckReadable',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkReadable(request: CheckReadableRequest): CheckReadableResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkReadableWithOptions(request, runtime);
}

model CreateTicketRequest {
  accountName?: string(name='AccountName'),
  accountType?: int32(name='AccountType'),
  cmptId?: string(name='CmptId'),
  expireTime?: int32(name='ExpireTime'),
  globalParam?: string(name='GlobalParam'),
  ticketNum?: int32(name='TicketNum'),
  userId?: string(name='UserId'),
  watermarkParam?: string(name='WatermarkParam'),
  worksId?: string(name='WorksId'),
}

model CreateTicketResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
  success?: boolean(name='Success'),
}

model CreateTicketResponse = {
  headers: map[string]string(name='headers'),
  body: CreateTicketResponseBody(name='body'),
}

async function createTicketWithOptions(request: CreateTicketRequest, runtime: Util.RuntimeOptions): CreateTicketResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.accountType)) {
    query['AccountType'] = request.accountType;
  }
  if (!Util.isUnset(request.cmptId)) {
    query['CmptId'] = request.cmptId;
  }
  if (!Util.isUnset(request.expireTime)) {
    query['ExpireTime'] = request.expireTime;
  }
  if (!Util.isUnset(request.globalParam)) {
    query['GlobalParam'] = request.globalParam;
  }
  if (!Util.isUnset(request.ticketNum)) {
    query['TicketNum'] = request.ticketNum;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  if (!Util.isUnset(request.watermarkParam)) {
    query['WatermarkParam'] = request.watermarkParam;
  }
  if (!Util.isUnset(request.worksId)) {
    query['WorksId'] = request.worksId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateTicket',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createTicket(request: CreateTicketRequest): CreateTicketResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTicketWithOptions(request, runtime);
}

model CreateUserGroupRequest {
  parentUserGroupId?: string(name='ParentUserGroupId'),
  userGroupDescription?: string(name='UserGroupDescription'),
  userGroupId?: string(name='UserGroupId'),
  userGroupName?: string(name='UserGroupName'),
}

model CreateUserGroupResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
  success?: boolean(name='Success'),
}

model CreateUserGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateUserGroupResponseBody(name='body'),
}

async function createUserGroupWithOptions(request: CreateUserGroupRequest, runtime: Util.RuntimeOptions): CreateUserGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.parentUserGroupId)) {
    query['ParentUserGroupId'] = request.parentUserGroupId;
  }
  if (!Util.isUnset(request.userGroupDescription)) {
    query['UserGroupDescription'] = request.userGroupDescription;
  }
  if (!Util.isUnset(request.userGroupId)) {
    query['UserGroupId'] = request.userGroupId;
  }
  if (!Util.isUnset(request.userGroupName)) {
    query['UserGroupName'] = request.userGroupName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateUserGroup',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createUserGroup(request: CreateUserGroupRequest): CreateUserGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createUserGroupWithOptions(request, runtime);
}

model DelayTicketExpireTimeRequest {
  expireTime?: int32(name='ExpireTime'),
  ticket?: string(name='Ticket'),
}

model DelayTicketExpireTimeResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model DelayTicketExpireTimeResponse = {
  headers: map[string]string(name='headers'),
  body: DelayTicketExpireTimeResponseBody(name='body'),
}

async function delayTicketExpireTimeWithOptions(request: DelayTicketExpireTimeRequest, runtime: Util.RuntimeOptions): DelayTicketExpireTimeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.expireTime)) {
    query['ExpireTime'] = request.expireTime;
  }
  if (!Util.isUnset(request.ticket)) {
    query['Ticket'] = request.ticket;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DelayTicketExpireTime',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function delayTicketExpireTime(request: DelayTicketExpireTimeRequest): DelayTicketExpireTimeResponse {
  var runtime = new Util.RuntimeOptions{};
  return delayTicketExpireTimeWithOptions(request, runtime);
}

model DeleteDataLevelPermissionRuleUsersRequest {
  deleteUserModel?: string(name='DeleteUserModel'),
}

model DeleteDataLevelPermissionRuleUsersResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model DeleteDataLevelPermissionRuleUsersResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDataLevelPermissionRuleUsersResponseBody(name='body'),
}

async function deleteDataLevelPermissionRuleUsersWithOptions(request: DeleteDataLevelPermissionRuleUsersRequest, runtime: Util.RuntimeOptions): DeleteDataLevelPermissionRuleUsersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deleteUserModel)) {
    query['DeleteUserModel'] = request.deleteUserModel;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDataLevelPermissionRuleUsers',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDataLevelPermissionRuleUsers(request: DeleteDataLevelPermissionRuleUsersRequest): DeleteDataLevelPermissionRuleUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDataLevelPermissionRuleUsersWithOptions(request, runtime);
}

model DeleteDataLevelRuleConfigRequest {
  cubeId?: string(name='CubeId'),
  ruleId?: string(name='RuleId'),
}

model DeleteDataLevelRuleConfigResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model DeleteDataLevelRuleConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDataLevelRuleConfigResponseBody(name='body'),
}

async function deleteDataLevelRuleConfigWithOptions(request: DeleteDataLevelRuleConfigRequest, runtime: Util.RuntimeOptions): DeleteDataLevelRuleConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cubeId)) {
    query['CubeId'] = request.cubeId;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDataLevelRuleConfig',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDataLevelRuleConfig(request: DeleteDataLevelRuleConfigRequest): DeleteDataLevelRuleConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDataLevelRuleConfigWithOptions(request, runtime);
}

model DeleteTicketRequest {
  ticket?: string(name='Ticket'),
}

model DeleteTicketResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model DeleteTicketResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteTicketResponseBody(name='body'),
}

async function deleteTicketWithOptions(request: DeleteTicketRequest, runtime: Util.RuntimeOptions): DeleteTicketResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ticket)) {
    query['Ticket'] = request.ticket;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteTicket',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteTicket(request: DeleteTicketRequest): DeleteTicketResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTicketWithOptions(request, runtime);
}

model DeleteUserRequest {
  transferUserId?: string(name='TransferUserId'),
  userId?: string(name='UserId'),
}

model DeleteUserResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model DeleteUserResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteUserResponseBody(name='body'),
}

async function deleteUserWithOptions(request: DeleteUserRequest, runtime: Util.RuntimeOptions): DeleteUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.transferUserId)) {
    query['TransferUserId'] = request.transferUserId;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteUser',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteUser(request: DeleteUserRequest): DeleteUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteUserWithOptions(request, runtime);
}

model DeleteUserFromWorkspaceRequest {
  userId?: string(name='UserId'),
  workspaceId?: string(name='WorkspaceId'),
}

model DeleteUserFromWorkspaceResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model DeleteUserFromWorkspaceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteUserFromWorkspaceResponseBody(name='body'),
}

async function deleteUserFromWorkspaceWithOptions(request: DeleteUserFromWorkspaceRequest, runtime: Util.RuntimeOptions): DeleteUserFromWorkspaceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteUserFromWorkspace',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteUserFromWorkspace(request: DeleteUserFromWorkspaceRequest): DeleteUserFromWorkspaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteUserFromWorkspaceWithOptions(request, runtime);
}

model DeleteUserGroupRequest {
  userGroupId?: string(name='UserGroupId'),
}

model DeleteUserGroupResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model DeleteUserGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteUserGroupResponseBody(name='body'),
}

async function deleteUserGroupWithOptions(request: DeleteUserGroupRequest, runtime: Util.RuntimeOptions): DeleteUserGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.userGroupId)) {
    query['UserGroupId'] = request.userGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteUserGroup',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteUserGroup(request: DeleteUserGroupRequest): DeleteUserGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteUserGroupWithOptions(request, runtime);
}

model DeleteUserGroupMemberRequest {
  userGroupId?: string(name='UserGroupId'),
  userId?: string(name='UserId'),
}

model DeleteUserGroupMemberResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model DeleteUserGroupMemberResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteUserGroupMemberResponseBody(name='body'),
}

async function deleteUserGroupMemberWithOptions(request: DeleteUserGroupMemberRequest, runtime: Util.RuntimeOptions): DeleteUserGroupMemberResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.userGroupId)) {
    query['UserGroupId'] = request.userGroupId;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteUserGroupMember',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteUserGroupMember(request: DeleteUserGroupMemberRequest): DeleteUserGroupMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteUserGroupMemberWithOptions(request, runtime);
}

model DeleteUserGroupMembersRequest {
  userGroupIds?: string(name='UserGroupIds'),
  userId?: string(name='UserId'),
}

model DeleteUserGroupMembersResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model DeleteUserGroupMembersResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteUserGroupMembersResponseBody(name='body'),
}

async function deleteUserGroupMembersWithOptions(request: DeleteUserGroupMembersRequest, runtime: Util.RuntimeOptions): DeleteUserGroupMembersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.userGroupIds)) {
    query['UserGroupIds'] = request.userGroupIds;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteUserGroupMembers',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteUserGroupMembers(request: DeleteUserGroupMembersRequest): DeleteUserGroupMembersResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteUserGroupMembersWithOptions(request, runtime);
}

model DeleteUserTagMetaRequest {
  tagId?: string(name='TagId'),
}

model DeleteUserTagMetaResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model DeleteUserTagMetaResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteUserTagMetaResponseBody(name='body'),
}

async function deleteUserTagMetaWithOptions(request: DeleteUserTagMetaRequest, runtime: Util.RuntimeOptions): DeleteUserTagMetaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.tagId)) {
    query['TagId'] = request.tagId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteUserTagMeta',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteUserTagMeta(request: DeleteUserTagMetaRequest): DeleteUserTagMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteUserTagMetaWithOptions(request, runtime);
}

model GetUserGroupInfoRequest {
  keyword?: string(name='Keyword'),
}

model GetUserGroupInfoResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      createTime?: string(name='CreateTime'),
      createUser?: string(name='CreateUser'),
      identifiedPath?: string(name='IdentifiedPath'),
      modifiedTime?: string(name='ModifiedTime'),
      modifyUser?: string(name='ModifyUser'),
      parentUsergroupId?: string(name='ParentUsergroupId'),
      usergroupDesc?: string(name='UsergroupDesc'),
      usergroupId?: string(name='UsergroupId'),
      usergroupName?: string(name='UsergroupName'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
}

model GetUserGroupInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetUserGroupInfoResponseBody(name='body'),
}

async function getUserGroupInfoWithOptions(request: GetUserGroupInfoRequest, runtime: Util.RuntimeOptions): GetUserGroupInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetUserGroupInfo',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getUserGroupInfo(request: GetUserGroupInfoRequest): GetUserGroupInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getUserGroupInfoWithOptions(request, runtime);
}

model ListByUserGroupIdRequest {
  userGroupIds?: string(name='UserGroupIds'),
}

model ListByUserGroupIdResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    failedUserGroupIds?: [ string ](name='FailedUserGroupIds'),
    userGroupModels?: [ 
      {
        createTime?: string(name='CreateTime'),
        createUser?: string(name='CreateUser'),
        identifiedPath?: string(name='IdentifiedPath'),
        modifiedTime?: string(name='ModifiedTime'),
        modifyUser?: string(name='ModifyUser'),
        parentUsergroupId?: string(name='ParentUsergroupId'),
        usergroupDesc?: string(name='UsergroupDesc'),
        usergroupId?: string(name='UsergroupId'),
        usergroupName?: string(name='UsergroupName'),
      }
    ](name='UserGroupModels'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model ListByUserGroupIdResponse = {
  headers: map[string]string(name='headers'),
  body: ListByUserGroupIdResponseBody(name='body'),
}

async function listByUserGroupIdWithOptions(request: ListByUserGroupIdRequest, runtime: Util.RuntimeOptions): ListByUserGroupIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.userGroupIds)) {
    query['UserGroupIds'] = request.userGroupIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListByUserGroupId',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listByUserGroupId(request: ListByUserGroupIdRequest): ListByUserGroupIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return listByUserGroupIdWithOptions(request, runtime);
}

model ListCollectionsRequest {
  userId?: string(name='UserId'),
}

model ListCollectionsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      favoriteId?: int32(name='FavoriteId'),
      ownerId?: string(name='OwnerId'),
      worksId?: string(name='WorksId'),
      worksName?: string(name='WorksName'),
      worksType?: string(name='WorksType'),
      workspaceId?: string(name='WorkspaceId'),
      workspaceName?: string(name='WorkspaceName'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
}

model ListCollectionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListCollectionsResponseBody(name='body'),
}

async function listCollectionsWithOptions(request: ListCollectionsRequest, runtime: Util.RuntimeOptions): ListCollectionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCollections',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listCollections(request: ListCollectionsRequest): ListCollectionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCollectionsWithOptions(request, runtime);
}

model ListCubeDataLevelPermissionConfigRequest {
  cubeId?: string(name='CubeId'),
  ruleType?: string(name='RuleType'),
}

model ListCubeDataLevelPermissionConfigResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
  success?: boolean(name='Success'),
}

model ListCubeDataLevelPermissionConfigResponse = {
  headers: map[string]string(name='headers'),
  body: ListCubeDataLevelPermissionConfigResponseBody(name='body'),
}

async function listCubeDataLevelPermissionConfigWithOptions(request: ListCubeDataLevelPermissionConfigRequest, runtime: Util.RuntimeOptions): ListCubeDataLevelPermissionConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cubeId)) {
    query['CubeId'] = request.cubeId;
  }
  if (!Util.isUnset(request.ruleType)) {
    query['RuleType'] = request.ruleType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCubeDataLevelPermissionConfig',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listCubeDataLevelPermissionConfig(request: ListCubeDataLevelPermissionConfigRequest): ListCubeDataLevelPermissionConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCubeDataLevelPermissionConfigWithOptions(request, runtime);
}

model ListDataLevelPermissionWhiteListRequest {
  cubeId?: string(name='CubeId'),
  ruleType?: string(name='RuleType'),
}

model ListDataLevelPermissionWhiteListResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    cubeId?: string(name='CubeId'),
    ruleType?: string(name='RuleType'),
    usersModel?: {
      userGroups?: [ string ](name='UserGroups'),
      users?: [ string ](name='Users'),
    }(name='UsersModel'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model ListDataLevelPermissionWhiteListResponse = {
  headers: map[string]string(name='headers'),
  body: ListDataLevelPermissionWhiteListResponseBody(name='body'),
}

async function listDataLevelPermissionWhiteListWithOptions(request: ListDataLevelPermissionWhiteListRequest, runtime: Util.RuntimeOptions): ListDataLevelPermissionWhiteListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cubeId)) {
    query['CubeId'] = request.cubeId;
  }
  if (!Util.isUnset(request.ruleType)) {
    query['RuleType'] = request.ruleType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDataLevelPermissionWhiteList',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDataLevelPermissionWhiteList(request: ListDataLevelPermissionWhiteListRequest): ListDataLevelPermissionWhiteListResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDataLevelPermissionWhiteListWithOptions(request, runtime);
}

model ListFavoriteReportsRequest {
  keyword?: string(name='Keyword'),
  pageSize?: int32(name='PageSize'),
  treeType?: string(name='TreeType'),
  userId?: string(name='UserId'),
}

model ListFavoriteReportsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    data?: [ 
      {
        favorite?: boolean(name='Favorite'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        hasEditAuth?: boolean(name='HasEditAuth'),
        hasViewAuth?: boolean(name='HasViewAuth'),
        name?: string(name='Name'),
        ownerName?: string(name='OwnerName'),
        ownerNum?: string(name='OwnerNum'),
        publishStatus?: int32(name='PublishStatus'),
        treeId?: string(name='TreeId'),
        type?: string(name='Type'),
        workspaceId?: string(name='WorkspaceId'),
        workspaceName?: string(name='WorkspaceName'),
      }
    ](name='Data'),
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    totalNum?: int32(name='TotalNum'),
    totalPages?: int32(name='TotalPages'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model ListFavoriteReportsResponse = {
  headers: map[string]string(name='headers'),
  body: ListFavoriteReportsResponseBody(name='body'),
}

async function listFavoriteReportsWithOptions(request: ListFavoriteReportsRequest, runtime: Util.RuntimeOptions): ListFavoriteReportsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.treeType)) {
    query['TreeType'] = request.treeType;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFavoriteReports',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFavoriteReports(request: ListFavoriteReportsRequest): ListFavoriteReportsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFavoriteReportsWithOptions(request, runtime);
}

model ListPortalMenuAuthorizationRequest {
  dataPortalId?: string(name='DataPortalId'),
}

model ListPortalMenuAuthorizationResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      menuId?: string(name='MenuId'),
      receivers?: [ 
        {
          receiverId?: string(name='ReceiverId'),
          receiverType?: int32(name='ReceiverType'),
        }
      ](name='Receivers'),
      showOnlyWithAccess?: boolean(name='ShowOnlyWithAccess'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
}

model ListPortalMenuAuthorizationResponse = {
  headers: map[string]string(name='headers'),
  body: ListPortalMenuAuthorizationResponseBody(name='body'),
}

async function listPortalMenuAuthorizationWithOptions(request: ListPortalMenuAuthorizationRequest, runtime: Util.RuntimeOptions): ListPortalMenuAuthorizationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dataPortalId)) {
    query['DataPortalId'] = request.dataPortalId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPortalMenuAuthorization',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPortalMenuAuthorization(request: ListPortalMenuAuthorizationRequest): ListPortalMenuAuthorizationResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPortalMenuAuthorizationWithOptions(request, runtime);
}

model ListPortalMenusRequest {
  dataPortalId?: string(name='DataPortalId'),
  userId?: string(name='UserId'),
}

model ListPortalMenusResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
  success?: boolean(name='Success'),
}

model ListPortalMenusResponse = {
  headers: map[string]string(name='headers'),
  body: ListPortalMenusResponseBody(name='body'),
}

async function listPortalMenusWithOptions(request: ListPortalMenusRequest, runtime: Util.RuntimeOptions): ListPortalMenusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dataPortalId)) {
    query['DataPortalId'] = request.dataPortalId;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPortalMenus',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPortalMenus(request: ListPortalMenusRequest): ListPortalMenusResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPortalMenusWithOptions(request, runtime);
}

model ListRecentViewReportsRequest {
  keyword?: string(name='Keyword'),
  offsetDay?: int32(name='OffsetDay'),
  pageSize?: int32(name='PageSize'),
  queryMode?: string(name='QueryMode'),
  treeType?: string(name='TreeType'),
  userId?: string(name='UserId'),
}

model ListRecentViewReportsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    data?: [ 
      {
        favorite?: boolean(name='Favorite'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        hasEditAuth?: boolean(name='HasEditAuth'),
        hasViewAuth?: boolean(name='HasViewAuth'),
        latestViewTime?: string(name='LatestViewTime'),
        name?: string(name='Name'),
        ownerName?: string(name='OwnerName'),
        ownerNum?: string(name='OwnerNum'),
        publishStatus?: int32(name='PublishStatus'),
        treeId?: string(name='TreeId'),
        type?: string(name='Type'),
        viewCount?: long(name='ViewCount'),
        workspaceId?: string(name='WorkspaceId'),
        workspaceName?: string(name='WorkspaceName'),
      }
    ](name='Data'),
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    totalNum?: int32(name='TotalNum'),
    totalPages?: int32(name='TotalPages'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model ListRecentViewReportsResponse = {
  headers: map[string]string(name='headers'),
  body: ListRecentViewReportsResponseBody(name='body'),
}

async function listRecentViewReportsWithOptions(request: ListRecentViewReportsRequest, runtime: Util.RuntimeOptions): ListRecentViewReportsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.offsetDay)) {
    query['OffsetDay'] = request.offsetDay;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.queryMode)) {
    query['QueryMode'] = request.queryMode;
  }
  if (!Util.isUnset(request.treeType)) {
    query['TreeType'] = request.treeType;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRecentViewReports',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listRecentViewReports(request: ListRecentViewReportsRequest): ListRecentViewReportsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRecentViewReportsWithOptions(request, runtime);
}

model ListSharedReportsRequest {
  keyword?: string(name='Keyword'),
  pageSize?: int32(name='PageSize'),
  treeType?: string(name='TreeType'),
  userId?: string(name='UserId'),
}

model ListSharedReportsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    data?: [ 
      {
        favorite?: boolean(name='Favorite'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        hasEditAuth?: boolean(name='HasEditAuth'),
        hasViewAuth?: boolean(name='HasViewAuth'),
        name?: string(name='Name'),
        ownerName?: string(name='OwnerName'),
        ownerNum?: string(name='OwnerNum'),
        publishStatus?: int32(name='PublishStatus'),
        treeId?: string(name='TreeId'),
        type?: string(name='Type'),
        workspaceId?: string(name='WorkspaceId'),
        workspaceName?: string(name='WorkspaceName'),
      }
    ](name='Data'),
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    totalNum?: int32(name='TotalNum'),
    totalPages?: int32(name='TotalPages'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model ListSharedReportsResponse = {
  headers: map[string]string(name='headers'),
  body: ListSharedReportsResponseBody(name='body'),
}

async function listSharedReportsWithOptions(request: ListSharedReportsRequest, runtime: Util.RuntimeOptions): ListSharedReportsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.treeType)) {
    query['TreeType'] = request.treeType;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSharedReports',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSharedReports(request: ListSharedReportsRequest): ListSharedReportsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSharedReportsWithOptions(request, runtime);
}

model ListUserGroupsByUserIdRequest {
  userId?: string(name='UserId'),
}

model ListUserGroupsByUserIdResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      createTime?: string(name='CreateTime'),
      createUser?: string(name='CreateUser'),
      identifiedPath?: string(name='IdentifiedPath'),
      modifiedTime?: string(name='ModifiedTime'),
      modifyUser?: string(name='ModifyUser'),
      parentUsergroupId?: string(name='ParentUsergroupId'),
      usergroupDesc?: string(name='UsergroupDesc'),
      usergroupId?: string(name='UsergroupId'),
      usergroupName?: string(name='UsergroupName'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
}

model ListUserGroupsByUserIdResponse = {
  headers: map[string]string(name='headers'),
  body: ListUserGroupsByUserIdResponseBody(name='body'),
}

async function listUserGroupsByUserIdWithOptions(request: ListUserGroupsByUserIdRequest, runtime: Util.RuntimeOptions): ListUserGroupsByUserIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUserGroupsByUserId',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listUserGroupsByUserId(request: ListUserGroupsByUserIdRequest): ListUserGroupsByUserIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUserGroupsByUserIdWithOptions(request, runtime);
}

model QueryDataServiceRequest {
  apiId?: string(name='ApiId'),
  conditions?: string(name='Conditions'),
  returnFields?: string(name='ReturnFields'),
}

model QueryDataServiceResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    headers?: [ 
      {
        aggregator?: string(name='Aggregator'),
        column?: string(name='Column'),
        dataType?: string(name='DataType'),
        granularity?: string(name='Granularity'),
        label?: string(name='Label'),
        type?: string(name='Type'),
      }
    ](name='Headers'),
    sql?: string(name='Sql'),
    values?: [  map[string]any ](name='Values'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model QueryDataServiceResponse = {
  headers: map[string]string(name='headers'),
  body: QueryDataServiceResponseBody(name='body'),
}

async function queryDataServiceWithOptions(request: QueryDataServiceRequest, runtime: Util.RuntimeOptions): QueryDataServiceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.apiId)) {
    query['ApiId'] = request.apiId;
  }
  if (!Util.isUnset(request.conditions)) {
    query['Conditions'] = request.conditions;
  }
  if (!Util.isUnset(request.returnFields)) {
    query['ReturnFields'] = request.returnFields;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDataService',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryDataService(request: QueryDataServiceRequest): QueryDataServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDataServiceWithOptions(request, runtime);
}

model QueryDatasetDetailInfoRequest {
  datasetId?: string(name='DatasetId'),
}

model QueryDatasetDetailInfoResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
  success?: boolean(name='Success'),
}

model QueryDatasetDetailInfoResponse = {
  headers: map[string]string(name='headers'),
  body: QueryDatasetDetailInfoResponseBody(name='body'),
}

async function queryDatasetDetailInfoWithOptions(request: QueryDatasetDetailInfoRequest, runtime: Util.RuntimeOptions): QueryDatasetDetailInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.datasetId)) {
    query['DatasetId'] = request.datasetId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDatasetDetailInfo',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryDatasetDetailInfo(request: QueryDatasetDetailInfoRequest): QueryDatasetDetailInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDatasetDetailInfoWithOptions(request, runtime);
}

model QueryDatasetInfoRequest {
  datasetId?: string(name='DatasetId'),
}

model QueryDatasetInfoResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    cubeTableList?: [ 
      {
        caption?: string(name='Caption'),
        customsql?: boolean(name='Customsql'),
        datasourceId?: string(name='DatasourceId'),
        dsType?: string(name='DsType'),
        factTable?: boolean(name='FactTable'),
        sql?: string(name='Sql'),
        tableName?: string(name='TableName'),
        uniqueId?: string(name='UniqueId'),
      }
    ](name='CubeTableList'),
    custimzeSql?: boolean(name='CustimzeSql'),
    datasetId?: string(name='DatasetId'),
    datasetName?: string(name='DatasetName'),
    dimensionList?: [ 
      {
        caption?: string(name='Caption'),
        dataType?: string(name='DataType'),
        dimensionType?: string(name='DimensionType'),
        expression?: string(name='Expression'),
        factColumn?: string(name='FactColumn'),
        granularity?: string(name='Granularity'),
        refUid?: string(name='RefUid'),
        tableUniqueId?: string(name='TableUniqueId'),
        uid?: string(name='Uid'),
      }
    ](name='DimensionList'),
    directory?: {
      id?: string(name='Id'),
      name?: string(name='Name'),
      pathId?: string(name='PathId'),
      pathName?: string(name='PathName'),
    }(name='Directory'),
    dsId?: string(name='DsId'),
    dsName?: string(name='DsName'),
    dsType?: string(name='DsType'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModify?: string(name='GmtModify'),
    measureList?: [ 
      {
        caption?: string(name='Caption'),
        dataType?: string(name='DataType'),
        expression?: string(name='Expression'),
        factColumn?: string(name='FactColumn'),
        measureType?: string(name='MeasureType'),
        tableUniqueId?: string(name='TableUniqueId'),
        uid?: string(name='Uid'),
      }
    ](name='MeasureList'),
    ownerId?: string(name='OwnerId'),
    ownerName?: string(name='OwnerName'),
    rowLevel?: boolean(name='RowLevel'),
    workspaceId?: string(name='WorkspaceId'),
    workspaceName?: string(name='WorkspaceName'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model QueryDatasetInfoResponse = {
  headers: map[string]string(name='headers'),
  body: QueryDatasetInfoResponseBody(name='body'),
}

async function queryDatasetInfoWithOptions(request: QueryDatasetInfoRequest, runtime: Util.RuntimeOptions): QueryDatasetInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.datasetId)) {
    query['DatasetId'] = request.datasetId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDatasetInfo',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryDatasetInfo(request: QueryDatasetInfoRequest): QueryDatasetInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDatasetInfoWithOptions(request, runtime);
}

model QueryDatasetListRequest {
  directoryId?: string(name='DirectoryId'),
  keyword?: string(name='Keyword'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  withChildren?: boolean(name='WithChildren'),
  workspaceId?: string(name='WorkspaceId'),
}

model QueryDatasetListResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    data?: [ 
      {
        createTime?: string(name='CreateTime'),
        dataSource?: {
          dsId?: string(name='DsId'),
          dsName?: string(name='DsName'),
          dsType?: string(name='DsType'),
        }(name='DataSource'),
        datasetId?: string(name='DatasetId'),
        datasetName?: string(name='DatasetName'),
        description?: string(name='Description'),
        directory?: {
          id?: string(name='Id'),
          name?: string(name='Name'),
          pathId?: string(name='PathId'),
          pathName?: string(name='PathName'),
        }(name='Directory'),
        modifyTime?: string(name='ModifyTime'),
        ownerId?: string(name='OwnerId'),
        ownerName?: string(name='OwnerName'),
        rowLevel?: boolean(name='RowLevel'),
        workspaceId?: string(name='WorkspaceId'),
        workspaceName?: string(name='WorkspaceName'),
      }
    ](name='Data'),
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    totalNum?: int32(name='TotalNum'),
    totalPages?: int32(name='TotalPages'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model QueryDatasetListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryDatasetListResponseBody(name='body'),
}

async function queryDatasetListWithOptions(request: QueryDatasetListRequest, runtime: Util.RuntimeOptions): QueryDatasetListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.withChildren)) {
    query['WithChildren'] = request.withChildren;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDatasetList',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryDatasetList(request: QueryDatasetListRequest): QueryDatasetListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDatasetListWithOptions(request, runtime);
}

model QueryDatasetSwitchInfoRequest {
  cubeId?: string(name='CubeId'),
}

model QueryDatasetSwitchInfoResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    cubeId?: string(name='CubeId'),
    isOpenColumnLevelPermission?: int32(name='IsOpenColumnLevelPermission'),
    isOpenRowLevelPermission?: int32(name='IsOpenRowLevelPermission'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model QueryDatasetSwitchInfoResponse = {
  headers: map[string]string(name='headers'),
  body: QueryDatasetSwitchInfoResponseBody(name='body'),
}

async function queryDatasetSwitchInfoWithOptions(request: QueryDatasetSwitchInfoRequest, runtime: Util.RuntimeOptions): QueryDatasetSwitchInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cubeId)) {
    query['CubeId'] = request.cubeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDatasetSwitchInfo',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryDatasetSwitchInfo(request: QueryDatasetSwitchInfoRequest): QueryDatasetSwitchInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDatasetSwitchInfoWithOptions(request, runtime);
}

model QueryEmbeddedInfoResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    detail?: {
      dashboardOfflineQuery?: int32(name='DashboardOfflineQuery'),
      page?: int32(name='Page'),
      report?: int32(name='Report'),
    }(name='Detail'),
    embeddedCount?: int32(name='EmbeddedCount'),
    maxCount?: int32(name='MaxCount'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model QueryEmbeddedInfoResponse = {
  headers: map[string]string(name='headers'),
  body: QueryEmbeddedInfoResponseBody(name='body'),
}

async function queryEmbeddedInfoWithOptions(runtime: Util.RuntimeOptions): QueryEmbeddedInfoResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'QueryEmbeddedInfo',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryEmbeddedInfo(): QueryEmbeddedInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryEmbeddedInfoWithOptions(runtime);
}

model QueryEmbeddedStausRequest {
  worksId?: string(name='WorksId'),
}

model QueryEmbeddedStausResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model QueryEmbeddedStausResponse = {
  headers: map[string]string(name='headers'),
  body: QueryEmbeddedStausResponseBody(name='body'),
}

async function queryEmbeddedStausWithOptions(request: QueryEmbeddedStausRequest, runtime: Util.RuntimeOptions): QueryEmbeddedStausResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.worksId)) {
    query['WorksId'] = request.worksId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryEmbeddedStaus',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryEmbeddedStaus(request: QueryEmbeddedStausRequest): QueryEmbeddedStausResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryEmbeddedStausWithOptions(request, runtime);
}

model QueryOrganizationWorkspaceListRequest {
  keyword?: string(name='Keyword'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  userId?: string(name='UserId'),
}

model QueryOrganizationWorkspaceListResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    data?: [ 
      {
        allowPublishOperation?: boolean(name='AllowPublishOperation'),
        allowShareOperation?: boolean(name='AllowShareOperation'),
        createTime?: string(name='CreateTime'),
        createUser?: string(name='CreateUser'),
        createUserAccountName?: string(name='CreateUserAccountName'),
        modifiedTime?: string(name='ModifiedTime'),
        modifyUser?: string(name='ModifyUser'),
        modifyUserAccountName?: string(name='ModifyUserAccountName'),
        organizationId?: string(name='OrganizationId'),
        owner?: string(name='Owner'),
        ownerAccountName?: string(name='OwnerAccountName'),
        workspaceDescription?: string(name='WorkspaceDescription'),
        workspaceId?: string(name='WorkspaceId'),
        workspaceName?: string(name='WorkspaceName'),
      }
    ](name='Data'),
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    totalNum?: int32(name='TotalNum'),
    totalPages?: int32(name='TotalPages'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model QueryOrganizationWorkspaceListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryOrganizationWorkspaceListResponseBody(name='body'),
}

async function queryOrganizationWorkspaceListWithOptions(request: QueryOrganizationWorkspaceListRequest, runtime: Util.RuntimeOptions): QueryOrganizationWorkspaceListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryOrganizationWorkspaceList',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryOrganizationWorkspaceList(request: QueryOrganizationWorkspaceListRequest): QueryOrganizationWorkspaceListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryOrganizationWorkspaceListWithOptions(request, runtime);
}

model QueryReadableResourcesListByUserIdRequest {
  userId?: string(name='UserId'),
}

model QueryReadableResourcesListByUserIdResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      createTime?: string(name='CreateTime'),
      description?: string(name='Description'),
      directory?: {
        id?: string(name='Id'),
        name?: string(name='Name'),
        pathId?: string(name='PathId'),
        pathName?: string(name='PathName'),
      }(name='Directory'),
      modifyName?: string(name='ModifyName'),
      modifyTime?: string(name='ModifyTime'),
      ownerId?: string(name='OwnerId'),
      ownerName?: string(name='OwnerName'),
      securityLevel?: string(name='SecurityLevel'),
      status?: int32(name='Status'),
      thirdPartAuthFlag?: int32(name='ThirdPartAuthFlag'),
      workName?: string(name='WorkName'),
      workType?: string(name='WorkType'),
      worksId?: string(name='WorksId'),
      workspaceId?: string(name='WorkspaceId'),
      workspaceName?: string(name='WorkspaceName'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
}

model QueryReadableResourcesListByUserIdResponse = {
  headers: map[string]string(name='headers'),
  body: QueryReadableResourcesListByUserIdResponseBody(name='body'),
}

async function queryReadableResourcesListByUserIdWithOptions(request: QueryReadableResourcesListByUserIdRequest, runtime: Util.RuntimeOptions): QueryReadableResourcesListByUserIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryReadableResourcesListByUserId',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryReadableResourcesListByUserId(request: QueryReadableResourcesListByUserIdRequest): QueryReadableResourcesListByUserIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryReadableResourcesListByUserIdWithOptions(request, runtime);
}

model QueryShareListRequest {
  reportId?: string(name='ReportId'),
}

model QueryShareListResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      authPoint?: int32(name='AuthPoint'),
      expireDate?: long(name='ExpireDate'),
      reportId?: string(name='ReportId'),
      shareId?: string(name='ShareId'),
      shareToId?: string(name='ShareToId'),
      shareToName?: string(name='ShareToName'),
      shareToType?: int32(name='ShareToType'),
      shareType?: string(name='ShareType'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
}

model QueryShareListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryShareListResponseBody(name='body'),
}

async function queryShareListWithOptions(request: QueryShareListRequest, runtime: Util.RuntimeOptions): QueryShareListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.reportId)) {
    query['ReportId'] = request.reportId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryShareList',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryShareList(request: QueryShareListRequest): QueryShareListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryShareListWithOptions(request, runtime);
}

model QuerySharesToUserListRequest {
  userId?: string(name='UserId'),
}

model QuerySharesToUserListResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      createTime?: string(name='CreateTime'),
      description?: string(name='Description'),
      directory?: {
        id?: string(name='Id'),
        name?: string(name='Name'),
        pathId?: string(name='PathId'),
        pathName?: string(name='PathName'),
      }(name='Directory'),
      modifyName?: string(name='ModifyName'),
      modifyTime?: string(name='ModifyTime'),
      ownerId?: string(name='OwnerId'),
      ownerName?: string(name='OwnerName'),
      securityLevel?: string(name='SecurityLevel'),
      status?: int32(name='Status'),
      thirdPartAuthFlag?: int32(name='ThirdPartAuthFlag'),
      workName?: string(name='WorkName'),
      workType?: string(name='WorkType'),
      worksId?: string(name='WorksId'),
      workspaceId?: string(name='WorkspaceId'),
      workspaceName?: string(name='WorkspaceName'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
}

model QuerySharesToUserListResponse = {
  headers: map[string]string(name='headers'),
  body: QuerySharesToUserListResponseBody(name='body'),
}

async function querySharesToUserListWithOptions(request: QuerySharesToUserListRequest, runtime: Util.RuntimeOptions): QuerySharesToUserListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QuerySharesToUserList',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function querySharesToUserList(request: QuerySharesToUserListRequest): QuerySharesToUserListResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySharesToUserListWithOptions(request, runtime);
}

model QueryTicketInfoRequest {
  ticket?: string(name='Ticket'),
}

model QueryTicketInfoResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    accessTicket?: string(name='AccessTicket'),
    cmptId?: string(name='CmptId'),
    globalParam?: string(name='GlobalParam'),
    invalidTime?: string(name='InvalidTime'),
    maxTicketNum?: int32(name='MaxTicketNum'),
    organizationId?: string(name='OrganizationId'),
    registerTime?: string(name='RegisterTime'),
    usedTicketNum?: int32(name='UsedTicketNum'),
    userId?: string(name='UserId'),
    watermarkParam?: string(name='WatermarkParam'),
    worksId?: string(name='WorksId'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model QueryTicketInfoResponse = {
  headers: map[string]string(name='headers'),
  body: QueryTicketInfoResponseBody(name='body'),
}

async function queryTicketInfoWithOptions(request: QueryTicketInfoRequest, runtime: Util.RuntimeOptions): QueryTicketInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ticket)) {
    query['Ticket'] = request.ticket;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTicketInfo',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTicketInfo(request: QueryTicketInfoRequest): QueryTicketInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTicketInfoWithOptions(request, runtime);
}

model QueryUserGroupListByParentIdRequest {
  parentUserGroupId?: string(name='ParentUserGroupId'),
}

model QueryUserGroupListByParentIdResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      createTime?: string(name='CreateTime'),
      createUser?: string(name='CreateUser'),
      identifiedPath?: string(name='IdentifiedPath'),
      modifiedTime?: string(name='ModifiedTime'),
      modifyUser?: string(name='ModifyUser'),
      parentUserGroupId?: string(name='ParentUserGroupId'),
      userGroupDescription?: string(name='UserGroupDescription'),
      userGroupId?: string(name='UserGroupId'),
      userGroupName?: string(name='UserGroupName'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
}

model QueryUserGroupListByParentIdResponse = {
  headers: map[string]string(name='headers'),
  body: QueryUserGroupListByParentIdResponseBody(name='body'),
}

async function queryUserGroupListByParentIdWithOptions(request: QueryUserGroupListByParentIdRequest, runtime: Util.RuntimeOptions): QueryUserGroupListByParentIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.parentUserGroupId)) {
    query['ParentUserGroupId'] = request.parentUserGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryUserGroupListByParentId',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryUserGroupListByParentId(request: QueryUserGroupListByParentIdRequest): QueryUserGroupListByParentIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryUserGroupListByParentIdWithOptions(request, runtime);
}

model QueryUserGroupMemberRequest {
  keyword?: string(name='Keyword'),
  userGroupId?: string(name='UserGroupId'),
}

model QueryUserGroupMemberResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      id?: string(name='Id'),
      isUserGroup?: boolean(name='IsUserGroup'),
      name?: string(name='Name'),
      parentUserGroupId?: string(name='ParentUserGroupId'),
      parentUserGroupName?: string(name='ParentUserGroupName'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
}

model QueryUserGroupMemberResponse = {
  headers: map[string]string(name='headers'),
  body: QueryUserGroupMemberResponseBody(name='body'),
}

async function queryUserGroupMemberWithOptions(request: QueryUserGroupMemberRequest, runtime: Util.RuntimeOptions): QueryUserGroupMemberResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.userGroupId)) {
    query['UserGroupId'] = request.userGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryUserGroupMember',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryUserGroupMember(request: QueryUserGroupMemberRequest): QueryUserGroupMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryUserGroupMemberWithOptions(request, runtime);
}

model QueryUserInfoByAccountRequest {
  account?: string(name='Account'),
}

model QueryUserInfoByAccountResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    accountId?: string(name='AccountId'),
    accountName?: string(name='AccountName'),
    adminUser?: boolean(name='AdminUser'),
    authAdminUser?: boolean(name='AuthAdminUser'),
    email?: string(name='Email'),
    nickName?: string(name='NickName'),
    phone?: string(name='Phone'),
    userId?: string(name='UserId'),
    userType?: int32(name='UserType'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model QueryUserInfoByAccountResponse = {
  headers: map[string]string(name='headers'),
  body: QueryUserInfoByAccountResponseBody(name='body'),
}

async function queryUserInfoByAccountWithOptions(request: QueryUserInfoByAccountRequest, runtime: Util.RuntimeOptions): QueryUserInfoByAccountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.account)) {
    query['Account'] = request.account;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryUserInfoByAccount',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryUserInfoByAccount(request: QueryUserInfoByAccountRequest): QueryUserInfoByAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryUserInfoByAccountWithOptions(request, runtime);
}

model QueryUserInfoByUserIdRequest {
  userId?: string(name='UserId'),
}

model QueryUserInfoByUserIdResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    accountId?: string(name='AccountId'),
    accountName?: string(name='AccountName'),
    adminUser?: boolean(name='AdminUser'),
    authAdminUser?: boolean(name='AuthAdminUser'),
    email?: string(name='Email'),
    nickName?: string(name='NickName'),
    phone?: string(name='Phone'),
    userId?: string(name='UserId'),
    userType?: int32(name='UserType'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model QueryUserInfoByUserIdResponse = {
  headers: map[string]string(name='headers'),
  body: QueryUserInfoByUserIdResponseBody(name='body'),
}

async function queryUserInfoByUserIdWithOptions(request: QueryUserInfoByUserIdRequest, runtime: Util.RuntimeOptions): QueryUserInfoByUserIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryUserInfoByUserId',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryUserInfoByUserId(request: QueryUserInfoByUserIdRequest): QueryUserInfoByUserIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryUserInfoByUserIdWithOptions(request, runtime);
}

model QueryUserListRequest {
  keyword?: string(name='Keyword'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
}

model QueryUserListResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    data?: [ 
      {
        accountId?: string(name='AccountId'),
        accountName?: string(name='AccountName'),
        adminUser?: boolean(name='AdminUser'),
        authAdminUser?: boolean(name='AuthAdminUser'),
        nickName?: string(name='NickName'),
        userId?: string(name='UserId'),
        userType?: int32(name='UserType'),
      }
    ](name='Data'),
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    totalNum?: int32(name='TotalNum'),
    totalPages?: int32(name='TotalPages'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model QueryUserListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryUserListResponseBody(name='body'),
}

async function queryUserListWithOptions(request: QueryUserListRequest, runtime: Util.RuntimeOptions): QueryUserListResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryUserList',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryUserList(request: QueryUserListRequest): QueryUserListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryUserListWithOptions(request, runtime);
}

model QueryUserRoleInfoInWorkspaceRequest {
  userId?: string(name='UserId'),
  workspaceId?: string(name='WorkspaceId'),
}

model QueryUserRoleInfoInWorkspaceResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    roleCode?: string(name='RoleCode'),
    roleId?: long(name='RoleId'),
    roleName?: string(name='RoleName'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model QueryUserRoleInfoInWorkspaceResponse = {
  headers: map[string]string(name='headers'),
  body: QueryUserRoleInfoInWorkspaceResponseBody(name='body'),
}

async function queryUserRoleInfoInWorkspaceWithOptions(request: QueryUserRoleInfoInWorkspaceRequest, runtime: Util.RuntimeOptions): QueryUserRoleInfoInWorkspaceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryUserRoleInfoInWorkspace',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryUserRoleInfoInWorkspace(request: QueryUserRoleInfoInWorkspaceRequest): QueryUserRoleInfoInWorkspaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryUserRoleInfoInWorkspaceWithOptions(request, runtime);
}

model QueryUserTagMetaListResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      tagDescription?: string(name='TagDescription'),
      tagId?: string(name='TagId'),
      tagName?: string(name='TagName'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
}

model QueryUserTagMetaListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryUserTagMetaListResponseBody(name='body'),
}

async function queryUserTagMetaListWithOptions(runtime: Util.RuntimeOptions): QueryUserTagMetaListResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'QueryUserTagMetaList',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryUserTagMetaList(): QueryUserTagMetaListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryUserTagMetaListWithOptions(runtime);
}

model QueryUserTagValueListRequest {
  userId?: string(name='UserId'),
}

model QueryUserTagValueListResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      tagId?: string(name='TagId'),
      tagName?: string(name='TagName'),
      tagValue?: string(name='TagValue'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
}

model QueryUserTagValueListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryUserTagValueListResponseBody(name='body'),
}

async function queryUserTagValueListWithOptions(request: QueryUserTagValueListRequest, runtime: Util.RuntimeOptions): QueryUserTagValueListResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryUserTagValueList',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryUserTagValueList(request: QueryUserTagValueListRequest): QueryUserTagValueListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryUserTagValueListWithOptions(request, runtime);
}

model QueryWorksRequest {
  worksId?: string(name='WorksId', description='报表ID'),
}

model QueryWorksResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    auth3rdFlag?: int32(name='Auth3rdFlag', description='第三方嵌入状态'),
    description?: string(name='Description', description='描述'),
    directory?: {
      id?: string(name='Id', description='目录ID'),
      name?: string(name='Name', description='目录名称'),
      pathId?: string(name='PathId', description='目录ID的路径，例如：aa/bb/cc/dd'),
      pathName?: string(name='PathName', description='目录ID的路径名称，例如：一层目录/二层目录'),
    }(name='Directory', description='所属空间目录信息'),
    gmtCreate?: string(name='GmtCreate', description='创建时间d'),
    gmtModify?: string(name='GmtModify', description='修改时间'),
    modifyName?: string(name='ModifyName', description='修改显示名称'),
    ownerId?: string(name='OwnerId', description='所有者Id'),
    ownerName?: string(name='OwnerName', description='所有者显示名称'),
    securityLevel?: string(name='SecurityLevel', description='安全策略：0 私有 1 协同编辑。 （'),
    status?: int32(name='Status', description='报表发布状态 @PublishStatusEnum'),
    workName?: string(name='WorkName', description='作品名称'),
    workType?: string(name='WorkType', description='作品类型'),
    worksId?: string(name='WorksId', description='作品ID'),
    workspaceId?: string(name='WorkspaceId', description='所属工作空间'),
    workspaceName?: string(name='WorkspaceName', description='所属空间名称'),
  }(name='Result', description='QueryWorksModel'),
  success?: boolean(name='Success'),
}

model QueryWorksResponse = {
  headers: map[string]string(name='headers'),
  body: QueryWorksResponseBody(name='body'),
}

async function queryWorksWithOptions(request: QueryWorksRequest, runtime: Util.RuntimeOptions): QueryWorksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.worksId)) {
    query['WorksId'] = request.worksId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryWorks',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryWorks(request: QueryWorksRequest): QueryWorksResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryWorksWithOptions(request, runtime);
}

model QueryWorksBloodRelationshipRequest {
  worksId?: string(name='WorksId', description='报表ID'),
}

model QueryWorksBloodRelationshipResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      componentId?: string(name='ComponentId', description='组件ID or  sheetId'),
      componentName?: string(name='ComponentName'),
      componentType?: int32(name='ComponentType', description='组件类型'),
      componentTypeName?: string(name='ComponentTypeName'),
      datasetId?: string(name='DatasetId', description='数据集ID'),
      queryParams?: [ 
        {
          areaId?: string(name='AreaId', description='所属位置：'),
          areaName?: string(name='AreaName'),
          caption?: string(name='Caption', description='字段显示名称'),
          dataType?: string(name='DataType', description='字段类型'),
          isMeasure?: boolean(name='IsMeasure', description='是否是度量'),
          pathId?: string(name='PathId', description='全局唯一的PathId。位于cube的level中pathId'),
          uid?: string(name='Uid', description='字段唯一ID。即cube中的name'),
        }
      ](name='QueryParams', description='查询参数引用的列信息'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
}

model QueryWorksBloodRelationshipResponse = {
  headers: map[string]string(name='headers'),
  body: QueryWorksBloodRelationshipResponseBody(name='body'),
}

async function queryWorksBloodRelationshipWithOptions(request: QueryWorksBloodRelationshipRequest, runtime: Util.RuntimeOptions): QueryWorksBloodRelationshipResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.worksId)) {
    query['WorksId'] = request.worksId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryWorksBloodRelationship',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryWorksBloodRelationship(request: QueryWorksBloodRelationshipRequest): QueryWorksBloodRelationshipResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryWorksBloodRelationshipWithOptions(request, runtime);
}

model QueryWorksByOrganizationRequest {
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  status?: int32(name='Status'),
  thirdPartAuthFlag?: int32(name='ThirdPartAuthFlag'),
  worksType?: string(name='WorksType'),
}

model QueryWorksByOrganizationResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    data?: [ 
      {
        auth3rdFlag?: int32(name='Auth3rdFlag'),
        description?: string(name='Description'),
        directory?: {
          id?: string(name='Id'),
          name?: string(name='Name'),
          pathId?: string(name='PathId'),
          pathName?: string(name='PathName'),
        }(name='Directory'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModify?: string(name='GmtModify'),
        modifyName?: string(name='ModifyName'),
        ownerId?: string(name='OwnerId'),
        ownerName?: string(name='OwnerName'),
        securityLevel?: string(name='SecurityLevel'),
        status?: int32(name='Status'),
        workName?: string(name='WorkName'),
        workType?: string(name='WorkType'),
        worksId?: string(name='WorksId'),
        workspaceId?: string(name='WorkspaceId'),
        workspaceName?: string(name='WorkspaceName'),
      }
    ](name='Data'),
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    totalNum?: int32(name='TotalNum'),
    totalPages?: int32(name='TotalPages'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model QueryWorksByOrganizationResponse = {
  headers: map[string]string(name='headers'),
  body: QueryWorksByOrganizationResponseBody(name='body'),
}

async function queryWorksByOrganizationWithOptions(request: QueryWorksByOrganizationRequest, runtime: Util.RuntimeOptions): QueryWorksByOrganizationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.thirdPartAuthFlag)) {
    query['ThirdPartAuthFlag'] = request.thirdPartAuthFlag;
  }
  if (!Util.isUnset(request.worksType)) {
    query['WorksType'] = request.worksType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryWorksByOrganization',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryWorksByOrganization(request: QueryWorksByOrganizationRequest): QueryWorksByOrganizationResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryWorksByOrganizationWithOptions(request, runtime);
}

model QueryWorksByWorkspaceRequest {
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  status?: int32(name='Status'),
  thirdPartAuthFlag?: int32(name='ThirdPartAuthFlag'),
  worksType?: string(name='WorksType'),
  workspaceId?: string(name='WorkspaceId'),
}

model QueryWorksByWorkspaceResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    data?: [ 
      {
        auth3rdFlag?: int32(name='Auth3rdFlag'),
        description?: string(name='Description'),
        directory?: {
          id?: string(name='Id'),
          name?: string(name='Name'),
          pathId?: string(name='PathId'),
          pathName?: string(name='PathName'),
        }(name='Directory'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModify?: string(name='GmtModify'),
        modifyName?: string(name='ModifyName'),
        ownerId?: string(name='OwnerId'),
        ownerName?: string(name='OwnerName'),
        securityLevel?: string(name='SecurityLevel'),
        status?: int32(name='Status'),
        workName?: string(name='WorkName'),
        workType?: string(name='WorkType'),
        worksId?: string(name='WorksId'),
        workspaceId?: string(name='WorkspaceId'),
        workspaceName?: string(name='WorkspaceName'),
      }
    ](name='Data'),
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    totalNum?: int32(name='TotalNum'),
    totalPages?: int32(name='TotalPages'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model QueryWorksByWorkspaceResponse = {
  headers: map[string]string(name='headers'),
  body: QueryWorksByWorkspaceResponseBody(name='body'),
}

async function queryWorksByWorkspaceWithOptions(request: QueryWorksByWorkspaceRequest, runtime: Util.RuntimeOptions): QueryWorksByWorkspaceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.thirdPartAuthFlag)) {
    query['ThirdPartAuthFlag'] = request.thirdPartAuthFlag;
  }
  if (!Util.isUnset(request.worksType)) {
    query['WorksType'] = request.worksType;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryWorksByWorkspace',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryWorksByWorkspace(request: QueryWorksByWorkspaceRequest): QueryWorksByWorkspaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryWorksByWorkspaceWithOptions(request, runtime);
}

model QueryWorkspaceUserListRequest {
  keyword?: string(name='Keyword'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  workspaceId?: string(name='WorkspaceId'),
}

model QueryWorkspaceUserListResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    data?: [ 
      {
        accountId?: string(name='AccountId'),
        accountName?: string(name='AccountName'),
        nickName?: string(name='NickName'),
        role?: {
          roleCode?: string(name='RoleCode'),
          roleId?: long(name='RoleId'),
          roleName?: string(name='RoleName'),
        }(name='Role'),
        userId?: string(name='UserId'),
      }
    ](name='Data'),
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    totalNum?: int32(name='TotalNum'),
    totalPages?: int32(name='TotalPages'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model QueryWorkspaceUserListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryWorkspaceUserListResponseBody(name='body'),
}

async function queryWorkspaceUserListWithOptions(request: QueryWorkspaceUserListRequest, runtime: Util.RuntimeOptions): QueryWorkspaceUserListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryWorkspaceUserList',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryWorkspaceUserList(request: QueryWorkspaceUserListRequest): QueryWorkspaceUserListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryWorkspaceUserListWithOptions(request, runtime);
}

model ResultCallbackRequest {
  applicationId?: string(name='ApplicationId'),
  handleReason?: string(name='HandleReason'),
  status?: int32(name='Status'),
}

model ResultCallbackResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model ResultCallbackResponse = {
  headers: map[string]string(name='headers'),
  body: ResultCallbackResponseBody(name='body'),
}

async function resultCallbackWithOptions(request: ResultCallbackRequest, runtime: Util.RuntimeOptions): ResultCallbackResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.applicationId)) {
    query['ApplicationId'] = request.applicationId;
  }
  if (!Util.isUnset(request.handleReason)) {
    query['HandleReason'] = request.handleReason;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResultCallback',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function resultCallback(request: ResultCallbackRequest): ResultCallbackResponse {
  var runtime = new Util.RuntimeOptions{};
  return resultCallbackWithOptions(request, runtime);
}

model SaveFavoritesRequest {
  userId?: string(name='UserId'),
  worksId?: string(name='WorksId'),
}

model SaveFavoritesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model SaveFavoritesResponse = {
  headers: map[string]string(name='headers'),
  body: SaveFavoritesResponseBody(name='body'),
}

async function saveFavoritesWithOptions(request: SaveFavoritesRequest, runtime: Util.RuntimeOptions): SaveFavoritesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  if (!Util.isUnset(request.worksId)) {
    query['WorksId'] = request.worksId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveFavorites',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveFavorites(request: SaveFavoritesRequest): SaveFavoritesResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveFavoritesWithOptions(request, runtime);
}

model SetDataLevelPermissionExtraConfigRequest {
  cubeId?: string(name='CubeId'),
  missHitPolicy?: string(name='MissHitPolicy'),
  ruleType?: string(name='RuleType'),
}

model SetDataLevelPermissionExtraConfigResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model SetDataLevelPermissionExtraConfigResponse = {
  headers: map[string]string(name='headers'),
  body: SetDataLevelPermissionExtraConfigResponseBody(name='body'),
}

async function setDataLevelPermissionExtraConfigWithOptions(request: SetDataLevelPermissionExtraConfigRequest, runtime: Util.RuntimeOptions): SetDataLevelPermissionExtraConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cubeId)) {
    query['CubeId'] = request.cubeId;
  }
  if (!Util.isUnset(request.missHitPolicy)) {
    query['MissHitPolicy'] = request.missHitPolicy;
  }
  if (!Util.isUnset(request.ruleType)) {
    query['RuleType'] = request.ruleType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetDataLevelPermissionExtraConfig',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setDataLevelPermissionExtraConfig(request: SetDataLevelPermissionExtraConfigRequest): SetDataLevelPermissionExtraConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDataLevelPermissionExtraConfigWithOptions(request, runtime);
}

model SetDataLevelPermissionRuleConfigRequest {
  ruleModel?: string(name='RuleModel'),
}

model SetDataLevelPermissionRuleConfigResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
  success?: boolean(name='Success'),
}

model SetDataLevelPermissionRuleConfigResponse = {
  headers: map[string]string(name='headers'),
  body: SetDataLevelPermissionRuleConfigResponseBody(name='body'),
}

async function setDataLevelPermissionRuleConfigWithOptions(request: SetDataLevelPermissionRuleConfigRequest, runtime: Util.RuntimeOptions): SetDataLevelPermissionRuleConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ruleModel)) {
    query['RuleModel'] = request.ruleModel;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetDataLevelPermissionRuleConfig',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setDataLevelPermissionRuleConfig(request: SetDataLevelPermissionRuleConfigRequest): SetDataLevelPermissionRuleConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDataLevelPermissionRuleConfigWithOptions(request, runtime);
}

model SetDataLevelPermissionWhiteListRequest {
  whiteListModel?: string(name='WhiteListModel'),
}

model SetDataLevelPermissionWhiteListResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model SetDataLevelPermissionWhiteListResponse = {
  headers: map[string]string(name='headers'),
  body: SetDataLevelPermissionWhiteListResponseBody(name='body'),
}

async function setDataLevelPermissionWhiteListWithOptions(request: SetDataLevelPermissionWhiteListRequest, runtime: Util.RuntimeOptions): SetDataLevelPermissionWhiteListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.whiteListModel)) {
    query['WhiteListModel'] = request.whiteListModel;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetDataLevelPermissionWhiteList',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setDataLevelPermissionWhiteList(request: SetDataLevelPermissionWhiteListRequest): SetDataLevelPermissionWhiteListResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDataLevelPermissionWhiteListWithOptions(request, runtime);
}

model UpdateDataLevelPermissionStatusRequest {
  cubeId?: string(name='CubeId'),
  isOpen?: int32(name='IsOpen'),
  ruleType?: string(name='RuleType'),
}

model UpdateDataLevelPermissionStatusResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model UpdateDataLevelPermissionStatusResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateDataLevelPermissionStatusResponseBody(name='body'),
}

async function updateDataLevelPermissionStatusWithOptions(request: UpdateDataLevelPermissionStatusRequest, runtime: Util.RuntimeOptions): UpdateDataLevelPermissionStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cubeId)) {
    query['CubeId'] = request.cubeId;
  }
  if (!Util.isUnset(request.isOpen)) {
    query['IsOpen'] = request.isOpen;
  }
  if (!Util.isUnset(request.ruleType)) {
    query['RuleType'] = request.ruleType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDataLevelPermissionStatus',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDataLevelPermissionStatus(request: UpdateDataLevelPermissionStatusRequest): UpdateDataLevelPermissionStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDataLevelPermissionStatusWithOptions(request, runtime);
}

model UpdateEmbeddedStatusRequest {
  thirdPartAuthFlag?: boolean(name='ThirdPartAuthFlag'),
  worksId?: string(name='WorksId'),
}

model UpdateEmbeddedStatusResponseBody = {
  requestId?: string(name='RequestId'),
  result?: int32(name='Result'),
  success?: boolean(name='Success'),
}

model UpdateEmbeddedStatusResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateEmbeddedStatusResponseBody(name='body'),
}

async function updateEmbeddedStatusWithOptions(request: UpdateEmbeddedStatusRequest, runtime: Util.RuntimeOptions): UpdateEmbeddedStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.thirdPartAuthFlag)) {
    query['ThirdPartAuthFlag'] = request.thirdPartAuthFlag;
  }
  if (!Util.isUnset(request.worksId)) {
    query['WorksId'] = request.worksId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateEmbeddedStatus',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateEmbeddedStatus(request: UpdateEmbeddedStatusRequest): UpdateEmbeddedStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateEmbeddedStatusWithOptions(request, runtime);
}

model UpdateTicketNumRequest {
  ticket?: string(name='Ticket'),
  ticketNum?: int32(name='TicketNum'),
}

model UpdateTicketNumResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model UpdateTicketNumResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateTicketNumResponseBody(name='body'),
}

async function updateTicketNumWithOptions(request: UpdateTicketNumRequest, runtime: Util.RuntimeOptions): UpdateTicketNumResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ticket)) {
    query['Ticket'] = request.ticket;
  }
  if (!Util.isUnset(request.ticketNum)) {
    query['TicketNum'] = request.ticketNum;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTicketNum',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateTicketNum(request: UpdateTicketNumRequest): UpdateTicketNumResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateTicketNumWithOptions(request, runtime);
}

model UpdateUserRequest {
  adminUser?: boolean(name='AdminUser'),
  authAdminUser?: boolean(name='AuthAdminUser'),
  nickName?: string(name='NickName'),
  userId?: string(name='UserId'),
  userType?: int32(name='UserType'),
}

model UpdateUserResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model UpdateUserResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateUserResponseBody(name='body'),
}

async function updateUserWithOptions(request: UpdateUserRequest, runtime: Util.RuntimeOptions): UpdateUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.adminUser)) {
    query['AdminUser'] = request.adminUser;
  }
  if (!Util.isUnset(request.authAdminUser)) {
    query['AuthAdminUser'] = request.authAdminUser;
  }
  if (!Util.isUnset(request.nickName)) {
    query['NickName'] = request.nickName;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  if (!Util.isUnset(request.userType)) {
    query['UserType'] = request.userType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateUser',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateUser(request: UpdateUserRequest): UpdateUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateUserWithOptions(request, runtime);
}

model UpdateUserGroupRequest {
  userGroupDescription?: string(name='UserGroupDescription'),
  userGroupId?: string(name='UserGroupId'),
  userGroupName?: string(name='UserGroupName'),
}

model UpdateUserGroupResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model UpdateUserGroupResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateUserGroupResponseBody(name='body'),
}

async function updateUserGroupWithOptions(request: UpdateUserGroupRequest, runtime: Util.RuntimeOptions): UpdateUserGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.userGroupDescription)) {
    query['UserGroupDescription'] = request.userGroupDescription;
  }
  if (!Util.isUnset(request.userGroupId)) {
    query['UserGroupId'] = request.userGroupId;
  }
  if (!Util.isUnset(request.userGroupName)) {
    query['UserGroupName'] = request.userGroupName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateUserGroup',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateUserGroup(request: UpdateUserGroupRequest): UpdateUserGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateUserGroupWithOptions(request, runtime);
}

model UpdateUserTagMetaRequest {
  tagDescription?: string(name='TagDescription'),
  tagId?: string(name='TagId'),
  tagName?: string(name='TagName'),
}

model UpdateUserTagMetaResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model UpdateUserTagMetaResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateUserTagMetaResponseBody(name='body'),
}

async function updateUserTagMetaWithOptions(request: UpdateUserTagMetaRequest, runtime: Util.RuntimeOptions): UpdateUserTagMetaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.tagDescription)) {
    query['TagDescription'] = request.tagDescription;
  }
  if (!Util.isUnset(request.tagId)) {
    query['TagId'] = request.tagId;
  }
  if (!Util.isUnset(request.tagName)) {
    query['TagName'] = request.tagName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateUserTagMeta',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateUserTagMeta(request: UpdateUserTagMetaRequest): UpdateUserTagMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateUserTagMetaWithOptions(request, runtime);
}

model UpdateUserTagValueRequest {
  tagId?: string(name='TagId'),
  tagValue?: string(name='TagValue'),
  userId?: string(name='UserId'),
}

model UpdateUserTagValueResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model UpdateUserTagValueResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateUserTagValueResponseBody(name='body'),
}

async function updateUserTagValueWithOptions(request: UpdateUserTagValueRequest, runtime: Util.RuntimeOptions): UpdateUserTagValueResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.tagId)) {
    query['TagId'] = request.tagId;
  }
  if (!Util.isUnset(request.tagValue)) {
    query['TagValue'] = request.tagValue;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateUserTagValue',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateUserTagValue(request: UpdateUserTagValueRequest): UpdateUserTagValueResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateUserTagValueWithOptions(request, runtime);
}

model UpdateWorkspaceUserRoleRequest {
  roleId?: long(name='RoleId'),
  userId?: string(name='UserId'),
  workspaceId?: string(name='WorkspaceId'),
}

model UpdateWorkspaceUserRoleResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model UpdateWorkspaceUserRoleResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateWorkspaceUserRoleResponseBody(name='body'),
}

async function updateWorkspaceUserRoleWithOptions(request: UpdateWorkspaceUserRoleRequest, runtime: Util.RuntimeOptions): UpdateWorkspaceUserRoleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.roleId)) {
    query['RoleId'] = request.roleId;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateWorkspaceUserRole',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateWorkspaceUserRole(request: UpdateWorkspaceUserRoleRequest): UpdateWorkspaceUserRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateWorkspaceUserRoleWithOptions(request, runtime);
}

model UpdateWorkspaceUsersRoleRequest {
  roleId?: long(name='RoleId'),
  userIds?: string(name='UserIds'),
  workspaceId?: string(name='WorkspaceId'),
}

model UpdateWorkspaceUsersRoleResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    failure?: int32(name='Failure'),
    failureDetail?: map[string]any(name='FailureDetail'),
    success?: int32(name='Success'),
    total?: int32(name='Total'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model UpdateWorkspaceUsersRoleResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateWorkspaceUsersRoleResponseBody(name='body'),
}

async function updateWorkspaceUsersRoleWithOptions(request: UpdateWorkspaceUsersRoleRequest, runtime: Util.RuntimeOptions): UpdateWorkspaceUsersRoleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.roleId)) {
    query['RoleId'] = request.roleId;
  }
  if (!Util.isUnset(request.userIds)) {
    query['UserIds'] = request.userIds;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateWorkspaceUsersRole',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateWorkspaceUsersRole(request: UpdateWorkspaceUsersRoleRequest): UpdateWorkspaceUsersRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateWorkspaceUsersRoleWithOptions(request, runtime);
}

model WithdrawAllUserGroupsRequest {
  userId?: string(name='UserId'),
}

model WithdrawAllUserGroupsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model WithdrawAllUserGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: WithdrawAllUserGroupsResponseBody(name='body'),
}

async function withdrawAllUserGroupsWithOptions(request: WithdrawAllUserGroupsRequest, runtime: Util.RuntimeOptions): WithdrawAllUserGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'WithdrawAllUserGroups',
    version = '2022-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function withdrawAllUserGroups(request: WithdrawAllUserGroupsRequest): WithdrawAllUserGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return withdrawAllUserGroupsWithOptions(request, runtime);
}

