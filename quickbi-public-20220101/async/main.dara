/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'quickbi-public';
  @version = '2022-01-01';
  @endpointRule = 'central';
  @endpointMap = {
  };
}

function close(): void {
  @handler.close();
}

model AddDataLevelPermissionRuleUsersRequest {
  addUserModel: string(name='AddUserModel', position='Query'),
}

model AddDataLevelPermissionRuleUsersResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model AddDataLevelPermissionRuleUsersResponse = {
  headers: map[string]string(name='headers'),
  body: AddDataLevelPermissionRuleUsersResponseBody(name='body'),
}

async function addDataLevelPermissionRuleUsers(request: AddDataLevelPermissionRuleUsersRequest): AddDataLevelPermissionRuleUsersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddDataLevelPermissionRuleUsers', 'POST', '/', 'json', false, 'json', request);
}

model AddDataLevelPermissionWhiteListRequest {
  cubeId: string(name='CubeId', position='Query'),
  operateType?: string(name='OperateType', position='Query'),
  ruleType?: string(name='RuleType', position='Query'),
  targetIds?: string(name='TargetIds', position='Query'),
  targetType?: string(name='TargetType', position='Query'),
}

model AddDataLevelPermissionWhiteListResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model AddDataLevelPermissionWhiteListResponse = {
  headers: map[string]string(name='headers'),
  body: AddDataLevelPermissionWhiteListResponseBody(name='body'),
}

async function addDataLevelPermissionWhiteList(request: AddDataLevelPermissionWhiteListRequest): AddDataLevelPermissionWhiteListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddDataLevelPermissionWhiteList', 'POST', '/', 'json', false, 'json', request);
}

model AddShareReportRequest {
  authPoint: int32(name='AuthPoint', minimum=1, maximum=3, position='Query'),
  expireDate: long(name='ExpireDate', minimum=0, maximum=33167973431000, position='Query'),
  shareToId: string(name='ShareToId', position='Query'),
  shareToType: int32(name='ShareToType', minimum=0, maximum=2, position='Query'),
  worksId: string(name='WorksId', position='Query'),
}

model AddShareReportResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model AddShareReportResponse = {
  headers: map[string]string(name='headers'),
  body: AddShareReportResponseBody(name='body'),
}

async function addShareReport(request: AddShareReportRequest): AddShareReportResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddShareReport', 'POST', '/', 'json', false, 'json', request);
}

model AddUserRequest {
  accountName: string(name='AccountName', position='Query'),
  adminUser: boolean(name='AdminUser', position='Query'),
  authAdminUser: boolean(name='AuthAdminUser', position='Query'),
  nickName: string(name='NickName', position='Query'),
  userType: int32(name='UserType', minimum=1, maximum=10, position='Query'),
}

model AddUserResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    accountName?: string(name='AccountName'),
    adminUser?: boolean(name='AdminUser'),
    authAdminUser?: boolean(name='AuthAdminUser'),
    nickName?: string(name='NickName'),
    userId?: string(name='UserId'),
    userType?: int32(name='UserType'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model AddUserResponse = {
  headers: map[string]string(name='headers'),
  body: AddUserResponseBody(name='body'),
}

async function addUser(request: AddUserRequest): AddUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddUser', 'POST', '/', 'json', false, 'json', request);
}

model AddUserGroupMemberRequest {
  userGroupId: string(name='UserGroupId', position='Query'),
  userIdList: string(name='UserIdList', position='Query'),
}

model AddUserGroupMemberResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model AddUserGroupMemberResponse = {
  headers: map[string]string(name='headers'),
  body: AddUserGroupMemberResponseBody(name='body'),
}

async function addUserGroupMember(request: AddUserGroupMemberRequest): AddUserGroupMemberResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddUserGroupMember', 'POST', '/', 'json', false, 'json', request);
}

model AddUserGroupMembersRequest {
  userGroupIds: string(name='UserGroupIds', position='Query'),
  userId: string(name='UserId', position='Query'),
}

model AddUserGroupMembersResponseBody = {
  requestId?: string(name='RequestId', description='请求ID。'),
  result?: boolean(name='Result', description='接口执行结果。取值范围：true：请求成功false：请求失败'),
  success?: boolean(name='Success', description='是否请求成功。取值范围：true：请求成功false：请求失败'),
}

model AddUserGroupMembersResponse = {
  headers: map[string]string(name='headers'),
  body: AddUserGroupMembersResponseBody(name='body'),
}

async function addUserGroupMembers(request: AddUserGroupMembersRequest): AddUserGroupMembersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddUserGroupMembers', 'POST', '/', 'json', false, 'json', request);
}

model AddUserTagMetaRequest {
  tagDescription?: string(name='TagDescription', position='Query'),
  tagName: string(name='TagName', position='Query'),
}

model AddUserTagMetaResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
  success?: boolean(name='Success'),
}

model AddUserTagMetaResponse = {
  headers: map[string]string(name='headers'),
  body: AddUserTagMetaResponseBody(name='body'),
}

async function addUserTagMeta(request: AddUserTagMetaRequest): AddUserTagMetaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddUserTagMeta', 'POST', '/', 'json', false, 'json', request);
}

model AddUserToWorkspaceRequest {
  roleId: long(name='RoleId', minimum=25, maximum=30, position='Query'),
  userId: string(name='UserId', position='Query'),
  workspaceId: string(name='WorkspaceId', position='Query'),
}

model AddUserToWorkspaceResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model AddUserToWorkspaceResponse = {
  headers: map[string]string(name='headers'),
  body: AddUserToWorkspaceResponseBody(name='body'),
}

async function addUserToWorkspace(request: AddUserToWorkspaceRequest): AddUserToWorkspaceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddUserToWorkspace', 'POST', '/', 'json', false, 'json', request);
}

model AddWorkspaceUsersRequest {
  roleId: long(name='RoleId', minimum=25, maximum=30, position='Query'),
  userIds: string(name='UserIds', position='Query'),
  workspaceId: string(name='WorkspaceId', position='Query'),
}

model AddWorkspaceUsersResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    failure?: int32(name='Failure'),
    failureDetail?: map[string]any(name='FailureDetail'),
    success?: int32(name='Success'),
    total?: int32(name='Total'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model AddWorkspaceUsersResponse = {
  headers: map[string]string(name='headers'),
  body: AddWorkspaceUsersResponseBody(name='body'),
}

async function addWorkspaceUsers(request: AddWorkspaceUsersRequest): AddWorkspaceUsersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddWorkspaceUsers', 'POST', '/', 'json', false, 'json', request);
}

model AuthorizeMenuRequest {
  authPointsValue?: int32(name='AuthPointsValue', position='Query'),
  dataPortalId: string(name='DataPortalId', position='Query'),
  menuIds: string(name='MenuIds', position='Query'),
  userGroupIds?: string(name='UserGroupIds', position='Query'),
  userIds?: string(name='UserIds', position='Query'),
}

model AuthorizeMenuResponseBody = {
  requestId?: string(name='RequestId'),
  result?: int32(name='Result'),
  success?: boolean(name='Success'),
}

model AuthorizeMenuResponse = {
  headers: map[string]string(name='headers'),
  body: AuthorizeMenuResponseBody(name='body'),
}

async function authorizeMenu(request: AuthorizeMenuRequest): AuthorizeMenuResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AuthorizeMenu', 'POST', '/', 'json', false, 'json', request);
}

model CancelAuthorizationMenuRequest {
  dataPortalId: string(name='DataPortalId', position='Query'),
  menuIds: string(name='MenuIds', position='Query'),
  userGroupIds?: string(name='UserGroupIds', position='Query'),
  userIds?: string(name='UserIds', position='Query'),
}

model CancelAuthorizationMenuResponseBody = {
  requestId?: string(name='RequestId'),
  result?: int32(name='Result'),
  success?: boolean(name='Success'),
}

model CancelAuthorizationMenuResponse = {
  headers: map[string]string(name='headers'),
  body: CancelAuthorizationMenuResponseBody(name='body'),
}

async function cancelAuthorizationMenu(request: CancelAuthorizationMenuRequest): CancelAuthorizationMenuResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CancelAuthorizationMenu', 'POST', '/', 'json', false, 'json', request);
}

model CancelCollectionRequest {
  userId: string(name='UserId', position='Query'),
  worksId: string(name='WorksId', position='Query'),
}

model CancelCollectionResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model CancelCollectionResponse = {
  headers: map[string]string(name='headers'),
  body: CancelCollectionResponseBody(name='body'),
}

async function cancelCollection(request: CancelCollectionRequest): CancelCollectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CancelCollection', 'POST', '/', 'json', false, 'json', request);
}

model CancelReportShareRequest {
  reportId: string(name='ReportId', position='Query'),
  shareToIds: string(name='ShareToIds', position='Query'),
  shareToType: int32(name='ShareToType', position='Query'),
}

model CancelReportShareResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model CancelReportShareResponse = {
  headers: map[string]string(name='headers'),
  body: CancelReportShareResponseBody(name='body'),
}

async function cancelReportShare(request: CancelReportShareRequest): CancelReportShareResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CancelReportShare', 'POST', '/', 'json', false, 'json', request);
}

model ChangeVisibilityModelRequest {
  dataPortalId: string(name='DataPortalId', position='Query'),
  menuIds: string(name='MenuIds', position='Query'),
  showOnlyWithAccess: boolean(name='ShowOnlyWithAccess', position='Query'),
}

model ChangeVisibilityModelResponseBody = {
  requestId?: string(name='RequestId'),
  result?: int32(name='Result'),
  success?: boolean(name='Success'),
}

model ChangeVisibilityModelResponse = {
  headers: map[string]string(name='headers'),
  body: ChangeVisibilityModelResponseBody(name='body'),
}

async function changeVisibilityModel(request: ChangeVisibilityModelRequest): ChangeVisibilityModelResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ChangeVisibilityModel', 'POST', '/', 'json', false, 'json', request);
}

model CheckReadableRequest {
  userId: string(name='UserId', position='Query'),
  worksId: string(name='WorksId', position='Query'),
}

model CheckReadableResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model CheckReadableResponse = {
  headers: map[string]string(name='headers'),
  body: CheckReadableResponseBody(name='body'),
}

async function checkReadable(request: CheckReadableRequest): CheckReadableResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CheckReadable', 'POST', '/', 'json', false, 'json', request);
}

model CreateTicketRequest {
  accountName?: string(name='AccountName', position='Query'),
  accountType?: int32(name='AccountType', position='Query'),
  cmptId?: string(name='CmptId', position='Query'),
  expireTime?: int32(name='ExpireTime', position='Query'),
  globalParam?: string(name='GlobalParam', position='Query'),
  ticketNum?: int32(name='TicketNum', position='Query'),
  userId?: string(name='UserId', position='Query'),
  watermarkParam?: string(name='WatermarkParam', position='Query'),
  worksId: string(name='WorksId', position='Query'),
}

model CreateTicketResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
  success?: boolean(name='Success'),
}

model CreateTicketResponse = {
  headers: map[string]string(name='headers'),
  body: CreateTicketResponseBody(name='body'),
}

async function createTicket(request: CreateTicketRequest): CreateTicketResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateTicket', 'POST', '/', 'json', false, 'json', request);
}

model CreateUserGroupRequest {
  parentUserGroupId: string(name='ParentUserGroupId', position='Query'),
  userGroupDescription?: string(name='UserGroupDescription', position='Query'),
  userGroupId?: string(name='UserGroupId', position='Query'),
  userGroupName: string(name='UserGroupName', position='Query'),
}

model CreateUserGroupResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
  success?: boolean(name='Success'),
}

model CreateUserGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateUserGroupResponseBody(name='body'),
}

async function createUserGroup(request: CreateUserGroupRequest): CreateUserGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateUserGroup', 'POST', '/', 'json', false, 'json', request);
}

model DelayTicketExpireTimeRequest {
  expireTime: int32(name='ExpireTime', position='Query'),
  ticket: string(name='Ticket', position='Query'),
}

model DelayTicketExpireTimeResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model DelayTicketExpireTimeResponse = {
  headers: map[string]string(name='headers'),
  body: DelayTicketExpireTimeResponseBody(name='body'),
}

async function delayTicketExpireTime(request: DelayTicketExpireTimeRequest): DelayTicketExpireTimeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DelayTicketExpireTime', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDataLevelPermissionRuleUsersRequest {
  deleteUserModel: string(name='DeleteUserModel', position='Query'),
}

model DeleteDataLevelPermissionRuleUsersResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model DeleteDataLevelPermissionRuleUsersResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDataLevelPermissionRuleUsersResponseBody(name='body'),
}

async function deleteDataLevelPermissionRuleUsers(request: DeleteDataLevelPermissionRuleUsersRequest): DeleteDataLevelPermissionRuleUsersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDataLevelPermissionRuleUsers', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDataLevelRuleConfigRequest {
  cubeId: string(name='CubeId', position='Query'),
  ruleId: string(name='RuleId', position='Query'),
}

model DeleteDataLevelRuleConfigResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model DeleteDataLevelRuleConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDataLevelRuleConfigResponseBody(name='body'),
}

async function deleteDataLevelRuleConfig(request: DeleteDataLevelRuleConfigRequest): DeleteDataLevelRuleConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDataLevelRuleConfig', 'POST', '/', 'json', false, 'json', request);
}

model DeleteTicketRequest {
  ticket: string(name='Ticket', position='Query'),
}

model DeleteTicketResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model DeleteTicketResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteTicketResponseBody(name='body'),
}

async function deleteTicket(request: DeleteTicketRequest): DeleteTicketResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteTicket', 'POST', '/', 'json', false, 'json', request);
}

model DeleteUserRequest {
  transferUserId?: string(name='TransferUserId', position='Query'),
  userId: string(name='UserId', position='Query'),
}

model DeleteUserResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model DeleteUserResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteUserResponseBody(name='body'),
}

async function deleteUser(request: DeleteUserRequest): DeleteUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteUser', 'POST', '/', 'json', false, 'json', request);
}

model DeleteUserFromWorkspaceRequest {
  userId: string(name='UserId', position='Query'),
  workspaceId: string(name='WorkspaceId', position='Query'),
}

model DeleteUserFromWorkspaceResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model DeleteUserFromWorkspaceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteUserFromWorkspaceResponseBody(name='body'),
}

async function deleteUserFromWorkspace(request: DeleteUserFromWorkspaceRequest): DeleteUserFromWorkspaceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteUserFromWorkspace', 'POST', '/', 'json', false, 'json', request);
}

model DeleteUserGroupRequest {
  userGroupId: string(name='UserGroupId', position='Query'),
}

model DeleteUserGroupResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model DeleteUserGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteUserGroupResponseBody(name='body'),
}

async function deleteUserGroup(request: DeleteUserGroupRequest): DeleteUserGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteUserGroup', 'POST', '/', 'json', false, 'json', request);
}

model DeleteUserGroupMemberRequest {
  userGroupId: string(name='UserGroupId', position='Query'),
  userId: string(name='UserId', position='Query'),
}

model DeleteUserGroupMemberResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model DeleteUserGroupMemberResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteUserGroupMemberResponseBody(name='body'),
}

async function deleteUserGroupMember(request: DeleteUserGroupMemberRequest): DeleteUserGroupMemberResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteUserGroupMember', 'POST', '/', 'json', false, 'json', request);
}

model DeleteUserGroupMembersRequest {
  userGroupIds: string(name='UserGroupIds', position='Query'),
  userId: string(name='UserId', position='Query'),
}

model DeleteUserGroupMembersResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model DeleteUserGroupMembersResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteUserGroupMembersResponseBody(name='body'),
}

async function deleteUserGroupMembers(request: DeleteUserGroupMembersRequest): DeleteUserGroupMembersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteUserGroupMembers', 'POST', '/', 'json', false, 'json', request);
}

model DeleteUserTagMetaRequest {
  tagId: string(name='TagId', position='Query'),
}

model DeleteUserTagMetaResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model DeleteUserTagMetaResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteUserTagMetaResponseBody(name='body'),
}

async function deleteUserTagMeta(request: DeleteUserTagMetaRequest): DeleteUserTagMetaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteUserTagMeta', 'POST', '/', 'json', false, 'json', request);
}

model GetUserGroupInfoRequest {
  keyword: string(name='Keyword', position='Query'),
}

model GetUserGroupInfoResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      createTime?: string(name='CreateTime'),
      createUser?: string(name='CreateUser'),
      identifiedPath?: string(name='IdentifiedPath'),
      modifiedTime?: string(name='ModifiedTime'),
      modifyUser?: string(name='ModifyUser'),
      parentUsergroupId?: string(name='ParentUsergroupId'),
      usergroupDesc?: string(name='UsergroupDesc'),
      usergroupId?: string(name='UsergroupId'),
      usergroupName?: string(name='UsergroupName'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
}

model GetUserGroupInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetUserGroupInfoResponseBody(name='body'),
}

async function getUserGroupInfo(request: GetUserGroupInfoRequest): GetUserGroupInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetUserGroupInfo', 'POST', '/', 'json', false, 'json', request);
}

model ListByUserGroupIdRequest {
  userGroupIds: string(name='UserGroupIds', position='Query'),
}

model ListByUserGroupIdResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    failedUserGroupIds?: [ string ](name='FailedUserGroupIds'),
    userGroupModels?: [ 
      {
        createTime?: string(name='CreateTime'),
        createUser?: string(name='CreateUser'),
        identifiedPath?: string(name='IdentifiedPath'),
        modifiedTime?: string(name='ModifiedTime'),
        modifyUser?: string(name='ModifyUser'),
        parentUsergroupId?: string(name='ParentUsergroupId'),
        usergroupDesc?: string(name='UsergroupDesc'),
        usergroupId?: string(name='UsergroupId'),
        usergroupName?: string(name='UsergroupName'),
      }
    ](name='UserGroupModels'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model ListByUserGroupIdResponse = {
  headers: map[string]string(name='headers'),
  body: ListByUserGroupIdResponseBody(name='body'),
}

async function listByUserGroupId(request: ListByUserGroupIdRequest): ListByUserGroupIdResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListByUserGroupId', 'POST', '/', 'json', false, 'json', request);
}

model ListCollectionsRequest {
  userId: string(name='UserId', position='Query'),
}

model ListCollectionsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      favoriteId?: int32(name='FavoriteId'),
      ownerId?: string(name='OwnerId'),
      worksId?: string(name='WorksId'),
      worksName?: string(name='WorksName'),
      worksType?: string(name='WorksType'),
      workspaceId?: string(name='WorkspaceId'),
      workspaceName?: string(name='WorkspaceName'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
}

model ListCollectionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListCollectionsResponseBody(name='body'),
}

async function listCollections(request: ListCollectionsRequest): ListCollectionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListCollections', 'POST', '/', 'json', false, 'json', request);
}

model ListCubeDataLevelPermissionConfigRequest {
  cubeId: string(name='CubeId', position='Query'),
  ruleType: string(name='RuleType', position='Query'),
}

model ListCubeDataLevelPermissionConfigResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
  success?: boolean(name='Success'),
}

model ListCubeDataLevelPermissionConfigResponse = {
  headers: map[string]string(name='headers'),
  body: ListCubeDataLevelPermissionConfigResponseBody(name='body'),
}

async function listCubeDataLevelPermissionConfig(request: ListCubeDataLevelPermissionConfigRequest): ListCubeDataLevelPermissionConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListCubeDataLevelPermissionConfig', 'POST', '/', 'json', false, 'json', request);
}

model ListDataLevelPermissionWhiteListRequest {
  cubeId: string(name='CubeId', position='Query'),
  ruleType: string(name='RuleType', position='Query'),
}

model ListDataLevelPermissionWhiteListResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    cubeId?: string(name='CubeId'),
    ruleType?: string(name='RuleType'),
    usersModel?: {
      userGroups?: [ string ](name='UserGroups'),
      users?: [ string ](name='Users'),
    }(name='UsersModel'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model ListDataLevelPermissionWhiteListResponse = {
  headers: map[string]string(name='headers'),
  body: ListDataLevelPermissionWhiteListResponseBody(name='body'),
}

async function listDataLevelPermissionWhiteList(request: ListDataLevelPermissionWhiteListRequest): ListDataLevelPermissionWhiteListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListDataLevelPermissionWhiteList', 'POST', '/', 'json', false, 'json', request);
}

model ListFavoriteReportsRequest {
  keyword?: string(name='Keyword', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  treeType?: string(name='TreeType', position='Query'),
  userId: string(name='UserId', position='Query'),
}

model ListFavoriteReportsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    data?: [ 
      {
        favorite?: boolean(name='Favorite'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        hasEditAuth?: boolean(name='HasEditAuth'),
        hasViewAuth?: boolean(name='HasViewAuth'),
        name?: string(name='Name'),
        ownerName?: string(name='OwnerName'),
        ownerNum?: string(name='OwnerNum'),
        publishStatus?: int32(name='PublishStatus'),
        treeId?: string(name='TreeId'),
        type?: string(name='Type'),
        workspaceId?: string(name='WorkspaceId'),
        workspaceName?: string(name='WorkspaceName'),
      }
    ](name='Data'),
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    totalNum?: int32(name='TotalNum'),
    totalPages?: int32(name='TotalPages'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model ListFavoriteReportsResponse = {
  headers: map[string]string(name='headers'),
  body: ListFavoriteReportsResponseBody(name='body'),
}

async function listFavoriteReports(request: ListFavoriteReportsRequest): ListFavoriteReportsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListFavoriteReports', 'POST', '/', 'json', false, 'json', request);
}

model ListPortalMenuAuthorizationRequest {
  dataPortalId: string(name='DataPortalId', position='Query'),
}

model ListPortalMenuAuthorizationResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      menuId?: string(name='MenuId'),
      receivers?: [ 
        {
          receiverId?: string(name='ReceiverId'),
          receiverType?: int32(name='ReceiverType'),
        }
      ](name='Receivers'),
      showOnlyWithAccess?: boolean(name='ShowOnlyWithAccess'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
}

model ListPortalMenuAuthorizationResponse = {
  headers: map[string]string(name='headers'),
  body: ListPortalMenuAuthorizationResponseBody(name='body'),
}

async function listPortalMenuAuthorization(request: ListPortalMenuAuthorizationRequest): ListPortalMenuAuthorizationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListPortalMenuAuthorization', 'POST', '/', 'json', false, 'json', request);
}

model ListPortalMenusRequest {
  dataPortalId: string(name='DataPortalId', position='Query'),
  userId?: string(name='UserId', position='Query'),
}

model ListPortalMenusResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
  success?: boolean(name='Success'),
}

model ListPortalMenusResponse = {
  headers: map[string]string(name='headers'),
  body: ListPortalMenusResponseBody(name='body'),
}

async function listPortalMenus(request: ListPortalMenusRequest): ListPortalMenusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListPortalMenus', 'POST', '/', 'json', false, 'json', request);
}

model ListRecentViewReportsRequest {
  keyword?: string(name='Keyword', position='Query'),
  offsetDay?: int32(name='OffsetDay', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  queryMode?: string(name='QueryMode', position='Query'),
  treeType?: string(name='TreeType', position='Query'),
  userId: string(name='UserId', position='Query'),
}

model ListRecentViewReportsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    data?: [ 
      {
        favorite?: boolean(name='Favorite'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        hasEditAuth?: boolean(name='HasEditAuth'),
        hasViewAuth?: boolean(name='HasViewAuth'),
        latestViewTime?: string(name='LatestViewTime'),
        name?: string(name='Name'),
        ownerName?: string(name='OwnerName'),
        ownerNum?: string(name='OwnerNum'),
        publishStatus?: int32(name='PublishStatus'),
        treeId?: string(name='TreeId'),
        type?: string(name='Type'),
        viewCount?: long(name='ViewCount'),
        workspaceId?: string(name='WorkspaceId'),
        workspaceName?: string(name='WorkspaceName'),
      }
    ](name='Data'),
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    totalNum?: int32(name='TotalNum'),
    totalPages?: int32(name='TotalPages'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model ListRecentViewReportsResponse = {
  headers: map[string]string(name='headers'),
  body: ListRecentViewReportsResponseBody(name='body'),
}

async function listRecentViewReports(request: ListRecentViewReportsRequest): ListRecentViewReportsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListRecentViewReports', 'POST', '/', 'json', false, 'json', request);
}

model ListSharedReportsRequest {
  keyword?: string(name='Keyword', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  treeType?: string(name='TreeType', position='Query'),
  userId: string(name='UserId', position='Query'),
}

model ListSharedReportsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    data?: [ 
      {
        favorite?: boolean(name='Favorite'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        hasEditAuth?: boolean(name='HasEditAuth'),
        hasViewAuth?: boolean(name='HasViewAuth'),
        name?: string(name='Name'),
        ownerName?: string(name='OwnerName'),
        ownerNum?: string(name='OwnerNum'),
        publishStatus?: int32(name='PublishStatus'),
        treeId?: string(name='TreeId'),
        type?: string(name='Type'),
        workspaceId?: string(name='WorkspaceId'),
        workspaceName?: string(name='WorkspaceName'),
      }
    ](name='Data'),
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    totalNum?: int32(name='TotalNum'),
    totalPages?: int32(name='TotalPages'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model ListSharedReportsResponse = {
  headers: map[string]string(name='headers'),
  body: ListSharedReportsResponseBody(name='body'),
}

async function listSharedReports(request: ListSharedReportsRequest): ListSharedReportsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListSharedReports', 'POST', '/', 'json', false, 'json', request);
}

model ListUserGroupsByUserIdRequest {
  userId: string(name='UserId', position='Query'),
}

model ListUserGroupsByUserIdResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      createTime?: string(name='CreateTime'),
      createUser?: string(name='CreateUser'),
      identifiedPath?: string(name='IdentifiedPath'),
      modifiedTime?: string(name='ModifiedTime'),
      modifyUser?: string(name='ModifyUser'),
      parentUsergroupId?: string(name='ParentUsergroupId'),
      usergroupDesc?: string(name='UsergroupDesc'),
      usergroupId?: string(name='UsergroupId'),
      usergroupName?: string(name='UsergroupName'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
}

model ListUserGroupsByUserIdResponse = {
  headers: map[string]string(name='headers'),
  body: ListUserGroupsByUserIdResponseBody(name='body'),
}

async function listUserGroupsByUserId(request: ListUserGroupsByUserIdRequest): ListUserGroupsByUserIdResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListUserGroupsByUserId', 'POST', '/', 'json', false, 'json', request);
}

model QueryDataServiceRequest {
  apiId: string(name='ApiId', position='Query'),
  conditions?: string(name='Conditions', position='Query'),
  returnFields?: string(name='ReturnFields', position='Query'),
}

model QueryDataServiceResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    headers?: [ 
      {
        aggregator?: string(name='Aggregator'),
        column?: string(name='Column'),
        dataType?: string(name='DataType'),
        granularity?: string(name='Granularity'),
        label?: string(name='Label'),
        type?: string(name='Type'),
      }
    ](name='Headers'),
    sql?: string(name='Sql'),
    values?: [  map[string]any ](name='Values'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model QueryDataServiceResponse = {
  headers: map[string]string(name='headers'),
  body: QueryDataServiceResponseBody(name='body'),
}

async function queryDataService(request: QueryDataServiceRequest): QueryDataServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryDataService', 'POST', '/', 'json', false, 'json', request);
}

model QueryDatasetDetailInfoRequest {
  datasetId: string(name='DatasetId', position='Query'),
}

model QueryDatasetDetailInfoResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
  success?: boolean(name='Success'),
}

model QueryDatasetDetailInfoResponse = {
  headers: map[string]string(name='headers'),
  body: QueryDatasetDetailInfoResponseBody(name='body'),
}

async function queryDatasetDetailInfo(request: QueryDatasetDetailInfoRequest): QueryDatasetDetailInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryDatasetDetailInfo', 'POST', '/', 'json', false, 'json', request);
}

model QueryDatasetInfoRequest {
  datasetId: string(name='DatasetId', position='Query'),
}

model QueryDatasetInfoResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    cubeTableList?: [ 
      {
        caption?: string(name='Caption'),
        customsql?: boolean(name='Customsql'),
        datasourceId?: string(name='DatasourceId'),
        dsType?: string(name='DsType'),
        factTable?: boolean(name='FactTable'),
        sql?: string(name='Sql'),
        tableName?: string(name='TableName'),
        uniqueId?: string(name='UniqueId'),
      }
    ](name='CubeTableList'),
    custimzeSql?: boolean(name='CustimzeSql'),
    datasetId?: string(name='DatasetId'),
    datasetName?: string(name='DatasetName'),
    dimensionList?: [ 
      {
        caption?: string(name='Caption'),
        dataType?: string(name='DataType'),
        dimensionType?: string(name='DimensionType'),
        expression?: string(name='Expression'),
        factColumn?: string(name='FactColumn'),
        granularity?: string(name='Granularity'),
        refUid?: string(name='RefUid'),
        tableUniqueId?: string(name='TableUniqueId'),
        uid?: string(name='Uid'),
      }
    ](name='DimensionList'),
    directory?: {
      id?: string(name='Id'),
      name?: string(name='Name'),
      pathId?: string(name='PathId'),
      pathName?: string(name='PathName'),
    }(name='Directory'),
    dsId?: string(name='DsId'),
    dsName?: string(name='DsName'),
    dsType?: string(name='DsType'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModify?: string(name='GmtModify'),
    measureList?: [ 
      {
        caption?: string(name='Caption'),
        dataType?: string(name='DataType'),
        expression?: string(name='Expression'),
        factColumn?: string(name='FactColumn'),
        measureType?: string(name='MeasureType'),
        tableUniqueId?: string(name='TableUniqueId'),
        uid?: string(name='Uid'),
      }
    ](name='MeasureList'),
    ownerId?: string(name='OwnerId'),
    ownerName?: string(name='OwnerName'),
    rowLevel?: boolean(name='RowLevel'),
    workspaceId?: string(name='WorkspaceId'),
    workspaceName?: string(name='WorkspaceName'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model QueryDatasetInfoResponse = {
  headers: map[string]string(name='headers'),
  body: QueryDatasetInfoResponseBody(name='body'),
}

async function queryDatasetInfo(request: QueryDatasetInfoRequest): QueryDatasetInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryDatasetInfo', 'POST', '/', 'json', false, 'json', request);
}

model QueryDatasetListRequest {
  directoryId?: string(name='DirectoryId', position='Query'),
  keyword?: string(name='Keyword', position='Query'),
  pageNum?: int32(name='PageNum', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  withChildren?: boolean(name='WithChildren', position='Query'),
  workspaceId: string(name='WorkspaceId', position='Query'),
}

model QueryDatasetListResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    data?: [ 
      {
        createTime?: string(name='CreateTime'),
        dataSource?: {
          dsId?: string(name='DsId'),
          dsName?: string(name='DsName'),
          dsType?: string(name='DsType'),
        }(name='DataSource'),
        datasetId?: string(name='DatasetId'),
        datasetName?: string(name='DatasetName'),
        description?: string(name='Description'),
        directory?: {
          id?: string(name='Id'),
          name?: string(name='Name'),
          pathId?: string(name='PathId'),
          pathName?: string(name='PathName'),
        }(name='Directory'),
        modifyTime?: string(name='ModifyTime'),
        ownerId?: string(name='OwnerId'),
        ownerName?: string(name='OwnerName'),
        rowLevel?: boolean(name='RowLevel'),
        workspaceId?: string(name='WorkspaceId'),
        workspaceName?: string(name='WorkspaceName'),
      }
    ](name='Data'),
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    totalNum?: int32(name='TotalNum'),
    totalPages?: int32(name='TotalPages'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model QueryDatasetListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryDatasetListResponseBody(name='body'),
}

async function queryDatasetList(request: QueryDatasetListRequest): QueryDatasetListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryDatasetList', 'POST', '/', 'json', false, 'json', request);
}

model QueryDatasetSwitchInfoRequest {
  cubeId: string(name='CubeId', position='Query'),
}

model QueryDatasetSwitchInfoResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    cubeId?: string(name='CubeId'),
    isOpenColumnLevelPermission?: int32(name='IsOpenColumnLevelPermission'),
    isOpenRowLevelPermission?: int32(name='IsOpenRowLevelPermission'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model QueryDatasetSwitchInfoResponse = {
  headers: map[string]string(name='headers'),
  body: QueryDatasetSwitchInfoResponseBody(name='body'),
}

async function queryDatasetSwitchInfo(request: QueryDatasetSwitchInfoRequest): QueryDatasetSwitchInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryDatasetSwitchInfo', 'POST', '/', 'json', false, 'json', request);
}

model QueryEmbeddedInfoRequest {
}

model QueryEmbeddedInfoResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    detail?: {
      dashboardOfflineQuery?: int32(name='DashboardOfflineQuery'),
      page?: int32(name='Page'),
      report?: int32(name='Report'),
    }(name='Detail'),
    embeddedCount?: int32(name='EmbeddedCount'),
    maxCount?: int32(name='MaxCount'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model QueryEmbeddedInfoResponse = {
  headers: map[string]string(name='headers'),
  body: QueryEmbeddedInfoResponseBody(name='body'),
}

async function queryEmbeddedInfo(request: QueryEmbeddedInfoRequest): QueryEmbeddedInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryEmbeddedInfo', 'POST', '/', 'json', false, 'json', request);
}

model QueryEmbeddedStausRequest {
  worksId: string(name='WorksId', position='Query'),
}

model QueryEmbeddedStausResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model QueryEmbeddedStausResponse = {
  headers: map[string]string(name='headers'),
  body: QueryEmbeddedStausResponseBody(name='body'),
}

async function queryEmbeddedStaus(request: QueryEmbeddedStausRequest): QueryEmbeddedStausResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryEmbeddedStaus', 'POST', '/', 'json', false, 'json', request);
}

model QueryOrganizationWorkspaceListRequest {
  keyword?: string(name='Keyword', position='Query'),
  pageNum?: int32(name='PageNum', minimum=1, maximum=1000000, position='Query'),
  pageSize?: int32(name='PageSize', minimum=10, maximum=1000, position='Query'),
  userId?: string(name='UserId', position='Query'),
}

model QueryOrganizationWorkspaceListResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    data?: [ 
      {
        allowPublishOperation?: boolean(name='AllowPublishOperation'),
        allowShareOperation?: boolean(name='AllowShareOperation'),
        createTime?: string(name='CreateTime'),
        createUser?: string(name='CreateUser'),
        createUserAccountName?: string(name='CreateUserAccountName'),
        modifiedTime?: string(name='ModifiedTime'),
        modifyUser?: string(name='ModifyUser'),
        modifyUserAccountName?: string(name='ModifyUserAccountName'),
        organizationId?: string(name='OrganizationId'),
        owner?: string(name='Owner'),
        ownerAccountName?: string(name='OwnerAccountName'),
        workspaceDescription?: string(name='WorkspaceDescription'),
        workspaceId?: string(name='WorkspaceId'),
        workspaceName?: string(name='WorkspaceName'),
      }
    ](name='Data'),
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    totalNum?: int32(name='TotalNum'),
    totalPages?: int32(name='TotalPages'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model QueryOrganizationWorkspaceListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryOrganizationWorkspaceListResponseBody(name='body'),
}

async function queryOrganizationWorkspaceList(request: QueryOrganizationWorkspaceListRequest): QueryOrganizationWorkspaceListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryOrganizationWorkspaceList', 'POST', '/', 'json', false, 'json', request);
}

model QueryReadableResourcesListByUserIdRequest {
  userId: string(name='UserId', position='Query'),
}

model QueryReadableResourcesListByUserIdResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      createTime?: string(name='CreateTime'),
      description?: string(name='Description'),
      directory?: {
        id?: string(name='Id'),
        name?: string(name='Name'),
        pathId?: string(name='PathId'),
        pathName?: string(name='PathName'),
      }(name='Directory'),
      modifyName?: string(name='ModifyName'),
      modifyTime?: string(name='ModifyTime'),
      ownerId?: string(name='OwnerId'),
      ownerName?: string(name='OwnerName'),
      securityLevel?: string(name='SecurityLevel'),
      status?: int32(name='Status'),
      thirdPartAuthFlag?: int32(name='ThirdPartAuthFlag'),
      workName?: string(name='WorkName'),
      workType?: string(name='WorkType'),
      worksId?: string(name='WorksId'),
      workspaceId?: string(name='WorkspaceId'),
      workspaceName?: string(name='WorkspaceName'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
}

model QueryReadableResourcesListByUserIdResponse = {
  headers: map[string]string(name='headers'),
  body: QueryReadableResourcesListByUserIdResponseBody(name='body'),
}

async function queryReadableResourcesListByUserId(request: QueryReadableResourcesListByUserIdRequest): QueryReadableResourcesListByUserIdResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryReadableResourcesListByUserId', 'POST', '/', 'json', false, 'json', request);
}

model QueryShareListRequest {
  reportId: string(name='ReportId', position='Query'),
}

model QueryShareListResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      authPoint?: int32(name='AuthPoint'),
      expireDate?: long(name='ExpireDate'),
      reportId?: string(name='ReportId'),
      shareId?: string(name='ShareId'),
      shareToId?: string(name='ShareToId'),
      shareToName?: string(name='ShareToName'),
      shareToType?: int32(name='ShareToType'),
      shareType?: string(name='ShareType'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
}

model QueryShareListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryShareListResponseBody(name='body'),
}

async function queryShareList(request: QueryShareListRequest): QueryShareListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryShareList', 'POST', '/', 'json', false, 'json', request);
}

model QuerySharesToUserListRequest {
  userId: string(name='UserId', position='Query'),
}

model QuerySharesToUserListResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      createTime?: string(name='CreateTime'),
      description?: string(name='Description'),
      directory?: {
        id?: string(name='Id'),
        name?: string(name='Name'),
        pathId?: string(name='PathId'),
        pathName?: string(name='PathName'),
      }(name='Directory'),
      modifyName?: string(name='ModifyName'),
      modifyTime?: string(name='ModifyTime'),
      ownerId?: string(name='OwnerId'),
      ownerName?: string(name='OwnerName'),
      securityLevel?: string(name='SecurityLevel'),
      status?: int32(name='Status'),
      thirdPartAuthFlag?: int32(name='ThirdPartAuthFlag'),
      workName?: string(name='WorkName'),
      workType?: string(name='WorkType'),
      worksId?: string(name='WorksId'),
      workspaceId?: string(name='WorkspaceId'),
      workspaceName?: string(name='WorkspaceName'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
}

model QuerySharesToUserListResponse = {
  headers: map[string]string(name='headers'),
  body: QuerySharesToUserListResponseBody(name='body'),
}

async function querySharesToUserList(request: QuerySharesToUserListRequest): QuerySharesToUserListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QuerySharesToUserList', 'POST', '/', 'json', false, 'json', request);
}

model QueryTicketInfoRequest {
  ticket: string(name='Ticket', position='Query'),
}

model QueryTicketInfoResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    accessTicket?: string(name='AccessTicket'),
    cmptId?: string(name='CmptId'),
    globalParam?: string(name='GlobalParam'),
    invalidTime?: string(name='InvalidTime'),
    maxTicketNum?: int32(name='MaxTicketNum'),
    organizationId?: string(name='OrganizationId'),
    registerTime?: string(name='RegisterTime'),
    usedTicketNum?: int32(name='UsedTicketNum'),
    userId?: string(name='UserId'),
    watermarkParam?: string(name='WatermarkParam'),
    worksId?: string(name='WorksId'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model QueryTicketInfoResponse = {
  headers: map[string]string(name='headers'),
  body: QueryTicketInfoResponseBody(name='body'),
}

async function queryTicketInfo(request: QueryTicketInfoRequest): QueryTicketInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryTicketInfo', 'POST', '/', 'json', false, 'json', request);
}

model QueryUserGroupListByParentIdRequest {
  parentUserGroupId: string(name='ParentUserGroupId', position='Query'),
}

model QueryUserGroupListByParentIdResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      createTime?: string(name='CreateTime'),
      createUser?: string(name='CreateUser'),
      identifiedPath?: string(name='IdentifiedPath'),
      modifiedTime?: string(name='ModifiedTime'),
      modifyUser?: string(name='ModifyUser'),
      parentUserGroupId?: string(name='ParentUserGroupId'),
      userGroupDescription?: string(name='UserGroupDescription'),
      userGroupId?: string(name='UserGroupId'),
      userGroupName?: string(name='UserGroupName'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
}

model QueryUserGroupListByParentIdResponse = {
  headers: map[string]string(name='headers'),
  body: QueryUserGroupListByParentIdResponseBody(name='body'),
}

async function queryUserGroupListByParentId(request: QueryUserGroupListByParentIdRequest): QueryUserGroupListByParentIdResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryUserGroupListByParentId', 'POST', '/', 'json', false, 'json', request);
}

model QueryUserGroupMemberRequest {
  keyword?: string(name='Keyword', position='Query'),
  userGroupId: string(name='UserGroupId', position='Query'),
}

model QueryUserGroupMemberResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      id?: string(name='Id'),
      isUserGroup?: boolean(name='IsUserGroup'),
      name?: string(name='Name'),
      parentUserGroupId?: string(name='ParentUserGroupId'),
      parentUserGroupName?: string(name='ParentUserGroupName'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
}

model QueryUserGroupMemberResponse = {
  headers: map[string]string(name='headers'),
  body: QueryUserGroupMemberResponseBody(name='body'),
}

async function queryUserGroupMember(request: QueryUserGroupMemberRequest): QueryUserGroupMemberResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryUserGroupMember', 'POST', '/', 'json', false, 'json', request);
}

model QueryUserInfoByAccountRequest {
  account: string(name='Account', position='Query'),
}

model QueryUserInfoByAccountResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    accountId?: string(name='AccountId'),
    accountName?: string(name='AccountName'),
    adminUser?: boolean(name='AdminUser'),
    authAdminUser?: boolean(name='AuthAdminUser'),
    email?: string(name='Email'),
    nickName?: string(name='NickName'),
    phone?: string(name='Phone'),
    userId?: string(name='UserId'),
    userType?: int32(name='UserType'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model QueryUserInfoByAccountResponse = {
  headers: map[string]string(name='headers'),
  body: QueryUserInfoByAccountResponseBody(name='body'),
}

async function queryUserInfoByAccount(request: QueryUserInfoByAccountRequest): QueryUserInfoByAccountResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryUserInfoByAccount', 'POST', '/', 'json', false, 'json', request);
}

model QueryUserInfoByUserIdRequest {
  userId: string(name='UserId', position='Query'),
}

model QueryUserInfoByUserIdResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    accountId?: string(name='AccountId'),
    accountName?: string(name='AccountName'),
    adminUser?: boolean(name='AdminUser'),
    authAdminUser?: boolean(name='AuthAdminUser'),
    email?: string(name='Email'),
    nickName?: string(name='NickName'),
    phone?: string(name='Phone'),
    userId?: string(name='UserId'),
    userType?: int32(name='UserType'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model QueryUserInfoByUserIdResponse = {
  headers: map[string]string(name='headers'),
  body: QueryUserInfoByUserIdResponseBody(name='body'),
}

async function queryUserInfoByUserId(request: QueryUserInfoByUserIdRequest): QueryUserInfoByUserIdResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryUserInfoByUserId', 'POST', '/', 'json', false, 'json', request);
}

model QueryUserListRequest {
  keyword?: string(name='Keyword', position='Query'),
  pageNum?: int32(name='PageNum', minimum=1, maximum=99999999, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=1000, position='Query'),
}

model QueryUserListResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    data?: [ 
      {
        accountId?: string(name='AccountId'),
        accountName?: string(name='AccountName'),
        adminUser?: boolean(name='AdminUser'),
        authAdminUser?: boolean(name='AuthAdminUser'),
        nickName?: string(name='NickName'),
        userId?: string(name='UserId'),
        userType?: int32(name='UserType'),
      }
    ](name='Data'),
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    totalNum?: int32(name='TotalNum'),
    totalPages?: int32(name='TotalPages'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model QueryUserListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryUserListResponseBody(name='body'),
}

async function queryUserList(request: QueryUserListRequest): QueryUserListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryUserList', 'GET', '/', 'json', false, 'json', request);
}

model QueryUserRoleInfoInWorkspaceRequest {
  userId: string(name='UserId', position='Query'),
  workspaceId: string(name='WorkspaceId', position='Query'),
}

model QueryUserRoleInfoInWorkspaceResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    roleCode?: string(name='RoleCode'),
    roleId?: long(name='RoleId'),
    roleName?: string(name='RoleName'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model QueryUserRoleInfoInWorkspaceResponse = {
  headers: map[string]string(name='headers'),
  body: QueryUserRoleInfoInWorkspaceResponseBody(name='body'),
}

async function queryUserRoleInfoInWorkspace(request: QueryUserRoleInfoInWorkspaceRequest): QueryUserRoleInfoInWorkspaceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryUserRoleInfoInWorkspace', 'POST', '/', 'json', false, 'json', request);
}

model QueryUserTagMetaListRequest {
}

model QueryUserTagMetaListResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      tagDescription?: string(name='TagDescription'),
      tagId?: string(name='TagId'),
      tagName?: string(name='TagName'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
}

model QueryUserTagMetaListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryUserTagMetaListResponseBody(name='body'),
}

async function queryUserTagMetaList(request: QueryUserTagMetaListRequest): QueryUserTagMetaListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryUserTagMetaList', 'GET', '/', 'json', false, 'json', request);
}

model QueryUserTagValueListRequest {
  userId: string(name='UserId', position='Query'),
}

model QueryUserTagValueListResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      tagId?: string(name='TagId'),
      tagName?: string(name='TagName'),
      tagValue?: string(name='TagValue'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
}

model QueryUserTagValueListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryUserTagValueListResponseBody(name='body'),
}

async function queryUserTagValueList(request: QueryUserTagValueListRequest): QueryUserTagValueListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryUserTagValueList', 'GET', '/', 'json', false, 'json', request);
}

model QueryWorksRequest {
  worksId: string(name='WorksId', description='报表ID', position='Query'),
}

model QueryWorksResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    auth3rdFlag?: int32(name='Auth3rdFlag', description='第三方嵌入状态'),
    description?: string(name='Description', description='描述'),
    directory?: {
      id?: string(name='Id', description='目录ID'),
      name?: string(name='Name', description='目录名称'),
      pathId?: string(name='PathId', description='目录ID的路径，例如：aa/bb/cc/dd'),
      pathName?: string(name='PathName', description='目录ID的路径名称，例如：一层目录/二层目录'),
    }(name='Directory', description='所属空间目录信息'),
    gmtCreate?: string(name='GmtCreate', description='创建时间d'),
    gmtModify?: string(name='GmtModify', description='修改时间'),
    modifyName?: string(name='ModifyName', description='修改显示名称'),
    ownerId?: string(name='OwnerId', description='所有者Id'),
    ownerName?: string(name='OwnerName', description='所有者显示名称'),
    securityLevel?: string(name='SecurityLevel', description='安全策略：0 私有 1 协同编辑。 （'),
    status?: int32(name='Status', description='报表发布状态 @PublishStatusEnum'),
    workName?: string(name='WorkName', description='作品名称'),
    workType?: string(name='WorkType', description='作品类型'),
    worksId?: string(name='WorksId', description='作品ID'),
    workspaceId?: string(name='WorkspaceId', description='所属工作空间'),
    workspaceName?: string(name='WorkspaceName', description='所属空间名称'),
  }(name='Result', description='QueryWorksModel'),
  success?: boolean(name='Success'),
}

model QueryWorksResponse = {
  headers: map[string]string(name='headers'),
  body: QueryWorksResponseBody(name='body'),
}

async function queryWorks(request: QueryWorksRequest): QueryWorksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryWorks', 'POST', '/', 'json', false, 'json', request);
}

model QueryWorksBloodRelationshipRequest {
  worksId: string(name='WorksId', description='报表ID', position='Query'),
}

model QueryWorksBloodRelationshipResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      componentId?: string(name='ComponentId', description='组件ID or  sheetId'),
      componentName?: string(name='ComponentName'),
      componentType?: int32(name='ComponentType', description='组件类型'),
      componentTypeName?: string(name='ComponentTypeName'),
      datasetId?: string(name='DatasetId', description='数据集ID'),
      queryParams?: [ 
        {
          areaId?: string(name='AreaId', description='所属位置：'),
          areaName?: string(name='AreaName'),
          caption?: string(name='Caption', description='字段显示名称'),
          dataType?: string(name='DataType', description='字段类型'),
          isMeasure?: boolean(name='IsMeasure', description='是否是度量'),
          pathId?: string(name='PathId', description='全局唯一的PathId。位于cube的level中pathId'),
          uid?: string(name='Uid', description='字段唯一ID。即cube中的name'),
        }
      ](name='QueryParams', description='查询参数引用的列信息'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
}

model QueryWorksBloodRelationshipResponse = {
  headers: map[string]string(name='headers'),
  body: QueryWorksBloodRelationshipResponseBody(name='body'),
}

async function queryWorksBloodRelationship(request: QueryWorksBloodRelationshipRequest): QueryWorksBloodRelationshipResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryWorksBloodRelationship', 'POST', '/', 'json', false, 'json', request);
}

model QueryWorksByOrganizationRequest {
  pageNum?: int32(name='PageNum', minimum=1, maximum=99999999, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=1000, position='Query'),
  status?: int32(name='Status', position='Query'),
  thirdPartAuthFlag?: int32(name='ThirdPartAuthFlag', position='Query'),
  worksType?: string(name='WorksType', position='Query'),
}

model QueryWorksByOrganizationResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    data?: [ 
      {
        auth3rdFlag?: int32(name='Auth3rdFlag'),
        description?: string(name='Description'),
        directory?: {
          id?: string(name='Id'),
          name?: string(name='Name'),
          pathId?: string(name='PathId'),
          pathName?: string(name='PathName'),
        }(name='Directory'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModify?: string(name='GmtModify'),
        modifyName?: string(name='ModifyName'),
        ownerId?: string(name='OwnerId'),
        ownerName?: string(name='OwnerName'),
        securityLevel?: string(name='SecurityLevel'),
        status?: int32(name='Status'),
        workName?: string(name='WorkName'),
        workType?: string(name='WorkType'),
        worksId?: string(name='WorksId'),
        workspaceId?: string(name='WorkspaceId'),
        workspaceName?: string(name='WorkspaceName'),
      }
    ](name='Data'),
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    totalNum?: int32(name='TotalNum'),
    totalPages?: int32(name='TotalPages'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model QueryWorksByOrganizationResponse = {
  headers: map[string]string(name='headers'),
  body: QueryWorksByOrganizationResponseBody(name='body'),
}

async function queryWorksByOrganization(request: QueryWorksByOrganizationRequest): QueryWorksByOrganizationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryWorksByOrganization', 'POST', '/', 'json', false, 'json', request);
}

model QueryWorksByWorkspaceRequest {
  pageNum?: int32(name='PageNum', minimum=1, maximum=99999999, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=1000, position='Query'),
  status?: int32(name='Status', position='Query'),
  thirdPartAuthFlag?: int32(name='ThirdPartAuthFlag', position='Query'),
  worksType?: string(name='WorksType', position='Query'),
  workspaceId: string(name='WorkspaceId', position='Query'),
}

model QueryWorksByWorkspaceResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    data?: [ 
      {
        auth3rdFlag?: int32(name='Auth3rdFlag'),
        description?: string(name='Description'),
        directory?: {
          id?: string(name='Id'),
          name?: string(name='Name'),
          pathId?: string(name='PathId'),
          pathName?: string(name='PathName'),
        }(name='Directory'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModify?: string(name='GmtModify'),
        modifyName?: string(name='ModifyName'),
        ownerId?: string(name='OwnerId'),
        ownerName?: string(name='OwnerName'),
        securityLevel?: string(name='SecurityLevel'),
        status?: int32(name='Status'),
        workName?: string(name='WorkName'),
        workType?: string(name='WorkType'),
        worksId?: string(name='WorksId'),
        workspaceId?: string(name='WorkspaceId'),
        workspaceName?: string(name='WorkspaceName'),
      }
    ](name='Data'),
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    totalNum?: int32(name='TotalNum'),
    totalPages?: int32(name='TotalPages'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model QueryWorksByWorkspaceResponse = {
  headers: map[string]string(name='headers'),
  body: QueryWorksByWorkspaceResponseBody(name='body'),
}

async function queryWorksByWorkspace(request: QueryWorksByWorkspaceRequest): QueryWorksByWorkspaceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryWorksByWorkspace', 'POST', '/', 'json', false, 'json', request);
}

model QueryWorkspaceUserListRequest {
  keyword?: string(name='Keyword', position='Query'),
  pageNum?: int32(name='PageNum', minimum=1, maximum=1000000, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=1000, position='Query'),
  workspaceId: string(name='WorkspaceId', position='Query'),
}

model QueryWorkspaceUserListResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    data?: [ 
      {
        accountId?: string(name='AccountId'),
        accountName?: string(name='AccountName'),
        nickName?: string(name='NickName'),
        role?: {
          roleCode?: string(name='RoleCode'),
          roleId?: long(name='RoleId'),
          roleName?: string(name='RoleName'),
        }(name='Role'),
        userId?: string(name='UserId'),
      }
    ](name='Data'),
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    totalNum?: int32(name='TotalNum'),
    totalPages?: int32(name='TotalPages'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model QueryWorkspaceUserListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryWorkspaceUserListResponseBody(name='body'),
}

async function queryWorkspaceUserList(request: QueryWorkspaceUserListRequest): QueryWorkspaceUserListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryWorkspaceUserList', 'POST', '/', 'json', false, 'json', request);
}

model SaveFavoritesRequest {
  userId: string(name='UserId', position='Query'),
  worksId: string(name='WorksId', position='Query'),
}

model SaveFavoritesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model SaveFavoritesResponse = {
  headers: map[string]string(name='headers'),
  body: SaveFavoritesResponseBody(name='body'),
}

async function saveFavorites(request: SaveFavoritesRequest): SaveFavoritesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SaveFavorites', 'POST', '/', 'json', false, 'json', request);
}

model SetDataLevelPermissionExtraConfigRequest {
  cubeId: string(name='CubeId', position='Query'),
  missHitPolicy: string(name='MissHitPolicy', position='Query'),
  ruleType: string(name='RuleType', position='Query'),
}

model SetDataLevelPermissionExtraConfigResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model SetDataLevelPermissionExtraConfigResponse = {
  headers: map[string]string(name='headers'),
  body: SetDataLevelPermissionExtraConfigResponseBody(name='body'),
}

async function setDataLevelPermissionExtraConfig(request: SetDataLevelPermissionExtraConfigRequest): SetDataLevelPermissionExtraConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetDataLevelPermissionExtraConfig', 'POST', '/', 'json', false, 'json', request);
}

model SetDataLevelPermissionRuleConfigRequest {
  ruleModel: string(name='RuleModel', position='Query'),
}

model SetDataLevelPermissionRuleConfigResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
  success?: boolean(name='Success'),
}

model SetDataLevelPermissionRuleConfigResponse = {
  headers: map[string]string(name='headers'),
  body: SetDataLevelPermissionRuleConfigResponseBody(name='body'),
}

async function setDataLevelPermissionRuleConfig(request: SetDataLevelPermissionRuleConfigRequest): SetDataLevelPermissionRuleConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetDataLevelPermissionRuleConfig', 'POST', '/', 'json', false, 'json', request);
}

model SetDataLevelPermissionWhiteListRequest {
  whiteListModel: string(name='WhiteListModel', position='Query'),
}

model SetDataLevelPermissionWhiteListResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model SetDataLevelPermissionWhiteListResponse = {
  headers: map[string]string(name='headers'),
  body: SetDataLevelPermissionWhiteListResponseBody(name='body'),
}

async function setDataLevelPermissionWhiteList(request: SetDataLevelPermissionWhiteListRequest): SetDataLevelPermissionWhiteListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetDataLevelPermissionWhiteList', 'POST', '/', 'json', false, 'json', request);
}

model UpdateDataLevelPermissionStatusRequest {
  cubeId: string(name='CubeId', position='Query'),
  isOpen: int32(name='IsOpen', minimum=0, maximum=10, position='Query'),
  ruleType: string(name='RuleType', position='Query'),
}

model UpdateDataLevelPermissionStatusResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model UpdateDataLevelPermissionStatusResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateDataLevelPermissionStatusResponseBody(name='body'),
}

async function updateDataLevelPermissionStatus(request: UpdateDataLevelPermissionStatusRequest): UpdateDataLevelPermissionStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateDataLevelPermissionStatus', 'POST', '/', 'json', false, 'json', request);
}

model UpdateEmbeddedStatusRequest {
  thirdPartAuthFlag: boolean(name='ThirdPartAuthFlag', position='Query'),
  worksId: string(name='WorksId', position='Query'),
}

model UpdateEmbeddedStatusResponseBody = {
  requestId?: string(name='RequestId'),
  result?: int32(name='Result'),
  success?: boolean(name='Success'),
}

model UpdateEmbeddedStatusResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateEmbeddedStatusResponseBody(name='body'),
}

async function updateEmbeddedStatus(request: UpdateEmbeddedStatusRequest): UpdateEmbeddedStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateEmbeddedStatus', 'POST', '/', 'json', false, 'json', request);
}

model UpdateTicketNumRequest {
  ticket: string(name='Ticket', position='Query'),
  ticketNum: int32(name='TicketNum', position='Query'),
}

model UpdateTicketNumResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model UpdateTicketNumResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateTicketNumResponseBody(name='body'),
}

async function updateTicketNum(request: UpdateTicketNumRequest): UpdateTicketNumResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateTicketNum', 'POST', '/', 'json', false, 'json', request);
}

model UpdateUserRequest {
  adminUser: boolean(name='AdminUser', position='Query'),
  authAdminUser: boolean(name='AuthAdminUser', position='Query'),
  nickName: string(name='NickName', position='Query'),
  userId: string(name='UserId', position='Query'),
  userType: int32(name='UserType', minimum=1, maximum=10, position='Query'),
}

model UpdateUserResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model UpdateUserResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateUserResponseBody(name='body'),
}

async function updateUser(request: UpdateUserRequest): UpdateUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateUser', 'POST', '/', 'json', false, 'json', request);
}

model UpdateUserGroupRequest {
  userGroupDescription?: string(name='UserGroupDescription', position='Query'),
  userGroupId: string(name='UserGroupId', position='Query'),
  userGroupName?: string(name='UserGroupName', position='Query'),
}

model UpdateUserGroupResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model UpdateUserGroupResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateUserGroupResponseBody(name='body'),
}

async function updateUserGroup(request: UpdateUserGroupRequest): UpdateUserGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateUserGroup', 'POST', '/', 'json', false, 'json', request);
}

model UpdateUserTagMetaRequest {
  tagDescription?: string(name='TagDescription', position='Query'),
  tagId: string(name='TagId', position='Query'),
  tagName: string(name='TagName', position='Query'),
}

model UpdateUserTagMetaResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model UpdateUserTagMetaResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateUserTagMetaResponseBody(name='body'),
}

async function updateUserTagMeta(request: UpdateUserTagMetaRequest): UpdateUserTagMetaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateUserTagMeta', 'POST', '/', 'json', false, 'json', request);
}

model UpdateUserTagValueRequest {
  tagId: string(name='TagId', position='Query'),
  tagValue: string(name='TagValue', position='Query'),
  userId: string(name='UserId', position='Query'),
}

model UpdateUserTagValueResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model UpdateUserTagValueResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateUserTagValueResponseBody(name='body'),
}

async function updateUserTagValue(request: UpdateUserTagValueRequest): UpdateUserTagValueResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateUserTagValue', 'POST', '/', 'json', false, 'json', request);
}

model UpdateWorkspaceUserRoleRequest {
  roleId: long(name='RoleId', minimum=25, maximum=30, position='Query'),
  userId: string(name='UserId', position='Query'),
  workspaceId: string(name='WorkspaceId', position='Query'),
}

model UpdateWorkspaceUserRoleResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model UpdateWorkspaceUserRoleResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateWorkspaceUserRoleResponseBody(name='body'),
}

async function updateWorkspaceUserRole(request: UpdateWorkspaceUserRoleRequest): UpdateWorkspaceUserRoleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateWorkspaceUserRole', 'POST', '/', 'json', false, 'json', request);
}

model UpdateWorkspaceUsersRoleRequest {
  roleId: long(name='RoleId', minimum=25, maximum=30, position='Query'),
  userIds: string(name='UserIds', position='Query'),
  workspaceId: string(name='WorkspaceId', position='Query'),
}

model UpdateWorkspaceUsersRoleResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    failure?: int32(name='Failure'),
    failureDetail?: map[string]any(name='FailureDetail'),
    success?: int32(name='Success'),
    total?: int32(name='Total'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model UpdateWorkspaceUsersRoleResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateWorkspaceUsersRoleResponseBody(name='body'),
}

async function updateWorkspaceUsersRole(request: UpdateWorkspaceUsersRoleRequest): UpdateWorkspaceUsersRoleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateWorkspaceUsersRole', 'POST', '/', 'json', false, 'json', request);
}

model WithdrawAllUserGroupsRequest {
  userId: string(name='UserId', position='Query'),
}

model WithdrawAllUserGroupsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model WithdrawAllUserGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: WithdrawAllUserGroupsResponseBody(name='body'),
}

async function withdrawAllUserGroups(request: WithdrawAllUserGroupsRequest): WithdrawAllUserGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'WithdrawAllUserGroups', 'POST', '/', 'json', false, 'json', request);
}

