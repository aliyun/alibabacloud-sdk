/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('batchcompute', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model Attempt {
  endTime?: string(name='EndTime'),
  exitCode?: int32(name='ExitCode'),
  output?: bytes(name='Output'),
  pid?: int32(name='Pid'),
  reason?: string(name='Reason'),
  startTime?: string(name='StartTime'),
  state?: string(name='State'),
  userStages?: [
    UserStage
  ](name='UserStages'),
  worker?: string(name='Worker'),
}

model AutoScaling {
  scaling?: Scaling(name='Scaling'),
  trigger?: Trigger(name='Trigger'),
}

model Bootstrap {
  background?: boolean(name='Background'),
  command?: [ string ](name='Command'),
  envs?: map[string]string(name='Envs'),
  loggings?: [
    Logging
  ](name='Loggings'),
  mountPoints?: [
    MountPoint
  ](name='MountPoints'),
  packageUri?: string(name='PackageUri'),
  runningTimeout?: int32(name='RunningTimeout'),
  runtimes?: BootstrapRuntime(name='Runtimes'),
  volumes?: [
    Volume
  ](name='Volumes'),
}

model BootstrapRuntime {
  docker?: Docker(name='Docker'),
  shareDirectory?: string(name='ShareDirectory'),
}

model ClusterDefinition {
  autoScaling?: [
    AutoScaling
  ](name='AutoScaling'),
  bootstrap?: Bootstrap(name='Bootstrap'),
  credentialConfigs?: CredentialConfig(name='CredentialConfigs'),
  docker?: Docker(name='Docker'),
  ECS?: ECS(name='ECS'),
  livenessProbe?: Probe(name='LivenessProbe'),
  managedJobQueue?: boolean(name='ManagedJobQueue'),
  mountPoints?: [
    MountPoint
  ](name='MountPoints'),
  providerType?: string(name='ProviderType'),
  resources?: map[string]string(name='Resources'),
  SLB?: SLB(name='SLB'),
  scaleDownDelay?: int32(name='ScaleDownDelay'),
  scaleUpDelay?: int32(name='ScaleUpDelay'),
  scaling?: Scaling(name='Scaling'),
  startupProbe?: Probe(name='StartupProbe'),
  upgradePolicy?: UpgradePolicy(name='UpgradePolicy'),
  VPC?: VPC(name='VPC'),
  volumes?: [
    Volume
  ](name='Volumes'),
  workerType?: string(name='WorkerType'),
}

model Conditions {
  condition?: string(name='Condition'),
  errors?: [
    Errors
  ](name='Errors'),
  lastProbeTime?: string(name='LastProbeTime'),
  lastTransitionTime?: string(name='LastTransitionTime'),
  status?: string(name='Status'),
}

model CredentialConfig {
  chain?: [
    ServiceRoleNode
  ](name='Chain'),
  policy?: string(name='Policy'),
  serviceRole?: string(name='ServiceRole'),
}

model Destination {
  OSS?: OSSDescription(name='OSS'),
  PDS?: PDSDescription(name='PDS'),
}

model Docker {
  credentialType?: string(name='CredentialType'),
  exposedPorts?: [
    ExposedPort
  ](name='ExposedPorts'),
  image?: string(name='Image'),
}

model ECS {
  hostnamePrefix?: string(name='HostnamePrefix'),
  instanceType?: string(name='InstanceType'),
  passwordInherit?: boolean(name='PasswordInherit'),
  resourceType?: string(name='ResourceType'),
  spotPriceLimit?: string(name='SpotPriceLimit'),
  spotStrategy?: string(name='SpotStrategy'),
  systemDiskSize?: int32(name='SystemDiskSize'),
  systemDiskType?: string(name='SystemDiskType'),
  VMImage?: string(name='VMImage'),
}

model Errors {
  action?: string(name='Action'),
  code?: string(name='Code'),
  message?: string(name='Message'),
  repeat?: int32(name='Repeat'),
}

model Exec {
  exec?: ExecAction(name='Exec'),
}

model ExecAction {
  command?: [ string ](name='Command'),
}

model ExposedPort {
  containerPort?: int32(name='ContainerPort'),
  hostPorts?: [ int32 ](name='HostPorts'),
  proto?: string(name='Proto'),
}

model FailStrategy {
  maxRetries?: int32(name='MaxRetries'),
  runningTimeout?: int32(name='RunningTimeout'),
  successCode?: [ int32 ](name='SuccessCode'),
  waitingTimeout?: int32(name='WaitingTimeout'),
}

model HTTPGet {
  HTTPGet?: HTTPGetAction(name='HTTPGet'),
}

model HTTPGetAction {
  host?: string(name='Host'),
  httpHeaders?: [
    HTTPHeader
  ](name='HttpHeaders'),
  path?: string(name='Path'),
  port?: int32(name='Port'),
  scheme?: string(name='Scheme'),
}

model HTTPHeader {
  name?: string(name='Name'),
  value?: string(name='Value'),
}

model Handler {
  exec?: ExecAction(name='Exec'),
  httpGet?: HTTPGetAction(name='HttpGet'),
}

model Input {
  fileMode?: string(name='FileMode'),
  filePath?: string(name='FilePath'),
  source?: Source(name='Source'),
}

model JobDefinition {
  command?: [ string ](name='Command'),
  credentialConfig?: CredentialConfig(name='CredentialConfig'),
  envs?: map[string]string(name='Envs'),
  failStrategy?: FailStrategy(name='FailStrategy'),
  inputs?: [
    Input
  ](name='Inputs'),
  labels?: map[string]string(name='Labels'),
  loggings?: [
    Logging
  ](name='Loggings'),
  mountPoints?: [
    MountPoint
  ](name='MountPoints'),
  notification?: Notification(name='Notification'),
  outputs?: [
    Output
  ](name='Outputs'),
  packageUri?: string(name='PackageUri'),
  releaseStrategy?: ReleaseStrategy(name='ReleaseStrategy'),
  resources?: map[string]string(name='Resources'),
  runtimes?: Runtimes(name='Runtimes'),
  userData?: map[string]string(name='UserData'),
  volumes?: [
    Volume
  ](name='Volumes'),
}

model JobQueueDefinition {
  labels?: map[string]string(name='Labels'),
  priority?: int32(name='Priority'),
  providerConfigs?: [
    ProviderConfig
  ](name='ProviderConfigs'),
  schedulerConfig?: {
    state?: string(name='State'),
  }(name='SchedulerConfig'),
  type?: string(name='Type'),
}

model JobQueueStatus {
  allocatableResources?: map[string]string(name='AllocatableResources'),
  allocatedResources?: map[string]string(name='AllocatedResources'),
  createTime?: string(name='CreateTime'),
  lastUpdateTime?: string(name='LastUpdateTime'),
  managed?: boolean(name='Managed'),
  providerStatuses?: [
    ProviderStatus
  ](name='ProviderStatuses'),
  reason?: string(name='Reason'),
  schedulerStatus?: SchedulerStatus(name='SchedulerStatus'),
  state?: string(name='State'),
}

model Logging {
  name?: string(name='Name'),
  OSS?: OSSLogging(name='OSS'),
  path?: string(name='Path'),
  SLS?: SLSLogging(name='SLS'),
}

model MNSNotification {
  endpoint?: string(name='Endpoint'),
  filters?: [ string ](name='Filters'),
  topic?: string(name='Topic'),
}

model MountPoint {
  mountPath?: string(name='MountPath'),
  name?: string(name='Name'),
  readOnly?: boolean(name='ReadOnly'),
  subPath?: string(name='SubPath'),
}

model NFSVolumeSource {
  path?: string(name='Path'),
  readOnly?: boolean(name='ReadOnly'),
  server?: string(name='Server'),
  version?: string(name='Version'),
}

model Notification {
  MNS?: MNSNotification(name='MNS'),
}

model OSSDescription {
  bucket?: string(name='Bucket'),
  credentialType?: string(name='CredentialType'),
  object?: string(name='Object'),
  prefix?: string(name='Prefix'),
}

model OSSLogging {
  bucket?: string(name='Bucket'),
  prefix?: string(name='Prefix'),
}

model OSSVolumeSource {
  bucket?: string(name='Bucket'),
  credentialType?: string(name='CredentialType'),
  objects?: [ string ](name='Objects'),
  prefix?: string(name='Prefix'),
  readOnly?: boolean(name='ReadOnly'),
}

model Output {
  destination?: Destination(name='Destination'),
  filePattern?: string(name='FilePattern'),
  uploadConditions?: [ string ](name='UploadConditions'),
  uploadMode?: string(name='UploadMode'),
}

model PDSDescription {
  domain?: string(name='Domain'),
  drive?: string(name='Drive'),
  object?: string(name='Object'),
  prefix?: string(name='Prefix'),
}

model PDSVolumeSource {
  domain?: string(name='Domain'),
  drive?: string(name='Drive'),
  objects?: [ string ](name='Objects'),
  prefix?: string(name='Prefix'),
  readOnly?: boolean(name='ReadOnly'),
}

model Probe {
  failureThreshold?: int32(name='FailureThreshold'),
  handler?: Handler(name='Handler'),
  initialDelaySeconds?: int32(name='InitialDelaySeconds'),
  periodSeconds?: int32(name='PeriodSeconds'),
  successThreshold?: int32(name='SuccessThreshold'),
  timeoutSeconds?: int32(name='TimeoutSeconds'),
}

model ProjectDefinition {
  jobLifecycle?: int32(name='JobLifecycle'),
  labels?: map[string]string(name='Labels'),
  role?: string(name='Role'),
}

model ProviderConfig {
  maxWorkerCount?: int32(name='MaxWorkerCount'),
  minWorkerCount?: int32(name='MinWorkerCount'),
  providerId?: string(name='ProviderId'),
  providerType?: string(name='ProviderType'),
  workerType?: string(name='WorkerType'),
}

model ProviderStatus {
  allocatableResources?: map[string]string(name='AllocatableResources'),
  allocatedResources?: map[string]string(name='AllocatedResources'),
  providerId?: string(name='ProviderId'),
}

model ReleaseCondition {
  state?: string(name='State'),
  TTLSeconds?: long(name='TTLSeconds'),
}

model ReleaseStrategy {
  releaseConditions?: [
    ReleaseCondition
  ](name='ReleaseConditions'),
}

model Runtimes {
  dataDisks?: [ 
    {
      path?: string(name='Path'),
      size?: int32(name='Size'),
      type?: string(name='Type'),
    }
  ](name='DataDisks'),
  docker?: Docker(name='Docker'),
  ECS?: ECS(name='ECS'),
  jobQueue?: string(name='JobQueue'),
  VPC?: VPC(name='VPC'),
}

model SLB {
  SLBId?: string(name='SLBId'),
}

model SLSLogging {
  logtailConfigName?: string(name='LogtailConfigName'),
  project?: string(name='Project'),
  store?: string(name='Store'),
}

model Scaling {
  adjustmentType?: string(name='AdjustmentType'),
  adjustmentValue?: float(name='AdjustmentValue'),
  maxWorkerCount?: int32(name='MaxWorkerCount'),
  minWorkerCount?: int32(name='MinWorkerCount'),
}

model SchedulerStatus {
  canceledJobCount?: long(name='CanceledJobCount'),
  failedJobCount?: long(name='FailedJobCount'),
  runningJobCount?: long(name='RunningJobCount'),
  succeededJobCount?: long(name='SucceededJobCount'),
  waitingJobCount?: long(name='WaitingJobCount'),
}

model ServiceRoleNode {
  assumeRoleFor?: string(name='AssumeRoleFor'),
  role?: string(name='Role'),
  roleType?: string(name='RoleType'),
}

model Source {
  OSS?: OSSDescription(name='OSS'),
  PDS?: PDSDescription(name='PDS'),
}

model Trigger {
  desiredMetricValue?: double(name='DesiredMetricValue'),
  desiredRecoverTime?: int32(name='DesiredRecoverTime'),
  enabled?: boolean(name='Enabled'),
  firstLaunchTime?: string(name='FirstLaunchTime'),
  metricType?: string(name='MetricType'),
  period?: int32(name='Period'),
  repeatType?: string(name='RepeatType'),
  repeatValue?: string(name='RepeatValue'),
  statisticalMethod?: string(name='StatisticalMethod'),
  toleranceValue?: double(name='ToleranceValue'),
}

model UpgradePolicy {
  upgradeRatio?: float(name='UpgradeRatio'),
}

model UserStage {
  description?: string(name='Description'),
  endTime?: int32(name='EndTime'),
  startTime?: int32(name='StartTime'),
  state?: string(name='State'),
}

model VPC {
  securityGroups?: [ string ](name='SecurityGroups'),
  VPCId?: string(name='VPCId'),
  vSwitches?: [ string ](name='VSwitches'),
}

model Volume {
  NFS?: NFSVolumeSource(name='NFS'),
  name?: string(name='Name'),
  OSS?: OSSVolumeSource(name='OSS'),
  PDS?: PDSVolumeSource(name='PDS'),
}

model WorkerStatus {
  conditions?: [
    Conditions
  ](name='Conditions'),
  container?: {
    cpu?: int32(name='Cpu'),
    memory?: int32(name='Memory'),
  }(name='Container'),
  createTime?: string(name='CreateTime'),
  ECS?: {
    cpu?: int32(name='Cpu'),
    endpoint?: string(name='Endpoint'),
    hostname?: string(name='Hostname'),
    instanceId?: string(name='InstanceId'),
    instanceType?: string(name='InstanceType'),
    memory?: int32(name='Memory'),
    password?: string(name='Password'),
    resourceType?: string(name='ResourceType'),
    spotPriceLimit?: string(name='SpotPriceLimit'),
    spotStrategy?: string(name='SpotStrategy'),
    systemDiskSize?: int32(name='SystemDiskSize'),
    systemDiskType?: string(name='SystemDiskType'),
    VMImage?: string(name='VMImage'),
    zoneId?: string(name='ZoneId'),
  }(name='ECS'),
  jobQueue?: string(name='JobQueue'),
  networkInterfaceId?: string(name='NetworkInterfaceId'),
  poolWorkerId?: string(name='PoolWorkerId'),
  securityGroupId?: string(name='SecurityGroupId'),
  state?: string(name='State'),
  vSwitchId?: string(name='VSwitchId'),
  workerType?: int32(name='WorkerType'),
}

model CancelJobRequest {
  exitCode?: string(name='ExitCode'),
  jobId?: string(name='JobId'),
  project?: string(name='Project'),
  reason?: string(name='Reason'),
}

model CancelJobResponseBody = {
  hostId?: string(name='HostId'),
  requestId?: string(name='RequestId'),
}

model CancelJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelJobResponseBody(name='body'),
}

async function cancelJobWithOptions(request: CancelJobRequest, runtime: Util.RuntimeOptions): CancelJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.exitCode)) {
    query['ExitCode'] = request.exitCode;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.reason)) {
    query['Reason'] = request.reason;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelJob',
    version = '2018-12-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cancelJob(request: CancelJobRequest): CancelJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelJobWithOptions(request, runtime);
}

model CreateClusterRequest {
  clientToken?: string(name='ClientToken'),
  definition?: ClusterDefinition(name='Definition'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  project?: string(name='Project'),
}

model CreateClusterShrinkRequest {
  clientToken?: string(name='ClientToken'),
  definitionShrink?: string(name='Definition'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  project?: string(name='Project'),
}

model CreateClusterResponseBody = {
  clusterId?: string(name='ClusterId'),
  hostId?: string(name='HostId'),
  requestId?: string(name='RequestId'),
}

model CreateClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateClusterResponseBody(name='body'),
}

async function createClusterWithOptions(tmpReq: CreateClusterRequest, runtime: Util.RuntimeOptions): CreateClusterResponse {
  Util.validateModel(tmpReq);
  var request = new CreateClusterShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.definition)) {
    request.definitionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.definition, 'Definition', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.definitionShrink)) {
    body['Definition'] = request.definitionShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateCluster',
    version = '2018-12-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createCluster(request: CreateClusterRequest): CreateClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return createClusterWithOptions(request, runtime);
}

model CreateJobRequest {
  clientToken?: string(name='ClientToken'),
  definition?: JobDefinition(name='Definition'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  project?: string(name='Project'),
}

model CreateJobShrinkRequest {
  clientToken?: string(name='ClientToken'),
  definitionShrink?: string(name='Definition'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  project?: string(name='Project'),
}

model CreateJobResponseBody = {
  hostId?: string(name='HostId'),
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model CreateJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateJobResponseBody(name='body'),
}

async function createJobWithOptions(tmpReq: CreateJobRequest, runtime: Util.RuntimeOptions): CreateJobResponse {
  Util.validateModel(tmpReq);
  var request = new CreateJobShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.definition)) {
    request.definitionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.definition, 'Definition', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.definitionShrink)) {
    body['Definition'] = request.definitionShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateJob',
    version = '2018-12-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createJob(request: CreateJobRequest): CreateJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return createJobWithOptions(request, runtime);
}

model CreateJobQueueRequest {
  clientToken?: string(name='ClientToken'),
  definition?: JobQueueDefinition(name='Definition'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  project?: string(name='Project'),
}

model CreateJobQueueShrinkRequest {
  clientToken?: string(name='ClientToken'),
  definitionShrink?: string(name='Definition'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  project?: string(name='Project'),
}

model CreateJobQueueResponseBody = {
  hostId?: string(name='HostId'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
}

model CreateJobQueueResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateJobQueueResponseBody(name='body'),
}

async function createJobQueueWithOptions(tmpReq: CreateJobQueueRequest, runtime: Util.RuntimeOptions): CreateJobQueueResponse {
  Util.validateModel(tmpReq);
  var request = new CreateJobQueueShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.definition)) {
    request.definitionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.definition, 'Definition', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.definitionShrink)) {
    body['Definition'] = request.definitionShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateJobQueue',
    version = '2018-12-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createJobQueue(request: CreateJobQueueRequest): CreateJobQueueResponse {
  var runtime = new Util.RuntimeOptions{};
  return createJobQueueWithOptions(request, runtime);
}

model CreateProjectRequest {
  clientToken?: string(name='ClientToken'),
  definition?: ProjectDefinition(name='Definition'),
  description?: string(name='Description'),
  project?: string(name='Project'),
}

model CreateProjectShrinkRequest {
  clientToken?: string(name='ClientToken'),
  definitionShrink?: string(name='Definition'),
  description?: string(name='Description'),
  project?: string(name='Project'),
}

model CreateProjectResponseBody = {
  hostId?: string(name='HostId'),
  project?: string(name='Project'),
  requestId?: string(name='RequestId'),
}

model CreateProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateProjectResponseBody(name='body'),
}

async function createProjectWithOptions(tmpReq: CreateProjectRequest, runtime: Util.RuntimeOptions): CreateProjectResponse {
  Util.validateModel(tmpReq);
  var request = new CreateProjectShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.definition)) {
    request.definitionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.definition, 'Definition', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.definitionShrink)) {
    body['Definition'] = request.definitionShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateProject',
    version = '2018-12-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createProject(request: CreateProjectRequest): CreateProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return createProjectWithOptions(request, runtime);
}

model DeleteClusterRequest {
  clusterId?: string(name='ClusterId'),
  project?: string(name='Project'),
}

model DeleteClusterResponseBody = {
  hostId?: string(name='HostId'),
  requestId?: string(name='RequestId'),
}

model DeleteClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteClusterResponseBody(name='body'),
}

async function deleteClusterWithOptions(request: DeleteClusterRequest, runtime: Util.RuntimeOptions): DeleteClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCluster',
    version = '2018-12-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteCluster(request: DeleteClusterRequest): DeleteClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteClusterWithOptions(request, runtime);
}

model DeleteJobRequest {
  jobId?: string(name='JobId'),
  project?: string(name='Project'),
}

model DeleteJobResponseBody = {
  hostId?: string(name='HostId'),
  requestId?: string(name='RequestId'),
}

model DeleteJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteJobResponseBody(name='body'),
}

async function deleteJobWithOptions(request: DeleteJobRequest, runtime: Util.RuntimeOptions): DeleteJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteJob',
    version = '2018-12-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteJob(request: DeleteJobRequest): DeleteJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteJobWithOptions(request, runtime);
}

model DeleteJobQueueRequest {
  name?: string(name='Name'),
  project?: string(name='Project'),
}

model DeleteJobQueueResponseBody = {
  hostId?: string(name='HostId'),
  requestId?: string(name='RequestId'),
}

model DeleteJobQueueResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteJobQueueResponseBody(name='body'),
}

async function deleteJobQueueWithOptions(request: DeleteJobQueueRequest, runtime: Util.RuntimeOptions): DeleteJobQueueResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteJobQueue',
    version = '2018-12-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteJobQueue(request: DeleteJobQueueRequest): DeleteJobQueueResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteJobQueueWithOptions(request, runtime);
}

model DeleteProjectRequest {
  project?: string(name='Project'),
}

model DeleteProjectResponseBody = {
  hostId?: string(name='HostId'),
  requestId?: string(name='RequestId'),
}

model DeleteProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteProjectResponseBody(name='body'),
}

async function deleteProjectWithOptions(request: DeleteProjectRequest, runtime: Util.RuntimeOptions): DeleteProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteProject',
    version = '2018-12-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteProject(request: DeleteProjectRequest): DeleteProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteProjectWithOptions(request, runtime);
}

model GetClusterRequest {
  clusterId?: string(name='ClusterId'),
  project?: string(name='Project'),
}

model GetClusterResponseBody = {
  clusterId?: string(name='ClusterId'),
  definition?: ClusterDefinition(name='Definition'),
  description?: string(name='Description'),
  hostId?: string(name='HostId'),
  name?: string(name='Name'),
  ownerId?: string(name='OwnerId'),
  project?: string(name='Project'),
  requestId?: string(name='RequestId'),
  status?: {
    allocatableResources?: map[string]string(name='AllocatableResources'),
    allocatedResources?: map[string]string(name='AllocatedResources'),
    conditions?: [
      Conditions
    ](name='Conditions'),
    createTime?: string(name='CreateTime'),
    currentWorkerCount?: int32(name='CurrentWorkerCount'),
    desiredWorkerCount?: int32(name='DesiredWorkerCount'),
    state?: string(name='State'),
  }(name='Status'),
}

model GetClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetClusterResponseBody(name='body'),
}

async function getClusterWithOptions(request: GetClusterRequest, runtime: Util.RuntimeOptions): GetClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCluster',
    version = '2018-12-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getCluster(request: GetClusterRequest): GetClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return getClusterWithOptions(request, runtime);
}

model GetJobRequest {
  jobId?: string(name='JobId'),
  project?: string(name='Project'),
}

model GetJobResponseBody = {
  definition?: JobDefinition(name='Definition'),
  description?: string(name='Description'),
  hostId?: string(name='HostId'),
  jobId?: string(name='JobId'),
  name?: string(name='Name'),
  ownerId?: string(name='OwnerId'),
  project?: string(name='Project'),
  requestId?: string(name='RequestId'),
  status?: {
    attempts?: [
      Attempt
    ](name='Attempts'),
    createTime?: string(name='CreateTime'),
    endTime?: string(name='EndTime'),
    exitCode?: int32(name='ExitCode'),
    pid?: int32(name='Pid'),
    reason?: string(name='Reason'),
    startTime?: string(name='StartTime'),
    state?: string(name='State'),
    worker?: string(name='Worker'),
  }(name='Status'),
}

model GetJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetJobResponseBody(name='body'),
}

async function getJobWithOptions(request: GetJobRequest, runtime: Util.RuntimeOptions): GetJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetJob',
    version = '2018-12-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getJob(request: GetJobRequest): GetJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return getJobWithOptions(request, runtime);
}

model GetJobQueueRequest {
  name?: string(name='Name'),
  project?: string(name='Project'),
}

model GetJobQueueResponseBody = {
  definition?: JobQueueDefinition(name='Definition'),
  description?: string(name='Description'),
  hostId?: string(name='HostId'),
  name?: string(name='Name'),
  ownerId?: string(name='OwnerId'),
  project?: string(name='Project'),
  requestId?: string(name='RequestId'),
  status?: JobQueueStatus(name='Status'),
}

model GetJobQueueResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetJobQueueResponseBody(name='body'),
}

async function getJobQueueWithOptions(request: GetJobQueueRequest, runtime: Util.RuntimeOptions): GetJobQueueResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetJobQueue',
    version = '2018-12-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getJobQueue(request: GetJobQueueRequest): GetJobQueueResponse {
  var runtime = new Util.RuntimeOptions{};
  return getJobQueueWithOptions(request, runtime);
}

model GetProjectRequest {
  project?: string(name='Project'),
}

model GetProjectResponseBody = {
  definition?: ProjectDefinition(name='Definition'),
  description?: string(name='Description'),
  hostId?: string(name='HostId'),
  project?: string(name='Project'),
  requestId?: string(name='RequestId'),
  status?: {
    createTime?: string(name='CreateTime'),
    lastModifiedTime?: string(name='LastModifiedTime'),
  }(name='Status'),
}

model GetProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetProjectResponseBody(name='body'),
}

async function getProjectWithOptions(request: GetProjectRequest, runtime: Util.RuntimeOptions): GetProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetProject',
    version = '2018-12-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getProject(request: GetProjectRequest): GetProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return getProjectWithOptions(request, runtime);
}

model GetWorkerRequest {
  clusterId?: string(name='ClusterId'),
  project?: string(name='Project'),
  workerId?: string(name='WorkerId'),
}

model GetWorkerResponseBody = {
  definition?: {
    bootstrap?: Bootstrap(name='Bootstrap'),
    docker?: Docker(name='Docker'),
    livenessProbe?: Probe(name='LivenessProbe'),
    mountPoints?: [
      MountPoint
    ](name='MountPoints'),
    startupProbe?: Probe(name='StartupProbe'),
    volumes?: [
      Volume
    ](name='Volumes'),
  }(name='Definition'),
  hostId?: string(name='HostId'),
  requestId?: string(name='RequestId'),
  status?: {
    allocateTime?: string(name='AllocateTime'),
    conditions?: [
      Conditions
    ](name='Conditions'),
    container?: {
      cpu?: int32(name='Cpu'),
      memory?: int32(name='Memory'),
    }(name='Container'),
    createTime?: string(name='CreateTime'),
    ECS?: {
      cpu?: int32(name='Cpu'),
      instanceType?: string(name='InstanceType'),
      memory?: int32(name='Memory'),
      resourceType?: string(name='ResourceType'),
      spotPriceLimit?: string(name='SpotPriceLimit'),
      spotStrategy?: string(name='SpotStrategy'),
      systemDiskSize?: int32(name='SystemDiskSize'),
      systemDiskType?: string(name='SystemDiskType'),
      VMImage?: string(name='VMImage'),
      zoneId?: string(name='ZoneId'),
    }(name='ECS'),
    jobQueue?: string(name='JobQueue'),
    networkInterfaceId?: string(name='NetworkInterfaceId'),
    poolWorkerId?: string(name='PoolWorkerId'),
    securityGroupId?: string(name='SecurityGroupId'),
    state?: string(name='State'),
    vSwitchId?: string(name='VSwitchId'),
    workerType?: int32(name='WorkerType'),
  }(name='Status'),
  workerId?: string(name='WorkerId'),
}

model GetWorkerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetWorkerResponseBody(name='body'),
}

async function getWorkerWithOptions(request: GetWorkerRequest, runtime: Util.RuntimeOptions): GetWorkerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.workerId)) {
    query['WorkerId'] = request.workerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetWorker',
    version = '2018-12-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getWorker(request: GetWorkerRequest): GetWorkerResponse {
  var runtime = new Util.RuntimeOptions{};
  return getWorkerWithOptions(request, runtime);
}

model KillWorkerRequest {
  clusterId?: string(name='ClusterId'),
  project?: string(name='Project'),
  workerId?: string(name='WorkerId'),
}

model KillWorkerResponseBody = {
  hostId?: string(name='HostId'),
  requestId?: string(name='RequestId'),
}

model KillWorkerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: KillWorkerResponseBody(name='body'),
}

async function killWorkerWithOptions(request: KillWorkerRequest, runtime: Util.RuntimeOptions): KillWorkerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.workerId)) {
    query['WorkerId'] = request.workerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'KillWorker',
    version = '2018-12-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function killWorker(request: KillWorkerRequest): KillWorkerResponse {
  var runtime = new Util.RuntimeOptions{};
  return killWorkerWithOptions(request, runtime);
}

model ListClustersRequest {
  filter?: string(name='Filter'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  project?: string(name='Project'),
}

model ListClustersResponseBody = {
  clusters?: [ 
    {
      clusterId?: string(name='ClusterId'),
      definition?: ClusterDefinition(name='Definition'),
      description?: string(name='Description'),
      name?: string(name='Name'),
      ownerId?: string(name='OwnerId'),
      project?: string(name='Project'),
      status?: {
        allocatableResources?: map[string]string(name='AllocatableResources'),
        allocatedResources?: map[string]string(name='AllocatedResources'),
        conditions?: [
          Conditions
        ](name='Conditions'),
        createTime?: string(name='CreateTime'),
        currentWorkerCount?: int32(name='CurrentWorkerCount'),
        desiredWorkerCount?: int32(name='DesiredWorkerCount'),
        state?: string(name='State'),
      }(name='Status'),
    }
  ](name='Clusters'),
  hostId?: string(name='HostId'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListClustersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListClustersResponseBody(name='body'),
}

async function listClustersWithOptions(request: ListClustersRequest, runtime: Util.RuntimeOptions): ListClustersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.filter)) {
    query['Filter'] = request.filter;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListClusters',
    version = '2018-12-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listClusters(request: ListClustersRequest): ListClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClustersWithOptions(request, runtime);
}

model ListJobQueuesRequest {
  labelSelector?: string(name='LabelSelector'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  orderBy?: string(name='OrderBy'),
  orderReverse?: boolean(name='OrderReverse'),
  project?: string(name='Project'),
  state?: string(name='State'),
}

model ListJobQueuesResponseBody = {
  hostId?: string(name='HostId'),
  jobQueues?: [ 
    {
      definition?: JobQueueDefinition(name='Definition'),
      description?: string(name='Description'),
      name?: string(name='Name'),
      ownerId?: string(name='OwnerId'),
      project?: string(name='Project'),
      status?: JobQueueStatus(name='Status'),
    }
  ](name='JobQueues'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListJobQueuesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListJobQueuesResponseBody(name='body'),
}

async function listJobQueuesWithOptions(request: ListJobQueuesRequest, runtime: Util.RuntimeOptions): ListJobQueuesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.labelSelector)) {
    query['LabelSelector'] = request.labelSelector;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['OrderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderReverse)) {
    query['OrderReverse'] = request.orderReverse;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.state)) {
    query['State'] = request.state;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListJobQueues',
    version = '2018-12-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listJobQueues(request: ListJobQueuesRequest): ListJobQueuesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listJobQueuesWithOptions(request, runtime);
}

model ListJobsRequest {
  clusterId?: string(name='ClusterId'),
  labelSelector?: string(name='LabelSelector'),
  maxResults?: int32(name='MaxResults'),
  name?: string(name='Name'),
  nextToken?: string(name='NextToken'),
  orderBy?: string(name='OrderBy'),
  orderReverse?: boolean(name='OrderReverse'),
  project?: string(name='Project'),
  state?: string(name='State'),
}

model ListJobsResponseBody = {
  hostId?: string(name='HostId'),
  jobs?: [ 
    {
      definition?: JobDefinition(name='Definition'),
      description?: string(name='Description'),
      jobId?: string(name='JobId'),
      name?: string(name='Name'),
      ownerId?: string(name='OwnerId'),
      project?: string(name='Project'),
      status?: {
        attempts?: [
          Attempt
        ](name='Attempts'),
        createTime?: string(name='CreateTime'),
        endTime?: string(name='EndTime'),
        exitCode?: int32(name='ExitCode'),
        pid?: int32(name='Pid'),
        reason?: string(name='Reason'),
        startTime?: string(name='StartTime'),
        state?: string(name='State'),
        worker?: string(name='Worker'),
      }(name='Status'),
    }
  ](name='Jobs'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListJobsResponseBody(name='body'),
}

async function listJobsWithOptions(request: ListJobsRequest, runtime: Util.RuntimeOptions): ListJobsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.labelSelector)) {
    query['LabelSelector'] = request.labelSelector;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['OrderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderReverse)) {
    query['OrderReverse'] = request.orderReverse;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.state)) {
    query['State'] = request.state;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListJobs',
    version = '2018-12-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listJobs(request: ListJobsRequest): ListJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listJobsWithOptions(request, runtime);
}

model ListProjectsRequest {
  labelSelector?: string(name='LabelSelector'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  orderBy?: string(name='OrderBy'),
  orderReverse?: boolean(name='OrderReverse'),
}

model ListProjectsResponseBody = {
  hostId?: string(name='HostId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  projects?: [ 
    {
      definition?: ProjectDefinition(name='Definition'),
      description?: string(name='Description'),
      project?: string(name='Project'),
      status?: {
        createTime?: string(name='CreateTime'),
        lastModifiedTime?: string(name='LastModifiedTime'),
        status?: string(name='Status'),
      }(name='Status'),
    }
  ](name='Projects'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListProjectsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListProjectsResponseBody(name='body'),
}

async function listProjectsWithOptions(request: ListProjectsRequest, runtime: Util.RuntimeOptions): ListProjectsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.labelSelector)) {
    query['LabelSelector'] = request.labelSelector;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['OrderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderReverse)) {
    query['OrderReverse'] = request.orderReverse;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListProjects',
    version = '2018-12-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listProjects(request: ListProjectsRequest): ListProjectsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listProjectsWithOptions(request, runtime);
}

model ListRegionsRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
}

model ListRegionsResponseBody = {
  hostId?: string(name='HostId'),
  regions?: [ 
    {
      localName?: string(name='LocalName'),
      regionId?: string(name='RegionId'),
    }
  ](name='Regions'),
  requestId?: string(name='RequestId'),
}

model ListRegionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRegionsResponseBody(name='body'),
}

async function listRegionsWithOptions(request: ListRegionsRequest, runtime: Util.RuntimeOptions): ListRegionsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRegions',
    version = '2018-12-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listRegions(request: ListRegionsRequest): ListRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRegionsWithOptions(request, runtime);
}

model ListWorkersRequest {
  clusterId?: string(name='ClusterId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  project?: string(name='Project'),
}

model ListWorkersResponseBody = {
  hostId?: string(name='HostId'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  workers?: [ 
    {
      definition?: {
        bootstrap?: Bootstrap(name='Bootstrap'),
        docker?: Docker(name='Docker'),
        livenessProbe?: Probe(name='LivenessProbe'),
        mountPoints?: [
          MountPoint
        ](name='MountPoints'),
        startupProbe?: Probe(name='StartupProbe'),
        volumes?: [
          Volume
        ](name='Volumes'),
      }(name='Definition'),
      status?: {
        allocateTime?: string(name='AllocateTime'),
        conditions?: [
          Conditions
        ](name='Conditions'),
        container?: {
          cpu?: int32(name='Cpu'),
          memory?: int32(name='Memory'),
        }(name='Container'),
        createTime?: string(name='CreateTime'),
        ECS?: {
          cpu?: int32(name='Cpu'),
          instanceType?: string(name='InstanceType'),
          memory?: int32(name='Memory'),
          resourceType?: string(name='ResourceType'),
          spotPriceLimit?: string(name='SpotPriceLimit'),
          spotStrategy?: string(name='SpotStrategy'),
          systemDiskSize?: int32(name='SystemDiskSize'),
          systemDiskType?: string(name='SystemDiskType'),
          VMImage?: string(name='VMImage'),
          zoneId?: string(name='ZoneId'),
        }(name='ECS'),
        jobQueue?: string(name='JobQueue'),
        networkInterfaceId?: string(name='NetworkInterfaceId'),
        poolWorkerId?: string(name='PoolWorkerId'),
        securityGroupId?: string(name='SecurityGroupId'),
        state?: string(name='State'),
        vSwitchId?: string(name='VSwitchId'),
        workerType?: int32(name='WorkerType'),
      }(name='Status'),
      workerId?: string(name='WorkerId'),
    }
  ](name='Workers'),
}

model ListWorkersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListWorkersResponseBody(name='body'),
}

async function listWorkersWithOptions(request: ListWorkersRequest, runtime: Util.RuntimeOptions): ListWorkersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListWorkers',
    version = '2018-12-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listWorkers(request: ListWorkersRequest): ListWorkersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listWorkersWithOptions(request, runtime);
}

model OpenBatchComputeServiceResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model OpenBatchComputeServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OpenBatchComputeServiceResponseBody(name='body'),
}

async function openBatchComputeServiceWithOptions(runtime: Util.RuntimeOptions): OpenBatchComputeServiceResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'OpenBatchComputeService',
    version = '2018-12-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function openBatchComputeService(): OpenBatchComputeServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return openBatchComputeServiceWithOptions(runtime);
}

model PollCmdRequest {
  queue?: string(name='Queue'),
  waitSeconds?: string(name='WaitSeconds'),
  workerId?: string(name='WorkerId'),
}

model PollCmdResponseBody = {
  hostId?: string(name='HostId'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model PollCmdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PollCmdResponseBody(name='body'),
}

async function pollCmdWithOptions(request: PollCmdRequest, runtime: Util.RuntimeOptions): PollCmdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.queue)) {
    query['Queue'] = request.queue;
  }
  if (!Util.isUnset(request.waitSeconds)) {
    query['WaitSeconds'] = request.waitSeconds;
  }
  if (!Util.isUnset(request.workerId)) {
    query['WorkerId'] = request.workerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PollCmd',
    version = '2018-12-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function pollCmd(request: PollCmdRequest): PollCmdResponse {
  var runtime = new Util.RuntimeOptions{};
  return pollCmdWithOptions(request, runtime);
}

model RecreateWorkerRequest {
  clusterId?: string(name='ClusterId'),
  project?: string(name='Project'),
  workerId?: string(name='WorkerId'),
}

model RecreateWorkerResponseBody = {
  hostId?: string(name='HostId'),
  requestId?: string(name='RequestId'),
}

model RecreateWorkerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RecreateWorkerResponseBody(name='body'),
}

async function recreateWorkerWithOptions(request: RecreateWorkerRequest, runtime: Util.RuntimeOptions): RecreateWorkerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.workerId)) {
    query['WorkerId'] = request.workerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RecreateWorker',
    version = '2018-12-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function recreateWorker(request: RecreateWorkerRequest): RecreateWorkerResponse {
  var runtime = new Util.RuntimeOptions{};
  return recreateWorkerWithOptions(request, runtime);
}

model RunJobRequest {
  clientToken?: string(name='ClientToken'),
  definition?: JobDefinition(name='Definition'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  project?: string(name='Project'),
}

model RunJobShrinkRequest {
  clientToken?: string(name='ClientToken'),
  definitionShrink?: string(name='Definition'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  project?: string(name='Project'),
}

model RunJobResponseBody = {
  createTime?: string(name='CreateTime'),
  endTime?: string(name='EndTime'),
  exitCode?: int32(name='ExitCode'),
  hostId?: string(name='HostId'),
  pid?: int32(name='Pid'),
  reason?: string(name='Reason'),
  requestId?: string(name='RequestId'),
  startTime?: string(name='StartTime'),
  state?: string(name='State'),
  worker?: string(name='Worker'),
}

model RunJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RunJobResponseBody(name='body'),
}

async function runJobWithOptions(tmpReq: RunJobRequest, runtime: Util.RuntimeOptions): RunJobResponse {
  Util.validateModel(tmpReq);
  var request = new RunJobShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.definition)) {
    request.definitionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.definition, 'Definition', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.definitionShrink)) {
    body['Definition'] = request.definitionShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RunJob',
    version = '2018-12-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function runJob(request: RunJobRequest): RunJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return runJobWithOptions(request, runtime);
}

model UpdateClusterRequest {
  clusterId?: string(name='ClusterId'),
  definition?: ClusterDefinition(name='Definition'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  project?: string(name='Project'),
}

model UpdateClusterShrinkRequest {
  clusterId?: string(name='ClusterId'),
  definitionShrink?: string(name='Definition'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  project?: string(name='Project'),
}

model UpdateClusterResponseBody = {
  hostId?: string(name='HostId'),
  requestId?: string(name='RequestId'),
}

model UpdateClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateClusterResponseBody(name='body'),
}

async function updateClusterWithOptions(tmpReq: UpdateClusterRequest, runtime: Util.RuntimeOptions): UpdateClusterResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateClusterShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.definition)) {
    request.definitionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.definition, 'Definition', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.definitionShrink)) {
    body['Definition'] = request.definitionShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateCluster',
    version = '2018-12-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateCluster(request: UpdateClusterRequest): UpdateClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateClusterWithOptions(request, runtime);
}

model UpdateJobQueueRequest {
  definition?: JobQueueDefinition(name='Definition'),
  name?: string(name='Name'),
  project?: string(name='Project'),
}

model UpdateJobQueueShrinkRequest {
  definitionShrink?: string(name='Definition'),
  name?: string(name='Name'),
  project?: string(name='Project'),
}

model UpdateJobQueueResponseBody = {
  hostId?: string(name='HostId'),
  requestId?: string(name='RequestId'),
}

model UpdateJobQueueResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateJobQueueResponseBody(name='body'),
}

async function updateJobQueueWithOptions(tmpReq: UpdateJobQueueRequest, runtime: Util.RuntimeOptions): UpdateJobQueueResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateJobQueueShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.definition)) {
    request.definitionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.definition, 'Definition', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.definitionShrink)) {
    query['Definition'] = request.definitionShrink;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateJobQueue',
    version = '2018-12-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateJobQueue(request: UpdateJobQueueRequest): UpdateJobQueueResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateJobQueueWithOptions(request, runtime);
}

model UpdateProjectRequest {
  definition?: ProjectDefinition(name='Definition'),
  description?: string(name='Description'),
  project?: string(name='Project'),
}

model UpdateProjectShrinkRequest {
  definitionShrink?: string(name='Definition'),
  description?: string(name='Description'),
  project?: string(name='Project'),
}

model UpdateProjectResponseBody = {
  hostId?: string(name='HostId'),
  requestId?: string(name='RequestId'),
}

model UpdateProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateProjectResponseBody(name='body'),
}

async function updateProjectWithOptions(tmpReq: UpdateProjectRequest, runtime: Util.RuntimeOptions): UpdateProjectResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateProjectShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.definition)) {
    request.definitionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.definition, 'Definition', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.definitionShrink)) {
    body['Definition'] = request.definitionShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateProject',
    version = '2018-12-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateProject(request: UpdateProjectRequest): UpdateProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateProjectWithOptions(request, runtime);
}

model UpdateWorkerStatusRequest {
  clusterId?: string(name='ClusterId'),
  status?: string(name='Status'),
  workerId?: string(name='WorkerId'),
}

model UpdateWorkerStatusResponseBody = {
  hostId?: string(name='HostId'),
  requestId?: string(name='RequestId'),
}

model UpdateWorkerStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateWorkerStatusResponseBody(name='body'),
}

async function updateWorkerStatusWithOptions(request: UpdateWorkerStatusRequest, runtime: Util.RuntimeOptions): UpdateWorkerStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.workerId)) {
    query['WorkerId'] = request.workerId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.status)) {
    body['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateWorkerStatus',
    version = '2018-12-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateWorkerStatus(request: UpdateWorkerStatusRequest): UpdateWorkerStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateWorkerStatusWithOptions(request, runtime);
}

