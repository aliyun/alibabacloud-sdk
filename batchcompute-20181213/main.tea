/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('batchcompute', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model Attempt {
  endTime?: string(name='EndTime', description='EndTime'),
  exitCode?: int32(name='ExitCode', description='ExitCode'),
  output?: bytes(name='Output', description='Output'),
  pid?: int32(name='Pid', description='Pid'),
  reason?: string(name='Reason', description='Reason'),
  startTime?: string(name='StartTime', description='StartTime'),
  state?: string(name='State', description='State'),
  userStages?: [
    UserStage
  ](name='UserStages', description='UserStages'),
  worker?: string(name='Worker', description='Worker'),
}

model AutoScaling {
  scaling?: Scaling(name='Scaling', description='Scaling'),
  trigger?: Trigger(name='Trigger', description='Trigger'),
}

model Bootstrap {
  background?: boolean(name='Background', description='Background'),
  command?: [ string ](name='Command', description='Command'),
  envs?: map[string]string(name='Envs', description='Envs'),
  loggings?: Logging(name='Loggings', description='Loggings'),
  mountPoints?: [
    MountPoint
  ](name='MountPoints', description='MountPoints'),
  packageUri?: string(name='PackageUri', description='PackageUri'),
  runningTimeout?: int32(name='RunningTimeout', description='RunningTimeout'),
  runtimes?: BootstrapRuntime(name='Runtimes', description='Runtimes'),
  volumes?: [
    Volume
  ](name='Volumes', description='Volumes'),
}

model BootstrapRuntime {
  docker?: Docker(name='Docker', description='Docker'),
}

model ClusterDefinition {
  autoScaling?: [
    AutoScaling
  ](name='AutoScaling', description='AutoScaling'),
  bootstrap?: Bootstrap(name='Bootstrap', description='Bootstrap'),
  credentialConfigs?: CredentialConfig(name='CredentialConfigs', description='CredentialConfigs'),
  docker?: Docker(name='Docker', description='Docker'),
  ECS?: ECS(name='ECS', description='ECS'),
  livenessProbe?: Probe(name='LivenessProbe', description='LivenessProbe'),
  managedJobQueue?: boolean(name='ManagedJobQueue', description='ManagedJobQueue'),
  mountPoints?: [
    MountPoint
  ](name='MountPoints', description='MountPoints'),
  providerType?: string(name='ProviderType', description='ProviderType'),
  resources?: map[string]string(name='Resources', description='Resources'),
  SLB?: SLB(name='SLB', description='SLB'),
  scaling?: Scaling(name='Scaling', description='Scaling'),
  startupProbe?: Probe(name='StartupProbe', description='StartupProbe'),
  upgradePolicy?: UpgradePolicy(name='UpgradePolicy', description='UpgradePolicy'),
  VPC?: VPC(name='VPC', description='VPC'),
  volumes?: [
    Volume
  ](name='Volumes', description='Volumes'),
  workerType?: string(name='WorkerType', description='WorkerType'),
}

model Conditions {
  condition?: string(name='Condition', description='Condition'),
  errors?: [
    Errors
  ](name='Errors', description='Errors'),
  lastProbeTime?: string(name='LastProbeTime', description='LastProbeTime'),
  lastTransitionTime?: string(name='LastTransitionTime', description='LastTransitionTime'),
  status?: string(name='Status', description='Status'),
}

model CredentialConfig {
  chain?: [
    ServiceRoleNode
  ](name='Chain', description='Chain'),
  policy?: string(name='Policy', description='Policy'),
  serviceRole?: string(name='ServiceRole', description='ServiceRole'),
}

model Destination {
  OSS?: OSSDescription(name='OSS'),
  PDS?: PDSDescription(name='PDS'),
}

model Docker {
  exposedPorts?: [
    ExposedPort
  ](name='ExposedPorts', description='ExposedPorts'),
  image?: string(name='Image', description='Image'),
}

model ECS {
  hostnamePrefix?: string(name='HostnamePrefix', description='HostnamePrefix'),
  instanceType?: string(name='InstanceType', description='InstanceType'),
  passwordInherit?: boolean(name='PasswordInherit', description='PasswordInherit'),
  resourceType?: string(name='ResourceType', description='ResourceType'),
  spotPriceLimit?: string(name='SpotPriceLimit', description='SpotPriceLimit'),
  spotStrategy?: string(name='SpotStrategy', description='SpotStrategy'),
  systemDiskSize?: int32(name='SystemDiskSize', description='SystemDiskSize'),
  systemDiskType?: string(name='SystemDiskType', description='SystemDiskType'),
  VMImage?: string(name='VMImage', description='VMImage'),
}

model Errors {
  action?: string(name='Action', description='Action'),
  code?: string(name='Code', description='Code'),
  message?: string(name='Message', description='Message'),
  repeat?: int32(name='Repeat', description='Repeat'),
}

model Exec {
  exec?: ExecAction(name='Exec', description='Exec'),
}

model ExecAction {
  command?: [ string ](name='Command', description='Command'),
}

model ExposedPort {
  containerPort?: int32(name='ContainerPort', description='ContainerPort'),
  hostPorts?: [ int32 ](name='HostPorts', description='HostPorts'),
  proto?: string(name='Proto', description='Proto'),
}

model FailStrategy {
  maxRetries?: int32(name='MaxRetries', description='MaxRetries'),
  runningTimeout?: int32(name='RunningTimeout', description='RunningTimeout'),
  successCode?: [ int32 ](name='SuccessCode', description='SuccessCode'),
  waitingTimeout?: int32(name='WaitingTimeout', description='WaitingTimeout'),
}

model HTTPGet {
  HTTPGet?: HTTPGetAction(name='HTTPGet', description='HTTPGet'),
}

model HTTPGetAction {
  HTTPHeaders?: [
    HTTPHeader
  ](name='HTTPHeaders', description='HTTPHeaders'),
  host?: string(name='Host', description='Host'),
  path?: string(name='Path', description='Path'),
  port?: int32(name='Port', description='Port'),
  scheme?: string(name='Scheme', description='Scheme'),
}

model HTTPHeader {
  name?: string(name='Name', description='Name'),
  value?: string(name='Value', description='Value'),
}

model Handler {
  exec?: ExecAction(name='Exec', description='Exec'),
  HTTPGet?: HTTPGetAction(name='HTTPGet', description='HTTPGet'),
}

model Input {
  fileMode?: string(name='FileMode', description='FileMode'),
  filePath?: string(name='FilePath', description='FilePath'),
  source?: Source(name='Source'),
}

model JobDefinition {
  command?: [ string ](name='Command', description='Command'),
  credentialConfig?: CredentialConfig(name='CredentialConfig', description='CredentialConfig'),
  envs?: map[string]string(name='Envs', description='Envs'),
  failStrategy?: FailStrategy(name='FailStrategy', description='FailStrategy'),
  inputs?: [
    Input
  ](name='Inputs', description='Inputs'),
  labels?: map[string]string(name='Labels', description='Labels'),
  loggings?: Logging(name='Loggings', description='Loggings'),
  mountPoints?: [
    MountPoint
  ](name='MountPoints', description='MountPoints'),
  notification?: Notification(name='Notification', description='Notification'),
  outputs?: [
    Output
  ](name='Outputs', description='Outputs'),
  packageUri?: string(name='PackageUri', description='PackageUri'),
  releaseStrategy?: ReleaseStrategy(name='ReleaseStrategy', description='ReleaseStrategy'),
  resources?: map[string]string(name='Resources', description='Resources'),
  runtimes?: Runtimes(name='Runtimes', description='Runtimes'),
  userData?: map[string]string(name='UserData', description='UserData'),
  volumes?: [
    Volume
  ](name='Volumes', description='Volumes'),
}

model JobQueueDefinition {
  labels?: map[string]string(name='Labels', description='Labels'),
  priority?: int32(name='Priority', description='Priority'),
  providerConfigs?: [
    ProviderConfig
  ](name='ProviderConfigs', description='ProviderConfigs'),
  schedulerConfig?: {
    state?: string(name='State', description='State'),
  }(name='SchedulerConfig', description='SchedulerConfig'),
}

model JobQueueStatus {
  allocatableResources?: map[string]string(name='AllocatableResources', description='AllocatableResources'),
  allocatedResources?: map[string]string(name='AllocatedResources', description='AllocatedResources'),
  createTime?: string(name='CreateTime', description='CreateTime'),
  lastUpdateTime?: string(name='LastUpdateTime', description='LastUpdateTime'),
  managed?: boolean(name='Managed', description='Managed'),
  providerStatuses?: [
    ProviderStatus
  ](name='ProviderStatuses', description='ProviderStatuses'),
  reason?: string(name='Reason', description='Reason'),
  schedulerStatus?: SchedulerStatus(name='SchedulerStatus'),
  state?: string(name='State', description='State'),
}

model Logging {
  name?: string(name='Name', description='Name'),
  OSS?: OSSLogging(name='OSS', description='OSS'),
  path?: string(name='Path', description='Path'),
  SLS?: SLSLogging(name='SLS', description='SLS'),
}

model MNSNotification {
  endpoint?: string(name='Endpoint', description='Endpoint'),
  filters?: [ string ](name='Filters', description='Filters'),
  topic?: string(name='Topic', description='Topic'),
}

model MountPoint {
  mountPath?: string(name='MountPath', description='MountPath'),
  name?: string(name='Name', description='Name'),
  readOnly?: boolean(name='ReadOnly', description='ReadOnly'),
  subPath?: string(name='SubPath', description='SubPath'),
}

model NFSVolumeSource {
  path?: string(name='Path', description='Path'),
  readOnly?: boolean(name='ReadOnly', description='ReadOnly'),
  server?: string(name='Server', description='Server'),
  version?: string(name='Version', description='Version'),
}

model Notification {
  MNS?: MNSNotification(name='MNS', description='MNS'),
}

model OSSDescription {
  bucket?: string(name='Bucket', description='Bucket'),
  object?: string(name='Object', description='Object'),
  prefix?: string(name='Prefix', description='Prefix'),
}

model OSSLogging {
  bucket?: string(name='Bucket', description='Bucket'),
  prefix?: string(name='Prefix', description='Prefix'),
}

model OSSVolumeSource {
  bucket?: string(name='Bucket', description='Bucket'),
  object?: string(name='Object', description='Object'),
  prefix?: string(name='Prefix', description='Prefix'),
  readOnly?: boolean(name='ReadOnly', description='ReadOnly'),
}

model Output {
  destination?: Destination(name='Destination', description='Destination'),
  filePattern?: string(name='FilePattern', description='FilePattern'),
  uploadConditions?: [ string ](name='UploadConditions', description='UploadConditions'),
  uploadMode?: string(name='UploadMode', description='UploadMode'),
}

model PDSDescription {
  domain?: string(name='Domain', description='Domain'),
  drive?: string(name='Drive', description='Drive'),
  object?: string(name='Object', description='Object'),
  prefix?: string(name='Prefix', description='Prefix'),
}

model PDSVolumeSource {
  domain?: string(name='Domain', description='Domain'),
  drive?: string(name='Drive', description='Drive'),
  object?: string(name='Object', description='Object'),
  prefix?: string(name='Prefix', description='Prefix'),
  readOnly?: boolean(name='ReadOnly', description='ReadOnly'),
}

model Probe {
  failureThreshold?: int32(name='FailureThreshold', description='FailureThreshold'),
  handler?: Handler(name='Handler', description='Handler'),
  initialDelaySeconds?: int32(name='InitialDelaySeconds', description='InitialDelaySeconds'),
  periodSeconds?: int32(name='PeriodSeconds', description='PeriodSeconds'),
  successThreshold?: int32(name='SuccessThreshold', description='SuccessThreshold'),
  timeoutSeconds?: int32(name='TimeoutSeconds', description='TimeoutSeconds'),
}

model ProjectDefinition {
  jobLifecycle?: int32(name='JobLifecycle', description='JobLifecycle'),
  labels?: map[string]string(name='Labels', description='Labels'),
  role?: string(name='Role', description='Role'),
}

model ProviderConfig {
  maxWorkerCount?: int32(name='MaxWorkerCount', description='MaxWorkerCount'),
  minWorkerCount?: int32(name='MinWorkerCount', description='MinWorkerCount'),
  providerId?: string(name='ProviderId', description='ProviderId'),
  providerType?: string(name='ProviderType', description='ProviderType'),
  workerType?: string(name='WorkerType', description='WorkerType'),
}

model ProviderStatus {
  allocatableResources?: map[string]string(name='AllocatableResources', description='AllocatableResources'),
  allocatedResources?: map[string]string(name='AllocatedResources', description='AllocatedResources'),
  providerId?: string(name='ProviderId', description='ProviderId'),
}

model ReleaseCondition {
  state?: string(name='State', description='State'),
  TTLSeconds?: long(name='TTLSeconds', description='TTLSeconds'),
}

model ReleaseStrategy {
  releaseConditions?: [
    ReleaseCondition
  ](name='ReleaseConditions', description='ReleaseConditions'),
}

model Runtimes {
  docker?: Docker(name='Docker', description='Docker'),
  ECS?: ECS(name='ECS', description='ECS'),
  jobQueue?: string(name='JobQueue', description='JobQueue'),
  VPC?: VPC(name='VPC', description='VPC'),
}

model SLB {
  SLBId?: string(name='SLBId', description='SLBId'),
}

model SLSLogging {
  logtailConfigName?: string(name='LogtailConfigName', description='LogtailConfigName'),
  project?: string(name='Project', description='Project'),
  store?: string(name='Store', description='Store'),
}

model Scaling {
  adjustmentType?: string(name='AdjustmentType', description='AdjustmentType'),
  adjustmentValue?: float(name='AdjustmentValue', description='AdjustmentValue'),
  maxWorkerCount?: int32(name='MaxWorkerCount', description='MaxWorkerCount'),
  metricType?: string(name='MetricType', description='MetricType'),
  metricValue?: float(name='MetricValue', description='MetricValue'),
  minWorkerCount?: int32(name='MinWorkerCount', description='MinWorkerCount'),
  toleranceValue?: float(name='ToleranceValue', description='ToleranceValue'),
}

model SchedulerStatus {
  canceledJobCount?: long(name='CanceledJobCount', description='CanceledJobCount'),
  failedJobCount?: long(name='FailedJobCount', description='FailedJobCount'),
  runningJobCount?: long(name='RunningJobCount', description='RunningJobCount'),
  succeededJobCount?: long(name='SucceededJobCount', description='SucceededJobCount'),
  waitingJobCount?: long(name='WaitingJobCount', description='WaitingJobCount'),
}

model ServiceRoleNode {
  assumeRoleFor?: string(name='AssumeRoleFor', description='AssumeRoleFor'),
  role?: string(name='Role', description='Role'),
  roleType?: string(name='RoleType', description='RoleType'),
}

model Source {
  OSS?: OSSDescription(name='OSS'),
  PDS?: PDSDescription(name='PDS'),
}

model Trigger {
  enabled?: boolean(name='Enabled', description='Enabled'),
  firstLaunchTime?: string(name='FirstLaunchTime', description='FirstLaunchTime'),
  repeatType?: string(name='RepeatType', description='RepeatType'),
  repeatValue?: string(name='RepeatValue', description='RepeatValue'),
}

model UpgradePolicy {
  upgradeRatio?: float(name='UpgradeRatio', description='UpgradeRatio'),
}

model UserStage {
  description?: string(name='Description', description='Description'),
  endTime?: int32(name='EndTime', description='EndTime'),
  startTime?: int32(name='StartTime', description='StartTime'),
  state?: string(name='State', description='State'),
}

model VPC {
  securityGroups?: [ string ](name='SecurityGroups', description='SecurityGroups'),
  VPCId?: string(name='VPCId', description='VPCId'),
  vSwitches?: [ string ](name='VSwitches', description='VSwitches'),
}

model Volume {
  NFS?: NFSVolumeSource(name='NFS', description='NFS'),
  name?: string(name='Name', description='Name'),
  OSS?: OSSVolumeSource(name='OSS', description='OSS'),
  PDS?: PDSVolumeSource(name='PDS', description='PDS'),
}

model WorkerStatus {
  conditions?: [
    Conditions
  ](name='Conditions', description='Conditions'),
  container?: {
    cpu?: int32(name='Cpu', description='Cpu'),
    memory?: int32(name='Memory', description='Memory'),
  }(name='Container', description='Container'),
  createTime?: string(name='CreateTime', description='CreateTime'),
  ECS?: {
    cpu?: int32(name='Cpu', description='Cpu'),
    endpoint?: string(name='Endpoint', description='Endpoint'),
    hostname?: string(name='Hostname', description='Hostname'),
    instanceId?: string(name='InstanceId', description='InstanceId'),
    instanceType?: string(name='InstanceType', description='InstanceType'),
    memory?: int32(name='Memory', description='Memory'),
    password?: string(name='Password', description='Password'),
    resourceType?: string(name='ResourceType', description='ResourceType'),
    spotPriceLimit?: string(name='SpotPriceLimit', description='SpotPriceLimit'),
    spotStrategy?: string(name='SpotStrategy', description='SpotStrategy'),
    systemDiskSize?: int32(name='SystemDiskSize', description='SystemDiskSize'),
    systemDiskType?: string(name='SystemDiskType', description='SystemDiskType'),
    VMImage?: string(name='VMImage', description='VMImage'),
    zoneId?: string(name='ZoneId', description='ZoneId'),
  }(name='ECS', description='ECS'),
  jobQueue?: string(name='JobQueue', description='JobQueue'),
  networkInterfaceId?: string(name='NetworkInterfaceId', description='NetworkInterfaceId'),
  poolWorkerId?: string(name='PoolWorkerId', description='PoolWorkerId'),
  securityGroupId?: string(name='SecurityGroupId', description='SecurityGroupId'),
  state?: string(name='State', description='State'),
  vSwitchId?: string(name='VSwitchId', description='VSwitchId'),
  workerType?: int32(name='WorkerType', description='WorkerType'),
}

model CancelJobRequest {
  exitCode?: string(name='ExitCode'),
  jobId?: string(name='JobId'),
  project?: string(name='Project'),
  reason?: string(name='Reason'),
}

model CancelJobResponseBody = {
  hostId?: string(name='HostId'),
  requestId?: string(name='RequestId'),
}

model CancelJobResponse = {
  headers: map[string]string(name='headers'),
  body: CancelJobResponseBody(name='body'),
}

async function cancelJobWithOptions(request: CancelJobRequest, runtime: Util.RuntimeOptions): CancelJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CancelJob', '2018-12-13', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function cancelJob(request: CancelJobRequest): CancelJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelJobWithOptions(request, runtime);
}

model CreateClusterRequest {
  clientToken?: string(name='ClientToken'),
  definition?: ClusterDefinition(name='Definition', description='Definition'),
  description?: string(name='Description', description='Description'),
  name?: string(name='Name', description='Name'),
  project?: string(name='Project', description='Project'),
}

model CreateClusterShrinkRequest {
  clientToken?: string(name='ClientToken'),
  definitionShrink?: string(name='Definition', description='Definition'),
  description?: string(name='Description', description='Description'),
  name?: string(name='Name', description='Name'),
  project?: string(name='Project', description='Project'),
}

model CreateClusterResponseBody = {
  clusterId?: string(name='ClusterId'),
  hostId?: string(name='HostId'),
  requestId?: string(name='RequestId'),
}

model CreateClusterResponse = {
  headers: map[string]string(name='headers'),
  body: CreateClusterResponseBody(name='body'),
}

async function createClusterWithOptions(tmpReq: CreateClusterRequest, runtime: Util.RuntimeOptions): CreateClusterResponse {
  Util.validateModel(tmpReq);
  var request = new CreateClusterShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.definition)) {
    request.definitionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.definition, 'Definition', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateCluster', '2018-12-13', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createCluster(request: CreateClusterRequest): CreateClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return createClusterWithOptions(request, runtime);
}

model CreateJobRequest {
  clientToken?: string(name='ClientToken'),
  definition?: JobDefinition(name='Definition'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  project?: string(name='Project'),
}

model CreateJobShrinkRequest {
  clientToken?: string(name='ClientToken'),
  definitionShrink?: string(name='Definition'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  project?: string(name='Project'),
}

model CreateJobResponseBody = {
  hostId?: string(name='HostId'),
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model CreateJobResponse = {
  headers: map[string]string(name='headers'),
  body: CreateJobResponseBody(name='body'),
}

async function createJobWithOptions(tmpReq: CreateJobRequest, runtime: Util.RuntimeOptions): CreateJobResponse {
  Util.validateModel(tmpReq);
  var request = new CreateJobShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.definition)) {
    request.definitionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.definition, 'Definition', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateJob', '2018-12-13', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createJob(request: CreateJobRequest): CreateJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return createJobWithOptions(request, runtime);
}

model CreateJobQueueRequest {
  clientToken?: string(name='ClientToken'),
  definition?: JobQueueDefinition(name='Definition'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  project?: string(name='Project'),
}

model CreateJobQueueShrinkRequest {
  clientToken?: string(name='ClientToken'),
  definitionShrink?: string(name='Definition'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  project?: string(name='Project'),
}

model CreateJobQueueResponseBody = {
  hostId?: string(name='HostId'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
}

model CreateJobQueueResponse = {
  headers: map[string]string(name='headers'),
  body: CreateJobQueueResponseBody(name='body'),
}

async function createJobQueueWithOptions(tmpReq: CreateJobQueueRequest, runtime: Util.RuntimeOptions): CreateJobQueueResponse {
  Util.validateModel(tmpReq);
  var request = new CreateJobQueueShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.definition)) {
    request.definitionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.definition, 'Definition', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateJobQueue', '2018-12-13', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createJobQueue(request: CreateJobQueueRequest): CreateJobQueueResponse {
  var runtime = new Util.RuntimeOptions{};
  return createJobQueueWithOptions(request, runtime);
}

model CreateProjectRequest {
  clientToken?: string(name='ClientToken'),
  definition?: ProjectDefinition(name='Definition'),
  description?: string(name='Description'),
  project?: string(name='Project'),
}

model CreateProjectShrinkRequest {
  clientToken?: string(name='ClientToken'),
  definitionShrink?: string(name='Definition'),
  description?: string(name='Description'),
  project?: string(name='Project'),
}

model CreateProjectResponseBody = {
  hostId?: string(name='HostId'),
  project?: string(name='Project'),
  requestId?: string(name='RequestId'),
}

model CreateProjectResponse = {
  headers: map[string]string(name='headers'),
  body: CreateProjectResponseBody(name='body'),
}

async function createProjectWithOptions(tmpReq: CreateProjectRequest, runtime: Util.RuntimeOptions): CreateProjectResponse {
  Util.validateModel(tmpReq);
  var request = new CreateProjectShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.definition)) {
    request.definitionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.definition, 'Definition', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateProject', '2018-12-13', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createProject(request: CreateProjectRequest): CreateProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return createProjectWithOptions(request, runtime);
}

model DeleteClusterRequest {
  clusterId?: string(name='ClusterId', description='ClusterId'),
  project?: string(name='Project', description='Project'),
}

model DeleteClusterResponseBody = {
  hostId?: string(name='HostId'),
  requestId?: string(name='RequestId'),
}

model DeleteClusterResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteClusterResponseBody(name='body'),
}

async function deleteClusterWithOptions(request: DeleteClusterRequest, runtime: Util.RuntimeOptions): DeleteClusterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteCluster', '2018-12-13', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteCluster(request: DeleteClusterRequest): DeleteClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteClusterWithOptions(request, runtime);
}

model DeleteJobRequest {
  jobId?: string(name='JobId'),
  project?: string(name='Project'),
}

model DeleteJobResponseBody = {
  hostId?: string(name='HostId'),
  requestId?: string(name='RequestId'),
}

model DeleteJobResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteJobResponseBody(name='body'),
}

async function deleteJobWithOptions(request: DeleteJobRequest, runtime: Util.RuntimeOptions): DeleteJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteJob', '2018-12-13', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteJob(request: DeleteJobRequest): DeleteJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteJobWithOptions(request, runtime);
}

model DeleteJobQueueRequest {
  name?: string(name='Name'),
  project?: string(name='Project'),
}

model DeleteJobQueueResponseBody = {
  hostId?: string(name='HostId'),
  requestId?: string(name='RequestId'),
}

model DeleteJobQueueResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteJobQueueResponseBody(name='body'),
}

async function deleteJobQueueWithOptions(request: DeleteJobQueueRequest, runtime: Util.RuntimeOptions): DeleteJobQueueResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteJobQueue', '2018-12-13', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteJobQueue(request: DeleteJobQueueRequest): DeleteJobQueueResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteJobQueueWithOptions(request, runtime);
}

model DeleteProjectRequest {
  project?: string(name='Project'),
}

model DeleteProjectResponseBody = {
  hostId?: string(name='HostId'),
  requestId?: string(name='RequestId'),
}

model DeleteProjectResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteProjectResponseBody(name='body'),
}

async function deleteProjectWithOptions(request: DeleteProjectRequest, runtime: Util.RuntimeOptions): DeleteProjectResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteProject', '2018-12-13', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteProject(request: DeleteProjectRequest): DeleteProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteProjectWithOptions(request, runtime);
}

model GetClusterRequest {
  clusterId?: string(name='ClusterId'),
  project?: string(name='Project'),
}

model GetClusterResponseBody = {
  clusterId?: string(name='ClusterId'),
  definition?: ClusterDefinition(name='Definition'),
  description?: string(name='Description'),
  hostId?: string(name='HostId'),
  name?: string(name='Name'),
  ownerId?: string(name='OwnerId'),
  project?: string(name='Project'),
  requestId?: string(name='RequestId'),
  status?: {
    allocatableResources?: map[string]string(name='AllocatableResources'),
    allocatedResources?: map[string]string(name='AllocatedResources'),
    conditions?: [
      Conditions
    ](name='Conditions'),
    createTime?: string(name='CreateTime'),
    currentWorkerCount?: int32(name='CurrentWorkerCount'),
    desiredWorkerCount?: int32(name='DesiredWorkerCount'),
    state?: string(name='State'),
  }(name='Status'),
}

model GetClusterResponse = {
  headers: map[string]string(name='headers'),
  body: GetClusterResponseBody(name='body'),
}

async function getClusterWithOptions(request: GetClusterRequest, runtime: Util.RuntimeOptions): GetClusterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetCluster', '2018-12-13', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getCluster(request: GetClusterRequest): GetClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return getClusterWithOptions(request, runtime);
}

model GetJobRequest {
  jobId?: string(name='JobId'),
  project?: string(name='Project'),
}

model GetJobResponseBody = {
  definition?: JobDefinition(name='Definition'),
  description?: string(name='Description'),
  hostId?: string(name='HostId'),
  jobId?: string(name='JobId'),
  name?: string(name='Name'),
  ownerId?: string(name='OwnerId'),
  project?: string(name='Project'),
  requestId?: string(name='RequestId'),
  status?: {
    attempts?: [
      Attempt
    ](name='Attempts'),
    createTime?: string(name='CreateTime'),
    endTime?: string(name='EndTime'),
    exitCode?: int32(name='ExitCode'),
    pid?: int32(name='Pid'),
    reason?: string(name='Reason'),
    startTime?: string(name='StartTime'),
    state?: string(name='State'),
    worker?: string(name='Worker'),
  }(name='Status'),
}

model GetJobResponse = {
  headers: map[string]string(name='headers'),
  body: GetJobResponseBody(name='body'),
}

async function getJobWithOptions(request: GetJobRequest, runtime: Util.RuntimeOptions): GetJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetJob', '2018-12-13', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getJob(request: GetJobRequest): GetJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return getJobWithOptions(request, runtime);
}

model GetJobQueueRequest {
  name?: string(name='Name'),
  project?: string(name='Project'),
}

model GetJobQueueResponseBody = {
  definition?: JobQueueDefinition(name='Definition'),
  description?: string(name='Description'),
  hostId?: string(name='HostId'),
  name?: string(name='Name'),
  ownerId?: string(name='OwnerId'),
  project?: string(name='Project'),
  requestId?: string(name='RequestId'),
  status?: JobQueueStatus(name='Status'),
}

model GetJobQueueResponse = {
  headers: map[string]string(name='headers'),
  body: GetJobQueueResponseBody(name='body'),
}

async function getJobQueueWithOptions(request: GetJobQueueRequest, runtime: Util.RuntimeOptions): GetJobQueueResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetJobQueue', '2018-12-13', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getJobQueue(request: GetJobQueueRequest): GetJobQueueResponse {
  var runtime = new Util.RuntimeOptions{};
  return getJobQueueWithOptions(request, runtime);
}

model GetProjectRequest {
  project?: string(name='Project'),
}

model GetProjectResponseBody = {
  definition?: ProjectDefinition(name='Definition'),
  description?: string(name='Description'),
  hostId?: string(name='HostId'),
  project?: string(name='Project'),
  requestId?: string(name='RequestId'),
  status?: {
    createTime?: string(name='CreateTime'),
    lastModifiedTime?: string(name='LastModifiedTime'),
  }(name='Status'),
}

model GetProjectResponse = {
  headers: map[string]string(name='headers'),
  body: GetProjectResponseBody(name='body'),
}

async function getProjectWithOptions(request: GetProjectRequest, runtime: Util.RuntimeOptions): GetProjectResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetProject', '2018-12-13', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getProject(request: GetProjectRequest): GetProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return getProjectWithOptions(request, runtime);
}

model GetWorkerRequest {
  clusterId?: string(name='ClusterId'),
  project?: string(name='Project'),
  workerId?: string(name='WorkerId'),
}

model GetWorkerResponseBody = {
  hostId?: string(name='HostId'),
  requestId?: string(name='RequestId'),
  status?: {
    activeTime?: string(name='ActiveTime'),
    allocateTime?: string(name='AllocateTime'),
    conditions?: [
      Conditions
    ](name='Conditions'),
    container?: {
      cpu?: int32(name='Cpu'),
      memory?: int32(name='Memory'),
    }(name='Container'),
    createTime?: string(name='CreateTime'),
    ECS?: {
      cpu?: int32(name='Cpu'),
      endpoint?: string(name='Endpoint'),
      hostname?: string(name='Hostname'),
      instanceId?: string(name='InstanceId'),
      instanceType?: string(name='InstanceType'),
      memory?: int32(name='Memory'),
      password?: string(name='Password'),
      resourceType?: string(name='ResourceType'),
      spotPriceLimit?: string(name='SpotPriceLimit'),
      spotStrategy?: string(name='SpotStrategy'),
      systemDiskSize?: int32(name='SystemDiskSize'),
      systemDiskType?: string(name='SystemDiskType'),
      VMImage?: string(name='VMImage'),
      zoneId?: string(name='ZoneId'),
    }(name='ECS'),
    jobQueue?: string(name='JobQueue'),
    networkInterfaceId?: string(name='NetworkInterfaceId'),
    poolWorkerId?: string(name='PoolWorkerId'),
    securityGroupId?: string(name='SecurityGroupId'),
    state?: string(name='State'),
    vSwitchId?: string(name='VSwitchId'),
    workerType?: int32(name='WorkerType'),
  }(name='Status'),
  workerId?: string(name='WorkerId'),
}

model GetWorkerResponse = {
  headers: map[string]string(name='headers'),
  body: GetWorkerResponseBody(name='body'),
}

async function getWorkerWithOptions(request: GetWorkerRequest, runtime: Util.RuntimeOptions): GetWorkerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetWorker', '2018-12-13', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getWorker(request: GetWorkerRequest): GetWorkerResponse {
  var runtime = new Util.RuntimeOptions{};
  return getWorkerWithOptions(request, runtime);
}

model KillWorkerRequest {
  clusterId?: string(name='ClusterId'),
  project?: string(name='Project'),
  workerId?: string(name='WorkerId'),
}

model KillWorkerResponseBody = {
  hostId?: string(name='HostId'),
  requestId?: string(name='RequestId'),
}

model KillWorkerResponse = {
  headers: map[string]string(name='headers'),
  body: KillWorkerResponseBody(name='body'),
}

async function killWorkerWithOptions(request: KillWorkerRequest, runtime: Util.RuntimeOptions): KillWorkerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('KillWorker', '2018-12-13', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function killWorker(request: KillWorkerRequest): KillWorkerResponse {
  var runtime = new Util.RuntimeOptions{};
  return killWorkerWithOptions(request, runtime);
}

model ListClustersRequest {
  filter?: string(name='Filter'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  project?: string(name='Project'),
}

model ListClustersResponseBody = {
  clusters?: [ 
    {
      clusterId?: string(name='ClusterId'),
      definition?: ClusterDefinition(name='Definition'),
      description?: string(name='Description'),
      name?: string(name='Name'),
      ownerId?: string(name='OwnerId'),
      project?: string(name='Project'),
      status?: {
        allocatableResources?: map[string]string(name='AllocatableResources'),
        allocatedResources?: map[string]string(name='AllocatedResources'),
        conditions?: [
          Conditions
        ](name='Conditions'),
        createTime?: string(name='CreateTime'),
        currentWorkerCount?: int32(name='CurrentWorkerCount'),
        desiredWorkerCount?: int32(name='DesiredWorkerCount'),
        state?: string(name='State'),
      }(name='Status'),
    }
  ](name='Clusters'),
  hostId?: string(name='HostId'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListClustersResponse = {
  headers: map[string]string(name='headers'),
  body: ListClustersResponseBody(name='body'),
}

async function listClustersWithOptions(request: ListClustersRequest, runtime: Util.RuntimeOptions): ListClustersResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListClusters', '2018-12-13', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listClusters(request: ListClustersRequest): ListClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClustersWithOptions(request, runtime);
}

model ListJobQueuesRequest {
  labelSelector?: string(name='LabelSelector'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  orderBy?: string(name='OrderBy'),
  orderReverse?: boolean(name='OrderReverse'),
  project?: string(name='Project'),
  state?: string(name='State'),
}

model ListJobQueuesResponseBody = {
  hostId?: string(name='HostId'),
  jobQueues?: [ 
    {
      definition?: JobQueueDefinition(name='Definition'),
      description?: string(name='Description'),
      name?: string(name='Name'),
      nextToken?: string(name='NextToken'),
      ownerId?: string(name='OwnerId'),
      project?: string(name='Project'),
      status?: JobQueueStatus(name='Status'),
      totalCount?: int32(name='TotalCount'),
    }
  ](name='JobQueues'),
  requestId?: string(name='RequestId'),
}

model ListJobQueuesResponse = {
  headers: map[string]string(name='headers'),
  body: ListJobQueuesResponseBody(name='body'),
}

async function listJobQueuesWithOptions(request: ListJobQueuesRequest, runtime: Util.RuntimeOptions): ListJobQueuesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListJobQueues', '2018-12-13', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listJobQueues(request: ListJobQueuesRequest): ListJobQueuesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listJobQueuesWithOptions(request, runtime);
}

model ListJobsRequest {
  clusterId?: string(name='ClusterId'),
  labelSelector?: string(name='LabelSelector'),
  maxResults?: int32(name='MaxResults'),
  name?: string(name='Name'),
  nextToken?: string(name='NextToken'),
  orderBy?: string(name='OrderBy'),
  orderReverse?: boolean(name='OrderReverse'),
  project?: string(name='Project'),
  state?: string(name='State'),
}

model ListJobsResponseBody = {
  hostId?: string(name='HostId'),
  jobs?: [ 
    {
      definition?: JobDefinition(name='Definition'),
      description?: string(name='Description'),
      jobId?: string(name='JobId'),
      name?: string(name='Name'),
      ownerId?: string(name='OwnerId'),
      project?: string(name='Project'),
      status?: {
        attempts?: [
          Attempt
        ](name='Attempts'),
        createTime?: string(name='CreateTime'),
        endTime?: string(name='EndTime'),
        exitCode?: int32(name='ExitCode'),
        pid?: int32(name='Pid'),
        reason?: string(name='Reason'),
        startTime?: string(name='StartTime'),
        state?: string(name='State'),
        worker?: string(name='Worker'),
      }(name='Status'),
    }
  ](name='Jobs'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListJobsResponse = {
  headers: map[string]string(name='headers'),
  body: ListJobsResponseBody(name='body'),
}

async function listJobsWithOptions(request: ListJobsRequest, runtime: Util.RuntimeOptions): ListJobsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListJobs', '2018-12-13', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listJobs(request: ListJobsRequest): ListJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listJobsWithOptions(request, runtime);
}

model ListProjectsRequest {
  labelSelector?: string(name='LabelSelector'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  orderBy?: string(name='OrderBy'),
  orderReverse?: boolean(name='OrderReverse'),
}

model ListProjectsResponseBody = {
  hostId?: string(name='HostId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  projects?: [ 
    {
      definition?: ProjectDefinition(name='Definition'),
      description?: string(name='Description'),
      project?: string(name='Project'),
      status?: {
        createTime?: string(name='CreateTime'),
        lastModifiedTime?: string(name='LastModifiedTime'),
      }(name='Status'),
    }
  ](name='Projects'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListProjectsResponse = {
  headers: map[string]string(name='headers'),
  body: ListProjectsResponseBody(name='body'),
}

async function listProjectsWithOptions(request: ListProjectsRequest, runtime: Util.RuntimeOptions): ListProjectsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListProjects', '2018-12-13', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listProjects(request: ListProjectsRequest): ListProjectsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listProjectsWithOptions(request, runtime);
}

model ListRegionsRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
}

model ListRegionsResponseBody = {
  hostId?: string(name='HostId'),
  regions?: [ 
    {
      localName?: string(name='LocalName'),
      regionId?: string(name='RegionId'),
    }
  ](name='Regions'),
  requestId?: string(name='RequestId'),
}

model ListRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListRegionsResponseBody(name='body'),
}

async function listRegionsWithOptions(request: ListRegionsRequest, runtime: Util.RuntimeOptions): ListRegionsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListRegions', '2018-12-13', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listRegions(request: ListRegionsRequest): ListRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRegionsWithOptions(request, runtime);
}

model ListWorkersRequest {
  clusterId?: string(name='ClusterId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  project?: string(name='Project'),
}

model ListWorkersResponseBody = {
  hostId?: string(name='HostId'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  workers?: [ 
    {
      status?: {
        activeTime?: string(name='ActiveTime'),
        allocateTime?: string(name='AllocateTime'),
        conditions?: [
          Conditions
        ](name='Conditions'),
        container?: {
          cpu?: int32(name='Cpu'),
          memory?: int32(name='Memory'),
        }(name='Container'),
        createTime?: string(name='CreateTime'),
        ECS?: {
          cpu?: int32(name='Cpu'),
          endpoint?: string(name='Endpoint'),
          hostname?: string(name='Hostname'),
          instanceId?: string(name='InstanceId'),
          instanceType?: string(name='InstanceType'),
          memory?: int32(name='Memory'),
          password?: string(name='Password'),
          resourceType?: string(name='ResourceType'),
          spotPriceLimit?: string(name='SpotPriceLimit'),
          spotStrategy?: string(name='SpotStrategy'),
          systemDiskSize?: int32(name='SystemDiskSize'),
          systemDiskType?: string(name='SystemDiskType'),
          VMImage?: string(name='VMImage'),
          zoneId?: string(name='ZoneId'),
        }(name='ECS'),
        jobQueue?: string(name='JobQueue'),
        networkInterfaceId?: string(name='NetworkInterfaceId'),
        poolWorkerId?: string(name='PoolWorkerId'),
        securityGroupId?: string(name='SecurityGroupId'),
        state?: string(name='State'),
        vSwitchId?: string(name='VSwitchId'),
        workerType?: int32(name='WorkerType'),
      }(name='Status'),
      workerId?: string(name='WorkerId'),
    }
  ](name='Workers'),
}

model ListWorkersResponse = {
  headers: map[string]string(name='headers'),
  body: ListWorkersResponseBody(name='body'),
}

async function listWorkersWithOptions(request: ListWorkersRequest, runtime: Util.RuntimeOptions): ListWorkersResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListWorkers', '2018-12-13', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listWorkers(request: ListWorkersRequest): ListWorkersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listWorkersWithOptions(request, runtime);
}

model OpenBatchComputeServiceResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model OpenBatchComputeServiceResponse = {
  headers: map[string]string(name='headers'),
  body: OpenBatchComputeServiceResponseBody(name='body'),
}

async function openBatchComputeServiceWithOptions(runtime: Util.RuntimeOptions): OpenBatchComputeServiceResponse {
  var req = new OpenApi.OpenApiRequest{};
  return doRPCRequest('OpenBatchComputeService', '2018-12-13', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function openBatchComputeService(): OpenBatchComputeServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return openBatchComputeServiceWithOptions(runtime);
}

model PollCmdRequest {
  queue?: string(name='Queue'),
  waitSeconds?: string(name='WaitSeconds'),
  workerId?: string(name='WorkerId'),
}

model PollCmdResponseBody = {
  hostId?: string(name='HostId'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model PollCmdResponse = {
  headers: map[string]string(name='headers'),
  body: PollCmdResponseBody(name='body'),
}

async function pollCmdWithOptions(request: PollCmdRequest, runtime: Util.RuntimeOptions): PollCmdResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('PollCmd', '2018-12-13', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function pollCmd(request: PollCmdRequest): PollCmdResponse {
  var runtime = new Util.RuntimeOptions{};
  return pollCmdWithOptions(request, runtime);
}

model RecreateWorkerRequest {
  clusterId?: string(name='ClusterId'),
  project?: string(name='Project'),
  workerId?: string(name='WorkerId'),
}

model RecreateWorkerResponseBody = {
  hostId?: string(name='HostId'),
  requestId?: string(name='RequestId'),
}

model RecreateWorkerResponse = {
  headers: map[string]string(name='headers'),
  body: RecreateWorkerResponseBody(name='body'),
}

async function recreateWorkerWithOptions(request: RecreateWorkerRequest, runtime: Util.RuntimeOptions): RecreateWorkerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RecreateWorker', '2018-12-13', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function recreateWorker(request: RecreateWorkerRequest): RecreateWorkerResponse {
  var runtime = new Util.RuntimeOptions{};
  return recreateWorkerWithOptions(request, runtime);
}

model RunJobRequest {
  clientToken?: string(name='ClientToken'),
  definition?: JobDefinition(name='Definition'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  project?: string(name='Project'),
}

model RunJobShrinkRequest {
  clientToken?: string(name='ClientToken'),
  definitionShrink?: string(name='Definition'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  project?: string(name='Project'),
}

model RunJobResponseBody = {
  createTime?: string(name='CreateTime'),
  endTime?: string(name='EndTime'),
  exitCode?: int32(name='ExitCode'),
  hostId?: string(name='HostId'),
  pid?: int32(name='Pid'),
  reason?: string(name='Reason'),
  requestId?: string(name='RequestId'),
  startTime?: string(name='StartTime'),
  state?: string(name='State'),
  worker?: string(name='Worker'),
}

model RunJobResponse = {
  headers: map[string]string(name='headers'),
  body: RunJobResponseBody(name='body'),
}

async function runJobWithOptions(tmpReq: RunJobRequest, runtime: Util.RuntimeOptions): RunJobResponse {
  Util.validateModel(tmpReq);
  var request = new RunJobShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.definition)) {
    request.definitionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.definition, 'Definition', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RunJob', '2018-12-13', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function runJob(request: RunJobRequest): RunJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return runJobWithOptions(request, runtime);
}

model UpdateClusterRequest {
  clusterId?: string(name='ClusterId'),
  definition?: ClusterDefinition(name='Definition'),
  project?: string(name='Project'),
}

model UpdateClusterShrinkRequest {
  clusterId?: string(name='ClusterId'),
  definitionShrink?: string(name='Definition'),
  project?: string(name='Project'),
}

model UpdateClusterResponseBody = {
  hostId?: string(name='HostId'),
  requestId?: string(name='RequestId'),
}

model UpdateClusterResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateClusterResponseBody(name='body'),
}

async function updateClusterWithOptions(tmpReq: UpdateClusterRequest, runtime: Util.RuntimeOptions): UpdateClusterResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateClusterShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.definition)) {
    request.definitionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.definition, 'Definition', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateCluster', '2018-12-13', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateCluster(request: UpdateClusterRequest): UpdateClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateClusterWithOptions(request, runtime);
}

model UpdateJobQueueRequest {
  definition?: JobQueueDefinition(name='Definition'),
  name?: string(name='Name'),
  project?: string(name='Project'),
}

model UpdateJobQueueShrinkRequest {
  definitionShrink?: string(name='Definition'),
  name?: string(name='Name'),
  project?: string(name='Project'),
}

model UpdateJobQueueResponseBody = {
  hostId?: string(name='HostId'),
  requestId?: string(name='RequestId'),
}

model UpdateJobQueueResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateJobQueueResponseBody(name='body'),
}

async function updateJobQueueWithOptions(tmpReq: UpdateJobQueueRequest, runtime: Util.RuntimeOptions): UpdateJobQueueResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateJobQueueShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.definition)) {
    request.definitionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.definition, 'Definition', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateJobQueue', '2018-12-13', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateJobQueue(request: UpdateJobQueueRequest): UpdateJobQueueResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateJobQueueWithOptions(request, runtime);
}

model UpdateProjectRequest {
  definition?: ProjectDefinition(name='Definition'),
  description?: string(name='Description'),
  project?: string(name='Project'),
}

model UpdateProjectShrinkRequest {
  definitionShrink?: string(name='Definition'),
  description?: string(name='Description'),
  project?: string(name='Project'),
}

model UpdateProjectResponseBody = {
  hostId?: string(name='HostId'),
  requestId?: string(name='RequestId'),
}

model UpdateProjectResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateProjectResponseBody(name='body'),
}

async function updateProjectWithOptions(tmpReq: UpdateProjectRequest, runtime: Util.RuntimeOptions): UpdateProjectResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateProjectShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.definition)) {
    request.definitionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.definition, 'Definition', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateProject', '2018-12-13', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateProject(request: UpdateProjectRequest): UpdateProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateProjectWithOptions(request, runtime);
}

model UpdateWorkerStatusRequest {
  clusterId?: string(name='ClusterId'),
  status?: string(name='Status'),
  workerId?: string(name='WorkerId'),
}

model UpdateWorkerStatusResponseBody = {
  hostId?: string(name='HostId'),
  requestId?: string(name='RequestId'),
}

model UpdateWorkerStatusResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateWorkerStatusResponseBody(name='body'),
}

async function updateWorkerStatusWithOptions(request: UpdateWorkerStatusRequest, runtime: Util.RuntimeOptions): UpdateWorkerStatusResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateWorkerStatus', '2018-12-13', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateWorkerStatus(request: UpdateWorkerStatusRequest): UpdateWorkerStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateWorkerStatusWithOptions(request, runtime);
}

