/**
 *
 */
import Util;
import OSS;
import OpenPlatform;
import OSSUtil;
import FileForm;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('aisearch', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model Box {
  height?: int32(name='Height', example='200'),
  left?: int32(name='Left', example='10'),
  top?: int32(name='Top', example='20'),
  width?: int32(name='Width', example='100'),
}

model AddImageRequest {
  boxes?: [
    Box
  ](name='Boxes'),
  customContent?: string(name='CustomContent'),
  detectLimit?: int32(name='DetectLimit'),
  intAttr?: int32(name='IntAttr'),
  picContent?: string(name='PicContent'),
  picName?: string(name='PicName'),
  picUrl?: string(name='PicUrl'),
  strAttr?: string(name='StrAttr'),
}

model AddImageAdvanceRequest {
  boxes?: [
    Box
  ](name='Boxes'),
  customContent?: string(name='CustomContent'),
  detectLimit?: int32(name='DetectLimit'),
  intAttr?: int32(name='IntAttr'),
  picContentObject?: readable(name='PicContent'),
  picName?: string(name='PicName'),
  picUrl?: string(name='PicUrl'),
  strAttr?: string(name='StrAttr'),
}

model AddImageShrinkRequest {
  boxesShrink?: string(name='Boxes'),
  customContent?: string(name='CustomContent'),
  detectLimit?: int32(name='DetectLimit'),
  intAttr?: int32(name='IntAttr'),
  picContent?: string(name='PicContent'),
  picName?: string(name='PicName'),
  picUrl?: string(name='PicUrl'),
  strAttr?: string(name='StrAttr'),
}

model AddImageResponseBody = {
  requestId?: string(name='RequestId', example='AEBFD401-E487-502A-B20D-54CACD4AA42D'),
  success?: boolean(name='Success', example='true'),
}

model AddImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddImageResponseBody(name='body'),
}

async function addImageWithOptions(InstanceName: string, ProductId: string, tmpReq: AddImageRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddImageResponse {
  Util.validateModel(tmpReq);
  var request = new AddImageShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.boxes)) {
    request.boxesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.boxes, 'Boxes', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.customContent)) {
    query['CustomContent'] = request.customContent;
  }
  if (!Util.isUnset(request.detectLimit)) {
    query['DetectLimit'] = request.detectLimit;
  }
  if (!Util.isUnset(request.intAttr)) {
    query['IntAttr'] = request.intAttr;
  }
  if (!Util.isUnset(request.picContent)) {
    query['PicContent'] = request.picContent;
  }
  if (!Util.isUnset(request.picName)) {
    query['PicName'] = request.picName;
  }
  if (!Util.isUnset(request.picUrl)) {
    query['PicUrl'] = request.picUrl;
  }
  if (!Util.isUnset(request.strAttr)) {
    query['StrAttr'] = request.strAttr;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.boxesShrink)) {
    body['Boxes'] = request.boxesShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddImage',
    version = '2023-01-01',
    protocol = 'HTTPS',
    pathname = `/api/instance/${OpenApiUtil.getEncodeParam(InstanceName)}/entity/${OpenApiUtil.getEncodeParam(ProductId)}/image`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addImage(InstanceName: string, ProductId: string, request: AddImageRequest): AddImageResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addImageWithOptions(InstanceName, ProductId, request, headers, runtime);
}

async function addImageAdvance(InstanceName: string, ProductId: string, request: AddImageAdvanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddImageResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'aisearch',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var addImageReq = new AddImageRequest{};
  OpenApiUtil.convert(request, addImageReq);

  if(!Util.isUnset(request.picContentObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.picContentObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    addImageReq.picContent = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var addImageResp = addImageWithOptions(InstanceName, ProductId, addImageReq, headers, runtime);
  return addImageResp;
}

model CheckOssIncrementMetaExistRequest {
  bucketName?: string(name='BucketName', description='oss bucket', example='linyunjing'),
  key?: string(name='Key', example='increment.meta'),
  ossPath?: string(name='OssPath', description='oss path', example='/test/abc'),
}

model CheckOssIncrementMetaExistResponseBody = {
  data?: {
    exist?: boolean(name='Exist', example='False'),
  }(name='Data'),
  requestId?: string(name='RequestId', example='8DDBFDF3-9132-589A-8035-877E288450E7'),
  success?: boolean(name='Success', example='true'),
}

model CheckOssIncrementMetaExistResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckOssIncrementMetaExistResponseBody(name='body'),
}

async function checkOssIncrementMetaExistWithOptions(request: CheckOssIncrementMetaExistRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CheckOssIncrementMetaExistResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.bucketName)) {
    query['BucketName'] = request.bucketName;
  }
  if (!Util.isUnset(request.key)) {
    query['Key'] = request.key;
  }
  if (!Util.isUnset(request.ossPath)) {
    query['OssPath'] = request.ossPath;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckOssIncrementMetaExist',
    version = '2023-01-01',
    protocol = 'HTTPS',
    pathname = `/api/oss/check-increment-metafile`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkOssIncrementMetaExist(request: CheckOssIncrementMetaExistRequest): CheckOssIncrementMetaExistResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return checkOssIncrementMetaExistWithOptions(request, headers, runtime);
}

model CreateBatchTasksRequest {
  bucketName?: string(name='BucketName', description='oss bucket', example='test032201'),
  callbackAddress?: string(name='CallbackAddress', example='http://xxx.com'),
  ossPath?: string(name='OssPath', description='oss path', example='/test/abc'),
}

model CreateBatchTasksResponseBody = {
  data?: {
    id?: long(name='Id', example='100'),
    status?: string(name='Status', example='PROCESSING'),
  }(name='Data'),
  requestId?: string(name='RequestId', example='E7293DDE-2846-5611-AC3E-97848D8A678D'),
  success?: boolean(name='Success', example='true'),
}

model CreateBatchTasksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateBatchTasksResponseBody(name='body'),
}

async function createBatchTasksWithOptions(InstanceName: string, request: CreateBatchTasksRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateBatchTasksResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.bucketName)) {
    query['BucketName'] = request.bucketName;
  }
  if (!Util.isUnset(request.callbackAddress)) {
    query['CallbackAddress'] = request.callbackAddress;
  }
  if (!Util.isUnset(request.ossPath)) {
    query['OssPath'] = request.ossPath;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateBatchTasks',
    version = '2023-01-01',
    protocol = 'HTTPS',
    pathname = `/api/instance/${OpenApiUtil.getEncodeParam(InstanceName)}/batch-task`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createBatchTasks(InstanceName: string, request: CreateBatchTasksRequest): CreateBatchTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createBatchTasksWithOptions(InstanceName, request, headers, runtime);
}

model CreateDumpMetaResponseBody = {
  data?: {
    id?: long(name='Id', example='100'),
    status?: string(name='Status', example='PROCESSING'),
  }(name='Data'),
  requestId?: string(name='RequestId', example='3D5AF31F-0682-5771-AD4B-EB8A759F566C'),
  success?: boolean(name='Success', example='true'),
}

model CreateDumpMetaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDumpMetaResponseBody(name='body'),
}

async function createDumpMetaWithOptions(InstanceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): CreateDumpMetaResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'CreateDumpMeta',
    version = '2023-01-01',
    protocol = 'HTTPS',
    pathname = `/api/instance/${OpenApiUtil.getEncodeParam(InstanceName)}/dump-meta`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDumpMeta(InstanceName: string): CreateDumpMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createDumpMetaWithOptions(InstanceName, headers, runtime);
}

model DeleteImageRequest {
  picName?: string(name='PicName', example='2092061_1.jpg'),
}

model DeleteImageResponseBody = {
  data?: {
    picNames?: [ string ](name='PicNames'),
  }(name='Data'),
  requestId?: string(name='RequestId', example='0683A93A-50C7-5ABA-8CF7-0294E3445384'),
  success?: boolean(name='Success', example='true'),
}

model DeleteImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteImageResponseBody(name='body'),
}

async function deleteImageWithOptions(InstanceName: string, ProductId: string, request: DeleteImageRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteImageResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.picName)) {
    query['PicName'] = request.picName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteImage',
    version = '2023-01-01',
    protocol = 'HTTPS',
    pathname = `/api/instance/${OpenApiUtil.getEncodeParam(InstanceName)}/entity/${OpenApiUtil.getEncodeParam(ProductId)}/image`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteImage(InstanceName: string, ProductId: string, request: DeleteImageRequest): DeleteImageResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteImageWithOptions(InstanceName, ProductId, request, headers, runtime);
}

model GetImageRequest {
  picName?: string(name='PicName', example='2092061_1.jpg'),
}

model GetImageResponseBody = {
  data?: {
    boxes?: [ 
      {
        bbox?: [ int32 ](name='Bbox'),
        confidence?: float(name='Confidence', example='0.95'),
      }
    ](name='Boxes'),
    customContent?: string(name='CustomContent', example='zidingyi'),
    intAttr?: int32(name='IntAttr', example='123'),
    picName?: string(name='PicName', example='2092061_1.jpg'),
    productId?: string(name='ProductId', example='P0001'),
    strAttr?: string(name='StrAttr', example='abc'),
  }(name='Data'),
  requestId?: string(name='RequestId', example='01783FD4-26B7-5FE5-BF78-56B43F41AAFF'),
  success?: boolean(name='Success', example='true'),
}

model GetImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetImageResponseBody(name='body'),
}

async function getImageWithOptions(InstanceName: string, ProductId: string, request: GetImageRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetImageResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.picName)) {
    query['PicName'] = request.picName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetImage',
    version = '2023-01-01',
    protocol = 'HTTPS',
    pathname = `/api/instance/${OpenApiUtil.getEncodeParam(InstanceName)}/entity/${OpenApiUtil.getEncodeParam(ProductId)}/image`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getImage(InstanceName: string, ProductId: string, request: GetImageRequest): GetImageResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getImageWithOptions(InstanceName, ProductId, request, headers, runtime);
}

model GetInstanceResponseBody = {
  data?: {
    capacity?: int32(name='Capacity', example='5'),
    instanceId?: string(name='InstanceId', example='imagesearch_aisearch_xxx'),
    instanceName?: string(name='InstanceName'),
    qps?: string(name='Qps'),
    region?: string(name='Region'),
    serviceType?: string(name='ServiceType', example='COMMODITY'),
    status?: string(name='Status', example='NORMAL'),
    totalCount?: long(name='TotalCount', example='1000'),
    utcCreateTime?: long(name='UtcCreateTime', example='1623081600000'),
    utcExpireTime?: long(name='UtcExpireTime', example='1620382716000'),
  }(name='Data'),
  requestId?: string(name='RequestId', example='3F37E8F4-2D57-5FEC-96AF-B88ACF3252FC'),
  success?: boolean(name='Success', example='true'),
}

model GetInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetInstanceResponseBody(name='body'),
}

async function getInstanceWithOptions(InstanceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetInstanceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetInstance',
    version = '2023-01-01',
    protocol = 'HTTPS',
    pathname = `/api/instance/${OpenApiUtil.getEncodeParam(InstanceName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getInstance(InstanceName: string): GetInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getInstanceWithOptions(InstanceName, headers, runtime);
}

model ListBatchTasksRequest {
  bucketName?: string(name='BucketName', description='oss bucket', example='bucket-test'),
  id?: long(name='Id', example='911'),
  ossPath?: string(name='OssPath', description='oss path', example='/test/abc'),
  pageNumber?: int32(name='PageNumber', example='1'),
  pageSize?: int32(name='PageSize', example='10'),
}

model ListBatchTasksResponseBody = {
  data?: {
    increments?: [ 
      {
        bucketName?: string(name='BucketName', example='maijun-test'),
        callbackAddress?: string(name='CallbackAddress', example='http://xxx.com'),
        callbackTaskStatus?: string(name='CallbackTaskStatus', example='PROCESSING'),
        errorUrl?: string(name='ErrorUrl', example='https://xxx.com'),
        id?: long(name='Id', example='38'),
        msg?: string(name='Msg'),
        ossPath?: string(name='OssPath', example='/test/abc'),
        status?: string(name='Status', example='PROCESSING'),
        utcCreateTime?: string(name='UtcCreateTime', example='2023-02-09T02:15:46.911+00:00'),
        utcUpdateTime?: string(name='UtcUpdateTime', example='2023-02-09T02:15:46.911+00:00'),
      }
    ](name='Increments'),
    pageNumber?: int32(name='PageNumber', example='1'),
    pageSize?: int32(name='PageSize', example='10'),
    total?: long(name='Total', example='2000'),
  }(name='Data'),
  requestId?: string(name='RequestId', example='F2F99088-0151-5E22-910D-5E82C6DEA486'),
  success?: boolean(name='Success', example='true'),
}

model ListBatchTasksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListBatchTasksResponseBody(name='body'),
}

async function listBatchTasksWithOptions(InstanceName: string, request: ListBatchTasksRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListBatchTasksResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.bucketName)) {
    query['BucketName'] = request.bucketName;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.ossPath)) {
    query['OssPath'] = request.ossPath;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListBatchTasks',
    version = '2023-01-01',
    protocol = 'HTTPS',
    pathname = `/api/instance/${OpenApiUtil.getEncodeParam(InstanceName)}/batch-tasks`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listBatchTasks(InstanceName: string, request: ListBatchTasksRequest): ListBatchTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listBatchTasksWithOptions(InstanceName, request, headers, runtime);
}

model ListDumpMetaRequest {
  id?: long(name='Id', example='1499'),
  pageNumber?: int32(name='PageNumber', example='1'),
  pageSize?: int32(name='PageSize', example='10'),
}

model ListDumpMetaResponseBody = {
  data?: {
    dumpMetaList?: [ 
      {
        id?: long(name='Id', example='45'),
        metaUrl?: string(name='MetaUrl', example='https://xxx.com'),
        msg?: string(name='Msg'),
        status?: string(name='Status', example='PROCESSING'),
        utcCreateTime?: string(name='UtcCreateTime', example='2023-02-09T02:15:46.911+00:00'),
        utcUpdateTime?: string(name='UtcUpdateTime', example='2023-02-09T02:15:46.911+00:00'),
      }
    ](name='DumpMetaList'),
    pageNumber?: int32(name='PageNumber', example='1'),
    pageSize?: int32(name='PageSize', example='10'),
    total?: long(name='Total', example='2000'),
  }(name='Data'),
  requestId?: string(name='RequestId', example='C8E822FA-10EE-57AA-A3EE-6C95FE132386'),
  success?: boolean(name='Success', example='true'),
}

model ListDumpMetaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDumpMetaResponseBody(name='body'),
}

async function listDumpMetaWithOptions(InstanceName: string, request: ListDumpMetaRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDumpMetaResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDumpMeta',
    version = '2023-01-01',
    protocol = 'HTTPS',
    pathname = `/api/instance/${OpenApiUtil.getEncodeParam(InstanceName)}/dump-metas`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDumpMeta(InstanceName: string, request: ListDumpMetaRequest): ListDumpMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDumpMetaWithOptions(InstanceName, request, headers, runtime);
}

model ListInstanceRequest {
  instanceName?: string(name='InstanceName', example='de'),
  pageNumber?: int32(name='PageNumber', example='1'),
  pageSize?: int32(name='PageSize', example='10'),
  serviceType?: string(name='ServiceType', example='COMMODITY'),
}

model ListInstanceResponseBody = {
  data?: {
    instances?: [ 
      {
        capacity?: int32(name='Capacity'),
        instanceId?: string(name='InstanceId'),
        instanceName?: string(name='InstanceName'),
        qps?: string(name='Qps'),
        region?: string(name='Region'),
        serviceType?: string(name='ServiceType'),
        status?: string(name='Status'),
        utcCreateTime?: long(name='UtcCreateTime'),
        utcExpireTime?: long(name='UtcExpireTime'),
      }
    ](name='Instances'),
    pageNumber?: int32(name='PageNumber', example='1'),
    pageSize?: int32(name='PageSize', example='10'),
    total?: long(name='Total', example='2000'),
  }(name='Data'),
  requestId?: string(name='RequestId', example='5880E7AA-2304-5452-9278-259524D489B1'),
  success?: boolean(name='Success', example='true'),
}

model ListInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInstanceResponseBody(name='body'),
}

async function listInstanceWithOptions(request: ListInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListInstanceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.instanceName)) {
    query['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.serviceType)) {
    query['ServiceType'] = request.serviceType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInstance',
    version = '2023-01-01',
    protocol = 'HTTPS',
    pathname = `/api/instances`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listInstance(request: ListInstanceRequest): ListInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listInstanceWithOptions(request, headers, runtime);
}

model ListOssBucketAndPathRequest {
  bucketName?: string(name='BucketName', example='bucket-test'),
  ossPath?: string(name='OssPath', example='/test/abc'),
}

model ListOssBucketAndPathResponseBody = {
  data?: {
    bucketList?: [ string ](name='BucketList'),
    pathList?: [ string ](name='PathList'),
  }(name='Data'),
  requestId?: string(name='RequestId', example='AEBFD401-E487-502A-B20D-54CACD4AA42D'),
  success?: boolean(name='Success', example='true'),
}

model ListOssBucketAndPathResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListOssBucketAndPathResponseBody(name='body'),
}

async function listOssBucketAndPathWithOptions(request: ListOssBucketAndPathRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListOssBucketAndPathResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.bucketName)) {
    query['BucketName'] = request.bucketName;
  }
  if (!Util.isUnset(request.ossPath)) {
    query['OssPath'] = request.ossPath;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListOssBucketAndPath',
    version = '2023-01-01',
    protocol = 'HTTPS',
    pathname = `/api/oss/buckets-and-path`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listOssBucketAndPath(request: ListOssBucketAndPathRequest): ListOssBucketAndPathResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listOssBucketAndPathWithOptions(request, headers, runtime);
}

model ResetInstanceResponseBody = {
  data?: {
    capacity?: int32(name='Capacity', example='5'),
    instanceId?: string(name='InstanceId', example='imagesearch_aisearch_xxx'),
    instanceName?: string(name='InstanceName', example='demoinstance1'),
    serviceType?: string(name='ServiceType', example='COMMODITY'),
    status?: string(name='Status', example='NORMAL'),
    utcCreateTime?: long(name='UtcCreateTime', example='1623081600000'),
    utcExpireTime?: long(name='UtcExpireTime', example='1620382716000'),
  }(name='Data'),
  requestId?: string(name='RequestId', example='CD8E5DA2-D61D-5D47-BAE2-EB25E6D56B8D'),
  success?: boolean(name='Success', example='true'),
}

model ResetInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ResetInstanceResponseBody(name='body'),
}

async function resetInstanceWithOptions(InstanceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): ResetInstanceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ResetInstance',
    version = '2023-01-01',
    protocol = 'HTTPS',
    pathname = `/api/instance/${OpenApiUtil.getEncodeParam(InstanceName)}/reset`,
    method = 'PATCH',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function resetInstance(InstanceName: string): ResetInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return resetInstanceWithOptions(InstanceName, headers, runtime);
}

model SearchImageByNameRequest {
  filter?: string(name='Filter', example='intAttr = 1000 AND strAttr = "value1"'),
  num?: int32(name='Num', example='1'),
  picName?: string(name='PicName', example='2092061_1.jpg'),
  productId?: string(name='ProductId', example='3825215'),
  start?: int32(name='Start', example='0'),
  text?: string(name='Text'),
}

model SearchImageByNameResponseBody = {
  data?: {
    picInfos?: [ 
      {
        bbox?: [ int32 ](name='Bbox'),
        confidence?: float(name='Confidence', example='0.5'),
      }
    ](name='PicInfos'),
    picList?: [ 
      {
        customContent?: string(name='CustomContent', example='fdafdasf'),
        intAttr?: int32(name='IntAttr', example='123'),
        otherBoxes?: [ 
          {
            bbox?: [ int32 ](name='Bbox'),
            confidence?: float(name='Confidence', example='0.5'),
          }
        ](name='OtherBoxes'),
        picName?: string(name='PicName', example='7837303_8566180.jpg'),
        productId?: string(name='ProductId', example='3841983'),
        score?: float(name='Score', example='0.9'),
        similarBoxes?: [ 
          {
            bbox?: [ int32 ](name='Bbox'),
            confidence?: float(name='Confidence', example='0.5'),
            score?: float(name='Score', example='0.9'),
          }
        ](name='SimilarBoxes'),
        strAttr?: string(name='StrAttr', example='abc'),
      }
    ](name='PicList'),
  }(name='Data'),
  requestId?: string(name='RequestId', example='6439E600-931C-5AF8-942F-CEA9ECA79952'),
  success?: boolean(name='Success', example='true'),
}

model SearchImageByNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchImageByNameResponseBody(name='body'),
}

async function searchImageByNameWithOptions(InstanceName: string, request: SearchImageByNameRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SearchImageByNameResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.filter)) {
    query['Filter'] = request.filter;
  }
  if (!Util.isUnset(request.num)) {
    query['Num'] = request.num;
  }
  if (!Util.isUnset(request.picName)) {
    query['PicName'] = request.picName;
  }
  if (!Util.isUnset(request.productId)) {
    query['ProductId'] = request.productId;
  }
  if (!Util.isUnset(request.start)) {
    query['Start'] = request.start;
  }
  if (!Util.isUnset(request.text)) {
    query['Text'] = request.text;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchImageByName',
    version = '2023-01-01',
    protocol = 'HTTPS',
    pathname = `/api/instance/${OpenApiUtil.getEncodeParam(InstanceName)}/search-by-name`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchImageByName(InstanceName: string, request: SearchImageByNameRequest): SearchImageByNameResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return searchImageByNameWithOptions(InstanceName, request, headers, runtime);
}

model SearchImageByPicRequest {
  box?: Box(name='Box'),
  detectLimit?: int32(name='DetectLimit', example='0'),
  filter?: string(name='Filter', example='intAttr = 1000 AND strAttr = "value1"'),
  num?: int32(name='Num', example='1'),
  picContent?: string(name='PicContent', example='https://my-test.oss-cn-hangzhou.aliyuncs.com/ssth/case.jpeg'),
  picUrl?: string(name='PicUrl', example='https://my-test.oss-cn-hangzhou.aliyuncs.com/ssth/case.jpeg'),
  start?: int32(name='Start', example='0'),
  text?: string(name='Text'),
}

model SearchImageByPicAdvanceRequest {
  box?: Box(name='Box'),
  detectLimit?: int32(name='DetectLimit', example='0'),
  filter?: string(name='Filter', example='intAttr = 1000 AND strAttr = "value1"'),
  num?: int32(name='Num', example='1'),
  picContentObject?: readable(name='PicContent', example='https://my-test.oss-cn-hangzhou.aliyuncs.com/ssth/case.jpeg'),
  picUrl?: string(name='PicUrl', example='https://my-test.oss-cn-hangzhou.aliyuncs.com/ssth/case.jpeg'),
  start?: int32(name='Start', example='0'),
  text?: string(name='Text'),
}

model SearchImageByPicShrinkRequest {
  boxShrink?: string(name='Box'),
  detectLimit?: int32(name='DetectLimit', example='0'),
  filter?: string(name='Filter', example='intAttr = 1000 AND strAttr = "value1"'),
  num?: int32(name='Num', example='1'),
  picContent?: string(name='PicContent', example='https://my-test.oss-cn-hangzhou.aliyuncs.com/ssth/case.jpeg'),
  picUrl?: string(name='PicUrl', example='https://my-test.oss-cn-hangzhou.aliyuncs.com/ssth/case.jpeg'),
  start?: int32(name='Start', example='0'),
  text?: string(name='Text'),
}

model SearchImageByPicResponseBody = {
  data?: {
    picInfos?: [ 
      {
        bbox?: [ int32 ](name='Bbox'),
        confidence?: float(name='Confidence', example='0.78'),
      }
    ](name='PicInfos'),
    picList?: [ 
      {
        customContent?: string(name='CustomContent', example='abcdef'),
        intAttr?: int32(name='IntAttr', example='1860'),
        otherBoxes?: [ 
          {
            bbox?: [ int32 ](name='Bbox'),
            confidence?: float(name='Confidence', example='0.5'),
          }
        ](name='OtherBoxes'),
        picName?: string(name='PicName', example='JY03546'),
        productId?: string(name='ProductId', example='124624'),
        score?: float(name='Score', example='0.9'),
        similarBoxes?: [ 
          {
            bbox?: [ int32 ](name='Bbox'),
            confidence?: float(name='Confidence', example='0.9'),
            score?: float(name='Score', example='0.8'),
          }
        ](name='SimilarBoxes'),
        strAttr?: string(name='StrAttr', example='abcdef'),
      }
    ](name='PicList'),
  }(name='Data'),
  requestId?: string(name='RequestId', example='5880E7AA-2304-5452-9278-259524D489B1'),
  success?: boolean(name='Success', example='true'),
}

model SearchImageByPicResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchImageByPicResponseBody(name='body'),
}

async function searchImageByPicWithOptions(InstanceName: string, tmpReq: SearchImageByPicRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SearchImageByPicResponse {
  Util.validateModel(tmpReq);
  var request = new SearchImageByPicShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.box)) {
    request.boxShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.box, 'Box', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.boxShrink)) {
    query['Box'] = request.boxShrink;
  }
  if (!Util.isUnset(request.detectLimit)) {
    query['DetectLimit'] = request.detectLimit;
  }
  if (!Util.isUnset(request.filter)) {
    query['Filter'] = request.filter;
  }
  if (!Util.isUnset(request.num)) {
    query['Num'] = request.num;
  }
  if (!Util.isUnset(request.picContent)) {
    query['PicContent'] = request.picContent;
  }
  if (!Util.isUnset(request.picUrl)) {
    query['PicUrl'] = request.picUrl;
  }
  if (!Util.isUnset(request.start)) {
    query['Start'] = request.start;
  }
  if (!Util.isUnset(request.text)) {
    query['Text'] = request.text;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchImageByPic',
    version = '2023-01-01',
    protocol = 'HTTPS',
    pathname = `/api/instance/${OpenApiUtil.getEncodeParam(InstanceName)}/search-by-pic`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchImageByPic(InstanceName: string, request: SearchImageByPicRequest): SearchImageByPicResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return searchImageByPicWithOptions(InstanceName, request, headers, runtime);
}

async function searchImageByPicAdvance(InstanceName: string, request: SearchImageByPicAdvanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SearchImageByPicResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'aisearch',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var searchImageByPicReq = new SearchImageByPicRequest{};
  OpenApiUtil.convert(request, searchImageByPicReq);

  if(!Util.isUnset(request.picContentObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.picContentObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    searchImageByPicReq.picContent = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var searchImageByPicResp = searchImageByPicWithOptions(InstanceName, searchImageByPicReq, headers, runtime);
  return searchImageByPicResp;
}

model StopBatchTasksResponseBody = {
  requestId?: string(name='RequestId', example='7BAB46B5-F00F-5AF3-AC41-6F8B64BF6E52'),
  success?: boolean(name='Success', example='true'),
}

model StopBatchTasksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopBatchTasksResponseBody(name='body'),
}

async function stopBatchTasksWithOptions(InstanceName: string, Id: string, headers: map[string]string, runtime: Util.RuntimeOptions): StopBatchTasksResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StopBatchTasks',
    version = '2023-01-01',
    protocol = 'HTTPS',
    pathname = `/api/instance/${OpenApiUtil.getEncodeParam(InstanceName)}/batch-task/${OpenApiUtil.getEncodeParam(Id)}/stop`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopBatchTasks(InstanceName: string, Id: string): StopBatchTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopBatchTasksWithOptions(InstanceName, Id, headers, runtime);
}

model StopDumpMetaResponseBody = {
  requestId?: string(name='RequestId', example='D41689F2-39A4-5A81-8037-7D56629D8A9C'),
  success?: boolean(name='Success', example='true'),
}

model StopDumpMetaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopDumpMetaResponseBody(name='body'),
}

async function stopDumpMetaWithOptions(InstanceName: string, Id: string, headers: map[string]string, runtime: Util.RuntimeOptions): StopDumpMetaResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StopDumpMeta',
    version = '2023-01-01',
    protocol = 'HTTPS',
    pathname = `/api/instance/${OpenApiUtil.getEncodeParam(InstanceName)}/dump-meta/${OpenApiUtil.getEncodeParam(Id)}/stop`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopDumpMeta(InstanceName: string, Id: string): StopDumpMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopDumpMetaWithOptions(InstanceName, Id, headers, runtime);
}

model UpdateImageRequest {
  customContent?: string(name='CustomContent'),
  intAttr?: int32(name='IntAttr'),
  picName?: string(name='PicName'),
  strAttr?: string(name='StrAttr'),
}

model UpdateImageResponseBody = {
  requestId?: string(name='RequestId', example='AEBFD401-E487-502A-B20D-54CACD4AA42D'),
  success?: boolean(name='Success', example='true'),
}

model UpdateImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateImageResponseBody(name='body'),
}

async function updateImageWithOptions(InstanceName: string, ProductId: string, request: UpdateImageRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateImageResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.customContent)) {
    query['CustomContent'] = request.customContent;
  }
  if (!Util.isUnset(request.intAttr)) {
    query['IntAttr'] = request.intAttr;
  }
  if (!Util.isUnset(request.picName)) {
    query['PicName'] = request.picName;
  }
  if (!Util.isUnset(request.strAttr)) {
    query['StrAttr'] = request.strAttr;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateImage',
    version = '2023-01-01',
    protocol = 'HTTPS',
    pathname = `/api/instance/${OpenApiUtil.getEncodeParam(InstanceName)}/entity/${OpenApiUtil.getEncodeParam(ProductId)}/image`,
    method = 'PATCH',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateImage(InstanceName: string, ProductId: string, request: UpdateImageRequest): UpdateImageResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateImageWithOptions(InstanceName, ProductId, request, headers, runtime);
}

