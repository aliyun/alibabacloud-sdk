/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('iacservice', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model JobStatusDetailValue = {
  comment?: string(name='comment'),
  timeStamps?: string(name='timeStamps'),
  jobResult?: string(name='jobResult'),
}

model ProjectBuildConfigTaskPoliciesValue = {
  taskId?: string(name='taskId'),
  priority?: long(name='priority'),
  destroyAfterExecution?: boolean(name='destroyAfterExecution'),
}

model JobsStatusDetailValue = {
  comment?: string(name='comment'),
  timeStamps?: string(name='timeStamps'),
  jobResult?: string(name='jobResult'),
}

model AssociateParameterSetRequest {
  parameterSetIds?: [ string ](name='parameterSetIds'),
  resourceId?: string(name='resourceId'),
  resourceType?: string(name='resourceType'),
}

model AssociateParameterSetResponseBody = {
  requestId?: string(name='requestId'),
}

model AssociateParameterSetResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AssociateParameterSetResponseBody(name='body'),
}

async function associateParameterSet(request: AssociateParameterSetRequest): AssociateParameterSetResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return associateParameterSetWithOptions(request, headers, runtime);
}

async function associateParameterSetWithOptions(request: AssociateParameterSetRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AssociateParameterSetResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.parameterSetIds)) {
    body['parameterSetIds'] = request.parameterSetIds;
  }
  if (!Util.isUnset(request.resourceId)) {
    body['resourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    body['resourceType'] = request.resourceType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AssociateParameterSet',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/parameterSets/operations/associate`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model AssociateTaskGroupRequest {
  taskIds?: [ string ](name='taskIds'),
}

model AssociateTaskGroupResponseBody = {
  requestId?: string(name='requestId'),
}

model AssociateTaskGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AssociateTaskGroupResponseBody(name='body'),
}

async function associateTaskGroup(projectId: string, groupId: string, request: AssociateTaskGroupRequest): AssociateTaskGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return associateTaskGroupWithOptions(projectId, groupId, request, headers, runtime);
}

async function associateTaskGroupWithOptions(projectId: string, groupId: string, request: AssociateTaskGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AssociateTaskGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.taskIds)) {
    body['taskIds'] = request.taskIds;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AssociateTaskGroup',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/project/${OpenApiUtil.getEncodeParam(projectId)}/groups/${OpenApiUtil.getEncodeParam(groupId)}/associate`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model AttachRabbitmqPublisherRequest {
  taskId?: string(name='taskId'),
}

model AttachRabbitmqPublisherResponseBody = {
  requestId?: string(name='requestId'),
}

model AttachRabbitmqPublisherResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AttachRabbitmqPublisherResponseBody(name='body'),
}

async function attachRabbitmqPublisher(publisherId: string, request: AttachRabbitmqPublisherRequest): AttachRabbitmqPublisherResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return attachRabbitmqPublisherWithOptions(publisherId, request, headers, runtime);
}

async function attachRabbitmqPublisherWithOptions(publisherId: string, request: AttachRabbitmqPublisherRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AttachRabbitmqPublisherResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.taskId)) {
    body['taskId'] = request.taskId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AttachRabbitmqPublisher',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/publishers/${OpenApiUtil.getEncodeParam(publisherId)}/attach`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CancelResourceExportTaskRequest {
  clientToken?: string(name='clientToken'),
  ramRole?: string(name='ramRole'),
}

model CancelResourceExportTaskResponseBody = {
  exportTaskId?: string(name='exportTaskId'),
  exportVersion?: string(name='exportVersion'),
  requestId?: string(name='requestId'),
}

model CancelResourceExportTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelResourceExportTaskResponseBody(name='body'),
}

async function cancelResourceExportTask(exportTaskId: string, request: CancelResourceExportTaskRequest): CancelResourceExportTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return cancelResourceExportTaskWithOptions(exportTaskId, request, headers, runtime);
}

async function cancelResourceExportTaskWithOptions(exportTaskId: string, request: CancelResourceExportTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CancelResourceExportTaskResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ramRole)) {
    body['ramRole'] = request.ramRole;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CancelResourceExportTask',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/exportTasks/cancel/${OpenApiUtil.getEncodeParam(exportTaskId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CloneModuleRequest {
  description?: string(name='description'),
  moduleId?: string(name='moduleId'),
  moduleSource?: string(name='moduleSource'),
  moduleVersion?: string(name='moduleVersion'),
  name?: string(name='name'),
}

model CloneModuleResponseBody = {
  moduleId?: string(name='moduleId'),
  requestId?: string(name='requestId'),
}

model CloneModuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CloneModuleResponseBody(name='body'),
}

async function cloneModule(request: CloneModuleRequest): CloneModuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return cloneModuleWithOptions(request, headers, runtime);
}

async function cloneModuleWithOptions(request: CloneModuleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CloneModuleResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.moduleId)) {
    body['moduleId'] = request.moduleId;
  }
  if (!Util.isUnset(request.moduleSource)) {
    body['moduleSource'] = request.moduleSource;
  }
  if (!Util.isUnset(request.moduleVersion)) {
    body['moduleVersion'] = request.moduleVersion;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CloneModule',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/modules/operations/clone`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateAuthorizationRequest {
  clientToken?: string(name='clientToken'),
  dueTime?: string(name='dueTime'),
  moduleId?: string(name='moduleId'),
  moduleVersion?: string(name='moduleVersion'),
  name?: string(name='name'),
  uid?: long(name='uid'),
}

model CreateAuthorizationResponseBody = {
  authorizationId?: string(name='authorizationId'),
  requestId?: string(name='requestId'),
}

model CreateAuthorizationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAuthorizationResponseBody(name='body'),
}

async function createAuthorization(request: CreateAuthorizationRequest): CreateAuthorizationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createAuthorizationWithOptions(request, headers, runtime);
}

async function createAuthorizationWithOptions(request: CreateAuthorizationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateAuthorizationResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dueTime)) {
    body['dueTime'] = request.dueTime;
  }
  if (!Util.isUnset(request.moduleId)) {
    body['moduleId'] = request.moduleId;
  }
  if (!Util.isUnset(request.moduleVersion)) {
    body['moduleVersion'] = request.moduleVersion;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.uid)) {
    body['uid'] = request.uid;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateAuthorization',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/authorizations`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateGroupRequest {
  clientToken?: string(name='clientToken'),
  description?: string(name='description'),
  name?: string(name='name'),
  projectId?: string(name='projectId'),
}

model CreateGroupResponseBody = {
  id?: string(name='id'),
  requestId?: string(name='requestId'),
}

model CreateGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateGroupResponseBody(name='body'),
}

async function createGroup(request: CreateGroupRequest): CreateGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createGroupWithOptions(request, headers, runtime);
}

async function createGroupWithOptions(request: CreateGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.projectId)) {
    body['projectId'] = request.projectId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateGroup',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/group`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateJobRequest {
  clientToken?: string(name='clientToken'),
  description?: string(name='description'),
  subCommand?: string(name='subCommand'),
}

model CreateJobResponseBody = {
  jobId?: string(name='jobId'),
  requestId?: string(name='requestId'),
}

model CreateJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateJobResponseBody(name='body'),
}

async function createJob(taskId: string, request: CreateJobRequest): CreateJobResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createJobWithOptions(taskId, request, headers, runtime);
}

async function createJobWithOptions(taskId: string, request: CreateJobRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateJobResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.subCommand)) {
    body['subCommand'] = request.subCommand;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateJob',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/tasks/${OpenApiUtil.getEncodeParam(taskId)}/jobs`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateModuleRequest {
  clientToken?: string(name='clientToken'),
  description?: string(name='description'),
  name?: string(name='name'),
  source?: string(name='source'),
  sourcePath?: string(name='sourcePath'),
  statePath?: string(name='statePath'),
  versionStrategy?: string(name='versionStrategy'),
}

model CreateModuleResponseBody = {
  moduleId?: string(name='moduleId'),
  requestId?: string(name='requestId'),
}

model CreateModuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateModuleResponseBody(name='body'),
}

async function createModule(request: CreateModuleRequest): CreateModuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createModuleWithOptions(request, headers, runtime);
}

async function createModuleWithOptions(request: CreateModuleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateModuleResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.source)) {
    body['source'] = request.source;
  }
  if (!Util.isUnset(request.sourcePath)) {
    body['sourcePath'] = request.sourcePath;
  }
  if (!Util.isUnset(request.statePath)) {
    body['statePath'] = request.statePath;
  }
  if (!Util.isUnset(request.versionStrategy)) {
    body['versionStrategy'] = request.versionStrategy;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateModule',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/modules`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateModuleMarketRequest {
  clientToken?: string(name='clientToken'),
  codeUrl?: string(name='codeUrl'),
  description?: string(name='description'),
  moduleDetail?: string(name='moduleDetail'),
  moduleId?: string(name='moduleId'),
  moduleVersion?: string(name='moduleVersion'),
  name?: string(name='name'),
}

model CreateModuleMarketResponseBody = {
  moduleMarketId?: string(name='moduleMarketId'),
  requestId?: string(name='requestId'),
}

model CreateModuleMarketResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateModuleMarketResponseBody(name='body'),
}

async function createModuleMarket(request: CreateModuleMarketRequest): CreateModuleMarketResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createModuleMarketWithOptions(request, headers, runtime);
}

async function createModuleMarketWithOptions(request: CreateModuleMarketRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateModuleMarketResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.codeUrl)) {
    body['codeUrl'] = request.codeUrl;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.moduleDetail)) {
    body['moduleDetail'] = request.moduleDetail;
  }
  if (!Util.isUnset(request.moduleId)) {
    body['moduleId'] = request.moduleId;
  }
  if (!Util.isUnset(request.moduleVersion)) {
    body['moduleVersion'] = request.moduleVersion;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateModuleMarket',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/moduleMarkets`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateModuleVersionRequest {
  clientToken?: string(name='clientToken'),
  description?: string(name='description'),
  name?: string(name='name'),
}

model CreateModuleVersionResponseBody = {
  moduleVersion?: string(name='moduleVersion'),
  requestId?: string(name='requestId'),
}

model CreateModuleVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateModuleVersionResponseBody(name='body'),
}

async function createModuleVersion(moduleId: string, request: CreateModuleVersionRequest): CreateModuleVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createModuleVersionWithOptions(moduleId, request, headers, runtime);
}

async function createModuleVersionWithOptions(moduleId: string, request: CreateModuleVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateModuleVersionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateModuleVersion',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/modules/${OpenApiUtil.getEncodeParam(moduleId)}/versions`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateParameterSetRequest {
  clientToken?: string(name='clientToken'),
  description?: string(name='description'),
  name?: string(name='name'),
  parameters?: [ 
    {
      name?: string(name='name'),
      type?: string(name='type'),
      value?: string(name='value'),
    }
  ](name='parameters'),
}

model CreateParameterSetResponseBody = {
  parameterSetId?: string(name='parameterSetId'),
  requestId?: string(name='requestId'),
}

model CreateParameterSetResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateParameterSetResponseBody(name='body'),
}

async function createParameterSet(request: CreateParameterSetRequest): CreateParameterSetResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createParameterSetWithOptions(request, headers, runtime);
}

async function createParameterSetWithOptions(request: CreateParameterSetRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateParameterSetResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.parameters)) {
    body['parameters'] = request.parameters;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateParameterSet',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/parameterSets`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateProjectRequest {
  clientToken?: string(name='clientToken'),
  description?: string(name='description'),
  name?: string(name='name'),
}

model CreateProjectResponseBody = {
  id?: string(name='id'),
  requestId?: string(name='requestId'),
}

model CreateProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateProjectResponseBody(name='body'),
}

async function createProject(request: CreateProjectRequest): CreateProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createProjectWithOptions(request, headers, runtime);
}

async function createProjectWithOptions(request: CreateProjectRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateProjectResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateProject',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/project`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateProjectBuildRequest {
  clientToken?: string(name='clientToken'),
  projectBuildAction?: string(name='projectBuildAction'),
  taskIds?: [ string ](name='taskIds'),
  taskPolicies?: [ 
    {
      destroyAfterExecution?: boolean(name='destroyAfterExecution'),
      priority?: long(name='priority'),
      taskId?: string(name='taskId'),
    }
  ](name='taskPolicies'),
}

model CreateProjectBuildResponseBody = {
  id?: string(name='id'),
  requestId?: string(name='requestId'),
}

model CreateProjectBuildResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateProjectBuildResponseBody(name='body'),
}

async function createProjectBuild(projectId: string, request: CreateProjectBuildRequest): CreateProjectBuildResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createProjectBuildWithOptions(projectId, request, headers, runtime);
}

async function createProjectBuildWithOptions(projectId: string, request: CreateProjectBuildRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateProjectBuildResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.projectBuildAction)) {
    body['projectBuildAction'] = request.projectBuildAction;
  }
  if (!Util.isUnset(request.taskIds)) {
    body['taskIds'] = request.taskIds;
  }
  if (!Util.isUnset(request.taskPolicies)) {
    body['taskPolicies'] = request.taskPolicies;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateProjectBuild',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/project/${OpenApiUtil.getEncodeParam(projectId)}/build`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateRabbitmqPublisherRequest {
  clientToken?: string(name='clientToken'),
  description?: string(name='description'),
  exchangeName?: string(name='exchangeName'),
  exchangeType?: string(name='exchangeType'),
  hostName?: string(name='hostName'),
  name?: string(name='name'),
  password?: string(name='password'),
  port?: long(name='port'),
  userName?: string(name='userName'),
  virtualHost?: string(name='virtualHost'),
}

model CreateRabbitmqPublisherResponseBody = {
  publisherId?: string(name='publisherId'),
  requestId?: string(name='requestId'),
}

model CreateRabbitmqPublisherResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRabbitmqPublisherResponseBody(name='body'),
}

async function createRabbitmqPublisher(request: CreateRabbitmqPublisherRequest): CreateRabbitmqPublisherResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createRabbitmqPublisherWithOptions(request, headers, runtime);
}

async function createRabbitmqPublisherWithOptions(request: CreateRabbitmqPublisherRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateRabbitmqPublisherResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.exchangeName)) {
    body['exchangeName'] = request.exchangeName;
  }
  if (!Util.isUnset(request.exchangeType)) {
    body['exchangeType'] = request.exchangeType;
  }
  if (!Util.isUnset(request.hostName)) {
    body['hostName'] = request.hostName;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.password)) {
    body['password'] = request.password;
  }
  if (!Util.isUnset(request.port)) {
    body['port'] = request.port;
  }
  if (!Util.isUnset(request.userName)) {
    body['userName'] = request.userName;
  }
  if (!Util.isUnset(request.virtualHost)) {
    body['virtualHost'] = request.virtualHost;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateRabbitmqPublisher',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/publishers`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateResourceExportTaskRequest {
  clientToken?: string(name='clientToken'),
  description?: string(name='description'),
  excludeRules?: [ 
    {
      key?: string(name='key'),
      values?: [ string ](name='values'),
    }
  ](name='excludeRules'),
  exportToModule?: {
    source?: string(name='source'),
    sourcePath?: string(name='sourcePath'),
    statePath?: string(name='statePath'),
  }(name='exportToModule'),
  includeRules?: [ 
    {
      key?: string(name='key'),
      values?: [ string ](name='values'),
    }
  ](name='includeRules'),
  name?: string(name='name'),
  ramRole?: string(name='ramRole'),
  terraformVersion?: string(name='terraformVersion'),
  triggerStrategy?: string(name='triggerStrategy'),
  variables?: [ 
    {
      properties?: [ string ](name='properties'),
      resourceType?: string(name='resourceType'),
    }
  ](name='variables'),
}

model CreateResourceExportTaskResponseBody = {
  exportTaskId?: string(name='exportTaskId'),
  exportVersion?: string(name='exportVersion'),
  requestId?: string(name='requestId'),
}

model CreateResourceExportTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateResourceExportTaskResponseBody(name='body'),
}

async function createResourceExportTask(request: CreateResourceExportTaskRequest): CreateResourceExportTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createResourceExportTaskWithOptions(request, headers, runtime);
}

async function createResourceExportTaskWithOptions(request: CreateResourceExportTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateResourceExportTaskResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.excludeRules)) {
    body['excludeRules'] = request.excludeRules;
  }
  if (!Util.isUnset(request.exportToModule)) {
    body['exportToModule'] = request.exportToModule;
  }
  if (!Util.isUnset(request.includeRules)) {
    body['includeRules'] = request.includeRules;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.ramRole)) {
    body['ramRole'] = request.ramRole;
  }
  if (!Util.isUnset(request.terraformVersion)) {
    body['terraformVersion'] = request.terraformVersion;
  }
  if (!Util.isUnset(request.triggerStrategy)) {
    body['triggerStrategy'] = request.triggerStrategy;
  }
  if (!Util.isUnset(request.variables)) {
    body['variables'] = request.variables;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateResourceExportTask',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/exportTasks`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateTaskRequest {
  autoApply?: boolean(name='autoApply'),
  clientToken?: string(name='clientToken'),
  groupInfo?: {
    groupId?: string(name='groupId'),
    projectId?: string(name='projectId'),
  }(name='groupInfo'),
  moduleId?: string(name='moduleId'),
  moduleVersion?: string(name='moduleVersion'),
  name?: string(name='name'),
  parameters?: map[string]string(name='parameters'),
  protectionStrategy?: [ string ](name='protectionStrategy'),
  ramRole?: string(name='ramRole'),
  terraformVersion?: string(name='terraformVersion'),
  triggerStrategy?: string(name='triggerStrategy'),
}

model CreateTaskResponseBody = {
  requestId?: string(name='requestId'),
  taskId?: string(name='taskId'),
}

model CreateTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateTaskResponseBody(name='body'),
}

async function createTask(request: CreateTaskRequest): CreateTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createTaskWithOptions(request, headers, runtime);
}

async function createTaskWithOptions(request: CreateTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateTaskResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.autoApply)) {
    body['autoApply'] = request.autoApply;
  }
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.groupInfo)) {
    body['groupInfo'] = request.groupInfo;
  }
  if (!Util.isUnset(request.moduleId)) {
    body['moduleId'] = request.moduleId;
  }
  if (!Util.isUnset(request.moduleVersion)) {
    body['moduleVersion'] = request.moduleVersion;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.parameters)) {
    body['parameters'] = request.parameters;
  }
  if (!Util.isUnset(request.protectionStrategy)) {
    body['protectionStrategy'] = request.protectionStrategy;
  }
  if (!Util.isUnset(request.ramRole)) {
    body['ramRole'] = request.ramRole;
  }
  if (!Util.isUnset(request.terraformVersion)) {
    body['terraformVersion'] = request.terraformVersion;
  }
  if (!Util.isUnset(request.triggerStrategy)) {
    body['triggerStrategy'] = request.triggerStrategy;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateTask',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/tasks`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteAuthorizationResponseBody = {
  requestId?: string(name='requestId'),
}

model DeleteAuthorizationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAuthorizationResponseBody(name='body'),
}

async function deleteAuthorization(authorizationId: string): DeleteAuthorizationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteAuthorizationWithOptions(authorizationId, headers, runtime);
}

async function deleteAuthorizationWithOptions(authorizationId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteAuthorizationResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteAuthorization',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/authorizations/${OpenApiUtil.getEncodeParam(authorizationId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteGroupResponseBody = {
  requestId?: string(name='requestId'),
}

model DeleteGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteGroupResponseBody(name='body'),
}

async function deleteGroup(id: string): DeleteGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteGroupWithOptions(id, headers, runtime);
}

async function deleteGroupWithOptions(id: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteGroupResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteGroup',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/group/${OpenApiUtil.getEncodeParam(id)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteModuleResponseBody = {
  requestId?: string(name='requestId'),
}

model DeleteModuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteModuleResponseBody(name='body'),
}

async function deleteModule(moduleId: string): DeleteModuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteModuleWithOptions(moduleId, headers, runtime);
}

async function deleteModuleWithOptions(moduleId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteModuleResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteModule',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/modules/${OpenApiUtil.getEncodeParam(moduleId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteParameterSetResponseBody = {
  requestId?: string(name='requestId'),
}

model DeleteParameterSetResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteParameterSetResponseBody(name='body'),
}

async function deleteParameterSet(parameterSetId: string): DeleteParameterSetResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteParameterSetWithOptions(parameterSetId, headers, runtime);
}

async function deleteParameterSetWithOptions(parameterSetId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteParameterSetResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteParameterSet',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/parameterSets/${OpenApiUtil.getEncodeParam(parameterSetId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteProjectResponseBody = {
  requestId?: string(name='requestId'),
}

model DeleteProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteProjectResponseBody(name='body'),
}

async function deleteProject(id: string): DeleteProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteProjectWithOptions(id, headers, runtime);
}

async function deleteProjectWithOptions(id: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteProjectResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteProject',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/project/${OpenApiUtil.getEncodeParam(id)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteRabbitmqPublisherResponseBody = {
  requestId?: string(name='requestId'),
}

model DeleteRabbitmqPublisherResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteRabbitmqPublisherResponseBody(name='body'),
}

async function deleteRabbitmqPublisher(publisherId: string): DeleteRabbitmqPublisherResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteRabbitmqPublisherWithOptions(publisherId, headers, runtime);
}

async function deleteRabbitmqPublisherWithOptions(publisherId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteRabbitmqPublisherResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteRabbitmqPublisher',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/publishers/${OpenApiUtil.getEncodeParam(publisherId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteResourceExportTaskResponseBody = {
  requestId?: string(name='requestId'),
}

model DeleteResourceExportTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteResourceExportTaskResponseBody(name='body'),
}

async function deleteResourceExportTask(exportTaskId: string): DeleteResourceExportTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteResourceExportTaskWithOptions(exportTaskId, headers, runtime);
}

async function deleteResourceExportTaskWithOptions(exportTaskId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteResourceExportTaskResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteResourceExportTask',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/exportTasks/${OpenApiUtil.getEncodeParam(exportTaskId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteResourceLinkRequest {
  productCode?: string(name='productCode'),
  resourceTypeCode?: string(name='resourceTypeCode'),
}

model DeleteResourceLinkResponseBody = {
  requestId?: string(name='requestId'),
}

model DeleteResourceLinkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteResourceLinkResponseBody(name='body'),
}

async function deleteResourceLink(request: DeleteResourceLinkRequest): DeleteResourceLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteResourceLinkWithOptions(request, headers, runtime);
}

async function deleteResourceLinkWithOptions(request: DeleteResourceLinkRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteResourceLinkResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.productCode)) {
    query['productCode'] = request.productCode;
  }
  if (!Util.isUnset(request.resourceTypeCode)) {
    query['resourceTypeCode'] = request.resourceTypeCode;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteResourceLink',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/resources`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteTaskResponseBody = {
  requestId?: string(name='requestId'),
}

model DeleteTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteTaskResponseBody(name='body'),
}

async function deleteTask(taskId: string): DeleteTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteTaskWithOptions(taskId, headers, runtime);
}

async function deleteTaskWithOptions(taskId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteTaskResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteTask',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/tasks/${OpenApiUtil.getEncodeParam(taskId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DetachRabbitmqPublisherRequest {
  taskId?: string(name='taskId'),
}

model DetachRabbitmqPublisherResponseBody = {
  requestId?: string(name='requestId'),
}

model DetachRabbitmqPublisherResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetachRabbitmqPublisherResponseBody(name='body'),
}

async function detachRabbitmqPublisher(publisherId: string, request: DetachRabbitmqPublisherRequest): DetachRabbitmqPublisherResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return detachRabbitmqPublisherWithOptions(publisherId, request, headers, runtime);
}

async function detachRabbitmqPublisherWithOptions(publisherId: string, request: DetachRabbitmqPublisherRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DetachRabbitmqPublisherResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.taskId)) {
    body['taskId'] = request.taskId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DetachRabbitmqPublisher',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/publishers/${OpenApiUtil.getEncodeParam(publisherId)}/detach`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DissociateParameterSetRequest {
  parameterSetIds?: [ string ](name='parameterSetIds'),
  resourceId?: string(name='resourceId'),
  resourceType?: string(name='resourceType'),
}

model DissociateParameterSetResponseBody = {
  requestId?: string(name='requestId'),
}

model DissociateParameterSetResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DissociateParameterSetResponseBody(name='body'),
}

async function dissociateParameterSet(request: DissociateParameterSetRequest): DissociateParameterSetResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return dissociateParameterSetWithOptions(request, headers, runtime);
}

async function dissociateParameterSetWithOptions(request: DissociateParameterSetRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DissociateParameterSetResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.parameterSetIds)) {
    body['parameterSetIds'] = request.parameterSetIds;
  }
  if (!Util.isUnset(request.resourceId)) {
    body['resourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    body['resourceType'] = request.resourceType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DissociateParameterSet',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/parameterSets/operations/dissociate`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DissociateTaskGroupRequest {
  taskIds?: [ string ](name='taskIds'),
}

model DissociateTaskGroupResponseBody = {
  requestId?: string(name='requestId'),
}

model DissociateTaskGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DissociateTaskGroupResponseBody(name='body'),
}

async function dissociateTaskGroup(projectId: string, groupId: string, request: DissociateTaskGroupRequest): DissociateTaskGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return dissociateTaskGroupWithOptions(projectId, groupId, request, headers, runtime);
}

async function dissociateTaskGroupWithOptions(projectId: string, groupId: string, request: DissociateTaskGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DissociateTaskGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.taskIds)) {
    body['taskIds'] = request.taskIds;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DissociateTaskGroup',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/project/${OpenApiUtil.getEncodeParam(projectId)}/groups/${OpenApiUtil.getEncodeParam(groupId)}/dissociate`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ExecuteResourceExportTaskRequest {
  clientToken?: string(name='clientToken'),
  ramRole?: string(name='ramRole'),
}

model ExecuteResourceExportTaskResponseBody = {
  exportTaskId?: string(name='exportTaskId'),
  exportVersion?: string(name='exportVersion'),
  requestId?: string(name='requestId'),
}

model ExecuteResourceExportTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ExecuteResourceExportTaskResponseBody(name='body'),
}

async function executeResourceExportTask(exportTaskId: string, request: ExecuteResourceExportTaskRequest): ExecuteResourceExportTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return executeResourceExportTaskWithOptions(exportTaskId, request, headers, runtime);
}

async function executeResourceExportTaskWithOptions(exportTaskId: string, request: ExecuteResourceExportTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ExecuteResourceExportTaskResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ramRole)) {
    body['ramRole'] = request.ramRole;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ExecuteResourceExportTask',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/exportTasks/execute/${OpenApiUtil.getEncodeParam(exportTaskId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetGroupResponseBody = {
  group?: {
    createTime?: string(name='createTime'),
    description?: string(name='description'),
    id?: string(name='id'),
    name?: string(name='name'),
    projectId?: string(name='projectId'),
    taskCnt?: long(name='taskCnt'),
  }(name='group'),
  requestId?: string(name='requestId'),
}

model GetGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetGroupResponseBody(name='body'),
}

async function getGroup(id: string): GetGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getGroupWithOptions(id, headers, runtime);
}

async function getGroupWithOptions(id: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetGroupResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetGroup',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/group/${OpenApiUtil.getEncodeParam(id)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetJobResponseBody = {
  job?: {
    config?: {
      autoApply?: boolean(name='autoApply'),
      isDestroy?: boolean(name='isDestroy'),
      moduleVersion?: string(name='moduleVersion'),
      resourcesChanged?: string(name='resourcesChanged'),
    }(name='config'),
    createTime?: string(name='createTime'),
    description?: string(name='description'),
    jobId?: string(name='jobId'),
    output?: string(name='output'),
    parameters?: map[string]string(name='parameters'),
    runtimeType?: string(name='runtimeType'),
    status?: string(name='status'),
    statusDetail?: map[string]JobStatusDetailValue(name='statusDetail'),
    taskId?: string(name='taskId'),
  }(name='job'),
  requestId?: string(name='requestId'),
}

model GetJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetJobResponseBody(name='body'),
}

async function getJob(taskId: string, jobId: string): GetJobResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getJobWithOptions(taskId, jobId, headers, runtime);
}

async function getJobWithOptions(taskId: string, jobId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetJobResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetJob',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/tasks/${OpenApiUtil.getEncodeParam(taskId)}/jobs/${OpenApiUtil.getEncodeParam(jobId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetModuleResponseBody = {
  module?: {
    createTime?: string(name='createTime'),
    description?: string(name='description'),
    latestVersion?: string(name='latestVersion'),
    moduleId?: string(name='moduleId'),
    name?: string(name='name'),
    outputPath?: string(name='outputPath'),
    source?: string(name='source'),
    sourcePath?: string(name='sourcePath'),
    statePath?: string(name='statePath'),
    status?: string(name='status'),
    versionStrategy?: string(name='versionStrategy'),
  }(name='module'),
  requestId?: string(name='requestId'),
}

model GetModuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetModuleResponseBody(name='body'),
}

async function getModule(moduleId: string): GetModuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getModuleWithOptions(moduleId, headers, runtime);
}

async function getModuleWithOptions(moduleId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetModuleResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetModule',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/modules/${OpenApiUtil.getEncodeParam(moduleId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetModuleMarketResponseBody = {
  moduleMarket?: {
    description?: string(name='description'),
    message?: string(name='message'),
    moduleDetail?: string(name='moduleDetail'),
    moduleId?: string(name='moduleId'),
    moduleMarketId?: string(name='moduleMarketId'),
    moduleVersion?: string(name='moduleVersion'),
    name?: string(name='name'),
    status?: string(name='status'),
  }(name='moduleMarket'),
  requestId?: string(name='requestId'),
}

model GetModuleMarketResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetModuleMarketResponseBody(name='body'),
}

async function getModuleMarket(moduleMarketId: string): GetModuleMarketResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getModuleMarketWithOptions(moduleMarketId, headers, runtime);
}

async function getModuleMarketWithOptions(moduleMarketId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetModuleMarketResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetModuleMarket',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/moduleMarkets/${OpenApiUtil.getEncodeParam(moduleMarketId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetModuleVersionResponseBody = {
  requestId?: string(name='requestId'),
  version?: {
    createTime?: string(name='createTime'),
    description?: string(name='description'),
    moduleId?: string(name='moduleId'),
    moduleVersion?: string(name='moduleVersion'),
    name?: string(name='name'),
    source?: string(name='source'),
    sourcePath?: string(name='sourcePath'),
    statePath?: string(name='statePath'),
    terraformContext?: map[string]any(name='terraformContext'),
    versionStrategy?: string(name='versionStrategy'),
  }(name='version'),
}

model GetModuleVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetModuleVersionResponseBody(name='body'),
}

async function getModuleVersion(moduleId: string, moduleVersion: string): GetModuleVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getModuleVersionWithOptions(moduleId, moduleVersion, headers, runtime);
}

async function getModuleVersionWithOptions(moduleId: string, moduleVersion: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetModuleVersionResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetModuleVersion',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/modules/${OpenApiUtil.getEncodeParam(moduleId)}/versions/${OpenApiUtil.getEncodeParam(moduleVersion)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetParameterSetResponseBody = {
  parameterSet?: {
    createTime?: string(name='createTime'),
    description?: string(name='description'),
    name?: string(name='name'),
    parameterSetId?: string(name='parameterSetId'),
    parameters?: [ 
      {
        name?: string(name='name'),
        type?: string(name='type'),
        value?: any(name='value'),
      }
    ](name='parameters'),
    relationList?: [ 
      {
        createTime?: string(name='createTime'),
        resourceId?: string(name='resourceId'),
        resourceType?: string(name='resourceType'),
      }
    ](name='relationList'),
  }(name='parameterSet'),
  requestId?: string(name='requestId'),
}

model GetParameterSetResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetParameterSetResponseBody(name='body'),
}

async function getParameterSet(parameterSetId: string): GetParameterSetResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getParameterSetWithOptions(parameterSetId, headers, runtime);
}

async function getParameterSetWithOptions(parameterSetId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetParameterSetResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetParameterSet',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/parameterSets/${OpenApiUtil.getEncodeParam(parameterSetId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetProjectResponseBody = {
  project?: {
    createTime?: string(name='createTime'),
    description?: string(name='description'),
    id?: string(name='id'),
    name?: string(name='name'),
    taskCnt?: long(name='taskCnt'),
  }(name='project'),
  requestId?: string(name='requestId'),
}

model GetProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetProjectResponseBody(name='body'),
}

async function getProject(id: string): GetProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getProjectWithOptions(id, headers, runtime);
}

async function getProjectWithOptions(id: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetProjectResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetProject',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/project/${OpenApiUtil.getEncodeParam(id)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetProjectBuildConfigRequest {
  projectBuildId?: string(name='projectBuildId'),
}

model GetProjectBuildConfigResponseBody = {
  projectBuildConfig?: {
    taskPolicies?: map[string]ProjectBuildConfigTaskPoliciesValue(name='taskPolicies'),
  }(name='projectBuildConfig'),
  requestId?: string(name='requestId'),
}

model GetProjectBuildConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetProjectBuildConfigResponseBody(name='body'),
}

async function getProjectBuildConfig(projectId: string, request: GetProjectBuildConfigRequest): GetProjectBuildConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getProjectBuildConfigWithOptions(projectId, request, headers, runtime);
}

async function getProjectBuildConfigWithOptions(projectId: string, request: GetProjectBuildConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetProjectBuildConfigResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.projectBuildId)) {
    query['projectBuildId'] = request.projectBuildId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetProjectBuildConfig',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/project/${OpenApiUtil.getEncodeParam(projectId)}/buildConfig`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetProjectBuildContextResponseBody = {
  projectBuild?: {
    endTime?: string(name='endTime'),
    failCnt?: long(name='failCnt'),
    jobList?: [ 
      {
        isDeleted?: long(name='isDeleted'),
        jobId?: string(name='jobId'),
        moduleId?: string(name='moduleId'),
        moduleVersion?: string(name='moduleVersion'),
        name?: string(name='name'),
        status?: string(name='status'),
        taskId?: string(name='taskId'),
      }
    ](name='jobList'),
    jobTotalCnt?: long(name='jobTotalCnt'),
    projectBuildId?: string(name='projectBuildId'),
    projectId?: string(name='projectId'),
    resourceCnt?: long(name='resourceCnt'),
    resourceList?: [ 
      {
        info?: map[string]string(name='info'),
        resourceCnt?: long(name='resourceCnt'),
        resourceType?: string(name='resourceType'),
      }
    ](name='resourceList'),
    resourceTypeCnt?: long(name='resourceTypeCnt'),
    status?: string(name='status'),
    successCnt?: long(name='successCnt'),
  }(name='ProjectBuild'),
  requestId?: string(name='requestId'),
}

model GetProjectBuildContextResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetProjectBuildContextResponseBody(name='body'),
}

async function getProjectBuildContext(projectId: string, projectBuildId: string): GetProjectBuildContextResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getProjectBuildContextWithOptions(projectId, projectBuildId, headers, runtime);
}

async function getProjectBuildContextWithOptions(projectId: string, projectBuildId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetProjectBuildContextResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetProjectBuildContext',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/project/${OpenApiUtil.getEncodeParam(projectId)}/build/${OpenApiUtil.getEncodeParam(projectBuildId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetProjectJobSummaryResponseBody = {
  jobSummary?: {
    detail?: [ 
      {
        failCnt?: long(name='failCnt'),
        runningCnt?: long(name='runningCnt'),
        successCnt?: long(name='successCnt'),
        taskId?: string(name='taskId'),
        total?: long(name='total'),
      }
    ](name='detail'),
    failCnt?: long(name='failCnt'),
    runningCnt?: long(name='runningCnt'),
    successCnt?: long(name='successCnt'),
    total?: long(name='total'),
  }(name='jobSummary'),
  requestId?: string(name='requestId'),
}

model GetProjectJobSummaryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetProjectJobSummaryResponseBody(name='body'),
}

async function getProjectJobSummary(projectId: string): GetProjectJobSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getProjectJobSummaryWithOptions(projectId, headers, runtime);
}

async function getProjectJobSummaryWithOptions(projectId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetProjectJobSummaryResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetProjectJobSummary',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/project/${OpenApiUtil.getEncodeParam(projectId)}/job/statistics`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetProjectResourceSummaryResponseBody = {
  requestId?: string(name='requestId'),
  resourceSummary?: {
    detail?: [ 
      {
        resourceCnt?: long(name='resourceCnt'),
        resourceType?: string(name='resourceType'),
        taskIds?: [ string ](name='taskIds'),
      }
    ](name='detail'),
    resourceCnt?: long(name='resourceCnt'),
    resourceTypeCnt?: long(name='resourceTypeCnt'),
  }(name='resourceSummary'),
}

model GetProjectResourceSummaryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetProjectResourceSummaryResponseBody(name='body'),
}

async function getProjectResourceSummary(projectId: string): GetProjectResourceSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getProjectResourceSummaryWithOptions(projectId, headers, runtime);
}

async function getProjectResourceSummaryWithOptions(projectId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetProjectResourceSummaryResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetProjectResourceSummary',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/project/${OpenApiUtil.getEncodeParam(projectId)}/resource/statistics`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetRabbitmqPublisherResponseBody = {
  publisher?: {
    createTime?: string(name='createTime'),
    description?: string(name='description'),
    exchangeName?: string(name='exchangeName'),
    exchangeType?: string(name='exchangeType'),
    hostName?: string(name='hostName'),
    name?: string(name='name'),
    port?: long(name='port'),
    publisherId?: string(name='publisherId'),
    taskIds?: [ string ](name='taskIds'),
    userName?: string(name='userName'),
    virtualHost?: string(name='virtualHost'),
  }(name='publisher'),
  requestId?: string(name='requestId'),
}

model GetRabbitmqPublisherResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRabbitmqPublisherResponseBody(name='body'),
}

async function getRabbitmqPublisher(publisherId: string): GetRabbitmqPublisherResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getRabbitmqPublisherWithOptions(publisherId, headers, runtime);
}

async function getRabbitmqPublisherWithOptions(publisherId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetRabbitmqPublisherResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetRabbitmqPublisher',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/publishers/${OpenApiUtil.getEncodeParam(publisherId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetResourceExportTaskRequest {
  exportVersion?: string(name='exportVersion'),
}

model GetResourceExportTaskResponseBody = {
  requestId?: string(name='requestId'),
  task?: {
    createTime?: string(name='createTime'),
    description?: string(name='description'),
    excludeRules?: [ 
      {
        key?: string(name='key'),
        values?: [ string ](name='values'),
      }
    ](name='excludeRules'),
    exportTaskId?: string(name='exportTaskId'),
    exportToModule?: {
      source?: string(name='source'),
      sourcePath?: string(name='sourcePath'),
      statePath?: string(name='statePath'),
    }(name='exportToModule'),
    exportVersion?: string(name='exportVersion'),
    failedReason?: string(name='failedReason'),
    includeRules?: [ 
      {
        key?: string(name='key'),
        values?: [ string ](name='values'),
      }
    ](name='includeRules'),
    modules?: [ 
      {
        source?: string(name='source'),
        sourcePath?: string(name='sourcePath'),
        version?: string(name='version'),
      }
    ](name='modules'),
    name?: string(name='name'),
    ramRole?: string(name='ramRole'),
    status?: string(name='status'),
    taskOutputPath?: string(name='taskOutputPath'),
    terraformVersion?: string(name='terraformVersion'),
    triggerStrategy?: string(name='triggerStrategy'),
    variables?: [ 
      {
        properties?: [ string ](name='properties'),
        resourceType?: string(name='resourceType'),
      }
    ](name='variables'),
  }(name='task'),
}

model GetResourceExportTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetResourceExportTaskResponseBody(name='body'),
}

async function getResourceExportTask(exportTaskId: string, request: GetResourceExportTaskRequest): GetResourceExportTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getResourceExportTaskWithOptions(exportTaskId, request, headers, runtime);
}

async function getResourceExportTaskWithOptions(exportTaskId: string, request: GetResourceExportTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetResourceExportTaskResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.exportVersion)) {
    query['exportVersion'] = request.exportVersion;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetResourceExportTask',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/exportTasks/${OpenApiUtil.getEncodeParam(exportTaskId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetResourceLinkRequest {
  productCode?: string(name='productCode'),
  resourceTypeCode?: string(name='resourceTypeCode'),
}

model GetResourceLinkResponseBody = {
  link?: string(name='link'),
  requestId?: string(name='requestId'),
}

model GetResourceLinkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetResourceLinkResponseBody(name='body'),
}

async function getResourceLink(request: GetResourceLinkRequest): GetResourceLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getResourceLinkWithOptions(request, headers, runtime);
}

async function getResourceLinkWithOptions(request: GetResourceLinkRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetResourceLinkResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.productCode)) {
    query['productCode'] = request.productCode;
  }
  if (!Util.isUnset(request.resourceTypeCode)) {
    query['resourceTypeCode'] = request.resourceTypeCode;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetResourceLink',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/resources`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetTaskResponseBody = {
  requestId?: string(name='requestId'),
  task?: {
    autoApply?: boolean(name='autoApply'),
    createTime?: string(name='createTime'),
    currentJobId?: string(name='currentJobId'),
    groupInfo?: {
      groupId?: string(name='groupId'),
      groupName?: string(name='groupName'),
      projectId?: string(name='projectId'),
      projectName?: string(name='projectName'),
    }(name='groupInfo'),
    meta?: map[string]string(name='meta'),
    moduleId?: string(name='moduleId'),
    moduleVersion?: string(name='moduleVersion'),
    name?: string(name='name'),
    parameters?: map[string]string(name='parameters'),
    protectionStrategy?: [ string ](name='protectionStrategy'),
    ramRole?: string(name='ramRole'),
    status?: string(name='status'),
    taskId?: string(name='taskId'),
    taskOutputPath?: string(name='taskOutputPath'),
    terraformVersion?: string(name='terraformVersion'),
    triggerStrategy?: string(name='triggerStrategy'),
  }(name='task'),
}

model GetTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTaskResponseBody(name='body'),
}

async function getTask(taskId: string): GetTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTaskWithOptions(taskId, headers, runtime);
}

async function getTaskWithOptions(taskId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetTaskResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetTask',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/tasks/${OpenApiUtil.getEncodeParam(taskId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetTaskContextResponseBody = {
  requestId?: string(name='requestId'),
  task?: {
    autoApply?: boolean(name='autoApply'),
    jobConfig?: {
      isDestroy?: boolean(name='isDestroy'),
      jobModuleVersion?: string(name='jobModuleVersion'),
      resourcesChanged?: string(name='resourcesChanged'),
    }(name='jobConfig'),
    jobDescription?: string(name='jobDescription'),
    jobGmtCreate?: string(name='jobGmtCreate'),
    jobId?: string(name='jobId'),
    jobStatus?: string(name='jobStatus'),
    moduleId?: string(name='moduleId'),
    modulePath?: string(name='modulePath'),
    moduleVersion?: string(name='moduleVersion'),
    parameters?: map[string]string(name='parameters'),
    ramRole?: string(name='ramRole'),
    resourceCount?: int32(name='resourceCount'),
    taskGmtCreate?: string(name='taskGmtCreate'),
    taskId?: string(name='taskId'),
    taskName?: string(name='taskName'),
    taskOutputPath?: string(name='taskOutputPath'),
    taskStatus?: string(name='taskStatus'),
    terraformVersion?: string(name='terraformVersion'),
    triggerStrategy?: string(name='triggerStrategy'),
  }(name='task'),
}

model GetTaskContextResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTaskContextResponseBody(name='body'),
}

async function getTaskContext(taskId: string): GetTaskContextResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTaskContextWithOptions(taskId, headers, runtime);
}

async function getTaskContextWithOptions(taskId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetTaskContextResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetTaskContext',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/tasks/${OpenApiUtil.getEncodeParam(taskId)}/context`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListAuthorizationsRequest {
  authorizationId?: string(name='authorizationId'),
  authorizationType?: string(name='authorizationType'),
  keyword?: string(name='keyword'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
}

model ListAuthorizationsResponseBody = {
  authorizations?: [ 
    {
      authorizationId?: string(name='authorizationId'),
      createTime?: string(name='createTime'),
      dueTime?: string(name='dueTime'),
      moduleId?: string(name='moduleId'),
      moduleVersion?: string(name='moduleVersion'),
      name?: string(name='name'),
      ownerUid?: long(name='ownerUid'),
      uid?: long(name='uid'),
    }
  ](name='authorizations'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  requestId?: string(name='requestId'),
  totalCount?: int32(name='totalCount'),
}

model ListAuthorizationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAuthorizationsResponseBody(name='body'),
}

async function listAuthorizations(request: ListAuthorizationsRequest): ListAuthorizationsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAuthorizationsWithOptions(request, headers, runtime);
}

async function listAuthorizationsWithOptions(request: ListAuthorizationsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAuthorizationsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.authorizationId)) {
    query['authorizationId'] = request.authorizationId;
  }
  if (!Util.isUnset(request.authorizationType)) {
    query['authorizationType'] = request.authorizationType;
  }
  if (!Util.isUnset(request.keyword)) {
    query['keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAuthorizations',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/authorizations`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListGroupRequest {
  pageNumber?: string(name='pageNumber'),
  pageSize?: string(name='pageSize'),
  projectId?: string(name='projectId'),
}

model ListGroupResponseBody = {
  count?: long(name='count'),
  groups?: [ 
    {
      createTime?: string(name='createTime'),
      description?: string(name='description'),
      id?: string(name='id'),
      isDefault?: boolean(name='isDefault'),
      name?: string(name='name'),
      projectId?: string(name='projectId'),
      taskCnt?: long(name='taskCnt'),
    }
  ](name='groups'),
  pageNumber?: long(name='pageNumber'),
  pageSize?: long(name='pageSize'),
  requestId?: string(name='requestId'),
}

model ListGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListGroupResponseBody(name='body'),
}

async function listGroup(request: ListGroupRequest): ListGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listGroupWithOptions(request, headers, runtime);
}

async function listGroupWithOptions(request: ListGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListGroupResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    query['projectId'] = request.projectId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListGroup',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/group`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListJobsRequest {
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  status?: string(name='status'),
}

model ListJobsResponseBody = {
  jobs?: [ 
    {
      config?: {
        moduleVersion?: string(name='moduleVersion'),
        resourcesChanged?: string(name='resourcesChanged'),
      }(name='config'),
      createTime?: string(name='createTime'),
      description?: string(name='description'),
      jobId?: string(name='jobId'),
      status?: string(name='status'),
      statusDetail?: map[string]JobsStatusDetailValue(name='statusDetail'),
      taskId?: string(name='taskId'),
    }
  ](name='jobs'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  requestId?: string(name='requestId'),
  totalCount?: int32(name='totalCount'),
}

model ListJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListJobsResponseBody(name='body'),
}

async function listJobs(taskId: string, request: ListJobsRequest): ListJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listJobsWithOptions(taskId, request, headers, runtime);
}

async function listJobsWithOptions(taskId: string, request: ListJobsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListJobsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.status)) {
    query['status'] = request.status;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListJobs',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/tasks/${OpenApiUtil.getEncodeParam(taskId)}/jobs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListModuleMarketsRequest {
  keyword?: string(name='keyword'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  status?: string(name='status'),
  type?: string(name='type'),
}

model ListModuleMarketsResponseBody = {
  moduleMarkets?: [ 
    {
      cloneCount?: int32(name='cloneCount'),
      codeUrl?: string(name='codeUrl'),
      config?: map[string]string(name='config'),
      description?: string(name='description'),
      message?: string(name='message'),
      moduleDetail?: string(name='moduleDetail'),
      moduleId?: string(name='moduleId'),
      moduleMarketId?: string(name='moduleMarketId'),
      moduleVersion?: string(name='moduleVersion'),
      name?: string(name='name'),
      relatedId?: long(name='relatedId'),
      status?: string(name='status'),
    }
  ](name='moduleMarkets'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  requestId?: string(name='requestId'),
  totalCount?: int32(name='totalCount'),
}

model ListModuleMarketsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListModuleMarketsResponseBody(name='body'),
}

async function listModuleMarkets(request: ListModuleMarketsRequest): ListModuleMarketsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listModuleMarketsWithOptions(request, headers, runtime);
}

async function listModuleMarketsWithOptions(request: ListModuleMarketsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListModuleMarketsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.keyword)) {
    query['keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.status)) {
    query['status'] = request.status;
  }
  if (!Util.isUnset(request.type)) {
    query['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListModuleMarkets',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/moduleMarkets`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListModuleVersionRequest {
  keyword?: string(name='keyword'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
}

model ListModuleVersionResponseBody = {
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  requestId?: string(name='requestId'),
  totalCount?: int32(name='totalCount'),
  versions?: [ 
    {
      createTime?: string(name='createTime'),
      description?: string(name='description'),
      moduleId?: string(name='moduleId'),
      moduleVersion?: string(name='moduleVersion'),
      name?: string(name='name'),
      sourcePath?: string(name='sourcePath'),
    }
  ](name='versions'),
}

model ListModuleVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListModuleVersionResponseBody(name='body'),
}

async function listModuleVersion(moduleId: string, request: ListModuleVersionRequest): ListModuleVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listModuleVersionWithOptions(moduleId, request, headers, runtime);
}

async function listModuleVersionWithOptions(moduleId: string, request: ListModuleVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListModuleVersionResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.keyword)) {
    query['keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListModuleVersion',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/modules/${OpenApiUtil.getEncodeParam(moduleId)}/versions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListModulesRequest {
  keyword?: string(name='keyword'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
}

model ListModulesResponseBody = {
  modules?: [ 
    {
      createTime?: string(name='createTime'),
      deletionProtection?: boolean(name='deletionProtection'),
      description?: string(name='description'),
      latestVersion?: string(name='latestVersion'),
      meta?: map[string]any(name='meta'),
      moduleId?: string(name='moduleId'),
      name?: string(name='name'),
      source?: string(name='source'),
      sourceConfig?: map[string]any(name='sourceConfig'),
      status?: string(name='status'),
    }
  ](name='modules'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  requestId?: string(name='requestId'),
  totalCount?: int32(name='totalCount'),
}

model ListModulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListModulesResponseBody(name='body'),
}

async function listModules(request: ListModulesRequest): ListModulesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listModulesWithOptions(request, headers, runtime);
}

async function listModulesWithOptions(request: ListModulesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListModulesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.keyword)) {
    query['keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListModules',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/modules`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListParameterSetRelationRequest {
  resourceId?: string(name='resourceId'),
  resourceType?: string(name='resourceType'),
}

model ListParameterSetRelationResponseBody = {
  parameterSets?: [ 
    {
      createTime?: string(name='createTime'),
      description?: string(name='description'),
      name?: string(name='name'),
      parameterSetId?: string(name='parameterSetId'),
      parameters?: map[string]string(name='parameters'),
    }
  ](name='parameterSets'),
  requestId?: string(name='requestId'),
  totalCount?: int32(name='totalCount'),
}

model ListParameterSetRelationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListParameterSetRelationResponseBody(name='body'),
}

async function listParameterSetRelation(request: ListParameterSetRelationRequest): ListParameterSetRelationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listParameterSetRelationWithOptions(request, headers, runtime);
}

async function listParameterSetRelationWithOptions(request: ListParameterSetRelationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListParameterSetRelationResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.resourceId)) {
    query['resourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['resourceType'] = request.resourceType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListParameterSetRelation',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/parameterSets/operations/relation`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListParameterSetsRequest {
  keyword?: string(name='keyword'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
}

model ListParameterSetsResponseBody = {
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  parameterSets?: [ 
    {
      createTime?: string(name='createTime'),
      description?: string(name='description'),
      name?: string(name='name'),
      parameterSetId?: string(name='parameterSetId'),
      parameters?: [ 
        {
          name?: string(name='name'),
          type?: string(name='type'),
          value?: any(name='value'),
        }
      ](name='parameters'),
      relationList?: [ 
        {
          createTime?: string(name='createTime'),
          resourceId?: string(name='resourceId'),
          resourceType?: string(name='resourceType'),
        }
      ](name='relationList'),
    }
  ](name='parameterSets'),
  requestId?: string(name='requestId'),
  totalCount?: int32(name='totalCount'),
}

model ListParameterSetsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListParameterSetsResponseBody(name='body'),
}

async function listParameterSets(request: ListParameterSetsRequest): ListParameterSetsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listParameterSetsWithOptions(request, headers, runtime);
}

async function listParameterSetsWithOptions(request: ListParameterSetsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListParameterSetsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.keyword)) {
    query['keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListParameterSets',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/parameterSets`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListProjectRequest {
  pageNumber?: string(name='pageNumber'),
  pageSize?: string(name='pageSize'),
}

model ListProjectResponseBody = {
  count?: long(name='count'),
  pageNumber?: long(name='pageNumber'),
  pageSize?: long(name='pageSize'),
  projects?: [ 
    {
      createTime?: string(name='createTime'),
      description?: string(name='description'),
      id?: string(name='id'),
      name?: string(name='name'),
      taskCnt?: long(name='taskCnt'),
    }
  ](name='projects'),
  requestId?: string(name='requestId'),
}

model ListProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListProjectResponseBody(name='body'),
}

async function listProject(request: ListProjectRequest): ListProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listProjectWithOptions(request, headers, runtime);
}

async function listProjectWithOptions(request: ListProjectRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListProjectResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListProject',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/project`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListProjectBuildsResponseBody = {
  projectBuilds?: [ 
    {
      createTime?: string(name='createTime'),
      projectBuildAction?: string(name='projectBuildAction'),
      projectBuildId?: string(name='projectBuildId'),
      projectBuildIndex?: long(name='projectBuildIndex'),
      projectId?: string(name='projectId'),
      status?: string(name='status'),
      timestamp?: long(name='timestamp'),
    }
  ](name='ProjectBuilds'),
  requestId?: string(name='requestId'),
  totalCount?: int32(name='totalCount'),
}

model ListProjectBuildsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListProjectBuildsResponseBody(name='body'),
}

async function listProjectBuilds(projectId: string): ListProjectBuildsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listProjectBuildsWithOptions(projectId, headers, runtime);
}

async function listProjectBuildsWithOptions(projectId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListProjectBuildsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListProjectBuilds',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/project/${OpenApiUtil.getEncodeParam(projectId)}/build`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListRabbitmqPublishersRequest {
  keyword?: string(name='keyword'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
}

model ListRabbitmqPublishersResponseBody = {
  authorizations?: [ 
    {
      createTime?: string(name='createTime'),
      description?: string(name='description'),
      exchangeName?: string(name='exchangeName'),
      exchangeType?: string(name='exchangeType'),
      hostName?: string(name='hostName'),
      name?: string(name='name'),
      port?: long(name='port'),
      publisherId?: string(name='publisherId'),
      userName?: string(name='userName'),
      virtualHost?: string(name='virtualHost'),
    }
  ](name='authorizations'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  requestId?: string(name='requestId'),
  totalCount?: int32(name='totalCount'),
}

model ListRabbitmqPublishersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRabbitmqPublishersResponseBody(name='body'),
}

async function listRabbitmqPublishers(request: ListRabbitmqPublishersRequest): ListRabbitmqPublishersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRabbitmqPublishersWithOptions(request, headers, runtime);
}

async function listRabbitmqPublishersWithOptions(request: ListRabbitmqPublishersRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRabbitmqPublishersResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.keyword)) {
    query['keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRabbitmqPublishers',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/publishers`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListRelationModulesResponseBody = {
  modules?: [ 
    {
      latestVersion?: string(name='latestVersion'),
      moduleId?: string(name='moduleId'),
      name?: string(name='name'),
    }
  ](name='modules'),
  requestId?: string(name='requestId'),
  totalCount?: int32(name='totalCount'),
}

model ListRelationModulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRelationModulesResponseBody(name='body'),
}

async function listRelationModules(type: string): ListRelationModulesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRelationModulesWithOptions(type, headers, runtime);
}

async function listRelationModulesWithOptions(type: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListRelationModulesResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListRelationModules',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/modules/relation/${OpenApiUtil.getEncodeParam(type)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListRelationTasksRequest {
  keyword?: string(name='keyword'),
  moduleId?: string(name='moduleId'),
  pageNumber?: long(name='pageNumber'),
  pageSize?: long(name='pageSize'),
  projectId?: string(name='projectId'),
}

model ListRelationTasksResponseBody = {
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  requestId?: string(name='requestId'),
  tasks?: [ 
    {
      createTime?: string(name='createTime'),
      moduleId?: string(name='moduleId'),
      moduleVersion?: string(name='moduleVersion'),
      name?: string(name='name'),
      status?: string(name='status'),
      taskId?: string(name='taskId'),
    }
  ](name='tasks'),
  totalCount?: long(name='totalCount'),
}

model ListRelationTasksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRelationTasksResponseBody(name='body'),
}

async function listRelationTasks(type: string, request: ListRelationTasksRequest): ListRelationTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRelationTasksWithOptions(type, request, headers, runtime);
}

async function listRelationTasksWithOptions(type: string, request: ListRelationTasksRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRelationTasksResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.keyword)) {
    query['keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.moduleId)) {
    query['moduleId'] = request.moduleId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    query['projectId'] = request.projectId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRelationTasks',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/tasks/relation/${OpenApiUtil.getEncodeParam(type)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListResourceExportTaskVersionsRequest {
  exportVersion?: string(name='exportVersion'),
  keyword?: string(name='keyword'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  status?: string(name='status'),
}

model ListResourceExportTaskVersionsResponseBody = {
  exportTasks?: [ 
    {
      createTime?: string(name='createTime'),
      description?: string(name='description'),
      excludeRules?: [ 
        {
          key?: string(name='key'),
          values?: [ string ](name='values'),
        }
      ](name='excludeRules'),
      exportTaskId?: string(name='exportTaskId'),
      exportToModule?: {
        source?: string(name='source'),
        sourcePath?: string(name='sourcePath'),
        statePath?: string(name='statePath'),
      }(name='exportToModule'),
      exportVersion?: string(name='exportVersion'),
      failedReason?: string(name='failedReason'),
      hasDestroy?: boolean(name='hasDestroy'),
      includeRules?: [ 
        {
          key?: string(name='key'),
          values?: [ string ](name='values'),
        }
      ](name='includeRules'),
      modules?: [ 
        {
          source?: string(name='source'),
          sourcePath?: string(name='sourcePath'),
          version?: string(name='version'),
        }
      ](name='modules'),
      name?: string(name='name'),
      status?: string(name='status'),
      variables?: [ 
        {
          properties?: [ string ](name='properties'),
          resourceType?: string(name='resourceType'),
        }
      ](name='variables'),
    }
  ](name='exportTasks'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  requestId?: string(name='requestId'),
  totalCount?: int32(name='totalCount'),
}

model ListResourceExportTaskVersionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListResourceExportTaskVersionsResponseBody(name='body'),
}

async function listResourceExportTaskVersions(exportTaskId: string, request: ListResourceExportTaskVersionsRequest): ListResourceExportTaskVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listResourceExportTaskVersionsWithOptions(exportTaskId, request, headers, runtime);
}

async function listResourceExportTaskVersionsWithOptions(exportTaskId: string, request: ListResourceExportTaskVersionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListResourceExportTaskVersionsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.exportVersion)) {
    query['exportVersion'] = request.exportVersion;
  }
  if (!Util.isUnset(request.keyword)) {
    query['keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.status)) {
    query['status'] = request.status;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListResourceExportTaskVersions',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/exportTasks/${OpenApiUtil.getEncodeParam(exportTaskId)}/exportVersions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListResourceExportTasksRequest {
  exportTaskId?: string(name='exportTaskId'),
  keyword?: string(name='keyword'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
}

model ListResourceExportTasksResponseBody = {
  exportTasks?: [ 
    {
      createTime?: string(name='createTime'),
      description?: string(name='description'),
      excludeRules?: [ 
        {
          key?: string(name='key'),
          values?: [ string ](name='values'),
        }
      ](name='excludeRules'),
      exportTaskId?: string(name='exportTaskId'),
      exportToModule?: {
        source?: string(name='source'),
        sourcePath?: string(name='sourcePath'),
        statePath?: string(name='statePath'),
      }(name='exportToModule'),
      exportVersion?: string(name='exportVersion'),
      hasDestroy?: boolean(name='hasDestroy'),
      includeRules?: [ 
        {
          key?: string(name='key'),
          values?: [ string ](name='values'),
        }
      ](name='includeRules'),
      modules?: [ 
        {
          source?: string(name='source'),
          sourcePath?: string(name='sourcePath'),
          version?: string(name='version'),
        }
      ](name='modules'),
      name?: string(name='name'),
      status?: string(name='status'),
      variables?: [ 
        {
          properties?: [ string ](name='properties'),
          resourceType?: string(name='resourceType'),
        }
      ](name='variables'),
    }
  ](name='exportTasks'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  requestId?: string(name='requestId'),
  totalCount?: int32(name='totalCount'),
}

model ListResourceExportTasksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListResourceExportTasksResponseBody(name='body'),
}

async function listResourceExportTasks(request: ListResourceExportTasksRequest): ListResourceExportTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listResourceExportTasksWithOptions(request, headers, runtime);
}

async function listResourceExportTasksWithOptions(request: ListResourceExportTasksRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListResourceExportTasksResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.exportTaskId)) {
    query['exportTaskId'] = request.exportTaskId;
  }
  if (!Util.isUnset(request.keyword)) {
    query['keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListResourceExportTasks',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/exportTasks`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListResourcesRequest {
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  sourceType?: string(name='sourceType'),
  sourceValue?: string(name='sourceValue'),
  specType?: string(name='specType'),
}

model ListResourcesResponseBody = {
  resources?: [ 
    {
      accountId?: string(name='accountId'),
      createTime?: string(name='createTime'),
      dependsOnResourceIds?: [ string ](name='dependsOnResourceIds'),
      productCode?: string(name='productCode'),
      properties?: map[string]any(name='properties'),
      propertyVariables?: map[string]any(name='propertyVariables'),
      regionId?: string(name='regionId'),
      resourceArn?: string(name='resourceArn'),
      resourceGroupId?: string(name='resourceGroupId'),
      resourceId?: string(name='resourceId'),
      resourceName?: string(name='resourceName'),
      resourceType?: string(name='resourceType'),
      status?: string(name='status'),
      tags?: [ 
        {
          tagKey?: string(name='tagKey'),
          tagValue?: string(name='tagValue'),
        }
      ](name='tags'),
      terraformArn?: string(name='terraformArn'),
      terraformCode?: string(name='terraformCode'),
      zoneId?: string(name='zoneId'),
    }
  ](name='Resources'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  requestId?: string(name='requestId'),
  totalCount?: int32(name='totalCount'),
}

model ListResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListResourcesResponseBody(name='body'),
}

async function listResources(request: ListResourcesRequest): ListResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listResourcesWithOptions(request, headers, runtime);
}

async function listResourcesWithOptions(request: ListResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListResourcesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['sourceType'] = request.sourceType;
  }
  if (!Util.isUnset(request.sourceValue)) {
    query['sourceValue'] = request.sourceValue;
  }
  if (!Util.isUnset(request.specType)) {
    query['specType'] = request.specType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListResources',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/resources/stateparser`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListTaskResourceRequest {
  pageNumber?: string(name='pageNumber'),
  pageSize?: string(name='pageSize'),
}

model ListTaskResourceResponseBody = {
  count?: long(name='count'),
  pageNumber?: long(name='pageNumber'),
  pageSize?: long(name='pageSize'),
  requestId?: string(name='requestId'),
  resources?: [ 
    {
      instanceAttribute?: string(name='instanceAttribute'),
      instanceId?: string(name='instanceId'),
      jobId?: string(name='jobId'),
      name?: string(name='name'),
      type?: string(name='type'),
    }
  ](name='resources'),
}

model ListTaskResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTaskResourceResponseBody(name='body'),
}

async function listTaskResource(taskId: string, request: ListTaskResourceRequest): ListTaskResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTaskResourceWithOptions(taskId, request, headers, runtime);
}

async function listTaskResourceWithOptions(taskId: string, request: ListTaskResourceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTaskResourceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTaskResource',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/tasks/${OpenApiUtil.getEncodeParam(taskId)}/resources`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListTasksRequest {
  groupId?: string(name='groupId'),
  keyword?: string(name='keyword'),
  moduleId?: string(name='moduleId'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  projectId?: string(name='projectId'),
  taskId?: string(name='taskId'),
}

model ListTasksResponseBody = {
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  requestId?: string(name='requestId'),
  tasks?: [ 
    {
      createTime?: string(name='createTime'),
      currentJobId?: string(name='currentJobId'),
      currentJobStatus?: string(name='currentJobStatus'),
      groupInfo?: {
        groupId?: string(name='groupId'),
        groupName?: string(name='groupName'),
        projectId?: string(name='projectId'),
        projectName?: string(name='projectName'),
      }(name='groupInfo'),
      hasDestroy?: boolean(name='hasDestroy'),
      moduleId?: string(name='moduleId'),
      moduleVersion?: string(name='moduleVersion'),
      name?: string(name='name'),
      status?: string(name='status'),
      taskId?: string(name='taskId'),
    }
  ](name='tasks'),
  totalCount?: int32(name='totalCount'),
}

model ListTasksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTasksResponseBody(name='body'),
}

async function listTasks(request: ListTasksRequest): ListTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTasksWithOptions(request, headers, runtime);
}

async function listTasksWithOptions(request: ListTasksRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTasksResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.groupId)) {
    query['groupId'] = request.groupId;
  }
  if (!Util.isUnset(request.keyword)) {
    query['keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.moduleId)) {
    query['moduleId'] = request.moduleId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    query['projectId'] = request.projectId;
  }
  if (!Util.isUnset(request.taskId)) {
    query['taskId'] = request.taskId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTasks',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/tasks`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model OperateJobRequest {
  comment?: string(name='comment'),
}

model OperateJobResponseBody = {
  requestId?: string(name='requestId'),
}

model OperateJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OperateJobResponseBody(name='body'),
}

async function operateJob(taskId: string, jobId: string, operationType: string, request: OperateJobRequest): OperateJobResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return operateJobWithOptions(taskId, jobId, operationType, request, headers, runtime);
}

async function operateJobWithOptions(taskId: string, jobId: string, operationType: string, request: OperateJobRequest, headers: map[string]string, runtime: Util.RuntimeOptions): OperateJobResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.comment)) {
    query['comment'] = request.comment;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OperateJob',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/tasks/${OpenApiUtil.getEncodeParam(taskId)}/jobs/${OpenApiUtil.getEncodeParam(jobId)}/operation/${OpenApiUtil.getEncodeParam(operationType)}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RemoveResourceExportTaskVersionResponseBody = {
  requestId?: string(name='requestId'),
}

model RemoveResourceExportTaskVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveResourceExportTaskVersionResponseBody(name='body'),
}

async function removeResourceExportTaskVersion(exportTaskId: string, exportVersion: string): RemoveResourceExportTaskVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return removeResourceExportTaskVersionWithOptions(exportTaskId, exportVersion, headers, runtime);
}

async function removeResourceExportTaskVersionWithOptions(exportTaskId: string, exportVersion: string, headers: map[string]string, runtime: Util.RuntimeOptions): RemoveResourceExportTaskVersionResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'RemoveResourceExportTaskVersion',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/exportTasks/${OpenApiUtil.getEncodeParam(exportTaskId)}/${OpenApiUtil.getEncodeParam(exportVersion)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateAuthorizationAttributeRequest {
  dueTime?: string(name='dueTime'),
  name?: string(name='name'),
}

model UpdateAuthorizationAttributeResponseBody = {
  requestId?: string(name='requestId'),
}

model UpdateAuthorizationAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAuthorizationAttributeResponseBody(name='body'),
}

async function updateAuthorizationAttribute(authorizationId: string, request: UpdateAuthorizationAttributeRequest): UpdateAuthorizationAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateAuthorizationAttributeWithOptions(authorizationId, request, headers, runtime);
}

async function updateAuthorizationAttributeWithOptions(authorizationId: string, request: UpdateAuthorizationAttributeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateAuthorizationAttributeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.dueTime)) {
    body['dueTime'] = request.dueTime;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAuthorizationAttribute',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/authorizations/${OpenApiUtil.getEncodeParam(authorizationId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateGroupRequest {
  clientToken?: string(name='clientToken'),
  description?: string(name='description'),
  name?: string(name='name'),
}

model UpdateGroupResponseBody = {
  group?: {
    createTime?: string(name='createTime'),
    description?: string(name='description'),
    id?: string(name='id'),
    name?: string(name='name'),
    projectId?: string(name='projectId'),
    taskCnt?: long(name='taskCnt'),
  }(name='group'),
  requestId?: string(name='requestId'),
}

model UpdateGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateGroupResponseBody(name='body'),
}

async function updateGroup(id: string, request: UpdateGroupRequest): UpdateGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateGroupWithOptions(id, request, headers, runtime);
}

async function updateGroupWithOptions(id: string, request: UpdateGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateGroup',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/group/${OpenApiUtil.getEncodeParam(id)}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateModuleAttributeRequest {
  description?: string(name='description'),
  name?: string(name='name'),
  source?: string(name='source'),
  sourcePath?: string(name='sourcePath'),
  statePath?: string(name='statePath'),
  versionStrategy?: string(name='versionStrategy'),
}

model UpdateModuleAttributeResponseBody = {
  requestId?: string(name='requestId'),
}

model UpdateModuleAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateModuleAttributeResponseBody(name='body'),
}

async function updateModuleAttribute(moduleId: string, request: UpdateModuleAttributeRequest): UpdateModuleAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateModuleAttributeWithOptions(moduleId, request, headers, runtime);
}

async function updateModuleAttributeWithOptions(moduleId: string, request: UpdateModuleAttributeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateModuleAttributeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.source)) {
    body['source'] = request.source;
  }
  if (!Util.isUnset(request.sourcePath)) {
    body['sourcePath'] = request.sourcePath;
  }
  if (!Util.isUnset(request.statePath)) {
    body['statePath'] = request.statePath;
  }
  if (!Util.isUnset(request.versionStrategy)) {
    body['versionStrategy'] = request.versionStrategy;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateModuleAttribute',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/modules/${OpenApiUtil.getEncodeParam(moduleId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateModuleMarketAttributeRequest {
  description?: string(name='description'),
  moduleDetail?: string(name='moduleDetail'),
  name?: string(name='name'),
}

model UpdateModuleMarketAttributeResponseBody = {
  requestId?: string(name='requestId'),
}

model UpdateModuleMarketAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateModuleMarketAttributeResponseBody(name='body'),
}

async function updateModuleMarketAttribute(moduleMarketId: string, request: UpdateModuleMarketAttributeRequest): UpdateModuleMarketAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateModuleMarketAttributeWithOptions(moduleMarketId, request, headers, runtime);
}

async function updateModuleMarketAttributeWithOptions(moduleMarketId: string, request: UpdateModuleMarketAttributeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateModuleMarketAttributeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.moduleDetail)) {
    body['moduleDetail'] = request.moduleDetail;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateModuleMarketAttribute',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/moduleMarkets/${OpenApiUtil.getEncodeParam(moduleMarketId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateParameterSetAttributeRequest {
  description?: string(name='description'),
  name?: string(name='name'),
  parameters?: [ 
    {
      name?: string(name='name'),
      type?: string(name='type'),
      value?: string(name='value'),
    }
  ](name='parameters'),
}

model UpdateParameterSetAttributeResponseBody = {
  requestId?: string(name='requestId'),
}

model UpdateParameterSetAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateParameterSetAttributeResponseBody(name='body'),
}

async function updateParameterSetAttribute(parameterSetId: string, request: UpdateParameterSetAttributeRequest): UpdateParameterSetAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateParameterSetAttributeWithOptions(parameterSetId, request, headers, runtime);
}

async function updateParameterSetAttributeWithOptions(parameterSetId: string, request: UpdateParameterSetAttributeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateParameterSetAttributeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.parameters)) {
    body['parameters'] = request.parameters;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateParameterSetAttribute',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/parameterSets/${OpenApiUtil.getEncodeParam(parameterSetId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateProjectRequest {
  clientToken?: string(name='clientToken'),
  description?: string(name='description'),
  name?: string(name='name'),
}

model UpdateProjectResponseBody = {
  project?: {
    createTime?: string(name='createTime'),
    description?: string(name='description'),
    groupCnt?: long(name='groupCnt'),
    id?: string(name='id'),
    name?: string(name='name'),
    taskCnt?: long(name='taskCnt'),
  }(name='project'),
  requestId?: string(name='requestId'),
}

model UpdateProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateProjectResponseBody(name='body'),
}

async function updateProject(id: string, request: UpdateProjectRequest): UpdateProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateProjectWithOptions(id, request, headers, runtime);
}

async function updateProjectWithOptions(id: string, request: UpdateProjectRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateProjectResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateProject',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/project/${OpenApiUtil.getEncodeParam(id)}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateRabbitmqPublisherAttributeRequest {
  description?: string(name='description'),
  exchangeName?: string(name='exchangeName'),
  exchangeType?: string(name='exchangeType'),
  name?: string(name='name'),
}

model UpdateRabbitmqPublisherAttributeResponseBody = {
  requestId?: string(name='requestId'),
}

model UpdateRabbitmqPublisherAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateRabbitmqPublisherAttributeResponseBody(name='body'),
}

async function updateRabbitmqPublisherAttribute(publisherId: string, request: UpdateRabbitmqPublisherAttributeRequest): UpdateRabbitmqPublisherAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateRabbitmqPublisherAttributeWithOptions(publisherId, request, headers, runtime);
}

async function updateRabbitmqPublisherAttributeWithOptions(publisherId: string, request: UpdateRabbitmqPublisherAttributeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateRabbitmqPublisherAttributeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.exchangeName)) {
    body['exchangeName'] = request.exchangeName;
  }
  if (!Util.isUnset(request.exchangeType)) {
    body['exchangeType'] = request.exchangeType;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateRabbitmqPublisherAttribute',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/publishers/${OpenApiUtil.getEncodeParam(publisherId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateResourceExportTaskAttributeRequest {
  clientToken?: string(name='clientToken'),
  description?: string(name='description'),
  excludeRules?: [ 
    {
      key?: string(name='key'),
      values?: [ string ](name='values'),
    }
  ](name='excludeRules'),
  exportToModule?: {
    source?: string(name='source'),
    sourcePath?: string(name='sourcePath'),
    statePath?: string(name='statePath'),
  }(name='exportToModule'),
  includeRules?: [ 
    {
      key?: string(name='key'),
      values?: [ string ](name='values'),
    }
  ](name='includeRules'),
  name?: string(name='name'),
  ramRole?: string(name='ramRole'),
  terraformVersion?: string(name='terraformVersion'),
  triggerStrategy?: string(name='triggerStrategy'),
  variables?: [ 
    {
      properties?: [ string ](name='properties'),
      resourceType?: string(name='resourceType'),
    }
  ](name='variables'),
}

model UpdateResourceExportTaskAttributeResponseBody = {
  exportTaskId?: string(name='exportTaskId'),
  exportVersion?: string(name='exportVersion'),
  requestId?: string(name='requestId'),
}

model UpdateResourceExportTaskAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateResourceExportTaskAttributeResponseBody(name='body'),
}

async function updateResourceExportTaskAttribute(exportTaskId: string, request: UpdateResourceExportTaskAttributeRequest): UpdateResourceExportTaskAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateResourceExportTaskAttributeWithOptions(exportTaskId, request, headers, runtime);
}

async function updateResourceExportTaskAttributeWithOptions(exportTaskId: string, request: UpdateResourceExportTaskAttributeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateResourceExportTaskAttributeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.excludeRules)) {
    body['excludeRules'] = request.excludeRules;
  }
  if (!Util.isUnset(request.exportToModule)) {
    body['exportToModule'] = request.exportToModule;
  }
  if (!Util.isUnset(request.includeRules)) {
    body['includeRules'] = request.includeRules;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.ramRole)) {
    body['ramRole'] = request.ramRole;
  }
  if (!Util.isUnset(request.terraformVersion)) {
    body['terraformVersion'] = request.terraformVersion;
  }
  if (!Util.isUnset(request.triggerStrategy)) {
    body['triggerStrategy'] = request.triggerStrategy;
  }
  if (!Util.isUnset(request.variables)) {
    body['variables'] = request.variables;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateResourceExportTaskAttribute',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/exportTasks/${OpenApiUtil.getEncodeParam(exportTaskId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateTaskAttributeRequest {
  autoApply?: boolean(name='autoApply'),
  groupInfo?: {
    groupId?: string(name='groupId'),
    projectId?: string(name='projectId'),
  }(name='groupInfo'),
  moduleId?: string(name='moduleId'),
  moduleVersion?: string(name='moduleVersion'),
  name?: string(name='name'),
  parameters?: map[string]string(name='parameters'),
  protectionStrategy?: [ string ](name='protectionStrategy'),
  ramRole?: string(name='ramRole'),
  terraformVersion?: string(name='terraformVersion'),
  triggerStrategy?: string(name='triggerStrategy'),
}

model UpdateTaskAttributeResponseBody = {
  requestId?: string(name='requestId'),
}

model UpdateTaskAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateTaskAttributeResponseBody(name='body'),
}

async function updateTaskAttribute(taskId: string, request: UpdateTaskAttributeRequest): UpdateTaskAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateTaskAttributeWithOptions(taskId, request, headers, runtime);
}

async function updateTaskAttributeWithOptions(taskId: string, request: UpdateTaskAttributeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateTaskAttributeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.autoApply)) {
    body['autoApply'] = request.autoApply;
  }
  if (!Util.isUnset(request.groupInfo)) {
    body['groupInfo'] = request.groupInfo;
  }
  if (!Util.isUnset(request.moduleId)) {
    body['moduleId'] = request.moduleId;
  }
  if (!Util.isUnset(request.moduleVersion)) {
    body['moduleVersion'] = request.moduleVersion;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.parameters)) {
    body['parameters'] = request.parameters;
  }
  if (!Util.isUnset(request.protectionStrategy)) {
    body['protectionStrategy'] = request.protectionStrategy;
  }
  if (!Util.isUnset(request.ramRole)) {
    body['ramRole'] = request.ramRole;
  }
  if (!Util.isUnset(request.terraformVersion)) {
    body['terraformVersion'] = request.terraformVersion;
  }
  if (!Util.isUnset(request.triggerStrategy)) {
    body['triggerStrategy'] = request.triggerStrategy;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTaskAttribute',
    version = '2021-08-06',
    protocol = 'HTTPS',
    pathname = `/tasks/${OpenApiUtil.getEncodeParam(taskId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

