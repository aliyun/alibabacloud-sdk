/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('rocketmq', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model CreateConsumerGroupRequest {
  consumeRetryPolicy?: {
    maxRetryTimes?: int32(name='maxRetryTimes'),
    retryPolicy?: string(name='retryPolicy'),
  }(name='consumeRetryPolicy'),
  deliveryOrderType?: string(name='deliveryOrderType'),
  remark?: string(name='remark'),
  resourceGroupId?: string(name='resourceGroupId'),
}

model CreateConsumerGroupResponseBody = {
  code?: string(name='code'),
  data?: boolean(name='data'),
  dynamicCode?: string(name='dynamicCode'),
  dynamicMessage?: string(name='dynamicMessage'),
  httpStatusCode?: int32(name='httpStatusCode'),
  message?: string(name='message'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model CreateConsumerGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateConsumerGroupResponseBody(name='body'),
}

async function createConsumerGroup(instanceId: string, consumerGroupId: string, request: CreateConsumerGroupRequest): CreateConsumerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createConsumerGroupWithOptions(instanceId, consumerGroupId, request, headers, runtime);
}

async function createConsumerGroupWithOptions(instanceId: string, consumerGroupId: string, request: CreateConsumerGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateConsumerGroupResponse {
  Util.validateModel(request);
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  consumerGroupId = OpenApiUtil.getEncodeParam(consumerGroupId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.consumeRetryPolicy)) {
    body['consumeRetryPolicy'] = request.consumeRetryPolicy;
  }
  if (!Util.isUnset(request.deliveryOrderType)) {
    body['deliveryOrderType'] = request.deliveryOrderType;
  }
  if (!Util.isUnset(request.remark)) {
    body['remark'] = request.remark;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    body['resourceGroupId'] = request.resourceGroupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateConsumerGroup',
    version = '2022-08-01',
    protocol = 'HTTPS',
    pathname = `/instances/${instanceId}/consumerGroups/${consumerGroupId}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateTopicRequest {
  messageType?: string(name='messageType'),
  remark?: string(name='remark'),
  resourceGroupId?: string(name='resourceGroupId'),
}

model CreateTopicResponseBody = {
  code?: string(name='code'),
  data?: boolean(name='data'),
  dynamicCode?: string(name='dynamicCode'),
  dynamicMessage?: string(name='dynamicMessage'),
  httpStatusCode?: int32(name='httpStatusCode'),
  message?: string(name='message'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model CreateTopicResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateTopicResponseBody(name='body'),
}

async function createTopic(instanceId: string, topicName: string, request: CreateTopicRequest): CreateTopicResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createTopicWithOptions(instanceId, topicName, request, headers, runtime);
}

async function createTopicWithOptions(instanceId: string, topicName: string, request: CreateTopicRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateTopicResponse {
  Util.validateModel(request);
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  topicName = OpenApiUtil.getEncodeParam(topicName);
  var body : map[string]any = {};
  if (!Util.isUnset(request.messageType)) {
    body['messageType'] = request.messageType;
  }
  if (!Util.isUnset(request.remark)) {
    body['remark'] = request.remark;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    body['resourceGroupId'] = request.resourceGroupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateTopic',
    version = '2022-08-01',
    protocol = 'HTTPS',
    pathname = `/instances/${instanceId}/topics/${topicName}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteConsumerGroupResponseBody = {
  code?: string(name='code'),
  data?: boolean(name='data'),
  dynamicCode?: string(name='dynamicCode'),
  dynamicMessage?: string(name='dynamicMessage'),
  httpStatusCode?: int32(name='httpStatusCode'),
  message?: string(name='message'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model DeleteConsumerGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteConsumerGroupResponseBody(name='body'),
}

async function deleteConsumerGroup(instanceId: string, consumerGroupId: string): DeleteConsumerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteConsumerGroupWithOptions(instanceId, consumerGroupId, headers, runtime);
}

async function deleteConsumerGroupWithOptions(instanceId: string, consumerGroupId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteConsumerGroupResponse {
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  consumerGroupId = OpenApiUtil.getEncodeParam(consumerGroupId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteConsumerGroup',
    version = '2022-08-01',
    protocol = 'HTTPS',
    pathname = `/instances/${instanceId}/consumerGroups/${consumerGroupId}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteInstanceResponseBody = {
  code?: string(name='code'),
  data?: boolean(name='data'),
  dynamicCode?: string(name='dynamicCode'),
  dynamicMessage?: string(name='dynamicMessage'),
  httpStatusCode?: int32(name='httpStatusCode'),
  message?: string(name='message'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model DeleteInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteInstanceResponseBody(name='body'),
}

async function deleteInstance(instanceId: string): DeleteInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteInstanceWithOptions(instanceId, headers, runtime);
}

async function deleteInstanceWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteInstanceResponse {
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteInstance',
    version = '2022-08-01',
    protocol = 'HTTPS',
    pathname = `/instances/${instanceId}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteTopicResponseBody = {
  code?: string(name='code'),
  data?: boolean(name='data'),
  dynamicCode?: string(name='dynamicCode'),
  dynamicMessage?: string(name='dynamicMessage'),
  httpStatusCode?: int32(name='httpStatusCode'),
  message?: string(name='message'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model DeleteTopicResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteTopicResponseBody(name='body'),
}

async function deleteTopic(instanceId: string, topicName: string): DeleteTopicResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteTopicWithOptions(instanceId, topicName, headers, runtime);
}

async function deleteTopicWithOptions(instanceId: string, topicName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteTopicResponse {
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  topicName = OpenApiUtil.getEncodeParam(topicName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteTopic',
    version = '2022-08-01',
    protocol = 'HTTPS',
    pathname = `/instances/${instanceId}/topics/${topicName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetConsumerGroupResponseBody = {
  code?: string(name='code'),
  data?: {
    consumeRetryPolicy?: {
      maxRetryTimes?: int32(name='maxRetryTimes'),
      retryPolicy?: string(name='retryPolicy'),
    }(name='consumeRetryPolicy'),
    consumerGroupId?: string(name='consumerGroupId'),
    createTime?: string(name='createTime'),
    deliveryOrderType?: string(name='deliveryOrderType'),
    instanceId?: string(name='instanceId'),
    regionId?: string(name='regionId'),
    remark?: string(name='remark'),
    resourceGroupId?: string(name='resourceGroupId'),
    status?: string(name='status'),
    updateTime?: string(name='updateTime'),
  }(name='data'),
  dynamicCode?: string(name='dynamicCode'),
  dynamicMessage?: string(name='dynamicMessage'),
  httpStatusCode?: int32(name='httpStatusCode'),
  message?: string(name='message'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model GetConsumerGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetConsumerGroupResponseBody(name='body'),
}

async function getConsumerGroup(instanceId: string, consumerGroupId: string): GetConsumerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getConsumerGroupWithOptions(instanceId, consumerGroupId, headers, runtime);
}

async function getConsumerGroupWithOptions(instanceId: string, consumerGroupId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetConsumerGroupResponse {
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  consumerGroupId = OpenApiUtil.getEncodeParam(consumerGroupId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetConsumerGroup',
    version = '2022-08-01',
    protocol = 'HTTPS',
    pathname = `/instances/${instanceId}/consumerGroups/${consumerGroupId}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetInstanceResponseBody = {
  code?: string(name='code'),
  data?: {
    accountInfo?: {
      password?: string(name='password'),
      username?: string(name='username'),
    }(name='accountInfo'),
    bid?: string(name='bid'),
    commodityCode?: string(name='commodityCode'),
    createTime?: string(name='createTime'),
    expireTime?: string(name='expireTime'),
    extConfig?: {
      aclType?: string(name='aclType'),
      autoScaling?: boolean(name='autoScaling'),
      flowOutBandwidth?: int32(name='flowOutBandwidth'),
      flowOutType?: string(name='flowOutType'),
      internetSpec?: string(name='internetSpec'),
      messageRetentionTime?: int32(name='messageRetentionTime'),
      msgProcessSpec?: string(name='msgProcessSpec'),
      sendReceiveRatio?: float(name='sendReceiveRatio'),
      supportAutoScaling?: boolean(name='supportAutoScaling'),
    }(name='extConfig'),
    instanceId?: string(name='instanceId'),
    instanceName?: string(name='instanceName'),
    instanceQuotas?: [ 
      {
        freeCount?: double(name='freeCount'),
        quotaName?: string(name='quotaName'),
        totalCount?: double(name='totalCount'),
        usedCount?: double(name='usedCount'),
      }
    ](name='instanceQuotas'),
    networkInfo?: {
      endpoints?: [ 
        {
          endpointType?: string(name='endpointType'),
          endpointUrl?: string(name='endpointUrl'),
          ipWhitelist?: string(name='ipWhitelist'),
        }
      ](name='endpoints'),
      vpcInfo?: {
        vSwitchId?: string(name='vSwitchId'),
        vpcId?: string(name='vpcId'),
      }(name='vpcInfo'),
    }(name='networkInfo'),
    paymentType?: string(name='paymentType'),
    regionId?: string(name='regionId'),
    releaseTime?: string(name='releaseTime'),
    remark?: string(name='remark'),
    resourceGroupId?: string(name='resourceGroupId'),
    seriesCode?: string(name='seriesCode'),
    serviceCode?: string(name='serviceCode'),
    startTime?: string(name='startTime'),
    status?: string(name='status'),
    subSeriesCode?: string(name='subSeriesCode'),
    updateTime?: string(name='updateTime'),
    userId?: string(name='userId'),
  }(name='data'),
  dynamicCode?: string(name='dynamicCode'),
  dynamicMessage?: string(name='dynamicMessage'),
  httpStatusCode?: int32(name='httpStatusCode'),
  message?: string(name='message'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model GetInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetInstanceResponseBody(name='body'),
}

async function getInstance(instanceId: string): GetInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getInstanceWithOptions(instanceId, headers, runtime);
}

async function getInstanceWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetInstanceResponse {
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetInstance',
    version = '2022-08-01',
    protocol = 'HTTPS',
    pathname = `/instances/${instanceId}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetTopicResponseBody = {
  code?: string(name='code'),
  data?: {
    createTime?: string(name='createTime'),
    instanceId?: string(name='instanceId'),
    messageType?: string(name='messageType'),
    regionId?: string(name='regionId'),
    remark?: string(name='remark'),
    resourceGroupId?: string(name='resourceGroupId'),
    status?: string(name='status'),
    topicName?: string(name='topicName'),
    updateTime?: string(name='updateTime'),
  }(name='data'),
  dynamicCode?: string(name='dynamicCode'),
  dynamicMessage?: string(name='dynamicMessage'),
  httpStatusCode?: int32(name='httpStatusCode'),
  message?: string(name='message'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model GetTopicResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTopicResponseBody(name='body'),
}

async function getTopic(instanceId: string, topicName: string): GetTopicResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTopicWithOptions(instanceId, topicName, headers, runtime);
}

async function getTopicWithOptions(instanceId: string, topicName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetTopicResponse {
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  topicName = OpenApiUtil.getEncodeParam(topicName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetTopic',
    version = '2022-08-01',
    protocol = 'HTTPS',
    pathname = `/instances/${instanceId}/topics/${topicName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListConsumerGroupsRequest {
  filter?: string(name='filter'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  resourceGroupId?: string(name='resourceGroupId'),
}

model ListConsumerGroupsResponseBody = {
  code?: string(name='code'),
  data?: {
    list?: [ 
      {
        consumerGroupId?: string(name='consumerGroupId'),
        createTime?: string(name='createTime'),
        instanceId?: string(name='instanceId'),
        regionId?: string(name='regionId'),
        remark?: string(name='remark'),
        resourceGroupId?: string(name='resourceGroupId'),
        status?: string(name='status'),
        updateTime?: string(name='updateTime'),
      }
    ](name='list'),
    pageNumber?: long(name='pageNumber'),
    pageSize?: long(name='pageSize'),
    totalCount?: long(name='totalCount'),
  }(name='data'),
  dynamicCode?: string(name='dynamicCode'),
  dynamicMessage?: string(name='dynamicMessage'),
  httpStatusCode?: int32(name='httpStatusCode'),
  message?: string(name='message'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model ListConsumerGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListConsumerGroupsResponseBody(name='body'),
}

async function listConsumerGroups(instanceId: string, request: ListConsumerGroupsRequest): ListConsumerGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listConsumerGroupsWithOptions(instanceId, request, headers, runtime);
}

async function listConsumerGroupsWithOptions(instanceId: string, request: ListConsumerGroupsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListConsumerGroupsResponse {
  Util.validateModel(request);
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.filter)) {
    query['filter'] = request.filter;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['resourceGroupId'] = request.resourceGroupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListConsumerGroups',
    version = '2022-08-01',
    protocol = 'HTTPS',
    pathname = `/instances/${instanceId}/consumerGroups`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListInstancesRequest {
  filter?: string(name='filter'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  resourceGroupId?: string(name='resourceGroupId'),
}

model ListInstancesResponseBody = {
  code?: string(name='code'),
  data?: {
    list?: [ 
      {
        commodityCode?: string(name='commodityCode'),
        createTime?: string(name='createTime'),
        expireTime?: string(name='expireTime'),
        groupCount?: long(name='groupCount'),
        instanceId?: string(name='instanceId'),
        instanceName?: string(name='instanceName'),
        paymentType?: string(name='paymentType'),
        regionId?: string(name='regionId'),
        releaseTime?: string(name='releaseTime'),
        remark?: string(name='remark'),
        resourceGroupId?: string(name='resourceGroupId'),
        seriesCode?: string(name='seriesCode'),
        serviceCode?: string(name='serviceCode'),
        startTime?: string(name='startTime'),
        status?: string(name='status'),
        subSeriesCode?: string(name='subSeriesCode'),
        topicCount?: long(name='topicCount'),
        updateTime?: string(name='updateTime'),
        userId?: string(name='userId'),
      }
    ](name='list'),
    pageNumber?: long(name='pageNumber'),
    pageSize?: long(name='pageSize'),
    totalCount?: long(name='totalCount'),
  }(name='data'),
  dynamicCode?: string(name='dynamicCode'),
  dynamicMessage?: string(name='dynamicMessage'),
  httpStatusCode?: int32(name='httpStatusCode'),
  message?: string(name='message'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model ListInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInstancesResponseBody(name='body'),
}

async function listInstances(request: ListInstancesRequest): ListInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listInstancesWithOptions(request, headers, runtime);
}

async function listInstancesWithOptions(request: ListInstancesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListInstancesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.filter)) {
    query['filter'] = request.filter;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['resourceGroupId'] = request.resourceGroupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInstances',
    version = '2022-08-01',
    protocol = 'HTTPS',
    pathname = `/instances`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListTopicsRequest {
  filter?: string(name='filter'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  resourceGroupId?: string(name='resourceGroupId'),
}

model ListTopicsResponseBody = {
  code?: string(name='code'),
  data?: {
    list?: [ 
      {
        createTime?: string(name='createTime'),
        instanceId?: string(name='instanceId'),
        messageType?: string(name='messageType'),
        regionId?: string(name='regionId'),
        remark?: string(name='remark'),
        resourceGroupId?: string(name='resourceGroupId'),
        status?: string(name='status'),
        topicName?: string(name='topicName'),
        updateTime?: string(name='updateTime'),
      }
    ](name='list'),
    pageNumber?: long(name='pageNumber'),
    pageSize?: long(name='pageSize'),
    totalCount?: long(name='totalCount'),
  }(name='data'),
  dynamicCode?: string(name='dynamicCode'),
  dynamicMessage?: string(name='dynamicMessage'),
  httpStatusCode?: int32(name='httpStatusCode'),
  message?: string(name='message'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model ListTopicsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTopicsResponseBody(name='body'),
}

async function listTopics(instanceId: string, request: ListTopicsRequest): ListTopicsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTopicsWithOptions(instanceId, request, headers, runtime);
}

async function listTopicsWithOptions(instanceId: string, request: ListTopicsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTopicsResponse {
  Util.validateModel(request);
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.filter)) {
    query['filter'] = request.filter;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['resourceGroupId'] = request.resourceGroupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTopics',
    version = '2022-08-01',
    protocol = 'HTTPS',
    pathname = `/instances/${instanceId}/topics`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateConsumerGroupRequest {
  consumeRetryPolicy?: {
    maxRetryTimes?: int32(name='maxRetryTimes'),
    retryPolicy?: string(name='retryPolicy'),
  }(name='consumeRetryPolicy'),
  deliveryOrderType?: string(name='deliveryOrderType'),
  remark?: string(name='remark'),
  resourceGroupId?: string(name='resourceGroupId'),
}

model UpdateConsumerGroupResponseBody = {
  code?: string(name='code'),
  data?: boolean(name='data'),
  dynamicCode?: string(name='dynamicCode'),
  dynamicMessage?: string(name='dynamicMessage'),
  httpStatusCode?: int32(name='httpStatusCode'),
  message?: string(name='message'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model UpdateConsumerGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateConsumerGroupResponseBody(name='body'),
}

async function updateConsumerGroup(instanceId: string, consumerGroupId: string, request: UpdateConsumerGroupRequest): UpdateConsumerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateConsumerGroupWithOptions(instanceId, consumerGroupId, request, headers, runtime);
}

async function updateConsumerGroupWithOptions(instanceId: string, consumerGroupId: string, request: UpdateConsumerGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateConsumerGroupResponse {
  Util.validateModel(request);
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  consumerGroupId = OpenApiUtil.getEncodeParam(consumerGroupId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.consumeRetryPolicy)) {
    body['consumeRetryPolicy'] = request.consumeRetryPolicy;
  }
  if (!Util.isUnset(request.deliveryOrderType)) {
    body['deliveryOrderType'] = request.deliveryOrderType;
  }
  if (!Util.isUnset(request.remark)) {
    body['remark'] = request.remark;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    body['resourceGroupId'] = request.resourceGroupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateConsumerGroup',
    version = '2022-08-01',
    protocol = 'HTTPS',
    pathname = `/instances/${instanceId}/consumerGroups/${consumerGroupId}`,
    method = 'PATCH',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateInstanceRequest {
  extConfig?: {
    autoScaling?: boolean(name='autoScaling'),
    messageRetentionTime?: int32(name='messageRetentionTime'),
    sendReceiveRatio?: float(name='sendReceiveRatio'),
  }(name='extConfig'),
  instanceName?: string(name='instanceName'),
  networkInfo?: {
    endpoints?: [ 
      {
        endpointType?: string(name='endpointType'),
        ipWhitelist?: string(name='ipWhitelist'),
      }
    ](name='endpoints'),
  }(name='networkInfo'),
  remark?: string(name='remark'),
  resourceGroupId?: string(name='resourceGroupId'),
}

model UpdateInstanceResponseBody = {
  code?: string(name='code'),
  data?: boolean(name='data'),
  dynamicCode?: string(name='dynamicCode'),
  dynamicMessage?: string(name='dynamicMessage'),
  httpStatusCode?: int32(name='httpStatusCode'),
  message?: string(name='message'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model UpdateInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateInstanceResponseBody(name='body'),
}

async function updateInstance(instanceId: string, request: UpdateInstanceRequest): UpdateInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateInstanceWithOptions(instanceId, request, headers, runtime);
}

async function updateInstanceWithOptions(instanceId: string, request: UpdateInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateInstanceResponse {
  Util.validateModel(request);
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.extConfig)) {
    body['extConfig'] = request.extConfig;
  }
  if (!Util.isUnset(request.instanceName)) {
    body['instanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.networkInfo)) {
    body['networkInfo'] = request.networkInfo;
  }
  if (!Util.isUnset(request.remark)) {
    body['remark'] = request.remark;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    body['resourceGroupId'] = request.resourceGroupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateInstance',
    version = '2022-08-01',
    protocol = 'HTTPS',
    pathname = `/instances/${instanceId}`,
    method = 'PATCH',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateTopicRequest {
  remark?: string(name='remark'),
  resourceGroupId?: string(name='resourceGroupId'),
}

model UpdateTopicResponseBody = {
  code?: string(name='code'),
  data?: boolean(name='data'),
  dynamicCode?: string(name='dynamicCode'),
  dynamicMessage?: string(name='dynamicMessage'),
  httpStatusCode?: int32(name='httpStatusCode'),
  message?: string(name='message'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model UpdateTopicResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateTopicResponseBody(name='body'),
}

async function updateTopic(instanceId: string, topicName: string, request: UpdateTopicRequest): UpdateTopicResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateTopicWithOptions(instanceId, topicName, request, headers, runtime);
}

async function updateTopicWithOptions(instanceId: string, topicName: string, request: UpdateTopicRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateTopicResponse {
  Util.validateModel(request);
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  topicName = OpenApiUtil.getEncodeParam(topicName);
  var body : map[string]any = {};
  if (!Util.isUnset(request.remark)) {
    body['remark'] = request.remark;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    body['resourceGroupId'] = request.resourceGroupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTopic',
    version = '2022-08-01',
    protocol = 'HTTPS',
    pathname = `/instances/${instanceId}/topics/${topicName}`,
    method = 'PATCH',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

