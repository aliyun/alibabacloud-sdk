/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    cn-beijing = 'pai.cn-beijing.aliyuncs.com',
    cn-hangzhou = 'pai.cn-hangzhou.aliyuncs.com',
    cn-shanghai = 'pai.cn-shanghai.aliyuncs.com',
    cn-shenzhen = 'pai.cn-shenzhen.aliyuncs.com',
    cn-hongkong = 'pai.cn-hongkong.aliyuncs.com',
    ap-southeast-1 = 'pai.ap-southeast-1.aliyuncs.com',
    ap-southeast-2 = 'pai.ap-southeast-2.aliyuncs.com',
    ap-southeast-3 = 'pai.ap-southeast-3.aliyuncs.com',
    ap-southeast-5 = 'pai.ap-southeast-5.aliyuncs.com',
    us-west-1 = 'pai.us-west-1.aliyuncs.com',
    us-east-1 = 'pai.us-east-1.aliyuncs.com',
    eu-central-1 = 'pai.eu-central-1.aliyuncs.com',
    me-east-1 = 'pai.me-east-1.aliyuncs.com',
    ap-south-1 = 'pai.ap-south-1.aliyuncs.com',
    cn-qingdao = 'pai.cn-qingdao.aliyuncs.com',
    cn-zhangjiakou = 'pai.cn-zhangjiakou.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('paistudio', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AddImageRequest {
  description?: string(name='Description'),
  imageUri?: string(name='ImageUri'),
  labels?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Labels'),
  name?: string(name='Name'),
}

model AddImageResponseBody = {
  imageId?: string(name='ImageId'),
  requestId?: string(name='requestId'),
}

model AddImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddImageResponseBody(name='body'),
}

async function addImage(request: AddImageRequest): AddImageResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addImageWithOptions(request, headers, runtime);
}

async function addImageWithOptions(request: AddImageRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddImageResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.imageUri)) {
    body['ImageUri'] = request.imageUri;
  }
  if (!Util.isUnset(request.labels)) {
    body['Labels'] = request.labels;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddImage',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/images`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model AddImageLabelsRequest {
  labels?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Labels'),
}

model AddImageLabelsResponseBody = {
  requestId?: string(name='requestId'),
}

model AddImageLabelsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddImageLabelsResponseBody(name='body'),
}

async function addImageLabels(ImageId: string, request: AddImageLabelsRequest): AddImageLabelsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addImageLabelsWithOptions(ImageId, request, headers, runtime);
}

async function addImageLabelsWithOptions(ImageId: string, request: AddImageLabelsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddImageLabelsResponse {
  Util.validateModel(request);
  ImageId = OpenApiUtil.getEncodeParam(ImageId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.labels)) {
    body['Labels'] = request.labels;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddImageLabels',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/images/${ImageId}/labels`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CopyExperimentRequest {
  accessibility?: string(name='Accessibility'),
  description?: string(name='Description'),
  folderId?: string(name='FolderId'),
  name?: string(name='Name'),
  source?: string(name='Source'),
  workspaceId?: string(name='WorkspaceId'),
}

model CopyExperimentResponseBody = {
  experimentId?: string(name='ExperimentId'),
  requestId?: string(name='RequestId'),
}

model CopyExperimentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CopyExperimentResponseBody(name='body'),
}

async function copyExperiment(ExperimentId: string, request: CopyExperimentRequest): CopyExperimentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return copyExperimentWithOptions(ExperimentId, request, headers, runtime);
}

async function copyExperimentWithOptions(ExperimentId: string, request: CopyExperimentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CopyExperimentResponse {
  Util.validateModel(request);
  ExperimentId = OpenApiUtil.getEncodeParam(ExperimentId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.accessibility)) {
    body['Accessibility'] = request.accessibility;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.folderId)) {
    body['FolderId'] = request.folderId;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.source)) {
    body['Source'] = request.source;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CopyExperiment',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/experiments/[ExperimentId]/copy`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateExperimentRequest {
  accessibility?: string(name='Accessibility'),
  description?: string(name='Description'),
  folderId?: string(name='FolderId'),
  name?: string(name='Name'),
  options?: string(name='Options'),
  source?: string(name='Source'),
  templateId?: string(name='TemplateId'),
  workspaceId?: string(name='WorkspaceId'),
}

model CreateExperimentResponseBody = {
  experimentId?: string(name='ExperimentId'),
  requestId?: string(name='RequestId'),
}

model CreateExperimentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateExperimentResponseBody(name='body'),
}

async function createExperiment(request: CreateExperimentRequest): CreateExperimentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createExperimentWithOptions(request, headers, runtime);
}

async function createExperimentWithOptions(request: CreateExperimentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateExperimentResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.accessibility)) {
    body['Accessibility'] = request.accessibility;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.folderId)) {
    body['FolderId'] = request.folderId;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.options)) {
    body['Options'] = request.options;
  }
  if (!Util.isUnset(request.source)) {
    body['Source'] = request.source;
  }
  if (!Util.isUnset(request.templateId)) {
    body['TemplateId'] = request.templateId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateExperiment',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/experiments`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateExperimentFolderRequest {
  accessibility?: string(name='Accessibility'),
  name?: string(name='Name'),
  parentFolderId?: string(name='ParentFolderId'),
  source?: string(name='Source'),
  workspaceId?: string(name='WorkspaceId'),
}

model CreateExperimentFolderResponseBody = {
  folderId?: string(name='FolderId'),
  requestId?: string(name='RequestId'),
}

model CreateExperimentFolderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateExperimentFolderResponseBody(name='body'),
}

async function createExperimentFolder(request: CreateExperimentFolderRequest): CreateExperimentFolderResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createExperimentFolderWithOptions(request, headers, runtime);
}

async function createExperimentFolderWithOptions(request: CreateExperimentFolderRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateExperimentFolderResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.accessibility)) {
    body['Accessibility'] = request.accessibility;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.parentFolderId)) {
    body['ParentFolderId'] = request.parentFolderId;
  }
  if (!Util.isUnset(request.source)) {
    body['Source'] = request.source;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateExperimentFolder',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/experimentfolders`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateExperimentMigrateValidationRequest {
  sourceExpId?: long(name='SourceExpId'),
}

model CreateExperimentMigrateValidationResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateExperimentMigrateValidationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateExperimentMigrateValidationResponseBody(name='body'),
}

async function createExperimentMigrateValidation(request: CreateExperimentMigrateValidationRequest): CreateExperimentMigrateValidationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createExperimentMigrateValidationWithOptions(request, headers, runtime);
}

async function createExperimentMigrateValidationWithOptions(request: CreateExperimentMigrateValidationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateExperimentMigrateValidationResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.sourceExpId)) {
    query['SourceExpId'] = request.sourceExpId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateExperimentMigrateValidation',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/migrate/experimentvalidation`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateJobRequest {
  executeType?: string(name='ExecuteType'),
  experimentId?: string(name='ExperimentId'),
  nodeId?: string(name='NodeId'),
  options?: string(name='Options'),
}

model CreateJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model CreateJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateJobResponseBody(name='body'),
}

async function createJob(request: CreateJobRequest): CreateJobResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createJobWithOptions(request, headers, runtime);
}

async function createJobWithOptions(request: CreateJobRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateJobResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.executeType)) {
    body['ExecuteType'] = request.executeType;
  }
  if (!Util.isUnset(request.experimentId)) {
    body['ExperimentId'] = request.experimentId;
  }
  if (!Util.isUnset(request.nodeId)) {
    body['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.options)) {
    body['Options'] = request.options;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateJob',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/jobs`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteExperimentResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteExperimentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteExperimentResponseBody(name='body'),
}

async function deleteExperiment(ExperimentId: string): DeleteExperimentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteExperimentWithOptions(ExperimentId, headers, runtime);
}

async function deleteExperimentWithOptions(ExperimentId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteExperimentResponse {
  ExperimentId = OpenApiUtil.getEncodeParam(ExperimentId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteExperiment',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/experiments/${ExperimentId}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteExperimentFolderResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteExperimentFolderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteExperimentFolderResponseBody(name='body'),
}

async function deleteExperimentFolder(FolderId: string): DeleteExperimentFolderResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteExperimentFolderWithOptions(FolderId, headers, runtime);
}

async function deleteExperimentFolderWithOptions(FolderId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteExperimentFolderResponse {
  FolderId = OpenApiUtil.getEncodeParam(FolderId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteExperimentFolder',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/experimentfolders/${FolderId}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetAlgoTreeRequest {
  source?: string(name='Source'),
}

model GetAlgoTreeResponseBody = {
  data?: map[string]any(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetAlgoTreeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAlgoTreeResponseBody(name='body'),
}

async function getAlgoTree(request: GetAlgoTreeRequest): GetAlgoTreeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAlgoTreeWithOptions(request, headers, runtime);
}

async function getAlgoTreeWithOptions(request: GetAlgoTreeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetAlgoTreeResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAlgoTree',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/algo/tree`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetAlgorithmDefRequest {
  algoVersion?: string(name='AlgoVersion'),
  identifier?: string(name='Identifier'),
  provider?: string(name='Provider'),
  signature?: string(name='Signature'),
}

model GetAlgorithmDefResponseBody = {
  requestId?: string(name='RequestId'),
  spec?: map[string]any(name='Spec'),
}

model GetAlgorithmDefResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAlgorithmDefResponseBody(name='body'),
}

async function getAlgorithmDef(request: GetAlgorithmDefRequest): GetAlgorithmDefResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAlgorithmDefWithOptions(request, headers, runtime);
}

async function getAlgorithmDefWithOptions(request: GetAlgorithmDefRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetAlgorithmDefResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.algoVersion)) {
    query['AlgoVersion'] = request.algoVersion;
  }
  if (!Util.isUnset(request.identifier)) {
    query['Identifier'] = request.identifier;
  }
  if (!Util.isUnset(request.provider)) {
    query['Provider'] = request.provider;
  }
  if (!Util.isUnset(request.signature)) {
    query['Signature'] = request.signature;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAlgorithmDef',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/algorithm/def`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetAlgorithmDefsRequest {
  latestTimestamp?: string(name='LatestTimestamp'),
  rangeEnd?: int32(name='RangeEnd'),
  rangeStart?: int32(name='RangeStart'),
  timestamp?: string(name='Timestamp'),
}

model GetAlgorithmDefsResponseBody = {
  requestId?: string(name='RequestId'),
  specs?: [  map[string]any ](name='Specs'),
}

model GetAlgorithmDefsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAlgorithmDefsResponseBody(name='body'),
}

async function getAlgorithmDefs(request: GetAlgorithmDefsRequest): GetAlgorithmDefsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAlgorithmDefsWithOptions(request, headers, runtime);
}

async function getAlgorithmDefsWithOptions(request: GetAlgorithmDefsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetAlgorithmDefsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.latestTimestamp)) {
    query['LatestTimestamp'] = request.latestTimestamp;
  }
  if (!Util.isUnset(request.rangeEnd)) {
    query['RangeEnd'] = request.rangeEnd;
  }
  if (!Util.isUnset(request.rangeStart)) {
    query['RangeStart'] = request.rangeStart;
  }
  if (!Util.isUnset(request.timestamp)) {
    query['Timestamp'] = request.timestamp;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAlgorithmDefs',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/algorithm/defs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetAlgorithmTreeRequest {
  source?: string(name='Source'),
}

model GetAlgorithmTreeResponseBody = {
  requestId?: string(name='RequestId'),
  timestamp?: string(name='Timestamp'),
  tree?: [  map[string]any ](name='Tree'),
}

model GetAlgorithmTreeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAlgorithmTreeResponseBody(name='body'),
}

async function getAlgorithmTree(request: GetAlgorithmTreeRequest): GetAlgorithmTreeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAlgorithmTreeWithOptions(request, headers, runtime);
}

async function getAlgorithmTreeWithOptions(request: GetAlgorithmTreeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetAlgorithmTreeResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAlgorithmTree',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/algorithm/tree`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetExperimentResponseBody = {
  accessibility?: string(name='Accessibility'),
  content?: string(name='Content'),
  creator?: string(name='Creator'),
  description?: string(name='Description'),
  experimentId?: string(name='ExperimentId'),
  gmtCreateTime?: string(name='GmtCreateTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  name?: string(name='Name'),
  options?: string(name='Options'),
  requestId?: string(name='RequestId'),
  source?: string(name='Source'),
  version?: long(name='Version'),
  workspaceId?: string(name='WorkspaceId'),
}

model GetExperimentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetExperimentResponseBody(name='body'),
}

async function getExperiment(ExperimentId: string): GetExperimentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getExperimentWithOptions(ExperimentId, headers, runtime);
}

async function getExperimentWithOptions(ExperimentId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetExperimentResponse {
  ExperimentId = OpenApiUtil.getEncodeParam(ExperimentId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetExperiment',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/experiments/${ExperimentId}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetExperimentFolderChildrenRequest {
  accessibility?: string(name='Accessibility'),
  onlyFolder?: boolean(name='OnlyFolder'),
  source?: string(name='Source'),
  userId?: string(name='UserId'),
  workspaceId?: string(name='WorkspaceId'),
}

model GetExperimentFolderChildrenResponseBody = {
  items?: [ 
    {
      empty?: boolean(name='Empty'),
      icon?: string(name='Icon'),
      id?: string(name='Id'),
      name?: string(name='Name'),
      type?: string(name='Type'),
    }
  ](name='Items'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model GetExperimentFolderChildrenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetExperimentFolderChildrenResponseBody(name='body'),
}

async function getExperimentFolderChildren(FolderId: string, request: GetExperimentFolderChildrenRequest): GetExperimentFolderChildrenResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getExperimentFolderChildrenWithOptions(FolderId, request, headers, runtime);
}

async function getExperimentFolderChildrenWithOptions(FolderId: string, request: GetExperimentFolderChildrenRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetExperimentFolderChildrenResponse {
  Util.validateModel(request);
  FolderId = OpenApiUtil.getEncodeParam(FolderId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessibility)) {
    query['Accessibility'] = request.accessibility;
  }
  if (!Util.isUnset(request.onlyFolder)) {
    query['OnlyFolder'] = request.onlyFolder;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetExperimentFolderChildren',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/experimentfolders/${FolderId}/children`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetExperimentMetaResponseBody = {
  accessibility?: string(name='Accessibility'),
  creator?: string(name='Creator'),
  description?: string(name='Description'),
  experimentId?: string(name='ExperimentId'),
  gmtCreateTime?: string(name='GmtCreateTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  name?: string(name='Name'),
  options?: string(name='Options'),
  requestId?: string(name='RequestId'),
  source?: string(name='Source'),
  version?: string(name='Version'),
  workspaceId?: string(name='WorkspaceId'),
}

model GetExperimentMetaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetExperimentMetaResponseBody(name='body'),
}

async function getExperimentMeta(ExperimentId: string): GetExperimentMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getExperimentMetaWithOptions(ExperimentId, headers, runtime);
}

async function getExperimentMetaWithOptions(ExperimentId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetExperimentMetaResponse {
  ExperimentId = OpenApiUtil.getEncodeParam(ExperimentId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetExperimentMeta',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/experiments/${ExperimentId}/meta`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetExperimentStatusResponseBody = {
  nodes?: [ 
    {
      finishedAt?: string(name='FinishedAt'),
      jobId?: string(name='JobId'),
      nodeId?: string(name='NodeId'),
      runId?: string(name='RunId'),
      runNodeId?: string(name='RunNodeId'),
      startedAt?: string(name='StartedAt'),
      status?: string(name='Status'),
    }
  ](name='Nodes'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
}

model GetExperimentStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetExperimentStatusResponseBody(name='body'),
}

async function getExperimentStatus(ExperimentId: string): GetExperimentStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getExperimentStatusWithOptions(ExperimentId, headers, runtime);
}

async function getExperimentStatusWithOptions(ExperimentId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetExperimentStatusResponse {
  ExperimentId = OpenApiUtil.getEncodeParam(ExperimentId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetExperimentStatus',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/experiments/${ExperimentId}/status`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetExperimentVisualizationMetaRequest {
  nodeIds?: string(name='NodeIds'),
}

model GetExperimentVisualizationMetaResponseBody = {
  visualizationMeta?: [ 
    {
      meta?: string(name='Meta'),
      nodeId?: string(name='NodeId'),
      nodeName?: string(name='NodeName'),
    }
  ](name='VisualizationMeta'),
  requestId?: string(name='requestId'),
}

model GetExperimentVisualizationMetaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetExperimentVisualizationMetaResponseBody(name='body'),
}

async function getExperimentVisualizationMeta(ExperimentId: string, request: GetExperimentVisualizationMetaRequest): GetExperimentVisualizationMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getExperimentVisualizationMetaWithOptions(ExperimentId, request, headers, runtime);
}

async function getExperimentVisualizationMetaWithOptions(ExperimentId: string, request: GetExperimentVisualizationMetaRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetExperimentVisualizationMetaResponse {
  Util.validateModel(request);
  ExperimentId = OpenApiUtil.getEncodeParam(ExperimentId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.nodeIds)) {
    query['NodeIds'] = request.nodeIds;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetExperimentVisualizationMeta',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/experiments/${ExperimentId}/visualizationMeta`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetExperimentsStatisticsRequest {
  source?: string(name='Source'),
  workspaceIds?: string(name='WorkspaceIds'),
}

model GetExperimentsStatisticsResponseBody = {
  data?: [ 
    {
      createCount?: long(name='CreateCount'),
      totalCount?: long(name='TotalCount'),
      workspaceId?: string(name='WorkspaceId'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
}

model GetExperimentsStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetExperimentsStatisticsResponseBody(name='body'),
}

async function getExperimentsStatistics(request: GetExperimentsStatisticsRequest): GetExperimentsStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getExperimentsStatisticsWithOptions(request, headers, runtime);
}

async function getExperimentsStatisticsWithOptions(request: GetExperimentsStatisticsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetExperimentsStatisticsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.workspaceIds)) {
    query['WorkspaceIds'] = request.workspaceIds;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetExperimentsStatistics',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/statistics/experiments`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetExperimentsUsersStatisticsRequest {
  source?: string(name='Source'),
  workspaceId?: string(name='WorkspaceId'),
}

model GetExperimentsUsersStatisticsResponseBody = {
  requestId?: string(name='RequestId'),
  users?: [ 
    {
      userId?: string(name='UserId'),
    }
  ](name='Users'),
}

model GetExperimentsUsersStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetExperimentsUsersStatisticsResponseBody(name='body'),
}

async function getExperimentsUsersStatistics(request: GetExperimentsUsersStatisticsRequest): GetExperimentsUsersStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getExperimentsUsersStatisticsWithOptions(request, headers, runtime);
}

async function getExperimentsUsersStatisticsWithOptions(request: GetExperimentsUsersStatisticsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetExperimentsUsersStatisticsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetExperimentsUsersStatistics',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/statistics/experimentsusers`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetImageRequest {
  verbose?: boolean(name='Verbose'),
}

model GetImageResponseBody = {
  description?: string(name='Description'),
  gmtCreateTime?: string(name='GmtCreateTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  imageUri?: string(name='ImageUri'),
  labels?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Labels'),
  name?: string(name='Name'),
  operatorCreate?: string(name='OperatorCreate'),
  parentOperatorCreate?: string(name='ParentOperatorCreate'),
  requestId?: string(name='requestId'),
}

model GetImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetImageResponseBody(name='body'),
}

async function getImage(ImageId: string, request: GetImageRequest): GetImageResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getImageWithOptions(ImageId, request, headers, runtime);
}

async function getImageWithOptions(ImageId: string, request: GetImageRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetImageResponse {
  Util.validateModel(request);
  ImageId = OpenApiUtil.getEncodeParam(ImageId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.verbose)) {
    query['Verbose'] = request.verbose;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetImage',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/images/${ImageId}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetJobRequest {
  verbose?: boolean(name='Verbose'),
}

model GetJobResponseBody = {
  arguments?: string(name='Arguments'),
  creator?: string(name='Creator'),
  executeType?: string(name='ExecuteType'),
  experimentId?: string(name='ExperimentId'),
  gmtCreateTime?: string(name='GmtCreateTime'),
  jobId?: string(name='JobId'),
  nodeId?: string(name='NodeId'),
  paiflowNodeId?: string(name='PaiflowNodeId'),
  requestId?: string(name='RequestId'),
  runId?: string(name='RunId'),
  runInfo?: string(name='RunInfo'),
  snapshot?: string(name='Snapshot'),
  status?: string(name='Status'),
  workspaceId?: string(name='WorkspaceId'),
}

model GetJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetJobResponseBody(name='body'),
}

async function getJob(JobId: string, request: GetJobRequest): GetJobResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getJobWithOptions(JobId, request, headers, runtime);
}

async function getJobWithOptions(JobId: string, request: GetJobRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetJobResponse {
  Util.validateModel(request);
  JobId = OpenApiUtil.getEncodeParam(JobId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.verbose)) {
    query['Verbose'] = request.verbose;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetJob',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/jobs/${JobId}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetMCTableSchemaRequest {
  workspaceId?: string(name='WorkspaceId'),
}

model GetMCTableSchemaResponseBody = {
  columns?: [ 
    {
      name?: string(name='Name'),
      preview?: [ string ](name='Preview'),
      type?: string(name='Type'),
    }
  ](name='Columns'),
  partitionColumns?: [ string ](name='PartitionColumns'),
  requestId?: string(name='RequestId'),
}

model GetMCTableSchemaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMCTableSchemaResponseBody(name='body'),
}

async function getMCTableSchema(TableName: string, request: GetMCTableSchemaRequest): GetMCTableSchemaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getMCTableSchemaWithOptions(TableName, request, headers, runtime);
}

async function getMCTableSchemaWithOptions(TableName: string, request: GetMCTableSchemaRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetMCTableSchemaResponse {
  Util.validateModel(request);
  TableName = OpenApiUtil.getEncodeParam(TableName);
  var query : map[string]any = {};
  if (!Util.isUnset(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMCTableSchema',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/datasources/maxcompute/tables/${TableName}/schema`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetNodeInputSchemaRequest {
  inputId?: string(name='InputId'),
  inputIndex?: int32(name='InputIndex'),
}

model GetNodeInputSchemaResponseBody = {
  colNames?: [ string ](name='ColNames'),
  colTypes?: [ string ](name='ColTypes'),
  requestId?: string(name='RequestId'),
}

model GetNodeInputSchemaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetNodeInputSchemaResponseBody(name='body'),
}

async function getNodeInputSchema(ExperimentId: string, NodeId: string, request: GetNodeInputSchemaRequest): GetNodeInputSchemaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getNodeInputSchemaWithOptions(ExperimentId, NodeId, request, headers, runtime);
}

async function getNodeInputSchemaWithOptions(ExperimentId: string, NodeId: string, request: GetNodeInputSchemaRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetNodeInputSchemaResponse {
  Util.validateModel(request);
  ExperimentId = OpenApiUtil.getEncodeParam(ExperimentId);
  NodeId = OpenApiUtil.getEncodeParam(NodeId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.inputId)) {
    query['InputId'] = request.inputId;
  }
  if (!Util.isUnset(request.inputIndex)) {
    query['InputIndex'] = request.inputIndex;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetNodeInputSchema',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/experiments/${ExperimentId}/nodes/${NodeId}/schema`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetNodeOutputRequest {
  outputIndex?: string(name='OutputIndex'),
}

model GetNodeOutputResponseBody = {
  algoName?: string(name='AlgoName'),
  displayName?: string(name='DisplayName'),
  locationType?: string(name='LocationType'),
  nodeName?: string(name='NodeName'),
  requestId?: string(name='RequestId'),
  type?: string(name='Type'),
  value?: map[string]any(name='Value'),
}

model GetNodeOutputResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetNodeOutputResponseBody(name='body'),
}

async function getNodeOutput(ExperimentId: string, NodeId: string, OutputId: string, request: GetNodeOutputRequest): GetNodeOutputResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getNodeOutputWithOptions(ExperimentId, NodeId, OutputId, request, headers, runtime);
}

async function getNodeOutputWithOptions(ExperimentId: string, NodeId: string, OutputId: string, request: GetNodeOutputRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetNodeOutputResponse {
  Util.validateModel(request);
  ExperimentId = OpenApiUtil.getEncodeParam(ExperimentId);
  NodeId = OpenApiUtil.getEncodeParam(NodeId);
  OutputId = OpenApiUtil.getEncodeParam(OutputId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.outputIndex)) {
    query['OutputIndex'] = request.outputIndex;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetNodeOutput',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/experiments/${ExperimentId}/nodes/${NodeId}/outputs/${OutputId}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetNodeVisualizationRequest {
  config?: string(name='Config'),
}

model GetNodeVisualizationResponseBody = {
  content?: string(name='Content'),
  requestId?: string(name='RequestId'),
  visualizationType?: string(name='VisualizationType'),
}

model GetNodeVisualizationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetNodeVisualizationResponseBody(name='body'),
}

async function getNodeVisualization(ExperimentId: string, NodeId: string, VisualizationId: string, request: GetNodeVisualizationRequest): GetNodeVisualizationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getNodeVisualizationWithOptions(ExperimentId, NodeId, VisualizationId, request, headers, runtime);
}

async function getNodeVisualizationWithOptions(ExperimentId: string, NodeId: string, VisualizationId: string, request: GetNodeVisualizationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetNodeVisualizationResponse {
  Util.validateModel(request);
  ExperimentId = OpenApiUtil.getEncodeParam(ExperimentId);
  NodeId = OpenApiUtil.getEncodeParam(NodeId);
  VisualizationId = OpenApiUtil.getEncodeParam(VisualizationId);
  var query : map[string]any = {};
  if (!Util.isUnset(request.config)) {
    query['Config'] = request.config;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetNodeVisualization',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/experiments/${ExperimentId}/nodes/${NodeId}/visualizations/${VisualizationId}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetTemplateResponseBody = {
  content?: string(name='Content'),
  description?: string(name='Description'),
  detail?: string(name='Detail'),
  docLink?: string(name='DocLink'),
  imageLink?: string(name='ImageLink'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
  templateId?: string(name='TemplateId'),
}

model GetTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTemplateResponseBody(name='body'),
}

async function getTemplate(TemplateId: string): GetTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTemplateWithOptions(TemplateId, headers, runtime);
}

async function getTemplateWithOptions(TemplateId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetTemplateResponse {
  TemplateId = OpenApiUtil.getEncodeParam(TemplateId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetTemplate',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/templates/${TemplateId}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListAlgoDefsRequest {
  body?: [ 
    {
      identifier?: string(name='Identifier'),
      provider?: string(name='Provider'),
      signature?: string(name='Signature'),
      version?: string(name='Version'),
    }
  ](name='body'),
}

model ListAlgoDefsResponseBody = {
  data?: [  map[string]any ](name='Data'),
  requestId?: string(name='RequestId'),
}

model ListAlgoDefsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAlgoDefsResponseBody(name='body'),
}

async function listAlgoDefs(request: ListAlgoDefsRequest): ListAlgoDefsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAlgoDefsWithOptions(request, headers, runtime);
}

async function listAlgoDefsWithOptions(request: ListAlgoDefsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAlgoDefsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = Util.toArray(request.body),
  };
  var params = new OpenApi.Params{
    action = 'ListAlgoDefs',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/algo/detail`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListAuthRolesRequest {
  isGenerateToken?: string(name='IsGenerateToken'),
  workspaceId?: string(name='WorkspaceId'),
}

model ListAuthRolesResponseBody = {
  requestId?: string(name='RequestId'),
  roles?: [ 
    {
      isEnabled?: string(name='IsEnabled'),
      roleARN?: string(name='RoleARN'),
      roleName?: string(name='RoleName'),
      roleType?: string(name='RoleType'),
      token?: {
        accessKeyId?: string(name='AccessKeyId'),
        accessKeySecret?: string(name='AccessKeySecret'),
        expiration?: string(name='Expiration'),
        securityToken?: string(name='SecurityToken'),
      }(name='Token'),
    }
  ](name='Roles'),
}

model ListAuthRolesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAuthRolesResponseBody(name='body'),
}

async function listAuthRoles(request: ListAuthRolesRequest): ListAuthRolesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAuthRolesWithOptions(request, headers, runtime);
}

async function listAuthRolesWithOptions(request: ListAuthRolesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAuthRolesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.isGenerateToken)) {
    query['IsGenerateToken'] = request.isGenerateToken;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAuthRoles',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/authorization/roles`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListExperimentsRequest {
  creator?: string(name='Creator'),
  experimentId?: string(name='ExperimentId'),
  name?: string(name='Name'),
  order?: string(name='Order'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  sortBy?: string(name='SortBy'),
  source?: string(name='Source'),
  workspaceId?: string(name='WorkspaceId'),
}

model ListExperimentsResponseBody = {
  experiments?: [ 
    {
      accessibility?: string(name='Accessibility'),
      creator?: string(name='Creator'),
      description?: string(name='Description'),
      experimentId?: string(name='ExperimentId'),
      gmtCreateTime?: string(name='GmtCreateTime'),
      gmtModifiedTime?: string(name='GmtModifiedTime'),
      name?: string(name='Name'),
      source?: string(name='Source'),
      version?: long(name='Version'),
      workspaceId?: string(name='WorkspaceId'),
    }
  ](name='Experiments'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model ListExperimentsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListExperimentsResponseBody(name='body'),
}

async function listExperiments(request: ListExperimentsRequest): ListExperimentsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listExperimentsWithOptions(request, headers, runtime);
}

async function listExperimentsWithOptions(request: ListExperimentsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListExperimentsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.creator)) {
    query['Creator'] = request.creator;
  }
  if (!Util.isUnset(request.experimentId)) {
    query['ExperimentId'] = request.experimentId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sortBy)) {
    query['SortBy'] = request.sortBy;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListExperiments',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/experiments`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListImageLabelsRequest {
  imageId?: string(name='ImageId'),
  labelFilter?: string(name='LabelFilter'),
  labelKeys?: string(name='LabelKeys'),
}

model ListImageLabelsResponseBody = {
  labels?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Labels'),
  totalCount?: long(name='TotalCount'),
  requestId?: string(name='requestId'),
}

model ListImageLabelsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListImageLabelsResponseBody(name='body'),
}

async function listImageLabels(request: ListImageLabelsRequest): ListImageLabelsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listImageLabelsWithOptions(request, headers, runtime);
}

async function listImageLabelsWithOptions(request: ListImageLabelsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListImageLabelsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.imageId)) {
    query['ImageId'] = request.imageId;
  }
  if (!Util.isUnset(request.labelFilter)) {
    query['LabelFilter'] = request.labelFilter;
  }
  if (!Util.isUnset(request.labelKeys)) {
    query['LabelKeys'] = request.labelKeys;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListImageLabels',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/image/labels`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListImagesRequest {
  labels?: string(name='Labels'),
  name?: string(name='Name'),
  order?: string(name='Order'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  sortBy?: string(name='SortBy'),
  verbose?: boolean(name='Verbose'),
}

model ListImagesResponseBody = {
  images?: [ 
    {
      description?: string(name='Description'),
      gmtCreateTime?: string(name='GmtCreateTime'),
      imageId?: string(name='ImageId'),
      imageUri?: string(name='ImageUri'),
      labels?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Labels'),
      name?: string(name='Name'),
    }
  ](name='Images'),
  totalCount?: long(name='TotalCount'),
  requestId?: string(name='requestId'),
}

model ListImagesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListImagesResponseBody(name='body'),
}

async function listImages(request: ListImagesRequest): ListImagesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listImagesWithOptions(request, headers, runtime);
}

async function listImagesWithOptions(request: ListImagesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListImagesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.labels)) {
    query['Labels'] = request.labels;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sortBy)) {
    query['SortBy'] = request.sortBy;
  }
  if (!Util.isUnset(request.verbose)) {
    query['Verbose'] = request.verbose;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListImages',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/images`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListJobsRequest {
  creator?: string(name='Creator'),
  experimentId?: string(name='ExperimentId'),
  order?: string(name='Order'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListJobsResponseBody = {
  jobs?: [ 
    {
      creator?: string(name='Creator'),
      executeType?: string(name='ExecuteType'),
      experimentId?: string(name='ExperimentId'),
      gmtCreateTime?: string(name='GmtCreateTime'),
      jobId?: string(name='JobId'),
      nodeId?: string(name='NodeId'),
      paiflowNodeId?: string(name='PaiflowNodeId'),
      runId?: string(name='RunId'),
      status?: string(name='Status'),
      workspaceId?: string(name='WorkspaceId'),
    }
  ](name='Jobs'),
  requestId?: string(name='RequestId'),
}

model ListJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListJobsResponseBody(name='body'),
}

async function listJobs(request: ListJobsRequest): ListJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listJobsWithOptions(request, headers, runtime);
}

async function listJobsWithOptions(request: ListJobsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListJobsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.creator)) {
    query['Creator'] = request.creator;
  }
  if (!Util.isUnset(request.experimentId)) {
    query['ExperimentId'] = request.experimentId;
  }
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListJobs',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/jobs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListNodeOutputsResponseBody = {
  outputs?: [ 
    {
      algoName?: string(name='AlgoName'),
      displayName?: string(name='DisplayName'),
      locationType?: string(name='LocationType'),
      nodeName?: string(name='NodeName'),
      outputId?: string(name='OutputId'),
      outputIndex?: string(name='OutputIndex'),
      type?: string(name='Type'),
      value?: map[string]any(name='Value'),
    }
  ](name='Outputs'),
  requestId?: string(name='RequestId'),
}

model ListNodeOutputsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListNodeOutputsResponseBody(name='body'),
}

async function listNodeOutputs(ExperimentId: string, NodeId: string): ListNodeOutputsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listNodeOutputsWithOptions(ExperimentId, NodeId, headers, runtime);
}

async function listNodeOutputsWithOptions(ExperimentId: string, NodeId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListNodeOutputsResponse {
  ExperimentId = OpenApiUtil.getEncodeParam(ExperimentId);
  NodeId = OpenApiUtil.getEncodeParam(NodeId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListNodeOutputs',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/experiments/${ExperimentId}/nodes/${NodeId}/outputs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListRecentExperimentsRequest {
  order?: string(name='Order'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  source?: string(name='Source'),
  type?: string(name='Type'),
  workspaceId?: string(name='WorkspaceId'),
}

model ListRecentExperimentsResponseBody = {
  experiments?: [ 
    {
      description?: string(name='Description'),
      experimentId?: string(name='ExperimentId'),
      modifyCnt?: long(name='ModifyCnt'),
      name?: string(name='Name'),
      recentGmtModifiedTime?: string(name='RecentGmtModifiedTime'),
      source?: string(name='Source'),
      workspaceId?: string(name='WorkspaceId'),
      workspaceName?: string(name='WorkspaceName'),
    }
  ](name='Experiments'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model ListRecentExperimentsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRecentExperimentsResponseBody(name='body'),
}

async function listRecentExperiments(request: ListRecentExperimentsRequest): ListRecentExperimentsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRecentExperimentsWithOptions(request, headers, runtime);
}

async function listRecentExperimentsWithOptions(request: ListRecentExperimentsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRecentExperimentsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRecentExperiments',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/recentexperiments`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListTemplatesRequest {
  list?: string(name='List'),
  order?: string(name='Order'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  source?: string(name='Source'),
  tagId?: string(name='TagId'),
  typeId?: string(name='TypeId'),
}

model ListTemplatesResponseBody = {
  requestId?: string(name='RequestId'),
  templateData?: [ 
    {
      template?: {
        content?: string(name='Content'),
        description?: string(name='Description'),
        detail?: string(name='Detail'),
        docLink?: string(name='DocLink'),
        imageLink?: string(name='ImageLink'),
        name?: string(name='Name'),
        templateId?: string(name='TemplateId'),
      }(name='Template'),
      templateTag?: {
        name?: string(name='Name'),
        tagId?: string(name='TagId'),
        typeId?: string(name='TypeId'),
      }(name='TemplateTag'),
      templateType?: {
        name?: string(name='Name'),
        typeId?: string(name='TypeId'),
      }(name='TemplateType'),
    }
  ](name='TemplateData'),
  totalCount?: int32(name='TotalCount'),
}

model ListTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTemplatesResponseBody(name='body'),
}

async function listTemplates(request: ListTemplatesRequest): ListTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTemplatesWithOptions(request, headers, runtime);
}

async function listTemplatesWithOptions(request: ListTemplatesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTemplatesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.list)) {
    query['List'] = request.list;
  }
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.tagId)) {
    query['TagId'] = request.tagId;
  }
  if (!Util.isUnset(request.typeId)) {
    query['TypeId'] = request.typeId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTemplates',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/templates`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model MigrateExperimentFoldersRequest {
  accessibility?: string(name='Accessibility'),
  isOwner?: boolean(name='IsOwner'),
  workspaceId?: string(name='WorkspaceId'),
}

model MigrateExperimentFoldersResponseBody = {
  code?: string(name='Code'),
  folderIdMapping?: map[string]object(name='FolderIdMapping'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model MigrateExperimentFoldersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MigrateExperimentFoldersResponseBody(name='body'),
}

async function migrateExperimentFolders(request: MigrateExperimentFoldersRequest): MigrateExperimentFoldersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return migrateExperimentFoldersWithOptions(request, headers, runtime);
}

async function migrateExperimentFoldersWithOptions(request: MigrateExperimentFoldersRequest, headers: map[string]string, runtime: Util.RuntimeOptions): MigrateExperimentFoldersResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessibility)) {
    query['Accessibility'] = request.accessibility;
  }
  if (!Util.isUnset(request.isOwner)) {
    query['IsOwner'] = request.isOwner;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'MigrateExperimentFolders',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/migrate/folders`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model MigrateExperimentsRequest {
  accessibility?: string(name='Accessibility'),
  destFolderId?: string(name='DestFolderId'),
  isOwner?: boolean(name='IsOwner'),
  sourceExpId?: long(name='SourceExpId'),
  updateIfExists?: boolean(name='UpdateIfExists'),
  workspaceId?: string(name='WorkspaceId'),
}

model MigrateExperimentsResponseBody = {
  code?: string(name='Code'),
  data?: {
    alreadyExists?: boolean(name='AlreadyExists'),
    experimentId?: string(name='ExperimentId'),
    updated?: boolean(name='Updated'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model MigrateExperimentsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MigrateExperimentsResponseBody(name='body'),
}

async function migrateExperiments(request: MigrateExperimentsRequest): MigrateExperimentsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return migrateExperimentsWithOptions(request, headers, runtime);
}

async function migrateExperimentsWithOptions(request: MigrateExperimentsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): MigrateExperimentsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessibility)) {
    query['Accessibility'] = request.accessibility;
  }
  if (!Util.isUnset(request.destFolderId)) {
    query['DestFolderId'] = request.destFolderId;
  }
  if (!Util.isUnset(request.isOwner)) {
    query['IsOwner'] = request.isOwner;
  }
  if (!Util.isUnset(request.sourceExpId)) {
    query['SourceExpId'] = request.sourceExpId;
  }
  if (!Util.isUnset(request.updateIfExists)) {
    query['UpdateIfExists'] = request.updateIfExists;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'MigrateExperiments',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/migrate/experiments`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model PreviewMCTableRequest {
  endpoint?: string(name='Endpoint'),
  partition?: string(name='Partition'),
  workspaceId?: string(name='WorkspaceId'),
}

model PreviewMCTableResponseBody = {
  content?: [[ string ]  ](name='Content'),
  requestId?: string(name='RequestId'),
}

model PreviewMCTableResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PreviewMCTableResponseBody(name='body'),
}

async function previewMCTable(TableName: string, request: PreviewMCTableRequest): PreviewMCTableResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return previewMCTableWithOptions(TableName, request, headers, runtime);
}

async function previewMCTableWithOptions(TableName: string, request: PreviewMCTableRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PreviewMCTableResponse {
  Util.validateModel(request);
  TableName = OpenApiUtil.getEncodeParam(TableName);
  var query : map[string]any = {};
  if (!Util.isUnset(request.endpoint)) {
    query['Endpoint'] = request.endpoint;
  }
  if (!Util.isUnset(request.partition)) {
    query['Partition'] = request.partition;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PreviewMCTable',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/datasources/maxcompute/tables/${TableName}/preview`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model PublishExperimentRequest {
  folderId?: string(name='FolderId'),
}

model PublishExperimentResponseBody = {
  requestId?: string(name='RequestId'),
}

model PublishExperimentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PublishExperimentResponseBody(name='body'),
}

async function publishExperiment(ExperimentId: string, request: PublishExperimentRequest): PublishExperimentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return publishExperimentWithOptions(ExperimentId, request, headers, runtime);
}

async function publishExperimentWithOptions(ExperimentId: string, request: PublishExperimentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PublishExperimentResponse {
  Util.validateModel(request);
  ExperimentId = OpenApiUtil.getEncodeParam(ExperimentId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.folderId)) {
    body['FolderId'] = request.folderId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PublishExperiment',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/experiments/${ExperimentId}/publish`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model QueryExperimentVisualizationDataRequest {
  body?: [ 
    {
      endTime?: string(name='EndTime'),
      nodeId?: string(name='NodeId'),
      startTime?: string(name='StartTime'),
      visualizationDataIds?: [ string ](name='VisualizationDataIds'),
    }
  ](name='body'),
}

model QueryExperimentVisualizationDataResponseBody = {
  visualizationData?: [ 
    {
      createTime?: string(name='CreateTime'),
      data?: string(name='Data'),
      dataId?: string(name='DataId'),
      nodeId?: string(name='NodeId'),
    }
  ](name='VisualizationData'),
  requestId?: string(name='requestId'),
}

model QueryExperimentVisualizationDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryExperimentVisualizationDataResponseBody(name='body'),
}

async function queryExperimentVisualizationData(ExperimentId: string, request: QueryExperimentVisualizationDataRequest): QueryExperimentVisualizationDataResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryExperimentVisualizationDataWithOptions(ExperimentId, request, headers, runtime);
}

async function queryExperimentVisualizationDataWithOptions(ExperimentId: string, request: QueryExperimentVisualizationDataRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryExperimentVisualizationDataResponse {
  Util.validateModel(request);
  ExperimentId = OpenApiUtil.getEncodeParam(ExperimentId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = Util.toArray(request.body),
  };
  var params = new OpenApi.Params{
    action = 'QueryExperimentVisualizationData',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/experiments/${ExperimentId}/visualizationDataQuery`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RemoveImageResponseBody = {
  requestId?: string(name='requestId'),
}

model RemoveImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveImageResponseBody(name='body'),
}

async function removeImage(ImageId: string): RemoveImageResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return removeImageWithOptions(ImageId, headers, runtime);
}

async function removeImageWithOptions(ImageId: string, headers: map[string]string, runtime: Util.RuntimeOptions): RemoveImageResponse {
  ImageId = OpenApiUtil.getEncodeParam(ImageId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'RemoveImage',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/images/${ImageId}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RemoveImageLabelsResponseBody = {
  requestId?: string(name='requestId'),
}

model RemoveImageLabelsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveImageLabelsResponseBody(name='body'),
}

async function removeImageLabels(ImageId: string, LabelKey: string): RemoveImageLabelsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return removeImageLabelsWithOptions(ImageId, LabelKey, headers, runtime);
}

async function removeImageLabelsWithOptions(ImageId: string, LabelKey: string, headers: map[string]string, runtime: Util.RuntimeOptions): RemoveImageLabelsResponse {
  ImageId = OpenApiUtil.getEncodeParam(ImageId);
  LabelKey = OpenApiUtil.getEncodeParam(LabelKey);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'RemoveImageLabels',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/images/${ImageId}/labels/${LabelKey}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model SearchMCTablesRequest {
  keyword?: string(name='Keyword'),
  workspaceId?: string(name='WorkspaceId'),
}

model SearchMCTablesResponseBody = {
  requestId?: string(name='RequestId'),
  tables?: [ string ](name='Tables'),
}

model SearchMCTablesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchMCTablesResponseBody(name='body'),
}

async function searchMCTables(request: SearchMCTablesRequest): SearchMCTablesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return searchMCTablesWithOptions(request, headers, runtime);
}

async function searchMCTablesWithOptions(request: SearchMCTablesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SearchMCTablesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchMCTables',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/datasources/maxcompute/tables`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model StopExperimentResponseBody = {
  requestId?: string(name='RequestId'),
}

model StopExperimentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopExperimentResponseBody(name='body'),
}

async function stopExperiment(ExperimentId: string): StopExperimentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopExperimentWithOptions(ExperimentId, headers, runtime);
}

async function stopExperimentWithOptions(ExperimentId: string, headers: map[string]string, runtime: Util.RuntimeOptions): StopExperimentResponse {
  ExperimentId = OpenApiUtil.getEncodeParam(ExperimentId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StopExperiment',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/experiments/${ExperimentId}/stop`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model StopJobResponseBody = {
  requestId?: string(name='RequestId'),
}

model StopJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopJobResponseBody(name='body'),
}

async function stopJob(JobId: string): StopJobResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopJobWithOptions(JobId, headers, runtime);
}

async function stopJobWithOptions(JobId: string, headers: map[string]string, runtime: Util.RuntimeOptions): StopJobResponse {
  JobId = OpenApiUtil.getEncodeParam(JobId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StopJob',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/jobs/${JobId}/stop`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateExperimentContentRequest {
  content?: string(name='Content'),
  version?: long(name='Version'),
}

model UpdateExperimentContentResponseBody = {
  requestId?: string(name='RequestId'),
  version?: long(name='Version'),
}

model UpdateExperimentContentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateExperimentContentResponseBody(name='body'),
}

async function updateExperimentContent(ExperimentId: string, request: UpdateExperimentContentRequest): UpdateExperimentContentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateExperimentContentWithOptions(ExperimentId, request, headers, runtime);
}

async function updateExperimentContentWithOptions(ExperimentId: string, request: UpdateExperimentContentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateExperimentContentResponse {
  Util.validateModel(request);
  ExperimentId = OpenApiUtil.getEncodeParam(ExperimentId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.content)) {
    body['Content'] = request.content;
  }
  if (!Util.isUnset(request.version)) {
    body['Version'] = request.version;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateExperimentContent',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/experiments/${ExperimentId}/content`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateExperimentFolderRequest {
  name?: string(name='Name'),
  parentFolderId?: string(name='ParentFolderId'),
}

model UpdateExperimentFolderResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateExperimentFolderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateExperimentFolderResponseBody(name='body'),
}

async function updateExperimentFolder(FolderId: string, request: UpdateExperimentFolderRequest): UpdateExperimentFolderResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateExperimentFolderWithOptions(FolderId, request, headers, runtime);
}

async function updateExperimentFolderWithOptions(FolderId: string, request: UpdateExperimentFolderRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateExperimentFolderResponse {
  Util.validateModel(request);
  FolderId = OpenApiUtil.getEncodeParam(FolderId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.parentFolderId)) {
    body['ParentFolderId'] = request.parentFolderId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateExperimentFolder',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/experimentfolders/${FolderId}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateExperimentMetaRequest {
  accessibility?: string(name='Accessibility'),
  description?: string(name='Description'),
  folderId?: string(name='FolderId'),
  name?: string(name='Name'),
  options?: string(name='Options'),
}

model UpdateExperimentMetaResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateExperimentMetaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateExperimentMetaResponseBody(name='body'),
}

async function updateExperimentMeta(ExperimentId: string, request: UpdateExperimentMetaRequest): UpdateExperimentMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateExperimentMetaWithOptions(ExperimentId, request, headers, runtime);
}

async function updateExperimentMetaWithOptions(ExperimentId: string, request: UpdateExperimentMetaRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateExperimentMetaResponse {
  Util.validateModel(request);
  ExperimentId = OpenApiUtil.getEncodeParam(ExperimentId);
  var body : map[string]any = {};
  if (!Util.isUnset(request.accessibility)) {
    body['Accessibility'] = request.accessibility;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.folderId)) {
    body['FolderId'] = request.folderId;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.options)) {
    body['Options'] = request.options;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateExperimentMeta',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/experiments/${ExperimentId}/meta`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

