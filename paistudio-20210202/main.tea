/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  @endpointMap = {
    cn-beijing = 'pai.cn-beijing.aliyuncs.com',
    cn-hangzhou = 'pai.cn-hangzhou.aliyuncs.com',
    cn-shanghai = 'pai.cn-shanghai.aliyuncs.com',
    cn-shenzhen = 'pai.cn-shenzhen.aliyuncs.com',
    cn-hongkong = 'pai.cn-hongkong.aliyuncs.com',
    ap-southeast-1 = 'pai.ap-southeast-1.aliyuncs.com',
    ap-southeast-2 = 'pai.ap-southeast-2.aliyuncs.com',
    ap-southeast-3 = 'pai.ap-southeast-3.aliyuncs.com',
    ap-southeast-5 = 'pai.ap-southeast-5.aliyuncs.com',
    us-west-1 = 'pai.us-west-1.aliyuncs.com',
    us-east-1 = 'pai.us-east-1.aliyuncs.com',
    eu-central-1 = 'pai.eu-central-1.aliyuncs.com',
    me-east-1 = 'pai.me-east-1.aliyuncs.com',
    ap-south-1 = 'pai.ap-south-1.aliyuncs.com',
    cn-qingdao = 'pai.cn-qingdao.aliyuncs.com',
    cn-zhangjiakou = 'pai.cn-zhangjiakou.aliyuncs.com',
  };
  checkConfig(config);
  @endpoint = getEndpoint('paistudio', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model AddImageRequest {
  name?: string(name='Name', description='镜像名称'),
  description?: string(name='Description', description='镜像描述'),
  imageUri?: string(name='ImageUri', description='镜像地址'),
  labels?: [ 
    {
      key?: string(name='Key', description='Key'),
      value?: string(name='Value', description='Value'),
    }
  ](name='Labels', description='镜像标签，是个数组'),
}

model AddImageResponseBody = {
  requestId?: string(name='requestId', description='Id of the request'),
  imageId?: string(name='ImageId', description='镜像 id'),
}

model AddImageResponse = {
  headers: map[string]string(name='headers'),
  body: AddImageResponseBody(name='body'),
}

async function addImage(request: AddImageRequest): AddImageResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addImageWithOptions(request, headers, runtime);
}

async function addImageWithOptions(request: AddImageRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddImageResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.name)) {
    body.Name = request.name;
  }
  if (!Util.isUnset(request.description)) {
    body.Description = request.description;
  }
  if (!Util.isUnset(request.imageUri)) {
    body.ImageUri = request.imageUri;
  }
  if (!Util.isUnset(request.labels)) {
    body.Labels = request.labels;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('AddImage', '2021-02-02', 'HTTPS', 'POST', 'AK', `/api/v1/images`, 'json', req, runtime);
}

model AddImageLabelsRequest {
  labels?: [ 
    {
      key?: string(name='Key', description='Key'),
      value?: string(name='Value', description='Value'),
    }
  ](name='Labels', description='标签'),
}

model AddImageLabelsResponseBody = {
  requestId?: string(name='requestId', description='Id of the request'),
}

model AddImageLabelsResponse = {
  headers: map[string]string(name='headers'),
  body: AddImageLabelsResponseBody(name='body'),
}

async function addImageLabels(ImageId: string, request: AddImageLabelsRequest): AddImageLabelsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addImageLabelsWithOptions(ImageId, request, headers, runtime);
}

async function addImageLabelsWithOptions(ImageId: string, request: AddImageLabelsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddImageLabelsResponse {
  Util.validateModel(request);
  ImageId = OpenApiUtil.getEncodeParam(ImageId);
  var body : map[string]any= {};
  if (!Util.isUnset(request.labels)) {
    body.Labels = request.labels;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('AddImageLabels', '2021-02-02', 'HTTPS', 'POST', 'AK', `/api/v1/images/${ImageId}/labels`, 'json', req, runtime);
}

model CopyExperimentRequest {
  name?: string(name='Name', description='实验名称，最大长度 128，可包含中英文'),
  description?: string(name='Description', description='实验描述'),
  source?: string(name='Source', description='实验来源，目前 PaiStudio，data-airec（推荐白盒）'),
  folderId?: string(name='FolderId', description='实验创建的目录 id'),
  workspaceId?: string(name='WorkspaceId', description='实验创建的Workspace'),
}

model CopyExperimentResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  experimentId?: string(name='ExperimentId'),
}

model CopyExperimentResponse = {
  headers: map[string]string(name='headers'),
  body: CopyExperimentResponseBody(name='body'),
}

async function copyExperiment(ExperimentId: string, request: CopyExperimentRequest): CopyExperimentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return copyExperimentWithOptions(ExperimentId, request, headers, runtime);
}

async function copyExperimentWithOptions(ExperimentId: string, request: CopyExperimentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CopyExperimentResponse {
  Util.validateModel(request);
  ExperimentId = OpenApiUtil.getEncodeParam(ExperimentId);
  var body : map[string]any= {};
  if (!Util.isUnset(request.name)) {
    body.Name = request.name;
  }
  if (!Util.isUnset(request.description)) {
    body.Description = request.description;
  }
  if (!Util.isUnset(request.source)) {
    body.Source = request.source;
  }
  if (!Util.isUnset(request.folderId)) {
    body.FolderId = request.folderId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body.WorkspaceId = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('CopyExperiment', '2021-02-02', 'HTTPS', 'POST', 'AK', `/api/v1/experiments/[ExperimentId]/copy`, 'json', req, runtime);
}

model CreateExperimentRequest {
  name?: string(name='Name'),
  description?: string(name='Description'),
  source?: string(name='Source'),
  folderId?: string(name='FolderId'),
  workspaceId?: string(name='WorkspaceId'),
  templateId?: string(name='TemplateId'),
  options?: string(name='Options'),
}

model CreateExperimentResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  experimentId?: string(name='ExperimentId'),
}

model CreateExperimentResponse = {
  headers: map[string]string(name='headers'),
  body: CreateExperimentResponseBody(name='body'),
}

async function createExperiment(request: CreateExperimentRequest): CreateExperimentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createExperimentWithOptions(request, headers, runtime);
}

async function createExperimentWithOptions(request: CreateExperimentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateExperimentResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.name)) {
    body.Name = request.name;
  }
  if (!Util.isUnset(request.description)) {
    body.Description = request.description;
  }
  if (!Util.isUnset(request.source)) {
    body.Source = request.source;
  }
  if (!Util.isUnset(request.folderId)) {
    body.FolderId = request.folderId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body.WorkspaceId = request.workspaceId;
  }
  if (!Util.isUnset(request.templateId)) {
    body.TemplateId = request.templateId;
  }
  if (!Util.isUnset(request.options)) {
    body.Options = request.options;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('CreateExperiment', '2021-02-02', 'HTTPS', 'POST', 'AK', `/api/v1/experiments`, 'json', req, runtime);
}

model CreateExperimentFolderRequest {
  workspaceId?: string(name='WorkspaceId'),
  name?: string(name='Name'),
  parentFolderId?: string(name='ParentFolderId'),
  source?: string(name='Source'),
}

model CreateExperimentFolderResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  folderId?: string(name='FolderId'),
}

model CreateExperimentFolderResponse = {
  headers: map[string]string(name='headers'),
  body: CreateExperimentFolderResponseBody(name='body'),
}

async function createExperimentFolder(request: CreateExperimentFolderRequest): CreateExperimentFolderResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createExperimentFolderWithOptions(request, headers, runtime);
}

async function createExperimentFolderWithOptions(request: CreateExperimentFolderRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateExperimentFolderResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.workspaceId)) {
    body.WorkspaceId = request.workspaceId;
  }
  if (!Util.isUnset(request.name)) {
    body.Name = request.name;
  }
  if (!Util.isUnset(request.parentFolderId)) {
    body.ParentFolderId = request.parentFolderId;
  }
  if (!Util.isUnset(request.source)) {
    body.Source = request.source;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('CreateExperimentFolder', '2021-02-02', 'HTTPS', 'POST', 'AK', `/api/v1/experimentfolders`, 'json', req, runtime);
}

model CreateJobRequest {
  experimentId?: string(name='ExperimentId'),
  executeType?: string(name='ExecuteType'),
  nodeId?: string(name='NodeId'),
  options?: string(name='Options'),
}

model CreateJobResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  jobId?: string(name='JobId'),
}

model CreateJobResponse = {
  headers: map[string]string(name='headers'),
  body: CreateJobResponseBody(name='body'),
}

async function createJob(request: CreateJobRequest): CreateJobResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createJobWithOptions(request, headers, runtime);
}

async function createJobWithOptions(request: CreateJobRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateJobResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.experimentId)) {
    body.ExperimentId = request.experimentId;
  }
  if (!Util.isUnset(request.executeType)) {
    body.ExecuteType = request.executeType;
  }
  if (!Util.isUnset(request.nodeId)) {
    body.NodeId = request.nodeId;
  }
  if (!Util.isUnset(request.options)) {
    body.Options = request.options;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('CreateJob', '2021-02-02', 'HTTPS', 'POST', 'AK', `/api/v1/jobs`, 'json', req, runtime);
}

model CreateServiceRequest {
  serviceType?: string(name='ServiceType'),
  config?: {
    logDirectory?: string(name='LogDirectory'),
  }(name='Config'),
}

model CreateServiceResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  url?: string(name='Url'),
  serviceId?: string(name='ServiceId'),
}

model CreateServiceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateServiceResponseBody(name='body'),
}

async function createService(request: CreateServiceRequest): CreateServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createServiceWithOptions(request, headers, runtime);
}

async function createServiceWithOptions(request: CreateServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateServiceResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.serviceType)) {
    body.ServiceType = request.serviceType;
  }
  if (!Util.isUnset(request.config)) {
    body.Config = request.config;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('CreateService', '2021-02-02', 'HTTPS', 'POST', 'AK', `/api/v1/services`, 'json', req, runtime);
}

model DeleteExperimentResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteExperimentResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteExperimentResponseBody(name='body'),
}

async function deleteExperiment(ExperimentId: string): DeleteExperimentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteExperimentWithOptions(ExperimentId, headers, runtime);
}

async function deleteExperimentWithOptions(ExperimentId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteExperimentResponse {
  ExperimentId = OpenApiUtil.getEncodeParam(ExperimentId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('DeleteExperiment', '2021-02-02', 'HTTPS', 'DELETE', 'AK', `/api/v1/experiments/${ExperimentId}`, 'json', req, runtime);
}

model DeleteExperimentFolderResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteExperimentFolderResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteExperimentFolderResponseBody(name='body'),
}

async function deleteExperimentFolder(FolderId: string): DeleteExperimentFolderResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteExperimentFolderWithOptions(FolderId, headers, runtime);
}

async function deleteExperimentFolderWithOptions(FolderId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteExperimentFolderResponse {
  FolderId = OpenApiUtil.getEncodeParam(FolderId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('DeleteExperimentFolder', '2021-02-02', 'HTTPS', 'DELETE', 'AK', `/api/v1/experimentfolders/${FolderId}`, 'json', req, runtime);
}

model DeleteServiceResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteServiceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteServiceResponseBody(name='body'),
}

async function deleteService(ServiceId: string): DeleteServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteServiceWithOptions(ServiceId, headers, runtime);
}

async function deleteServiceWithOptions(ServiceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteServiceResponse {
  ServiceId = OpenApiUtil.getEncodeParam(ServiceId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('DeleteService', '2021-02-02', 'HTTPS', 'DELETE', 'AK', `/api/v1/services/${ServiceId}`, 'json', req, runtime);
}

model GetAlgorithmDefRequest {
  provider?: string(name='Provider'),
  identifier?: string(name='Identifier'),
  algoVersion?: string(name='AlgoVersion'),
  signature?: string(name='Signature'),
}

model GetAlgorithmDefResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  spec?: map[string]any(name='Spec'),
}

model GetAlgorithmDefResponse = {
  headers: map[string]string(name='headers'),
  body: GetAlgorithmDefResponseBody(name='body'),
}

async function getAlgorithmDef(request: GetAlgorithmDefRequest): GetAlgorithmDefResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAlgorithmDefWithOptions(request, headers, runtime);
}

async function getAlgorithmDefWithOptions(request: GetAlgorithmDefRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetAlgorithmDefResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.provider)) {
    query.Provider = request.provider;
  }
  if (!Util.isUnset(request.identifier)) {
    query.Identifier = request.identifier;
  }
  if (!Util.isUnset(request.algoVersion)) {
    query.AlgoVersion = request.algoVersion;
  }
  if (!Util.isUnset(request.signature)) {
    query.Signature = request.signature;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetAlgorithmDef', '2021-02-02', 'HTTPS', 'GET', 'AK', `/api/v1/algorithm/def`, 'json', req, runtime);
}

model GetAlgorithmDefsRequest {
  timestamp?: string(name='Timestamp'),
  latestTimestamp?: string(name='LatestTimestamp'),
  rangeStart?: int32(name='RangeStart'),
  rangeEnd?: int32(name='RangeEnd'),
}

model GetAlgorithmDefsResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  specs?: [  map[string]any ](name='Specs'),
}

model GetAlgorithmDefsResponse = {
  headers: map[string]string(name='headers'),
  body: GetAlgorithmDefsResponseBody(name='body'),
}

async function getAlgorithmDefs(request: GetAlgorithmDefsRequest): GetAlgorithmDefsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAlgorithmDefsWithOptions(request, headers, runtime);
}

async function getAlgorithmDefsWithOptions(request: GetAlgorithmDefsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetAlgorithmDefsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.timestamp)) {
    query.Timestamp = request.timestamp;
  }
  if (!Util.isUnset(request.latestTimestamp)) {
    query.LatestTimestamp = request.latestTimestamp;
  }
  if (!Util.isUnset(request.rangeStart)) {
    query.RangeStart = request.rangeStart;
  }
  if (!Util.isUnset(request.rangeEnd)) {
    query.RangeEnd = request.rangeEnd;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetAlgorithmDefs', '2021-02-02', 'HTTPS', 'GET', 'AK', `/api/v1/algorithm/defs`, 'json', req, runtime);
}

model GetAlgorithmTreeRequest {
  source?: string(name='Source'),
}

model GetAlgorithmTreeResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  tree?: [  map[string]any ](name='Tree'),
  timestamp?: string(name='Timestamp'),
}

model GetAlgorithmTreeResponse = {
  headers: map[string]string(name='headers'),
  body: GetAlgorithmTreeResponseBody(name='body'),
}

async function getAlgorithmTree(request: GetAlgorithmTreeRequest): GetAlgorithmTreeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAlgorithmTreeWithOptions(request, headers, runtime);
}

async function getAlgorithmTreeWithOptions(request: GetAlgorithmTreeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetAlgorithmTreeResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.source)) {
    query.Source = request.source;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetAlgorithmTree', '2021-02-02', 'HTTPS', 'GET', 'AK', `/api/v1/algorithm/tree`, 'json', req, runtime);
}

model GetAlgoTreeRequest {
  source?: string(name='Source'),
}

model GetAlgoTreeResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  data?: map[string]any(name='Data'),
}

model GetAlgoTreeResponse = {
  headers: map[string]string(name='headers'),
  body: GetAlgoTreeResponseBody(name='body'),
}

async function getAlgoTree(request: GetAlgoTreeRequest): GetAlgoTreeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAlgoTreeWithOptions(request, headers, runtime);
}

async function getAlgoTreeWithOptions(request: GetAlgoTreeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetAlgoTreeResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.source)) {
    query.Source = request.source;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetAlgoTree', '2021-02-02', 'HTTPS', 'GET', 'AK', `/api/v1/algo/tree`, 'json', req, runtime);
}

model GetExperimentResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  experimentId?: string(name='ExperimentId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  gmtCreateTime?: string(name='GmtCreateTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  creator?: string(name='Creator'),
  source?: string(name='Source'),
  version?: long(name='Version'),
  workspaceId?: string(name='WorkspaceId'),
  content?: string(name='Content'),
  options?: string(name='Options'),
}

model GetExperimentResponse = {
  headers: map[string]string(name='headers'),
  body: GetExperimentResponseBody(name='body'),
}

async function getExperiment(ExperimentId: string): GetExperimentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getExperimentWithOptions(ExperimentId, headers, runtime);
}

async function getExperimentWithOptions(ExperimentId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetExperimentResponse {
  ExperimentId = OpenApiUtil.getEncodeParam(ExperimentId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('GetExperiment', '2021-02-02', 'HTTPS', 'GET', 'AK', `/api/v1/experiments/${ExperimentId}`, 'json', req, runtime);
}

model GetExperimentFolderChildrenRequest {
  workspaceId?: string(name='WorkspaceId'),
  onlyFolder?: boolean(name='OnlyFolder'),
}

model GetExperimentFolderChildrenResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  totalCount?: int32(name='TotalCount'),
  items?: [ 
    {
      id?: string(name='Id'),
      name?: string(name='Name'),
      type?: string(name='Type'),
      icon?: string(name='Icon'),
      empty?: boolean(name='Empty'),
    }
  ](name='Items'),
}

model GetExperimentFolderChildrenResponse = {
  headers: map[string]string(name='headers'),
  body: GetExperimentFolderChildrenResponseBody(name='body'),
}

async function getExperimentFolderChildren(FolderId: string, request: GetExperimentFolderChildrenRequest): GetExperimentFolderChildrenResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getExperimentFolderChildrenWithOptions(FolderId, request, headers, runtime);
}

async function getExperimentFolderChildrenWithOptions(FolderId: string, request: GetExperimentFolderChildrenRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetExperimentFolderChildrenResponse {
  Util.validateModel(request);
  FolderId = OpenApiUtil.getEncodeParam(FolderId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.workspaceId)) {
    query.WorkspaceId = request.workspaceId;
  }
  if (!Util.isUnset(request.onlyFolder)) {
    query.OnlyFolder = request.onlyFolder;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetExperimentFolderChildren', '2021-02-02', 'HTTPS', 'GET', 'AK', `/api/v1/experimentfolders/${FolderId}/children`, 'json', req, runtime);
}

model GetExperimentMetaResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  experimentId?: string(name='ExperimentId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  gmtCreateTime?: string(name='GmtCreateTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  creator?: string(name='Creator'),
  source?: string(name='Source'),
  version?: string(name='Version'),
  workspaceId?: string(name='WorkspaceId'),
  options?: string(name='Options'),
}

model GetExperimentMetaResponse = {
  headers: map[string]string(name='headers'),
  body: GetExperimentMetaResponseBody(name='body'),
}

async function getExperimentMeta(ExperimentId: string): GetExperimentMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getExperimentMetaWithOptions(ExperimentId, headers, runtime);
}

async function getExperimentMetaWithOptions(ExperimentId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetExperimentMetaResponse {
  ExperimentId = OpenApiUtil.getEncodeParam(ExperimentId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('GetExperimentMeta', '2021-02-02', 'HTTPS', 'GET', 'AK', `/api/v1/experiments/${ExperimentId}/meta`, 'json', req, runtime);
}

model GetExperimentsStatisticsRequest {
  workspaceIds?: string(name='WorkspaceIds'),
  source?: string(name='Source'),
}

model GetExperimentsStatisticsResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  data?: [ 
    {
      workspaceId?: string(name='WorkspaceId'),
      totalCount?: long(name='TotalCount'),
      createCount?: long(name='CreateCount'),
    }
  ](name='Data'),
}

model GetExperimentsStatisticsResponse = {
  headers: map[string]string(name='headers'),
  body: GetExperimentsStatisticsResponseBody(name='body'),
}

async function getExperimentsStatistics(request: GetExperimentsStatisticsRequest): GetExperimentsStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getExperimentsStatisticsWithOptions(request, headers, runtime);
}

async function getExperimentsStatisticsWithOptions(request: GetExperimentsStatisticsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetExperimentsStatisticsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.workspaceIds)) {
    query.WorkspaceIds = request.workspaceIds;
  }
  if (!Util.isUnset(request.source)) {
    query.Source = request.source;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetExperimentsStatistics', '2021-02-02', 'HTTPS', 'GET', 'AK', `/api/v1/statistics/experiments`, 'json', req, runtime);
}

model GetExperimentStatusResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  status?: string(name='Status'),
  nodes?: [ 
    {
      nodeId?: string(name='NodeId'),
      jobId?: string(name='JobId'),
      runId?: string(name='RunId'),
      runNodeId?: string(name='RunNodeId'),
      status?: string(name='Status'),
      startedAt?: string(name='StartedAt'),
      finishedAt?: string(name='FinishedAt'),
    }
  ](name='Nodes'),
}

model GetExperimentStatusResponse = {
  headers: map[string]string(name='headers'),
  body: GetExperimentStatusResponseBody(name='body'),
}

async function getExperimentStatus(ExperimentId: string): GetExperimentStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getExperimentStatusWithOptions(ExperimentId, headers, runtime);
}

async function getExperimentStatusWithOptions(ExperimentId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetExperimentStatusResponse {
  ExperimentId = OpenApiUtil.getEncodeParam(ExperimentId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('GetExperimentStatus', '2021-02-02', 'HTTPS', 'GET', 'AK', `/api/v1/experiments/${ExperimentId}/status`, 'json', req, runtime);
}

model GetImageRequest {
  verbose?: boolean(name='Verbose', description='是否显示非必要信息：Labels'),
}

model GetImageResponseBody = {
  requestId?: string(name='requestId', description='Id of the request'),
  gmtCreateTime?: string(name='GmtCreateTime', description='创建 UTC 时间，日期格式 iso8601'),
  gmtModifiedTime?: string(name='GmtModifiedTime', description='创建 UTC 时间，日期格式 iso8601'),
  name?: string(name='Name', description='镜像名称'),
  description?: string(name='Description', description='描述'),
  imageUri?: string(name='ImageUri', description='镜像地址，包含版本号'),
  operatorCreate?: string(name='OperatorCreate', description='创建人'),
  parentOperatorCreate?: string(name='ParentOperatorCreate', description='创建人父账户'),
  labels?: [ 
    {
      key?: string(name='Key', description='Key'),
      value?: string(name='Value', description='Value'),
    }
  ](name='Labels', description='镜像标签'),
}

model GetImageResponse = {
  headers: map[string]string(name='headers'),
  body: GetImageResponseBody(name='body'),
}

async function getImage(ImageId: string, request: GetImageRequest): GetImageResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getImageWithOptions(ImageId, request, headers, runtime);
}

async function getImageWithOptions(ImageId: string, request: GetImageRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetImageResponse {
  Util.validateModel(request);
  ImageId = OpenApiUtil.getEncodeParam(ImageId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.verbose)) {
    query.Verbose = request.verbose;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetImage', '2021-02-02', 'HTTPS', 'GET', 'AK', `/api/v1/images/${ImageId}`, 'json', req, runtime);
}

model GetJobRequest {
  verbose?: boolean(name='Verbose'),
}

model GetJobResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  experimentId?: string(name='ExperimentId'),
  workspaceId?: string(name='WorkspaceId'),
  jobId?: string(name='JobId'),
  snapshot?: string(name='Snapshot'),
  executeType?: string(name='ExecuteType'),
  nodeId?: string(name='NodeId'),
  runInfo?: string(name='RunInfo'),
  runId?: string(name='RunId'),
  paiflowNodeId?: string(name='PaiflowNodeId'),
  creator?: string(name='Creator'),
  status?: string(name='Status'),
  gmtCreateTime?: string(name='GmtCreateTime'),
  arguments?: string(name='Arguments'),
}

model GetJobResponse = {
  headers: map[string]string(name='headers'),
  body: GetJobResponseBody(name='body'),
}

async function getJob(JobId: string, request: GetJobRequest): GetJobResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getJobWithOptions(JobId, request, headers, runtime);
}

async function getJobWithOptions(JobId: string, request: GetJobRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetJobResponse {
  Util.validateModel(request);
  JobId = OpenApiUtil.getEncodeParam(JobId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.verbose)) {
    query.Verbose = request.verbose;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetJob', '2021-02-02', 'HTTPS', 'GET', 'AK', `/api/v1/jobs/${JobId}`, 'json', req, runtime);
}

model GetMCTableSchemaRequest {
  workspaceId?: string(name='WorkspaceId'),
}

model GetMCTableSchemaResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  columns?: [ 
    {
      name?: string(name='Name'),
      type?: string(name='Type'),
      preview?: [ string ](name='Preview'),
    }
  ](name='Columns'),
  partitionColumns?: [ string ](name='PartitionColumns'),
}

model GetMCTableSchemaResponse = {
  headers: map[string]string(name='headers'),
  body: GetMCTableSchemaResponseBody(name='body'),
}

async function getMCTableSchema(TableName: string, request: GetMCTableSchemaRequest): GetMCTableSchemaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getMCTableSchemaWithOptions(TableName, request, headers, runtime);
}

async function getMCTableSchemaWithOptions(TableName: string, request: GetMCTableSchemaRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetMCTableSchemaResponse {
  Util.validateModel(request);
  TableName = OpenApiUtil.getEncodeParam(TableName);
  var query : map[string]any= {};
  if (!Util.isUnset(request.workspaceId)) {
    query.WorkspaceId = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetMCTableSchema', '2021-02-02', 'HTTPS', 'GET', 'AK', `/api/v1/datasources/maxcompute/tables/${TableName}/schema`, 'json', req, runtime);
}

model GetNodeInputSchemaRequest {
  inputId?: string(name='InputId'),
  inputIndex?: int32(name='InputIndex'),
}

model GetNodeInputSchemaResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  colNames?: [ string ](name='ColNames'),
  colTypes?: [ string ](name='ColTypes'),
}

model GetNodeInputSchemaResponse = {
  headers: map[string]string(name='headers'),
  body: GetNodeInputSchemaResponseBody(name='body'),
}

async function getNodeInputSchema(ExperimentId: string, NodeId: string, request: GetNodeInputSchemaRequest): GetNodeInputSchemaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getNodeInputSchemaWithOptions(ExperimentId, NodeId, request, headers, runtime);
}

async function getNodeInputSchemaWithOptions(ExperimentId: string, NodeId: string, request: GetNodeInputSchemaRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetNodeInputSchemaResponse {
  Util.validateModel(request);
  ExperimentId = OpenApiUtil.getEncodeParam(ExperimentId);
  NodeId = OpenApiUtil.getEncodeParam(NodeId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.inputId)) {
    query.InputId = request.inputId;
  }
  if (!Util.isUnset(request.inputIndex)) {
    query.InputIndex = request.inputIndex;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetNodeInputSchema', '2021-02-02', 'HTTPS', 'GET', 'AK', `/api/v1/experiments/${ExperimentId}/nodes/${NodeId}/schema`, 'json', req, runtime);
}

model GetNodeOutputRequest {
  outputIndex?: string(name='OutputIndex'),
}

model GetNodeOutputResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  nodeName?: string(name='NodeName'),
  algoName?: string(name='AlgoName'),
  displayName?: string(name='DisplayName'),
  type?: string(name='Type'),
  value?: map[string]any(name='Value'),
  locationType?: string(name='LocationType'),
}

model GetNodeOutputResponse = {
  headers: map[string]string(name='headers'),
  body: GetNodeOutputResponseBody(name='body'),
}

async function getNodeOutput(ExperimentId: string, NodeId: string, OutputId: string, request: GetNodeOutputRequest): GetNodeOutputResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getNodeOutputWithOptions(ExperimentId, NodeId, OutputId, request, headers, runtime);
}

async function getNodeOutputWithOptions(ExperimentId: string, NodeId: string, OutputId: string, request: GetNodeOutputRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetNodeOutputResponse {
  Util.validateModel(request);
  ExperimentId = OpenApiUtil.getEncodeParam(ExperimentId);
  NodeId = OpenApiUtil.getEncodeParam(NodeId);
  OutputId = OpenApiUtil.getEncodeParam(OutputId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.outputIndex)) {
    query.OutputIndex = request.outputIndex;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetNodeOutput', '2021-02-02', 'HTTPS', 'GET', 'AK', `/api/v1/experiments/${ExperimentId}/nodes/${NodeId}/outputs/${OutputId}`, 'json', req, runtime);
}

model GetNodeVisualizationRequest {
  config?: string(name='Config'),
}

model GetNodeVisualizationResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  visualizationType?: string(name='VisualizationType'),
  content?: string(name='Content'),
}

model GetNodeVisualizationResponse = {
  headers: map[string]string(name='headers'),
  body: GetNodeVisualizationResponseBody(name='body'),
}

async function getNodeVisualization(ExperimentId: string, NodeId: string, VisualizationId: string, request: GetNodeVisualizationRequest): GetNodeVisualizationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getNodeVisualizationWithOptions(ExperimentId, NodeId, VisualizationId, request, headers, runtime);
}

async function getNodeVisualizationWithOptions(ExperimentId: string, NodeId: string, VisualizationId: string, request: GetNodeVisualizationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetNodeVisualizationResponse {
  Util.validateModel(request);
  ExperimentId = OpenApiUtil.getEncodeParam(ExperimentId);
  NodeId = OpenApiUtil.getEncodeParam(NodeId);
  VisualizationId = OpenApiUtil.getEncodeParam(VisualizationId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.config)) {
    query.Config = request.config;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetNodeVisualization', '2021-02-02', 'HTTPS', 'GET', 'AK', `/api/v1/experiments/${ExperimentId}/nodes/${NodeId}/visualizations/${VisualizationId}`, 'json', req, runtime);
}

model GetServiceRequest {
  serviceType?: string(name='ServiceType'),
}

model GetServiceResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  url?: string(name='Url'),
  serviceId?: string(name='ServiceId'),
}

model GetServiceResponse = {
  headers: map[string]string(name='headers'),
  body: GetServiceResponseBody(name='body'),
}

async function getService(ServiceId: string, request: GetServiceRequest): GetServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getServiceWithOptions(ServiceId, request, headers, runtime);
}

async function getServiceWithOptions(ServiceId: string, request: GetServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetServiceResponse {
  Util.validateModel(request);
  ServiceId = OpenApiUtil.getEncodeParam(ServiceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.serviceType)) {
    query.ServiceType = request.serviceType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetService', '2021-02-02', 'HTTPS', 'GET', 'AK', `/api/v1/services/${ServiceId}`, 'json', req, runtime);
}

model GetTemplateResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  templateId?: string(name='TemplateId'),
  name?: string(name='Name'),
  imageLink?: string(name='ImageLink'),
  docLink?: string(name='DocLink'),
  detail?: string(name='Detail'),
  description?: string(name='Description'),
  content?: string(name='Content'),
}

model GetTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: GetTemplateResponseBody(name='body'),
}

async function getTemplate(TemplateId: string): GetTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTemplateWithOptions(TemplateId, headers, runtime);
}

async function getTemplateWithOptions(TemplateId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetTemplateResponse {
  TemplateId = OpenApiUtil.getEncodeParam(TemplateId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('GetTemplate', '2021-02-02', 'HTTPS', 'GET', 'AK', `/api/v1/templates/${TemplateId}`, 'json', req, runtime);
}

model ListAlgoDefsRequest {
  body?: [ 
    {
      provider?: string(name='Provider'),
      identifier?: string(name='Identifier'),
      version?: string(name='Version'),
      signature?: string(name='Signature'),
    }
  ](name='body'),
}

model ListAlgoDefsResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  data?: [  map[string]any ](name='Data'),
}

model ListAlgoDefsResponse = {
  headers: map[string]string(name='headers'),
  body: ListAlgoDefsResponseBody(name='body'),
}

async function listAlgoDefs(request: ListAlgoDefsRequest): ListAlgoDefsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAlgoDefsWithOptions(request, headers, runtime);
}

async function listAlgoDefsWithOptions(request: ListAlgoDefsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAlgoDefsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = Util.toArray(request.body),
  };
  return doROARequest('ListAlgoDefs', '2021-02-02', 'HTTPS', 'POST', 'AK', `/api/v1/algo/detail`, 'json', req, runtime);
}

model ListAuthRolesRequest {
  workspaceId?: string(name='WorkspaceId'),
  isGenerateToken?: string(name='IsGenerateToken'),
}

model ListAuthRolesResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  roles?: [ 
    {
      roleName?: string(name='RoleName'),
      roleARN?: string(name='RoleARN'),
      isEnabled?: string(name='IsEnabled'),
      token?: {
        securityToken?: string(name='SecurityToken'),
        accessKeyId?: string(name='AccessKeyId'),
        accessKeySecret?: string(name='AccessKeySecret'),
        expiration?: string(name='Expiration'),
      }(name='Token'),
      roleType?: string(name='RoleType'),
    }
  ](name='Roles'),
}

model ListAuthRolesResponse = {
  headers: map[string]string(name='headers'),
  body: ListAuthRolesResponseBody(name='body'),
}

async function listAuthRoles(request: ListAuthRolesRequest): ListAuthRolesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAuthRolesWithOptions(request, headers, runtime);
}

async function listAuthRolesWithOptions(request: ListAuthRolesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAuthRolesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.workspaceId)) {
    query.WorkspaceId = request.workspaceId;
  }
  if (!Util.isUnset(request.isGenerateToken)) {
    query.IsGenerateToken = request.isGenerateToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListAuthRoles', '2021-02-02', 'HTTPS', 'GET', 'AK', `/api/v1/authorization/roles`, 'json', req, runtime);
}

model ListExperimentsRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  order?: string(name='Order'),
  experimentId?: string(name='ExperimentId'),
  name?: string(name='Name'),
  creator?: string(name='Creator'),
  source?: string(name='Source'),
  workspaceId?: string(name='WorkspaceId'),
  sortBy?: string(name='SortBy'),
}

model ListExperimentsResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  experiments?: [ 
    {
      experimentId?: string(name='ExperimentId'),
      name?: string(name='Name'),
      description?: string(name='Description'),
      gmtCreateTime?: string(name='GmtCreateTime'),
      gmtModifiedTime?: string(name='GmtModifiedTime'),
      creator?: string(name='Creator'),
      source?: string(name='Source'),
      version?: long(name='Version'),
      workspaceId?: string(name='WorkspaceId'),
    }
  ](name='Experiments'),
  totalCount?: long(name='TotalCount'),
}

model ListExperimentsResponse = {
  headers: map[string]string(name='headers'),
  body: ListExperimentsResponseBody(name='body'),
}

async function listExperiments(request: ListExperimentsRequest): ListExperimentsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listExperimentsWithOptions(request, headers, runtime);
}

async function listExperimentsWithOptions(request: ListExperimentsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListExperimentsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.pageNumber)) {
    query.PageNumber = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query.PageSize = request.pageSize;
  }
  if (!Util.isUnset(request.order)) {
    query.Order = request.order;
  }
  if (!Util.isUnset(request.experimentId)) {
    query.ExperimentId = request.experimentId;
  }
  if (!Util.isUnset(request.name)) {
    query.Name = request.name;
  }
  if (!Util.isUnset(request.creator)) {
    query.Creator = request.creator;
  }
  if (!Util.isUnset(request.source)) {
    query.Source = request.source;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query.WorkspaceId = request.workspaceId;
  }
  if (!Util.isUnset(request.sortBy)) {
    query.SortBy = request.sortBy;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListExperiments', '2021-02-02', 'HTTPS', 'GET', 'AK', `/api/v1/experiments`, 'json', req, runtime);
}

model ListImageLabelsRequest {
  labelKeys?: string(name='LabelKeys', description='标签列表，以逗号分隔'),
  labelFilter?: string(name='LabelFilter', description='image过滤条件，获取满足条件的image的所有label'),
  imageId?: string(name='ImageId', description='镜像id'),
}

model ListImageLabelsResponseBody = {
  requestId?: string(name='requestId', description='Id of the request'),
  labels?: [ 
    {
      key?: string(name='Key', description='键'),
      value?: string(name='Value', description='值'),
    }
  ](name='Labels', description='镜像标签'),
  totalCount?: long(name='TotalCount', description='符合过滤条件的数量'),
}

model ListImageLabelsResponse = {
  headers: map[string]string(name='headers'),
  body: ListImageLabelsResponseBody(name='body'),
}

async function listImageLabels(request: ListImageLabelsRequest): ListImageLabelsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listImageLabelsWithOptions(request, headers, runtime);
}

async function listImageLabelsWithOptions(request: ListImageLabelsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListImageLabelsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.labelKeys)) {
    query.LabelKeys = request.labelKeys;
  }
  if (!Util.isUnset(request.labelFilter)) {
    query.LabelFilter = request.labelFilter;
  }
  if (!Util.isUnset(request.imageId)) {
    query.ImageId = request.imageId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListImageLabels', '2021-02-02', 'HTTPS', 'GET', 'AK', `/api/v1/image/labels`, 'json', req, runtime);
}

model ListImagesRequest {
  name?: string(name='Name', description='镜像名称，支持模糊搜索'),
  pageNumber?: int32(name='PageNumber', description='分页，从1开始，默认1'),
  pageSize?: int32(name='PageSize', description='页大小，默认20'),
  sortBy?: string(name='SortBy', description='排序字段'),
  order?: string(name='Order', description='排序方向： ASC - 升序 DESC - 降序'),
  labels?: string(name='Labels', description='过滤值 以逗号分隔'),
  verbose?: boolean(name='Verbose', description='是否显示非必要信息：Labels'),
}

model ListImagesResponseBody = {
  requestId?: string(name='requestId', description='Id of the request'),
  totalCount?: long(name='TotalCount', description='总数'),
  images?: [ 
    {
      name?: string(name='Name', description='镜像名称'),
      gmtCreateTime?: string(name='GmtCreateTime', description='创建 UTC 时间，日期格式 iso8601'),
      description?: string(name='Description', description='镜像描述'),
      imageUri?: string(name='ImageUri', description='镜像地址，包含版本号'),
      labels?: [ 
        {
          key?: string(name='Key', description='Key'),
          value?: string(name='Value', description='Value'),
        }
      ](name='Labels', description='镜像标签，是个map'),
      imageId?: string(name='ImageId', description='镜像id'),
    }
  ](name='Images', description='镜像列表'),
}

model ListImagesResponse = {
  headers: map[string]string(name='headers'),
  body: ListImagesResponseBody(name='body'),
}

async function listImages(request: ListImagesRequest): ListImagesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listImagesWithOptions(request, headers, runtime);
}

async function listImagesWithOptions(request: ListImagesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListImagesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.name)) {
    query.Name = request.name;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query.PageNumber = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query.PageSize = request.pageSize;
  }
  if (!Util.isUnset(request.sortBy)) {
    query.SortBy = request.sortBy;
  }
  if (!Util.isUnset(request.order)) {
    query.Order = request.order;
  }
  if (!Util.isUnset(request.labels)) {
    query.Labels = request.labels;
  }
  if (!Util.isUnset(request.verbose)) {
    query.Verbose = request.verbose;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListImages', '2021-02-02', 'HTTPS', 'GET', 'AK', `/api/v1/images`, 'json', req, runtime);
}

model ListJobsRequest {
  experimentId?: string(name='ExperimentId'),
  creator?: string(name='Creator'),
  order?: string(name='Order'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListJobsResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  jobs?: [ 
    {
      experimentId?: string(name='ExperimentId'),
      workspaceId?: string(name='WorkspaceId'),
      jobId?: string(name='JobId'),
      executeType?: string(name='ExecuteType'),
      nodeId?: string(name='NodeId'),
      runId?: string(name='RunId'),
      paiflowNodeId?: string(name='PaiflowNodeId'),
      creator?: string(name='Creator'),
      status?: string(name='Status'),
      gmtCreateTime?: string(name='GmtCreateTime'),
    }
  ](name='Jobs'),
}

model ListJobsResponse = {
  headers: map[string]string(name='headers'),
  body: ListJobsResponseBody(name='body'),
}

async function listJobs(request: ListJobsRequest): ListJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listJobsWithOptions(request, headers, runtime);
}

async function listJobsWithOptions(request: ListJobsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListJobsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.experimentId)) {
    query.ExperimentId = request.experimentId;
  }
  if (!Util.isUnset(request.creator)) {
    query.Creator = request.creator;
  }
  if (!Util.isUnset(request.order)) {
    query.Order = request.order;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query.PageNumber = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query.PageSize = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListJobs', '2021-02-02', 'HTTPS', 'GET', 'AK', `/api/v1/jobs`, 'json', req, runtime);
}

model ListNodeOutputsResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  outputs?: [ 
    {
      displayName?: string(name='DisplayName'),
      type?: string(name='Type'),
      outputId?: string(name='OutputId'),
      outputIndex?: string(name='OutputIndex'),
      value?: map[string]any(name='Value'),
      nodeName?: string(name='NodeName'),
      algoName?: string(name='AlgoName'),
      locationType?: string(name='LocationType'),
    }
  ](name='Outputs'),
}

model ListNodeOutputsResponse = {
  headers: map[string]string(name='headers'),
  body: ListNodeOutputsResponseBody(name='body'),
}

async function listNodeOutputs(ExperimentId: string, NodeId: string): ListNodeOutputsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listNodeOutputsWithOptions(ExperimentId, NodeId, headers, runtime);
}

async function listNodeOutputsWithOptions(ExperimentId: string, NodeId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListNodeOutputsResponse {
  ExperimentId = OpenApiUtil.getEncodeParam(ExperimentId);
  NodeId = OpenApiUtil.getEncodeParam(NodeId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('ListNodeOutputs', '2021-02-02', 'HTTPS', 'GET', 'AK', `/api/v1/experiments/${ExperimentId}/nodes/${NodeId}/outputs`, 'json', req, runtime);
}

model ListRecentExperimentsRequest {
  order?: string(name='Order'),
  source?: string(name='Source'),
  type?: string(name='Type'),
  workspaceId?: string(name='WorkspaceId'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
}

model ListRecentExperimentsResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  experiments?: [ 
    {
      experimentId?: string(name='ExperimentId'),
      name?: string(name='Name'),
      description?: string(name='Description'),
      recentGmtModifiedTime?: string(name='RecentGmtModifiedTime'),
      source?: string(name='Source'),
      modifyCnt?: long(name='ModifyCnt'),
      workspaceId?: string(name='WorkspaceId'),
      workspaceName?: string(name='WorkspaceName'),
    }
  ](name='Experiments'),
  totalCount?: long(name='TotalCount'),
}

model ListRecentExperimentsResponse = {
  headers: map[string]string(name='headers'),
  body: ListRecentExperimentsResponseBody(name='body'),
}

async function listRecentExperiments(request: ListRecentExperimentsRequest): ListRecentExperimentsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRecentExperimentsWithOptions(request, headers, runtime);
}

async function listRecentExperimentsWithOptions(request: ListRecentExperimentsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRecentExperimentsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.order)) {
    query.Order = request.order;
  }
  if (!Util.isUnset(request.source)) {
    query.Source = request.source;
  }
  if (!Util.isUnset(request.type)) {
    query.Type = request.type;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query.WorkspaceId = request.workspaceId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query.PageNumber = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query.PageSize = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListRecentExperiments', '2021-02-02', 'HTTPS', 'GET', 'AK', `/api/v1/recentexperiments`, 'json', req, runtime);
}

model ListServicesRequest {
  workspaceId?: string(name='WorkspaceId'),
  serviceType?: string(name='ServiceType'),
}

model ListServicesResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  totalCount?: int32(name='TotalCount'),
  services?: [ 
    {
      url?: string(name='Url'),
      serviceId?: string(name='ServiceId'),
    }
  ](name='Services'),
}

model ListServicesResponse = {
  headers: map[string]string(name='headers'),
  body: ListServicesResponseBody(name='body'),
}

async function listServices(request: ListServicesRequest): ListServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listServicesWithOptions(request, headers, runtime);
}

async function listServicesWithOptions(request: ListServicesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListServicesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.workspaceId)) {
    query.WorkspaceId = request.workspaceId;
  }
  if (!Util.isUnset(request.serviceType)) {
    query.ServiceType = request.serviceType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListServices', '2021-02-02', 'HTTPS', 'GET', 'AK', `/api/v1/services`, 'json', req, runtime);
}

model ListTemplatesRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  source?: string(name='Source'),
  list?: string(name='List'),
  tagId?: string(name='TagId'),
  order?: string(name='Order'),
  typeId?: string(name='TypeId'),
}

model ListTemplatesResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  totalCount?: int32(name='TotalCount'),
  templateData?: [ 
    {
      template?: {
        templateId?: string(name='TemplateId'),
        content?: string(name='Content'),
        description?: string(name='Description'),
        detail?: string(name='Detail'),
        docLink?: string(name='DocLink'),
        imageLink?: string(name='ImageLink'),
        name?: string(name='Name'),
      }(name='Template'),
      templateTag?: {
        name?: string(name='Name'),
        tagId?: string(name='TagId'),
        typeId?: string(name='TypeId'),
      }(name='TemplateTag'),
      templateType?: {
        typeId?: string(name='TypeId'),
        name?: string(name='Name'),
      }(name='TemplateType'),
    }
  ](name='TemplateData'),
}

model ListTemplatesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTemplatesResponseBody(name='body'),
}

async function listTemplates(request: ListTemplatesRequest): ListTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTemplatesWithOptions(request, headers, runtime);
}

async function listTemplatesWithOptions(request: ListTemplatesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTemplatesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.pageNumber)) {
    query.PageNumber = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query.PageSize = request.pageSize;
  }
  if (!Util.isUnset(request.source)) {
    query.Source = request.source;
  }
  if (!Util.isUnset(request.list)) {
    query.List = request.list;
  }
  if (!Util.isUnset(request.tagId)) {
    query.TagId = request.tagId;
  }
  if (!Util.isUnset(request.order)) {
    query.Order = request.order;
  }
  if (!Util.isUnset(request.typeId)) {
    query.TypeId = request.typeId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListTemplates', '2021-02-02', 'HTTPS', 'GET', 'AK', `/api/v1/templates`, 'json', req, runtime);
}

model PreviewMCTableRequest {
  workspaceId?: string(name='WorkspaceId'),
  endpoint?: string(name='Endpoint'),
}

model PreviewMCTableResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  content?: [[ string ]  ](name='Content'),
}

model PreviewMCTableResponse = {
  headers: map[string]string(name='headers'),
  body: PreviewMCTableResponseBody(name='body'),
}

async function previewMCTable(TableName: string, request: PreviewMCTableRequest): PreviewMCTableResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return previewMCTableWithOptions(TableName, request, headers, runtime);
}

async function previewMCTableWithOptions(TableName: string, request: PreviewMCTableRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PreviewMCTableResponse {
  Util.validateModel(request);
  TableName = OpenApiUtil.getEncodeParam(TableName);
  var query : map[string]any= {};
  if (!Util.isUnset(request.workspaceId)) {
    query.WorkspaceId = request.workspaceId;
  }
  if (!Util.isUnset(request.endpoint)) {
    query.Endpoint = request.endpoint;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('PreviewMCTable', '2021-02-02', 'HTTPS', 'GET', 'AK', `/api/v1/datasources/maxcompute/tables/${TableName}/preview`, 'json', req, runtime);
}

model RemoveImageResponseBody = {
  requestId?: string(name='requestId', description='Id of the request'),
}

model RemoveImageResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveImageResponseBody(name='body'),
}

async function removeImage(ImageId: string): RemoveImageResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return removeImageWithOptions(ImageId, headers, runtime);
}

async function removeImageWithOptions(ImageId: string, headers: map[string]string, runtime: Util.RuntimeOptions): RemoveImageResponse {
  ImageId = OpenApiUtil.getEncodeParam(ImageId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('RemoveImage', '2021-02-02', 'HTTPS', 'DELETE', 'AK', `/api/v1/images/${ImageId}`, 'json', req, runtime);
}

model RemoveImageLabelsResponseBody = {
  requestId?: string(name='requestId', description='Id of the request'),
}

model RemoveImageLabelsResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveImageLabelsResponseBody(name='body'),
}

async function removeImageLabels(ImageId: string, LabelKey: string): RemoveImageLabelsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return removeImageLabelsWithOptions(ImageId, LabelKey, headers, runtime);
}

async function removeImageLabelsWithOptions(ImageId: string, LabelKey: string, headers: map[string]string, runtime: Util.RuntimeOptions): RemoveImageLabelsResponse {
  ImageId = OpenApiUtil.getEncodeParam(ImageId);
  LabelKey = OpenApiUtil.getEncodeParam(LabelKey);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('RemoveImageLabels', '2021-02-02', 'HTTPS', 'DELETE', 'AK', `/api/v1/images/${ImageId}/labels/${LabelKey}`, 'json', req, runtime);
}

model SearchMCTablesRequest {
  workspaceId?: string(name='WorkspaceId'),
  keyword?: string(name='Keyword'),
}

model SearchMCTablesResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  tables?: [ string ](name='Tables'),
}

model SearchMCTablesResponse = {
  headers: map[string]string(name='headers'),
  body: SearchMCTablesResponseBody(name='body'),
}

async function searchMCTables(request: SearchMCTablesRequest): SearchMCTablesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return searchMCTablesWithOptions(request, headers, runtime);
}

async function searchMCTablesWithOptions(request: SearchMCTablesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SearchMCTablesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.workspaceId)) {
    query.WorkspaceId = request.workspaceId;
  }
  if (!Util.isUnset(request.keyword)) {
    query.Keyword = request.keyword;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('SearchMCTables', '2021-02-02', 'HTTPS', 'GET', 'AK', `/api/v1/datasources/maxcompute/tables`, 'json', req, runtime);
}

model StopExperimentResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model StopExperimentResponse = {
  headers: map[string]string(name='headers'),
  body: StopExperimentResponseBody(name='body'),
}

async function stopExperiment(ExperimentId: string): StopExperimentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopExperimentWithOptions(ExperimentId, headers, runtime);
}

async function stopExperimentWithOptions(ExperimentId: string, headers: map[string]string, runtime: Util.RuntimeOptions): StopExperimentResponse {
  ExperimentId = OpenApiUtil.getEncodeParam(ExperimentId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('StopExperiment', '2021-02-02', 'HTTPS', 'POST', 'AK', `/api/v1/experiments/${ExperimentId}/stop`, 'json', req, runtime);
}

model StopJobResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model StopJobResponse = {
  headers: map[string]string(name='headers'),
  body: StopJobResponseBody(name='body'),
}

async function stopJob(JobId: string): StopJobResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopJobWithOptions(JobId, headers, runtime);
}

async function stopJobWithOptions(JobId: string, headers: map[string]string, runtime: Util.RuntimeOptions): StopJobResponse {
  JobId = OpenApiUtil.getEncodeParam(JobId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('StopJob', '2021-02-02', 'HTTPS', 'PUT', 'AK', `/api/v1/jobs/${JobId}/stop`, 'json', req, runtime);
}

model UpdateExperimentContentRequest {
  content?: string(name='Content'),
  version?: long(name='Version'),
}

model UpdateExperimentContentResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  version?: long(name='Version'),
}

model UpdateExperimentContentResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateExperimentContentResponseBody(name='body'),
}

async function updateExperimentContent(ExperimentId: string, request: UpdateExperimentContentRequest): UpdateExperimentContentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateExperimentContentWithOptions(ExperimentId, request, headers, runtime);
}

async function updateExperimentContentWithOptions(ExperimentId: string, request: UpdateExperimentContentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateExperimentContentResponse {
  Util.validateModel(request);
  ExperimentId = OpenApiUtil.getEncodeParam(ExperimentId);
  var body : map[string]any= {};
  if (!Util.isUnset(request.content)) {
    body.Content = request.content;
  }
  if (!Util.isUnset(request.version)) {
    body.Version = request.version;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('UpdateExperimentContent', '2021-02-02', 'HTTPS', 'PUT', 'AK', `/api/v1/experiments/${ExperimentId}/content`, 'json', req, runtime);
}

model UpdateExperimentFolderRequest {
  name?: string(name='Name'),
  parentFolderId?: string(name='ParentFolderId'),
}

model UpdateExperimentFolderResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model UpdateExperimentFolderResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateExperimentFolderResponseBody(name='body'),
}

async function updateExperimentFolder(FolderId: string, request: UpdateExperimentFolderRequest): UpdateExperimentFolderResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateExperimentFolderWithOptions(FolderId, request, headers, runtime);
}

async function updateExperimentFolderWithOptions(FolderId: string, request: UpdateExperimentFolderRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateExperimentFolderResponse {
  Util.validateModel(request);
  FolderId = OpenApiUtil.getEncodeParam(FolderId);
  var body : map[string]any= {};
  if (!Util.isUnset(request.name)) {
    body.Name = request.name;
  }
  if (!Util.isUnset(request.parentFolderId)) {
    body.ParentFolderId = request.parentFolderId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('UpdateExperimentFolder', '2021-02-02', 'HTTPS', 'PUT', 'AK', `/api/v1/experimentfolders/${FolderId}`, 'json', req, runtime);
}

model UpdateExperimentMetaRequest {
  name?: string(name='Name'),
  description?: string(name='Description'),
  folderId?: string(name='FolderId'),
  options?: string(name='Options'),
}

model UpdateExperimentMetaResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model UpdateExperimentMetaResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateExperimentMetaResponseBody(name='body'),
}

async function updateExperimentMeta(ExperimentId: string, request: UpdateExperimentMetaRequest): UpdateExperimentMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateExperimentMetaWithOptions(ExperimentId, request, headers, runtime);
}

async function updateExperimentMetaWithOptions(ExperimentId: string, request: UpdateExperimentMetaRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateExperimentMetaResponse {
  Util.validateModel(request);
  ExperimentId = OpenApiUtil.getEncodeParam(ExperimentId);
  var body : map[string]any= {};
  if (!Util.isUnset(request.name)) {
    body.Name = request.name;
  }
  if (!Util.isUnset(request.description)) {
    body.Description = request.description;
  }
  if (!Util.isUnset(request.folderId)) {
    body.FolderId = request.folderId;
  }
  if (!Util.isUnset(request.options)) {
    body.Options = request.options;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('UpdateExperimentMeta', '2021-02-02', 'HTTPS', 'PUT', 'AK', `/api/v1/experiments/${ExperimentId}/meta`, 'json', req, runtime);
}

