/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    cn-beijing = 'pai.cn-beijing.aliyuncs.com',
    cn-hangzhou = 'pai.cn-hangzhou.aliyuncs.com',
    cn-shanghai = 'pai.cn-shanghai.aliyuncs.com',
    cn-shenzhen = 'pai.cn-shenzhen.aliyuncs.com',
    cn-hongkong = 'pai.cn-hongkong.aliyuncs.com',
    ap-southeast-1 = 'pai.ap-southeast-1.aliyuncs.com',
    ap-southeast-2 = 'pai.ap-southeast-2.aliyuncs.com',
    ap-southeast-3 = 'pai.ap-southeast-3.aliyuncs.com',
    ap-southeast-5 = 'pai.ap-southeast-5.aliyuncs.com',
    us-west-1 = 'pai.us-west-1.aliyuncs.com',
    us-east-1 = 'pai.us-east-1.aliyuncs.com',
    eu-central-1 = 'pai.eu-central-1.aliyuncs.com',
    me-east-1 = 'pai.me-east-1.aliyuncs.com',
    ap-south-1 = 'pai.ap-south-1.aliyuncs.com',
    cn-qingdao = 'pai.cn-qingdao.aliyuncs.com',
    cn-zhangjiakou = 'pai.cn-zhangjiakou.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('paistudio', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AddImageRequest {
  description?: string(name='Description'),
  imageUri?: string(name='ImageUri'),
  labels?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Labels'),
  name?: string(name='Name'),
}

model AddImageResponseBody = {
  imageId?: string(name='ImageId'),
  requestId?: string(name='requestId'),
}

model AddImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddImageResponseBody(name='body'),
}

async function addImageWithOptions(request: AddImageRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddImageResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.imageUri)) {
    body['ImageUri'] = request.imageUri;
  }
  if (!Util.isUnset(request.labels)) {
    body['Labels'] = request.labels;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddImage',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/images`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addImage(request: AddImageRequest): AddImageResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addImageWithOptions(request, headers, runtime);
}

model AddImageLabelsRequest {
  labels?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Labels'),
}

model AddImageLabelsResponseBody = {
  requestId?: string(name='requestId'),
}

model AddImageLabelsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddImageLabelsResponseBody(name='body'),
}

async function addImageLabelsWithOptions(ImageId: string, request: AddImageLabelsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddImageLabelsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.labels)) {
    body['Labels'] = request.labels;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddImageLabels',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/images/${OpenApiUtil.getEncodeParam(ImageId)}/labels`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addImageLabels(ImageId: string, request: AddImageLabelsRequest): AddImageLabelsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addImageLabelsWithOptions(ImageId, request, headers, runtime);
}

model CopyExperimentRequest {
  accessibility?: string(name='Accessibility', example='PUBLIC'),
  description?: string(name='Description'),
  folderId?: string(name='FolderId'),
  name?: string(name='Name'),
  source?: string(name='Source', example='PaiStudio'),
  workspaceId?: string(name='WorkspaceId', example='84972'),
}

model CopyExperimentResponseBody = {
  experimentId?: string(name='ExperimentId', example='experiment-rbvg5wzljzjhc9ks92'),
  requestId?: string(name='RequestId'),
}

model CopyExperimentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CopyExperimentResponseBody(name='body'),
}

async function copyExperimentWithOptions(ExperimentId: string, request: CopyExperimentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CopyExperimentResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.accessibility)) {
    body['Accessibility'] = request.accessibility;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.folderId)) {
    body['FolderId'] = request.folderId;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.source)) {
    body['Source'] = request.source;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CopyExperiment',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/experiments/%5BExperimentId%5D/copy`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function copyExperiment(ExperimentId: string, request: CopyExperimentRequest): CopyExperimentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return copyExperimentWithOptions(ExperimentId, request, headers, runtime);
}

model CreateExperimentRequest {
  accessibility?: string(name='Accessibility', example='PUBLIC'),
  description?: string(name='Description'),
  folderId?: string(name='FolderId'),
  name?: string(name='Name'),
  options?: string(name='Options', example='{"mlflow":{"experimentId":"exp-1"}}'),
  source?: string(name='Source', example='PaiStudio'),
  templateId?: string(name='TemplateId'),
  workspaceId?: string(name='WorkspaceId', example='84972'),
}

model CreateExperimentResponseBody = {
  experimentId?: string(name='ExperimentId', example='experiment-rbvg5wzljzjhc9ks92'),
  requestId?: string(name='RequestId'),
}

model CreateExperimentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateExperimentResponseBody(name='body'),
}

async function createExperimentWithOptions(request: CreateExperimentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateExperimentResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.accessibility)) {
    body['Accessibility'] = request.accessibility;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.folderId)) {
    body['FolderId'] = request.folderId;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.options)) {
    body['Options'] = request.options;
  }
  if (!Util.isUnset(request.source)) {
    body['Source'] = request.source;
  }
  if (!Util.isUnset(request.templateId)) {
    body['TemplateId'] = request.templateId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateExperiment',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/experiments`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createExperiment(request: CreateExperimentRequest): CreateExperimentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createExperimentWithOptions(request, headers, runtime);
}

model CreateExperimentFolderRequest {
  accessibility?: string(name='Accessibility', example='PUBLIC'),
  name?: string(name='Name'),
  parentFolderId?: string(name='ParentFolderId'),
  source?: string(name='Source'),
  workspaceId?: string(name='WorkspaceId'),
}

model CreateExperimentFolderResponseBody = {
  folderId?: string(name='FolderId'),
  requestId?: string(name='RequestId'),
}

model CreateExperimentFolderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateExperimentFolderResponseBody(name='body'),
}

async function createExperimentFolderWithOptions(request: CreateExperimentFolderRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateExperimentFolderResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.accessibility)) {
    body['Accessibility'] = request.accessibility;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.parentFolderId)) {
    body['ParentFolderId'] = request.parentFolderId;
  }
  if (!Util.isUnset(request.source)) {
    body['Source'] = request.source;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateExperimentFolder',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/experimentfolders`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createExperimentFolder(request: CreateExperimentFolderRequest): CreateExperimentFolderResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createExperimentFolderWithOptions(request, headers, runtime);
}

model CreateExperimentMigrateValidationRequest {
  sourceExpId?: long(name='SourceExpId'),
}

model CreateExperimentMigrateValidationResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateExperimentMigrateValidationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateExperimentMigrateValidationResponseBody(name='body'),
}

async function createExperimentMigrateValidationWithOptions(request: CreateExperimentMigrateValidationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateExperimentMigrateValidationResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.sourceExpId)) {
    query['SourceExpId'] = request.sourceExpId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateExperimentMigrateValidation',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/migrate/experimentvalidation`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createExperimentMigrateValidation(request: CreateExperimentMigrateValidationRequest): CreateExperimentMigrateValidationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createExperimentMigrateValidationWithOptions(request, headers, runtime);
}

model CreateJobRequest {
  executeType?: string(name='ExecuteType'),
  experimentId?: string(name='ExperimentId'),
  nodeId?: string(name='NodeId'),
  options?: string(name='Options', example='{"mlflow":{"experimentId":"exp-1"}}'),
}

model CreateJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model CreateJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateJobResponseBody(name='body'),
}

async function createJobWithOptions(request: CreateJobRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateJobResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.executeType)) {
    body['ExecuteType'] = request.executeType;
  }
  if (!Util.isUnset(request.experimentId)) {
    body['ExperimentId'] = request.experimentId;
  }
  if (!Util.isUnset(request.nodeId)) {
    body['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.options)) {
    body['Options'] = request.options;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateJob',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/jobs`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createJob(request: CreateJobRequest): CreateJobResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createJobWithOptions(request, headers, runtime);
}

model DeleteExperimentResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteExperimentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteExperimentResponseBody(name='body'),
}

async function deleteExperimentWithOptions(ExperimentId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteExperimentResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteExperiment',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/experiments/${OpenApiUtil.getEncodeParam(ExperimentId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteExperiment(ExperimentId: string): DeleteExperimentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteExperimentWithOptions(ExperimentId, headers, runtime);
}

model DeleteExperimentFolderResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteExperimentFolderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteExperimentFolderResponseBody(name='body'),
}

async function deleteExperimentFolderWithOptions(FolderId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteExperimentFolderResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteExperimentFolder',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/experimentfolders/${OpenApiUtil.getEncodeParam(FolderId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteExperimentFolder(FolderId: string): DeleteExperimentFolderResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteExperimentFolderWithOptions(FolderId, headers, runtime);
}

model GetAlgoTreeRequest {
  source?: string(name='Source'),
}

model GetAlgoTreeResponseBody = {
  data?: map[string]any(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetAlgoTreeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAlgoTreeResponseBody(name='body'),
}

async function getAlgoTreeWithOptions(request: GetAlgoTreeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetAlgoTreeResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAlgoTree',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/algo/tree`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAlgoTree(request: GetAlgoTreeRequest): GetAlgoTreeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAlgoTreeWithOptions(request, headers, runtime);
}

model GetAlgorithmDefRequest {
  algoVersion?: string(name='AlgoVersion'),
  identifier?: string(name='Identifier'),
  provider?: string(name='Provider'),
  signature?: string(name='Signature'),
}

model GetAlgorithmDefResponseBody = {
  requestId?: string(name='RequestId'),
  spec?: map[string]any(name='Spec'),
}

model GetAlgorithmDefResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAlgorithmDefResponseBody(name='body'),
}

async function getAlgorithmDefWithOptions(request: GetAlgorithmDefRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetAlgorithmDefResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.algoVersion)) {
    query['AlgoVersion'] = request.algoVersion;
  }
  if (!Util.isUnset(request.identifier)) {
    query['Identifier'] = request.identifier;
  }
  if (!Util.isUnset(request.provider)) {
    query['Provider'] = request.provider;
  }
  if (!Util.isUnset(request.signature)) {
    query['Signature'] = request.signature;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAlgorithmDef',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/algorithm/def`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAlgorithmDef(request: GetAlgorithmDefRequest): GetAlgorithmDefResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAlgorithmDefWithOptions(request, headers, runtime);
}

model GetAlgorithmDefsRequest {
  latestTimestamp?: string(name='LatestTimestamp'),
  rangeEnd?: int32(name='RangeEnd'),
  rangeStart?: int32(name='RangeStart'),
  timestamp?: string(name='Timestamp'),
}

model GetAlgorithmDefsResponseBody = {
  requestId?: string(name='RequestId'),
  specs?: [  map[string]any ](name='Specs'),
}

model GetAlgorithmDefsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAlgorithmDefsResponseBody(name='body'),
}

async function getAlgorithmDefsWithOptions(request: GetAlgorithmDefsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetAlgorithmDefsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.latestTimestamp)) {
    query['LatestTimestamp'] = request.latestTimestamp;
  }
  if (!Util.isUnset(request.rangeEnd)) {
    query['RangeEnd'] = request.rangeEnd;
  }
  if (!Util.isUnset(request.rangeStart)) {
    query['RangeStart'] = request.rangeStart;
  }
  if (!Util.isUnset(request.timestamp)) {
    query['Timestamp'] = request.timestamp;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAlgorithmDefs',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/algorithm/defs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAlgorithmDefs(request: GetAlgorithmDefsRequest): GetAlgorithmDefsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAlgorithmDefsWithOptions(request, headers, runtime);
}

model GetAlgorithmTreeRequest {
  source?: string(name='Source'),
  workspaceId?: string(name='WorkspaceId'),
}

model GetAlgorithmTreeResponseBody = {
  requestId?: string(name='RequestId'),
  timestamp?: string(name='Timestamp'),
  tree?: [  map[string]any ](name='Tree'),
}

model GetAlgorithmTreeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAlgorithmTreeResponseBody(name='body'),
}

async function getAlgorithmTreeWithOptions(request: GetAlgorithmTreeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetAlgorithmTreeResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAlgorithmTree',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/algorithm/tree`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAlgorithmTree(request: GetAlgorithmTreeRequest): GetAlgorithmTreeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAlgorithmTreeWithOptions(request, headers, runtime);
}

model GetExperimentResponseBody = {
  accessibility?: string(name='Accessibility', example='PUBLIC'),
  content?: string(name='Content', example='{     "nodes": [         {             "id": "id-4c50-1609236241393-76174",             "name": "读数据表",             "metadata": {                 "identifier": "data_source",                 "version": "v1",                 "provider": "pai"             },             "properties": [                 {                     "name": "hasPartition",                     "value": false                 },                 {                     "name": "inputTableName",                     "value": "pai_online_project.e_commerce_test_data"                 }             ],             "position": {                 "x": 427,                 "y": 123             }         },         {             "id": "id-23ce-1609236252041-30106",             "name": "读数据表",             "metadata": {                 "identifier": "data_source",                 "version": "v1",                 "provider": "pai"             },             "properties": [                 {                     "name": "inputTableName",                     "value": "pai_online_project.e_commerce_train_data"                 },                 {                     "name": "hasPartition",                     "value": false                 }             ],             "position": {                 "x": 226,                 "y": 127             }         },         {             "id": "id-97a7-1609236275421-84245",             "name": "DeepFM",             "metadata": {                 "identifier": "deepfm",                 "version": "v1",                 "provider": "pai"             },             "properties": [                 {                     "name": "trainModel",                     "value": "train"                 },                 {                     "name": "arn",                     "value": true                 },                 {                     "name": "cluster",                     "value": "\\n{\\n    \\"ps\\": {\\n        \\"count\\": 2,\\n        \\"cpu\\": 1000,\\n        \\"memory\\": 40000\\n    },\\n    \\"worker\\": {\\n        \\"count\\": 8,\\n        \\"cpu\\": 1000,\\n        \\"memory\\": 40000\\n    }\\n}"                 }             ],             "position": {                 "x": 323,                 "y": 345             }         }     ],     "edges": [         {             "source": "id-23ce-1609236252041-30106",             "sourceAnchor": "outputTable",             "targetAnchor": "input1TableName",             "target": "id-97a7-1609236275421-84245"         },         {             "source": "id-4c50-1609236241393-76174",             "sourceAnchor": "outputTable",             "targetAnchor": "input2TableName",             "target": "id-97a7-1609236275421-84245"         }     ],     "globalParams": [],     "globalSettings": []  }'),
  creator?: string(name='Creator', example='1326689413376250'),
  description?: string(name='Description'),
  experimentId?: string(name='ExperimentId', example='experiment-rbvg5wzljzjhc9ks92'),
  gmtCreateTime?: string(name='GmtCreateTime', example='2021-01-30T12:51:33.028Z'),
  gmtModifiedTime?: string(name='GmtModifiedTime', example='2021-01-30T12:51:33.028Z'),
  name?: string(name='Name'),
  options?: string(name='Options', example='{"mlflow":{"experimentId":"exp-1"}}'),
  requestId?: string(name='RequestId'),
  source?: string(name='Source', example='PaiStudio'),
  version?: long(name='Version', example='12'),
  workspaceId?: string(name='WorkspaceId', example='23487'),
}

model GetExperimentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetExperimentResponseBody(name='body'),
}

async function getExperimentWithOptions(ExperimentId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetExperimentResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetExperiment',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/experiments/${OpenApiUtil.getEncodeParam(ExperimentId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getExperiment(ExperimentId: string): GetExperimentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getExperimentWithOptions(ExperimentId, headers, runtime);
}

model GetExperimentFolderChildrenRequest {
  accessibility?: string(name='Accessibility', example='PUBLIC'),
  onlyFolder?: boolean(name='OnlyFolder'),
  source?: string(name='Source', example='PaiStudio'),
  userId?: string(name='UserId'),
  workspaceId?: string(name='WorkspaceId'),
}

model GetExperimentFolderChildrenResponseBody = {
  items?: [ 
    {
      empty?: boolean(name='Empty'),
      gmtCreateTime?: string(name='GmtCreateTime'),
      gmtModifiedTime?: string(name='GmtModifiedTime'),
      icon?: string(name='Icon'),
      id?: string(name='Id'),
      name?: string(name='Name'),
      type?: string(name='Type'),
    }
  ](name='Items'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model GetExperimentFolderChildrenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetExperimentFolderChildrenResponseBody(name='body'),
}

async function getExperimentFolderChildrenWithOptions(FolderId: string, request: GetExperimentFolderChildrenRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetExperimentFolderChildrenResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessibility)) {
    query['Accessibility'] = request.accessibility;
  }
  if (!Util.isUnset(request.onlyFolder)) {
    query['OnlyFolder'] = request.onlyFolder;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetExperimentFolderChildren',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/experimentfolders/${OpenApiUtil.getEncodeParam(FolderId)}/children`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getExperimentFolderChildren(FolderId: string, request: GetExperimentFolderChildrenRequest): GetExperimentFolderChildrenResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getExperimentFolderChildrenWithOptions(FolderId, request, headers, runtime);
}

model GetExperimentMetaResponseBody = {
  accessibility?: string(name='Accessibility', example='PUBLIC'),
  creator?: string(name='Creator', example='1326689413376250'),
  description?: string(name='Description'),
  experimentId?: string(name='ExperimentId', example='experiment-rbvg5wzljzjhc9ks92'),
  gmtCreateTime?: string(name='GmtCreateTime', example='2021-01-30T12:51:33.028Z'),
  gmtModifiedTime?: string(name='GmtModifiedTime', example='2021-01-30T12:51:33.028Z'),
  name?: string(name='Name'),
  options?: string(name='Options', example='{"mlflow":{"experimentId":"exp-1"}}'),
  requestId?: string(name='RequestId'),
  source?: string(name='Source', example='PaiStudio'),
  version?: string(name='Version', example='12'),
  workspaceId?: string(name='WorkspaceId', example='23487'),
}

model GetExperimentMetaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetExperimentMetaResponseBody(name='body'),
}

async function getExperimentMetaWithOptions(ExperimentId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetExperimentMetaResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetExperimentMeta',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/experiments/${OpenApiUtil.getEncodeParam(ExperimentId)}/meta`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getExperimentMeta(ExperimentId: string): GetExperimentMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getExperimentMetaWithOptions(ExperimentId, headers, runtime);
}

model GetExperimentStatusResponseBody = {
  nodes?: [ 
    {
      finishedAt?: string(name='FinishedAt'),
      jobId?: string(name='JobId'),
      nodeId?: string(name='NodeId'),
      runId?: string(name='RunId'),
      runNodeId?: string(name='RunNodeId'),
      startedAt?: string(name='StartedAt'),
      status?: string(name='Status'),
    }
  ](name='Nodes'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
}

model GetExperimentStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetExperimentStatusResponseBody(name='body'),
}

async function getExperimentStatusWithOptions(ExperimentId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetExperimentStatusResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetExperimentStatus',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/experiments/${OpenApiUtil.getEncodeParam(ExperimentId)}/status`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getExperimentStatus(ExperimentId: string): GetExperimentStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getExperimentStatusWithOptions(ExperimentId, headers, runtime);
}

model GetExperimentVisualizationMetaRequest {
  nodeIds?: string(name='NodeIds', example='node_id1,node_id2'),
}

model GetExperimentVisualizationMetaResponseBody = {
  visualizationMeta?: [ 
    {
      meta?: string(name='Meta'),
      nodeId?: string(name='NodeId'),
      nodeName?: string(name='NodeName'),
    }
  ](name='VisualizationMeta'),
  requestId?: string(name='requestId'),
}

model GetExperimentVisualizationMetaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetExperimentVisualizationMetaResponseBody(name='body'),
}

async function getExperimentVisualizationMetaWithOptions(ExperimentId: string, request: GetExperimentVisualizationMetaRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetExperimentVisualizationMetaResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.nodeIds)) {
    query['NodeIds'] = request.nodeIds;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetExperimentVisualizationMeta',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/experiments/${OpenApiUtil.getEncodeParam(ExperimentId)}/visualizationMeta`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getExperimentVisualizationMeta(ExperimentId: string, request: GetExperimentVisualizationMetaRequest): GetExperimentVisualizationMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getExperimentVisualizationMetaWithOptions(ExperimentId, request, headers, runtime);
}

model GetExperimentsStatisticsRequest {
  source?: string(name='Source', example='PaiStudio'),
  workspaceIds?: string(name='WorkspaceIds', example='123,345'),
}

model GetExperimentsStatisticsResponseBody = {
  data?: [ 
    {
      createCount?: long(name='CreateCount'),
      totalCount?: long(name='TotalCount'),
      workspaceId?: string(name='WorkspaceId'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
}

model GetExperimentsStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetExperimentsStatisticsResponseBody(name='body'),
}

async function getExperimentsStatisticsWithOptions(request: GetExperimentsStatisticsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetExperimentsStatisticsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.workspaceIds)) {
    query['WorkspaceIds'] = request.workspaceIds;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetExperimentsStatistics',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/statistics/experiments`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getExperimentsStatistics(request: GetExperimentsStatisticsRequest): GetExperimentsStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getExperimentsStatisticsWithOptions(request, headers, runtime);
}

model GetExperimentsUsersStatisticsRequest {
  source?: string(name='Source', example='PaiStudio'),
  workspaceId?: string(name='WorkspaceId', example='123'),
}

model GetExperimentsUsersStatisticsResponseBody = {
  requestId?: string(name='RequestId'),
  users?: [ 
    {
      userId?: string(name='UserId'),
    }
  ](name='Users'),
}

model GetExperimentsUsersStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetExperimentsUsersStatisticsResponseBody(name='body'),
}

async function getExperimentsUsersStatisticsWithOptions(request: GetExperimentsUsersStatisticsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetExperimentsUsersStatisticsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetExperimentsUsersStatistics',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/statistics/experimentsusers`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getExperimentsUsersStatistics(request: GetExperimentsUsersStatisticsRequest): GetExperimentsUsersStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getExperimentsUsersStatisticsWithOptions(request, headers, runtime);
}

model GetImageRequest {
  verbose?: boolean(name='Verbose'),
}

model GetImageResponseBody = {
  description?: string(name='Description'),
  gmtCreateTime?: string(name='GmtCreateTime', example='2021-01-21T17:12:35.232Z'),
  gmtModifiedTime?: string(name='GmtModifiedTime', example='2021-01-21T17:12:35.232Z'),
  imageUri?: string(name='ImageUri'),
  labels?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Labels'),
  name?: string(name='Name'),
  operatorCreate?: string(name='OperatorCreate'),
  parentOperatorCreate?: string(name='ParentOperatorCreate'),
  requestId?: string(name='requestId'),
}

model GetImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetImageResponseBody(name='body'),
}

async function getImageWithOptions(ImageId: string, request: GetImageRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetImageResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.verbose)) {
    query['Verbose'] = request.verbose;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetImage',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/images/${OpenApiUtil.getEncodeParam(ImageId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getImage(ImageId: string, request: GetImageRequest): GetImageResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getImageWithOptions(ImageId, request, headers, runtime);
}

model GetJobRequest {
  verbose?: boolean(name='Verbose'),
}

model GetJobResponseBody = {
  arguments?: string(name='Arguments'),
  creator?: string(name='Creator'),
  executeType?: string(name='ExecuteType'),
  experimentId?: string(name='ExperimentId'),
  gmtCreateTime?: string(name='GmtCreateTime'),
  jobId?: string(name='JobId'),
  nodeId?: string(name='NodeId'),
  paiflowNodeId?: string(name='PaiflowNodeId'),
  requestId?: string(name='RequestId'),
  runId?: string(name='RunId'),
  runInfo?: string(name='RunInfo'),
  snapshot?: string(name='Snapshot'),
  status?: string(name='Status'),
  workspaceId?: string(name='WorkspaceId'),
}

model GetJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetJobResponseBody(name='body'),
}

async function getJobWithOptions(JobId: string, request: GetJobRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetJobResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.verbose)) {
    query['Verbose'] = request.verbose;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetJob',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/jobs/${OpenApiUtil.getEncodeParam(JobId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getJob(JobId: string, request: GetJobRequest): GetJobResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getJobWithOptions(JobId, request, headers, runtime);
}

model GetMCTableSchemaRequest {
  workspaceId?: string(name='WorkspaceId'),
}

model GetMCTableSchemaResponseBody = {
  columns?: [ 
    {
      name?: string(name='Name'),
      preview?: [ string ](name='Preview'),
      type?: string(name='Type'),
    }
  ](name='Columns'),
  partitionColumns?: [ string ](name='PartitionColumns'),
  requestId?: string(name='RequestId'),
}

model GetMCTableSchemaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMCTableSchemaResponseBody(name='body'),
}

async function getMCTableSchemaWithOptions(TableName: string, request: GetMCTableSchemaRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetMCTableSchemaResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMCTableSchema',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/datasources/maxcompute/tables/${OpenApiUtil.getEncodeParam(TableName)}/schema`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMCTableSchema(TableName: string, request: GetMCTableSchemaRequest): GetMCTableSchemaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getMCTableSchemaWithOptions(TableName, request, headers, runtime);
}

model GetNodeInputSchemaRequest {
  inputId?: string(name='InputId', example='inputTable'),
  inputIndex?: int32(name='InputIndex', example='0'),
}

model GetNodeInputSchemaResponseBody = {
  colNames?: [ string ](name='ColNames'),
  colTypes?: [ string ](name='ColTypes'),
  requestId?: string(name='RequestId'),
}

model GetNodeInputSchemaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetNodeInputSchemaResponseBody(name='body'),
}

async function getNodeInputSchemaWithOptions(ExperimentId: string, NodeId: string, request: GetNodeInputSchemaRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetNodeInputSchemaResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.inputId)) {
    query['InputId'] = request.inputId;
  }
  if (!Util.isUnset(request.inputIndex)) {
    query['InputIndex'] = request.inputIndex;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetNodeInputSchema',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/experiments/${OpenApiUtil.getEncodeParam(ExperimentId)}/nodes/${OpenApiUtil.getEncodeParam(NodeId)}/schema`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getNodeInputSchema(ExperimentId: string, NodeId: string, request: GetNodeInputSchemaRequest): GetNodeInputSchemaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getNodeInputSchemaWithOptions(ExperimentId, NodeId, request, headers, runtime);
}

model GetNodeOutputRequest {
  outputIndex?: string(name='OutputIndex'),
}

model GetNodeOutputResponseBody = {
  algoName?: string(name='AlgoName'),
  displayName?: string(name='DisplayName'),
  locationType?: string(name='LocationType'),
  nodeName?: string(name='NodeName'),
  requestId?: string(name='RequestId'),
  type?: string(name='Type'),
  value?: map[string]any(name='Value'),
}

model GetNodeOutputResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetNodeOutputResponseBody(name='body'),
}

async function getNodeOutputWithOptions(ExperimentId: string, NodeId: string, OutputId: string, request: GetNodeOutputRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetNodeOutputResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.outputIndex)) {
    query['OutputIndex'] = request.outputIndex;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetNodeOutput',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/experiments/${OpenApiUtil.getEncodeParam(ExperimentId)}/nodes/${OpenApiUtil.getEncodeParam(NodeId)}/outputs/${OpenApiUtil.getEncodeParam(OutputId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getNodeOutput(ExperimentId: string, NodeId: string, OutputId: string, request: GetNodeOutputRequest): GetNodeOutputResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getNodeOutputWithOptions(ExperimentId, NodeId, OutputId, request, headers, runtime);
}

model GetNodeVisualizationRequest {
  config?: string(name='Config'),
}

model GetNodeVisualizationResponseBody = {
  content?: string(name='Content'),
  requestId?: string(name='RequestId'),
  visualizationType?: string(name='VisualizationType'),
}

model GetNodeVisualizationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetNodeVisualizationResponseBody(name='body'),
}

async function getNodeVisualizationWithOptions(ExperimentId: string, NodeId: string, VisualizationId: string, request: GetNodeVisualizationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetNodeVisualizationResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.config)) {
    query['Config'] = request.config;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetNodeVisualization',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/experiments/${OpenApiUtil.getEncodeParam(ExperimentId)}/nodes/${OpenApiUtil.getEncodeParam(NodeId)}/visualizations/${OpenApiUtil.getEncodeParam(VisualizationId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getNodeVisualization(ExperimentId: string, NodeId: string, VisualizationId: string, request: GetNodeVisualizationRequest): GetNodeVisualizationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getNodeVisualizationWithOptions(ExperimentId, NodeId, VisualizationId, request, headers, runtime);
}

model GetTemplateRequest {
  verbose?: boolean(name='Verbose'),
}

model GetTemplateResponseBody = {
  content?: string(name='Content', example='{     "metadata": {       "name": "实验名称",       "id": "pai_exp_xxxdfafafasfa",       "desc": "实验描述",     },     "nodes": [     ],     "edges": [     ],     "globalParams": [     ],     "globalSettings":[     ]  }'),
  description?: string(name='Description'),
  detail?: string(name='Detail'),
  docLink?: string(name='DocLink', example='URL://xxx'),
  imageLink?: string(name='ImageLink', example='URL://xxx'),
  labels?: [  map[string]any ](name='Labels'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
  sourceId?: string(name='SourceId'),
  sourceType?: string(name='SourceType'),
  templateId?: string(name='TemplateId', example='template-12345'),
  templateType?: string(name='TemplateType'),
}

model GetTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTemplateResponseBody(name='body'),
}

async function getTemplateWithOptions(TemplateId: string, request: GetTemplateRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetTemplateResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.verbose)) {
    query['Verbose'] = request.verbose;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTemplate',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/templates/${OpenApiUtil.getEncodeParam(TemplateId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTemplate(TemplateId: string, request: GetTemplateRequest): GetTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTemplateWithOptions(TemplateId, request, headers, runtime);
}

model ListAlgoDefsRequest {
  body?: [ 
    {
      identifier?: string(name='Identifier'),
      provider?: string(name='Provider'),
      signature?: string(name='Signature'),
      version?: string(name='Version'),
    }
  ](name='body'),
}

model ListAlgoDefsResponseBody = {
  data?: [  map[string]any ](name='Data'),
  requestId?: string(name='RequestId'),
}

model ListAlgoDefsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAlgoDefsResponseBody(name='body'),
}

async function listAlgoDefsWithOptions(request: ListAlgoDefsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAlgoDefsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = Util.toArray(request.body),
  };
  var params = new OpenApi.Params{
    action = 'ListAlgoDefs',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/algo/detail`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAlgoDefs(request: ListAlgoDefsRequest): ListAlgoDefsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAlgoDefsWithOptions(request, headers, runtime);
}

model ListAuthRolesRequest {
  isGenerateToken?: string(name='IsGenerateToken'),
  workspaceId?: string(name='WorkspaceId'),
}

model ListAuthRolesResponseBody = {
  requestId?: string(name='RequestId'),
  roles?: [ 
    {
      isEnabled?: string(name='IsEnabled'),
      roleARN?: string(name='RoleARN'),
      roleName?: string(name='RoleName'),
      roleType?: string(name='RoleType'),
      token?: {
        accessKeyId?: string(name='AccessKeyId'),
        accessKeySecret?: string(name='AccessKeySecret'),
        expiration?: string(name='Expiration'),
        securityToken?: string(name='SecurityToken'),
      }(name='Token'),
    }
  ](name='Roles'),
}

model ListAuthRolesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAuthRolesResponseBody(name='body'),
}

async function listAuthRolesWithOptions(request: ListAuthRolesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAuthRolesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.isGenerateToken)) {
    query['IsGenerateToken'] = request.isGenerateToken;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAuthRoles',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/authorization/roles`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAuthRoles(request: ListAuthRolesRequest): ListAuthRolesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAuthRolesWithOptions(request, headers, runtime);
}

model ListExperimentsRequest {
  creator?: string(name='Creator', example='1326689413376250'),
  experimentId?: string(name='ExperimentId', example='experiment-rbvg5wzljzjhc9ks92'),
  name?: string(name='Name'),
  order?: string(name='Order', example='DESC'),
  pageNumber?: int32(name='PageNumber', example='1'),
  pageSize?: int32(name='PageSize', example='10'),
  sortBy?: string(name='SortBy', example='GmtCreate'),
  source?: string(name='Source', example='PaiStudio'),
  workspaceId?: string(name='WorkspaceId', example='34875'),
}

model ListExperimentsResponseBody = {
  experiments?: [ 
    {
      accessibility?: string(name='Accessibility', example='PUBLIC'),
      creator?: string(name='Creator', example='1326689413376250'),
      description?: string(name='Description'),
      experimentId?: string(name='ExperimentId', example='experiment-rbvg5wzljzjhc9ks92'),
      gmtCreateTime?: string(name='GmtCreateTime', example='2021-01-30T12:51:33.028Z'),
      gmtModifiedTime?: string(name='GmtModifiedTime', example='2021-01-30T12:51:33.028Z'),
      name?: string(name='Name'),
      source?: string(name='Source', example='PaiStudio'),
      version?: long(name='Version', example='12'),
      workspaceId?: string(name='WorkspaceId', example='23487'),
    }
  ](name='Experiments'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount', example='15'),
}

model ListExperimentsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListExperimentsResponseBody(name='body'),
}

async function listExperimentsWithOptions(request: ListExperimentsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListExperimentsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.creator)) {
    query['Creator'] = request.creator;
  }
  if (!Util.isUnset(request.experimentId)) {
    query['ExperimentId'] = request.experimentId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sortBy)) {
    query['SortBy'] = request.sortBy;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListExperiments',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/experiments`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listExperiments(request: ListExperimentsRequest): ListExperimentsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listExperimentsWithOptions(request, headers, runtime);
}

model ListImageLabelsRequest {
  imageId?: string(name='ImageId'),
  labelFilter?: string(name='LabelFilter', example='a=b,c=d'),
  labelKeys?: string(name='LabelKeys', example='ImageType,Framework,Platform'),
}

model ListImageLabelsResponseBody = {
  labels?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Labels'),
  totalCount?: long(name='TotalCount', example='2'),
  requestId?: string(name='requestId'),
}

model ListImageLabelsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListImageLabelsResponseBody(name='body'),
}

async function listImageLabelsWithOptions(request: ListImageLabelsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListImageLabelsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.imageId)) {
    query['ImageId'] = request.imageId;
  }
  if (!Util.isUnset(request.labelFilter)) {
    query['LabelFilter'] = request.labelFilter;
  }
  if (!Util.isUnset(request.labelKeys)) {
    query['LabelKeys'] = request.labelKeys;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListImageLabels',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/image/labels`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listImageLabels(request: ListImageLabelsRequest): ListImageLabelsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listImageLabelsWithOptions(request, headers, runtime);
}

model ListImagesRequest {
  labels?: string(name='Labels', example='Framework="Tensorflow 1.0",Framework="Tensorflow 2.0",Platform="GPU"'),
  name?: string(name='Name'),
  order?: string(name='Order'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  sortBy?: string(name='SortBy', example='GmtCreateTime'),
  verbose?: boolean(name='Verbose', example='true'),
}

model ListImagesResponseBody = {
  images?: [ 
    {
      description?: string(name='Description'),
      gmtCreateTime?: string(name='GmtCreateTime', example='2021-01-21T17:12:35.232Z'),
      imageId?: string(name='ImageId', example='image-tzi7f9czc0cxs9s45t'),
      imageUri?: string(name='ImageUri'),
      labels?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Labels'),
      name?: string(name='Name'),
    }
  ](name='Images'),
  totalCount?: long(name='TotalCount', example='2'),
  requestId?: string(name='requestId'),
}

model ListImagesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListImagesResponseBody(name='body'),
}

async function listImagesWithOptions(request: ListImagesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListImagesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.labels)) {
    query['Labels'] = request.labels;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sortBy)) {
    query['SortBy'] = request.sortBy;
  }
  if (!Util.isUnset(request.verbose)) {
    query['Verbose'] = request.verbose;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListImages',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/images`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listImages(request: ListImagesRequest): ListImagesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listImagesWithOptions(request, headers, runtime);
}

model ListJobsRequest {
  creator?: string(name='Creator'),
  experimentId?: string(name='ExperimentId'),
  order?: string(name='Order'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListJobsResponseBody = {
  jobs?: [ 
    {
      creator?: string(name='Creator'),
      executeType?: string(name='ExecuteType'),
      experimentId?: string(name='ExperimentId'),
      gmtCreateTime?: string(name='GmtCreateTime'),
      jobId?: string(name='JobId'),
      nodeId?: string(name='NodeId'),
      paiflowNodeId?: string(name='PaiflowNodeId'),
      runId?: string(name='RunId'),
      status?: string(name='Status'),
      workspaceId?: string(name='WorkspaceId'),
    }
  ](name='Jobs'),
  requestId?: string(name='RequestId'),
}

model ListJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListJobsResponseBody(name='body'),
}

async function listJobsWithOptions(request: ListJobsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListJobsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.creator)) {
    query['Creator'] = request.creator;
  }
  if (!Util.isUnset(request.experimentId)) {
    query['ExperimentId'] = request.experimentId;
  }
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListJobs',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/jobs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listJobs(request: ListJobsRequest): ListJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listJobsWithOptions(request, headers, runtime);
}

model ListNodeOutputsResponseBody = {
  outputs?: [ 
    {
      algoName?: string(name='AlgoName'),
      displayName?: string(name='DisplayName'),
      locationType?: string(name='LocationType'),
      nodeName?: string(name='NodeName'),
      outputId?: string(name='OutputId'),
      outputIndex?: string(name='OutputIndex'),
      type?: string(name='Type'),
      value?: map[string]any(name='Value'),
    }
  ](name='Outputs'),
  requestId?: string(name='RequestId'),
}

model ListNodeOutputsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListNodeOutputsResponseBody(name='body'),
}

async function listNodeOutputsWithOptions(ExperimentId: string, NodeId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListNodeOutputsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListNodeOutputs',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/experiments/${OpenApiUtil.getEncodeParam(ExperimentId)}/nodes/${OpenApiUtil.getEncodeParam(NodeId)}/outputs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listNodeOutputs(ExperimentId: string, NodeId: string): ListNodeOutputsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listNodeOutputsWithOptions(ExperimentId, NodeId, headers, runtime);
}

model ListRecentExperimentsRequest {
  order?: string(name='Order'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  source?: string(name='Source'),
  type?: string(name='Type'),
  workspaceId?: string(name='WorkspaceId'),
}

model ListRecentExperimentsResponseBody = {
  experiments?: [ 
    {
      description?: string(name='Description'),
      experimentId?: string(name='ExperimentId'),
      modifyCnt?: long(name='ModifyCnt'),
      name?: string(name='Name'),
      recentGmtModifiedTime?: string(name='RecentGmtModifiedTime'),
      source?: string(name='Source'),
      workspaceId?: string(name='WorkspaceId'),
      workspaceName?: string(name='WorkspaceName'),
    }
  ](name='Experiments'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model ListRecentExperimentsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRecentExperimentsResponseBody(name='body'),
}

async function listRecentExperimentsWithOptions(request: ListRecentExperimentsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRecentExperimentsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRecentExperiments',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/recentexperiments`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listRecentExperiments(request: ListRecentExperimentsRequest): ListRecentExperimentsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRecentExperimentsWithOptions(request, headers, runtime);
}

model ListTemplatesRequest {
  label?: string(name='Label'),
  list?: string(name='List', example='types'),
  name?: string(name='Name'),
  order?: string(name='Order', example='DESC'),
  pageNumber?: int32(name='PageNumber', example='1'),
  pageSize?: int32(name='PageSize', example='20'),
  sortBy?: string(name='SortBy'),
  source?: string(name='Source', example='PaiStudio'),
  tagId?: string(name='TagId', example='template-tag-12345'),
  templateType?: string(name='TemplateType'),
  typeId?: string(name='TypeId', example='template-type-12345'),
  verbose?: boolean(name='Verbose'),
  workspaceId?: string(name='WorkspaceId'),
}

model ListTemplatesResponseBody = {
  requestId?: string(name='RequestId'),
  templateData?: [ 
    {
      template?: {
        content?: string(name='Content', example='{}'),
        creator?: string(name='Creator'),
        description?: string(name='Description'),
        detail?: string(name='Detail'),
        docLink?: string(name='DocLink', example='url://xxx'),
        gmtCreateTime?: string(name='GmtCreateTime'),
        gmtModifiedTime?: string(name='GmtModifiedTime'),
        imageLink?: string(name='ImageLink', example='url://xxx'),
        labels?: [  map[string]any ](name='Labels'),
        name?: string(name='Name'),
        templateId?: string(name='TemplateId', example='template-rbvg5wzljzjhc9ks92'),
      }(name='Template'),
      templateTag?: {
        name?: string(name='Name', example='PyTorch'),
        tagId?: string(name='TagId', example='template-tag-rbvg5wzljzjhc9ks92'),
        typeId?: string(name='TypeId', example='template-tag-type-rbvg5wzljzjhc9ks92'),
      }(name='TemplateTag'),
      templateType?: {
        name?: string(name='Name', example='行业分类'),
        typeId?: string(name='TypeId', example='templatetagtype-rbvg5wzljzjhc9ks92'),
      }(name='TemplateType'),
    }
  ](name='TemplateData'),
  totalCount?: int32(name='TotalCount', example='15'),
}

model ListTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTemplatesResponseBody(name='body'),
}

async function listTemplatesWithOptions(request: ListTemplatesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTemplatesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.label)) {
    query['Label'] = request.label;
  }
  if (!Util.isUnset(request.list)) {
    query['List'] = request.list;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sortBy)) {
    query['SortBy'] = request.sortBy;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.tagId)) {
    query['TagId'] = request.tagId;
  }
  if (!Util.isUnset(request.templateType)) {
    query['TemplateType'] = request.templateType;
  }
  if (!Util.isUnset(request.typeId)) {
    query['TypeId'] = request.typeId;
  }
  if (!Util.isUnset(request.verbose)) {
    query['Verbose'] = request.verbose;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTemplates',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/templates`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTemplates(request: ListTemplatesRequest): ListTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTemplatesWithOptions(request, headers, runtime);
}

model MigrateExperimentFoldersRequest {
  accessibility?: string(name='Accessibility'),
  isOwner?: boolean(name='IsOwner'),
  workspaceId?: string(name='WorkspaceId'),
}

model MigrateExperimentFoldersResponseBody = {
  code?: string(name='Code'),
  folderIdMapping?: map[string]object(name='FolderIdMapping'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model MigrateExperimentFoldersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MigrateExperimentFoldersResponseBody(name='body'),
}

async function migrateExperimentFoldersWithOptions(request: MigrateExperimentFoldersRequest, headers: map[string]string, runtime: Util.RuntimeOptions): MigrateExperimentFoldersResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessibility)) {
    query['Accessibility'] = request.accessibility;
  }
  if (!Util.isUnset(request.isOwner)) {
    query['IsOwner'] = request.isOwner;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'MigrateExperimentFolders',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/migrate/folders`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function migrateExperimentFolders(request: MigrateExperimentFoldersRequest): MigrateExperimentFoldersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return migrateExperimentFoldersWithOptions(request, headers, runtime);
}

model MigrateExperimentsRequest {
  accessibility?: string(name='Accessibility'),
  destFolderId?: string(name='DestFolderId'),
  isOwner?: boolean(name='IsOwner'),
  sourceExpId?: long(name='SourceExpId'),
  updateIfExists?: boolean(name='UpdateIfExists'),
  workspaceId?: string(name='WorkspaceId'),
}

model MigrateExperimentsResponseBody = {
  code?: string(name='Code'),
  data?: {
    alreadyExists?: boolean(name='AlreadyExists'),
    experimentId?: string(name='ExperimentId'),
    updated?: boolean(name='Updated'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model MigrateExperimentsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MigrateExperimentsResponseBody(name='body'),
}

async function migrateExperimentsWithOptions(request: MigrateExperimentsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): MigrateExperimentsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accessibility)) {
    query['Accessibility'] = request.accessibility;
  }
  if (!Util.isUnset(request.destFolderId)) {
    query['DestFolderId'] = request.destFolderId;
  }
  if (!Util.isUnset(request.isOwner)) {
    query['IsOwner'] = request.isOwner;
  }
  if (!Util.isUnset(request.sourceExpId)) {
    query['SourceExpId'] = request.sourceExpId;
  }
  if (!Util.isUnset(request.updateIfExists)) {
    query['UpdateIfExists'] = request.updateIfExists;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'MigrateExperiments',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/migrate/experiments`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function migrateExperiments(request: MigrateExperimentsRequest): MigrateExperimentsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return migrateExperimentsWithOptions(request, headers, runtime);
}

model PreviewMCTableRequest {
  endpoint?: string(name='Endpoint'),
  limit?: int32(name='Limit'),
  partition?: string(name='Partition'),
  workspaceId?: string(name='WorkspaceId'),
}

model PreviewMCTableResponseBody = {
  content?: [[ string ]  ](name='Content'),
  requestId?: string(name='RequestId'),
}

model PreviewMCTableResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PreviewMCTableResponseBody(name='body'),
}

async function previewMCTableWithOptions(TableName: string, request: PreviewMCTableRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PreviewMCTableResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.endpoint)) {
    query['Endpoint'] = request.endpoint;
  }
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.partition)) {
    query['Partition'] = request.partition;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PreviewMCTable',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/datasources/maxcompute/tables/${OpenApiUtil.getEncodeParam(TableName)}/preview`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function previewMCTable(TableName: string, request: PreviewMCTableRequest): PreviewMCTableResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return previewMCTableWithOptions(TableName, request, headers, runtime);
}

model PublishExperimentRequest {
  folderId?: string(name='FolderId', example='root'),
}

model PublishExperimentResponseBody = {
  requestId?: string(name='RequestId'),
}

model PublishExperimentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PublishExperimentResponseBody(name='body'),
}

async function publishExperimentWithOptions(ExperimentId: string, request: PublishExperimentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PublishExperimentResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.folderId)) {
    body['FolderId'] = request.folderId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PublishExperiment',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/experiments/${OpenApiUtil.getEncodeParam(ExperimentId)}/publish`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function publishExperiment(ExperimentId: string, request: PublishExperimentRequest): PublishExperimentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return publishExperimentWithOptions(ExperimentId, request, headers, runtime);
}

model QueryExperimentVisualizationDataRequest {
  body?: [ 
    {
      endTime?: string(name='EndTime'),
      nodeId?: string(name='NodeId'),
      startTime?: string(name='StartTime'),
      visualizationDataIds?: [ string ](name='VisualizationDataIds'),
    }
  ](name='body'),
}

model QueryExperimentVisualizationDataResponseBody = {
  visualizationData?: [ 
    {
      createTime?: string(name='CreateTime'),
      data?: string(name='Data'),
      dataId?: string(name='DataId'),
      nodeId?: string(name='NodeId'),
    }
  ](name='VisualizationData'),
  requestId?: string(name='requestId'),
}

model QueryExperimentVisualizationDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryExperimentVisualizationDataResponseBody(name='body'),
}

async function queryExperimentVisualizationDataWithOptions(ExperimentId: string, request: QueryExperimentVisualizationDataRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryExperimentVisualizationDataResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = Util.toArray(request.body),
  };
  var params = new OpenApi.Params{
    action = 'QueryExperimentVisualizationData',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/experiments/${OpenApiUtil.getEncodeParam(ExperimentId)}/visualizationDataQuery`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryExperimentVisualizationData(ExperimentId: string, request: QueryExperimentVisualizationDataRequest): QueryExperimentVisualizationDataResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryExperimentVisualizationDataWithOptions(ExperimentId, request, headers, runtime);
}

model RemoveImageResponseBody = {
  requestId?: string(name='requestId'),
}

model RemoveImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveImageResponseBody(name='body'),
}

async function removeImageWithOptions(ImageId: string, headers: map[string]string, runtime: Util.RuntimeOptions): RemoveImageResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'RemoveImage',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/images/${OpenApiUtil.getEncodeParam(ImageId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removeImage(ImageId: string): RemoveImageResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return removeImageWithOptions(ImageId, headers, runtime);
}

model RemoveImageLabelsResponseBody = {
  requestId?: string(name='requestId'),
}

model RemoveImageLabelsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveImageLabelsResponseBody(name='body'),
}

async function removeImageLabelsWithOptions(ImageId: string, LabelKey: string, headers: map[string]string, runtime: Util.RuntimeOptions): RemoveImageLabelsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'RemoveImageLabels',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/images/${OpenApiUtil.getEncodeParam(ImageId)}/labels/${OpenApiUtil.getEncodeParam(LabelKey)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removeImageLabels(ImageId: string, LabelKey: string): RemoveImageLabelsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return removeImageLabelsWithOptions(ImageId, LabelKey, headers, runtime);
}

model SearchMCTablesRequest {
  keyword?: string(name='Keyword'),
  workspaceId?: string(name='WorkspaceId'),
}

model SearchMCTablesResponseBody = {
  requestId?: string(name='RequestId'),
  tables?: [ string ](name='Tables'),
}

model SearchMCTablesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchMCTablesResponseBody(name='body'),
}

async function searchMCTablesWithOptions(request: SearchMCTablesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SearchMCTablesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query['WorkspaceId'] = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchMCTables',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/datasources/maxcompute/tables`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchMCTables(request: SearchMCTablesRequest): SearchMCTablesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return searchMCTablesWithOptions(request, headers, runtime);
}

model StopExperimentResponseBody = {
  requestId?: string(name='RequestId'),
}

model StopExperimentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopExperimentResponseBody(name='body'),
}

async function stopExperimentWithOptions(ExperimentId: string, headers: map[string]string, runtime: Util.RuntimeOptions): StopExperimentResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StopExperiment',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/experiments/${OpenApiUtil.getEncodeParam(ExperimentId)}/stop`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopExperiment(ExperimentId: string): StopExperimentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopExperimentWithOptions(ExperimentId, headers, runtime);
}

model StopJobResponseBody = {
  requestId?: string(name='RequestId'),
}

model StopJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopJobResponseBody(name='body'),
}

async function stopJobWithOptions(JobId: string, headers: map[string]string, runtime: Util.RuntimeOptions): StopJobResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StopJob',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/jobs/${OpenApiUtil.getEncodeParam(JobId)}/stop`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopJob(JobId: string): StopJobResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopJobWithOptions(JobId, headers, runtime);
}

model UpdateExperimentContentRequest {
  content?: string(name='Content', example='{     "metadata": {       "name": "实验名称",       "id": "pai_exp_xxxdfafafasfa",       "desc": "实验描述",     },     "nodes": [     ],     "edges": [     ],     "globalParams": [     ],     "globalSettings":[     ]  }'),
  version?: long(name='Version', example='11'),
}

model UpdateExperimentContentResponseBody = {
  requestId?: string(name='RequestId'),
  version?: long(name='Version', example='12'),
}

model UpdateExperimentContentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateExperimentContentResponseBody(name='body'),
}

async function updateExperimentContentWithOptions(ExperimentId: string, request: UpdateExperimentContentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateExperimentContentResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.content)) {
    body['Content'] = request.content;
  }
  if (!Util.isUnset(request.version)) {
    body['Version'] = request.version;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateExperimentContent',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/experiments/${OpenApiUtil.getEncodeParam(ExperimentId)}/content`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateExperimentContent(ExperimentId: string, request: UpdateExperimentContentRequest): UpdateExperimentContentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateExperimentContentWithOptions(ExperimentId, request, headers, runtime);
}

model UpdateExperimentFolderRequest {
  name?: string(name='Name'),
  parentFolderId?: string(name='ParentFolderId'),
}

model UpdateExperimentFolderResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateExperimentFolderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateExperimentFolderResponseBody(name='body'),
}

async function updateExperimentFolderWithOptions(FolderId: string, request: UpdateExperimentFolderRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateExperimentFolderResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.parentFolderId)) {
    body['ParentFolderId'] = request.parentFolderId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateExperimentFolder',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/experimentfolders/${OpenApiUtil.getEncodeParam(FolderId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateExperimentFolder(FolderId: string, request: UpdateExperimentFolderRequest): UpdateExperimentFolderResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateExperimentFolderWithOptions(FolderId, request, headers, runtime);
}

model UpdateExperimentMetaRequest {
  accessibility?: string(name='Accessibility', example='PUBLIC'),
  description?: string(name='Description'),
  folderId?: string(name='FolderId'),
  name?: string(name='Name'),
  options?: string(name='Options', example='{"mlflow":{"experimentId":"exp-1"}}'),
}

model UpdateExperimentMetaResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateExperimentMetaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateExperimentMetaResponseBody(name='body'),
}

async function updateExperimentMetaWithOptions(ExperimentId: string, request: UpdateExperimentMetaRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateExperimentMetaResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.accessibility)) {
    body['Accessibility'] = request.accessibility;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.folderId)) {
    body['FolderId'] = request.folderId;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.options)) {
    body['Options'] = request.options;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateExperimentMeta',
    version = '2021-02-02',
    protocol = 'HTTPS',
    pathname = `/api/v1/experiments/${OpenApiUtil.getEncodeParam(ExperimentId)}/meta`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateExperimentMeta(ExperimentId: string, request: UpdateExperimentMetaRequest): UpdateExperimentMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateExperimentMetaWithOptions(ExperimentId, request, headers, runtime);
}

