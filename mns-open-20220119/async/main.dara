/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'Mns-open';
  @version = '2022-01-19';
  @endpointRule = 'regional';
  @endpointMap = {
  };
}

function close(): void {
  @handler.close();
}

model CreateQueueRequest {
  regionId?: string(name='RegionId', position='Host'),
  delaySeconds?: long(name='DelaySeconds', description='The period after which all messages sent to the queue are consumed. Valid values: 0 to 604800. Unit: seconds. Default value: 0', example='0', position='Query'),
  enableLogging?: boolean(name='EnableLogging', description='Specifies whether to enable the logging feature. Valid values:

*   True
*   False (default)', example='true', position='Query'),
  maximumMessageSize?: long(name='MaximumMessageSize', description='The maximum length of the message that is sent to the queue. Valid values: 1024 to 65536. Unit: bytes. Default value: 65536.', example='65536', position='Query'),
  messageRetentionPeriod?: long(name='MessageRetentionPeriod', description='The maximum duration for which a message is retained in the queue. After the specified retention period ends, the message is deleted regardless of whether the message is received. Valid values: 60 to 604800. Unit: seconds. Default value: 345600.', example='345600', position='Query'),
  pollingWaitSeconds?: long(name='PollingWaitSeconds', description='The maximum duration for which long polling requests are held after the ReceiveMessage operation is called. Valid values: 0 to 30. Unit: seconds. Default value: 0', example='0', position='Query'),
  queueName: string(name='QueueName', description='The name of the queue.', example='06273500-249F-5863-121D-74D51123****', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
  visibilityTimeout?: long(name='VisibilityTimeout', description='The duration for which a message stays in the Inactive state after the message is received from the queue. Valid values: 1 to 43200. Unit: seconds. Default value: 30.', example='60', position='Query'),
}

model CreateQueueResponseBody = {
  code?: long(name='Code', description='The response code.', example='200'),
  data?: {
    code?: long(name='Code', description='The response code.', example='200'),
    message?: string(name='Message', description='The returned message.'),
    success?: boolean(name='Success', description='Indicates whether the request was successful.', example='true'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned message.', example='operation success'),
  requestId?: string(name='RequestId', description='The request ID.', example='06273500-249F-5863-121D-74D51123E62C'),
  status?: string(name='Status', description='The response status.', example='Success'),
  success?: boolean(name='Success', description='Indicates whether the request was successful.', example='true'),
}

model CreateQueueResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateQueueResponseBody(name='body'),
}

async function createQueue(request: CreateQueueRequest): CreateQueueResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateQueue', 'POST', '/', 'json', false, 'json', request);
}

model CreateTopicRequest {
  regionId?: string(name='RegionId', position='Host'),
  enableLogging?: boolean(name='EnableLogging', description='Specifies whether to enable the logging feature. Valid values:

*   True
*   False (default)', example='true', position='Body'),
  maxMessageSize?: long(name='MaxMessageSize', description='The maximum length of the message that is sent to the topic. Valid values: 1024 to 65536. Unit: bytes. Default value: 65536.', example='10240', position='Body'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key.', example='tag1'),
      value?: string(name='Value', description='The tag value.', example='joyce.wang'),
    }
  ](name='Tag', description='The tags.', position='Query'),
  topicName: string(name='TopicName', description='The name of the topic that you want to create.', example='test', position='Body'),
}

model CreateTopicResponseBody = {
  code?: long(name='Code', description='The response code.', example='200'),
  data?: {
    code?: long(name='Code', description='The response code.', example='200'),
    message?: string(name='Message', description='The returned message.'),
    success?: boolean(name='Success', description='Indicates whether the request was successful.', example='true'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned message.', example='operation success'),
  requestId?: string(name='RequestId', description='The request ID.', example='06273500-249F-5863-121D-74D51123E62C'),
  status?: string(name='Status', description='The response status.', example='Success'),
  success?: boolean(name='Success', description='Indicates whether the request was successful.', example='true'),
}

model CreateTopicResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateTopicResponseBody(name='body'),
}

async function createTopic(request: CreateTopicRequest): CreateTopicResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateTopic', 'POST', '/', 'json', true, 'form', request);
}

model DeleteQueueRequest {
  regionId?: string(name='RegionId', position='Host'),
  queueName: string(name='QueueName', description='The name of the queue.', example='tf-testAccMNSQueue-525478433321945943', position='Query'),
}

model DeleteQueueResponseBody = {
  code?: long(name='Code', description='The response code.', example='200'),
  data?: {
    code?: long(name='Code', description='The response code.', example='200'),
    message?: string(name='Message', description='The returned message.'),
    success?: boolean(name='Success', description='Indicates whether the request was successful.', example='true'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned message.', example='operation success'),
  requestId?: string(name='RequestId', description='The request ID.', example='06273500-249F-5863-121D-74D51123****'),
  status?: string(name='Status', description='The response status.', example='Success'),
  success?: boolean(name='Success', description='Indicates whether the request was successful.', example='true'),
}

model DeleteQueueResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteQueueResponseBody(name='body'),
}

async function deleteQueue(request: DeleteQueueRequest): DeleteQueueResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteQueue', 'POST', '/', 'json', false, 'json', request);
}

model DeleteTopicRequest {
  regionId?: string(name='RegionId', position='Host'),
  topicName: string(name='TopicName', description='The name of the topic that you want to delete.', example='tf-testAccMNSTopic-112965059402264645', position='Query'),
}

model DeleteTopicResponseBody = {
  code?: long(name='Code', description='The response code.', example='200'),
  data?: map[string]any(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned message.', example='operation success'),
  requestId?: string(name='RequestId', description='The request ID.', example='06273500-249F-5863-121D-74D51123****'),
  status?: string(name='Status', description='The response status.', example='Success'),
  success?: boolean(name='Success', description='Indicates whether the request was successful.', example='true'),
}

model DeleteTopicResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteTopicResponseBody(name='body'),
}

async function deleteTopic(request: DeleteTopicRequest): DeleteTopicResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteTopic', 'POST', '/', 'json', false, 'json', request);
}

model GetQueueAttributesRequest {
  regionId?: string(name='RegionId', position='Host'),
  queueName: string(name='QueueName', description='The name of the queue.', example='demo-queue', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model GetQueueAttributesResponseBody = {
  code?: long(name='Code', description='The response code.', example='200'),
  data?: {
    activeMessages?: long(name='ActiveMessages', description='The total number of messages that are in the Active state in the queue. The value is an approximate number.', example='20'),
    createTime?: long(name='CreateTime', description='The time when the queue was created.', example='1250700999'),
    delayMessages?: long(name='DelayMessages', description='The total number of the messages that are in the Delayed state in the queue. The value is an approximate number.', example='0'),
    delaySeconds?: long(name='DelaySeconds', description='The period after which all messages sent to the queue are consumed. Unit: seconds.', example='30'),
    inactiveMessages?: long(name='InactiveMessages', description='The total number of the messages that are in the Inactive state in the queue. The value is an approximate number.', example='0'),
    lastModifyTime?: long(name='LastModifyTime', description='The time when the queue was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1250700999'),
    loggingEnabled?: boolean(name='LoggingEnabled', description='Indicates whether the logging feature is enabled. Valid values:

*   True
*   False', example='True'),
    maximumMessageSize?: long(name='MaximumMessageSize', description='The maximum length of the message that is sent to the queue. Unit: bytes.', example='65536'),
    messageRetentionPeriod?: long(name='MessageRetentionPeriod', description='The maximum duration for which a message is retained in the queue. After the specified retention period ends, the message is deleted regardless of whether the message is received. Unit: seconds.', example='65536'),
    pollingWaitSeconds?: long(name='PollingWaitSeconds', description='The maximum duration for which long polling requests are held after the ReceiveMessage operation is called. Unit: seconds.', example='0'),
    queueName?: string(name='QueueName', description='The name of the queue.', example='demo-queue'),
    tags?: [ 
      {
        tagKey?: string(name='TagKey'),
        tagValue?: string(name='TagValue'),
      }
    ](name='Tags'),
    visibilityTimeout?: long(name='VisibilityTimeout', description='The duration for which a message stays in the Inactive state after the message is received from the queue. Valid values: 1 to 43200. Unit: seconds. Default value: 30.', example='60'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned message.', example='operation success'),
  requestId?: string(name='RequestId', description='The request ID.', example='06273500-249F-5863-121D-74D51123****'),
  status?: string(name='Status', description='The response status.', example='Success'),
  success?: boolean(name='Success', description='Indicates whether the request was successful.', example='true'),
}

model GetQueueAttributesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetQueueAttributesResponseBody(name='body'),
}

async function getQueueAttributes(request: GetQueueAttributesRequest): GetQueueAttributesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetQueueAttributes', 'POST', '/', 'json', false, 'json', request);
}

model GetSubscriptionAttributesRequest {
  regionId?: string(name='RegionId', position='Host'),
  subscriptionName: string(name='SubscriptionName', description='The name of the subscription.', example='MySubscription', position='Query'),
  topicName: string(name='TopicName', description='The name of the topic.', example='MyTopic', position='Query'),
}

model GetSubscriptionAttributesResponseBody = {
  code?: long(name='Code', description='The response code.', example='200'),
  data?: {
    createTime?: long(name='CreateTime', description='The time when the subscription was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1449554806'),
    endpoint?: string(name='Endpoint', description='The endpoint to which the messages are pushed.', example='http://example.com'),
    filterTag?: string(name='FilterTag', description='The tag that is used to filter messages. Only the messages that are attached with the specified tag can be pushed.', example='important'),
    lastModifyTime?: long(name='LastModifyTime', description='The time when the subscription was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1449554962'),
    notifyContentFormat?: string(name='NotifyContentFormat', description='The content format of the messages that are pushed to the endpoint. Valid values:

*   XML
*   JSON
*   SIMPLIFIED', example='XML'),
    notifyStrategy?: string(name='NotifyStrategy', description='The retry policy that is applied if an error occurs when Message Service (MNS) pushes messages to the endpoint. Valid values:

*   BACKOFF_RETRY
*   EXPONENTIAL_DECAY_RETRY', example='BACKOFF_RETRY'),
    subscriptionName?: string(name='SubscriptionName', description='The name of the subscription.', example='MySubscription'),
    topicName?: string(name='TopicName', description='The name of the topic.', example='MyTopic'),
    topicOwner?: string(name='TopicOwner', description='The Alibaba Cloud account ID of the topic owner.', example='123456789098****'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned message.', example='operation success'),
  requestId?: string(name='RequestId', description='The request ID.', example='06273500-249F-5863-121D-74D51123****'),
  status?: string(name='Status', description='The response status.', example='Success'),
  success?: boolean(name='Success', description='Indicates whether the request was successful.', example='true'),
}

model GetSubscriptionAttributesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetSubscriptionAttributesResponseBody(name='body'),
}

async function getSubscriptionAttributes(request: GetSubscriptionAttributesRequest): GetSubscriptionAttributesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetSubscriptionAttributes', 'POST', '/', 'json', false, 'json', request);
}

model GetTopicAttributesRequest {
  regionId?: string(name='RegionId', position='Host'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
  topicName: string(name='TopicName', description='The name of the topic.', example='demo-topic', position='Query'),
}

model GetTopicAttributesResponseBody = {
  code?: long(name='Code', description='The response code.', example='200'),
  data?: {
    createTime?: long(name='CreateTime', description='The time when the topic was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1449554277'),
    lastModifyTime?: long(name='LastModifyTime', description='The time when the topic was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1449554460'),
    loggingEnabled?: boolean(name='LoggingEnabled', description='Indicates whether the logging feature is enabled. Valid values:

*   True
*   False', example='True'),
    maxMessageSize?: long(name='MaxMessageSize', description='The maximum length of the message that is sent to the topic. Unit: bytes.', example='65536'),
    messageCount?: long(name='MessageCount', description='The number of messages in the topic.', example='0'),
    messageRetentionPeriod?: long(name='MessageRetentionPeriod', description='The maximum duration for which a message is retained in the topic. After the specified retention period ends, the message is deleted regardless of whether the message is received. Unit: seconds.', example='86400'),
    tags?: [ 
      {
        tagKey?: string(name='TagKey'),
        tagValue?: string(name='TagValue'),
      }
    ](name='Tags'),
    topicName?: string(name='TopicName', description='The name of the topic.', example='demo-topic'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned message.', example='operation success'),
  requestId?: string(name='RequestId', description='The request ID.', example='06273500-249F-5863-121D-74D51123****'),
  status?: string(name='Status', description='The response status.', example='Success'),
  success?: boolean(name='Success', description='Indicates whether the request was successful.', example='true'),
}

model GetTopicAttributesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetTopicAttributesResponseBody(name='body'),
}

async function getTopicAttributes(request: GetTopicAttributesRequest): GetTopicAttributesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetTopicAttributes', 'POST', '/', 'json', false, 'json', request);
}

model ListQueueRequest {
  regionId?: string(name='RegionId', position='Host'),
  pageNum?: long(name='PageNum', description='The page number. Valid values: 1 to 100000000. If you set this parameter to a value smaller than 1, the value of this parameter is 1 by default. If you set this parameter to a value greater than 100000000, the value of this parameter is 100000000 by default.', example='1', position='Query'),
  pageSize?: long(name='PageSize', description='The number of entries per page. Value values: 10 to 50. If you set this parameter to a value smaller than 10, the value of this parameter is 10 by default. If you set this parameter to a value greater than 50, the value of this parameter is 50 by default.', example='20', position='Query'),
  queueName?: string(name='QueueName', description='The name of the queue.', example='demo-queue', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model ListQueueResponseBody = {
  code?: long(name='Code', description='The response code.', example='200'),
  data?: {
    pageData?: [ 
      {
        activeMessages?: long(name='ActiveMessages', description='The total number of messages that are in the Active state in the queue. The value is an approximate number.', example='20'),
        createTime?: long(name='CreateTime', description='The time when the queue was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1250700999'),
        delayMessages?: long(name='DelayMessages', description='The total number of the messages that are in the Delayed state in the queue. The value is an approximate number.', example='0'),
        delaySeconds?: long(name='DelaySeconds', description='The period after which all messages sent to the queue are consumed. Unit: seconds.', example='30'),
        inactiveMessages?: long(name='InactiveMessages', description='The total number of the messages that are in the Inactive state in the queue. The value is an approximate number.', example='0'),
        lastModifyTime?: long(name='LastModifyTime', description='The time when the queue was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1250700999'),
        loggingEnabled?: boolean(name='LoggingEnabled', description='Indicates whether the logging feature is enabled. Valid values:

*   True
*   False', example='True'),
        maximumMessageSize?: long(name='MaximumMessageSize', description='The maximum length of the message that is sent to the queue. Unit: bytes.', example='65536'),
        messageRetentionPeriod?: long(name='MessageRetentionPeriod', description='The maximum duration for which a message is retained in the queue. After the specified retention period ends, the message is deleted regardless of whether the message is received. Unit: seconds.', example='65536'),
        pollingWaitSeconds?: long(name='PollingWaitSeconds', description='The maximum duration for which long polling requests are held after the ReceiveMessage operation is called. Unit: seconds.', example='0'),
        queueName?: string(name='QueueName', description='The name of the queue.', example='demo-queue'),
        tags?: [ 
          {
            tagKey?: string(name='TagKey'),
            tagValue?: string(name='TagValue'),
          }
        ](name='Tags'),
        visibilityTimeout?: long(name='VisibilityTimeout', description='The duration for which a message stays in the Inactive state after the message is received from the queue. Valid values: 1 to 43200. Unit: seconds. Default value: 30.', example='60'),
      }
    ](name='PageData', description='The data returned on the current page.'),
    pageNum?: long(name='PageNum', description='The page number.', example='1'),
    pageSize?: long(name='PageSize', description='The number of entries per page.', example='50'),
    pages?: long(name='Pages', description='The total number of pages returned.', example='3'),
    size?: long(name='Size', description='The number of entries on the current page.', example='20'),
    total?: long(name='Total', description='The total number of entries.', example='130'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned message.', example='operation success'),
  requestId?: string(name='RequestId', description='The request ID.', example='06273500-249F-5863-121D-74D51123****'),
  status?: string(name='Status', description='The response status.', example='Success'),
  success?: boolean(name='Success', description='Indicates whether the request was successful.', example='true'),
}

model ListQueueResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListQueueResponseBody(name='body'),
}

async function listQueue(request: ListQueueRequest): ListQueueResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListQueue', 'POST', '/', 'json', false, 'json', request);
}

model ListSubscriptionByTopicRequest {
  regionId?: string(name='RegionId', position='Host'),
  pageNum?: long(name='PageNum', description='The page number. Valid values: 1 to 100000000. If you set this parameter to a value smaller than 1, the value of this parameter is 1 by default. If you set this parameter to a value greater than 100000000, the value of this parameter is 100000000 by default.', example='1', position='Query'),
  pageSize?: long(name='PageSize', description='The number of entries per page. Value values: 10 to 50. If you set this parameter to a value smaller than 10, the value of this parameter is 10 by default. If you set this parameter to a value greater than 50, the value of this parameter is 50 by default.', example='20', position='Query'),
  subscriptionName?: string(name='SubscriptionName', description='The name of the subscription.', example='demo-subscription', position='Query'),
  topicName?: string(name='TopicName', description='The name of the topic.', example='test', position='Query'),
}

model ListSubscriptionByTopicResponseBody = {
  code?: long(name='Code', description='The response code.', example='200'),
  data?: {
    pageData?: [ 
      {
        createTime?: long(name='CreateTime', description='The time when the subscription was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1449554806'),
        endpoint?: string(name='Endpoint', description='The endpoint to which the messages are pushed.', example='http://example.com'),
        filterTag?: string(name='FilterTag', description='The tag that is used to filter messages. Only the messages that are attached with the specified tag can be pushed.', example='important'),
        lastModifyTime?: long(name='LastModifyTime', description='The time when the subscription was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1449554806'),
        notifyContentFormat?: string(name='NotifyContentFormat', description='The content format of the messages that are pushed to the endpoint. Valid values:

*   XML
*   JSON
*   SIMPLIFIED', example='XML'),
        notifyStrategy?: string(name='NotifyStrategy', description='The retry policy that is applied if an error occurs when Message Service (MNS) pushes messages to the endpoint. Valid values:

*   BACKOFF_RETRY
*   EXPONENTIAL_DECAY_RETRY', example='BACKOFF_RETRY'),
        subscriptionName?: string(name='SubscriptionName', description='The name of the subscription.', example='MySubscription'),
        topicName?: string(name='TopicName', description='The name of the topic.', example='MyTopic'),
        topicOwner?: string(name='TopicOwner', description='The Alibaba Cloud account ID of the topic owner.', example='123456789098****'),
      }
    ](name='PageData', description='The data returned on the current page.'),
    pageNum?: long(name='PageNum', description='The page number.', example='1'),
    pageSize?: long(name='PageSize', description='The number of entries per page.', example='50'),
    pages?: long(name='Pages', description='The total number of pages returned.', example='3'),
    size?: long(name='Size', description='The number of entries on the current page.', example='20'),
    total?: long(name='Total', description='The total number of entries returned.', example='130'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned message.', example='operation success'),
  requestId?: string(name='RequestId', description='The request ID.', example='06273500-249F-5863-121D-74D51123****'),
  status?: string(name='Status', description='The response status.', example='Success'),
  success?: boolean(name='Success', description='Indicates whether the request was successful.', example='true'),
}

model ListSubscriptionByTopicResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListSubscriptionByTopicResponseBody(name='body'),
}

async function listSubscriptionByTopic(request: ListSubscriptionByTopicRequest): ListSubscriptionByTopicResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListSubscriptionByTopic', 'POST', '/', 'json', false, 'json', request);
}

model ListTopicRequest {
  regionId?: string(name='RegionId', position='Host'),
  pageNum?: long(name='PageNum', description='The page number. Valid values: 1 to 100000000. If you set this parameter to a value smaller than 1, the value of this parameter is 1 by default. If you set this parameter to a value greater than 100000000, the value of this parameter is 100000000 by default.', example='1', position='Query'),
  pageSize?: long(name='PageSize', description='The number of entries per page. Value values: 10 to 50. If you set this parameter to a value smaller than 10, the value of this parameter is 10 by default. If you set this parameter to a value greater than 50, the value of this parameter is 50 by default.', example='20', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
  topicName?: string(name='TopicName', description='The name of the topic.', example='test', position='Query'),
}

model ListTopicResponseBody = {
  code?: long(name='Code', description='The response code.', example='200'),
  data?: {
    pageData?: [ 
      {
        createTime?: long(name='CreateTime', description='The time when the subscription was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1449554962'),
        lastModifyTime?: long(name='LastModifyTime', description='The time when the subscription was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1449554962'),
        loggingEnabled?: boolean(name='LoggingEnabled', description='Indicates whether the logging feature is enabled.

*   True
*   False', example='True'),
        maxMessageSize?: long(name='MaxMessageSize', description='The maximum length of the message that is sent to the topic. Unit: bytes.', example='65536'),
        messageCount?: long(name='MessageCount', description='The number of messages in the topic.', example='0'),
        messageRetentionPeriod?: long(name='MessageRetentionPeriod', description='The maximum duration for which a message is retained in the topic. After the specified retention period ends, the message is deleted regardless of whether the message is received. Unit: seconds.', example='86400'),
        tags?: [ 
          {
            tagKey?: string(name='TagKey'),
            tagValue?: string(name='TagValue'),
          }
        ](name='Tags'),
        topicInnerUrl?: string(name='TopicInnerUrl'),
        topicName?: string(name='TopicName', description='The name of the topic.', example='demo-topic'),
        topicUrl?: string(name='TopicUrl'),
      }
    ](name='PageData', description='The data returned on the current page.'),
    pageNum?: long(name='PageNum', description='The page number.', example='1'),
    pageSize?: long(name='PageSize', description='The number of entries per page.', example='50'),
    total?: long(name='Total', description='The total number of entries returned.', example='130'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned message.', example='operation success'),
  requestId?: string(name='RequestId', description='The request ID.', example='06273500-249F-5863-121D-74D51123****'),
  status?: string(name='Status', description='The response status.', example='Success'),
  success?: boolean(name='Success', description='Indicates whether the request was successful.', example='true'),
}

model ListTopicResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTopicResponseBody(name='body'),
}

async function listTopic(request: ListTopicRequest): ListTopicResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTopic', 'POST', '/', 'json', false, 'json', request);
}

model SetQueueAttributesRequest {
  regionId?: string(name='RegionId', position='Host'),
  delaySeconds?: long(name='DelaySeconds', description='The period after which all messages sent to the queue are consumed. Valid values: 0 to 604800. Unit: seconds. Default value: 0', example='0', position='Query'),
  enableLogging?: boolean(name='EnableLogging', description='Specifies whether to enable the logging feature. Valid values:

*   True
*   False (default)', example='True', position='Query'),
  maximumMessageSize?: long(name='MaximumMessageSize', description='The maximum length of the message that is sent to the queue. Valid values: 1024 to 65536. Unit: bytes. Default value: 65536.', example='1024', position='Query'),
  messageRetentionPeriod?: long(name='MessageRetentionPeriod', description='The maximum duration for which a message is retained in the queue. After the specified retention period ends, the message is deleted regardless of whether the message is received. Valid values: 60 to 604800. Unit: seconds. Default value: 345600.', example='120', position='Query'),
  pollingWaitSeconds?: long(name='PollingWaitSeconds', description='The maximum duration for which long polling requests are held after the ReceiveMessage operation is called. Valid values: 0 to 30. Unit: seconds. Default value: 0', example='0', position='Query'),
  queueName: string(name='QueueName', description='The name of the queue.', example='testqueue', position='Query'),
  visibilityTimeout?: long(name='VisibilityTimeout', description='The duration for which a message stays in the Inactive state after the message is received from the queue. Valid values: 1 to 43200. Unit: seconds. Default value: 30.', example='60', position='Query'),
}

model SetQueueAttributesResponseBody = {
  code?: long(name='Code', description='The response code.', example='200'),
  data?: {
    code?: long(name='Code', description='The response code.', example='200'),
    message?: string(name='Message', description='The returned message.'),
    success?: boolean(name='Success', description='Indicates whether the request was successful.', example='true'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned message.', example='operation success'),
  requestId?: string(name='RequestId', description='The request ID.', example='06273500-249F-5863-121D-74D51123****'),
  status?: string(name='Status', description='The response status.', example='Success'),
  success?: boolean(name='Success', description='Indicates whether the request was successful.', example='true'),
}

model SetQueueAttributesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetQueueAttributesResponseBody(name='body'),
}

async function setQueueAttributes(request: SetQueueAttributesRequest): SetQueueAttributesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetQueueAttributes', 'POST', '/', 'json', false, 'json', request);
}

model SetSubscriptionAttributesRequest {
  regionId?: string(name='RegionId', position='Host'),
  notifyStrategy?: string(name='NotifyStrategy', description='The retry policy that is applied if an error occurs when Message Service (MNS) pushes messages to the endpoint. Valid values:

*   BACKOFF_RETRY
*   EXPONENTIAL_DECAY_RETRY', example='BACKOFF_RETRY', position='Query'),
  subscriptionName: string(name='SubscriptionName', description='The name of the subscription.', example='MySubscription', position='Query'),
  topicName: string(name='TopicName', description='The name of the topic.', example='test', position='Query'),
}

model SetSubscriptionAttributesResponseBody = {
  code?: long(name='Code', description='The response code.', example='200'),
  data?: {
    code?: long(name='Code', description='The response code.', example='200'),
    message?: string(name='Message', description='The returned message.'),
    success?: boolean(name='Success', description='Indicates whether the request was successful.', example='true'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned message.', example='operation success'),
  requestId?: string(name='RequestId', description='The request ID.', example='06273500-249F-5863-121D-74D51123****'),
  status?: string(name='Status', description='The response status.', example='Success'),
  success?: boolean(name='Success', description='Indicates whether the request was successful.', example='true'),
}

model SetSubscriptionAttributesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetSubscriptionAttributesResponseBody(name='body'),
}

async function setSubscriptionAttributes(request: SetSubscriptionAttributesRequest): SetSubscriptionAttributesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetSubscriptionAttributes', 'POST', '/', 'json', false, 'json', request);
}

model SetTopicAttributesRequest {
  regionId?: string(name='RegionId', position='Host'),
  enableLogging?: boolean(name='EnableLogging', description='Specifies whether to enable the logging feature. Valid values:

*   True
*   False (default)', example='True', position='Query'),
  maxMessageSize?: long(name='MaxMessageSize', description='The maximum length of the message that is sent to the topic. Valid values: 1024 to 65536. Unit: bytes. Default value: 65536.', example='65536', position='Query'),
  topicName: string(name='TopicName', description='The name of the topic.', example='test', position='Query'),
}

model SetTopicAttributesResponseBody = {
  code?: long(name='Code', description='The response code.', example='200'),
  data?: {
    code?: long(name='Code', description='The response code.', example='200'),
    message?: string(name='Message', description='The returned message.'),
    success?: boolean(name='Success', description='Indicates whether the request was successful.', example='true'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned message.', example='operation success'),
  requestId?: string(name='RequestId', description='The request ID.', example='06273500-249F-5863-121D-74D51123****'),
  status?: string(name='Status', description='The response status.', example='Success'),
  success?: boolean(name='Success', description='Indicates whether the request was successful.', example='true'),
}

model SetTopicAttributesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetTopicAttributesResponseBody(name='body'),
}

async function setTopicAttributes(request: SetTopicAttributesRequest): SetTopicAttributesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetTopicAttributes', 'POST', '/', 'json', false, 'json', request);
}

model SubscribeRequest {
  regionId?: string(name='RegionId', position='Host'),
  endpoint: string(name='Endpoint', description='The receiver endpoint. The format of the endpoint varies based on the terminal type.

*   If you set PushType to http, set Endpoint to an `HTTP URL that starts with http:// or https://`.
*   If you set PushType to queue, set Endpoint to a `queue name`.
*   If you set PushType to mpush, set Endpoint to an `AppKey`.
*   If you set PushType to alisms, set Endpoint to a `mobile number`.
*   If you set PushType to email, set Endpoint to an `email address`.', example='http://example.com', position='Query'),
  messageTag?: string(name='MessageTag', description='The tag that is used to filter messages. Only messages that have the same tag can be pushed. Set the value to a string of no more than 16 characters.

By default, no tag is specified to filter messages.', example='important', position='Query'),
  notifyContentFormat?: string(name='NotifyContentFormat', description='The content format of the messages that are pushed to the endpoint. Valid values:

*   XML
*   JSON
*   SIMPLIFIED', example='XML', position='Query'),
  notifyStrategy?: string(name='NotifyStrategy', description='The retry policy that is applied if an error occurs when Message Service (MNS) pushes messages to the endpoint. Valid values:

*   BACKOFF_RETRY
*   EXPONENTIAL_DECAY_RETRY', example='BACKOFF_RETRY', position='Query'),
  pushType: string(name='PushType', description='The terminal type. Valid values:

*   http: HTTP services
*   queue: queues
*   mpush: mobile devices
*   alisms: Alibaba Cloud Short Message Service (SMS)
*   email: emails', example='queue', position='Query'),
  subscriptionName: string(name='SubscriptionName', description='The name of the subscription.', example='testSubscription', position='Query'),
  topicName: string(name='TopicName', description='The name of the topic.', example='test', position='Query'),
}

model SubscribeResponseBody = {
  code?: long(name='Code', description='The response code.', example='200'),
  data?: string(name='Data', description='The returned data.', example='{\\"Code\\": 200, \\"Success\\": True}'),
  message?: string(name='Message', description='The returned message.', example='operation success'),
  requestId?: string(name='RequestId', description='The request ID.', example='06273500-249F-5863-121D-74D51123****'),
  status?: string(name='Status', description='The response status.', example='Success'),
  success?: boolean(name='Success', description='Indicates whether the request was successful.', example='true'),
}

model SubscribeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SubscribeResponseBody(name='body'),
}

async function subscribe(request: SubscribeRequest): SubscribeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'Subscribe', 'POST', '/', 'json', false, 'json', request);
}

model UnsubscribeRequest {
  regionId?: string(name='RegionId', position='Host'),
  subscriptionName: string(name='SubscriptionName', description='The name of the subscription.', example='MySubscription', position='Query'),
  topicName: string(name='TopicName', description='The name of the topic.', example='test', position='Query'),
}

model UnsubscribeResponseBody = {
  code?: long(name='Code', description='The response code.', example='200'),
  data?: {
    code?: long(name='Code', description='The response code.', example='200'),
    message?: string(name='Message', description='The returned message.'),
    success?: boolean(name='Success', description='Indicates whether the request was successful.', example='true'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned message.', example='operation success'),
  requestId?: string(name='RequestId', description='The request ID.', example='06273500-249F-5863-121D-74D51123****'),
  status?: string(name='Status', description='The response status.', example='Success'),
  success?: boolean(name='Success', description='Indicates whether the request was successful.', example='true'),
}

model UnsubscribeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UnsubscribeResponseBody(name='body'),
}

async function unsubscribe(request: UnsubscribeRequest): UnsubscribeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'Unsubscribe', 'POST', '/', 'json', false, 'json', request);
}

