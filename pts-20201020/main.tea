/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'central';
  
  checkConfig(config);
  @endpoint = getEndpoint('pts', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AdjustJMeterSceneSpeedRequest {
  reportId?: string(name='ReportId'),
  speed?: int32(name='Speed'),
}

model AdjustJMeterSceneSpeedResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  reportId?: string(name='ReportId'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AdjustJMeterSceneSpeedResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AdjustJMeterSceneSpeedResponseBody(name='body'),
}

async function adjustJMeterSceneSpeedWithOptions(request: AdjustJMeterSceneSpeedRequest, runtime: Util.RuntimeOptions): AdjustJMeterSceneSpeedResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.reportId)) {
    query['ReportId'] = request.reportId;
  }
  if (!Util.isUnset(request.speed)) {
    query['Speed'] = request.speed;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AdjustJMeterSceneSpeed',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function adjustJMeterSceneSpeed(request: AdjustJMeterSceneSpeedRequest): AdjustJMeterSceneSpeedResponse {
  var runtime = new Util.RuntimeOptions{};
  return adjustJMeterSceneSpeedWithOptions(request, runtime);
}

model CreatePtsSceneRequest {
  scene?: string(name='Scene'),
}

model CreatePtsSceneResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  sceneId?: string(name='SceneId'),
  success?: boolean(name='Success'),
}

model CreatePtsSceneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreatePtsSceneResponseBody(name='body'),
}

async function createPtsSceneWithOptions(request: CreatePtsSceneRequest, runtime: Util.RuntimeOptions): CreatePtsSceneResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.scene)) {
    query['Scene'] = request.scene;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreatePtsScene',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createPtsScene(request: CreatePtsSceneRequest): CreatePtsSceneResponse {
  var runtime = new Util.RuntimeOptions{};
  return createPtsSceneWithOptions(request, runtime);
}

model CreatePtsSceneBaseLineFromReportRequest {
  reportId?: string(name='ReportId'),
  sceneId?: string(name='SceneId'),
}

model CreatePtsSceneBaseLineFromReportResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreatePtsSceneBaseLineFromReportResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreatePtsSceneBaseLineFromReportResponseBody(name='body'),
}

async function createPtsSceneBaseLineFromReportWithOptions(request: CreatePtsSceneBaseLineFromReportRequest, runtime: Util.RuntimeOptions): CreatePtsSceneBaseLineFromReportResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.reportId)) {
    query['ReportId'] = request.reportId;
  }
  if (!Util.isUnset(request.sceneId)) {
    query['SceneId'] = request.sceneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreatePtsSceneBaseLineFromReport',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createPtsSceneBaseLineFromReport(request: CreatePtsSceneBaseLineFromReportRequest): CreatePtsSceneBaseLineFromReportResponse {
  var runtime = new Util.RuntimeOptions{};
  return createPtsSceneBaseLineFromReportWithOptions(request, runtime);
}

model DeletePtsSceneRequest {
  sceneId?: string(name='SceneId'),
}

model DeletePtsSceneResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeletePtsSceneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeletePtsSceneResponseBody(name='body'),
}

async function deletePtsSceneWithOptions(request: DeletePtsSceneRequest, runtime: Util.RuntimeOptions): DeletePtsSceneResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sceneId)) {
    query['SceneId'] = request.sceneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeletePtsScene',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deletePtsScene(request: DeletePtsSceneRequest): DeletePtsSceneResponse {
  var runtime = new Util.RuntimeOptions{};
  return deletePtsSceneWithOptions(request, runtime);
}

model DeletePtsSceneBaseLineRequest {
  sceneId?: string(name='SceneId'),
}

model DeletePtsSceneBaseLineResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeletePtsSceneBaseLineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeletePtsSceneBaseLineResponseBody(name='body'),
}

async function deletePtsSceneBaseLineWithOptions(request: DeletePtsSceneBaseLineRequest, runtime: Util.RuntimeOptions): DeletePtsSceneBaseLineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sceneId)) {
    query['SceneId'] = request.sceneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeletePtsSceneBaseLine',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deletePtsSceneBaseLine(request: DeletePtsSceneBaseLineRequest): DeletePtsSceneBaseLineResponse {
  var runtime = new Util.RuntimeOptions{};
  return deletePtsSceneBaseLineWithOptions(request, runtime);
}

model DeletePtsScenesRequest {
  sceneIds?: [ string ](name='SceneIds'),
}

model DeletePtsScenesShrinkRequest {
  sceneIdsShrink?: string(name='SceneIds'),
}

model DeletePtsScenesResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeletePtsScenesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeletePtsScenesResponseBody(name='body'),
}

async function deletePtsScenesWithOptions(tmpReq: DeletePtsScenesRequest, runtime: Util.RuntimeOptions): DeletePtsScenesResponse {
  Util.validateModel(tmpReq);
  var request = new DeletePtsScenesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.sceneIds)) {
    request.sceneIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sceneIds, 'SceneIds', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.sceneIdsShrink)) {
    query['SceneIds'] = request.sceneIdsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeletePtsScenes',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deletePtsScenes(request: DeletePtsScenesRequest): DeletePtsScenesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deletePtsScenesWithOptions(request, runtime);
}

model GetAllRegionsResponseBody = {
  allRegions?: map[string]string(name='AllRegions'),
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetAllRegionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAllRegionsResponseBody(name='body'),
}

async function getAllRegionsWithOptions(runtime: Util.RuntimeOptions): GetAllRegionsResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetAllRegions',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAllRegions(): GetAllRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAllRegionsWithOptions(runtime);
}

model GetJMeterLogsRequest {
  agentIndex?: int32(name='AgentIndex'),
  beginTime?: long(name='BeginTime'),
  endTime?: long(name='EndTime'),
  keyword?: string(name='Keyword'),
  level?: string(name='Level'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  reportId?: string(name='ReportId'),
  thread?: string(name='Thread'),
}

model GetJMeterLogsResponseBody = {
  agentCount?: int32(name='AgentCount'),
  code?: string(name='Code'),
  logs?: [  map[string]any ](name='Logs'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model GetJMeterLogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetJMeterLogsResponseBody(name='body'),
}

async function getJMeterLogsWithOptions(request: GetJMeterLogsRequest, runtime: Util.RuntimeOptions): GetJMeterLogsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.agentIndex)) {
    query['AgentIndex'] = request.agentIndex;
  }
  if (!Util.isUnset(request.beginTime)) {
    query['BeginTime'] = request.beginTime;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.level)) {
    query['Level'] = request.level;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.reportId)) {
    query['ReportId'] = request.reportId;
  }
  if (!Util.isUnset(request.thread)) {
    query['Thread'] = request.thread;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetJMeterLogs',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getJMeterLogs(request: GetJMeterLogsRequest): GetJMeterLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getJMeterLogsWithOptions(request, runtime);
}

model GetJMeterSampleMetricsRequest {
  beginTime?: long(name='BeginTime'),
  endTime?: long(name='EndTime'),
  reportId?: string(name='ReportId'),
  samplerId?: int32(name='SamplerId'),
}

model GetJMeterSampleMetricsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  sampleMetricList?: [ string ](name='SampleMetricList'),
  samplerMap?: map[string]any(name='SamplerMap'),
  success?: boolean(name='Success'),
}

model GetJMeterSampleMetricsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetJMeterSampleMetricsResponseBody(name='body'),
}

async function getJMeterSampleMetricsWithOptions(request: GetJMeterSampleMetricsRequest, runtime: Util.RuntimeOptions): GetJMeterSampleMetricsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.beginTime)) {
    query['BeginTime'] = request.beginTime;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.reportId)) {
    query['ReportId'] = request.reportId;
  }
  if (!Util.isUnset(request.samplerId)) {
    query['SamplerId'] = request.samplerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetJMeterSampleMetrics',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getJMeterSampleMetrics(request: GetJMeterSampleMetricsRequest): GetJMeterSampleMetricsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getJMeterSampleMetricsWithOptions(request, runtime);
}

model GetJMeterSamplingLogsRequest {
  agentId?: long(name='AgentId'),
  beginTime?: long(name='BeginTime'),
  endTime?: long(name='EndTime'),
  keyword?: string(name='Keyword'),
  maxRT?: int32(name='MaxRT'),
  minRT?: int32(name='MinRT'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  reportId?: string(name='ReportId'),
  responseCode?: string(name='ResponseCode'),
  samplerId?: int32(name='SamplerId'),
  success?: boolean(name='Success'),
  thread?: string(name='Thread'),
}

model GetJMeterSamplingLogsResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  sampleResults?: [ string ](name='SampleResults'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model GetJMeterSamplingLogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetJMeterSamplingLogsResponseBody(name='body'),
}

async function getJMeterSamplingLogsWithOptions(request: GetJMeterSamplingLogsRequest, runtime: Util.RuntimeOptions): GetJMeterSamplingLogsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.agentId)) {
    query['AgentId'] = request.agentId;
  }
  if (!Util.isUnset(request.beginTime)) {
    query['BeginTime'] = request.beginTime;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.maxRT)) {
    query['MaxRT'] = request.maxRT;
  }
  if (!Util.isUnset(request.minRT)) {
    query['MinRT'] = request.minRT;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.reportId)) {
    query['ReportId'] = request.reportId;
  }
  if (!Util.isUnset(request.responseCode)) {
    query['ResponseCode'] = request.responseCode;
  }
  if (!Util.isUnset(request.samplerId)) {
    query['SamplerId'] = request.samplerId;
  }
  if (!Util.isUnset(request.success)) {
    query['Success'] = request.success;
  }
  if (!Util.isUnset(request.thread)) {
    query['Thread'] = request.thread;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetJMeterSamplingLogs',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getJMeterSamplingLogs(request: GetJMeterSamplingLogsRequest): GetJMeterSamplingLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getJMeterSamplingLogsWithOptions(request, runtime);
}

model GetJMeterSceneRunningDataRequest {
  sceneId?: string(name='SceneId'),
}

model GetJMeterSceneRunningDataResponseBody = {
  code?: string(name='Code'),
  documentUrl?: string(name='DocumentUrl'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  runningData?: {
    agentCount?: int32(name='AgentCount'),
    agentIdList?: [ string ](name='AgentIdList'),
    allSampleStat?: map[string]any(name='AllSampleStat'),
    concurrency?: int32(name='Concurrency'),
    hasReport?: boolean(name='HasReport'),
    holdFor?: int32(name='HoldFor'),
    isDebugging?: boolean(name='IsDebugging'),
    sampleStatList?: [  map[string]any ](name='SampleStatList'),
    sceneId?: string(name='SceneId'),
    sceneName?: string(name='SceneName'),
    stageName?: string(name='StageName'),
    startTimeTS?: long(name='StartTimeTS'),
    status?: string(name='Status'),
    vum?: long(name='Vum'),
  }(name='RunningData'),
  success?: boolean(name='Success'),
}

model GetJMeterSceneRunningDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetJMeterSceneRunningDataResponseBody(name='body'),
}

async function getJMeterSceneRunningDataWithOptions(request: GetJMeterSceneRunningDataRequest, runtime: Util.RuntimeOptions): GetJMeterSceneRunningDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sceneId)) {
    query['SceneId'] = request.sceneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetJMeterSceneRunningData',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getJMeterSceneRunningData(request: GetJMeterSceneRunningDataRequest): GetJMeterSceneRunningDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return getJMeterSceneRunningDataWithOptions(request, runtime);
}

model GetOpenJMeterSceneRequest {
  sceneId?: string(name='SceneId'),
}

model GetOpenJMeterSceneResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  scene?: {
    agentCount?: int32(name='AgentCount'),
    baseInfo?: {
      createName?: string(name='CreateName'),
      modifyName?: string(name='ModifyName'),
      operateType?: string(name='OperateType'),
      principal?: string(name='Principal'),
      remark?: string(name='Remark'),
      resource?: string(name='Resource'),
    }(name='BaseInfo'),
    concurrency?: int32(name='Concurrency'),
    constantThroughputTimerType?: string(name='ConstantThroughputTimerType'),
    dnsCacheConfig?: {
      clearCacheEachIteration?: boolean(name='ClearCacheEachIteration'),
      dnsServers?: [ string ](name='DnsServers'),
      hostTable?: map[string]any(name='HostTable'),
    }(name='DnsCacheConfig'),
    duration?: int32(name='Duration'),
    environmentId?: string(name='EnvironmentId'),
    fileList?: [ 
      {
        fileName?: string(name='FileName'),
        fileOssAddress?: string(name='FileOssAddress'),
        fileSize?: long(name='FileSize'),
        fileType?: string(name='FileType'),
        id?: long(name='Id'),
        md5?: string(name='Md5'),
        splitCsv?: boolean(name='SplitCsv'),
      }
    ](name='FileList'),
    isVpcTest?: boolean(name='IsVpcTest'),
    maxRps?: int32(name='MaxRps'),
    mode?: string(name='Mode'),
    pool?: string(name='Pool'),
    rampUp?: int32(name='RampUp'),
    regionId?: string(name='RegionId'),
    sceneId?: string(name='SceneId'),
    sceneName?: string(name='SceneName'),
    securityGroupId?: string(name='SecurityGroupId'),
    startConcurrency?: int32(name='StartConcurrency'),
    startRps?: int32(name='StartRps'),
    steps?: int32(name='Steps'),
    syncTimerType?: string(name='SyncTimerType'),
    testFile?: string(name='TestFile'),
    vSwitchId?: string(name='VSwitchId'),
    vpcId?: string(name='VpcId'),
  }(name='Scene'),
  success?: boolean(name='Success'),
}

model GetOpenJMeterSceneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetOpenJMeterSceneResponseBody(name='body'),
}

async function getOpenJMeterSceneWithOptions(request: GetOpenJMeterSceneRequest, runtime: Util.RuntimeOptions): GetOpenJMeterSceneResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sceneId)) {
    query['SceneId'] = request.sceneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetOpenJMeterScene',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getOpenJMeterScene(request: GetOpenJMeterSceneRequest): GetOpenJMeterSceneResponse {
  var runtime = new Util.RuntimeOptions{};
  return getOpenJMeterSceneWithOptions(request, runtime);
}

model GetPtsReportDetailsRequest {
  planId?: string(name='PlanId'),
  sceneId?: string(name='SceneId'),
}

model GetPtsReportDetailsResponseBody = {
  apiMetricsList?: [ 
    {
      allCount?: long(name='AllCount'),
      apiName?: string(name='ApiName'),
      avgRt?: float(name='AvgRt'),
      avgTps?: float(name='AvgTps'),
      failCountBiz?: long(name='FailCountBiz'),
      failCountReq?: long(name='FailCountReq'),
      maxRt?: float(name='MaxRt'),
      minRt?: float(name='MinRt'),
      seg50Rt?: float(name='Seg50Rt'),
      seg75Rt?: float(name='Seg75Rt'),
      seg90Rt?: float(name='Seg90Rt'),
      seg99Rt?: float(name='Seg99Rt'),
      successRateBiz?: float(name='SuccessRateBiz'),
      successRateReq?: float(name='SuccessRateReq'),
    }
  ](name='ApiMetricsList'),
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  reportOverView?: {
    agentCount?: int32(name='AgentCount'),
    endTime?: string(name='EndTime'),
    reportId?: string(name='ReportId'),
    reportName?: string(name='ReportName'),
    startTime?: string(name='StartTime'),
    vum?: long(name='Vum'),
  }(name='ReportOverView'),
  requestId?: string(name='RequestId'),
  sceneMetrics?: {
    allCount?: long(name='AllCount'),
    avgRt?: float(name='AvgRt'),
    avgTps?: float(name='AvgTps'),
    failCountBiz?: long(name='FailCountBiz'),
    failCountReq?: long(name='FailCountReq'),
    seg90Rt?: float(name='Seg90Rt'),
    seg99Rt?: float(name='Seg99Rt'),
    successRateBiz?: float(name='SuccessRateBiz'),
    successRateReq?: float(name='SuccessRateReq'),
  }(name='SceneMetrics'),
  sceneSnapShot?: {
    advanceSetting?: {
      connectionTimeoutInSecond?: int32(name='ConnectionTimeoutInSecond'),
      domainBindingList?: [ 
        {
          domain?: string(name='Domain'),
          ips?: [ string ](name='Ips'),
        }
      ](name='DomainBindingList'),
      logRate?: int32(name='LogRate'),
      successCode?: string(name='SuccessCode'),
    }(name='AdvanceSetting'),
    createTime?: string(name='CreateTime'),
    fileParameterList?: [ 
      {
        fileName?: string(name='FileName'),
        fileOssAddress?: string(name='FileOssAddress'),
      }
    ](name='FileParameterList'),
    globalParameterList?: [ 
      {
        paramName?: string(name='ParamName'),
        paramValue?: string(name='ParamValue'),
      }
    ](name='GlobalParameterList'),
    loadConfig?: {
      agentCount?: int32(name='AgentCount'),
      apiLoadConfigList?: [ 
        {
          rpsBegin?: int32(name='RpsBegin'),
          rpsLimit?: int32(name='RpsLimit'),
        }
      ](name='ApiLoadConfigList'),
      configuration?: {
        allConcurrencyBegin?: int32(name='AllConcurrencyBegin'),
        allConcurrencyLimit?: int32(name='AllConcurrencyLimit'),
        allRpsBegin?: int32(name='AllRpsBegin'),
        allRpsLimit?: int32(name='AllRpsLimit'),
      }(name='Configuration'),
      maxRunningTime?: int32(name='MaxRunningTime'),
      relationLoadConfigList?: [ 
        {
          concurrencyBegin?: int32(name='ConcurrencyBegin'),
          concurrencyLimit?: int32(name='ConcurrencyLimit'),
        }
      ](name='RelationLoadConfigList'),
      testMode?: string(name='TestMode'),
    }(name='LoadConfig'),
    modifiedTime?: string(name='ModifiedTime'),
    relationList?: [ 
      {
        apiList?: [ 
          {
            apiId?: string(name='ApiId'),
            apiName?: string(name='ApiName'),
            body?: {
              bodyValue?: string(name='BodyValue'),
              contentType?: string(name='ContentType'),
            }(name='Body'),
            checkPointList?: [ 
              {
                checkPoint?: string(name='CheckPoint'),
                checkType?: string(name='CheckType'),
                expectValue?: string(name='ExpectValue'),
                operator?: string(name='Operator'),
              }
            ](name='CheckPointList'),
            exportList?: [ 
              {
                count?: string(name='Count'),
                exportName?: string(name='ExportName'),
                exportType?: string(name='ExportType'),
                exportValue?: string(name='ExportValue'),
              }
            ](name='ExportList'),
            headerList?: [ 
              {
                headerName?: string(name='HeaderName'),
                headerValue?: string(name='HeaderValue'),
              }
            ](name='HeaderList'),
            method?: string(name='Method'),
            redirectCountLimit?: int32(name='RedirectCountLimit'),
            timeoutInSecond?: int32(name='TimeoutInSecond'),
            url?: string(name='Url'),
          }
        ](name='ApiList'),
        fileParameterExplainList?: [ 
          {
            baseFile?: boolean(name='BaseFile'),
            cycleOnce?: boolean(name='CycleOnce'),
            fileName?: string(name='FileName'),
            fileParamName?: string(name='FileParamName'),
          }
        ](name='FileParameterExplainList'),
        relationId?: string(name='RelationId'),
        relationName?: string(name='RelationName'),
      }
    ](name='RelationList'),
    sceneId?: string(name='SceneId'),
    sceneName?: string(name='SceneName'),
    status?: string(name='Status'),
  }(name='SceneSnapShot'),
  success?: boolean(name='Success'),
}

model GetPtsReportDetailsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPtsReportDetailsResponseBody(name='body'),
}

async function getPtsReportDetailsWithOptions(request: GetPtsReportDetailsRequest, runtime: Util.RuntimeOptions): GetPtsReportDetailsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.planId)) {
    query['PlanId'] = request.planId;
  }
  if (!Util.isUnset(request.sceneId)) {
    query['SceneId'] = request.sceneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetPtsReportDetails',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPtsReportDetails(request: GetPtsReportDetailsRequest): GetPtsReportDetailsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPtsReportDetailsWithOptions(request, runtime);
}

model GetPtsReportsBySceneIdRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  sceneId?: string(name='SceneId'),
}

model GetPtsReportsBySceneIdResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  reportOverViewList?: [ 
    {
      agentCount?: int32(name='AgentCount'),
      endTime?: string(name='EndTime'),
      reportId?: string(name='ReportId'),
      reportName?: string(name='ReportName'),
      startTime?: string(name='StartTime'),
      vum?: long(name='Vum'),
    }
  ](name='ReportOverViewList'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetPtsReportsBySceneIdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPtsReportsBySceneIdResponseBody(name='body'),
}

async function getPtsReportsBySceneIdWithOptions(request: GetPtsReportsBySceneIdRequest, runtime: Util.RuntimeOptions): GetPtsReportsBySceneIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sceneId)) {
    query['SceneId'] = request.sceneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetPtsReportsBySceneId',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPtsReportsBySceneId(request: GetPtsReportsBySceneIdRequest): GetPtsReportsBySceneIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPtsReportsBySceneIdWithOptions(request, runtime);
}

model GetPtsSceneRequest {
  sceneId?: string(name='SceneId'),
}

model GetPtsSceneResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  scene?: {
    advanceSetting?: {
      connectionTimeoutInSecond?: int32(name='ConnectionTimeoutInSecond'),
      domainBindingList?: [ 
        {
          domain?: string(name='Domain'),
          ips?: [ string ](name='Ips'),
        }
      ](name='DomainBindingList'),
      logRate?: int32(name='LogRate'),
      successCode?: string(name='SuccessCode'),
    }(name='AdvanceSetting'),
    createTime?: string(name='CreateTime'),
    fileParameterList?: [ 
      {
        fileName?: string(name='FileName'),
        fileOssAddress?: string(name='FileOssAddress'),
      }
    ](name='FileParameterList'),
    globalParameterList?: [ 
      {
        paramName?: string(name='ParamName'),
        paramValue?: string(name='ParamValue'),
      }
    ](name='GlobalParameterList'),
    loadConfig?: {
      agentCount?: int32(name='AgentCount'),
      apiLoadConfigList?: [ 
        {
          apiId?: string(name='ApiId'),
          rpsBegin?: int32(name='RpsBegin'),
          rpsLimit?: int32(name='RpsLimit'),
        }
      ](name='ApiLoadConfigList'),
      autoStep?: boolean(name='AutoStep'),
      configuration?: {
        allConcurrencyBegin?: int32(name='AllConcurrencyBegin'),
        allConcurrencyLimit?: int32(name='AllConcurrencyLimit'),
        allRpsBegin?: int32(name='AllRpsBegin'),
        allRpsLimit?: int32(name='AllRpsLimit'),
      }(name='Configuration'),
      increment?: int32(name='Increment'),
      keepTime?: int32(name='KeepTime'),
      maxRunningTime?: int32(name='MaxRunningTime'),
      relationLoadConfigList?: [ 
        {
          concurrencyBegin?: int32(name='ConcurrencyBegin'),
          concurrencyLimit?: int32(name='ConcurrencyLimit'),
          relationId?: string(name='RelationId'),
        }
      ](name='RelationLoadConfigList'),
      testMode?: string(name='TestMode'),
      vpcLoadConfig?: {
        regionId?: string(name='RegionId'),
        securityGroupId?: string(name='SecurityGroupId'),
        vSwitchId?: string(name='VSwitchId'),
        vpcId?: string(name='VpcId'),
      }(name='VpcLoadConfig'),
    }(name='LoadConfig'),
    modifiedTime?: string(name='ModifiedTime'),
    relationList?: [ 
      {
        apiList?: [ 
          {
            apiId?: string(name='ApiId'),
            apiName?: string(name='ApiName'),
            body?: {
              bodyValue?: string(name='BodyValue'),
              contentType?: string(name='ContentType'),
            }(name='Body'),
            checkPointList?: [ 
              {
                checkPoint?: string(name='CheckPoint'),
                checkType?: string(name='CheckType'),
                expectValue?: string(name='ExpectValue'),
                operator?: string(name='Operator'),
              }
            ](name='CheckPointList'),
            exportList?: [ 
              {
                count?: string(name='Count'),
                exportName?: string(name='ExportName'),
                exportType?: string(name='ExportType'),
                exportValue?: string(name='ExportValue'),
              }
            ](name='ExportList'),
            headerList?: [ 
              {
                headerName?: string(name='HeaderName'),
                headerValue?: string(name='HeaderValue'),
              }
            ](name='HeaderList'),
            method?: string(name='Method'),
            redirectCountLimit?: int32(name='RedirectCountLimit'),
            timeoutInSecond?: int32(name='TimeoutInSecond'),
            url?: string(name='Url'),
          }
        ](name='ApiList'),
        fileParameterExplainList?: [ 
          {
            baseFile?: boolean(name='BaseFile'),
            cycleOnce?: boolean(name='CycleOnce'),
            fileName?: string(name='FileName'),
            fileParamName?: string(name='FileParamName'),
          }
        ](name='FileParameterExplainList'),
        relationId?: string(name='RelationId'),
        relationName?: string(name='RelationName'),
      }
    ](name='RelationList'),
    sceneId?: string(name='SceneId'),
    sceneName?: string(name='SceneName'),
    status?: string(name='Status'),
  }(name='Scene'),
  success?: boolean(name='Success'),
}

model GetPtsSceneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPtsSceneResponseBody(name='body'),
}

async function getPtsSceneWithOptions(request: GetPtsSceneRequest, runtime: Util.RuntimeOptions): GetPtsSceneResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sceneId)) {
    query['SceneId'] = request.sceneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetPtsScene',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPtsScene(request: GetPtsSceneRequest): GetPtsSceneResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPtsSceneWithOptions(request, runtime);
}

model GetPtsSceneBaseLineRequest {
  sceneId?: string(name='SceneId'),
}

model GetPtsSceneBaseLineResponseBody = {
  baseline?: {
    apiBaselines?: [ 
      {
        avgRt?: float(name='AvgRt'),
        avgTps?: float(name='AvgTps'),
        failCountBiz?: long(name='FailCountBiz'),
        failCountReq?: long(name='FailCountReq'),
        id?: long(name='Id'),
        maxRt?: int32(name='MaxRt'),
        minRt?: int32(name='MinRt'),
        name?: string(name='Name'),
        seg90Rt?: float(name='Seg90Rt'),
        seg99Rt?: float(name='Seg99Rt'),
        successRateBiz?: float(name='SuccessRateBiz'),
        successRateReq?: float(name='SuccessRateReq'),
      }
    ](name='ApiBaselines'),
    name?: string(name='Name'),
    sceneBaseline?: {
      avgRt?: float(name='AvgRt'),
      avgTps?: float(name='AvgTps'),
      failCountBiz?: long(name='FailCountBiz'),
      failCountReq?: long(name='FailCountReq'),
      seg90Rt?: float(name='Seg90Rt'),
      seg99Rt?: float(name='Seg99Rt'),
      successRateBiz?: float(name='SuccessRateBiz'),
      successRateReq?: float(name='SuccessRateReq'),
    }(name='SceneBaseline'),
  }(name='Baseline'),
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  sceneId?: string(name='SceneId'),
  success?: boolean(name='Success'),
}

model GetPtsSceneBaseLineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPtsSceneBaseLineResponseBody(name='body'),
}

async function getPtsSceneBaseLineWithOptions(request: GetPtsSceneBaseLineRequest, runtime: Util.RuntimeOptions): GetPtsSceneBaseLineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sceneId)) {
    query['SceneId'] = request.sceneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetPtsSceneBaseLine',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPtsSceneBaseLine(request: GetPtsSceneBaseLineRequest): GetPtsSceneBaseLineResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPtsSceneBaseLineWithOptions(request, runtime);
}

model GetPtsSceneRunningDataRequest {
  planId?: string(name='PlanId'),
  sceneId?: string(name='SceneId'),
}

model GetPtsSceneRunningDataResponseBody = {
  agentLocation?: [ 
    {
      count?: int32(name='Count'),
      isp?: string(name='Isp'),
      province?: string(name='Province'),
      region?: string(name='Region'),
    }
  ](name='AgentLocation'),
  aliveAgents?: int32(name='AliveAgents'),
  averageRt?: long(name='AverageRt'),
  beginTime?: long(name='BeginTime'),
  chainMonitorDataList?: [ 
    {
      apiId?: string(name='ApiId'),
      apiName?: string(name='ApiName'),
      averageRt?: int32(name='AverageRt'),
      checkPointResult?: {
        failedBusinessCount?: long(name='FailedBusinessCount'),
        failedBusinessQps?: float(name='FailedBusinessQps'),
        succeedBusinessCount?: long(name='SucceedBusinessCount'),
        succeedBusinessQps?: float(name='SucceedBusinessQps'),
      }(name='CheckPointResult'),
      concurrency?: float(name='Concurrency'),
      configQps?: int32(name='ConfigQps'),
      count2XX?: long(name='Count2XX'),
      failedCount?: long(name='FailedCount'),
      failedQps?: float(name='FailedQps'),
      maxRt?: int32(name='MaxRt'),
      minRt?: int32(name='MinRt'),
      nodeId?: long(name='NodeId'),
      qps2XX?: float(name='Qps2XX'),
      realQps?: float(name='RealQps'),
      timePoint?: long(name='TimePoint'),
    }
  ](name='ChainMonitorDataList'),
  code?: string(name='Code'),
  concurrency?: int32(name='Concurrency'),
  concurrencyLimit?: int32(name='ConcurrencyLimit'),
  failedBusinessCount?: long(name='FailedBusinessCount'),
  failedRequestCount?: long(name='FailedRequestCount'),
  hasReport?: boolean(name='HasReport'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestBps?: string(name='RequestBps'),
  requestId?: string(name='RequestId'),
  responseBps?: string(name='ResponseBps'),
  seg90Rt?: long(name='Seg90Rt'),
  status?: int32(name='Status'),
  success?: boolean(name='Success'),
  totalAgents?: int32(name='TotalAgents'),
  totalRequestCount?: long(name='TotalRequestCount'),
  tpsLimit?: int32(name='TpsLimit'),
  vum?: long(name='Vum'),
}

model GetPtsSceneRunningDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPtsSceneRunningDataResponseBody(name='body'),
}

async function getPtsSceneRunningDataWithOptions(request: GetPtsSceneRunningDataRequest, runtime: Util.RuntimeOptions): GetPtsSceneRunningDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.planId)) {
    query['PlanId'] = request.planId;
  }
  if (!Util.isUnset(request.sceneId)) {
    query['SceneId'] = request.sceneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetPtsSceneRunningData',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPtsSceneRunningData(request: GetPtsSceneRunningDataRequest): GetPtsSceneRunningDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPtsSceneRunningDataWithOptions(request, runtime);
}

model GetPtsSceneRunningStatusRequest {
  sceneId?: string(name='SceneId'),
}

model GetPtsSceneRunningStatusResponseBody = {
  code?: string(name='Code'),
  createTime?: string(name='CreateTime'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  modifiedTime?: string(name='ModifiedTime'),
  requestId?: string(name='RequestId'),
  sceneName?: string(name='SceneName'),
  status?: string(name='Status'),
  success?: boolean(name='Success'),
}

model GetPtsSceneRunningStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPtsSceneRunningStatusResponseBody(name='body'),
}

async function getPtsSceneRunningStatusWithOptions(request: GetPtsSceneRunningStatusRequest, runtime: Util.RuntimeOptions): GetPtsSceneRunningStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sceneId)) {
    query['SceneId'] = request.sceneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetPtsSceneRunningStatus',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPtsSceneRunningStatus(request: GetPtsSceneRunningStatusRequest): GetPtsSceneRunningStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPtsSceneRunningStatusWithOptions(request, runtime);
}

model GetUserVpcSecurityGroupRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  vpcId?: string(name='VpcId'),
}

model GetUserVpcSecurityGroupResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  securityGroupCount?: int32(name='SecurityGroupCount'),
  securityGroupList?: [ 
    {
      description?: string(name='Description'),
      securityGroupId?: string(name='SecurityGroupId'),
      securityGroupName?: string(name='SecurityGroupName'),
      vpcId?: string(name='VpcId'),
    }
  ](name='SecurityGroupList'),
  success?: boolean(name='Success'),
}

model GetUserVpcSecurityGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetUserVpcSecurityGroupResponseBody(name='body'),
}

async function getUserVpcSecurityGroupWithOptions(request: GetUserVpcSecurityGroupRequest, runtime: Util.RuntimeOptions): GetUserVpcSecurityGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetUserVpcSecurityGroup',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getUserVpcSecurityGroup(request: GetUserVpcSecurityGroupRequest): GetUserVpcSecurityGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return getUserVpcSecurityGroupWithOptions(request, runtime);
}

model GetUserVpcVSwitchRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  vpcId?: string(name='VpcId'),
}

model GetUserVpcVSwitchResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  vSwitchCount?: int32(name='VSwitchCount'),
  vSwitchList?: [ 
    {
      availableIpAddressCount?: long(name='AvailableIpAddressCount'),
      maxAgentCount?: int32(name='MaxAgentCount'),
      vSwitchId?: string(name='VSwitchId'),
      vSwitchName?: string(name='VSwitchName'),
      vpcId?: string(name='VpcId'),
    }
  ](name='VSwitchList'),
}

model GetUserVpcVSwitchResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetUserVpcVSwitchResponseBody(name='body'),
}

async function getUserVpcVSwitchWithOptions(request: GetUserVpcVSwitchRequest, runtime: Util.RuntimeOptions): GetUserVpcVSwitchResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetUserVpcVSwitch',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getUserVpcVSwitch(request: GetUserVpcVSwitchRequest): GetUserVpcVSwitchResponse {
  var runtime = new Util.RuntimeOptions{};
  return getUserVpcVSwitchWithOptions(request, runtime);
}

model GetUserVpcsRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  vpcId?: string(name='VpcId'),
}

model GetUserVpcsResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
  vpcs?: [ 
    {
      cidrBlock?: string(name='CidrBlock'),
      description?: string(name='Description'),
      regionId?: string(name='RegionId'),
      resourceGroupId?: string(name='ResourceGroupId'),
      routerTableIds?: [ string ](name='RouterTableIds'),
      vSwitchIds?: [ string ](name='VSwitchIds'),
      vpcId?: string(name='VpcId'),
      vpcName?: string(name='VpcName'),
    }
  ](name='Vpcs'),
}

model GetUserVpcsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetUserVpcsResponseBody(name='body'),
}

async function getUserVpcsWithOptions(request: GetUserVpcsRequest, runtime: Util.RuntimeOptions): GetUserVpcsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetUserVpcs',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getUserVpcs(request: GetUserVpcsRequest): GetUserVpcsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getUserVpcsWithOptions(request, runtime);
}

model ListEnvsRequest {
  envId?: string(name='EnvId'),
  envName?: string(name='EnvName'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListEnvsResponseBody = {
  code?: string(name='Code'),
  envs?: [ 
    {
      createTime?: long(name='CreateTime'),
      envId?: string(name='EnvId'),
      envName?: string(name='EnvName'),
      envVersion?: string(name='EnvVersion'),
      files?: [ 
        {
          fileId?: long(name='FileId'),
          fileName?: string(name='FileName'),
          fileOssAddress?: string(name='FileOssAddress'),
          fileSize?: long(name='FileSize'),
          md5?: string(name='Md5'),
        }
      ](name='Files'),
      modifiedTime?: long(name='ModifiedTime'),
      properties?: [ 
        {
          description?: string(name='Description'),
          name?: string(name='Name'),
          value?: string(name='Value'),
        }
      ](name='Properties'),
      relatedScenes?: [ string ](name='RelatedScenes'),
      runningScenes?: [ string ](name='RunningScenes'),
      usedCapacity?: long(name='UsedCapacity'),
    }
  ](name='Envs'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model ListEnvsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListEnvsResponseBody(name='body'),
}

async function listEnvsWithOptions(request: ListEnvsRequest, runtime: Util.RuntimeOptions): ListEnvsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.envId)) {
    query['EnvId'] = request.envId;
  }
  if (!Util.isUnset(request.envName)) {
    query['EnvName'] = request.envName;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListEnvs',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listEnvs(request: ListEnvsRequest): ListEnvsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEnvsWithOptions(request, runtime);
}

model ListJMeterReportsRequest {
  beginTime?: long(name='BeginTime'),
  endTime?: long(name='EndTime'),
  keyword?: string(name='Keyword'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  reportId?: string(name='ReportId'),
  sceneId?: string(name='SceneId'),
}

model ListJMeterReportsResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  reports?: [ 
    {
      actualStartTime?: long(name='ActualStartTime'),
      duration?: string(name='Duration'),
      reportId?: string(name='ReportId'),
      reportName?: string(name='ReportName'),
      vum?: long(name='Vum'),
    }
  ](name='Reports'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model ListJMeterReportsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListJMeterReportsResponseBody(name='body'),
}

async function listJMeterReportsWithOptions(request: ListJMeterReportsRequest, runtime: Util.RuntimeOptions): ListJMeterReportsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.beginTime)) {
    query['BeginTime'] = request.beginTime;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.reportId)) {
    query['ReportId'] = request.reportId;
  }
  if (!Util.isUnset(request.sceneId)) {
    query['SceneId'] = request.sceneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListJMeterReports',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listJMeterReports(request: ListJMeterReportsRequest): ListJMeterReportsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listJMeterReportsWithOptions(request, runtime);
}

model ListOpenJMeterScenesRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  sceneId?: string(name='SceneId'),
  sceneName?: string(name='SceneName'),
}

model ListOpenJMeterScenesResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  JMeterScene?: [ 
    {
      durationStr?: string(name='DurationStr'),
      sceneId?: string(name='SceneId'),
      sceneName?: string(name='SceneName'),
    }
  ](name='JMeterScene'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model ListOpenJMeterScenesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListOpenJMeterScenesResponseBody(name='body'),
}

async function listOpenJMeterScenesWithOptions(request: ListOpenJMeterScenesRequest, runtime: Util.RuntimeOptions): ListOpenJMeterScenesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sceneId)) {
    query['SceneId'] = request.sceneId;
  }
  if (!Util.isUnset(request.sceneName)) {
    query['SceneName'] = request.sceneName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListOpenJMeterScenes',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listOpenJMeterScenes(request: ListOpenJMeterScenesRequest): ListOpenJMeterScenesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listOpenJMeterScenesWithOptions(request, runtime);
}

model ListPtsSceneRequest {
  keyWord?: string(name='KeyWord'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListPtsSceneResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  sceneViewList?: [ 
    {
      createTime?: string(name='CreateTime'),
      sceneId?: string(name='SceneId'),
      sceneName?: string(name='SceneName'),
    }
  ](name='SceneViewList'),
  success?: boolean(name='Success'),
}

model ListPtsSceneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPtsSceneResponseBody(name='body'),
}

async function listPtsSceneWithOptions(request: ListPtsSceneRequest, runtime: Util.RuntimeOptions): ListPtsSceneResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyWord)) {
    query['KeyWord'] = request.keyWord;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPtsScene',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPtsScene(request: ListPtsSceneRequest): ListPtsSceneResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPtsSceneWithOptions(request, runtime);
}

model ModifyPtsSceneRequest {
  scene?: string(name='Scene'),
}

model ModifyPtsSceneResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ModifyPtsSceneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyPtsSceneResponseBody(name='body'),
}

async function modifyPtsSceneWithOptions(request: ModifyPtsSceneRequest, runtime: Util.RuntimeOptions): ModifyPtsSceneResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.scene)) {
    body['Scene'] = request.scene;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyPtsScene',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyPtsScene(request: ModifyPtsSceneRequest): ModifyPtsSceneResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyPtsSceneWithOptions(request, runtime);
}

model RemoveEnvRequest {
  envId?: string(name='EnvId'),
}

model RemoveEnvResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RemoveEnvResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveEnvResponseBody(name='body'),
}

async function removeEnvWithOptions(request: RemoveEnvRequest, runtime: Util.RuntimeOptions): RemoveEnvResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.envId)) {
    query['EnvId'] = request.envId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemoveEnv',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removeEnv(request: RemoveEnvRequest): RemoveEnvResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeEnvWithOptions(request, runtime);
}

model RemoveOpenJMeterSceneRequest {
  sceneId?: string(name='SceneId'),
}

model RemoveOpenJMeterSceneResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RemoveOpenJMeterSceneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveOpenJMeterSceneResponseBody(name='body'),
}

async function removeOpenJMeterSceneWithOptions(request: RemoveOpenJMeterSceneRequest, runtime: Util.RuntimeOptions): RemoveOpenJMeterSceneResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sceneId)) {
    query['SceneId'] = request.sceneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemoveOpenJMeterScene',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removeOpenJMeterScene(request: RemoveOpenJMeterSceneRequest): RemoveOpenJMeterSceneResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeOpenJMeterSceneWithOptions(request, runtime);
}

model SaveEnvRequest {
  env?: {
    envId?: string(name='EnvId'),
    envName?: string(name='EnvName'),
    files?: [ 
      {
        fileName?: string(name='FileName'),
        fileOssAddress?: string(name='FileOssAddress'),
      }
    ](name='Files'),
    jmeterPluginLabel?: string(name='JmeterPluginLabel'),
    properties?: [ 
      {
        description?: string(name='Description'),
        name?: string(name='Name'),
        value?: string(name='Value'),
      }
    ](name='Properties'),
  }(name='Env'),
}

model SaveEnvShrinkRequest {
  envShrink?: string(name='Env'),
}

model SaveEnvResponseBody = {
  code?: string(name='Code'),
  envId?: string(name='EnvId'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SaveEnvResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveEnvResponseBody(name='body'),
}

async function saveEnvWithOptions(tmpReq: SaveEnvRequest, runtime: Util.RuntimeOptions): SaveEnvResponse {
  Util.validateModel(tmpReq);
  var request = new SaveEnvShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.env)) {
    request.envShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.env, 'Env', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.envShrink)) {
    query['Env'] = request.envShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveEnv',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveEnv(request: SaveEnvRequest): SaveEnvResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveEnvWithOptions(request, runtime);
}

model SaveOpenJMeterSceneRequest {
  openJMeterScene?: {
    agentCount?: int32(name='AgentCount'),
    concurrency?: int32(name='Concurrency'),
    constantThroughputTimerType?: string(name='ConstantThroughputTimerType'),
    dnsCacheConfig?: {
      clearCacheEachIteration?: boolean(name='ClearCacheEachIteration'),
      dnsServers?: [ string ](name='DnsServers'),
      hostTable?: map[string]string(name='HostTable'),
    }(name='DnsCacheConfig'),
    duration?: int32(name='Duration'),
    environmentId?: string(name='EnvironmentId'),
    fileList?: [ 
      {
        fileId?: long(name='FileId'),
        fileName?: string(name='FileName'),
        fileOssAddress?: string(name='FileOssAddress'),
        fileSize?: long(name='FileSize'),
        md5?: string(name='Md5'),
        splitCsv?: boolean(name='SplitCsv'),
        tags?: string(name='Tags'),
      }
    ](name='FileList'),
    isVpcTest?: boolean(name='IsVpcTest'),
    JMeterProperties?: [ 
      {
        name?: string(name='Name'),
        value?: string(name='Value'),
      }
    ](name='JMeterProperties'),
    jmeterPluginLabel?: string(name='JmeterPluginLabel'),
    maxRps?: int32(name='MaxRps'),
    mode?: string(name='Mode'),
    rampUp?: int32(name='RampUp'),
    regionId?: string(name='RegionId'),
    sceneId?: string(name='SceneId'),
    sceneName?: string(name='SceneName'),
    securityGroupId?: string(name='SecurityGroupId'),
    startConcurrency?: int32(name='StartConcurrency'),
    startRps?: int32(name='StartRps'),
    steps?: int32(name='Steps'),
    syncTimerType?: string(name='SyncTimerType'),
    testFile?: string(name='TestFile'),
    vSwitchId?: string(name='VSwitchId'),
    vpcId?: string(name='VpcId'),
  }(name='OpenJMeterScene'),
}

model SaveOpenJMeterSceneShrinkRequest {
  openJMeterSceneShrink?: string(name='OpenJMeterScene'),
}

model SaveOpenJMeterSceneResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  sceneId?: string(name='SceneId'),
  success?: boolean(name='Success'),
}

model SaveOpenJMeterSceneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveOpenJMeterSceneResponseBody(name='body'),
}

async function saveOpenJMeterSceneWithOptions(tmpReq: SaveOpenJMeterSceneRequest, runtime: Util.RuntimeOptions): SaveOpenJMeterSceneResponse {
  Util.validateModel(tmpReq);
  var request = new SaveOpenJMeterSceneShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.openJMeterScene)) {
    request.openJMeterSceneShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.openJMeterScene, 'OpenJMeterScene', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.openJMeterSceneShrink)) {
    query['OpenJMeterScene'] = request.openJMeterSceneShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveOpenJMeterScene',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveOpenJMeterScene(request: SaveOpenJMeterSceneRequest): SaveOpenJMeterSceneResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveOpenJMeterSceneWithOptions(request, runtime);
}

model SavePtsSceneRequest {
  scene?: {
    advanceSetting?: {
      connectionTimeoutInSecond?: int32(name='ConnectionTimeoutInSecond'),
      domainBindingList?: [ 
        {
          domain?: string(name='Domain'),
          ips?: [ string ](name='Ips'),
        }
      ](name='DomainBindingList'),
      logRate?: int32(name='LogRate'),
      successCode?: string(name='SuccessCode'),
    }(name='AdvanceSetting'),
    fileParameterList?: [ 
      {
        fileName?: string(name='FileName'),
        fileOssAddress?: string(name='FileOssAddress'),
      }
    ](name='FileParameterList'),
    globalParameterList?: [ 
      {
        paramName?: string(name='ParamName'),
        paramValue?: string(name='ParamValue'),
      }
    ](name='GlobalParameterList'),
    loadConfig?: {
      agentCount?: int32(name='AgentCount'),
      apiLoadConfigList?: [ 
        {
          apiId?: string(name='ApiId'),
          rpsBegin?: int32(name='RpsBegin'),
          rpsLimit?: int32(name='RpsLimit'),
        }
      ](name='ApiLoadConfigList'),
      autoStep?: boolean(name='AutoStep'),
      configuration?: {
        allConcurrencyBegin?: int32(name='AllConcurrencyBegin'),
        allConcurrencyLimit?: int32(name='AllConcurrencyLimit'),
        allRpsBegin?: int32(name='AllRpsBegin'),
        allRpsLimit?: int32(name='AllRpsLimit'),
      }(name='Configuration'),
      increment?: int32(name='Increment'),
      keepTime?: int32(name='KeepTime'),
      maxRunningTime?: int32(name='MaxRunningTime'),
      relationLoadConfigList?: [ 
        {
          concurrencyBegin?: int32(name='ConcurrencyBegin'),
          concurrencyLimit?: int32(name='ConcurrencyLimit'),
          relationId?: string(name='RelationId'),
        }
      ](name='RelationLoadConfigList'),
      testMode?: string(name='TestMode'),
      vpcLoadConfig?: {
        regionId?: string(name='RegionId'),
        securityGroupId?: string(name='SecurityGroupId'),
        vSwitchId?: string(name='VSwitchId'),
        vpcId?: string(name='VpcId'),
      }(name='VpcLoadConfig'),
    }(name='LoadConfig'),
    relationList?: [ 
      {
        apiList?: [ 
          {
            apiId?: string(name='ApiId'),
            apiName?: string(name='ApiName'),
            body?: {
              bodyValue?: string(name='BodyValue'),
              contentType?: string(name='ContentType'),
            }(name='Body'),
            checkPointList?: [ 
              {
                checkPoint?: string(name='CheckPoint'),
                checkType?: string(name='CheckType'),
                expectValue?: string(name='ExpectValue'),
                operator?: string(name='Operator'),
              }
            ](name='CheckPointList'),
            exportList?: [ 
              {
                count?: string(name='Count'),
                exportName?: string(name='ExportName'),
                exportType?: string(name='ExportType'),
                exportValue?: string(name='ExportValue'),
              }
            ](name='ExportList'),
            headerList?: [ 
              {
                headerName?: string(name='HeaderName'),
                headerValue?: string(name='HeaderValue'),
              }
            ](name='HeaderList'),
            method?: string(name='Method'),
            redirectCountLimit?: int32(name='RedirectCountLimit'),
            timeoutInSecond?: int32(name='TimeoutInSecond'),
            url?: string(name='Url'),
          }
        ](name='ApiList'),
        fileParameterExplainList?: [ 
          {
            baseFile?: boolean(name='BaseFile'),
            cycleOnce?: boolean(name='CycleOnce'),
            fileName?: string(name='FileName'),
            fileParamName?: string(name='FileParamName'),
          }
        ](name='FileParameterExplainList'),
        relationId?: string(name='RelationId'),
        relationName?: string(name='RelationName'),
      }
    ](name='RelationList'),
    sceneId?: string(name='SceneId'),
    sceneName?: string(name='SceneName'),
  }(name='Scene'),
}

model SavePtsSceneShrinkRequest {
  sceneShrink?: string(name='Scene'),
}

model SavePtsSceneResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  sceneId?: string(name='SceneId'),
  success?: boolean(name='Success'),
}

model SavePtsSceneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SavePtsSceneResponseBody(name='body'),
}

async function savePtsSceneWithOptions(tmpReq: SavePtsSceneRequest, runtime: Util.RuntimeOptions): SavePtsSceneResponse {
  Util.validateModel(tmpReq);
  var request = new SavePtsSceneShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.scene)) {
    request.sceneShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.scene, 'Scene', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.sceneShrink)) {
    query['Scene'] = request.sceneShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SavePtsScene',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function savePtsScene(request: SavePtsSceneRequest): SavePtsSceneResponse {
  var runtime = new Util.RuntimeOptions{};
  return savePtsSceneWithOptions(request, runtime);
}

model StartDebugPtsSceneRequest {
  sceneId?: string(name='SceneId'),
}

model StartDebugPtsSceneResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  planId?: string(name='PlanId'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model StartDebugPtsSceneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartDebugPtsSceneResponseBody(name='body'),
}

async function startDebugPtsSceneWithOptions(request: StartDebugPtsSceneRequest, runtime: Util.RuntimeOptions): StartDebugPtsSceneResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sceneId)) {
    query['SceneId'] = request.sceneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartDebugPtsScene',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startDebugPtsScene(request: StartDebugPtsSceneRequest): StartDebugPtsSceneResponse {
  var runtime = new Util.RuntimeOptions{};
  return startDebugPtsSceneWithOptions(request, runtime);
}

model StartDebuggingJMeterSceneRequest {
  sceneId?: string(name='SceneId'),
}

model StartDebuggingJMeterSceneResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  reportId?: string(name='ReportId'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model StartDebuggingJMeterSceneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartDebuggingJMeterSceneResponseBody(name='body'),
}

async function startDebuggingJMeterSceneWithOptions(request: StartDebuggingJMeterSceneRequest, runtime: Util.RuntimeOptions): StartDebuggingJMeterSceneResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sceneId)) {
    query['SceneId'] = request.sceneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartDebuggingJMeterScene',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startDebuggingJMeterScene(request: StartDebuggingJMeterSceneRequest): StartDebuggingJMeterSceneResponse {
  var runtime = new Util.RuntimeOptions{};
  return startDebuggingJMeterSceneWithOptions(request, runtime);
}

model StartPtsSceneRequest {
  sceneId?: string(name='SceneId'),
}

model StartPtsSceneResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  planId?: string(name='PlanId'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model StartPtsSceneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartPtsSceneResponseBody(name='body'),
}

async function startPtsSceneWithOptions(request: StartPtsSceneRequest, runtime: Util.RuntimeOptions): StartPtsSceneResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sceneId)) {
    query['SceneId'] = request.sceneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartPtsScene',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startPtsScene(request: StartPtsSceneRequest): StartPtsSceneResponse {
  var runtime = new Util.RuntimeOptions{};
  return startPtsSceneWithOptions(request, runtime);
}

model StartTestingJMeterSceneRequest {
  sceneId?: string(name='SceneId'),
}

model StartTestingJMeterSceneResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  reportId?: string(name='ReportId'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model StartTestingJMeterSceneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartTestingJMeterSceneResponseBody(name='body'),
}

async function startTestingJMeterSceneWithOptions(request: StartTestingJMeterSceneRequest, runtime: Util.RuntimeOptions): StartTestingJMeterSceneResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sceneId)) {
    query['SceneId'] = request.sceneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartTestingJMeterScene',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startTestingJMeterScene(request: StartTestingJMeterSceneRequest): StartTestingJMeterSceneResponse {
  var runtime = new Util.RuntimeOptions{};
  return startTestingJMeterSceneWithOptions(request, runtime);
}

model StopDebugPtsSceneRequest {
  planId?: string(name='PlanId'),
  sceneId?: string(name='SceneId'),
}

model StopDebugPtsSceneResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model StopDebugPtsSceneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopDebugPtsSceneResponseBody(name='body'),
}

async function stopDebugPtsSceneWithOptions(request: StopDebugPtsSceneRequest, runtime: Util.RuntimeOptions): StopDebugPtsSceneResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.planId)) {
    query['PlanId'] = request.planId;
  }
  if (!Util.isUnset(request.sceneId)) {
    query['SceneId'] = request.sceneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopDebugPtsScene',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopDebugPtsScene(request: StopDebugPtsSceneRequest): StopDebugPtsSceneResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopDebugPtsSceneWithOptions(request, runtime);
}

model StopDebuggingJMeterSceneRequest {
  sceneId?: string(name='SceneId'),
}

model StopDebuggingJMeterSceneResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model StopDebuggingJMeterSceneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopDebuggingJMeterSceneResponseBody(name='body'),
}

async function stopDebuggingJMeterSceneWithOptions(request: StopDebuggingJMeterSceneRequest, runtime: Util.RuntimeOptions): StopDebuggingJMeterSceneResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sceneId)) {
    query['SceneId'] = request.sceneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopDebuggingJMeterScene',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopDebuggingJMeterScene(request: StopDebuggingJMeterSceneRequest): StopDebuggingJMeterSceneResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopDebuggingJMeterSceneWithOptions(request, runtime);
}

model StopPtsSceneRequest {
  sceneId?: string(name='SceneId'),
}

model StopPtsSceneResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model StopPtsSceneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopPtsSceneResponseBody(name='body'),
}

async function stopPtsSceneWithOptions(request: StopPtsSceneRequest, runtime: Util.RuntimeOptions): StopPtsSceneResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sceneId)) {
    query['SceneId'] = request.sceneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopPtsScene',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopPtsScene(request: StopPtsSceneRequest): StopPtsSceneResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopPtsSceneWithOptions(request, runtime);
}

model StopTestingJMeterSceneRequest {
  sceneId?: string(name='SceneId'),
}

model StopTestingJMeterSceneResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model StopTestingJMeterSceneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopTestingJMeterSceneResponseBody(name='body'),
}

async function stopTestingJMeterSceneWithOptions(request: StopTestingJMeterSceneRequest, runtime: Util.RuntimeOptions): StopTestingJMeterSceneResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sceneId)) {
    query['SceneId'] = request.sceneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopTestingJMeterScene',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopTestingJMeterScene(request: StopTestingJMeterSceneRequest): StopTestingJMeterSceneResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopTestingJMeterSceneWithOptions(request, runtime);
}

model UpdatePtsSceneBaseLineRequest {
  apiBaselines?: map[string]any(name='ApiBaselines'),
  sceneBaseline?: map[string]any(name='SceneBaseline'),
  sceneId?: string(name='SceneId'),
}

model UpdatePtsSceneBaseLineShrinkRequest {
  apiBaselinesShrink?: string(name='ApiBaselines'),
  sceneBaselineShrink?: string(name='SceneBaseline'),
  sceneId?: string(name='SceneId'),
}

model UpdatePtsSceneBaseLineResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdatePtsSceneBaseLineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdatePtsSceneBaseLineResponseBody(name='body'),
}

async function updatePtsSceneBaseLineWithOptions(tmpReq: UpdatePtsSceneBaseLineRequest, runtime: Util.RuntimeOptions): UpdatePtsSceneBaseLineResponse {
  Util.validateModel(tmpReq);
  var request = new UpdatePtsSceneBaseLineShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.apiBaselines)) {
    request.apiBaselinesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.apiBaselines, 'ApiBaselines', 'json');
  }
  if (!Util.isUnset(tmpReq.sceneBaseline)) {
    request.sceneBaselineShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sceneBaseline, 'SceneBaseline', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.apiBaselinesShrink)) {
    query['ApiBaselines'] = request.apiBaselinesShrink;
  }
  if (!Util.isUnset(request.sceneBaselineShrink)) {
    query['SceneBaseline'] = request.sceneBaselineShrink;
  }
  if (!Util.isUnset(request.sceneId)) {
    query['SceneId'] = request.sceneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdatePtsSceneBaseLine',
    version = '2020-10-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updatePtsSceneBaseLine(request: UpdatePtsSceneBaseLineRequest): UpdatePtsSceneBaseLineResponse {
  var runtime = new Util.RuntimeOptions{};
  return updatePtsSceneBaseLineWithOptions(request, runtime);
}

