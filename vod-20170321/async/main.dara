/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'vod';
  @version = '2017-03-21';
  @endpointRule = 'regional';
  @endpointMap = {
    ap-northeast-2-pop = 'vod.aliyuncs.com',
    ap-southeast-2 = 'vod.aliyuncs.com',
    ap-southeast-3 = 'vod.aliyuncs.com',
    cn-beijing-finance-1 = 'vod.aliyuncs.com',
    cn-beijing-finance-pop = 'vod.aliyuncs.com',
    cn-beijing-gov-1 = 'vod.aliyuncs.com',
    cn-beijing-nu16-b01 = 'vod.aliyuncs.com',
    cn-chengdu = 'vod.aliyuncs.com',
    cn-edge-1 = 'vod.aliyuncs.com',
    cn-fujian = 'vod.aliyuncs.com',
    cn-haidian-cm12-c01 = 'vod.aliyuncs.com',
    cn-hangzhou = 'vod.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'vod.aliyuncs.com',
    cn-hangzhou-finance = 'vod.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'vod.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'vod.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'vod.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'vod.aliyuncs.com',
    cn-hangzhou-test-306 = 'vod.aliyuncs.com',
    cn-hongkong = 'vod.aliyuncs.com',
    cn-hongkong-finance-pop = 'vod.aliyuncs.com',
    cn-huhehaote = 'vod.aliyuncs.com',
    cn-huhehaote-nebula-1 = 'vod.aliyuncs.com',
    cn-qingdao = 'vod.aliyuncs.com',
    cn-qingdao-nebula = 'vod.aliyuncs.com',
    cn-shanghai-et15-b01 = 'vod.aliyuncs.com',
    cn-shanghai-et2-b01 = 'vod.aliyuncs.com',
    cn-shanghai-finance-1 = 'vod.aliyuncs.com',
    cn-shanghai-inner = 'vod.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'vod.aliyuncs.com',
    cn-shenzhen-finance-1 = 'vod.aliyuncs.com',
    cn-shenzhen-inner = 'vod.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'vod.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'vod.aliyuncs.com',
    cn-wuhan = 'vod.aliyuncs.com',
    cn-wulanchabu = 'vod.aliyuncs.com',
    cn-yushanfang = 'vod.aliyuncs.com',
    cn-zhangbei = 'vod.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'vod.aliyuncs.com',
    cn-zhangjiakou = 'vod.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'vod.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'vod.aliyuncs.com',
    eu-west-1 = 'vod.aliyuncs.com',
    eu-west-1-oxs = 'vod.aliyuncs.com',
    me-east-1 = 'vod.aliyuncs.com',
    rus-west-1-pop = 'vod.aliyuncs.com',
    us-east-1 = 'vod.aliyuncs.com',
    us-west-1 = 'vod.aliyuncs.com',
  };
}

function close(): void {
  @handler.close();
}

model AddAITemplateRequest {
  templateConfig: string(name='TemplateConfig', description='Adds an AI template for automated review and smart thumbnail tasks.', example='{"AuditItem":["terrorism","porn"],"AuditRange":["image-cover","text-title","video"],"AuditContent":["screen"],"AuditAutoBlock":"yes"}', position='Query'),
  templateName: string(name='TemplateName', description='The ID of the request.', example='AI-media-test', position='Query'),
  templateType: string(name='TemplateType', description='The operation that you want to perform. Set the value to **AddAITemplate**.', example='AIMediaAudit', position='Query'),
}

model AddAITemplateResponseBody = {
  requestId?: string(name='RequestId', example='25818875-5F78-4A13-BEF6-****'),
  templateId?: string(name='TemplateId', example='1706a0063dd733f6a823ef32e0a5****'),
}

model AddAITemplateResponse = {
  headers: map[string]string(name='headers'),
  body: AddAITemplateResponseBody(name='body'),
}

/**
  * The type of the AI template. Valid values:
  * *   **AIMediaAudit**: automated review
  * *   **AIImage**: smart thumbnail
  *
 */
async function addAITemplate(request: AddAITemplateRequest): AddAITemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddAITemplate', 'POST', '/', 'json', false, 'json', request);
}

model AddCategoryRequest {
  cateName: string(name='CateName', description='test', example='The ID of the parent category. If you do not set this parameter, a level 1 category is generated by default. The parent category ID of a level 1 category is **-1**.

> Level 1 material categories are built in the system and cannot be changed. If you set the Type parameter to material, you must set the ParentId parameter.', position='Query'),
  parentId?: long(name='ParentId', description='test', example='100012****', position='Query'),
  type?: string(name='Type', description='The type of the category. Valid values:

- **default** (default): default category
- **material**: material category', example='default', position='Query'),
}

model AddCategoryResponseBody = {
  category?: {
    cateId?: long(name='CateId', example='10020'),
    cateName?: string(name='CateName', description='AddCategory'),
    level?: long(name='Level', example='1'),
    parentId?: long(name='ParentId', description='Creates a video category.', example='100012'),
    type?: string(name='Type', description='The ID of the video category.', example='default'),
  }(name='Category', description='The information about the video category.'),
  requestId?: string(name='RequestId', description='The operation that you want to perform. Set the value to **AddCategory**.', example='25818875-5F78-4AF6-D7393642CA58****'),
}

model AddCategoryResponse = {
  headers: map[string]string(name='headers'),
  body: AddCategoryResponseBody(name='body'),
}

/**
  * The level of the category. A value of **0** indicates a level 1 category.
  *
 */
async function addCategory(request: AddCategoryRequest): AddCategoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddCategory', 'POST', '/', 'json', false, 'json', request);
}

model AddEditingProjectRequest {
  coverURL?: string(name='CoverURL', description='The title of the online editing project.', example='https://demo.aliyundoc.com/6AB4D0E1E1C74468883516C2349D1FC2-6-2.png', position='Query'),
  description?: string(name='Description', description='The region where you want to create the online editing project.', example='testtimeline001desciption', position='Query'),
  division?: string(name='Division', description='The title of the online editing project.', example='cn-shanghai', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: string(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: string(name='ResourceOwnerId', position='Query'),
  timeline?: string(name='Timeline', description='The ID of the online editing project.', example='{"VideoTracks":[{"VideoTrackClips":[{"MediaId":"cc3308ac5006aed55a54328bc3443****"},{"MediaId":"95948ddba24446b6aed5db985e78****"}]}]}', position='Query'),
  title: string(name='Title', description='The operation that you want to perform. Set the value to **AddEditingProject**.', example='testtimeline', position='Query'),
}

model AddEditingProjectResponseBody = {
  project?: {
    creationTime?: string(name='CreationTime', description='The ID of the request.', example='2017-01-11T12:00:00Z'),
    description?: string(name='Description', description='朴灵', example='testtimeline001desciption'),
    modifiedTime?: string(name='ModifiedTime', description='58928', example='2017-01-11T13:00:00Z'),
    projectId?: string(name='ProjectId', example='fb2101bf24bf4df34c4cb3187****'),
    status?: string(name='Status', description='Creates an online editing project.', example='Normal'),
    title?: string(name='Title', example='testtimeline'),
  }(name='Project', description='The time when the online editing project was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.'),
  requestId?: string(name='RequestId', description='The thumbnail URL of the online editing project. If you do not specify this parameter and the video track in the timeline has mezzanine files, the thumbnail of the first mezzanine file in the timeline is used.', example='E4EBD2BF-5EB0-4476-8829-9D94E1B1****'),
}

model AddEditingProjectResponse = {
  headers: map[string]string(name='headers'),
  body: AddEditingProjectResponseBody(name='body'),
}

async function addEditingProject(request: AddEditingProjectRequest): AddEditingProjectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddEditingProject', 'POST', '/', 'json', false, 'json', request);
}

model AddTranscodeTemplateGroupRequest {
  appId?: string(name='AppId', example='app-****', position='Query'),
  name?: string(name='Name', description='Creates a transcoding template group or adds one or more transcoding templates to a template group.', example='transcodetemplate', position='Query'),
  transcodeTemplateGroupId?: string(name='TranscodeTemplateGroupId', example='4c71a339fe52b4fa6f4527****', position='Query'),
  transcodeTemplateList?: string(name='TranscodeTemplateList', position='Query'),
}

model AddTranscodeTemplateGroupResponseBody = {
  requestId?: string(name='RequestId', example='25818875-5F78-4AF6-D7393642CA58****'),
  transcodeTemplateGroupId?: string(name='TranscodeTemplateGroupId', example='34e908aa4024af7821c31f93a2a****'),
}

model AddTranscodeTemplateGroupResponse = {
  headers: map[string]string(name='headers'),
  body: AddTranscodeTemplateGroupResponseBody(name='body'),
}

/**
  * The ID of the transcoding template group.
  *
 */
async function addTranscodeTemplateGroup(request: AddTranscodeTemplateGroupRequest): AddTranscodeTemplateGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddTranscodeTemplateGroup', 'POST', '/', 'json', false, 'json', request);
}

model AddVodDomainRequest {
  checkUrl?: string(name='CheckUrl', description='## Common errors

The following table describes the error codes that this operation can return.

|Error code|Error message|HTTP status code|Description|
|---|---|---|---|
|InvalidDomainName.Malformed|Specified DomainName is malformed.|400|The error message returned because the value of the DomainName parameter is invalid.|
|InvalidCdnType.Malformed|Specified CdnType is malformed.|400|The error message returned because the value of the CdnType parameter is invalid.|
|InvalidSourceType.Malformed|Specified SourceType is malformed.|400|The error message returned because the value of the SourceType parameter is invalid.|
|InvalidSources.Malformed|Specified Sources is malformed.|400|The error message returned because the origin address does not match the origin type.|
|InvalidScope.Malformed|Specified Scope is malformed.|400|The error message returned because the value of the Scope parameter is invalid.|
|InvaildParameter|The Certificate you provided is malformed!|400|The error message returned because the total length of the HTTPS certificate and private key exceeds the upper limit.|
|BusinessExist|Business exist do not repeated submission|400|The error message returned because the domain name is being added. You cannot add duplicate domain names.|
|DomainAlreadyExist|This domain name is exist already|400|The error message returned because the domain name is already added.|
|DomainOverLimit|The Number of Domain is over the limit|403|The error message returned because the number of accelerated domain names exceeds the upper limit.|
|DomainNotRegistration|The Domain name is not registered|404|The error message returned because the domain name does not have an ICP filing.|
|IllegalOperation|Illegal domain operate is not permitted.|403|The error message returned because you are not authorized to perform this operation.|
|ServiceBusy|The specified Domain is configuring, please retry later.|403|The error message returned because the domain name is being configured. Try again later.|
|InvalidDomain.NotFound|The domain provided does not belong to you.|404|The error message returned because the specified domain name does not exist or does not belong to the current account.|
|InnerAddDomainDenied|Your account haven\\"t bind aoneId, can not add domain.|400|The error message returned because an internal account is not bound to an Aone ID. You cannot add a domain name by using the internal account.|
|ExtensiveAndAllBothExist|Extensive domain and the domain begins with \\"all.\\" can not exist at the same time.|400|The error message returned because a wildcard domain name and a domain name that starts with all. exist. They cannot exist at the same time.|
|CdnTypeNotSupportExtensiveDomain|Extensive domain not supported for this cdn type.|400|The error message returned because wildcard domain names are not supported for the specified business type.|
|ExtensiveAndSpecificDomainConflict|Extensive domain and corresponding specific domain are mutually exclusive.|400|The error message returned because the specified domain name is an exact match of an existing wildcard domain name at the same level.|
|InvalidParameter|Add live region parameters have error.|400|The error message returned because the system failed to specify the region for live streaming.|
|InvalidRegion.Malformed|Specified Region is malformed.|400|The error message returned because the value of the region parameter is invalid.|
|InvalidResourceGroupId.Malformed|Specified ResourceGroupId is malformed.|400|The error message returned because the value of the ResourceGroupId parameter is invalid.|
|EntityNotExists.ResourceGroup|The resource group does not exist.|400|The error message returned because the specified resource group does not exist.|
|InvalidStatus.ResourceGroup|It\\"s now allowed to do this operation because of the current status of resource-group.|400|The error message returned because the resource group is in an invalid state.|
|InvalidPriorities.Malformed|The length of priorities is not the same with source.|400|The error message returned because the number of priorities does not match the number of origin servers.|
|NotInternationRealIdentity|You need to do real name authentication when you use Chinese mainland resources.|400|The error message returned because you have not completed real-name verification that is required to use resources in the Chinese mainland.|', example='www.example.com/test.html', position='Query'),
  domainName: string(name='DomainName', description='*   This operation is available only in the **China (Shanghai)** region.
*   Before you add a domain name to accelerate, you must activate ApsaraVideo VOD and apply for an Internet content provider (ICP) filing for the domain name. For more information about how to activate ApsaraVideo VOD, see [Activate ApsaraVideo VOD](~~51512~~).
*   If the content on the origin server is not stored on Alibaba Cloud, the content must be reviewed by Alibaba Cloud. The review will be complete by the end of the next business day after you submit an application.
*   You can add only one domain name to accelerate in a request. You can add a maximum of 20 accelerated domain names within an Alibaba Cloud account.', example='example.com', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  scope?: string(name='Scope', description='The domain name that you want to accelerate. Wildcard domain names that start with periods (.) are supported. Example: .example.com.', example='domestic', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  sources: string(name='Sources', description='## Sources

|Parameter|Type|Required|Description|
|---|---|---|---|
|type|String|Yes|The type of the origin server. Valid values: <br>**ipaddr**: an IP address. <br>**domain**: a domain name. <br>**oss**: the domain of an Object Storage Service (OSS) bucket.|
|content|String|Yes|The address of the origin server. You can specify an IP address or a domain name.|
|port|Integer|No|The port number. Valid values: **443** and **80**. <br>Default value: **80**. If you specify **443**, requests are redirected to the origin server over HTTPS. You can also specify a custom port.|
|priority|String|No|The priority of the origin server if multiple origin servers are specified. Valid values: **20** and **30**. Default value: **20**. **20** indicates that the origin server is the primary origin server. **30** indicates that the origin server is a secondary origin server.|', example='[{"content":"1.1.1.1","type":"ipaddr","priority":"20","port":80}]', position='Query'),
  topLevelDomain?: string(name='TopLevelDomain', description='The information about the addresses of origin servers. For more information, see the **Sources** table in this topic.', example='example.com', position='Query'),
}

model AddVodDomainResponseBody = {
  requestId?: string(name='RequestId', description='The URL that is used for health checks.', example='15C66C7B-671A-4297-****-2C4477247A74'),
}

model AddVodDomainResponse = {
  headers: map[string]string(name='headers'),
  body: AddVodDomainResponseBody(name='body'),
}

/**
  * The ID of the request.
  *
 */
async function addVodDomain(request: AddVodDomainRequest): AddVodDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddVodDomain', 'POST', '/', 'json', false, 'json', request);
}

model AddVodTemplateRequest {
  appId?: string(name='AppId', description='Creates a snapshot template.', example='app-****', position='Query'),
  name: string(name='Name', description='The ID of the application. Default value: **app-1000000**. For more information, see [Overview](~~113600~~).', example='test', position='Query'),
  templateConfig: string(name='TemplateConfig', description='The operation that you want to perform. Set the value to **AddVodTemplate**.', example='{"SnapshotConfig":{"Count":10,"SpecifiedOffsetTime":0,"Interval":1},"SnapshotType":"NormalSnapshot"}', position='Query'),
  templateType: string(name='TemplateType', description='The ID of the request.', example='Snapshot', position='Query'),
}

model AddVodTemplateResponseBody = {
  requestId?: string(name='RequestId', example='25818875-5F78-4A*****F6-D7393642CA58'),
  vodTemplateId?: string(name='VodTemplateId', example='f5b228fe6930e*****0d6bf55bd87789'),
}

model AddVodTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: AddVodTemplateResponseBody(name='body'),
}

/**
  * The type of the template. Set the value to **Snapshot**.
  *
 */
async function addVodTemplate(request: AddVodTemplateRequest): AddVodTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddVodTemplate', 'POST', '/', 'json', false, 'json', request);
}

model AddWatermarkRequest {
  appId?: string(name='AppId', description='The ID of the request.', example='app-****', position='Query'),
  fileUrl?: string(name='FileUrl', description='The OSS URL or Content Delivery Network (CDN) URL of the watermark file. A text watermark does not have a file URL.', example='http://outin-326268*****63e1403e7.oss-cn-shanghai.aliyuncs.com/image/cover/C99345*****E7FDEC-6-2.png', position='Query'),
  name: string(name='Name', description='The ID of the application. Default value: **app-1000000**. For more information, see [Overview](~~113600~~).', example='The type of the watermark. Valid values:

*   **Image**: This is the default value.
*   **Text**', position='Query'),
  type: string(name='Type', description='The ID of the watermark.', example='Text', position='Query'),
  watermarkConfig: string(name='WatermarkConfig', description='The time when the watermark was added. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='The Object Storage Service (OSS) URL of the watermark file. You must set this parameter if you add image watermarks.', position='Query'),
}

model AddWatermarkResponseBody = {
  requestId?: string(name='RequestId', description='> For more information about how to upload a watermark file, see [CreateUploadAttachedMedia](~~98467~~).', example='25818875-5F78-4A*****F6-D7393642CA58'),
  watermarkInfo?: {
    creationTime?: string(name='CreationTime', example='2018-11-07T09:05:52Z'),
    fileUrl?: string(name='FileUrl', example='https://outin-3262*****9f4b3e7.oss-cn-shanghai.aliyuncs.com/image/cover/E6C3448CC8B715E6F8A72EC6B-6-2.png?Expires=1541600583&OSSAccessKeyId=****&Signature=gmf1eYMoDVg%2BHQCb4UGozBW****'),
    isDefault?: string(name='IsDefault', example='NotDefault'),
    name?: string(name='Name'),
    type?: string(name='Type', example='Text'),
    watermarkConfig?: string(name='WatermarkConfig'),
    watermarkId?: string(name='WatermarkId', example='9bcc8bfadb84*****109a2671d0df97'),
  }(name='WatermarkInfo', description='Adds a watermark.'),
}

model AddWatermarkResponse = {
  headers: map[string]string(name='headers'),
  body: AddWatermarkResponseBody(name='body'),
}

/**
  * The name of the watermark. Only letters and digits are supported.
  * *   The name can be up to 128 bytes in length.
  * *   The value must be encoded in UTF-8.
  *
 */
async function addWatermark(request: AddWatermarkRequest): AddWatermarkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddWatermark', 'POST', '/', 'json', false, 'json', request);
}

model AttachAppPolicyToIdentityRequest {
  appId?: string(name='AppId', description='The ID of the request.', example='app-****', position='Query'),
  identityName: string(name='IdentityName', description='The name of the policy. Only system policies are supported. Separate multiple policies with commas (,). Valid values:

*   **VODAppFullAccess**: authorizes an identity to manage all resources in an application.
*   **VODAppReadOnlyAccess**: authorizes an identity to access all resources in an application in read-only mode.
*   **VODAppAdministratorAccess**: assigns the application administrator role to an identity.', example='****', position='Query'),
  identityType: string(name='IdentityType', description='The ID of the application. Default value: **app-1000000**. For more information, see [Overview](~~113600~~).

> This parameter is optional when the PolicyNames parameter is set to VODAppAdministratorAccess. This parameter is required when the PolicyNames parameter is set to other values.', example='RamRole', position='Query'),
  policyNames: string(name='PolicyNames', description='The operation that you want to perform. Set the value to **AttachAppPolicyToIdentity**.', example='VODAppFullAccess', position='Query'),
}

model AttachAppPolicyToIdentityResponseBody = {
  failedPolicyNames?: [ string ](name='FailedPolicyNames'),
  nonExistPolicyNames?: [ string ](name='NonExistPolicyNames'),
  requestId?: string(name='RequestId', description='Authorizes the specified identity to access the applications of ApsaraVideo VOD. The identity may be a RAM user or RAM role.', example='25818875-5F78-4A13-****-D7393642CA58'),
}

model AttachAppPolicyToIdentityResponse = {
  headers: map[string]string(name='headers'),
  body: AttachAppPolicyToIdentityResponseBody(name='body'),
}

/**
  * The name of the policy that was not found.
  *
 */
async function attachAppPolicyToIdentity(request: AttachAppPolicyToIdentityRequest): AttachAppPolicyToIdentityResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AttachAppPolicyToIdentity', 'POST', '/', 'json', false, 'json', request);
}

model BatchSetVodDomainConfigsRequest {
  domainNames: string(name='DomainNames', description='The domain name for CDN. Separate multiple domain names with commas (,).', example='example.com', position='Query'),
  functions: string(name='Functions', description='The features to configure.

*   Set this parameter in the following format: `[{"functionArgs":[{"argName":"domain_name","argValue":"www.example.com"}],"functionName":"set_req_host_header"}]`.
*   Specific features, such as filetype_based_ttl_set, support more than one configuration record. To update one of the configuration records, use the configId field to specify the record. `[{"functionArgs":[{"argName":"file_type","argValue":"jpg"},{"argName":"ttl","argValue":"18"},{"argName":"weight","argValue":"30"}],"functionName":"filetype_based_ttl_set","configId":5068995}]`
*   For more information, see the **Feature description** section.', example='[{"functionArgs":[{"argName":"domain_name","argValue":"www.example.com"}],"functionName":"set_req_host_header"}]', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model BatchSetVodDomainConfigsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-****-6C044FE73368'),
}

model BatchSetVodDomainConfigsResponse = {
  headers: map[string]string(name='headers'),
  body: BatchSetVodDomainConfigsResponseBody(name='body'),
}

/**
  * > This operation is available only in the **China (Shanghai)** region.
  *
 */
async function batchSetVodDomainConfigs(request: BatchSetVodDomainConfigsRequest): BatchSetVodDomainConfigsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'BatchSetVodDomainConfigs', 'POST', '/', 'json', false, 'json', request);
}

model BatchStartVodDomainRequest {
  domainNames: string(name='DomainNames', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model BatchStartVodDomainResponseBody = {
  requestId?: string(name='RequestId', example='15C66C7B-671A-4297-****-2C4477247A74'),
}

model BatchStartVodDomainResponse = {
  headers: map[string]string(name='headers'),
  body: BatchStartVodDomainResponseBody(name='body'),
}

/**
  * The operation that you want to perform. Set the value to **BatchStartVodDomain**.
  *
 */
async function batchStartVodDomain(request: BatchStartVodDomainRequest): BatchStartVodDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'BatchStartVodDomain', 'POST', '/', 'json', false, 'json', request);
}

model BatchStopVodDomainRequest {
  domainNames: string(name='DomainNames', description='The domain name for CDN. Separate multiple domain names with commas (,).', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model BatchStopVodDomainResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='15C66C7B-671A-4297-****-2C4477247A74'),
}

model BatchStopVodDomainResponse = {
  headers: map[string]string(name='headers'),
  body: BatchStopVodDomainResponseBody(name='body'),
}

/**
  * > *   This operation is available only in the **China (Shanghai)** region.
  * > *   After you disable a domain name for CDN, the information about the domain name is retained. The system automatically reroutes all the requests that are destined for the domain name for CDN to the origin server.
  *
 */
async function batchStopVodDomain(request: BatchStopVodDomainRequest): BatchStopVodDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'BatchStopVodDomain', 'POST', '/', 'json', false, 'json', request);
}

model CancelUrlUploadJobsRequest {
  jobIds?: string(name='JobIds', description='The IDs of the upload jobs. You can obtain the job IDs in the response parameter PlayInfo of the [GetPlayInfo](~~56124~~) operation.
*   You can specify a maximum of 10 IDs.
*   Separate multiple IDs with commas (,).
> You must set one of the JobIds and the UploadUrls parameters. If you set both the JobIds and UploadUrls parameters, only the value of the JobIds parameter takes effect.', example='341c92e6c18dc435ee31253685****,0193d395194a83ad6ee2ef27a5b5****', position='Query'),
  uploadUrls?: string(name='UploadUrls', description='The upload URLs of source files. Separate multiple URLs with commas (,). You can specify a maximum of 10 URLs.
> *   You must encode the URLs before you use the URLs.
> *   You must set one of the JobIds and the UploadUrls parameters. If you set both the JobIds and UploadUrls parameters, only the value of the JobIds parameter takes effect.', example='http://www.example.aliyundoc.com/***/video01.mp4,http://www.example.aliyundoc.com/***/video02.mp4', position='Query'),
}

model CancelUrlUploadJobsResponseBody = {
  canceledJobs?: [ string ](name='CanceledJobs', description='The IDs of canceled jobs.'),
  nonExists?: [ string ](name='NonExists', description='The job IDs or upload URLs that do not exist.

If you set the request parameter JobIds, the job IDs that do not exist are returned. If you set the request parameter UploadUrls, the upload URLs that do not exist are returned.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='25818875-5F78-4D5C-3C3D-D7393642****'),
}

model CancelUrlUploadJobsResponse = {
  headers: map[string]string(name='headers'),
  body: CancelUrlUploadJobsResponseBody(name='body'),
}

/**
  * *   You can cancel only a URL-based upload job in the **Pending** state. You can query the status of a URL-based upload job by calling the [GetURLUploadInfos](~~106830~~) operation.
  * *   You cannot cancel an upload job that already starts.
  *
 */
async function cancelUrlUploadJobs(request: CancelUrlUploadJobsRequest): CancelUrlUploadJobsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CancelUrlUploadJobs', 'POST', '/', 'json', false, 'json', request);
}

model CreateAppInfoRequest {
  appName: string(name='AppName', description='Creates an application.', example='test', position='Query'),
  description?: string(name='Description', description='## Common errors

The following table describes the common errors that this operation can return. 

| Error code | Error message | HTTP status code | Description |
| ---------- | ------------- | ---------------- | ----------- |
| OperationDenied.NotOpenAppService | The app service is not open. | 403 | The error message returned because the multi-application service has not been activated. |
| Forbidden.OperateApp | User not authorized to operate app. | 403 | The error message returned because you are not authorized to manage the application. |
| AlreadyExist.AppName | The specified AppName has already exist. | 409 | The error message returned because the name of the application already exists. |
| LimitExceeded.AppCount | App Count has exceeded 10. | 400 | The error message returned because the number of applications that can be created exceeds the upper limit. |', example='myfirstapp', position='Query'),
}

model CreateAppInfoResponseBody = {
  appId?: string(name='AppId', example='app-****'),
  requestId?: string(name='RequestId', example='25818875-5F78-4A13-34D5-D7393642****'),
}

model CreateAppInfoResponse = {
  headers: map[string]string(name='headers'),
  body: CreateAppInfoResponseBody(name='body'),
}

/**
  * The description of the application. 
  * - The description can contain up to 512 characters in length.
  * - The description can contain only UTF-8 characters.
  *
 */
async function createAppInfo(request: CreateAppInfoRequest): CreateAppInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateAppInfo', 'POST', '/', 'json', false, 'json', request);
}

model CreateAuditRequest {
  auditContent: string(name='AuditContent', position='Query'),
}

model CreateAuditResponseBody = {
  requestId?: string(name='RequestId', example='25818875-5F78-4A*****F6-D7393642CA58'),
}

model CreateAuditResponse = {
  headers: map[string]string(name='headers'),
  body: CreateAuditResponseBody(name='body'),
}

async function createAudit(request: CreateAuditRequest): CreateAuditResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateAudit', 'POST', '/', 'json', false, 'json', request);
}

model CreateUploadAttachedMediaRequest {
  appId?: string(name='AppId', description='The ID of the application. Default value: **app-1000000**. For more information, see [Overview](~~113600~~).', example='app-****', position='Query'),
  businessType: string(name='BusinessType', description='The name of the source file.', example='watermark', position='Query'),
  cateIds?: string(name='CateIds', description='The one or more category IDs of the auxiliary media asset. Separate multiple category IDs with commas (,). A maximum of five category IDs can be specified. You can use one of the following methods to obtain the category ID:
*   Log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com). In the left-side navigation pane, choose **Configuration Management** > **Media Management** > **Categories**. On the Categories page, you can view the category ID.
*   View the value of the CateId parameter returned by the [AddCategory](~~56401~~) operation that you called to create a category.
*   View the value of the CateId parameter returned by the [GetCategories](~~56406~~) operation that you called to query a category.', example='1298****,0813****', position='Query'),
  description?: string(name='Description', description='The description of the auxiliary media asset. Take note of the following items:
*   The description can be up to 1,024 bytes in length.
*   The value must be encoded in UTF-8.', example='uploadTest', position='Query'),
  fileName?: string(name='FileName', example='D:\\test.png', position='Query'),
  fileSize?: string(name='FileSize', example='123', position='Query'),
  mediaExt?: string(name='MediaExt', description='The size of the auxiliary media asset. Unit: byte.', example='png', position='Query'),
  storageLocation?: string(name='StorageLocation', description='The storage location. You can use one of the following methods to obtain the storage location:

Log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com). In the left-side navigation pane, choose **Configuration Management** > **Media Management** > **Storage**. On the Storage page, you can view the storage location.
> If this parameter is set to a specific value, the auxiliary media asset is uploaded to the specified storage location.', example='out-****.oss-cn-shanghai.aliyuncs.com', position='Query'),
  tags?: string(name='Tags', description='The one or more tags of the auxiliary media asset. Take note of the following items:
*   You can specify a maximum of 16 tags.
*   If you need to specify multiple tags, separate the tags with commas (,).
*   Each tag can be up to 32 characters in length.
*   The value must be encoded in UTF-8.', example='tag1,tag2', position='Query'),
  title?: string(name='Title', description='The file name extension. Valid values:
*   Valid values for watermarks: **png, gif, apng, and mov**
*   Valid values for subtitles: **srt, ass, stl, ttml, and vtt**
*   Valid values for materials: **jpg, gif, png, mp4, mat, and zip**', position='Query'),
  userData?: string(name='UserData', description='The custom configurations, including callback configurations and upload acceleration configurations. The value is a JSON string. For more information, see the "UserData: specifies the custom configurations for media upload" section of the [Request parameters](~~86952~~) topic.
> *   The callback configurations take effect only after you specify the HTTP callback URL and select the specific callback events in the ApsaraVideo VOD console. For more information about how to configure an HTTP callback in the ApsaraVideo VOD console, see [Configure callback settings](~~86071~~).
> *   To use the upload acceleration feature, submit a [ticket](https://ticket-intl.console.aliyun.com/#/ticket/createIndex) to enable this feature. For more information, see [Overview](~~55396~~).', example='{"MessageCallback":{"CallbackURL":"http://example.aliyundoc.com"},"Extend":{"localId":"xxx","test":"www"}}', position='Query'),
}

model CreateUploadAttachedMediaResponseBody = {
  fileURL?: string(name='FileURL', description='The returned data.', example='https://****.oss-cn-shanghai.aliyuncs.com/watermark/****.mov'),
  mediaId?: string(name='MediaId', example='97dc17a5abc3668489b84ce9****'),
  mediaURL?: string(name='MediaURL', description='The ID of the request.', example='http://example.aliyundoc.com/watermark/****.mov?auth_key=****'),
  requestId?: string(name='RequestId', example='73254DE5-F260-4720-D06856B63C01****'),
  uploadAddress?: string(name='UploadAddress', description='The OSS URL of the file. The URL does not contain the information used for URL signing. You can set the FileUrl parameter to this URL when you call the [AddWatermark](~~98617~~) operation.', example='LWNuLXNoYW5naGFpLmFsaXl1b****'),
  uploadAuth?: string(name='UploadAuth', description='The upload URL.
> The upload URL returned by this operation is Base64-encoded. Before you can use an SDK or an API operation to upload a media asset based on the upload URL, you must decode the upload URL by using the Base64 algorithm. You must parse the upload URL only if you use native OSS SDKs or OSS API for uploads.', example='UzFnUjFxNkZ0NUIZTaklyNWJoQ00zdHF****'),
}

model CreateUploadAttachedMediaResponse = {
  headers: map[string]string(name='headers'),
  body: CreateUploadAttachedMediaResponseBody(name='body'),
}

/**
  * The type of the media asset. Valid values:
  * *   **watermark**
  * *   **subtitle**
  * *   **material**
  *
 */
async function createUploadAttachedMedia(request: CreateUploadAttachedMediaRequest): CreateUploadAttachedMediaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateUploadAttachedMedia', 'POST', '/', 'json', false, 'json', request);
}

model CreateUploadImageRequest {
  appId?: string(name='AppId', example='app-1000000', position='Query'),
  cateId?: long(name='CateId', example='100036****', position='Query'),
  description?: string(name='Description', position='Query'),
  imageExt?: string(name='ImageExt', example='png', position='Query'),
  imageType: string(name='ImageType', example='default', position='Query'),
  originalFileName?: string(name='OriginalFileName', description='图片源文件名称。

> 必须带扩展名，且扩展名不区分大小写。', example='D:\\picture_01.png', position='Query'),
  storageLocation?: string(name='StorageLocation', example='outin-****..oss-cn-shanghai.aliyuncs.com', position='Query'),
  tags?: string(name='Tags', position='Query'),
  title?: string(name='Title', example='mytitle', position='Query'),
  userData?: string(name='UserData', example='{"MessageCallback":{"CallbackURL":"http://example.aliyundoc.com"},"Extend":{"localId":"xxx","test":"www"}}', position='Query'),
}

model CreateUploadImageResponseBody = {
  fileURL?: string(name='FileURL', example='http://example.aliyundoc.com/cover/2017-34DB-4F4C-9373-003AA060****.png'),
  imageId?: string(name='ImageId', example='93ab850b4f6f46e91d24d81d4****'),
  imageURL?: string(name='ImageURL', example='http://example.aliyundoc.com/cover/2017-34DB-4F4C-9373-003AA060****.png'),
  requestId?: string(name='RequestId', example='25818875-5F78-AEF6-D7393642****'),
  uploadAddress?: string(name='UploadAddress', example='eyJTZWN1cmuIjoiQ0FJU3p3TjF****'),
  uploadAuth?: string(name='UploadAuth', example='eyJFbmmRCI6Im****'),
}

model CreateUploadImageResponse = {
  headers: map[string]string(name='headers'),
  body: CreateUploadImageResponseBody(name='body'),
}

/**
  * The custom configurations. For example, you can specify callback configurations and upload acceleration configurations. The value is a JSON string. For more information, see the "UserData: specifies the custom configurations for media upload" section of the [Request parameters](~~86952~~) topic.
  * > *   The callback configurations take effect only after you specify the HTTP callback URL and select specific callback events in the ApsaraVideo VOD console. For more information about how to configure HTTP callback settings in the ApsaraVideo VOD console, see [Configure callback settings](~~86071~~).
  * > *   To use the upload acceleration feature, submit a [ticket](https://ticket-intl.console.aliyun.com/#/ticket/createIndex) to enable this feature. For more information, see [Overview](~~55396~~).
  *
 */
async function createUploadImage(request: CreateUploadImageRequest): CreateUploadImageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateUploadImage', 'POST', '/', 'json', false, 'json', request);
}

model CreateUploadVideoRequest {
  appId?: string(name='AppId', example='app-1000000', position='Query'),
  cateId?: long(name='CateId', example='100036****', position='Query'),
  coverURL?: string(name='CoverURL', example='https://example.aliyundoc.com/image/D22F553TEST****.jpeg', position='Query'),
  description?: string(name='Description', example='UploadTest', position='Query'),
  fileName: string(name='FileName', example='D:\\video_01.mp4', position='Query'),
  fileSize?: long(name='FileSize', example='123', position='Query'),
  storageLocation?: string(name='StorageLocation', example='out-****.oss-cn-shanghai.aliyuncs.com', position='Query'),
  tags?: string(name='Tags', example='tag1,tag2', position='Query'),
  templateGroupId?: string(name='TemplateGroupId', example='405477f9e214d19ea2c7c854****', position='Query'),
  title: string(name='Title', example='UploadTest', position='Query'),
  userData?: string(name='UserData', example='{"MessageCallback":{"CallbackURL":"http://example.aliyundoc.com"},"Extend":{"localId":"*****","test":"www"}}', position='Query'),
  workflowId?: string(name='WorkflowId', example='613efff3887ec34af685714cc461****', position='Query'),
}

model CreateUploadVideoResponseBody = {
  requestId?: string(name='RequestId', example='25818875-5F78-4AF6-04D5-D7393642****'),
  uploadAddress?: string(name='UploadAddress', example='eyJTZWN1cml0a2VuIjoiQ0FJU3p3TjF****'),
  uploadAuth?: string(name='UploadAuth', example='eyJFbmRwb2ludCI6Imm****'),
  videoId?: string(name='VideoId', example='93ab850b4f6f54b6e91d24d81d44****'),
}

model CreateUploadVideoResponse = {
  headers: map[string]string(name='headers'),
  body: CreateUploadVideoResponseBody(name='body'),
}

/**
  * Obtains the upload URLs and credentials for media files and creates media assets in ApsaraVideo VOD.
  *
 */
async function createUploadVideo(request: CreateUploadVideoRequest): CreateUploadVideoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateUploadVideo', 'POST', '/', 'json', false, 'json', request);
}

model DecryptKMSDataKeyRequest {
  cipherText: string(name='CipherText', description='待解密的密文。', example='DZhOWVmZDktM2QxNi00ODk0LWJkNGYtMWZjNDNmM2YyYWJmaaSl+TztSIMe43nbTH/Z1Wr4XfLftKhAciUmDQXuMRl4WTvKhxjMThjK****', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: string(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: string(name='ResourceOwnerId', position='Query'),
}

model DecryptKMSDataKeyResponseBody = {
  keyId?: string(name='KeyId', example='202b9877-5a25-46e3-a763-e20791b5****'),
  plaintext?: string(name='Plaintext', example='tRYXuCwgja12xxO1N/gZERDDCLw9doZEQiPDk/Bv****'),
  requestId?: string(name='RequestId', example='25818875-5F78-4A*****F6-D7393642CA58'),
}

model DecryptKMSDataKeyResponse = {
  headers: map[string]string(name='headers'),
  body: DecryptKMSDataKeyResponseBody(name='body'),
}

async function decryptKMSDataKey(request: DecryptKMSDataKeyRequest): DecryptKMSDataKeyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DecryptKMSDataKey', 'POST', '/', 'json', false, 'json', request);
}

model DeleteAIImageInfosRequest {
  AIImageInfoIds: string(name='AIImageInfoIds', description='The IDs of the images that are submitted for AI processing. You can obtain the value of AIImageInfoId from the response to the [ListAIImageInfo](~~ListAIImageInfo~~) operation.

- You can specify a maximum of 10 IDs.
- Separate multiple IDs with commas (,).', example='b89a6aabf144*****6197ebd6fe6cf29', position='Query'),
}

model DeleteAIImageInfosResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='FCDC80EA-363C-41*****B8-0DF14033D643'),
}

model DeleteAIImageInfosResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAIImageInfosResponseBody(name='body'),
}

/**
  * This operation deletes only information about images that are submitted for AI processing. The image files are not deleted.
  * - The smart thumbnail feature is not supported. You cannot call this operation.
  * - This operation deletes only information about images that are submitted for AI processing. The image files are not deleted.
  * ### QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits on API operations in ApsaraVideo VoD](~~342790~~).
  *
 */
async function deleteAIImageInfos(request: DeleteAIImageInfosRequest): DeleteAIImageInfosResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteAIImageInfos', 'POST', '/', 'json', false, 'json', request);
}

model DeleteAITemplateRequest {
  templateId: string(name='TemplateId', description='The operation that you want to perform. Set the value to **DeleteAITemplate**.', example='1706a0063dd733f6a823ef32e0a5****', position='Query'),
}

model DeleteAITemplateResponseBody = {
  requestId?: string(name='RequestId', example='25818875-5F78-4A13-BEF6-****'),
  templateId?: string(name='TemplateId', example='1706a0063dd733f6a823ef32e0a5****'),
}

model DeleteAITemplateResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAITemplateResponseBody(name='body'),
}

/**
  * The ID of the AI template. You can use one of the following methods to obtain the ID of the AI template:
  * *   Call the [AddAITemplate](~~102930~~) operation to add an AI template if no AI template exists. The value of TemplateId from the response is the ID of the AI template.
  * *   Call the [ListAITemplate](~~102936~~) operation if the template already exists. The value of TemplateId from the response is the ID of the AI template.
  *
 */
async function deleteAITemplate(request: DeleteAITemplateRequest): DeleteAITemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteAITemplate', 'POST', '/', 'json', false, 'json', request);
}

model DeleteAppInfoRequest {
  appId: string(name='AppId', example='app-****', position='Query'),
}

model DeleteAppInfoResponseBody = {
  requestId?: string(name='RequestId', example='25818875-5F78-4A13-BEF6-****'),
}

model DeleteAppInfoResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAppInfoResponseBody(name='body'),
}

/**
  * The ID of the request.
  *
 */
async function deleteAppInfo(request: DeleteAppInfoRequest): DeleteAppInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteAppInfo', 'POST', '/', 'json', false, 'json', request);
}

model DeleteAttachedMediaRequest {
  mediaIds?: string(name='MediaIds', description='Deletes one or more auxiliary media assets at a time.', example='8bc8e94fe4e55abde85718****,eb186180e989dd56****', position='Query'),
}

model DeleteAttachedMediaResponseBody = {
  nonExistMediaIds?: [ string ](name='NonExistMediaIds'),
  requestId?: string(name='RequestId', example='25818875-5F78-4AF6-D7393642CA58****'),
}

model DeleteAttachedMediaResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAttachedMediaResponseBody(name='body'),
}

/**
  * The ID of the request.
  *
 */
async function deleteAttachedMedia(request: DeleteAttachedMediaRequest): DeleteAttachedMediaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteAttachedMedia', 'POST', '/', 'json', false, 'json', request);
}

model DeleteCategoryRequest {
  cateId: long(name='CateId', description='The ID of the category.', example='3300****', position='Query'),
}

model DeleteCategoryResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='25818875-5F78-4AF6-D7393642CA58****'),
}

model DeleteCategoryResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteCategoryResponseBody(name='body'),
}

/**
  * > If a video category is deleted, its subcategories, including level 2 and level 3 categories, are also deleted. Exercise caution when you call this operation.
  *
 */
async function deleteCategory(request: DeleteCategoryRequest): DeleteCategoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteCategory', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDynamicImageRequest {
  dynamicImageIds?: string(name='DynamicImageIds', example='beafec3834a4e52ea52042a4****,8281c8519847fd8970e79e80b6****', position='Query'),
  videoId: string(name='VideoId', example='2321077d460b028700ef6c2f4d****', position='Query'),
}

model DeleteDynamicImageResponseBody = {
  requestId?: string(name='RequestId', example='0C8F0FDD-A99F-4188-B41934C97A54****'),
}

model DeleteDynamicImageResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDynamicImageResponseBody(name='body'),
}

async function deleteDynamicImage(request: DeleteDynamicImageRequest): DeleteDynamicImageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDynamicImage', 'POST', '/', 'json', false, 'json', request);
}

model DeleteEditingProjectRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: string(name='OwnerId', position='Query'),
  projectIds: string(name='ProjectIds', example='fb2101bf24bf41*****cb318787dc', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: string(name='ResourceOwnerId', position='Query'),
}

model DeleteEditingProjectResponseBody = {
  requestId?: string(name='RequestId', example='25818875-5F78-4A*****F6-D7393642CA58'),
}

model DeleteEditingProjectResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteEditingProjectResponseBody(name='body'),
}

async function deleteEditingProject(request: DeleteEditingProjectRequest): DeleteEditingProjectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteEditingProject', 'POST', '/', 'json', false, 'json', request);
}

model DeleteImageRequest {
  deleteImageType: string(name='DeleteImageType', description='The ID of the request.', example='VideoId', position='Query'),
  imageIds?: string(name='ImageIds', description='The type of the image. This parameter only takes effect when the **DeleteImageType** parameter is set to **VideoId**. In this case, you must set this parameter. Valid values:

*   **CoverSnapshot**: thumbnail snapshot.
*   **NormalSnapshot**: normal snapshot.
*   **SpriteSnapshot**: sprite snapshot.
*   **SpriteOriginSnapshot**: sprite source snapshot.
*   **All**: images of all the preceding types. If this parameter is not set to All, you can specify multiple types and separate them with commas (,).', example='bbc65bba53fed90de118a7849****,594228cdd14b4d069fc17a8c4a****', position='Query'),
  imageType?: string(name='ImageType', example='All', position='Query'),
  imageURLs?: string(name='ImageURLs', description='The operation that you want to perform. Set the value to **DeleteImage**.', example='https://example.aliyundoc.com/image/default/41AE7ADABBE*****.png', position='Query'),
  videoId?: string(name='VideoId', description='Deletes uploaded images and automatic snapshots of videos.', example='eb1861d2c9a8842340e989dd56****', position='Query'),
}

model DeleteImageResponseBody = {
  requestId?: string(name='RequestId', example='25818875-5F78-4AF6-D7393642CA58****'),
}

model DeleteImageResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteImageResponseBody(name='body'),
}

/**
  * The URL of the image.
  * *   This parameter only takes effect when the **DeleteImageType** parameter is set to **ImageURL**. In this case, you must set this parameter.
  * *   Encode multiple image URLs and separate them with commas (,).
  * *   The use of special characters in image URLs may lead to the failure to delete the images. To prevent such failure, you must encode the image URLs before you concatenate them into a string with commas (,).
  *
 */
async function deleteImage(request: DeleteImageRequest): DeleteImageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteImage', 'POST', '/', 'json', false, 'json', request);
}

model DeleteMessageCallbackRequest {
  appId?: string(name='AppId', description='The ID of the application. If you do not set this parameter, the default value **app-1000000** is used.', example='app-1000000', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
}

model DeleteMessageCallbackResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='25818875-5F78-4A13-****-D7393642CA58'),
}

model DeleteMessageCallbackResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteMessageCallbackResponseBody(name='body'),
}

/**
  * > For more information, see [Overview](~~55627~~).
  *
 */
async function deleteMessageCallback(request: DeleteMessageCallbackRequest): DeleteMessageCallbackResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteMessageCallback', 'POST', '/', 'json', false, 'json', request);
}

model DeleteMezzaninesRequest {
  force?: boolean(name='Force', description='Deletes one or more mezzanine files at a time.', example='false', position='Query'),
  videoIds: string(name='VideoIds', description='The operation that you want to perform. Set the value to **DeleteMezzanines**.', example='23ab850b4f654b6e91d24d8157****,93ab850b4f6f4b6e91d24d81d4****', position='Query'),
}

model DeleteMezzaninesResponseBody = {
  nonExistVideoIds?: [ string ](name='NonExistVideoIds'),
  requestId?: string(name='RequestId', example='25818875-5F78-4AF6-D7393642CA58****'),
  unRemoveableVideoIds?: [ string ](name='UnRemoveableVideoIds'),
}

model DeleteMezzaninesResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteMezzaninesResponseBody(name='body'),
}

/**
  * The IDs of the videos that do not exist.
  *
 */
async function deleteMezzanines(request: DeleteMezzaninesRequest): DeleteMezzaninesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteMezzanines', 'POST', '/', 'json', false, 'json', request);
}

model DeleteMultipartUploadRequest {
  mediaId: string(name='MediaId', description='The ID of the media file, namely, the audio or video ID. You can use one of the following methods to obtain the audio or video ID:
* Log on to the [ApsaraVideo VOD](https://vod.console.aliyun.com) console. In the left-side navigation pane, choose **Media Files** > **Audio/Video**. On the Video and Audio page, you can view the audio or video ID. Use this method if the audio or video file is uploaded by using the ApsaraVideo VOD console.
* View the value of the VideoId parameter returned by the [CreateUploadVideo](~~55407~~) operation that you called to obtain an upload URL and credential.
* View the value of the VideoId parameter returned by the [SearchMedia](~~86044~~) operation that you called to query an audio or video ID after the audio or video file is uploaded.', example='61ccbdb06fa3012be4d8083f6****', position='Query'),
  mediaType: string(name='MediaType', description='The type of the media file. Set the value to **video**, which indicates audio and video files.', example='video', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
}

model DeleteMultipartUploadResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='25818875-5F78-4AF6-D7393642CA58****'),
}

model DeleteMultipartUploadResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteMultipartUploadResponseBody(name='body'),
}

/**
  * * In a multipart upload, fragments may be generated if the upload fails. In most cases, the fragments are automatically deleted after seven days. You can call this operation to delete the generated fragments after the upload is successful or fails.
  * * This operation does not delete the source file or transcoded file, but deletes only the fragments generated during the upload.
  * * If you call the [DeleteVideo](~~52837~~) operation, the entire video file is deleted, including the generated fragments.
  *
 */
async function deleteMultipartUpload(request: DeleteMultipartUploadRequest): DeleteMultipartUploadResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteMultipartUpload', 'POST', '/', 'json', false, 'json', request);
}

model DeleteStreamRequest {
  jobIds: string(name='JobIds', description='Deletes one or more video or audio streams and their storage files at a time.', example='35eb4dbda18c49cc0025df374b46****', position='Query'),
  videoId: string(name='VideoId', example='95948ddba24446b6aed5db985e78****', position='Query'),
}

model DeleteStreamResponseBody = {
  requestId?: string(name='RequestId', example='25818875-5F78-4A7U43F6-D7393642****'),
}

model DeleteStreamResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteStreamResponseBody(name='body'),
}

async function deleteStream(request: DeleteStreamRequest): DeleteStreamResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteStream', 'POST', '/', 'json', false, 'json', request);
}

model DeleteTranscodeTemplateGroupRequest {
  forceDelGroup?: string(name='ForceDelGroup', description='Specifies whether to forcibly delete the entire transcoding template group. Valid values:

*   **true**: deletes the entire transcoding template group and its transcoding templates.
*   **false**: removes the specified transcoding templates from the transcoding template group. This is the default value.', example='true', position='Query'),
  transcodeTemplateGroupId: string(name='TranscodeTemplateGroupId', description='The ID of the transcoding template group.', example='4c71a339fec*****152b4fa6f4527', position='Query'),
  transcodeTemplateIds?: string(name='TranscodeTemplateIds', description='The IDs of the transcoding templates that you want to remove.

*   Separate multiple IDs with commas (,).
*   You can specify a maximum of 10 IDs.', example='["613702defdc4*****6a3b94cace1129e","bfd6c90253a2*****7fc054d7c5825"]', position='Query'),
}

model DeleteTranscodeTemplateGroupResponseBody = {
  nonExistTranscodeTemplateIds?: [ string ](name='NonExistTranscodeTemplateIds', description='The IDs of transcoding templates that were not found when the system removed transcoding templates based on the IDs.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='25818875-5F78-4A*****F6-D7393642CA58'),
}

model DeleteTranscodeTemplateGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteTranscodeTemplateGroupResponseBody(name='body'),
}

/**
  * *   You cannot remove the default transcoding template. You can remove it only after it is no longer specified as the default.
  * *   For security purposes, you cannot add, modify, or remove transcoding templates in a transcoding template group that is locked in the ApsaraVideo VOD console. To manage such transcoding template groups, contact the ApsaraVideo VOD technical support.
  * *   You can call the GetTranscodeTemplateGroup operation to query the configurations of a transcoding template group and check whether the transcoding template group is locked by using the response parameter Locked.
  *
 */
async function deleteTranscodeTemplateGroup(request: DeleteTranscodeTemplateGroupRequest): DeleteTranscodeTemplateGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteTranscodeTemplateGroup', 'POST', '/', 'json', false, 'json', request);
}

model DeleteVideoRequest {
  videoIds: string(name='VideoIds', description='The list of video IDs. Separate multiple IDs with commas (,). A maximum of 20 IDs can be specified. You can obtain a video ID in one of the following ways:

*   If the video is uploaded by using the [ApsaraVideo VOD console](https://vod.console.aliyun.com), log on to the console and choose **Media Files** > **Audio/Video** to view the ID of the video.
*   If the video is uploaded by calling the [CreateUploadVideo](~~55407~~) operation, the video ID is the VideoId value in the response.
*   You can also call the [SearchMedia](~~86044~~) operation to obtain the video ID, which is the VideoId value in the response.', example='e44ebf1147hdsa2d2adbea8b****,e44ebf11oj984adbea8****,73ab850b4f6f4b6e91d24d81d54****', position='Query'),
}

model DeleteVideoResponseBody = {
  forbiddenVideoIds?: [ string ](name='ForbiddenVideoIds', description='The IDs of the videos that cannot be deleted.
> Generally, videos cannot be deleted if you do not have the required [permissions](~~113600~~).'),
  nonExistVideoIds?: [ string ](name='NonExistVideoIds', description='The IDs of the videos that do not exist.
> If the list of videos to be deleted contains one or more videos that do not exist, the IDs of these non-existing videos are returned. If none of the videos in the list exists, a 404 error is returned.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='E4EBD2BF-5EB0-4476-8829-9D94E1B1****'),
}

model DeleteVideoResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVideoResponseBody(name='body'),
}

/**
  * *   This operation physically deletes videos. Deleted videos cannot be recovered. Exercise caution when you call this operation.
  * *   You can call this operation to delete multiple videos at a time.
  * *   When you delete a video, its source file, transcoded stream file, and thumbnail screenshot are also deleted. However, the Alibaba Cloud Content Delivery Network (CDN) cache is not refreshed simultaneously. You can use the refresh feature in the ApsaraVideo VOD console to clear garbage data on CDN nodes. For more information, see [Refresh and prefetch](~~86098~~).
  *
 */
async function deleteVideo(request: DeleteVideoRequest): DeleteVideoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteVideo', 'POST', '/', 'json', false, 'json', request);
}

model DeleteVodDomainRequest {
  domainName: string(name='DomainName', example='example.com', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DeleteVodDomainResponseBody = {
  requestId?: string(name='RequestId', example='15C66C7B-671A-4297-****-2C4477247A74'),
}

model DeleteVodDomainResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVodDomainResponseBody(name='body'),
}

/**
  * The ID of the request.
  *
 */
async function deleteVodDomain(request: DeleteVodDomainRequest): DeleteVodDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteVodDomain', 'POST', '/', 'json', false, 'json', request);
}

model DeleteVodSpecificConfigRequest {
  configId: string(name='ConfigId', example='2317****', position='Query'),
  domainName: string(name='DomainName', description='Deletes the configurations of a domain name for CDN.', example='www.example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DeleteVodSpecificConfigResponseBody = {
  requestId?: string(name='RequestId', example='04F0F334-1335-436C-****-6C044FE73368'),
}

model DeleteVodSpecificConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVodSpecificConfigResponseBody(name='body'),
}

/**
  * The ID of the request.
  *
 */
async function deleteVodSpecificConfig(request: DeleteVodSpecificConfigRequest): DeleteVodSpecificConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteVodSpecificConfig', 'POST', '/', 'json', false, 'json', request);
}

model DeleteVodTemplateRequest {
  vodTemplateId: string(name='VodTemplateId', description='Deletes a snapshot template.', example='f5b228fe6930e*****d6bf55bd87789', position='Query'),
}

model DeleteVodTemplateResponseBody = {
  requestId?: string(name='RequestId', example='25818875-5F78-4A*****F6-D7393642CA58'),
  vodTemplateId?: string(name='VodTemplateId', example='f5b228fe6930e*****d6bf55bd87789'),
}

model DeleteVodTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVodTemplateResponseBody(name='body'),
}

async function deleteVodTemplate(request: DeleteVodTemplateRequest): DeleteVodTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteVodTemplate', 'POST', '/', 'json', false, 'json', request);
}

model DeleteWatermarkRequest {
  watermarkId: string(name='WatermarkId', example='9bcc8bfadb843f*****09a2671d0df97', position='Query'),
}

model DeleteWatermarkResponseBody = {
  requestId?: string(name='RequestId', example='25818875-5F78-4A*****F6-D7393642CA58'),
}

model DeleteWatermarkResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteWatermarkResponseBody(name='body'),
}

/**
  * The ID of the request.
  *
 */
async function deleteWatermark(request: DeleteWatermarkRequest): DeleteWatermarkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteWatermark', 'POST', '/', 'json', false, 'json', request);
}

model DescribePlayTopVideosRequest {
  bizDate: string(name='BizDate', description='The page number of the returned page.', example='2016-06-29T13:00:00Z', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNo?: long(name='PageNo', description='The operation that you want to perform. Set the value to **DescribePlayTopVideos**.', example='1', position='Query'),
  pageSize?: long(name='PageSize', description='The time to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.', example='100', minimum=10, maximum=1000, position='Query'),
}

model DescribePlayTopVideosResponseBody = {
  pageNo?: long(name='PageNo', description='The playback duration. Unit: milliseconds.', example='1'),
  pageSize?: long(name='PageSize', description='The total number of entries that were collected in playback statistics on top videos.', example='100'),
  requestId?: string(name='RequestId', description='The number of unique visitors.', example='4B0BCF9F-2FD5-4817-****-7BEBBE3AF90B"'),
  topPlayVideos?: {
    topPlayVideoStatis?: [ 
    {
      playDuration?: string(name='PlayDuration', example='4640369'),
      title?: string(name='Title', description='The number of entries returned per page.', example='The ID of the request.'),
      uv?: string(name='UV', example='1'),
      vv?: string(name='VV', description='Queries daily playback statistics on top videos, including video views, unique visitors, and total playback duration.', example='107'),
      videoId?: string(name='VideoId', example='2a8d4cb9ecbb487681473a15****8fda'),
    }
  ](name='TopPlayVideoStatis')
  }(name='TopPlayVideos', description='The ID of the video.'),
  totalNum?: long(name='TotalNum', description='The number of video views.', example='2'),
}

model DescribePlayTopVideosResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePlayTopVideosResponseBody(name='body'),
}

/**
  * The number of entries to return on each page. Default value: **100**. Maximum value: **1000**.
  *
 */
async function describePlayTopVideos(request: DescribePlayTopVideosRequest): DescribePlayTopVideosResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePlayTopVideos', 'POST', '/', 'json', false, 'json', request);
}

model DescribePlayUserAvgRequest {
  endTime: string(name='EndTime', description='The date when the statistics were generated. The date follows the *yyyy-MM-dd* format.', example='2016-06-30T13:00:00Z', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  startTime: string(name='StartTime', description='The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.', example='2016-06-29T13:00:00Z', position='Query'),
}

model DescribePlayUserAvgResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6C7F90B2-BDA4-4FAC-****-A38A121DFE19'),
  userPlayStatisAvgs?: {
    userPlayStatisAvg?: [ 
    {
      avgPlayCount?: string(name='AvgPlayCount', example='170'),
      avgPlayDuration?: string(name='AvgPlayDuration', example='1035902.8'),
      date?: string(name='Date', description='Queries the statistics on average playback each day in a specified time range.', example='20170120'),
    }
  ](name='UserPlayStatisAvg')
  }(name='UserPlayStatisAvgs', description='The operation that you want to perform. Set the value to **DescribePlayUserAvg**.'),
}

model DescribePlayUserAvgResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePlayUserAvgResponseBody(name='body'),
}

/**
  * The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
  *
 */
async function describePlayUserAvg(request: DescribePlayUserAvgRequest): DescribePlayUserAvgResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePlayUserAvg', 'POST', '/', 'json', false, 'json', request);
}

model DescribePlayUserTotalRequest {
  endTime: string(name='EndTime', description='The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.', example='2016-06-30T13:00:00Z', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  startTime: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.', example='2016-06-29T13:00:00Z', position='Query'),
}

model DescribePlayUserTotalResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='1FAFB884-D5A7-47D1-****-8928AA9C8720'),
  userPlayStatisTotals?: {
    userPlayStatisTotal?: [ 
    {
      date?: string(name='Date', description='The date when the statistics were generated. The date follows the *yyyy-MM-dd* format.', example='20170120'),
      playDuration?: string(name='PlayDuration', description='The total playback duration. Unit: milliseconds.', example='9340070'),
      playRange?: string(name='PlayRange', description='The distribution of the playback duration.', example='"<=1m:74.3%;>1<=5m:22.8%;>5<=10m:1.0%;>10<=15m:1.0%;>15<=30m:1.0%"'),
      uv?: {
        android?: string(name='Android', description='The total number of unique visitors who use ApsaraVideo Player SDK for Android.', example='2'),
        flash?: string(name='Flash', description='The total number of unique visitors who use ApsaraVideo Player SDK for Flash.', example='1'),
        HTML5?: string(name='HTML5', description='The total number of unique visitors who use ApsaraVideo Player SDK for HTML5.', example='1'),
        iOS?: string(name='iOS', description='The total number of unique visitors who use ApsaraVideo Player SDK for iOS.', example='0'),
      }(name='UV', description='The total number of unique visitors.'),
      vv?: {
        android?: string(name='Android', description='The total number of video views that is collected for videos that are played by using ApsaraVideo Player SDK for Android.', example='161'),
        flash?: string(name='Flash', description='The total number of video views that is collected for videos that are played by using ApsaraVideo Player SDK for Flash.', example='2'),
        HTML5?: string(name='HTML5', description='The total number of video views that is collected for videos that are played by using ApsaraVideo Player SDK for HTML5.', example='2'),
        iOS?: string(name='iOS', description='The total number of video views that is collected for videos that are played by using ApsaraVideo Player SDK for iOS.', example='0'),
      }(name='VV', description='The total number of video views.'),
    }
  ](name='UserPlayStatisTotal')
  }(name='UserPlayStatisTotals', description='The statistics on total playback each day.'),
}

model DescribePlayUserTotalResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePlayUserTotalResponseBody(name='body'),
}

/**
  * > *   This operation is available only in the **China (Shanghai)** region.
  * > *   You can call this operation to query only playback statistics collected on videos that are played by using ApsaraVideo Player SDKs.
  * > *   Playback statistics for the previous day are generated at 09:00 on the current day, in UTC+8.
  * > *   You can query data that is generated since January 1, 2018. The maximum time range to query is 180 days.
  *
 */
async function describePlayUserTotal(request: DescribePlayUserTotalRequest): DescribePlayUserTotalResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePlayUserTotal', 'POST', '/', 'json', false, 'json', request);
}

model DescribePlayVideoStatisRequest {
  endTime: string(name='EndTime', description='The number of video views.', example='2016-06-30T13:00:00Z', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  startTime: string(name='StartTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.', example='2016-06-29T13:00:00Z', position='Query'),
  videoId: string(name='VideoId', description='The date when the statistics were generated. The date follows the *yyyy-MM-dd* format.', example='2a8d4cb9ecbb487681473****aba8fda', position='Query'),
}

model DescribePlayVideoStatisResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the video.', example='A92D3600-A3E7-43D6-****-B6E3B4A1FE6B'),
  videoPlayStatisDetails?: {
    videoPlayStatisDetail?: [ 
    {
      date?: string(name='Date', description='The ID of the request.', example='20170120'),
      playDuration?: string(name='PlayDuration', description='The title of the video.', example='967277'),
      playRange?: string(name='PlayRange', example='<=1m:79.2%;>1<=5m:16.7%;>5<=10m:4.2%'),
      title?: string(name='Title', description='Queries daily playback statistics on a specified video in a specified time range.'),
      uv?: string(name='UV', example='1'),
      vv?: string(name='VV', description='The operation that you want to perform. Set the value to **DescribePlayVideoStatis**.', example='24'),
    }
  ](name='VideoPlayStatisDetail')
  }(name='VideoPlayStatisDetails', description='The number of unique visitors.'),
}

model DescribePlayVideoStatisResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePlayVideoStatisResponseBody(name='body'),
}

/**
  * The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
  *
 */
async function describePlayVideoStatis(request: DescribePlayVideoStatisRequest): DescribePlayVideoStatisResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePlayVideoStatis', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVodAIDataRequest {
  AIType?: string(name='AIType', description='The type of video AI. If you leave this parameter empty, statistics on video AI of all types are returned. Separate multiple types with commas (,). Valid values:

*   **AIVideoCensor**: automated review
*   **AIVideoFPShot**: media fingerprinting
*   **AIVideoTag**: smart tagging', example='AIVideoCensor', position='Query'),
  endTime: string(name='EndTime', description='The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format. The time must be in UTC.', example='2019-02-01T15:00:00Z', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  region?: string(name='Region', description='The region in which you want to query data. If you leave this parameter empty, data in all regions is returned. Separate multiple regions with commas (,). Valid values:

*   **cn-shanghai**: China (Shanghai)
*   **cn-beijing**: China (Beijing)
*   **eu-central-1**: Germany (Frankfurt)
*   **ap-southeast-1**: Singapore', example='cn-beijing', position='Query'),
  startTime: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format. The time must be in UTC.', example='2019-02-01T13:00:00Z', position='Query'),
}

model DescribeVodAIDataResponseBody = {
  AIData?: {
    AIDataItem?: [ 
    {
      data?: {
        dataItem?: [ 
        {
          name?: string(name='Name', description='The type of video AI. Valid values:

*   **AIVideoCensor**: automated review
*   **AIVideoFPShot**: media fingerprinting
*   **AIVideoTag**: smart tagging', example='AIVideoCensor'),
          value?: string(name='Value', description='The processing duration. Unit: seconds.', example='111'),
        }
      ](name='DataItem')
      }(name='Data', description='The statistics on video AI of each type.'),
      timeStamp?: string(name='TimeStamp', description='The timestamp of the returned data. The time follows the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.', example='2019-02-01T13:00:00Z'),
    }
  ](name='AIDataItem')
  }(name='AIData', description='The statistics on video AI.'),
  dataInterval?: string(name='DataInterval', description='The time granularity at which the data was queried. Valid values:

*   **hour**
*   **day**', example='day'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='C370DAF1-C838-4288-****-9A87633D248E'),
}

model DescribeVodAIDataResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVodAIDataResponseBody(name='body'),
}

/**
  * > *   This operation is available only in the **China (Shanghai)** region.
  * >*   If the time range to query is less than or equal to seven days, the system returns the statistics collected on an hourly basis. If the time range to query is greater than seven days, the system returns the statistics collected on a daily basis. The maximum time range that you can specify to query is 31 days.
  *
 */
async function describeVodAIData(request: DescribeVodAIDataRequest): DescribeVodAIDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVodAIData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVodCertificateListRequest {
  domainName?: string(name='DomainName', description='certificate', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DescribeVodCertificateListResponseBody = {
  certificateListModel?: {
    certList?: {
      cert?: [ 
      {
        certId?: long(name='CertId', example='235437'),
        certName?: string(name='CertName', description='The operation that you want to perform. Set the value to **DescribeVodCertificateList**.', example='The information about the returned certificates.'),
        common?: string(name='Common', example='test'),
        fingerprint?: string(name='Fingerprint', description='The ID of the request.', example='****'),
        issuer?: string(name='Issuer', description='Queries the certificates of a specified domain name for CDN or all the domain names for CDN within your Alibaba Cloud account.', example='****'),
        lastTime?: long(name='LastTime', description='The details of each certificate.', example='1512388610'),
      }
    ](name='Cert')
    }(name='CertList', description='The ID of the certificate.'),
    count?: int32(name='Count', description='The number of certificates.', example='2'),
  }(name='CertificateListModel', description='The common name of the certificate.'),
  requestId?: string(name='RequestId', description='The certificate authority (CA) that issued the certificate.', example='FC0E34AC-0239-44A7-****-800DE522C8DA'),
}

model DescribeVodCertificateListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVodCertificateListResponseBody(name='body'),
}

/**
  * The domain name for CDN.
  *
 */
async function describeVodCertificateList(request: DescribeVodCertificateListRequest): DescribeVodCertificateListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVodCertificateList', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVodDomainBpsDataRequest {
  domainName?: string(name='DomainName', description='The domain name to be queried. If you do not specify this parameter, the merged data of all your domain names for CDN is returned. You can specify multiple domain names. Separate them with commas (,).', example='example.com', position='Query'),
  endTime?: string(name='EndTime', description='The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.', example='2015-12-10T14:00:00Z', position='Query'),
  interval?: string(name='Interval', description='The query interval. Unit: seconds. Valid values: **300**, **3600**, and **86400**.

*   If the time range to query is less than 3 days, valid values are **300**, **3600**, and **86400**. The default value is 300.
*   If the time range to query is from 3 to less than 31 days, valid values are **3600** and **86400**. The default value is 3600.
*   If the time range to query is from 31 to 90 days, the valid value is **86400**.', example='300', position='Query'),
  ispNameEn?: string(name='IspNameEn', description='The name of the Internet service provider (ISP). If you do not specify this parameter, the data of all ISPs is returned.', example='Alibaba', position='Query'),
  locationNameEn?: string(name='LocationNameEn', description='The name of the region. If you do not specify this parameter, the data in all regions is returned. Only data in the China (Shanghai) region can be queried.', example='cn-shanghai', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.

> The minimum query interval is 5 minutes. If you do not specify this parameter, the data in the last 24 hours is queried.', example='2015-12-10T13:00:00Z', position='Query'),
}

model DescribeVodDomainBpsDataResponseBody = {
  bpsDataPerInterval?: {
    dataModule?: [ 
    {
      domesticValue?: string(name='DomesticValue', description='The bandwidth in mainland China. Unit: bit/s. When the bandwidth data is queried by ISP, no value is returned.', example='11286111'),
      httpsDomesticValue?: string(name='HttpsDomesticValue', description='The HTTPS bandwidth on L1 nodes in mainland China. Unit: bit/s. When the bandwidth data is queried by ISP, no value is returned.', example='11286111'),
      httpsOverseasValue?: string(name='HttpsOverseasValue', description='The HTTPS bandwidth on L1 nodes outside mainland China. Unit: bit/s. When the bandwidth data is queried by ISP, no value is returned.', example='2000'),
      httpsValue?: string(name='HttpsValue', description='The total HTTPS bandwidth on L1 nodes. Unit: bit/s.', example='11288111'),
      overseasValue?: string(name='OverseasValue', description='The bandwidth outside mainland China. Unit: bit/s. When the bandwidth data is queried by ISP, no value is returned.', example='2000'),
      timeStamp?: string(name='TimeStamp', description='The timestamp of the returned data. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.', example='2015-12-10T13:00:00Z'),
      value?: string(name='Value', description='The bandwidth. Unit: bit/s.', example='11288111'),
    }
  ](name='DataModule')
  }(name='BpsDataPerInterval', description='The bandwidth data that is collected for each interval.'),
  dataInterval?: string(name='DataInterval', description='The time interval between the returned entries. Unit: seconds.', example='300'),
  domainName?: string(name='DomainName', description='The domain name for CDN.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range in which data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2015-12-10T14:00:00Z'),
  ispNameEn?: string(name='IspNameEn', description='The name of the ISP. By default, the data of all ISPs is returned.', example='Alibaba'),
  locationNameEn?: string(name='LocationNameEn', description='The name of the region. By default, the data in all regions is returned.', example='cn-shanghai'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='3C6CCEC4-6B88-4D4A-****-D47B3D92CF8F'),
  startTime?: string(name='StartTime', description='The beginning of the time range in which data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2015-12-10T13:00:00Z'),
}

model DescribeVodDomainBpsDataResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVodDomainBpsDataResponseBody(name='body'),
}

/**
  * If you specify neither the StartTime parameter nor the EndTime parameter, the data in the last 24 hours is queried. Alternatively, you can specify both the StartTime and EndTime parameters to query data that is generated in the specified duration. You can query data for the last 90 days at most.
  *
 */
async function describeVodDomainBpsData(request: DescribeVodDomainBpsDataRequest): DescribeVodDomainBpsDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVodDomainBpsData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVodDomainCertificateInfoRequest {
  domainName: string(name='DomainName', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
}

model DescribeVodDomainCertificateInfoResponseBody = {
  certInfos?: {
    certInfo?: [ 
    {
      certDomainName?: string(name='CertDomainName', example='example.com'),
      certExpireTime?: string(name='CertExpireTime', example='2018-06-03T13:03:39Z'),
      certLife?: string(name='CertLife', example='3 months'),
      certName?: string(name='CertName', example='cert-example.com'),
      certOrg?: string(name='CertOrg', example='Let\\"s Encrypt'),
      certType?: string(name='CertType', example='free'),
      domainName?: string(name='DomainName', example='example.com'),
      serverCertificateStatus?: string(name='ServerCertificateStatus', example='checking'),
      status?: string(name='Status', example='success'),
    }
  ](name='CertInfo')
  }(name='CertInfos'),
  requestId?: string(name='RequestId', example='5C1E43DC-9E51-4771-****-7D5ECEB547A1'),
}

model DescribeVodDomainCertificateInfoResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVodDomainCertificateInfoResponseBody(name='body'),
}

async function describeVodDomainCertificateInfo(request: DescribeVodDomainCertificateInfoRequest): DescribeVodDomainCertificateInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVodDomainCertificateInfo', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVodDomainConfigsRequest {
  domainName: string(name='DomainName', description='The name of the feature. Separate multiple names with commas (,). For more information, see the **Feature description** section.', example='www.example.com', position='Query'),
  functionNames: string(name='FunctionNames', description='The parameters of each feature.', example='filetype_based_ttl_set,set_req_host_header', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DescribeVodDomainConfigsResponseBody = {
  domainConfigs?: {
    domainConfig?: [ 
    {
      configId?: string(name='ConfigId', description='## Feature description

| Feature | Description |
| ------- | ----------- |
| referer_white_list_set | Specifies the referer whitelist. |
| referer_black_list_set | Specifies the referer blacklist. |
| filetype_based_ttl_set | Specifies the time period after which a file expires. |
| path_based_ttl_set | Specifies the time period after which a directory expires. |
| cc_defense | Configures protection against HTTP flood attacks. |
| oss_auth | Configures authentication for the access to an Object Storage Service (OSS) bucket. |
| ip_black_list_set | Specifies the IP address blacklist. |
| ip_white_list_set | Specifies the IP address whitelist. |
| error_page | Redirects an error page to a specified page. |
| tesla | Optimizes pages to accelerate access. |
| set_req_host_header | Modifies the custom header of back-to-origin requests. |
| set_hashkey_args | Ignores the specified URL parameters. |
| aliauth | Configures Alibaba Cloud authentication. |
| set_resp_header | Specifies a response header. To verify the setting, you can check the response message in a browser. |
| video_seek | Configures video seeking. |
| range | Configures object chunking. |
| gzip | Optimizes pages by using GNU zip (Gzip) compression. |
| https_force | Configures force redirect to HTTPS. |
| http_force | Configures force redirect to HTTP. |
| alivod | Configures ApsaraVideo VOD. |
| forward_scheme | Specifies the origin protocol policy or configures whether to enable adaptive origin fetch. |
| tmd_signature | Specifies the self-defined rules for the rate limit. |', example='5003576'),
      functionArgs?: {
        functionArg?: [ 
        {
          argName?: string(name='ArgName', example='file_type'),
          argValue?: string(name='ArgValue', example='txt'),
        }
      ](name='FunctionArg')
      }(name='FunctionArgs'),
      functionName?: string(name='FunctionName', description='Queries the configurations of a specified domain name for CDN. You can query the configurations of one or more features at a time.', example='set_req_host_header'),
      status?: string(name='Status', description='The operation that you want to perform. Set the value to **DescribeVodDomainConfigs**.', example='success'),
    }
  ](name='DomainConfig')
  }(name='DomainConfigs', description='The value of the parameter.'),
  requestId?: string(name='RequestId', description='The status of the configuration. Valid values:

- **success**
- **testing**
- **failed**
- **configuring**', example='F8AA0364-0FDB-4AD5-****-D69FAB8924ED'),
}

model DescribeVodDomainConfigsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVodDomainConfigsResponseBody(name='body'),
}

/**
  * The name of the function.
  *
 */
async function describeVodDomainConfigs(request: DescribeVodDomainConfigsRequest): DescribeVodDomainConfigsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVodDomainConfigs', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVodDomainDetailRequest {
  domainName: string(name='DomainName', description='The status of the origin server. Valid values:

*   **online**: indicates that the origin server is enabled.
*   **offline**: indicates that the origin server is disabled.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DescribeVodDomainDetailResponseBody = {
  domainDetail?: {
    certName?: string(name='CertName', description='The time when the domain name for CDN was added. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='testCertName'),
    cname?: string(name='Cname', description='The status of the domain name for CDN. Value values:

*   **online**: indicates that the domain name is enabled.
*   **offline**: indicates that the domain name is disabled.
*   **configuring**: indicates that the domain name is being configured.
*   **configure_failed**: indicates that the domain name failed to be configured.
*   **checking**: indicates that the domain name is under review.
*   **check_failed**: indicates that the domain name failed the review.', example='example.com.w.alikunlun.net'),
    description?: string(name='Description', description='The name of the certificate. The value of this parameter is returned if HTTPS is enabled.', example='testDescription'),
    domainName?: string(name='DomainName', description='The port number. Valid values: 443 and 80.', example='example.com'),
    domainStatus?: string(name='DomainStatus', description='The address of the origin server.', example='online'),
    gmtCreated?: string(name='GmtCreated', description='The last time when the domain name for CDN was modified. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2017-11-27T06:51:26Z'),
    gmtModified?: string(name='GmtModified', description='Indicates whether the Secure Sockets Layer (SSL) certificate is enabled. Valid values:

*   **on**: indicates that the SSL certificate is enabled.
*   **off**: indicates that the SSL certificate is disabled.', example='2017-11-27T06:55:26Z'),
    SSLProtocol?: string(name='SSLProtocol', description='This parameter is applicable to users of level 3 or higher in mainland China and users outside mainland China. Valid values:

*   **domestic**: mainland China. This is the default value.
*   **overseas**: outside mainland China.
*   **global**: regions in and outside mainland China.', example='on'),
    SSLPub?: string(name='SSLPub', description='The domain name for CDN.', example='yourSSLPub'),
    scope?: string(name='Scope', description='The weight of the origin server.', example='domestic'),
    sources?: {
      source?: [ 
      {
        content?: string(name='Content', example='****.oss-cn-hangzhou.aliyuncs.com'),
        enabled?: string(name='Enabled', example='online'),
        port?: int32(name='Port', example='80'),
        priority?: string(name='Priority', example='50'),
        type?: string(name='Type', description='Queries the basic information about a specified domain name for CDN.', example='oss'),
      }
    ](name='Source')
    }(name='Sources', description='The ID of the request.'),
    weight?: string(name='Weight', description='The CNAME that is assigned to the domain name for CDN. You must add a CNAME record in the system of your Domain Name System (DNS) service provider to map the domain name for CDN to the CNAME.', example='1'),
  }(name='DomainDetail', description='The priority of the origin server.'),
  requestId?: string(name='RequestId', description='The operation that you want to perform. Set the value to **DescribeVodDomainDetail**.', example='09ABE829-6CD3-4FE0-556113E2****'),
}

model DescribeVodDomainDetailResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVodDomainDetailResponseBody(name='body'),
}

/**
  * The description of the domain name for CDN.
  *
 */
async function describeVodDomainDetail(request: DescribeVodDomainDetailRequest): DescribeVodDomainDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVodDomainDetail', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVodDomainLogRequest {
  domainName: string(name='DomainName', description='The page number of the returned page.', example='example.com', position='Query'),
  endTime?: string(name='EndTime', description='The operation that you want to perform. Set the value to **DescribeVodDomainLog**.', example='2016-10-20T05:00:00Z', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: long(name='PageNumber', description='The name of the log file.', example='1', minimum=1, position='Query'),
  pageSize?: long(name='PageSize', description='The number of the page to return. Default value: **1**.', example='300', minimum=1, maximum=1000, position='Query'),
  startTime?: string(name='StartTime', description='The beginning of the time range in which data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2016-10-20T04:00:00Z', position='Query'),
}

model DescribeVodDomainLogResponseBody = {
  domainLogDetails?: {
    domainLogDetail?: [ 
    {
      domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
      logCount?: long(name='LogCount', description='The detailed information about Alibaba Cloud CDN logs.', example='2'),
      logInfos?: {
        logInfoDetail?: [ 
        {
          endTime?: string(name='EndTime', description='The total number of entries returned.', example='2018-05-31T05:00:00Z'),
          logName?: string(name='LogName', description='Queries the information about the raw access logs for a specific domain name, including the log path.', example='example.com_2018_03_25_180000_19****.gz'),
          logPath?: string(name='LogPath', example='example.com/2018_03_25/example.com_2018_03_25_180000_19****.gz?Expires=1522659931&OSSAccessKeyId=****&Signature=****'),
          logSize?: long(name='LogSize', description='The ID of the request.', example='2645401'),
          startTime?: string(name='StartTime', description='The pagination settings of Alibaba Cloud CDN logs.', example='2018-05-31T04:00:00Z'),
        }
      ](name='LogInfoDetail')
      }(name='LogInfos', description='The path of the log file.'),
      pageInfos?: {
        pageNumber?: long(name='PageNumber', example='1'),
        pageSize?: long(name='PageSize', example='300'),
        total?: long(name='Total', example='2'),
      }(name='PageInfos'),
    }
  ](name='DomainLogDetail')
  }(name='DomainLogDetails', description='The detailed data of Alibaba Cloud CDN logs.'),
  requestId?: string(name='RequestId', description='The number of entries returned per page.', example='077D0284-F041-4A41-4D3C-B48377FD****'),
}

model DescribeVodDomainLogResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVodDomainLogResponseBody(name='body'),
}

/**
  * The total number of entries returned on the current page.
  *
 */
async function describeVodDomainLog(request: DescribeVodDomainLogRequest): DescribeVodDomainLogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVodDomainLog', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVodDomainSrcBpsDataRequest {
  domainName?: string(name='DomainName', example='example.com', position='Query'),
  endTime?: string(name='EndTime', example='2022-04-26T15:59:59Z', position='Query'),
  interval?: string(name='Interval', example='300', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  startTime?: string(name='StartTime', example='2022-04-25T16:00:00Z', position='Query'),
}

model DescribeVodDomainSrcBpsDataResponseBody = {
  dataInterval?: string(name='DataInterval', example='300'),
  domainName?: string(name='DomainName', example='sample.com'),
  endTime?: string(name='EndTime', example='2022-08-23T02:02:57Z'),
  requestId?: string(name='RequestId', example='25818875-5F78-4A13-BEF6-****'),
  srcBpsDataPerInterval?: {
    dataModule?: [ 
    {
      httpsValue?: string(name='HttpsValue', example='0'),
      timeStamp?: string(name='TimeStamp', example='2022-08-23T02:02:57Z'),
      value?: string(name='Value', example='0'),
    }
  ](name='DataModule')
  }(name='SrcBpsDataPerInterval'),
  startTime?: string(name='StartTime', example='2022-07-12T16:00:00Z'),
}

model DescribeVodDomainSrcBpsDataResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVodDomainSrcBpsDataResponseBody(name='body'),
}

async function describeVodDomainSrcBpsData(request: DescribeVodDomainSrcBpsDataRequest): DescribeVodDomainSrcBpsDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVodDomainSrcBpsData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVodDomainSrcTrafficDataRequest {
  domainName?: string(name='DomainName', description='The accelerated domain name. You can specify a maximum of 500 domain names in a request. Separate multiple domain names with commas (,). If you specify multiple domain names in a request, aggregation results are returned.

If you leave this parameter empty, the origin traffic data for all accelerated domain names is queried by default.', example='example.com', position='Query'),
  endTime?: string(name='EndTime', description='The end of the time range to query. The end time must be later than the start time. Specify the time in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2022-09-24T15:59:59Z', position='Query'),
  interval?: string(name='Interval', description='The time interval between the data entries to return. Unit: seconds. Valid values:

*   **300**: 5 minutes
*   **3600**: 1 hour
*   **86400**: 1 day

> The time granularity supported by the Interval parameter varies based on the time range per query specified by using `StartTime` and `EndTime`. For more information, see the **Time granularity** section of this topic.', example='300', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

If you leave this parameter empty, the origin traffic data that is generated in the last 24 hours is queried by default.', example='2022-03-22T16:00:00Z', position='Query'),
}

model DescribeVodDomainSrcTrafficDataResponseBody = {
  dataInterval?: string(name='DataInterval', description='The time interval between the entries returned. Unit: seconds.', example='300'),
  domainName?: string(name='DomainName', description='The accelerated domain name.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range during which data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2022-09-23T15:59:59Z'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='25818875-5F78-4AF6-D7393642CA58****'),
  srcTrafficDataPerInterval?: {
    dataModule?: [ 
    {
      httpsValue?: string(name='HttpsValue', description='The amount of traffic generated by origin HTTPS requests.', example='0'),
      timeStamp?: string(name='TimeStamp', description='The timestamp of the returned data. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2022-09-23T15:59:59Z'),
      value?: string(name='Value', description='The traffic value at each time interval.', example='0'),
    }
  ](name='DataModule')
  }(name='SrcTrafficDataPerInterval', description='Details about the origin traffic returned at each time interval. Unit: bytes.'),
  startTime?: string(name='StartTime', description='The start of the time range during which data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2022-08-29T16:00:00Z'),
  totalTraffic?: string(name='TotalTraffic', description='The total traffic. Unit: bytes.', example='5906662826'),
}

model DescribeVodDomainSrcTrafficDataResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVodDomainSrcTrafficDataResponseBody(name='body'),
}

/**
  * * This operation is available only in the **China (Shanghai)** region.
  * * ApsaraVideo VOD stores the origin traffic data for 90 days before the data is deleted.
  * * If you do not set the `StartTime` or `EndTime` parameter, the request returns the data collected in the last 24 hours. If you set both the `StartTime` and `EndTime` parameters, the request returns the data collected within the specified time range.
  * * You can specify a maximum of 500 domain names in a request. Separate multiple domain names with commas (,). If you specify multiple domain names in a request, aggregation results are returned.
  * ### Time granularity
  * The time granularity supported by the Interval parameter varies based on the time range per query specified by using `StartTime` and `EndTime`. The following table describes the time period within which historical data is available and the data delay.
  * |Time granularity|Time range per query (days)|Historical data available (days)|Data delay|
  * |---|---|---|---|
  * |5 minutes|(0, 3\\]|93|15 minutes|
  * |1 hour|(3, 31\\]|186|4 hours|
  * |1 day|(31, 366\\]|366|04:00 on the next day|
  *
 */
async function describeVodDomainSrcTrafficData(request: DescribeVodDomainSrcTrafficDataRequest): DescribeVodDomainSrcTrafficDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVodDomainSrcTrafficData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVodDomainTrafficDataRequest {
  domainName?: string(name='DomainName', description='The accelerated domain name that you want to query. If you leave this parameter empty, the merged data of all your accelerated domain names is returned. Separate multiple domain names with commas (,).', example='example.com', position='Query'),
  endTime?: string(name='EndTime', description='The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.', example='2019-01-20T14:59:58Z', position='Query'),
  interval?: string(name='Interval', description='The interval at which to return data. Unit: seconds. Valid values: **300**, **3600**, and **86400**. If you leave this parameter empty or specify an invalid value, the default value is used.

*   Valid values if the time range to query is less than 3 days: **300**, **3600**, and **86400**. Default value: 300.
*   Valid values if the time range to query is 3 to less than 31 days: **3600** and **86400**. Default value: 3600.
*   Valid value if the time range to query is 31 to 90 days: **86400**.', example='300', position='Query'),
  ispNameEn?: string(name='IspNameEn', description='The name of the Internet service provider (ISP). If you leave this parameter empty, all ISPs are queried.', example='Alibaba', position='Query'),
  locationNameEn?: string(name='LocationNameEn', description='The name of the region. If you leave this parameter empty, all regions are queried. You can specify only the China (Shanghai) region.', example='cn-shanghai', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.

> The minimum time granularity to query data is 5 minutes. If you leave this parameter empty, the data in the last 24 hours is queried.', example='2019-01-20T13:59:58Z', position='Query'),
}

model DescribeVodDomainTrafficDataResponseBody = {
  dataInterval?: string(name='DataInterval', description='The time interval between the entries returned. Unit: seconds.', example='3600'),
  domainName?: string(name='DomainName', description='The accelerated domain name.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range during which data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2019-01-20T14:59:58Z'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='D94E471F-1A27-442E-552D-D4D2000C****'),
  startTime?: string(name='StartTime', description='The beginning of the time range during which data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2019-01-20T13:59:58Z'),
  totalTraffic?: string(name='TotalTraffic', description='The total amount of network traffic.', example='5906662826'),
  trafficDataPerInterval?: {
    dataModule?: [ 
    {
      domesticValue?: string(name='DomesticValue', description='The amount of network traffic in the Chinese mainland. Unit: bytes.', example='0'),
      httpsDomesticValue?: string(name='HttpsDomesticValue', description='The amount of HTTPS network traffic on points of presence (POPs) in the Chinese mainland. Unit: bytes.', example='0'),
      httpsOverseasValue?: string(name='HttpsOverseasValue', description='The amount of HTTPS network traffic on POPs outside the Chinese mainland. Unit: bytes.', example='0'),
      httpsValue?: string(name='HttpsValue', description='The total amount of HTTPS network traffic on POPs. Unit: bytes.', example='0'),
      overseasValue?: string(name='OverseasValue', description='The amount of network traffic outside the Chinese mainland. Unit: bytes.', example='0'),
      timeStamp?: string(name='TimeStamp', description='The timestamp of the returned data. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2019-01-15T19:00:00Z'),
      value?: string(name='Value', description='The total amount of network traffic. Unit: bytes.', example='0'),
    }
  ](name='DataModule')
  }(name='TrafficDataPerInterval', description='The network traffic that was collected at each interval.'),
}

model DescribeVodDomainTrafficDataResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVodDomainTrafficDataResponseBody(name='body'),
}

/**
  * *   This operation is available only in the **China (Shanghai)** region.
  * *   You can specify multiple accelerated domain names in a request.
  * *   If you do not specify the StartTime or EndTime parameter, data of the last 24 hours is returned. You can specify the StartTime and EndTime parameters to query data that is generated in the specified time range. You can query data of the last 90 days.
  * ### QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on API operations](~~342790~~).
  *
 */
async function describeVodDomainTrafficData(request: DescribeVodDomainTrafficDataRequest): DescribeVodDomainTrafficDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVodDomainTrafficData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVodDomainUsageDataRequest {
  area?: string(name='Area', description='The region where you want to query data. Default value: CN. Valid values:

*   **CN**: Chinese mainland
*   **OverSeas**: outside the Chinese mainland', example='CN', position='Query'),
  domainName?: string(name='DomainName', description='The accelerated domain name. If you leave this parameter empty, the merged data of all your accelerated domain names is returned. Separate multiple accelerated domain names with commas (,).', example='example.com', position='Query'),
  endTime: string(name='EndTime', description='The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.', example='2015-12-10T12:20:00Z', position='Query'),
  field: string(name='Field', description='The type of the data to return. Valid values:

*   **bps**: bandwidth
*   **traf**: traffic', example='bps', position='Query'),
  interval?: string(name='Interval', example='300', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  startTime: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.', example='2015-12-10T10:20:00Z', position='Query'),
  type?: string(name='Type', description='The type of content that you want to query. Valid values:

*   **static**: static content
*   **dynamic**: dynamic content
*   **all**: all content', example='static', position='Query'),
}

model DescribeVodDomainUsageDataResponseBody = {
  area?: string(name='Area', description='The billable region where the data was collected.', example='CN'),
  dataInterval?: string(name='DataInterval', description='The time interval between the entries returned. Unit: seconds.', example='300'),
  domainName?: string(name='DomainName', description='The accelerated domain name.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range during which data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2015-12-10T12:20:00Z'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='B955107D-E658-4E77-****-E0AC3D31693E'),
  startTime?: string(name='StartTime', description='The beginning of the time range during which data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2015-12-10T10:20:00Z'),
  type?: string(name='Type', description='The type of content returned. Valid values:

*   **static**: static content
*   **dynamic**: dynamic content
*   **all**: all content', example='static'),
  usageDataPerInterval?: {
    dataModule?: [ 
    {
      timeStamp?: string(name='TimeStamp', description='The timestamp of the returned data. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2015-12-10T10:00:00Z'),
      value?: string(name='Value', description='The traffic or bandwidth data. Unit: bit/s.', example='2592.3920000000003'),
    }
  ](name='DataModule')
  }(name='UsageDataPerInterval', description='The traffic or bandwidth data returned at each interval.'),
}

model DescribeVodDomainUsageDataResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVodDomainUsageDataResponseBody(name='body'),
}

/**
  * > -   This operation is available only in the **China (Shanghai)** region.
  * >-  You can specify a maximum of 100 accelerated domain names in a request. Separate multiple domain names with commas (,). If you do not specify an accelerated domain name, the data of all accelerated domain names within your Alibaba Cloud account is returned.
  * >-  You can query data in the last year. The maximum time range that can be queried is three months. If you specify a time range of one to three days, the system returns data on an hourly basis. If you specify a time range of four days or more, the system returns data on a daily basis.
  *
 */
async function describeVodDomainUsageData(request: DescribeVodDomainUsageDataRequest): DescribeVodDomainUsageDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVodDomainUsageData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVodRefreshQuotaRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DescribeVodRefreshQuotaResponseBody = {
  blockQuota?: string(name='BlockQuota', description='The maximum number of Object Storage Service (OSS) buckets that can be refreshed each day.', example='500'),
  dirQuota?: string(name='DirQuota', description='The maximum number of directories of files that can be refreshed each day.', example='100'),
  dirRemain?: string(name='DirRemain', description='The remaining number of directories of files that can be refreshed on the current day.', example='99'),
  preloadQuota?: string(name='PreloadQuota', description='The maximum number of URLs of files that can be prefetched each day.', example='500'),
  preloadRemain?: string(name='PreloadRemain', description='The remaining number of URLs of files that can be prefetched on the current day.', example='500'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='42E0554B-80F4-4921-****-ACFB22CAAAD0'),
  urlQuota?: string(name='UrlQuota', description='The maximum number of URLs of files that can be refreshed each day.', example='2000'),
  urlRemain?: string(name='UrlRemain', description='The remaining number of URLs of files that can be refreshed on the current day.', example='1996'),
  blockRemain?: string(name='blockRemain', description='The remaining number of OSS buckets that can be refreshed on the current day.', example='500'),
}

model DescribeVodRefreshQuotaResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVodRefreshQuotaResponseBody(name='body'),
}

/**
  * > *   This operation is available only in the **China (Shanghai)** region.
  * > *   You can call the [RefreshVodObjectCaches](~~69215~~) operation to refresh content and the [PreloadVodObjectCaches](~~69211~~) operation to prefetch content.
  *
 */
async function describeVodRefreshQuota(request: DescribeVodRefreshQuotaRequest): DescribeVodRefreshQuotaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVodRefreshQuota', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVodRefreshTasksRequest {
  domainName?: string(name='DomainName', description='The domain name.', example='example.com', position='Query'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.', example='2017-01-01T12:30:20Z', position='Query'),
  objectPath?: string(name='ObjectPath', description='The path of the object. The path is used as a condition for exact matching.', example='http://example.com/***.txt', position='Query'),
  objectType?: string(name='ObjectType', description='The type of the task. Valid values:

*   **file**: refreshes one or more files.
*   **directory**: refreshes files in the specified directories.
*   **preload**: prefetches one or more files.

> If you specify the DomainName or Status parameter, you must also specify the ObjectType parameter.', example='file', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return.', example='1', minimum=1, maximum=42949672, position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: **20**. Maximum value: **50**.', example='20', minimum=1, maximum=50, position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.

> You can query data that is collected in the last three days.', example='2017-01-01T12:12:20Z', position='Query'),
  status?: string(name='Status', description='The status of the task. Valid values:

*   **Complete**: The task is complete.
*   **Refreshing**: The task is in progress.
*   **Failed**: The task failed.', example='Complete', position='Query'),
  taskId?: string(name='TaskId', description='The ID of the task that you want to query.', example='70422****', position='Query'),
}

model DescribeVodRefreshTasksResponseBody = {
  pageNumber?: long(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries returned per page.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='174F6032-AA26-470D-****-36F0EB205BEE'),
  tasks?: {
    task?: [ 
    {
      creationTime?: string(name='CreationTime', description='The time when the task was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2014-11-27T08:23:22Z'),
      description?: string(name='Description', description='The type of error returned when the refresh or prefetch task failed. Valid values: Valid values:

*   **Internal Error**: An internal error occurred.
*   **Origin Timeout**: The response from the origin server timed out.
*   **Origin Return StatusCode 5XX**: The origin server returned an HTTP status code 5xx.', example='Internal Error'),
      objectPath?: string(name='ObjectPath', description='The URL of the object refreshed.', example='http://example.com/****.txt'),
      objectType?: string(name='ObjectType', description='The type of the task. Default value: file. Valid values:

*   **file**: refreshes one or more files.
*   **directory**: refreshes files in the specified directory.
*   **preload**: prefetches one or more files.', example='file'),
      process?: string(name='Process', description='The progress of the task in percentage.', example='100%'),
      status?: string(name='Status', description='The status of the task. Valid values:

*   **Complete**: The task is complete.
*   **Refreshing**: The task is in progress.
*   **Failed**: The task failed.
*   **Pending**: The task is pending.', example='Complete'),
      taskId?: string(name='TaskId', description='The ID of the task.', example='704225667'),
    }
  ](name='Task')
  }(name='Tasks', description='The information about the returned tasks.'),
  totalCount?: long(name='TotalCount', description='The total number of entries returned.', example='2'),
}

model DescribeVodRefreshTasksResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVodRefreshTasksResponseBody(name='body'),
}

/**
  * > *   This operation is available only in the **China (Shanghai)** region.
  * >*   If you do not specify the TaskId or ObjectPath parameter, the data in the last three days is returned on the first page. By default, one page displays a maximum of 20 entries. You can specify the TaskId and ObjectPath parameters at the same time.
  *
 */
async function describeVodRefreshTasks(request: DescribeVodRefreshTasksRequest): DescribeVodRefreshTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVodRefreshTasks', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVodStorageDataRequest {
  endTime: string(name='EndTime', description='The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.', example='2019-02-01T15:00:00Z', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  region?: string(name='Region', description='The region in which you want to query storage data. If you leave this parameter empty, data in all regions is returned. Separate multiple regions with commas (,). Valid values:

*   **cn-shanghai**: China (Shanghai)
*   **cn-beijing**: China (Beijing)
*   **eu-central-1**: Germany (Frankfurt)
*   **ap-southeast-1**: Singapore', example='cn-shanghai', position='Query'),
  startTime: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.', example='2019-02-01T14:00:00Z', position='Query'),
  storage?: string(name='Storage', description='The name of the Object Storage Service (OSS) bucket. If you leave this parameter empty, data of all buckets is returned. Separate multiple bucket names with commas (,).', example='bucket', position='Query'),
  storageType?: string(name='StorageType', description='The storage type. Set the value to **OSS**.', example='OSS', position='Query'),
}

model DescribeVodStorageDataResponseBody = {
  dataInterval?: string(name='DataInterval', description='The time granularity at which the data was queried. Valid values:

*   **hour**
*   **day**', example='day'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='C370DAF1-C838-4288-****-9A87633D248E'),
  storageData?: {
    storageDataItem?: [ 
    {
      networkOut?: string(name='NetworkOut', description='The outbound traffic. Unit: bytes. The outbound traffic is generated when videos are directly downloaded or played from OSS buckets without Alibaba Cloud CDN acceleration.', example='111111'),
      storageUtilization?: string(name='StorageUtilization', description='The detailed usage data of storage-related resources. Unit: bytes.', example='111111'),
      timeStamp?: string(name='TimeStamp', description='The timestamp of the returned data. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2019-02-01T15:00:00Z'),
    }
  ](name='StorageDataItem')
  }(name='StorageData', description='The storage usage data returned.'),
}

model DescribeVodStorageDataResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVodStorageDataResponseBody(name='body'),
}

/**
  * > *   This operation is available only in the **China (Shanghai)** region.
  * >*   If the time range to query is less than or equal to seven days, the system returns the statistics collected on an hourly basis. If the time range to query is greater than seven days, the system returns the statistics collected on a daily basis. The maximum time range that you can specify to query is 31 days.
  *
 */
async function describeVodStorageData(request: DescribeVodStorageDataRequest): DescribeVodStorageDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVodStorageData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVodTranscodeDataRequest {
  endTime: string(name='EndTime', description='The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.', example='2019-02-01T15:59:00Z', position='Query'),
  interval?: string(name='Interval', description='The interval at which you want to query data. Valid values:

*   **day**: days
*   **hour**: hours', example='day', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  region?: string(name='Region', description='The region in which you want to query data. If you leave this parameter empty, data in all regions is returned. Separate multiple regions with commas (,). Valid values:

*   **cn-shanghai**: China (Shanghai)
*   **cn-beijing**: China (Beijing)
*   **eu-central-1**: Germany (Frankfurt)
*   **ap-southeast-1**: Singapore', example='cn-shanghai', position='Query'),
  specification?: string(name='Specification', description='The transcoding specification. If you leave this parameter empty, data of all transcoding specifications is returned. Separate multiple transcoding specifications with commas (,). Valid values:

*   **Audio**: audio transcoding
*   **Segmentation**: container format conversion
*   **H264.LD**, **H264.SD**, **H264.HD**, **H264.2K**, **H264.4K**, and more', example='Audio', position='Query'),
  startTime: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.', example='2019-02-01T15:00:00Z', position='Query'),
  storage?: string(name='Storage', description='The name of the Object Storage Service (OSS) bucket. If you leave this parameter empty, data of all buckets is returned. Separate multiple bucket names with commas (,).', example='bucket01', position='Query'),
}

model DescribeVodTranscodeDataResponseBody = {
  dataInterval?: string(name='DataInterval', description='The interval at which the data was queried. Valid values:

*   **hour**
*   **day**', example='day'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='C370DAF1-C838-4288-****-9A87633D248E'),
  transcodeData?: {
    transcodeDataItem?: [ 
    {
      data?: {
        dataItem?: [ 
        {
          name?: string(name='Name', description='The transcoding specification. Valid values:

*   **Audio**: audio transcoding
*   **Segmentation**: container format conversion
*   **H264.LD, H264.SD, H264.HD, H264.2K, H264.4K, and more**', example='H264.SD'),
          value?: string(name='Value', description='The transcoding duration. Unit: seconds.', example='111'),
        }
      ](name='DataItem')
      }(name='Data', description='The statistics on transcoding of different specifications.'),
      timeStamp?: string(name='TimeStamp', description='The timestamp of the returned data. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2019-02-01T16:00:00Z'),
    }
  ](name='TranscodeDataItem')
  }(name='TranscodeData', description='The transcoding statistics returned.'),
}

model DescribeVodTranscodeDataResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVodTranscodeDataResponseBody(name='body'),
}

/**
  * *   This operation is available only in the **China (Shanghai)** region.
  * *   If the time range to query is less than or equal to seven days, the system returns the statistics collected on an hourly basis. If the time range to query is greater than seven days, the system returns the statistics collected on a daily basis. The maximum time range that you can specify to query is 31 days.
  *
 */
async function describeVodTranscodeData(request: DescribeVodTranscodeDataRequest): DescribeVodTranscodeDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVodTranscodeData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVodUserDomainsRequest {
  domainName?: string(name='DomainName', description='The domain name. The value of this parameter is used as a filter condition for a fuzzy match.', example='example.aliyundoc.com', position='Query'),
  domainSearchType?: string(name='DomainSearchType', description='The search method. Valid values:
*   **fuzzy_match**: fuzzy match. This is the default value.
*   **pre_match**: prefix match.
*   **suf_match**: suffix match.
*   **full_match**: exact match.', example='fuzzy_match', position='Query'),
  domainStatus?: string(name='DomainStatus', description='The status of the domain name. The value of this parameter is used as a condition to filter domain names. Value values:
*   **online**: indicates that the domain name is enabled.
*   **offline**: indicates that the domain name is disabled.
*   **configuring**: indicates that the domain name is being configured.
*   **configure_failed**: indicates that the domain name failed to be configured.
*   **checking**: indicates that the domain name is under review.
*   **check_failed**: indicates that the domain name failed the review.', example='online', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return.', example='1', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: **20**. Maximum value: **50**. Valid values: integers in the range of **1** to **50**.', example='20', minimum=1, maximum=500, position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key', description='The key of tag N. Valid values of N: **1** to **20**.

If you do not specify this parameter, all tag keys are queried.', example='key'),
      value?: string(name='Value', description='The value of tag N. Valid values of N: **1** to **20**.

If you do not specify this parameter, all tag values are queried.', example='value'),
    }
  ](name='Tag', description='Tag.', position='Query'),
}

model DescribeVodUserDomainsResponseBody = {
  domains?: {
    pageData?: [ 
    {
      cname?: string(name='Cname', description='The canonical domain name that is assigned to the domain name for CDN.', example='learn.developer.aliyundoc.com'),
      description?: string(name='Description', description='The remarks.', example='Zhejiang ICP Filing No. ****'),
      domainName?: string(name='DomainName', description='The domain name for CDN.', example='example.aliyundoc.com'),
      domainStatus?: string(name='DomainStatus', description='The status of the domain name for CDN. Valid values:

*   **online**: indicates that the domain name is enabled.
*   **offline**: indicates that the domain name is disabled.
*   **configuring**: indicates that the domain name is being configured.
*   **configure_failed**: indicates that the domain name failed to be configured.
*   **checking**: indicates that the domain name is under review.
*   **check_failed**: indicates that the domain name failed the review.', example='online'),
      gmtCreated?: string(name='GmtCreated', description='The time when the domain name for CDN was added. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2017-08-29T08:40:53Z'),
      gmtModified?: string(name='GmtModified', description='The last time when the domain name for CDN was modified. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2017-12-29T09:24:12Z'),
      sandbox?: string(name='Sandbox', description='Indicates whether the domain name for CDN is in a sandbox environment.', example='normal'),
      sources?: {
        source?: [ 
        {
          content?: string(name='Content', description='The address of the origin server.', example='192.168.0.1'),
          port?: int32(name='Port', description='The port number. Valid values: **443** and **80**.', example='80'),
          priority?: string(name='Priority', description='The priority of the origin server.', example='5'),
          type?: string(name='Type', description='The type of the origin server. Valid values:

*   **ipaddr**: a server that you can access by using an IP address.
*   **domain**: a server that you can access by using a domain name.
*   **oss**: an Object Storage Service (OSS) bucket.', example='oss'),
        }
      ](name='Source')
      }(name='Sources', description='The information about the origin server.'),
      sslProtocol?: string(name='SslProtocol', description='Indicates whether HTTPS is enabled.

- **on**: indicates that HTTPS is enabled.
- **off**: indicates that HTTPS is disabled.', example='on'),
    }
  ](name='PageData')
  }(name='Domains', description='The detailed information about each domain name for CDN. The returned information is displayed in the format that is specified by the PageData parameter.'),
  pageNumber?: long(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries returned per page.', example='20'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='E4EBD2BF-5EB0-4476-****-9D94E1B15267'),
  totalCount?: long(name='TotalCount', description='The total number of entries returned.', example='2'),
}

model DescribeVodUserDomainsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVodUserDomainsResponseBody(name='body'),
}

async function describeVodUserDomains(request: DescribeVodUserDomainsRequest): DescribeVodUserDomainsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVodUserDomains', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVodVerifyContentRequest {
  domainName: string(name='DomainName', description='Queries the ownership verification content.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
}

model DescribeVodVerifyContentResponseBody = {
  content?: string(name='Content', example='verify_dffeb661*****3a59c31cd91f'),
  requestId?: string(name='RequestId', example='34AB41F1-04A5-4688-634BDBE6****'),
}

model DescribeVodVerifyContentResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVodVerifyContentResponseBody(name='body'),
}

async function describeVodVerifyContent(request: DescribeVodVerifyContentRequest): DescribeVodVerifyContentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVodVerifyContent', 'POST', '/', 'json', false, 'json', request);
}

model DetachAppPolicyFromIdentityRequest {
  appId?: string(name='AppId', description='The ID of the request.', example='app-****', position='Query'),
  identityName: string(name='IdentityName', description='The name of the policy. Separate multiple policies with commas (,). Only system policies are supported.

*   **VODAppFullAccess**: authorizes an identity to manage all resources in an application.
*   **VODAppReadOnlyAccess**: authorizes an identity to access all resources in an application in read-only mode.
*   **VODAppAdministratorAccess**: assigns the application administrator role to an identity.', example='test****name', position='Query'),
  identityType: string(name='IdentityType', description='The ID of the application. This parameter is optional when the PolicyNames parameter is set to VODAppAdministratorAccess. This parameter is required when the PolicyNames parameter is set to other values.

*   Default value: **app-1000000**.
*   For more information, see [Overview](~~113600~~).', example='RamUser', position='Query'),
  policyNames: string(name='PolicyNames', description='The operation that you want to perform. Set the value to **DetachAppPolicyFromIdentity**.', example='VODAppFullAccess', position='Query'),
}

model DetachAppPolicyFromIdentityResponseBody = {
  failedPolicyNames?: [ string ](name='FailedPolicyNames'),
  nonExistPolicyNames?: [ string ](name='NonExistPolicyNames'),
  requestId?: string(name='RequestId', description='Revokes application permissions from the specified identity. The identity may a RAM user or RAM role.', example='25818875-5F78-4A13-****-D7393642C'),
}

model DetachAppPolicyFromIdentityResponse = {
  headers: map[string]string(name='headers'),
  body: DetachAppPolicyFromIdentityResponseBody(name='body'),
}

/**
  * The name of the policy that was not found.
  *
 */
async function detachAppPolicyFromIdentity(request: DetachAppPolicyFromIdentityRequest): DetachAppPolicyFromIdentityResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DetachAppPolicyFromIdentity', 'POST', '/', 'json', false, 'json', request);
}

model GenerateKMSDataKeyRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: string(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: string(name='ResourceOwnerId', position='Query'),
}

model GenerateKMSDataKeyResponseBody = {
  ciphertextBlob?: string(name='CiphertextBlob', example='ODZhOWVmZDktM2QxNi00ODk0LWJkNGYtMWZjNDNmM2YyYWJmS7FmDBBQ0BkKsQrtRnidtPwirmDcS0ZuJCU41xxAAWk4Z8qsADfbV0b+i6kQmlvj79dJdGOvtX69Uycs901qOjop4bTS****'),
  keyId?: string(name='KeyId', example='7906979c-8e06-46a2-be2d-68e3ccbc****'),
  plaintext?: string(name='Plaintext', example='QmFzZTY0IGVuY29kZWQgcGxhaW50****'),
  requestId?: string(name='RequestId', example='25818875-5F78-4A*****F6-D7393642CA58'),
}

model GenerateKMSDataKeyResponse = {
  headers: map[string]string(name='headers'),
  body: GenerateKMSDataKeyResponseBody(name='body'),
}

async function generateKMSDataKey(request: GenerateKMSDataKeyRequest): GenerateKMSDataKeyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GenerateKMSDataKey', 'POST', '/', 'json', false, 'json', request);
}

model GetAIImageJobsRequest {
  jobIds: string(name='JobIds', description='The returned data.', example='cf08a2c6e11e*****de1711b738b9067', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: string(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: string(name='ResourceOwnerId', position='Query'),
}

model GetAIImageJobsResponseBody = {
  AIImageJobList?: [ 
    {
      AIImageResult?: string(name='AIImageResult', description='The Object Storage Service (OSS) URL of the image file.

> This parameter does not include the complete authentication information. To obtain the authentication information, you must generate a signed URL. Alternatively, you can call the [ListAIImage](~~ListAIImage~~) operation to obtain the image information.', example='[{"Score":5.035636554444242,"Url":"http://outin-*****.oss-cn-shanghai.aliyuncs.com/357a8748c577*****789d2726e6436aa/image/ai/b0a7612554d*****5cbe3-00001.gif"}]'),
      code?: string(name='Code', description='The user data.

*   The value must be a JSON string.
*   The MessageCallback or Extend parameter is returned.
*   The value contains a maximum of 512 bytes.

For more information, see the "UserData: specifies the custom configurations for media upload" section of the [Request parameters](~~86952~~) topic.', example='Success'),
      creationTime?: string(name='CreationTime', description='The ID of the image AI processing job. You can obtain the value of JobId from the response to the [SubmitAIImageJob](~~186922~~) operation.

*   You can specify a maximum of 10 IDs.
*   Separate multiple IDs with commas (,).', example='2020-10-15T03:30:03Z'),
      jobId?: string(name='JobId', description='The ID of the image AI processing job.', example='cf08a2c6e11e*****de1711b738b9067'),
      message?: string(name='Message', description='Queries jobs of image AI processing.', example='success'),
      status?: string(name='Status', description='The error code.', example='success'),
      templateConfig?: string(name='TemplateConfig', example='{"Format":"gif","SetDefaultCover":"true"}'),
      templateId?: string(name='TemplateId', example='5a86a00f15194*****d7fe7de1b4a173'),
      userData?: string(name='UserData', description='The ID of the request.', example='{"Extend":{"localId":"****","test":"www"}}'),
      videoId?: string(name='VideoId', description='The configurations of the AI template that was used to submit the job.', example='357a8748c577*****789d2726e6436aa'),
    }
  ](name='AIImageJobList', description='The time when the image AI processing job was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.'),
  requestId?: string(name='RequestId', description='The information about the image AI processing job.', example='7721B494-1F78-4E*****E8-A7CEE7315BFA'),
}

model GetAIImageJobsResponse = {
  headers: map[string]string(name='headers'),
  body: GetAIImageJobsResponseBody(name='body'),
}

/**
  * The image AI processing jobs.
  *
 */
async function getAIImageJobs(request: GetAIImageJobsRequest): GetAIImageJobsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetAIImageJobs', 'POST', '/', 'json', false, 'json', request);
}

model GetAIMediaAuditJobRequest {
  jobId: string(name='JobId', description='http://temp-****bucket.oss-cn-shanghai.aliyuncs.com/aivideocensor/****.jpg', example='bdbc266af6894*****943a70176d92e9', position='Query'),
}

model GetAIMediaAuditJobResponseBody = {
  mediaAuditJob?: {
    code?: string(name='Code', description='The ID of the intelligent review job.', example='0'),
    completeTime?: string(name='CompleteTime', description='The recommendation for review results. Valid values:

*   **block**: The content violates the regulations.
*   **review**: The content may violate the regulations.
*   **pass**: The content passes the review.', example='2017-01-11T13:00:00Z'),
    creationTime?: string(name='CreationTime', description='The review scenario. Valid value: **antispam**.', example='2017-01-11T12:00:00Z'),
    data?: {
      abnormalModules?: string(name='AbnormalModules', description='The ID of the video.', example='video'),
      audioResult?: [ 
        {
          label?: string(name='Label', description='The recommendation for review results. Valid values:

*   **block**: The content violates the regulations.
*   **review**: The content may violate the regulations.
*   **pass**: The content passes the review.', example='normal'),
          scene?: string(name='Scene', description='The recommendation for review results. Valid values:

*   **block**: The content violates the regulations.
*   **review**: The content may violate the regulations.
*   **pass**: The content passes the review.', example='antispam'),
          score?: string(name='Score', description='The categories of the review results and the number of images.', example='99.91'),
          suggestion?: string(name='Suggestion', description='The category of the review result. Valid values:

*   **normal**
*   **bloody**
*   **explosion**
*   **outfit**
*   **logo**
*   **weapon**
*   **politics**
*   **violence**
*   **crowd**
*   **parade**
*   **carcrash**
*   **flag**
*   **location**
*   **others**', example='pass'),
        }
      ](name='AudioResult', description='The job result data.'),
      imageResult?: [ 
        {
          label?: string(name='Label', description='The error code. This parameter is returned if the value of Status is fail.', example='normal'),
          result?: [ 
            {
              label?: string(name='Label', description='The recommendation for review results. Valid values:

*   **block**: The content violates the regulations.
*   **review**: The content may violate the regulations.
*   **pass**: The content passes the review.', example='porn'),
              scene?: string(name='Scene', description='The category of the review result. Valid values:

*   **ad**
*   **normal**', example='porn'),
              score?: string(name='Score', description='The number of images.', example='0'),
              suggestion?: string(name='Suggestion', description='The results of logo review.', example='pass'),
            }
          ](name='Result', description='The results of terrorism content review.'),
          suggestion?: string(name='Suggestion', description='The categories of the review results and the number of images.', example='pass'),
          type?: string(name='Type', description='The information about the image with the highest score of the category that is indicated by Label.', example='cover'),
          url?: string(name='Url', description='The score of the image of the category that is indicated by Label.', example='http://www.test.com/****.jpg'),
        }
      ](name='ImageResult', description='The recommendation for review results. Valid values:

*   **block**: The content violates the regulations.
*   **review**: The content may violate the regulations.
*   **pass**: The content passes the review.'),
      label?: string(name='Label', description='The content that violates the regulations. Separate multiple values with commas (,). Valid values:

*   **video**: the video.
*   **image-cover**: the cover.
*   **text-title**: the title.', example='normal'),
      suggestion?: string(name='Suggestion', description='The results of pornography content review.', example='pass'),
      textResult?: [ 
        {
          content?: string(name='Content', description='The number of images.', example='http://temp-****bucket.oss-cn-shanghai.aliyuncs.com/aivideocensor/****.jpg'),
          label?: string(name='Label', description='The recommendation for review results. Valid values:

*   **block**: The content violates the regulations.
*   **review**: The content may violate the regulations.
*   **pass**: The content passes the review.', example='ad'),
          scene?: string(name='Scene', description='The categories of the review results and the number of images.', example='antispam'),
          score?: string(name='Score', description='The URL of the image.', example='100'),
          suggestion?: string(name='Suggestion', description='The information about the intelligent review job.', example='pass'),
          type?: string(name='Type', description='The category of the review result.

Valid values if scene is **porn**:

*   **porn**
*   **sexy**
*   **normal**

Valid values if scene is **terrorism**:

*   **normal**
*   **bloody**
*   **explosion**
*   **outfit**
*   **logo**
*   **weapon**
*   **politics**
*   **violence**
*   **crowd**
*   **parade**
*   **carcrash**
*   **flag**
*   **location**
*   **others**

Valid values if scene is **ad**:

*   **normal**
*   **ad**
*   **politics**
*   **porn**
*   **abuse**
*   **terrorism**
*   **contraband**
*   **spam**
*   **npx**: illegal ad
*   **qrcode**: QR code
*   **programCode**

Valid values if scene is **live**:

*   **normal**
*   **meaningless**
*   **PIP**
*   **smoking**
*   **drivelive**

Valid values if scene is **logo**:

*   **normal**
*   **TV**
*   **trademark**', example='title'),
        }
      ](name='TextResult', description='The results of ad review.'),
      videoResult?: {
        adResult?: {
          averageScore?: string(name='AverageScore', description='The number of images.', example='100'),
          counterList?: [ 
            {
              count?: int32(name='Count', description='The information about the image with the highest score of the category that is indicated by Label.', example='10'),
              label?: string(name='Label', description='The results of undesired content review.', example='ad'),
            }
          ](name='CounterList', description='The results of video review.'),
          label?: string(name='Label', description='The type of the image. Valid value: **cover**.', example='ad'),
          maxScore?: string(name='MaxScore', description='The category of the review result. Valid values:

*   **porn**
*   **sexy**
*   **normal**', example='100'),
          suggestion?: string(name='Suggestion', description='The statistics about tag frames.', example='block'),
          topList?: [ 
            {
              label?: string(name='Label', description='The URL of the image.', example='ad'),
              score?: string(name='Score', description='The average score of the review results.', example='100'),
              timestamp?: string(name='Timestamp', description='The categories of the review results and the number of images.', example='500'),
              url?: string(name='Url', description='The URL of the image.', example='The information about the image with the highest score of the category that is indicated by Label.'),
            }
          ](name='TopList', description='The information about the image with the highest score of the category that is indicated by Label.'),
        }(name='AdResult', description='The information about the image with the highest score of the category that is indicated by Label.'),
        label?: string(name='Label', description='The category of the review result. Valid values:

*   **live**: The content contains undesirable scenes.
*   **normal**', example='normal'),
        liveResult?: {
          averageScore?: string(name='AverageScore', description='The recommendation for review results. Valid values:

*   **block**: The content violates the regulations.
*   **review**: The content may violate the regulations.
*   **pass**: The content passes the review.', example='100'),
          counterList?: [ 
            {
              count?: int32(name='Count', description='The number of images.', example='The position in the video. Unit: milliseconds.'),
              label?: string(name='Label', description='The recommendation for review results. Valid values:

*   **block**: The content violates the regulations.
*   **review**: The content may violate the regulations.
*   **pass**: The content passes the review.', example='The category of the review result. Valid values:

*   **normal**
*   **spam**
*   **ad**
*   **politics**
*   **terrorism**
*   **abuse**
*   **porn**
*   **flood**: spam posts
*   **contraband**
*   **meaningless**'),
            }
          ](name='CounterList', description='The position in the video. Unit: milliseconds.'),
          label?: string(name='Label', description='The category of the review result. Separate multiple values with commas (,). Valid values:

*   **porn**
*   **terrorism**
*   **ad**
*   **live**: undesirable scenes
*   **logo**
*   **audio**: audio anti-spam
*   **normal**', example='The text.'),
          maxScore?: string(name='MaxScore', description='The time when the job is complete. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='100'),
          suggestion?: string(name='Suggestion', description='The error message. This parameter is returned if the value of Status is fail.', example='block'),
          topList?: [ 
            {
              label?: string(name='Label', description='Queries the information about an intelligent review job. After the job is submitted, it is processed asynchronously. You can call this operation to query the job information in real time.', example='GetAIMediaAuditJob'),
              score?: string(name='Score', description='The ID of the request.', example='100'),
              timestamp?: string(name='Timestamp', description='The results of text review.', example='500'),
              url?: string(name='Url', description='The category of the review result. Valid values:

*   **live**: The content contains undesirable scenes.
*   **normal**', example='The category of the review result. Valid values:

*   **ad**
*   **normal**'),
            }
          ](name='TopList', description='The results of image review.'),
        }(name='LiveResult', description='The recommendation for review results. Valid values:

*   **block**: The content violates the regulations.
*   **review**: The content may violate the regulations.
*   **pass**: The content passes the review.'),
        logoResult?: {
          averageScore?: string(name='AverageScore', example='100'),
          counterList?: [ 
            {
              count?: int32(name='Count', example='2'),
              label?: string(name='Label'),
            }
          ](name='CounterList'),
          label?: string(name='Label'),
          maxScore?: string(name='MaxScore', example='100'),
          suggestion?: string(name='Suggestion', example='block'),
          topList?: [ 
            {
              label?: string(name='Label'),
              score?: string(name='Score', example='100'),
              timestamp?: string(name='Timestamp', example='5000'),
              url?: string(name='Url'),
            }
          ](name='TopList'),
        }(name='LogoResult'),
        pornResult?: {
          averageScore?: string(name='AverageScore', description='Test', example='100'),
          counterList?: [ 
            {
              count?: int32(name='Count', description='The results of audio review.', example='0'),
              label?: string(name='Label', description='The category of the review result. Valid values:

*   **live**: The content contains undesirable scenes.
*   **normal**', example='porn'),
            }
          ](name='CounterList', description='The URL of the image.'),
          label?: string(name='Label', description='The average score of the review results.', example='porn'),
          maxScore?: string(name='MaxScore', description='The number of images.', example='100'),
          suggestion?: string(name='Suggestion', description='The score of the image of the category that is indicated by Label.', example='pass'),
          topList?: [ 
            {
              label?: string(name='Label', description='The score of the image of the category that is indicated by Label. Valid values: `[0, 100]`. The value is accurate to 10 decimal places. The score is representative of the confidence.', example='porn'),
              score?: string(name='Score', description='The position in the video. Unit: milliseconds.', example='100'),
              timestamp?: string(name='Timestamp', description='The score.', example='3005'),
              url?: string(name='Url', description='The score of the image of the category that is indicated by Label. Valid values: `[0, 100]`. The value is accurate to 10 decimal places. The score is representative of the confidence.', example='The review scenario. Valid value: **antispam**.'),
            }
          ](name='TopList', description='The category of the review result. Valid values:

*   **porn**
*   **sexy**
*   **normal**'),
        }(name='PornResult', description='The time when the job started to run. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.'),
        suggestion?: string(name='Suggestion', description='The position in the video. Unit: milliseconds.', example='pass'),
        terrorismResult?: {
          averageScore?: string(name='AverageScore', description='The category of the review result. Valid values:

*   **porn**
*   **sexy**
*   **normal**', example='100'),
          counterList?: [ 
            {
              count?: int32(name='Count', description='The highest score of the image of the category that is indicated by Label.', example='0'),
              label?: string(name='Label', description='The category of the review result. Valid values:

*   **normal**
*   **bloody**
*   **explosion**
*   **outfit**
*   **logo**
*   **weapon**
*   **politics**
*   **violence**
*   **crowd**
*   **parade**
*   **carcrash**
*   **flag**
*   **location**
*   **others**', example='terrorism'),
            }
          ](name='CounterList', description='The review scenario. Valid values:

*   **porn**
*   **terrorism**
*   **ad**
*   **live**: undesirable scenes
*   **logo**'),
          label?: string(name='Label', description='The category of the review result. Valid values:

*   **logo**
*   **normal**', example='normal'),
          maxScore?: string(name='MaxScore', description='The score of the image of the category that is indicated by Label.', example='100'),
          suggestion?: string(name='Suggestion', description='The URL of the image.', example='pass'),
          topList?: [ 
            {
              label?: string(name='Label', description='The category of the review result. Valid values:

*   **logo**
*   **normal**', example='normal'),
              score?: string(name='Score', description='The ID of the job.', example='100'),
              timestamp?: string(name='Timestamp', description='The highest review score.', example='5'),
              url?: string(name='Url', description='The position in the video. Unit: milliseconds.', example='http://ali*****.com/aivideocensor/yytysursrutyrxuq/****.jpg'),
            }
          ](name='TopList', description='The score of the image of the category that is indicated by Label. Valid values: `[0, 100]`. The score is representative of the confidence.'),
        }(name='TerrorismResult', description='The category of the review result. Valid values:

*   **ad**
*   **normal**'),
      }(name='VideoResult', description='The category of the review result. Valid values:

*   **logo**
*   **normal**'),
    }(name='Data', description='The status of the job. Valid values:

*   **success**: The job is successful.
*   **fail**: The job failed.
*   **init**: The job is being initialized.
*   **Processing**: The job is in progress.'),
    jobId?: string(name='JobId', description='Only the job type is supported.', example='bdbc266af6894*****943a70176d92e9'),
    mediaId?: string(name='MediaId', description='http://temp-****bucket.oss-cn-shanghai.aliyuncs.com/aivideocensor/****.jpg', example='fe028d09441d*****d1afffb138cd7e'),
    message?: string(name='Message', description='The highest score of the image of the category that is indicated by Label. Valid values: `[0, 100]`. The value is accurate to 10 decimal places. The score is representative of the confidence.', example='OK'),
    status?: string(name='Status', description='The category of the review result. Valid values:

*   **ad**
*   **normal**', example='success'),
    type?: string(name='Type', description='The category of the review result. Valid values:

*   **terrorism**
*   **outfit**
*   **logo**
*   **weapon**
*   **politics**
*   **others**
*   **normal**', example='AIMediaAudit'),
  }(name='MediaAuditJob', description='The average score of the images of the category that is indicated by Label. Valid values: `[0, 100]`. The value is accurate to 10 decimal places. The score is representative of the confidence.'),
  requestId?: string(name='RequestId', description='The highest review score.', example='EAA3E96A-02E2-41*****85-08E1D568ED3A'),
}

model GetAIMediaAuditJobResponse = {
  headers: map[string]string(name='headers'),
  body: GetAIMediaAuditJobResponseBody(name='body'),
}

/**
  * The recommendation for review results. Valid values:
  * *   **block**: The content violates the regulations.
  * *   **review**: The content may violate the regulations.
  * *   **pass**: The content passes the review.
  *
 */
async function getAIMediaAuditJob(request: GetAIMediaAuditJobRequest): GetAIMediaAuditJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetAIMediaAuditJob', 'POST', '/', 'json', false, 'json', request);
}

model GetAITemplateRequest {
  templateId: string(name='TemplateId', description='The source of the AI template. Valid values:

*   **System**
*   **Custom**', example='1706a0063dd733f6a823ef32e0a5****', position='Query'),
}

model GetAITemplateResponseBody = {
  requestId?: string(name='RequestId', description='The information about the AI template.', example='080DA371-8AC0-4CD4-4476-33E64282****'),
  templateInfo?: {
    creationTime?: string(name='CreationTime', description='The type of the AI template. Valid values:

*   **AIMediaAudit**: automated review
*   **AIImage**: smart thumbnail', example='2020-07-08T06:50:45Z'),
    isDefault?: string(name='IsDefault', description='The time when the AI template was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='NotDefault'),
    modifyTime?: string(name='ModifyTime', example='2020-07-08T06:58:45Z'),
    source?: string(name='Source', description='Queries the details of an AI template.', example='Custom'),
    templateConfig?: string(name='TemplateConfig', description='The time when the AI template was modified. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='{"AuditRange":["text-title","video"],"AuditContent":["screen"],"AuditItem":["terrorism","porn"],"AuditAutoBlock":"yes"}'),
    templateId?: string(name='TemplateId', example='1706a0063dd733f6a823ef32e0a5****'),
    templateName?: string(name='TemplateName', description='The ID of the request.', example='DemoAITemplate'),
    templateType?: string(name='TemplateType', description='Indicates whether the template is the default AI template. Valid values:

*   **Default**
*   **NotDefault**', example='AIMediaAudit'),
  }(name='TemplateInfo', description='The ID of the AI template.'),
}

model GetAITemplateResponse = {
  headers: map[string]string(name='headers'),
  body: GetAITemplateResponseBody(name='body'),
}

/**
  * The detailed configurations of the AI template. The value is a JSON string. For more information, see [AITemplateConfig](https://help.aliyun.com/document_detail/89863.html#title-vd3-499-o36).
  *
 */
async function getAITemplate(request: GetAITemplateRequest): GetAITemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetAITemplate', 'POST', '/', 'json', false, 'json', request);
}

model GetAIVideoTagResultRequest {
  mediaId: string(name='MediaId', description='The point in time when the time tag is displayed. Unit: milliseconds.', example='595d020bad37421f37433451720****', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: string(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: string(name='ResourceOwnerId', position='Query'),
}

model GetAIVideoTagResultResponseBody = {
  requestId?: string(name='RequestId', description='The location tag of the video.', example='8829B4DB-AFD9-4FF6-12965DBFFA14****'),
  videoTagResult?: {
    category?: [ 
      {
        tag?: string(name='Tag', description='John', example='Asia'),
      }
    ](name='Category', description='The location tags.'),
    keyword?: [ 
      {
        tag?: string(name='Tag', description='The URL of the profile photo.

> This parameter is returned only when a figure tag was used.', example='Queries the results of smart tagging jobs.'),
        times?: [ string ](name='Times'),
      }
    ](name='Keyword', description='The video categories.'),
    location?: [ 
      {
        tag?: string(name='Tag', description='The figure tag of the video.', example='The category of the video.'),
        times?: [ string ](name='Times', description='The returned result.'),
      }
    ](name='Location', description='The point in time when the location tag is displayed. Unit: milliseconds.'),
    person?: [ 
      {
        faceUrl?: string(name='FaceUrl', description='Retouching', example='http://example.com/aivideotag/8829B4DB-AFD9-4F*****F6-12965DBFFA14/Index_****.jpg'),
        tag?: string(name='Tag', description='The keyword tags.', example='The points in time when the tags are displayed. Unit: milliseconds.'),
        times?: [ string ](name='Times', description='The points in time when the tags are displayed. Unit: milliseconds.'),
      }
    ](name='Person', description='The tag string.'),
    time?: [ 
      {
        tag?: string(name='Tag', description='Cushion', example='The points in time when the tags are displayed. Unit: milliseconds.'),
        times?: [ string ](name='Times', description='The tag string.'),
      }
    ](name='Time', description='The ID of the media file. You can use one of the following methods to obtain the ID:

*   Log on to the [ApsaraVideo VOD](https://vod.console.aliyun.com) console. In the left-side navigation pane, choose **Media Files** > **Audio/Video**. On the Video and Audio page, view the ID of the audio or video file. This method is applicable to files that are uploaded by using the ApsaraVideo VOD console.
*   Obtain the value of VideoId from the response to the [CreateUploadVideo](~~55407~~) operation that you call to upload media files.
*   Obtain the value of VideoId from the response to the [SearchMedia](~~86044~~) operation after you upload media files.'),
  }(name='VideoTagResult', description='The tag string.'),
}

model GetAIVideoTagResultResponse = {
  headers: map[string]string(name='headers'),
  body: GetAIVideoTagResultResponseBody(name='body'),
}

/**
  * Milliseconds
  *
 */
async function getAIVideoTagResult(request: GetAIVideoTagResultRequest): GetAIVideoTagResultResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetAIVideoTagResult', 'POST', '/', 'json', false, 'json', request);
}

model GetAppInfosRequest {
  appIds: string(name='AppIds', description='The type of the application. Valid values:

- **System**
- **Custom**', example='app-****', position='Query'),
}

model GetAppInfosResponseBody = {
  appInfoList?: [ 
    {
      appId?: string(name='AppId', example='app-****'),
      appName?: string(name='AppName', example='test'),
      creationTime?: string(name='CreationTime', example='2019-03-01T08:00:00Z'),
      description?: string(name='Description', example='my first app.'),
      modificationTime?: string(name='ModificationTime', example='2019-03-01T09:00:00Z'),
      status?: string(name='Status', description='Queries the information about one or more applications based on application IDs.', example='Normal'),
      type?: string(name='Type', description='The ID of the request.', example='System'),
    }
  ](name='AppInfoList', description='The time when the application was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.'),
  code?: string(name='Code'),
  nonExistAppIds?: [ string ](name='NonExistAppIds', description='The ID of the application. You can specify a maximum of 10 application IDs. Separate them with commas (,).'),
  requestId?: string(name='RequestId', description='The last time when the application was modified. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='25818875-5F78-4A13-4DC4-D7393642****'),
}

model GetAppInfosResponse = {
  headers: map[string]string(name='headers'),
  body: GetAppInfosResponseBody(name='body'),
}

/**
  * The description of the application.
  *
 */
async function getAppInfos(request: GetAppInfosRequest): GetAppInfosResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetAppInfos', 'POST', '/', 'json', false, 'json', request);
}

model GetAttachedMediaInfoRequest {
  authTimeout?: long(name='AuthTimeout', description='The validity period of the URL of the auxiliary media asset. Unit: seconds.
> *   If the OutputType parameter is set to **cdn**:
>     *   The URL of the auxiliary media asset has a validity period only if URL signing is enabled. Otherwise, the URL of the auxiliary media asset is permanently valid.
>     *   Minimum value: **1**.
>     *   Maximum value: unlimited.
>     *   Default value: If you do not set this parameter, the default validity period that is specified in URL signing is used.
> *   If the OutputType parameter is set to **oss**:
>     *   The URL of the auxiliary media asset has a validity period only if the permissions on the Object Storage Service (OSS) bucket are private. Otherwise, the URL of the auxiliary media asset is permanently valid.
>     *   Minimum value: **1**.
>     *   Maximum value: **2592000** (30 days). The maximum value is limited to reduce security risks of the origin.
>     *   Default value: If you do not set this parameter, the default value is **3600**.', example='3600', position='Query'),
  mediaIds: string(name='MediaIds', description='The ID of the auxiliary media asset. Separate multiple IDs with commas (,). A maximum of 20 IDs can be specified.', example='eb1861d2c9a842340e989dd56****,0222e203cf80f9c22870a4d2c****', position='Query'),
  outputType?: string(name='OutputType', description='The type of the URL of the auxiliary media asset. Valid values:
*   **oss**: OSS URL
*   **cdn** (default): Content Delivery Network (CDN) URL', example='oss', position='Query'),
}

model GetAttachedMediaInfoResponseBody = {
  attachedMediaList?: [ 
    {
      appId?: string(name='AppId', description='The ID of the application.', example='app-*****'),
      categories?: [ 
        {
          cateId?: long(name='CateId', description='The ID of the video category.', example='1000224338'),
          cateName?: string(name='CateName', description='The name of the category.
- The value can be up to 64 bytes in length.
- The string must be encoded in the UTF-8 format.', example='category test'),
          level?: long(name='Level', description='The level of the category. A value of 0 indicates a level 1 category.', example='0'),
          parentId?: long(name='ParentId', description='The ID of the parent category. The parent category ID of a level 1 category is -1.', example='1000224336'),
        }
      ](name='Categories', description='The list of categories.'),
      creationTime?: string(name='CreationTime', description='The time when the auxiliary media asset was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2019-01-01T10:00:00Z'),
      description?: string(name='Description', description='The description of the auxiliary media asset.', example='description test'),
      mediaId?: string(name='MediaId', description='The ID of the auxiliary media asset.', example='0222e203cf80f9c22870a4d2c****'),
      modificationTime?: string(name='ModificationTime', description='The time when the auxiliary media asset was updated. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2020-05-31T11:42:20Z'),
      status?: string(name='Status', description='The status of the auxiliary media asset. Valid values:
- **Uploading**: The auxiliary media asset is being uploaded. This is the initial status.
- **Normal**: The auxiliary media asset is uploaded.
- **UploadFail**: The auxiliary media asset fails to be uploaded.', example='Normal'),
      storageLocation?: string(name='StorageLocation', description='The OSS bucket where the auxiliary media asset is stored.', example='outin-bfefbb9*****c7426.oss-cn-shanghai.aliyuncs.com'),
      tags?: string(name='Tags', description='The tags of the auxiliary media asset.', example='tag1,tag2'),
      title?: string(name='Title', description='The title of the auxiliary media asset.', example='subtitle test'),
      type?: string(name='Type', description='The type of the auxiliary media asset. Valid values:
- **watermark**
- **subtitle**
- **material**', example='subtitle'),
      URL?: string(name='URL', description='The URL of the auxiliary media asset.
> If a CDN domain name is specified, a CDN URL is returned. Otherwise, an OSS URL is returned.', example='https://al*****.cn/subtitle/9843C2*****4E186F19B6.vtt?auth_key=159099f60e0b7fd59****'),
    }
  ](name='AttachedMediaList', description='The information about the media asset.'),
  nonExistMediaIds?: [ string ](name='NonExistMediaIds', description='The IDs of the auxiliary media assets that do not exist.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='221BCB57-B217-42BF-619BD13378F9****'),
}

model GetAttachedMediaInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetAttachedMediaInfoResponseBody(name='body'),
}

async function getAttachedMediaInfo(request: GetAttachedMediaInfoRequest): GetAttachedMediaInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetAttachedMediaInfo', 'POST', '/', 'json', false, 'json', request);
}

model GetAuditHistoryRequest {
  pageNo?: long(name='PageNo', description='The reason why the video failed the review. If the video failed the review, specify the reason.', example='1', position='Query'),
  pageSize?: long(name='PageSize', description='The ID of the video.', example='10', position='Query'),
  sortBy?: string(name='SortBy', description='The review records.', example='CreationTime:Desc', position='Query'),
  videoId: string(name='VideoId', description='The operation that you want to perform. Set the value to **GetAuditHistory**.', example='93ab850b4f6f44*****6e91d24d81d4', position='Query'),
}

model GetAuditHistoryResponseBody = {
  histories?: [ 
    {
      auditor?: string(name='Auditor', example='auditor'),
      comment?: string(name='Comment', description='Queries the manual review history.'),
      creationTime?: string(name='CreationTime', description='The manual review result. Valid values:

- **Normal**: The video can be played.
- **Blocked**: The video is blocked.', example='2017-01-11T12:00:00Z'),
      reason?: string(name='Reason'),
      status?: string(name='Status', description='The time when the review record was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='Blocked'),
    }
  ](name='Histories', description='The ID of the request.'),
  requestId?: string(name='RequestId', description='The review comments, which are provided by the reviewer.', example='04F0F334-1335-43*****D7-6C044FE73368'),
  status?: string(name='Status', description='The reviewer.', example='Normal'),
  total?: long(name='Total', description='The sorting rule of the results. Valid values:

*   **CreationTime:Desc**: sorts the results based on the creation time in descending order. This is the default value.
*   **CreationTime:Asc**: sorts the results based on the creation time in ascending order.', example='2'),
}

model GetAuditHistoryResponse = {
  headers: map[string]string(name='headers'),
  body: GetAuditHistoryResponseBody(name='body'),
}

async function getAuditHistory(request: GetAuditHistoryRequest): GetAuditHistoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetAuditHistory', 'POST', '/', 'json', false, 'json', request);
}

model GetCategoriesRequest {
  cateId?: long(name='CateId', description='The number of the page where the subcategories to be returned are listed. Default value: **1**.', example='49339****', position='Query'),
  pageNo?: long(name='PageNo', description='The type of the category. Valid values:

*   **default** (default): default category
*   **material**: material category', example='1', position='Query'),
  pageSize?: long(name='PageSize', description='The number of entries to return on each page of the subcategory list. Default value: **10**. Maximum value: **100**.', example='10', position='Query'),
  sortBy?: string(name='SortBy', description='The list of subcategories.', example='CreationTime:Desc', position='Query'),
  type?: string(name='Type', description='The total number of subcategories.', example='default', position='Query'),
}

model GetCategoriesResponseBody = {
  category?: {
    cateId?: long(name='CateId', description='The ID of the video category.', example='100'),
    cateName?: string(name='CateName', description='The ID of the parent category. The parent category ID of a level 1 category is **-1**.', example='The method for sorting the results. Valid values:

*   **CreationTime:Desc** (default): The results are sorted in reverse chronological order based on the creation time.
*   **CreationTime:Asc**: The results are sorted in chronological order based on the creation time.'),
    level?: long(name='Level', description='The name of the category.

*   The value can be up to 64 bytes in length.
*   The string must be encoded in the UTF-8 format.', example='0'),
    parentId?: long(name='ParentId', description='The level of the category. A value of **0** indicates a level 1 category.', example='100012****'),
    type?: string(name='Type', description='The total number of subcategories.', example='default'),
  }(name='Category', description='The ID of the category. Default value: **-1**, which indicates the parent category ID of a level 1 category.'),
  requestId?: string(name='RequestId', description='The type of the category. Valid values:

*   **default** (default): default category
*   **material**: material category', example='25818875-5F78-4AF6-D7393642CA58****'),
  subCategories?: {
    category?: [ 
    {
      cateId?: long(name='CateId', example='100'),
      cateName?: string(name='CateName'),
      level?: long(name='Level', example='1'),
      parentId?: long(name='ParentId', example='10020****'),
      subTotal?: long(name='SubTotal', example='1'),
      type?: string(name='Type', description='Queries the information about the specified category and its subcategories.', example='default'),
    }
  ](name='Category')
  }(name='SubCategories', description='The ID of the request.'),
  subTotal?: long(name='SubTotal', description='The information about the specified category.', example='3795'),
}

model GetCategoriesResponse = {
  headers: map[string]string(name='headers'),
  body: GetCategoriesResponseBody(name='body'),
}

async function getCategories(request: GetCategoriesRequest): GetCategoriesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetCategories', 'POST', '/', 'json', false, 'json', request);
}

model GetDefaultAITemplateRequest {
  templateType: string(name='TemplateType', description='The source of the AI template. Valid values:

*   **System**
*   **Custom**', example='AIMediaAudit', position='Query'),
}

model GetDefaultAITemplateResponseBody = {
  requestId?: string(name='RequestId', description='The information about the AI template.', example='A017F1DE-3DC3-4441-6755-37E81113****'),
  templateInfo?: {
    creationTime?: string(name='CreationTime', description='The type of the AI template. The value is **AIMediaAudit**, which indicates automated review.', example='2020-07-08T06:50:45Z'),
    isDefault?: string(name='IsDefault', description='The time when the AI template was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='Default'),
    modifyTime?: string(name='ModifyTime', example='2020-07-08T06:58:45Z'),
    source?: string(name='Source', description='Queries information about the default AI template.', example='Custom'),
    templateConfig?: string(name='TemplateConfig', description='The time when the AI template was modified. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='{"AuditRange":["text-title","video"],"AuditContent":["screen"],"AuditItem":["terrorism","porn"],"AuditAutoBlock":"yes"}'),
    templateId?: string(name='TemplateId', example='1706a0063dd733f6a823ef32e0a5****'),
    templateName?: string(name='TemplateName', description='The ID of the request.', example='DemoAITemplate'),
    templateType?: string(name='TemplateType', description='Indicates whether the template is the default AI template. Valid values:

*   **Default**
*   **NotDefault**', example='AIMediaAudit'),
  }(name='TemplateInfo', description='The ID of the AI template.'),
}

model GetDefaultAITemplateResponse = {
  headers: map[string]string(name='headers'),
  body: GetDefaultAITemplateResponseBody(name='body'),
}

/**
  * The detailed configurations of the AI template. The value is a JSON string. For more information, see [AITemplateConfig](https://help.aliyun.com/document_detail/89863.html#title-vd3-499-o36).
  *
 */
async function getDefaultAITemplate(request: GetDefaultAITemplateRequest): GetDefaultAITemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetDefaultAITemplate', 'POST', '/', 'json', false, 'json', request);
}

model GetEditingProjectRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: string(name='OwnerId', position='Query'),
  projectId: string(name='ProjectId', description='The timeline of the online editing project.', example='fb2101bf24b27*****54cb318787dc', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: string(name='ResourceOwnerId', position='Query'),
}

model GetEditingProjectResponseBody = {
  project?: {
    coverURL?: string(name='CoverURL', description='The ID of the request.', example='https://****.com/6AB4D0E1E1C74468883516C2349****.png'),
    creationTime?: string(name='CreationTime', description='The title of the online editing project.', example='2017-10-23T13:33:40Z'),
    description?: string(name='Description', description='The time when the online editing project was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='testdescription'),
    modifiedTime?: string(name='ModifiedTime', description='The information about the online editing project.', example='2017-10-23T14:27:26Z'),
    projectId?: string(name='ProjectId', description='58928', example='fb2101bf24b27*****54cb318787dc'),
    regionId?: string(name='RegionId', example='cn-shanghai'),
    status?: string(name='Status', description='The path of the Object Storage Service (OSS) bucket where the online editing project is stored.

> To view the path of the OSS bucket, log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com/?spm=a2c4g.11186623.2.15.6948257eaZ4m54#/vod/settings/censored), and choose **Configuration Management** > **Media Management** > **Storage**. On the Storage page, you can view the path of the OSS bucket.', example='Normal'),
    storageLocation?: string(name='StorageLocation', description='The ID of the online editing project.', example='location_s'),
    timeline?: string(name='Timeline', description='朴灵', example='{\\"TimelineIn\\":0,\\"TimelineOut\\":9.42}'),
    title?: string(name='Title'),
  }(name='Project', description='The region where the online editing project was created.'),
  requestId?: string(name='RequestId', description='The ID of the online editing project.', example='63E8B7C7-4812-46*****AD-0FA56029AC86'),
}

model GetEditingProjectResponse = {
  headers: map[string]string(name='headers'),
  body: GetEditingProjectResponseBody(name='body'),
}

async function getEditingProject(request: GetEditingProjectRequest): GetEditingProjectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetEditingProject', 'POST', '/', 'json', false, 'json', request);
}

model GetEditingProjectMaterialsRequest {
  materialType?: string(name='MaterialType', description='The URLs of material snapshots. The value is an array.', example='video', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: string(name='OwnerId', position='Query'),
  projectId: string(name='ProjectId', description='The ID of the online editing project. You can use one of the following methods to obtain the ID of the online editing project:

*   Log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com). In the left-side navigation pane, choose **Production Center** > **Video Editing** to obtain the ID of the specified online editing project.
*   Call the **AddEditingProject** operation. The value of the response parameter ProjectId is the ID of the specified online editing project.', example='1982361011093374****', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: string(name='ResourceOwnerId', position='Query'),
  type?: string(name='Type', description='The ID of the material.', example='video', position='Query'),
}

model GetEditingProjectMaterialsResponseBody = {
  materialList?: {
    material?: [ 
    {
      cateId?: int32(name='CateId', description='The thumbnail URL of the material.', example='100005****'),
      cateName?: string(name='CateName', description='The category ID of the material.', example='The ID of the request.'),
      coverURL?: string(name='CoverURL', example='http://example.aliyundoc.com/aivideocover/46fa444aa34065cb9250f6c****/image_01.jpg'),
      creationTime?: string(name='CreationTime', description='The type of the material. Valid values:

*   **video**
*   **audio**', example='2017-10-19 10:48:17'),
      description?: string(name='Description', description='58928', example='朴灵'),
      duration?: float(name='Duration', example='15.16'),
      materialId?: string(name='MaterialId', example='85befc4118b84c6723e53b80b1****'),
      materialType?: string(name='MaterialType', description='The type of the material. Valid values:

*   **video**
*   **audio**
*   **image**', example='video'),
      modifiedTime?: string(name='ModifiedTime', description='Queries materials to be edited for an online editing project.', example='2017-10-19 10:48:17'),
      size?: long(name='Size', example='1682694'),
      snapshots?: {
        snapshot?: [ string ](name='Snapshot')
      }(name='Snapshots'),
      source?: string(name='Source', description='The time when the material was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='xxx'),
      spriteConfig?: string(name='SpriteConfig', description='The URLs of material sprites. The value is an array.', example='xxx'),
      sprites?: {
        sprite?: [ string ](name='Sprite')
      }(name='Sprites'),
      status?: string(name='Status', description='The configuration of the sprite.', example='Normal'),
      tags?: string(name='Tags', description='The type of the material. Valid values:

*   **video**
*   **audio**
*   **image**', example='The materials.'),
      title?: string(name='Title', example='test'),
    }
  ](name='Material')
  }(name='MaterialList', description='The duration of the material. The value is rounded to four decimal places. Unit: seconds.'),
  requestId?: string(name='RequestId', description='The tag of the material. Multiple tags are separated by commas (,).', example='746FFA07-8BBB-46B1-3E94E3B2915E****'),
}

model GetEditingProjectMaterialsResponse = {
  headers: map[string]string(name='headers'),
  body: GetEditingProjectMaterialsResponseBody(name='body'),
}

/**
  * The time when the material was last updated. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
  *
 */
async function getEditingProjectMaterials(request: GetEditingProjectMaterialsRequest): GetEditingProjectMaterialsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetEditingProjectMaterials', 'POST', '/', 'json', false, 'json', request);
}

model GetImageInfoRequest {
  authTimeout?: long(name='AuthTimeout', description='The validity period of the image URL. Unit: seconds.

> *   If the OutputType parameter is set to **cdn**:
>     *   The image URL has a validity period only if URL signing is enabled. Otherwise, the image URL is permanently valid.
>     *   Minimum value: **1**.
>     *   Maximum value: unlimited.
>     *   Default value: If you do not set this parameter, the default validity period that is specified in URL signing is used.
> *   If the OutputType parameter is set to **oss**:
>     *   The image URL has a validity period only if the permissions on the Object Storage Service (OSS) bucket are private. Otherwise, the image URL is permanently valid.
>     *   Minimum value: **1**.
>     *   Maximum value: **2592000** (30 days). The maximum value is limited to reduce security risks of the origin.
>     *   Default value: If you do not set this parameter, the default value is **3600**.', example='3600', position='Query'),
  imageId: string(name='ImageId', description='The ID of the image.', example='3e34733b40b9a96ccf5c1ff6f69****', position='Query'),
  outputType?: string(name='OutputType', description='The type of the image URL. Valid values:

*   **oss**: OSS URL
*   **cdn** (default): Content Delivery Network (CDN) URL', example='cdn', position='Query'),
}

model GetImageInfoResponseBody = {
  imageInfo?: {
    appId?: string(name='AppId', description='The ID of the application.', example='app-****'),
    cateId?: long(name='CateId', description='The ID of the category.', example='254766071'),
    cateName?: string(name='CateName', description='The name of the category.', example='test name'),
    creationTime?: string(name='CreationTime', description='The time when the image file was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2018-11-21T02:37:23Z'),
    description?: string(name='Description', description='The description of the image.', example='test description'),
    imageId?: string(name='ImageId', description='The ID of the image.', example='bbc65bba53f9*****ed90de118a7849'),
    imageType?: string(name='ImageType', description='The type of the image. Valid values:

- **CoverSnapshot**: thumbnail snapshot.
- **NormalSnapshot**: normal snapshot.
- **SpriteSnapshot**: sprite snapshot.
- **SpriteOriginSnapshot**: sprite source snapshot.
- **All**: images of all the preceding types. If this parameter is not set to All, you can specify multiple types and separate them with commas (,).', example='NormalSnapshot'),
    mezzanine?: {
      fileSize?: string(name='FileSize', description='The size of the file. Unit: byte.', example='8932'),
      fileURL?: string(name='FileURL', description='The OSS URL of the image.', example='https://outin-bfefbb*****163e1c7426.oss-cn-XXXXXXXX.aliyuncs.com/image/default/5E84CD536*****D4DAD.png?Expires=1590982353&OSSAccessKeyId=*****&Signature=ALPET74o*****c%3D'),
      height?: int32(name='Height', description='The height of the image. Unit: pixel.', example='200'),
      originalFileName?: string(name='OriginalFileName', description='The name of the uploaded file.', example='****.gif'),
      width?: int32(name='Width', description='The width of the image. Unit: pixel.', example='200'),
    }(name='Mezzanine', description='The information about the image mezzanine file.'),
    status?: string(name='Status', description='The status of the image. Valid values:

- **Uploading**: The image is being uploaded. This is the initial status.
- **Normal**: The image is uploaded.
- **UploadFail**: The image fails to be uploaded.', example='Uploading'),
    storageLocation?: string(name='StorageLocation', description='The OSS bucket where the image is stored.', example='outin-****..oss-cn-shanghai.aliyuncs.com'),
    tags?: string(name='Tags', description='The tag of the image. Multiple tags are separated by commas (,).', example='tag1,tag2,tag3'),
    title?: string(name='Title', description='The title of the image.', example='this is a sample'),
    URL?: string(name='URL', description='The URL of the image. If a CDN domain name is specified, a CDN URL is returned. Otherwise, an OSS URL is returned.', example='http://example.aliyundoc.com/image/default/****.gif?auth_key=****'),
  }(name='ImageInfo', description='The information about the image.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='AB99D4DF-FAFA-49DC-9C548C1E261E****'),
}

model GetImageInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetImageInfoResponseBody(name='body'),
}

async function getImageInfo(request: GetImageInfoRequest): GetImageInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetImageInfo', 'POST', '/', 'json', false, 'json', request);
}

model GetImageInfosRequest {
  authTimeout?: long(name='AuthTimeout', description='The time when the image URL expires. Unit: seconds.

*   If the OutputType parameter is set to cdn:

    *   This parameter takes effect only if URL authentication is enabled. Otherwise, the image URL does not expire.
    *   Minimum value: 1.
    *   Maximum value: unlimited.
    *   Default value: The default validity period that is specified in URL authentication is used.

*   If the OutputType parameter is set to oss:

    *   This parameter takes effect only when the ACL of the Object Storage Service (OSS) bucket is private. Otherwise, the image URL does not expire.
    *   Minimum value: 1.
    *   Maximum value: 2592000 (30 days). This limit is imposed to reduce security risks of the origin server.
    *   Default value: 3600.', example='3600', position='Query'),
  imageIds: string(name='ImageIds', description='The image IDs. Separate multiple IDs with commas (,). You can specify a maximum of 20 image IDs. You can use one of the following methods to obtain the image ID:

*   Log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com/) and choose Media Files > Images in the left-side navigation pane. This method is applicable to images that are uploaded by using the ApsaraVideo VOD console.
*   Obtain the value of ImageId from the response to the [CreateUploadImage](~~436544~~) operation that you call to obtain the upload URL and credential.
*   Obtain the value of ImageId from the response to the [SearchMedia](~~436559~~) operation after you upload images.', example='bbc65bba53fed90de118a7849****,594228cdd14b4d069fc17a8c4a****', position='Query'),
  outputType?: string(name='OutputType', description='The type of the output image URL. Valid values:

*   oss: OSS URL
*   cdn: CDN URL', example='cdn', position='Query'),
}

model GetImageInfosResponseBody = {
  imageInfo?: [ 
    {
      appId?: string(name='AppId', description='The ID of the application.', example='app-****'),
      cateId?: long(name='CateId', description='The ID of the category to which the image belongs.', example='254766071'),
      cateName?: string(name='CateName', description='The name of the category.', example='Test'),
      creationTime?: string(name='CreationTime', description='The time when the image was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2018-11-21T02:37:23Z'),
      description?: string(name='Description', description='The description of the image.', example='Test description'),
      imageId?: string(name='ImageId', description='The ID of the image file.', example='bbc65bba53f9*****ed90de118a7849'),
      imageType?: string(name='ImageType', description='The type of the image. Valid values:

*   **CoverSnapshot**: thumbnail snapshot
*   **NormalSnapshot**: normal snapshot
*   **SpriteSnapshot**: sprite snapshot
*   **SpriteOriginSnapshot**: sprite source snapshot
*   **All**: images of all the preceding types. If this parameter is not set to All, you can specify multiple types and separate the types with commas (,).', example='NormalSnapshot'),
      mezzanine?: {
        fileSize?: string(name='FileSize', description='The size of the image file. Unit: bytes.', example='8932'),
        fileURL?: string(name='FileURL', description='The OSS URL of the image file.', example='https://outin-bfefbb*****163e1c7426.oss-cn-XXXXXXXX.aliyuncs.com/image/default/5E84CD536*****D4DAD.png?Expires=1590982353&OSSAccessKeyId=*****&Signature=ALPET74o*****c%3D'),
        height?: int32(name='Height', description='The height of the image. Unit: pixels.', example='200'),
        originalFileName?: string(name='OriginalFileName', description='The name of the source file.', example='****.gif'),
        width?: int32(name='Width', description='The width of the image. Unit: pixels.', example='200'),
      }(name='Mezzanine', description='The source information about the image.'),
      status?: string(name='Status', description='The status of the image file. Valid values:

*   **Uploading**: The image is being uploaded. This is the initial status.
*   **Normal**: The image is uploaded.
*   **UploadFail**: The image fails to be uploaded.', example='Uploading'),
      storageLocation?: string(name='StorageLocation', description='The bucket in which the image is stored.', example='outin-****..oss-cn-shanghai.aliyuncs.com'),
      tags?: string(name='Tags', description='The tags of the image. Separate multiple tags with commas (,).', example='tag1,tag2,tag3'),
      title?: string(name='Title', description='The title of the image.', example='this is a sample'),
      URL?: string(name='URL', description='The image URL. If a domain name for CDN is specified, a CDN URL is returned. Otherwise, an OSS URL is returned.', example='http://example.aliyundoc.com/image/default/****.gif?auth_key=****'),
    }
  ](name='ImageInfo', description='The image information.'),
  nonExistImageIds?: [ string ](name='NonExistImageIds', description='The IDs of the images that do not exist.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='25818875-5F78-4AF6-D7393642CA58*****'),
}

model GetImageInfosResponse = {
  headers: map[string]string(name='headers'),
  body: GetImageInfosResponseBody(name='body'),
}

/**
  * You can call this operation to query the basic information about multiple images at a time, such as the image title, type, creation time, tags, and URL.
  * ### Limits
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](~~342790~~).
  *
 */
async function getImageInfos(request: GetImageInfosRequest): GetImageInfosResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetImageInfos', 'POST', '/', 'json', false, 'json', request);
}

model GetMediaAuditAudioResultDetailRequest {
  mediaId: string(name='MediaId', description='The end time of the audio that failed the review. Unit: seconds.', example='93ab850b4f6f*****54b6e91d24d81d4', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: string(name='OwnerId', position='Query'),
  pageNo?: int32(name='PageNo', description='Details of review results.', example='1', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: string(name='ResourceOwnerId', position='Query'),
}

model GetMediaAuditAudioResultDetailResponseBody = {
  mediaAuditAudioResultDetail?: {
    list?: [ 
      {
        endTime?: long(name='EndTime', description='The list of results.', example='10'),
        label?: string(name='Label', example='abuse'),
        startTime?: long(name='StartTime', description='Queries the details of audio review results.', example='8'),
        text?: string(name='Text'),
      }
    ](name='List', description='The text that corresponds to the audio.'),
    pageTotal?: int32(name='PageTotal', description='The operation that you want to perform. Set the value to **GetMediaAuditAudioResultDetail**.', example='1'),
    total?: int32(name='Total', description='The ID of the request.', example='10'),
  }(name='MediaAuditAudioResultDetail', description='The page number of the returned page.'),
  requestId?: string(name='RequestId', description='The number of the page to return. This parameter is optional. If you do not specify this parameter, all results are returned without pagination.', example='CB7D7232-1AB2-40FE-B8D3-****'),
}

model GetMediaAuditAudioResultDetailResponse = {
  headers: map[string]string(name='headers'),
  body: GetMediaAuditAudioResultDetailResponseBody(name='body'),
}

/**
  * The start time of the audio that failed the review. Unit: seconds.
  *
 */
async function getMediaAuditAudioResultDetail(request: GetMediaAuditAudioResultDetailRequest): GetMediaAuditAudioResultDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMediaAuditAudioResultDetail', 'POST', '/', 'json', false, 'json', request);
}

model GetMediaAuditResultRequest {
  mediaId: string(name='MediaId', description='The operation that you want to perform. Set the value to **GetMediaAuditResult**.', example='93ab850b4f6f*****54b6e91d24d81d4', position='Query'),
}

model GetMediaAuditResultResponseBody = {
  mediaAuditResult?: {
    abnormalModules?: string(name='AbnormalModules', description='The ID of the video or image.', example='video'),
    audioResult?: [ 
      {
        label?: string(name='Label', description='The statistics about tag frames.', example='normal'),
        scene?: string(name='Scene', description='The results of undesired content review.', example='antispam'),
        score?: string(name='Score', description='The results of video review.', example='99.91'),
        suggestion?: string(name='Suggestion', description='The category of the review result. Valid values:

- **ad**
- **normal**', example='pass'),
      }
    ](name='AudioResult', description='The category of the review result. Valid values:

- **porn**
- **sexy**
- **normal**'),
    imageResult?: [ 
      {
        label?: string(name='Label', description='The recommendation for review results. Valid values:

- **block**
- **review**
- **pass**', example='porn'),
        result?: [ 
          {
            label?: string(name='Label', description='The highest review score.', example='porn'),
            scene?: string(name='Scene', description='The category of the review result. Valid values:

- **normal**
- **bloody**
- **explosion**
- **outfit**
- **logo**
- **weapon**
- **politics**
- **violence**
- **crowd**
- **parade**
- **carcrash**
- **flag**
- **location**
- **others**', example='porn'),
            score?: string(name='Score', description='The recommendation for review results. Valid values:

*   **block**
*   **review**
*   **pass**', example='100.00000'),
            suggestion?: string(name='Suggestion', description='The category of the review result. 

- **ad**
- **normal**', example='pass'),
          }
        ](name='Result', description='The URL of the image.'),
        suggestion?: string(name='Suggestion', description='The results of ad review.', example='pass'),
        type?: string(name='Type', description='The score.', example='cover'),
        url?: string(name='Url', description='The type of the image. The value is **cover**.', example='http://www.test.com/****.jpg'),
      }
    ](name='ImageResult', description='The average score of the review results.'),
    label?: string(name='Label', description='The number of frames.', example='porn'),
    suggestion?: string(name='Suggestion', description='The URL of the image.', example='pass'),
    textResult?: [ 
      {
        content?: string(name='Content', description='The category of the review result. Valid values:

- **live**: The content contains undesirable scenes.
- **normal**: normal content.', example='The position in the video. Unit: milliseconds.'),
        label?: string(name='Label', description='The statistics about tag frames.', example='ad'),
        scene?: string(name='Scene', description='The position in the video. Unit: milliseconds.', example='antispam'),
        score?: string(name='Score', description='The recommendation for review results. Valid values:

*   **block**
*   **review**
*   **pass**', example='100.00000'),
        suggestion?: string(name='Suggestion', description='The category of the review result. Separate multiple values with commas (,). Valid values:

*   **porn**
*   **terrorism**
*   **normal**', example='pass'),
        type?: string(name='Type', description='The results of terrorist content review.', example='title'),
      }
    ](name='TextResult', description='The information about the image with the highest score of the category that is indicated by Label.'),
    videoResult?: {
      adResult?: {
        averageScore?: string(name='AverageScore', description='The category of the review result. Separate multiple values with commas (,). Valid values:

*   **porn**
*   **terrorism**
*   **normal**', example='100'),
        counterList?: [ 
          {
            count?: int32(name='Count', description='The statistics about tag frames.', example='12'),
            label?: string(name='Label', description='The average score of the review results.', example='ad'),
          }
        ](name='CounterList', description='The highest review score.'),
        label?: string(name='Label', description='The highest review score.', example='ad'),
        maxScore?: string(name='MaxScore', description='The information about the image with the highest score of the category that is indicated by Label.', example='100'),
        suggestion?: string(name='Suggestion', description='The average score of the review results.', example='block'),
        topList?: [ 
          {
            label?: string(name='Label', description='The score of the image of the category that is indicated by Label.', example='ad'),
            score?: string(name='Score', description='The recommendation for review results. Valid values:

- **block**
- **review**
- **pass**', example='100'),
            timestamp?: string(name='Timestamp', description='The score of the image of the category that is indicated by Label.', example='10'),
            url?: string(name='Url', description='The statistics about tag frames.', example='http://temp-testbucket.oss-cn-shanghai.aliyuncs.com/aivideocensor/****.jpg'),
          }
        ](name='TopList', description='The review scenario. The value is **antispam**.'),
      }(name='AdResult', description='The URL of the image.'),
      label?: string(name='Label', description='Details of image review results.', example='porn'),
      liveResult?: {
        averageScore?: string(name='AverageScore', description='The category of the review result. Valid values:

- **ad**
- **normal**', example='100'),
        counterList?: [ 
          {
            count?: int32(name='Count', description='The ID of the request.', example='2'),
            label?: string(name='Label', description='The score of the image of the category that is indicated by Label.', example='The URL of the image.'),
          }
        ](name='CounterList', description='The category of the review result. Valid values:

- **spam**
- **ad**
- **abuse**
- **flood**
- **contraband**
- **meaningless**
- **normal**'),
        label?: string(name='Label', description='The results of image review.', example='The recommendation for review results. Valid values:

- **block**
- **review**
- **pass**'),
        maxScore?: string(name='MaxScore', description='The category of the review result. Valid values:

- **porn**
- **sexy**
- **normal**', example='100'),
        suggestion?: string(name='Suggestion', description='The number of frames.', example='block'),
        topList?: [ 
          {
            label?: string(name='Label'),
            score?: string(name='Score', description='Queries the summary of automated review results.', example='100'),
            timestamp?: string(name='Timestamp', example='10'),
            url?: string(name='Url', description='The category of the review result. Separate multiple values with commas (,). Valid values: 

- **porn**
- **terrorism**
- **normal**', example='http://temp-testbucket.oss-cn-shanghai.aliyuncs.com/aivideocensor/****.jpg'),
          }
        ](name='TopList', description='The category of the review result. Valid values:

- **logo**
- **normal**'),
      }(name='LiveResult', description='The category of the review result. Valid values:

- **normal**
- **bloody**
- **explosion**
- **outfit**
- **logo**
- **weapon**
- **politics**
- **violence**
- **crowd**
- **parade**
- **carcrash**
- **flag**
- **location**
- **others**'),
      logoResult?: {
        averageScore?: string(name='AverageScore', description='The average score of the review results.', example='100'),
        counterList?: [ 
          {
            count?: int32(name='Count', description='The type of the text. The value is **title**.', example='1'),
            label?: string(name='Label', description='The results of logo review.', example='The score of the image of the category that is indicated by Label.'),
          }
        ](name='CounterList', description='The text content for review.'),
        label?: string(name='Label', description='The score of the image of the category that is indicated by Label.', example='The results of pornographic content review.'),
        maxScore?: string(name='MaxScore', description='The information about the image with the highest score of the category that is indicated by Label.', example='100'),
        suggestion?: string(name='Suggestion', description='The number of frames.', example='block'),
        topList?: [ 
          {
            label?: string(name='Label', description='The score of the image of the category that is indicated by Label.', example='The category of the review result. Valid values:

- **normal**
- **bloody**
- **explosion**
- **outfit**
- **logo**
- **weapon**
- **politics**
- **violence**
- **crowd**
- **parade**
- **carcrash**
- **flag**
- **location**
- **others**'),
            score?: string(name='Score', description='The recommendation for review results. Valid values:

*   **block**
*   **review**
*   **pass**', example='100'),
            timestamp?: string(name='Timestamp', description='The category of the review result. Valid values:

- **live**: The content contains undesirable scenes.
- **normal**: normal content.', example='16'),
            url?: string(name='Url', description='The number of frames.', example='http://temp-testbucket.oss-cn-shanghai.aliyuncs.com/aivideocensor/****.jpg'),
          }
        ](name='TopList', description='The category of the review result. Valid values:

- **logo**
- **normal**'),
      }(name='LogoResult', description='The recommendation for review results.'),
      pornResult?: {
        averageScore?: string(name='AverageScore', description='The category of the review result. Valid values:

- **live**: The content contains undesirable scenes.
- **normal**: normal content.', example='100'),
        counterList?: [ 
          {
            count?: int32(name='Count', description='The highest review score.', example='1'),
            label?: string(name='Label', description='The recommendation for review results. Valid values:

- **block**
- **review**
- **pass**', example='porn'),
          }
        ](name='CounterList', description='The category of the review result. Valid values:

- **porn**
- **sexy**
- **normal**'),
        label?: string(name='Label', description='The review scenario. Valid values:

*   **terrorism**
*   **porn**', example='porn'),
        maxScore?: string(name='MaxScore', description='The information about the image with the highest score of the category that is indicated by Label.', example='100'),
        suggestion?: string(name='Suggestion', description='The position in the video. Unit: milliseconds.', example='pass'),
        topList?: [ 
          {
            label?: string(name='Label', description='The results of text review.', example='porn'),
            score?: string(name='Score', description='The recommendation for review results. Valid values:

*   **block**
*   **review**
*   **pass**', example='100.0000'),
            timestamp?: string(name='Timestamp', description='The position in the video. Unit: milliseconds.', example='3005'),
            url?: string(name='Url', description='The category of the review result.

Valid values if scene is **porn**:

*   **porn**
*   **sexy**
*   **normal**

Valid values if scene is **terrorism**:

*   **normal**
*   **bloody**
*   **explosion**
*   **outfit**
*   **logo**
*   **weapon**
*   **politics**
*   **violence**
*   **crowd**
*   **parade**
*   **carcrash**
*   **flag**
*   **location**
*   **others**', example='http://temp-testbucket.oss-cn-shanghai.aliyuncs.com/aivideocensor/****.jpg'),
          }
        ](name='TopList', description='The score of the image of the category that is indicated by Label.'),
      }(name='PornResult', description='The average score of the review results.'),
      suggestion?: string(name='Suggestion', description='The category of the review result.

- **logo**
- **normal**', example='pass'),
      terrorismResult?: {
        averageScore?: string(name='AverageScore', example='100'),
        counterList?: [ 
          {
            count?: int32(name='Count', example='1'),
            label?: string(name='Label', example='outfit'),
          }
        ](name='CounterList'),
        label?: string(name='Label', example='normal'),
        maxScore?: string(name='MaxScore', example='100'),
        suggestion?: string(name='Suggestion', example='pass'),
        topList?: [ 
          {
            label?: string(name='Label', example='normal'),
            score?: string(name='Score', example='100.000'),
            timestamp?: string(name='Timestamp', example='3005'),
            url?: string(name='Url', example='http://temp-testbucket.oss-cn-shanghai.aliyuncs.com/aivideocensor/****.jpg'),
          }
        ](name='TopList'),
      }(name='TerrorismResult'),
    }(name='VideoResult', description='The recommendation for review results. Valid values:

- **block**
- **review**
- **pass**'),
  }(name='MediaAuditResult', description='The URL of the image.'),
  requestId?: string(name='RequestId', description='The URL of the image.', example='CB7D7232-1AB2-40FE-B8D5-****'),
}

model GetMediaAuditResultResponse = {
  headers: map[string]string(name='headers'),
  body: GetMediaAuditResultResponseBody(name='body'),
}

async function getMediaAuditResult(request: GetMediaAuditResultRequest): GetMediaAuditResultResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMediaAuditResult', 'POST', '/', 'json', false, 'json', request);
}

model GetMediaAuditResultDetailRequest {
  mediaId: string(name='MediaId', description='The category of the pornographic content review result. Valid values:

*   **normal**
*   **porn**
*   **sexy**', example='93ab850b4f6f*****54b6e91d24d81d4', position='Query'),
  pageNo: int32(name='PageNo', description='The score of the review result category. It is representative of the confidence. Valid values: `[0.00-100.00].` The value is rounded down to 10 decimal places.', example='1', position='Query'),
}

model GetMediaAuditResultDetailResponseBody = {
  mediaAuditResultDetail?: {
    list?: [ 
      {
        adLabel?: string(name='AdLabel', description='The score of the review result category. It is representative of the confidence. Valid values: `[0.00-100.00].` The value is rounded down to 10 decimal places.', example='normal'),
        adScore?: string(name='AdScore', description='The ID of the request.', example='100'),
        liveLabel?: string(name='LiveLabel', description='The position in the video. Unit: milliseconds.', example='normal'),
        liveScore?: string(name='LiveScore', example='100'),
        logoLabel?: string(name='LogoLabel', example='normal'),
        logoScore?: string(name='LogoScore', example='100'),
        pornLabel?: string(name='PornLabel', description='The ID of the video.', example='normal'),
        pornScore?: string(name='PornScore', description='The category of the logo review result. Valid values:

*   **normal**
*   **tlogo**', example='100.00'),
        terrorismLabel?: string(name='TerrorismLabel', example='normal'),
        terrorismScore?: string(name='TerrorismScore', description='The URL of the image.', example='100.00'),
        timestamp?: string(name='Timestamp', description='The review results returned.', example='3005'),
        url?: string(name='Url', description='The category of the ad review result. Valid values:

*   **normal**: normal content
*   **ad**: ad or text violation', example='http://temp-testbucket.oss-cn-shanghai.aliyuncs.com/aivideocensor/****.jpg'),
      }
    ](name='List', description='The operation that you want to perform. Set the value to **GetMediaAuditResultDetail**.'),
    total?: int32(name='Total', description='The score of the review result category. It is representative of the confidence. Valid values: `[0.00-100.00].` The value is rounded down to 10 decimal places.', example='2'),
  }(name='MediaAuditResultDetail', description='The total number of snapshots returned.'),
  requestId?: string(name='RequestId', description='The category of the terrorist content review result.

*   **normal**: normal
*   **terrorism**: terrorist content
*   **outfit**: special costume
*   **logo**: special logo
*   **weapon**: weapon
*   **politics**: politically sensitive content
*   **others**: other terrorist content and politically sensitive content', example='6438BD76-D523-46FC-956F-****'),
}

model GetMediaAuditResultDetailResponse = {
  headers: map[string]string(name='headers'),
  body: GetMediaAuditResultDetailResponseBody(name='body'),
}

/**
  * Details about review results.
  *
 */
async function getMediaAuditResultDetail(request: GetMediaAuditResultDetailRequest): GetMediaAuditResultDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMediaAuditResultDetail', 'POST', '/', 'json', false, 'json', request);
}

model GetMediaAuditResultTimelineRequest {
  mediaId: string(name='MediaId', description='The category of the review result. Valid values:

*   **normal**
*   **logo**', example='93ab850b4f6f*****54b6e91d24d81d4', position='Query'),
}

model GetMediaAuditResultTimelineResponseBody = {
  mediaAuditResultTimeline?: {
    ad?: [ 
      {
        label?: string(name='Label', example='ad'),
        score?: string(name='Score', example='100'),
        timestamp?: string(name='Timestamp', example='10'),
      }
    ](name='Ad'),
    live?: [ 
      {
        label?: string(name='Label'),
        score?: string(name='Score', example='100'),
        timestamp?: string(name='Timestamp', example='12'),
      }
    ](name='Live', description='Queries the timelines of all snapshots that violate content regulations.'),
    logo?: [ 
      {
        label?: string(name='Label', description='The ID of the request.', example='The category of the review result. Valid values:

*   **porn**
*   **sexy**
*   **normal**'),
        score?: string(name='Score', description='The category of the review result. Valid values:

*   **normal**: normal content
*   **ad**: ad or text violation', example='100'),
        timestamp?: string(name='Timestamp', description='The score of the review result category. Valid values: `[0, 100]`. The value is rounded down to 10 decimal places. The score is representative of the confidence.', example='13'),
      }
    ](name='Logo', description='The score of the review result category. Valid values: `[0, 100]`. The value is rounded down to 10 decimal places. The score is representative of the confidence.'),
    porn?: [ 
      {
        label?: string(name='Label', description='The collection of logo timelines.', example='porn'),
        score?: string(name='Score', description='The category of the review result. Valid values:

*   **normal**
*   **terrorism**', example='100.00'),
        timestamp?: string(name='Timestamp', description='The operation that you want to perform. Set the value to **GetMediaAuditResultTimeline**.', example='3005'),
      }
    ](name='Porn', description='The score of the review result category. Valid values: `[0, 100]`. The value is rounded down to 10 decimal places. The score is representative of the confidence.'),
    terrorism?: [ 
      {
        label?: string(name='Label', description='The collection of pornographic content timelines.', example='normal'),
        score?: string(name='Score', description='The collection of review result timelines.', example='100.00'),
        timestamp?: string(name='Timestamp', description='The collection of undesirable scene timelines.', example='3005'),
      }
    ](name='Terrorism', description='The ID of the video.'),
  }(name='MediaAuditResultTimeline', description='The position in the video. Unit: milliseconds.'),
  requestId?: string(name='RequestId', description='The position in the video. Unit: milliseconds.', example='6438BD76-D523-46FC-956F-****'),
}

model GetMediaAuditResultTimelineResponse = {
  headers: map[string]string(name='headers'),
  body: GetMediaAuditResultTimelineResponseBody(name='body'),
}

async function getMediaAuditResultTimeline(request: GetMediaAuditResultTimelineRequest): GetMediaAuditResultTimelineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMediaAuditResultTimeline', 'POST', '/', 'json', false, 'json', request);
}

model GetMediaDNAResultRequest {
  mediaId: string(name='MediaId', description='The ID of the video.', example='88c6ca184c0e*****a5b665e2a126797', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: string(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: string(name='ResourceOwnerId', position='Query'),
}

model GetMediaDNAResultResponseBody = {
  DNAResult?: {
    videoDNA?: [ 
      {
        detail?: [ 
          {
            duplication?: {
              duration?: string(name='Duration', example='12.0'),
              start?: string(name='Start', example='2.0'),
            }(name='Duplication', description='Queries a media fingerprinting result. After a media fingerprinting job is complete, you can call this operation to query the media fingerprinting result.'),
            input?: {
              duration?: string(name='Duration', description='The start time of the video. Unit: seconds.', example='12.0'),
              start?: string(name='Start', description='The duration of the video. Unit: seconds.', example='2.0'),
            }(name='Input', description='The ID of the request.'),
          }
        ](name='Detail', description='The duration of the video. Unit: seconds.'),
        primaryKey?: string(name='PrimaryKey', description='The start time and duration of the input video.', example='6ad8987da46f4b*****490ce2873745'),
        similarity?: string(name='Similarity', description='The video fingerprint recognition result.', example='0.98'),
      }
    ](name='VideoDNA', description='The media fingerprinting results.'),
  }(name='DNAResult', description='The similarity between the fingerprints of the input video and the matched video. 1 indicates that the fingerprints of the two videos are the same.'),
  requestId?: string(name='RequestId', description='The start time of the video. Unit: seconds.', example='63FC4896-E956-4B*****7D-134FF1BC597A'),
}

model GetMediaDNAResultResponse = {
  headers: map[string]string(name='headers'),
  body: GetMediaDNAResultResponseBody(name='body'),
}

/**
  * The details of the matched video. Information such as the location and duration of the video is returned.
  *
 */
async function getMediaDNAResult(request: GetMediaDNAResultRequest): GetMediaDNAResultResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMediaDNAResult', 'POST', '/', 'json', false, 'json', request);
}

model GetMediaRefreshJobsRequest {
  mediaId?: string(name='MediaId', description='The ID of the media file. It is the value of the `MediaIds` parameter that you specify when you call the [RefreshMediaPlayUrls](~~RefreshMediaPlayUrls~~) operation. You can specify only one media ID.

If you leave this parameter empty, information about all media files in the refresh or prefetch job specified by `MediaRefreshJobId` is returned. If you set this parameter, only the information about the specified media file is returned.``', example='ca3a8f6e4957b658067095869****', position='Query'),
  mediaRefreshJobId: string(name='MediaRefreshJobId', description='The ID of the refresh or prefetch job. It is the value of the MediaRefreshJobId parameter that is returned from the call to the [RefreshMediaPlayUrls](~~RefreshMediaPlayUrls~~) operation.', example='41d465e31957****', position='Query'),
}

model GetMediaRefreshJobsResponseBody = {
  mediaRefreshJobs?: [ 
    {
      errorCode?: string(name='ErrorCode', description='The error code. This parameter is returned if the refresh or prefetch task fails.', example='PreloadQueueFull'),
      errorMessage?: string(name='ErrorMessage', description='The error message. This parameter is returned if the refresh or prefetch task fails.', example='Preload queue is full, please try again later!'),
      filterPolicy?: string(name='FilterPolicy', description='The filtering conditions for stream playback. The value is a JSON string. This parameter is used as a request parameter of the [RefreshMediaPlayUrls](~~RefreshMediaPlayUrls~~) operation.', example='{"Formats":"mp4,m3u8", "Definitions":"HD,SD",  " StreamType":"video",  "ResultType":"Single",  " SliceFlag":false, "SliceCount": 3}'),
      gmtCreate?: string(name='GmtCreate', description='The time when the task was created.', example='2022-05-20T08:23:22Z'),
      gmtModified?: string(name='GmtModified', description='The time when the task was modified.', example='2022-05-21T08:23:22Z'),
      mediaId?: string(name='MediaId', description='The ID of the media file.', example='ca3a8f6e4957b658067095869****'),
      mediaRefreshJobId?: string(name='MediaRefreshJobId', description='The ID of the job.', example='41d465e31957****'),
      status?: string(name='Status', description='The status of the job. Valid values:

*   **success**
*   **fail**', example='success'),
      successPlayUrls?: string(name='SuccessPlayUrls', description='The playback URLs that were refreshed or prefetched.', example='https://shenzhen.****.aliyuncdn.com/74401a4f546007bf845cd8840****.m3u8,https://shenzhen.****.aliyuncdn.com/24041e7d13582d86604d8****.m3u8'),
      taskIds?: string(name='TaskIds', description='The IDs of the refresh or prefetch tasks for the playback URLs of media files. Only one URL can be refreshed or prefetched in a task. This value is used in the [DescribeVodRefreshTasks](~~DescribeVodRefreshTasks~~) operation, which queries the status of refresh or prefetch tasks for playback URLs of media files.', example='70422****,9524****'),
      taskType?: string(name='TaskType', description='The type of the job. Valid values:

*   **Refresh**
*   **Preload**', example='Preload'),
      userData?: string(name='UserData', description='The user data that you passed when you submit a refresh or prefetch task.', example='{"MessageCallback":{"CallbackURL":"http://example.aliyundoc.com"}, "Extend":{"localId":"xxx","test":"www"}}'),
    }
  ](name='MediaRefreshJobs', description='The media refresh or prefetch jobs.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='25818875-5F78-4AF6-D7393642CA58****'),
}

model GetMediaRefreshJobsResponse = {
  headers: map[string]string(name='headers'),
  body: GetMediaRefreshJobsResponseBody(name='body'),
}

/**
  * You can query the information about all media files or a specific media file in a refresh or prefetch job.
  * ### QPS limits
  * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits on API operations in ApsaraVideo VoD](~~342790~~).
  *
 */
async function getMediaRefreshJobs(request: GetMediaRefreshJobsRequest): GetMediaRefreshJobsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMediaRefreshJobs', 'GET', '/', 'json', false, 'json', request);
}

model GetMessageCallbackRequest {
  appId?: string(name='AppId', description='The ID of the application. If you do not set this parameter, the default value **app-1000000** is used.', example='app-1000000', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
}

model GetMessageCallbackResponseBody = {
  messageCallback?: {
    appId?: string(name='AppId', description='The ID of the application.', example='app-1000000'),
    authKey?: string(name='AuthKey', description='The cryptographic key. This parameter is returned only for HTTP callbacks.', example='12345678abc'),
    authSwitch?: string(name='AuthSwitch', description='Indicates whether callback authentication is enabled. This parameter is returned only for HTTP callbacks. Valid values:

*   **on**: indicates that authentication is enabled.
*   **off**: indicates that authentication is disabled.', example='on'),
    callbackType?: string(name='CallbackType', description='The callback method. Valid values:

*   **HTTP**
*   **MNS**', example='HTTP'),
    callbackURL?: string(name='CallbackURL', description='The callback URL. This parameter is returned only for HTTP callbacks.', example='http://test.com/test'),
    eventTypeList?: string(name='EventTypeList', description='The type of the callback event.', example='FileUploadComplete,StreamTranscodeComplete,TranscodeComplete,SnapshotComplete,AIComplete,AddLiveRecordVideoComplete,CreateAuditComplete,UploadByURLComplete,ProduceMediaComplete,LiveRecordVideoComposeStart,ImageUploadComplete,VideoAnalysisComplete'),
    mnsEndpoint?: string(name='MnsEndpoint', description='The public endpoint of Message Service (MNS). This parameter is returned only for MNS callbacks.', example='http://1234567.mns.cn-shanghai-internal.aliyuncs.com/'),
    mnsQueueName?: string(name='MnsQueueName', description='The name of the MNS queue. This parameter is returned only for MNS callbacks.', example='vodcallback'),
  }(name='MessageCallback', description='The configuration of the event notification.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='272A222A-F7F7-4A3E-****-F531574F1234'),
}

model GetMessageCallbackResponse = {
  headers: map[string]string(name='headers'),
  body: GetMessageCallbackResponseBody(name='body'),
}

/**
  * > For more information, see [Overview](~~55627~~).
  *
 */
async function getMessageCallback(request: GetMessageCallbackRequest): GetMessageCallbackResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMessageCallback', 'POST', '/', 'json', false, 'json', request);
}

model GetMezzanineInfoRequest {
  additionType?: string(name='AdditionType', description='The ID of the video.', example='video', position='Query'),
  authTimeout?: long(name='AuthTimeout', description='The type of the mezzanine file URL. Valid values:

- **oss**: OSS URL
- **cdn** (default): CDN URL

> If you specify an OSS URL for the video stream, the video stream must be in the MP4 format.', example='3600', position='Query'),
  outputType?: string(name='OutputType', description='The frame rate of the file. Unit: frames per second.', example='oss', position='Query'),
  videoId: string(name='VideoId', description='The operation that you want to perform. Set the value to **GetMezzanineInfo**.', example='1f1a6fc03ca04814031b8a6559e****', position='Query'),
}

model GetMezzanineInfoResponseBody = {
  mezzanine?: {
    audioStreamList?: [ 
      {
        bitrate?: string(name='Bitrate', description='The information about the video stream.', example='62.885'),
        channelLayout?: string(name='ChannelLayout', description='The target frame rate.', example='mono'),
        channels?: string(name='Channels', description='The width of the video resolution.', example='1'),
        codecLongName?: string(name='CodecLongName', description='The time when the file was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='AAC (Advanced Audio Coding)'),
        codecName?: string(name='CodecName', description='The duration of the video stream.', example='aac'),
        codecTag?: string(name='CodecTag', description='The sequence number of the audio stream, which specifies the position of the audio stream in all audio streams.', example='0x6134706d'),
        codecTagString?: string(name='CodecTagString', description='The tag of the codec format.', example='mp4a'),
        codecTimeBase?: string(name='CodecTimeBase', description='The full name of the codec format.', example='1/44100'),
        duration?: string(name='Duration', description='The name of the file.', example='3.227574'),
        index?: string(name='Index', description='The short name of the codec format.', example='0'),
        lang?: string(name='Lang', description='The bitrate of the file. Unit: Kbit/s.', example='und'),
        numFrames?: string(name='NumFrames', description='The codec profile.', example='1'),
        sampleFmt?: string(name='SampleFmt', description='The status of the file. Valid values:

*   **Uploading**: The file is being uploaded. This is the initial status.
*   **Normal**: The file is uploaded.
*   **UploadFail**: The file fails to be uploaded.
*   **Deleted**: The file is deleted.', example='fltp'),
        sampleRate?: string(name='SampleRate', description='The size of the file. Unit: byte.', example='44100'),
        startTime?: string(name='StartTime', description='The sample rate.', example='2017-01-11T12:00:00Z'),
        timebase?: string(name='Timebase', description='The ID of the video.', example='0.000000'),
      }
    ](name='AudioStreamList', description='The language.'),
    bitrate?: string(name='Bitrate', description='The type of the mezzanine file URL. Valid values:

- **oss**: OSS URL
- **cdn** (default): Content Delivery Network (CDN) URL

> If the mezzanine file is stored in a bucket of the in type, only an OSS URL is returned.', example='771.2280'),
    creationTime?: string(name='CreationTime', description='The information about the mezzanine file.', example='2017-11-14T09:15:50Z'),
    duration?: string(name='Duration', description='The type of additional information. Separate multiple values with commas (,). By default, only the basic information is returned. Valid values:

*   **video**: video stream information
*   **audio**: audio stream information', example='42.4930'),
    fileName?: string(name='FileName', description='The language.', example='27ffc438-164h67f57ef-0005-6884-51a-1****.mp4'),
    fileURL?: string(name='FileURL', description='The beginning of the time range that was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='http://example-bucket-****.oss-cn-shanghai.aliyuncs.com/27ffc438-164h67f57ef-0005-6884-51a-1****.mp4'),
    fps?: string(name='Fps', description='The sample aspect ratio.', example='25.0000'),
    height?: long(name='Height', description='The height of the video resolution.', example='540'),
    outputType?: string(name='OutputType', description='The total number of frames.', example='oss'),
    restoreExpiration?: string(name='RestoreExpiration'),
    restoreStatus?: string(name='RestoreStatus'),
    size?: long(name='Size', description='The duration of the file. Unit: seconds.', example='4096477'),
    status?: string(name='Status', description='The validity period of the mezzanine file URL. Unit: seconds. Default value: **1800**. Minimum value: **1**.

*   If the OutputType parameter is set to **cdn**:

    *   The mezzanine file URL has a validity period only if URL signing is enabled. Otherwise, the mezzanine file URL is permanently valid.
    *   Minimum value: **1**.
    *   Maximum Value: unlimited.
    *   Default value: If you do not set this parameter, the default validity period that is specified in URL signing is used.

<!---->

*   If the OutputType parameter is set to **oss**:

    *   The mezzanine file URL has a validity period only if the permissions on the Object Storage Service (OSS) bucket are private. Otherwise, the mezzanine file URL is permanently valid.
    *   Minimum value: **1**.
    *   Maximum value: **2592000** (30 days). The maximum value is limited to reduce security risks of the origin.
    *   Default value: If you do not set this parameter, the default value is **3600**.', example='Normal'),
    storageClass?: string(name='StorageClass'),
    videoId?: string(name='VideoId', description='The average frame rate.', example='1f1a6fc03ca04814031b8a6559e****'),
    videoStreamList?: [ 
      {
        avgFPS?: string(name='AvgFPS', description='The beginning of the time range that was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='30.0'),
        bitrate?: string(name='Bitrate', description='The URL of the file.', example='500'),
        codecLongName?: string(name='CodecLongName', description='The codec time base.', example='H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10'),
        codecName?: string(name='CodecName', example='h264'),
        codecTag?: string(name='CodecTag', example='0x31637661'),
        codecTagString?: string(name='CodecTagString', description='The tag string of the codec format.', example='avc1'),
        codecTimeBase?: string(name='CodecTimeBase', example='1/60'),
        dar?: string(name='Dar', description='Queries the information about the mezzanine file of an audio or video. The information includes the mezzanine file URL, resolution, and bitrate of the audio or video.', example='0:1'),
        duration?: string(name='Duration', example='3.166667'),
        fps?: string(name='Fps', example='30.0'),
        HDRType?: string(name='HDRType', description='视频流HDR类型', example='HDR'),
        hasBFrames?: string(name='HasBFrames', description='The rotation angle of the video. Valid values: **\\[0, 360)**.', example='0'),
        height?: string(name='Height', description='The number of sound channels.', example='320'),
        index?: string(name='Index', description='The sequence number of the video stream, which indicates the position of the video stream in all video streams.', example='1'),
        lang?: string(name='Lang', description='The information about the audio stream.', example='und'),
        level?: string(name='Level', example='30'),
        numFrames?: string(name='NumFrames', description='The time base.', example='0'),
        pixFmt?: string(name='PixFmt', description='The short name of the codec format.', example='yuv420p'),
        profile?: string(name='Profile', description='The ID of the request.', example='Main'),
        rotate?: string(name='Rotate', description='The duration of the audio stream.', example='90'),
        sar?: string(name='Sar', description='The width of the file. Unit: pixel.', example='0:1'),
        startTime?: string(name='StartTime', description='The height of the file. Unit: pixel.', example='2017-01-11T12:00:00Z'),
        timebase?: string(name='Timebase', description='The pixel format.', example='0.000000'),
        width?: string(name='Width', example='568'),
      }
    ](name='VideoStreamList', description='The output layout of the sound channels. Valid values:

*   **mono**: mono sound channel
*   **stereo**: two sound channels'),
    width?: long(name='Width', description='The tag of the codec format.', example='960'),
  }(name='Mezzanine', description='The time base.'),
  requestId?: string(name='RequestId', description='The codec time base.', example='25818875-5F78-4AF6-D7393642CA58****'),
}

model GetMezzanineInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetMezzanineInfoResponseBody(name='body'),
}

/**
  * The sampling format.
  *
 */
async function getMezzanineInfo(request: GetMezzanineInfoRequest): GetMezzanineInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMezzanineInfo', 'POST', '/', 'json', false, 'json', request);
}

model GetPlayInfoRequest {
  additionType?: string(name='AdditionType', description='The ID of the media transcoding job. This ID uniquely identifies a media stream.', example='danmu', position='Query'),
  authTimeout?: long(name='AuthTimeout', description='The frame rate of the media stream. Unit: frames per second.', example='1800', position='Query'),
  definition?: string(name='Definition', description='The type of Narrowband HD transcoding. Valid values:

*   **0**: regular
*   **1.0**: Narrowband HD 1.0
*   **2.0**: Narrowband HD 2.0

This parameter is returned only when a quality that is available in the built-in Narrowband HD 1.0 transcoding template is specified. For more information, see the [Definition parameter in the TranscodeTemplate](~~52839~~) table.', example='LD', position='Query'),
  formats?: string(name='Formats', description='The update time. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='mp4,m3u8', position='Query'),
  outputType?: string(name='OutputType', description='The URL of the masked live comment data. Set the value to **danmu**.

> This parameter takes effect only when the outputType parameter is set to **cdn**.', example='cdn', position='Query'),
  playConfig?: string(name='PlayConfig', description='The quality of the video stream. Valid values:

*   **FD**: low definition
*   **LD**: standard definition
*   **SD**: high definition
*   **HD**: ultra-high definition
*   **OD**: original definition
*   **2K**: 2K
*   **4K**: 4K
*   **SQ**: standard sound quality
*   **HQ**: high sound quality
*   **AUTO**: adaptive bitrate', example='{"PlayDomain":"vod.test_domain","XForwardedFor":"yqCD7Fp1uqChoVj/sl/p5Q==","PreviewTime":"20","MtsHlsUriToken":"yqCD7Fp1uqChoVjslp5Q"}', position='Query'),
  reAuthInfo?: string(name='ReAuthInfo', description='The playback URL of the video stream.', example='{"uid":"12345","rand":"abckljd"}', position='Query'),
  resultType?: string(name='ResultType', description='The time when the audio or video file was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='Single', position='Query'),
  streamType?: string(name='StreamType', description='Details of the audio or video file.', example='video', position='Query'),
  videoId: string(name='VideoId', description='The basic information about the audio or video file.', example='93ab850b4f654b6e91d24d81d44****', position='Query'),
}

model GetPlayInfoResponseBody = {
  playInfoList?: {
    playInfo?: [ 
    {
      bitDepth?: int32(name='BitDepth', description='颜色位深', example='8'),
      bitrate?: string(name='Bitrate', description='The format of the media stream. Separate multiple formats with commas (,). Valid values:

*   **mp4**
*   **m3u8**
*   **mp3**
*   **mpd**

> By default, ApsaraVideo VOD returns video streams in all the preceding formats. However, video streams in the MPD format are returned only if the MPD container format is specified in the transcoding template. For more information, see the [Container parameter in the TranscodeTemplate](~~52839~~) table.', example='450.878'),
      creationTime?: string(name='CreationTime', description='The status of the media stream. Valid values:

*   **Normal**
*   **Invisible**', example='2022-04-18T07:37:15Z'),
      definition?: string(name='Definition', description='The color depth. This value must be an integer.', example='LD'),
      duration?: string(name='Duration', description='The encryption type of the media stream. Valid values:

*   **AliyunVoDEncryption**: Alibaba Cloud proprietary cryptography
*   **HLSEncryption**: HTTP Live Streaming (HLS) encryption

> If the encryption type is**AliyunVoDEncryption**, only ApsaraVideo Player SDK can be used to play videos.', example='9.0464'),
      encrypt?: long(name='Encrypt', description='The status of the audio or video file. For more information about the value range and description, see the [Status](~~52839~~) table.', example='1'),
      encryptType?: string(name='EncryptType', description='The title of the audio or video file.', example='AliyunVoDEncryption'),
      format?: string(name='Format', description='Queries the playback URL of a video or audio file by its ID.', example='m3u8'),
      fps?: string(name='Fps', description='The type of the output URL. Default value: oss. Valid values:

*   **oss**
*   **cdn**', example='25'),
      HDRType?: string(name='HDRType', description='视频流HDR类型', example='HLG'),
      height?: long(name='Height', description='The returned result.', example='640'),
      jobId?: string(name='JobId', description='The type of the media file. Valid values:

*   **video**
*   **audio**', example='80e9c6580e754a798c3c19c59b16****'),
      modificationTime?: string(name='ModificationTime', description='The validity period of the playback URL. Unit: seconds.

*   If the OutputType parameter is set to **cdn**:

    *   This parameter takes effect only if URL authentication is enabled. Otherwise, the playback URL does not expire.
    *   Minimum value: **1**.
    *   Maximum value: unlimited.
    *   Default value: The default validity period that is specified in URL authentication is used.

*   If the OutputType parameter is set to **oss**:

    *   This parameter takes effect only when the ACL of the Object Storage Service (OSS) bucket is private. Otherwise, the playback URL does not expire.
    *   Minimum value: **1**.
    *   Maximum value: **2592000** (30 days). This limit is imposed to reduce security risks of the origin server.
    *   Default value: **3600**.', example='2022-04-20T06:32:19Z'),
      narrowBandType?: string(name='NarrowBandType', description='The type of the data to return. Default value: Single. Valid values:

*   **Single**: Only one latest transcoded stream is returned for each quality and format.
*   **Multiple**: All transcoded streams are returned for each quality and format.', example='0'),
      playURL?: string(name='PlayURL', description='The ID of the request.', example='https://example.aliyundoc.com/d52ee123f331466aabf6ab32a93d****/a777f9e24e6e47a2a942467d5c38ea37-8ee8e04293c6657fdda282bc422704****.m3u8'),
      size?: long(name='Size', description='The custom playback configuration. The value is a JSON string. For more information, see [PlayConfig](~~86952~~).

> 

*   If you do not specify PlayConfig or `PlayDomain` in PlayConfig, the default domain name configured in ApsaraVideo VOD is used in this operation. If no default domain name is configured, the domain names are queried in reverse chronological order based on the time when the domain names were modified. The domain name that was last modified is used as the streaming domain name. To prevent domain name issues, we recommend that you specify the default streaming domain name. You can log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com) and choose **Configuration Management** > **Media Management** > **Storage** > **Manage** > **Origin Domain Name** to set the default streaming domain name.

*   If the `EncryptType` parameter in PlayConfig is set to `AliyunVoDEncryption`, the playback URL of the stream encrypted by using proprietary cryptography is not returned to ensure video security. If you want to return such URL, you must set the `ResultType` parameter to `Multiple`.', example='418112'),
      specification?: string(name='Specification', description='The size of the media stream. Unit: bytes.', example='H264.LD'),
      status?: string(name='Status', description='The specifications of transcoded audio and video streams. For more information about the valid values, see [Output specifications](~~124671~~).', example='Normal'),
      streamType?: string(name='StreamType', description='The bitrate of the media stream. Unit: Kbit/s.', example='video'),
      watermarkId?: string(name='WatermarkId', description='The quality of the video stream. Separate multiple qualities with commas (,). Valid values:

*   **FD**: low definition
*   **LD**: standard definition
*   **SD**: high definition
*   **HD**: ultra-high definition
*   **OD**: original definition
*   **2K**: 2K
*   **4K**: 4K
*   **SQ**: standard sound quality
*   **HQ**: high sound quality
*   **AUTO**: adaptive bitrate

> By default, ApsaraVideo VOD returns video streams in all preceding qualities. However, video streams for adaptive bitrate streaming are returned only if the PackageSetting parameter is specified in the transcoding template. For more information, see the [PackageSetting parameter in the TranscodeTemplate](~~52839~~) table.', example='dgfn26457856****'),
      width?: long(name='Width', description='Indicates whether the video stream was encrypted. Valid values:

*   **0**: no
*   **1**: yes', example='360'),
    }
  ](name='PlayInfo')
  }(name='PlayInfoList', description='The height of the media stream. Unit: pixels.'),
  requestId?: string(name='RequestId', description='The information about the audio or video stream.', example='F552E596-967D-5500-842F-17E6364****'),
  videoBase?: {
    coverURL?: string(name='CoverURL', description='ApsaraVideo VOD', example='http://example.aliyundoc.com/sample.jpg?auth_key=2333232-atb****'),
    creationTime?: string(name='CreationTime', description='The type of the media stream. Separate multiple types with commas (,). Valid values:

*   **video**
*   **audio**

By default, video and audio streams are returned.', example='2017-06-26T06:38:48Z'),
    danMuURL?: string(name='DanMuURL', description='The time when the audio or video file was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='http://example.aliyundoc.com/****?auth_key=abdf2123-6783232****'),
    duration?: string(name='Duration', description='The ID of the watermark that is associated with the media stream.', example='3.1667'),
    mediaType?: string(name='MediaType', description='The ID of the audio or video file. You can use one of the following methods to obtain the ID of the file:

*   Log on to the [ApsaraVideo VOD](https://vod.console.aliyun.com) console. In the left-side navigation pane, choose **Media Files** > **Audio/Video**. On the Video and Audio page, you can view the ID of the audio or video file. This method is applicable to files that are uploaded by using the ApsaraVideo VOD console.
*   Obtain the value of the VideoId parameter when you call the [CreateUploadVideo](~~55407~~) operation to upload files.
*   Obtain the value of the VideoId parameter by calling the [SearchMedia](~~86044~~) operation. This method is applicable to files that have been uploaded.', example='video'),
    status?: string(name='Status', description='The thumbnail URL of the audio or video file.', example='Normal'),
    title?: string(name='Title', description='The format of the media stream.

*   If the media file is a video file, the valid values are **mp4** and **m3u8**.
*   If the media file is an audio-only file, the value is **mp3**.', example='The CDN reauthentication configuration. The value is a JSON string. If CDN reauthentication is enabled, you can use this parameter to specify the UID and rand fields for URL authentication. For more information, see [URL authentication](~~57007~~).'),
    videoId?: string(name='VideoId', description='The type of the media stream. If the media stream is a video stream, the value is **video**. If the media stream is an audio-only stream, the value is **audio**.', example='93ab850b4f654b6e91d24d81d44****'),
  }(name='VideoBase', description='The width of the media stream. Unit: pixels.'),
}

model GetPlayInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetPlayInfoResponseBody(name='body'),
}

/**
  * The ID of the media file.
  *
 */
async function getPlayInfo(request: GetPlayInfoRequest): GetPlayInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetPlayInfo', 'POST', '/', 'json', false, 'json', request);
}

model GetTranscodeSummaryRequest {
  videoIds: string(name='VideoIds', description='The ID of the audio or video file. You can specify up to 10 IDs. Separate the IDs with commas (,). You can use one of the following methods to obtain the ID:

*   Log on to the [ApsaraVideo VOD](https://vod.console.aliyun.com) console. In the left-side navigation pane, choose **Media Files** > **Audio/Video**. On the Video and Audio page, view the ID of the audio or video file. This method is applicable to files that are uploaded by using the ApsaraVideo VOD console.
*   Obtain the value of VideoId from the response to the [CreateUploadVideo](~~55407~~) operation that you call to obtain the upload URL and credential.
*   Obtain the value of VideoId by calling the [SearchMedia](~~86044~~) operation. This method is applicable to files that have been uploaded.', example='"d4860fcc6ae9fed52e8938244****,e1db68cc586644b83e562bcd94****,hhhhhhh"', position='Query'),
}

model GetTranscodeSummaryResponseBody = {
  nonExistVideoIds?: [ string ](name='NonExistVideoIds', description='The IDs of the audio or video files that do not exist.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='25818875-5F78-4A*****F6-D7393642CA58'),
  transcodeSummaryList?: [ 
    {
      completeTime?: string(name='CompleteTime', description='The time when the transcoding task was complete. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2019-01-23T12:40:12Z'),
      creationTime?: string(name='CreationTime', description='The time when the transcoding task was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2019-01-23T12:35:12Z'),
      transcodeJobInfoSummaryList?: [ 
        {
          bitrate?: string(name='Bitrate', description='The average bitrate of the output video. Unit: Kbit/s.', example='749'),
          completeTime?: string(name='CompleteTime', description='The time when the transcoding job was complete. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2019-02-27T03:40:51Z'),
          creationTime?: string(name='CreationTime', description='The time when the transcoding job was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2019-02-27T03:34:46Z'),
          duration?: string(name='Duration', description='The duration of the output video. Unit: seconds.', example='12'),
          errorCode?: string(name='ErrorCode', description='The error code returned when the transcoding job failed.', example='200'),
          errorMessage?: string(name='ErrorMessage', description='The error message returned when the transcoding job failed.', example='ErrorMessage'),
          filesize?: long(name='Filesize', description='The size of the output video. Unit: bytes.', example='1144259'),
          format?: string(name='Format', description='The container format of the output video.', example='mp4'),
          fps?: string(name='Fps', description='The frame rate of the output video. Unit: frames per second.', example='30'),
          height?: string(name='Height', description='The height of the output video. Unit: pixels.', example='960'),
          transcodeJobStatus?: string(name='TranscodeJobStatus', description='The status of the transcoding job. Valid values:
*   **Transcoding**
*   **TranscodeSuccess**
*   **TranscodeFail**', example='Transcoding'),
          transcodeProgress?: long(name='TranscodeProgress', description='The transcoding progress. Valid values: `[0,100]`.', example='100'),
          transcodeTemplateId?: string(name='TranscodeTemplateId', description='The ID of the transcoding template.', example='57496724ae2*****0968d6e08acc8f6'),
          watermarkIdList?: [ string ](name='WatermarkIdList', description='The IDs of the watermarks that are applied to the output video.'),
          width?: string(name='Width', description='The width of the output video. Unit: pixels.', example='544'),
        }
      ](name='TranscodeJobInfoSummaryList', description='The summaries of transcoding jobs.'),
      transcodeStatus?: string(name='TranscodeStatus', description='The status of the transcoding task. Valid values:
*   **Processing**: In progress.
*   **Partial**: Some transcoding jobs were complete.
*   **CompleteAllSucc**: All transcoding jobs were successful.
*   **CompleteAllFail**: All transcoding jobs failed. If an exception occurs in the source file, no transcoding job is initiated and the transcoding task fails.
*   **CompletePartialSucc**: All transcoding jobs were complete but only some were successful.', example='Processing'),
      transcodeTemplateGroupId?: string(name='TranscodeTemplateGroupId', description='The ID of the transcoding template group.', example='44f9e406bbb*****736a9abe876ecc0'),
      videoId?: string(name='VideoId', description='The ID of the audio or video file.', example='e1db68cc586644b83e562bcd94****'),
    }
  ](name='TranscodeSummaryList', description='The transcoding summary of the file.'),
}

model GetTranscodeSummaryResponse = {
  headers: map[string]string(name='headers'),
  body: GetTranscodeSummaryResponseBody(name='body'),
}

/**
  * *   A media file may be transcoded multiple times. This operation returns only the latest transcoding summary.
  * *   You can query transcoding summaries for a maximum of 10 media files in one request.
  * *   You can call the [ListTranscodeTask](~~109120~~) operation to query historical transcoding tasks.
  * *   **You can call this operation to query information only about transcoding tasks created within the past year.**
  *
 */
async function getTranscodeSummary(request: GetTranscodeSummaryRequest): GetTranscodeSummaryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetTranscodeSummary', 'POST', '/', 'json', false, 'json', request);
}

model GetTranscodeTaskRequest {
  transcodeTaskId: string(name='TranscodeTaskId', description='The OSS URL of the output file.', example='b1b65ab107e14*****3dbb900f6c1fe0', position='Query'),
}

model GetTranscodeTaskResponseBody = {
  requestId?: string(name='RequestId', description='The size of the output file. Unit: byte.', example='F4C6D5BE-BF13-45*****6C-516EA8906DCD'),
  transcodeTask?: {
    completeTime?: string(name='CompleteTime', description='The Object Storage Service (OSS) URL of the input file.', example='2019-01-23T12:40:12Z'),
    creationTime?: string(name='CreationTime', description='The operation that you want to perform. Set the value to **GetTranscodeTask**.', example='2019-01-23T12:35:12Z'),
    taskStatus?: string(name='TaskStatus', description='The mode in which the transcoding task is triggered. Valid values:

*   **Auto**: The transcoding task is automatically triggered when the video is uploaded.
*   **Manual**: The transcoding task is triggered by calling the SubmitTranscodeJobs operation.', example='Processing'),
    transcodeJobInfoList?: [ 
      {
        completeTime?: string(name='CompleteTime', description='The progress of the transcoding job. Valid values: `[0,100]`.', example='2019-02-26T08:30:16Z'),
        creationTime?: string(name='CreationTime', description='The status of the transcoding job.

*   **Transcoding**
*   **TranscodeSuccess**
*   **TranscodeFail**', example='2019-02-26T08:27:16Z'),
        definition?: string(name='Definition', description='The encryption method of the output file. Valid values:

*   **AliyunVoDEncryption**: Alibaba Cloud proprietary cryptography
*   **HLSEncryption**: HTTP Live Streaming (HLS) encryption', example='LD'),
        errorCode?: string(name='ErrorCode', description='Details about transcoding jobs.', example='200'),
        errorMessage?: string(name='ErrorMessage', description='The height of the output video. Unit: pixels.', example='ErrorMessage'),
        inputFileUrl?: string(name='InputFileUrl', description='The IDs of the watermarks used by the output file.', example='http://outin-40564*****e1403e7.oss-cn-shanghai.aliyuncs.com/customerTrans/5b95e568f8e*****47f38e/31f1184c-*****b2a2-f94-c213f.wmv'),
        outputFile?: {
          audioStreamList?: string(name='AudioStreamList', description='The ID of the transcoding job.', example='"AudioStreamList": "[{\\"Bitrate\\":\\"64.533\\",\\"ChannelLayout\\":\\"stereo\\",\\"Channels\\":\\"2\\",\\"CodecLongName\\":\\"AAC (Advanced Audio Coding)\\",\\"CodecName\\":\\"aac\\",\\"CodecTag\\":\\"0x6134706d\\",\\"CodecTagString\\":\\"mp4a\\",\\"CodecTimeBase\\":\\"1/44100\\",\\"Duration\\":\\"12.615533\\",\\"Index\\":\\"1\\",\\"Lang\\":\\"und\\",\\"SampleFmt\\":\\"fltp\\",\\"Samplerate\\":\\"44100\\",\\"StartTime\\":\\"-0.046440\\",\\"Timebase\\":\\"1/44100\\"}]'),
          bitrate?: string(name='Bitrate', description='The time when the transcoding task was complete. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='964'),
          duration?: string(name='Duration', description='The frame rate of the output file. Unit: frames per second.', example='12'),
          encryption?: string(name='Encryption', description='The audio streams.', example='{\\"EncryptType\\":\\"AliyunVoDEncryption\\"}'),
          filesize?: long(name='Filesize', description='Queries details about transcoding jobs based on the transcoding task ID.', example='851076'),
          format?: string(name='Format', description='The IDs of the watermarks used by the output file.', example='m3u8'),
          fps?: string(name='Fps', description='The ID of the request.', example='25'),
          height?: string(name='Height', description='The error message returned when the transcoding job failed.', example='360'),
          outputFileUrl?: string(name='OutputFileUrl', description='The ID of the transcoding task.', example='http://outin-40564*****e1403e7.oss-cn-shanghai.aliyuncs.com/883f5d*****f20aaa352f/c3be4f073*****7d5193ec8-{DestMd5}-od-S00000001-200000.mp4'),
          subtitleStreamList?: string(name='SubtitleStreamList', description='The time when the transcoding task was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='[]'),
          videoStreamList?: string(name='VideoStreamList', description='The time when the transcoding job was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='[{\\"AvgFPS\\":\\"30.0\\",\\"Bitrate\\":\\"933.814\\",\\"CodecLongName\\":\\"H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10\\",\\"CodecName\\":\\"h264\\",\\"CodecTag\\":\\"0x31637661\\",\\"CodecTagString\\":\\"avc1\\",\\"CodecTimeBase\\":\\"1/60\\",\\"Dar\\":\\"9:16\\",\\"Duration\\":\\"12.033333\\",\\"Fps\\":\\"30.0\\",\\"HasBFrames\\":\\"2\\",\\"Height\\":\\"360\\",\\"Index\\":\\"0\\",\\"Lang\\":\\"und\\",\\"Level\\":\\"30\\",\\"PixFmt\\":\\"yuv420p\\",\\"Profile\\":\\"High\\",\\"Sar\\":\\"81:256\\",\\"StartTime\\":\\"0.000000\\",\\"Timebase\\":\\"1/15360\\",\\"Width\\":\\"640\\"}]'),
          watermarkIdList?: [ string ](name='WatermarkIdList'),
          width?: string(name='Width', description='Details about transcoding tasks.', example='640'),
        }(name='OutputFile', description='The ID of the transcoding template group.'),
        priority?: string(name='Priority', description='The subtitle streams.', example='6'),
        transcodeJobId?: string(name='TranscodeJobId', description='The ID of the audio or video file.', example='38f0e513c88*****85515f9d50be188'),
        transcodeJobStatus?: string(name='TranscodeJobStatus', description='The priority of the transcoding job.', example='Transcoding'),
        transcodeProgress?: long(name='TranscodeProgress', description='The average bitrate of the output file. Unit: Kbit/s.', example='100'),
        transcodeTemplateId?: string(name='TranscodeTemplateId', description='The status of the transcoding task. Valid values:

*   **Processing**: In progress.
*   **Partial**: Some transcoding jobs were complete.
*   **CompleteAllSucc**: All transcoding jobs were successful.
*   **CompleteAllFail**: All transcoding jobs failed. If an exception occurs in the source file, no transcoding job is initiated and the transcoding task fails.
*   **CompletePartialSucc**: All transcoding jobs were complete but only some were successful.', example='174b0534fea3*****b51c8f0ad1374'),
      }
    ](name='TranscodeJobInfoList', description='The information about the output file.'),
    transcodeTaskId?: string(name='TranscodeTaskId', description='The container format of the output file.', example='b1b65ab107e14*****3dbb900f6c1fe0'),
    transcodeTemplateGroupId?: string(name='TranscodeTemplateGroupId', description='The ID of the transcoding task. You can use one of the following methods to obtain the ID:

*   Obtain the value of TranscodeTaskId from the response to the [SubmitTranscodeJobs](~~68570~~) operation.
*   Obtain the value of TranscodeTaskId from the response to the [ListTranscodeTask](~~109120~~) operation.', example='b500c7094bd241*****3e9900752d7c3'),
    trigger?: string(name='Trigger', description='The video streams.', example='Auto'),
    videoId?: string(name='VideoId', description='The ID of the transcoding template.', example='883f5d98107*****b7f20aaa352f'),
  }(name='TranscodeTask', description='The length of the output file. Unit: seconds.'),
}

model GetTranscodeTaskResponse = {
  headers: map[string]string(name='headers'),
  body: GetTranscodeTaskResponseBody(name='body'),
}

/**
  * The video resolution. Valid values:
  * *   **LD**: low definition
  * *   **SD**: standard definition
  * *   **HD**: high definition
  * *   **FHD**: ultra high definition
  * *   **OD**: original definition
  * *   **2K**: 2K
  * *   **4K**: 4K
  * *   **SQ**: standard sound quality
  * *   **HQ**: high sound quality
  * *   **AUTO**: adaptive bitrate Adaptive bitrate streams are returned only if PackageSetting is set in the transcoding template. For more information, see [Basic structures](~~52839~~).
  * > This parameter indicates the definition that is configured in the transcoding template and does not indicate the actual resolution of the output video.
  *
 */
async function getTranscodeTask(request: GetTranscodeTaskRequest): GetTranscodeTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetTranscodeTask', 'POST', '/', 'json', false, 'json', request);
}

model GetTranscodeTemplateGroupRequest {
  transcodeTemplateGroupId: string(name='TranscodeTemplateGroupId', description='The transcoding configurations of the video stream. The value is a JSON-formatted string.', example='a591f697c7167*****6ae1502142d0', position='Query'),
}

model GetTranscodeTemplateGroupResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the transcoding template.', example='6730AC93-7B12-4B*****7F-49EE1FE8BC49'),
  transcodeTemplateGroup?: {
    appId?: string(name='AppId', description='The configurations of the transcoding templates.', example='app-****'),
    creationTime?: string(name='CreationTime', description='The video rotation identifier. It is used to control the image rotation angle. For example, if you set this parameter to 180, the video image is turned upside down. Valid values: `0 to 360`.', example='2018-12-12T10:20:51Z'),
    isDefault?: string(name='IsDefault', description='The operation that you want to perform. Set the value to **GetTranscodeTemplateGroup**.', example='NotDefault'),
    locked?: string(name='Locked', description='The packaging configurations. Only HLS packaging and DASH packaging are supported. The value is a JSON-formatted string.', example='Enabled'),
    modifyTime?: string(name='ModifyTime', description='The information about the transcoding template group.', example='2018-12-12T11:20:51Z'),
    name?: string(name='Name', description='The transcoding segment configurations. This parameter must be returned if HTTP-Live-Streaming (HLS) encryption is used. The value is a JSON-formatted string.', example='test'),
    transcodeTemplateGroupId?: string(name='TranscodeTemplateGroupId', description='The ID of the transcoding template group.', example='a59b11f697c716*****6ae1502142d0'),
    transcodeTemplateList?: [ 
      {
        audio?: string(name='Audio', description='The encryption configuration used for transcoding.', example='{\\"Codec\\":\\"AAC\\",\\"Remove\\":\\"false\\",\\"Bitrate\\":\\"44\\",\\"Samplerate\\":\\"32000\\",\\"Channels\\":\\"2\\",\\"Profile\\":\\"aac_low\\"}'),
        clip?: string(name='Clip', description='The ID of the associated watermark.', example='{\\"TimeSpan\\":{\\"Seek\\":\\"1\\",\\"Duration\\":\\"5\\"}'),
        container?: string(name='Container', description='The subtitle configurations. The value is a JSON-formatted string.', example='"Format":"m3u8"'),
        definition?: string(name='Definition', description='The transcoding configurations of the audio stream. The value is a JSON-formatted string.', example='SD'),
        encryptSetting?: string(name='EncryptSetting', description='The conditional transcoding configurations. This parameter can be used if you want to determine the basic logic based on the bitrate and resolution of the mezzanine file before the video is transcoded. The value is a JSON-formatted string.', example='"EncryptType":"Private"'),
        muxConfig?: string(name='MuxConfig', description='Queries the details of a transcoding template group based on the ID of the transcoding template group.', example='"Segment": { "Duration":"6" }'),
        packageSetting?: string(name='PackageSetting', description='The ID of the request.', example='"PackageType":"HLSPackage","PackageConfig":{   "BandWidth":"900000"  }'),
        rotate?: string(name='Rotate', description='The ID of the application.', example='90'),
        subtitleList?: string(name='SubtitleList', description='The ID of the associated watermark.', example='[{"SubtitleUrl":"http://outin-test.oss-cn-shanghai.aliyuncs.com/subtitles/c737fece-14f1-4364-b107-d5f7f8edde0e.ass","CharEncode":"utf-8"}]'),
        templateName?: string(name='TemplateName', description='Indicates whether the template group is locked. Valid values:
*   **Disabled**: The template group is not locked.
*   **Enabled**: The template group is locked.', example='test'),
        transConfig?: string(name='TransConfig', description='The type of the template. Valid values:
*   **Normal**: a common transcoding template. This is the default value. The PackageSetting parameter cannot be set for this type of template.
*   **VideoPackage**: a video stream package template. If this type of template is used, ApsaraVideo VOD transcodes a video into video streams in different bitrates and packages these video streams with a file. The PackageSetting parameter must be set for this type of template.
*   **SubtitlePackage**: a subtitle package template. If this type of template is used, ApsaraVideo VOD adds the subtitle information to the output file generated by packaging the multi-bitrate video streams of the corresponding video. You must set the PackageSetting parameter for a subtitle package template and associate the subtitle package template with a video stream package template. A template group can contain only one subtitle package template.', example='{"IsCheckReso":"true","IsCheckResoFail":"false","IsCheckVideoBitrate":"false","IsCheckVideoBitrateFail":"false","IsCheckAudioBitrate":"false","IsCheckAudioBitrateFail":"false"}'),
        transcodeFileRegular?: string(name='TranscodeFileRegular', description='The clipping configurations of the video. The value is a JSON-formatted string. For example, you can set this parameter if you want to extract 5 seconds of content from a video to generate a new video.', example='{MediaId}/transcoce_1'),
        transcodeTemplateId?: string(name='TranscodeTemplateId', description='The time when the template group was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='696d29a11erc057*****a3acc398d02f4'),
        type?: string(name='Type', description='The ID of the transcoding template group.', example='Normal'),
        video?: string(name='Video', description='The time when the template group was modified. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='{"Codec":"H.264","Bitrate":"900","Width":"960","Remove":"false","Fps":"30"}'),
        watermarkIds?: [ string ](name='WatermarkIds'),
      }
    ](name='TranscodeTemplateList', description='The name of the transcoding template.'),
  }(name='TranscodeTemplateGroup', description='The format of the container used to encapsulate audio and video streams. The value is a JSON-formatted string.'),
}

model GetTranscodeTemplateGroupResponse = {
  headers: map[string]string(name='headers'),
  body: GetTranscodeTemplateGroupResponseBody(name='body'),
}

/**
  * Valid values for the definition of a common transcoding template:
  * *   **LD**: low definition.
  * *   **SD**: standard definition.
  * *   **HD**: high definition.
  * *   **FHD**: ultra high definition.
  * *   **OD**: original quality.
  * *   **2K**
  * *   **4K**
  * *   **SQ**: standard sound quality.
  * *   **HQ**: high sound quality.
  * Valid values for the definition of a Narrowband HD™ 1.0 transcoding template:
  * *   **LD-NBV1**: low definition.
  * *   **SD-NBV1**: standard definition.
  * *   **HD-NBV1**: high definition.
  * *   **FHD-NBV1**: ultra high definition.
  * *   **2K-NBV1**
  * *   **4K-NBV1**
  * >*   You cannot modify the definition of transcoding templates.
  * >*   You cannot modify the system parameters, such as the video resolution, audio resolution, and bitrate, of Narrowband HD™ 1.0 transcoding templates.
  * >*   You can create only Narrowband HD™ 1.0 transcoding templates that support the FLV, M3U8 (HLS), and MP4 output formats.
  *
 */
async function getTranscodeTemplateGroup(request: GetTranscodeTemplateGroupRequest): GetTranscodeTemplateGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetTranscodeTemplateGroup', 'POST', '/', 'json', false, 'json', request);
}

model GetURLUploadInfosRequest {
  jobIds?: string(name='JobIds', description='The ID of the upload job.', example='86c1925fba0****,7afb201e7fa****,2cc4997378****', position='Query'),
  uploadURLs?: string(name='UploadURLs', description='The operation that you want to perform. Set the value to **GetURLUploadInfos**.', example='http://****.mp4', position='Query'),
}

model GetURLUploadInfosResponseBody = {
  nonExists?: [ string ](name='NonExists', description='The error message returned.'),
  requestId?: string(name='RequestId', description='The ID of the uploaded media file.', example='25818875-5F78-4AF6-D7393642CA58****'),
  URLUploadInfoList?: [ 
    {
      completeTime?: string(name='CompleteTime', description='The error code returned.', example='2019-01-01T01:11:01Z'),
      creationTime?: string(name='CreationTime', description='The custom configurations. The value is a JSON string. For more information, see the "UserData: specifies the custom configurations for media upload" section of the [Request parameters](~~86952~~) topic.', example='2019-01-01T01:01:01Z'),
      errorCode?: string(name='ErrorCode', description='The ID of the request.', example='200'),
      errorMessage?: string(name='ErrorMessage', description='The upload URL of the source file.

> A maximum of 100 URLs can be returned.', example='error_message'),
      fileSize?: string(name='FileSize', example='24'),
      jobId?: string(name='JobId', description='Queries the information about URL-based upload jobs.', example='86c1925fba0****'),
      mediaId?: string(name='MediaId', example='93ab850b4f6f54b6e91d24d81d4****'),
      status?: string(name='Status', description='The time when the upload job was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='SUCCESS'),
      uploadURL?: string(name='UploadURL', example='http://****.mp4'),
      userData?: string(name='UserData', example='{"MessageCallback":"{"CallbackURL":"http://example.aliyundoc.com"}", "Extend":"{"localId":"***", "test":"www"}"}'),
    }
  ](name='URLUploadInfoList', description='The time when the upload job was complete. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.'),
}

model GetURLUploadInfosResponse = {
  headers: map[string]string(name='headers'),
  body: GetURLUploadInfosResponseBody(name='body'),
}

/**
  * The size of the uploaded media file. Unit: byte.
  *
 */
async function getURLUploadInfos(request: GetURLUploadInfosRequest): GetURLUploadInfosResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetURLUploadInfos', 'POST', '/', 'json', false, 'json', request);
}

model GetUploadDetailsRequest {
  mediaIds: string(name='MediaIds', description='The method that is used to upload the media file.', example='61ccbdb06fa83012be4d8083f6****,7d2fbc380b0e08e55f****', position='Query'),
  mediaType?: string(name='MediaType', description='The upload details.', example='video', position='Query'),
}

model GetUploadDetailsResponseBody = {
  forbiddenMediaIds?: [ string ](name='ForbiddenMediaIds', description='The time when the information about the media file was updated. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.'),
  nonExistMediaIds?: [ string ](name='NonExistMediaIds', description='The size of the uploaded file. Unit: byte.'),
  requestId?: string(name='RequestId', description='The operation that you want to perform. Set the value to **GetUploadDetails**.', example='9E290613-04F4-47F4-795D30732077****'),
  uploadDetails?: [ 
    {
      completionTime?: string(name='CompletionTime', description='Queries the upload details, such as the upload time, upload ratio, and upload source, about one or more media files based on the media IDs.', example='2019-04-28T09:45:07Z'),
      creationTime?: string(name='CreationTime', description='The title of the media file.', example='2019-04-28T09:42:07Z'),
      deviceModel?: string(name='DeviceModel', description='The time when the upload job was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='Chrome'),
      fileSize?: long(name='FileSize', example='46'),
      mediaId?: string(name='MediaId', example='61ccbdb06fa83012be4d8083f6****'),
      modificationTime?: string(name='ModificationTime', description='The ID of the request.', example='2019-04-28T09:43:12Z'),
      status?: string(name='Status', description='The status of the video. For more information about the valid values and value description of the parameter, see the "Status: the status of a video" section of the [Basic structures](~~52839~~) topic.', example='Uploading'),
      title?: string(name='Title'),
      uploadIP?: string(name='UploadIP', description='The upload size. Unit: byte.', example='192.168.0.1'),
      uploadRatio?: float(name='UploadRatio', example='0.038'),
      uploadSize?: long(name='UploadSize', example='346'),
      uploadSource?: string(name='UploadSource', description='The time when the upload job was complete. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='WebSDK'),
      uploadStatus?: string(name='UploadStatus', example='Uploading'),
    }
  ](name='UploadDetails', description='The upload ratio.'),
}

model GetUploadDetailsResponse = {
  headers: map[string]string(name='headers'),
  body: GetUploadDetailsResponseBody(name='body'),
}

/**
  * The type of the media file. Set the value to **video**, which indicates audio and video files.
  *
 */
async function getUploadDetails(request: GetUploadDetailsRequest): GetUploadDetailsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetUploadDetails', 'POST', '/', 'json', false, 'json', request);
}

model GetVideoInfoRequest {
  videoId: string(name='VideoId', example='9b73864d75f1d231e9001cd5f8****', position='Query'),
}

model GetVideoInfoResponseBody = {
  requestId?: string(name='RequestId', example='25818875-5F78-4AF6-D7393642CA58****'),
  video?: {
    appId?: string(name='AppId', example='app-****'),
    auditStatus?: string(name='AuditStatus', example='Normal'),
    cateId?: long(name='CateId', example='781111****'),
    cateName?: string(name='CateName'),
    coverURL?: string(name='CoverURL', example='https://example.aliyundoc.com/****.jpg'),
    creationTime?: string(name='CreationTime', example='2017-11-14T09:15:50Z'),
    customMediaInfo?: string(name='CustomMediaInfo', example='{"aaa":"test"}'),
    description?: string(name='Description'),
    duration?: float(name='Duration', example='135.6'),
    modificationTime?: string(name='ModificationTime', example='2017-11-14T10:15:50Z'),
    regionId?: string(name='RegionId', example='cn-shanghai'),
    restoreExpiration?: string(name='RestoreExpiration'),
    restoreStatus?: string(name='RestoreStatus'),
    size?: long(name='Size', example='10897890'),
    snapshots?: {
      snapshot?: [ string ](name='Snapshot')
    }(name='Snapshots'),
    status?: string(name='Status', example='Normal'),
    storageClass?: string(name='StorageClass'),
    storageLocation?: string(name='StorageLocation', example='out-201703232251****.oss-cn-shanghai.aliyuncs.com'),
    tags?: string(name='Tags'),
    templateGroupId?: string(name='TemplateGroupId', example='9ae2af636ca64835b0c10412f448****'),
    title?: string(name='Title'),
    videoId?: string(name='VideoId', example='9b73864d75f1d231e9001cd5f8****'),
  }(name='Video'),
}

model GetVideoInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetVideoInfoResponseBody(name='body'),
}

/**
  * The video snapshot URLs.
  *
 */
async function getVideoInfo(request: GetVideoInfoRequest): GetVideoInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetVideoInfo', 'POST', '/', 'json', false, 'json', request);
}

model GetVideoInfosRequest {
  videoIds: string(name='VideoIds', description='The tags of the video. Multiple tags are separated by commas (,).', example='7753d144efd8e649c6c45fe0579****,7753d144efd74d6c45fe0570****', position='Query'),
}

model GetVideoInfosResponseBody = {
  nonExistVideoIds?: [ string ](name='NonExistVideoIds', description='The status of the video. By default, videos in all states are returned. Multiple states are separated by commas (,). Valid values:

*   **Uploading**: The video is being uploaded.
*   **UploadFail**: The video fails to be uploaded.
*   **UploadSucc**: The video is uploaded.
*   **Transcoding**: The video is being transcoded.
*   **TranscodeFail**: The video fails to be transcoded.
*   **Blocked**: The video is blocked.
*   **Normal**: The video can be played.'),
  requestId?: string(name='RequestId', description='The title of the video.', example='25818875-5F78-4AF6-D7393642CA58****'),
  videoList?: [ 
    {
      appId?: string(name='AppId', example='app-****'),
      cateId?: long(name='CateId', description='The Object Storage Service (OSS) bucket where the video file is stored.', example='781111****'),
      cateName?: string(name='CateName', description='The name of the video category.', example='The ID of the request.'),
      coverURL?: string(name='CoverURL', example='https://example.aliyundoc.com/****.jpg'),
      creationTime?: string(name='CreationTime', description='The time when the video file was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2017-06-26T05:38:48Z'),
      description?: string(name='Description', description='Queries the information about multiple videos at a time.'),
      duration?: float(name='Duration', example='120'),
      modificationTime?: string(name='ModificationTime', description='The URL array of video snapshots.', example='2017-06-26T06:38:48Z'),
      restoreExpiration?: string(name='RestoreExpiration'),
      restoreStatus?: string(name='RestoreStatus'),
      size?: long(name='Size', example='453'),
      snapshots?: [ string ](name='Snapshots'),
      status?: string(name='Status', description='The URL of the video thumbnail.', example='Normal'),
      storageClass?: string(name='StorageClass'),
      storageLocation?: string(name='StorageLocation', description='The information about the video.', example='out-****.oss-cn-shanghai.aliyuncs.com'),
      tags?: string(name='Tags', description='The ID of the video category.', example='The size of the video mezzanine file. Unit: byte.'),
      templateGroupId?: string(name='TemplateGroupId', example='b4039216985f4312a5382a4ed****'),
      title?: string(name='Title'),
      videoId?: string(name='VideoId', description='The list of video IDs. Separate multiple IDs with commas (,). A maximum of 20 IDs can be specified.', example='7753d144efd74d6c45fe0570****'),
    }
  ](name='VideoList', description='The description of the video.'),
}

model GetVideoInfosResponse = {
  headers: map[string]string(name='headers'),
  body: GetVideoInfosResponseBody(name='body'),
}

/**
  * The duration of the video. Unit: seconds.
  *
 */
async function getVideoInfos(request: GetVideoInfosRequest): GetVideoInfosResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetVideoInfos', 'POST', '/', 'json', false, 'json', request);
}

model GetVideoListRequest {
  cateId?: long(name='CateId', description='The ID of the video category.', example='781111', position='Query'),
  endTime?: string(name='EndTime', description='The end of the time range for querying videos based on their creation time. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.', example='2017-01-11T12:59:00Z', position='Query'),
  pageNo?: int32(name='PageNo', description='The number of the page to return. Default value: **1**.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='Optional. The number of entries to return on each page. Default value: **10**. Maximum value: **100**.', example='10', position='Query'),
  sortBy?: string(name='SortBy', description='The method for sorting the results. Valid values:

*   **CreationTime:Desc** (default): The results are sorted in reverse chronological order based on the creation time.
*   **CreationTime:Asc**: The results are sorted in chronological order based on the creation time.', example='CreationTime:Asc', position='Query'),
  startTime?: string(name='StartTime', description='The beginning of the time range for querying videos based on their creation time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.', example='2017-01-11T12:00:00Z', position='Query'),
  status?: string(name='Status', description='The status of the video. By default, you can obtain videos in all states. Separate multiple states with commas (,). Valid values:

*   **Uploading**: The video is being uploaded.
*   **UploadFail**: The video fails to be uploaded.
*   **UploadSucc**: The video is uploaded.
*   **Transcoding**: The video is being transcoded.
*   **TranscodeFail**: The video fails to be transcoded.
*   **Blocked**: The video is blocked.
*   **Normal**: The video can be played.', example='Uploading,Normal', position='Query'),
  storageLocation?: string(name='StorageLocation', description='The Object Storage Service (OSS) bucket where the video file is stored.', example='out-****.oss-cn-shanghai.aliyuncs.com', position='Query'),
}

model GetVideoListResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='25818875-5F78-4AF6-D7393642CA58****'),
  total?: int32(name='Total', description='The total number of videos.', example='100'),
  videoList?: {
    video?: [ 
    {
      appId?: string(name='AppId', description='The ID of the application. Default value: **app-1000000**.', example='app-1000000'),
      cateId?: long(name='CateId', description='The ID of the video category.', example='781111'),
      cateName?: string(name='CateName', description='The name of the video category.', example='category name'),
      coverURL?: string(name='CoverURL', description='The URL of the video thumbnail.', example='https://example.aliyundoc.com/****.jpg'),
      creationTime?: string(name='CreationTime', description='The time when the video file was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2017-11-14T09:15:50Z'),
      description?: string(name='Description', description='The description of the video.', example='video description'),
      duration?: float(name='Duration', description='The duration of the video. Unit: seconds.', example='135.6'),
      modificationTime?: string(name='ModificationTime', description='The time when the video file was updated. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2017-11-14T09:16:50Z'),
      restoreExpiration?: string(name='RestoreExpiration'),
      restoreStatus?: string(name='RestoreStatus'),
      size?: long(name='Size', description='The size of the video mezzanine file. Unit: byte.', example='10897890'),
      snapshots?: {
        snapshot?: [ string ](name='Snapshot')
      }(name='Snapshots', description='The URL array of video snapshots.'),
      status?: string(name='Status', description='The status of the video. By default, videos in all states are returned. Multiple states are separated by commas (,). Valid values:

*   **Uploading**: The video is being uploaded.
*   **UploadFail**: The video fails to be uploaded.
*   **UploadSucc**: The video is uploaded.
*   **Transcoding**: The video is being transcoded.
*   **TranscodeFail**: The video fails to be transcoded.
*   **Blocked**: The video is blocked.
*   **Normal**: The video can be played.', example='Normal'),
      storageClass?: string(name='StorageClass'),
      storageLocation?: string(name='StorageLocation', description='The OSS bucket where the video file is stored.', example='out-****.oss-cn-shanghai.aliyuncs.com'),
      tags?: string(name='Tags', description='The tags of the video. Multiple tags are separated by commas (,).', example='tag1,tag2'),
      title?: string(name='Title', description='The title of the video.', example='video title'),
      videoId?: string(name='VideoId', description='The ID of the video.', example='9ae2af636ca6c10412f44891fc****'),
    }
  ](name='Video')
  }(name='VideoList', description='The information about the video. The information about a maximum of first 5,000 video records can be obtained in a single request.'),
}

model GetVideoListResponse = {
  headers: map[string]string(name='headers'),
  body: GetVideoListResponseBody(name='body'),
}

/**
  * In a single request, you can obtain the information about a maximum of first **5,000** video records that meet the specified filter criteria, such as the video status and category. We recommend that you set the StartTime and EndTime parameters to narrow down the time range for queries and perform multiple queries. For more information about how to query the information about more videos or even all videos, see [SearchMedia](~~86044~~).
  *
 */
async function getVideoList(request: GetVideoListRequest): GetVideoListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetVideoList', 'POST', '/', 'json', false, 'json', request);
}

model GetVideoPlayAuthRequest {
  apiVersion?: string(name='ApiVersion', description='The API version number. Set the value to **1.0.0**.', example='1.0.0', position='Query'),
  authInfoTimeout?: long(name='AuthInfoTimeout', description='The time when the playback credential expires. Unit: **seconds**. You cannot obtain the playback URL of a video by using a credential that has expired. A new credential is required.
*   Default value: **100**.
*   Valid values: `100 to 3000`.', example='100', position='Query'),
  videoId: string(name='VideoId', description='The ID of the audio or video file. You can use one of the following methods to obtain the ID of the file:
*   Log on to the [ApsaraVideo VOD](https://vod.console.aliyun.com) console. In the left-side navigation pane, choose **Media Files** > **Audio/Video**. On the Video and Audio page, view the ID of the audio or video file. This method is applicable to files that are uploaded by using the ApsaraVideo VOD console.
*   Obtain the value of the VideoId parameter when you call the [CreateUploadVideo](~~55407~~) operation to upload files.
*   Obtain the value of the VideoId parameter by calling the [SearchMedia](~~86044~~) operation. This method is applicable to files that have been uploaded.', example='dfde02284a5c46622a097adaf44a****', position='Query'),
}

model GetVideoPlayAuthResponseBody = {
  playAuth?: string(name='PlayAuth', description='The credential for video or audio playback.', example='sstyYuew6789000000xtt7TYUh****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='E4EBD2BF-5EB0-4476-8829-9D94E1B1****'),
  videoMeta?: {
    coverURL?: string(name='CoverURL', description='The thumbnail URL of the audio or video file.', example='https://example.aliyundoc.com/****.jpg'),
    duration?: float(name='Duration', description='The duration of the audio or video file. Unit: seconds.', example='120.0'),
    status?: string(name='Status', description='The status of the audio or video file. For more information about the value range and description, see the [Status](~~52839~~) table.', example='Normal'),
    title?: string(name='Title', description='The title of the audio or video file.', example='VOD'),
    videoId?: string(name='VideoId', description='The ID of the audio or video file.', example='dfde02284a5c46622a097adaf44a****'),
  }(name='VideoMeta', description='The metadata of the audio or video file.'),
}

model GetVideoPlayAuthResponse = {
  headers: map[string]string(name='headers'),
  body: GetVideoPlayAuthResponseBody(name='body'),
}

/**
  * *   You can call this operation to obtain a playback credential when you use ApsaraVideo Player SDK to play a media file based on PlayAuth. The credential is used to obtain the playback URL.
  * *   You cannot obtain the playback URL of a video by using a credential that has expired. A new credential is required.
  *
 */
async function getVideoPlayAuth(request: GetVideoPlayAuthRequest): GetVideoPlayAuthResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetVideoPlayAuth', 'POST', '/', 'json', false, 'json', request);
}

model GetVodTemplateRequest {
  vodTemplateId: string(name='VodTemplateId', description='Indicates whether the template is the default one. Valid values:

*   **Default**: The template is the default one.
*   **NotDefault**: The template is not the default one.', example='7c49f2f4c0969*****fcd446690', position='Query'),
}

model GetVodTemplateResponseBody = {
  requestId?: string(name='RequestId', description='The time when the template was modified. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='DE7A1F49-41C1-47*****DF-4CD0C02087DB'),
  vodTemplateInfo?: {
    creationTime?: string(name='CreationTime', description='The name of the template.', example='2018-11-30T08:05:59:57Z'),
    isDefault?: string(name='IsDefault', description='The ID of the request.', example='NotDefault'),
    modifyTime?: string(name='ModifyTime', example='2018-11-30T09:05:59:57Z'),
    name?: string(name='Name', example='test'),
    templateConfig?: string(name='TemplateConfig', description='Queries a single snapshot template.', example='{\\"SnapshotConfig\\":{\\"Count\\":10,\\"SpecifiedOffsetTime\\":0,\\"Interval\\":1},\\"SnapshotType\\":\\"NormalSnapshot\\"}'),
    templateType?: string(name='TemplateType', description='The operation that you want to perform. Set the value to **GetVodTemplate**.', example='Snapshot'),
    vodTemplateId?: string(name='VodTemplateId', description='The detailed configurations of the template. The value is a JSON-formatted string. For more information about the data structure, see the "SnapshotTemplateConfig" section of the [Media processing parameters](~~98618~~) topic.', example='7c49f2f4c09*****69fcd446690'),
  }(name='VodTemplateInfo', description='The ID of the template.'),
}

model GetVodTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: GetVodTemplateResponseBody(name='body'),
}

async function getVodTemplate(request: GetVodTemplateRequest): GetVodTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetVodTemplate', 'POST', '/', 'json', false, 'json', request);
}

model GetWatermarkRequest {
  watermarkId: string(name='WatermarkId', description='The information about the watermark.', example='9bcc8bfadb843f*****09a2671d0df97', position='Query'),
}

model GetWatermarkResponseBody = {
  requestId?: string(name='RequestId', description='The time when the watermark was added. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='25818875-5F78-4A*****F6-D7393642CA58'),
  watermarkInfo?: {
    appId?: string(name='AppId', description='The ID of the watermark.', example='app-****'),
    creationTime?: string(name='CreationTime', description='The name of the watermark.', example='2018-11-06T08:03:17Z'),
    fileUrl?: string(name='FileUrl', description='The operation that you want to perform. Set the value to **GetWatermark**.', example='https://outin-32*****f4b3e7.oss-cn-shanghai.aliyuncs.com/image/cover/F85529C8B715E6F8A72EC6B-6-2.png?Expires=1541600583&OSSAccessKeyId=****&Signature=gmf1eYMoDVg%2BHQCb4UGozBW****'),
    isDefault?: string(name='IsDefault', description='The ID of the request.', example='NotDefault'),
    name?: string(name='Name'),
    type?: string(name='Type', description='The Object Storage Service (OSS) URL or Content Delivery Network (CDN) URL of the watermark file. A text watermark does not have a file URL.', example='Text'),
    watermarkConfig?: string(name='WatermarkConfig', description='Queries a single watermark.', example='{"ReferPos": "BottomRight","Height": "55","Width": "55","Dx": "8","Dy": "8" }'),
    watermarkId?: string(name='WatermarkId', example='505e2e287ea*****ecfddd386d384'),
  }(name='WatermarkInfo', description='The ID of the application.'),
}

model GetWatermarkResponse = {
  headers: map[string]string(name='headers'),
  body: GetWatermarkResponseBody(name='body'),
}

async function getWatermark(request: GetWatermarkRequest): GetWatermarkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetWatermark', 'POST', '/', 'json', false, 'json', request);
}

model ListAIImageInfoRequest {
  videoId: string(name='VideoId', description='The ID of the video. You can use one of the following methods to obtain the ID:

*   Log on to the [ApsaraVideo VOD](https://vod.console.aliyun.com) console. In the left-side navigation pane, choose **Media Files** > **Audio/Video**. On the Video and Audio page, view the ID of the audio or video file. This method is applicable to files that are uploaded by using the ApsaraVideo VOD console.
*   Obtain the value of VideoId from the response to the [CreateUploadVideo](~~55407~~) operation that you call to upload media files.
*   Obtain the value of VideoId from the response to the [SearchMedia](~~86044~~) operation after you upload media files.', example='357a8748c5789d2726e6436aa****', position='Query'),
}

model ListAIImageInfoResponseBody = {
  AIImageInfoList?: [ 
    {
      AIImageInfoId?: string(name='AIImageInfoId', description='The ID of the image information.', example='b89a6aabf1b6197ebd6fe6cf29****'),
      creationTime?: string(name='CreationTime', description='The time when the file was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2020-10-15T03:30:03Z'),
      fileURL?: string(name='FileURL', description='The URL of the image file.', example='http://example.aliyundoc.com/357a8748c5789d2726e6436aa****/image/ai/b0a7612554d6400013-0****.gif?auth_key=1602745717-0-0-005ee05616c5925596d****'),
      format?: string(name='Format', description='The format of the image. Valid values: **gif** and **png**.', example='gif'),
      jobId?: string(name='JobId', description='The ID of the image AI processing job.', example='cf08a2c6e11ee1711b738b9067****'),
      score?: string(name='Score', description='The score of the image.', example='5.035636554444242'),
      version?: string(name='Version', description='The data version ID.', example='b547f3f0e199c3b457369f3cf****'),
      videoId?: string(name='VideoId', description='The ID of the video.', example='357a8748c5789d2726e6436aa****'),
    }
  ](name='AIImageInfoList', description='The image files that are uploaded for AI processing.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='D73420CD-D221-9122-5B8FA995A511****'),
}

model ListAIImageInfoResponse = {
  headers: map[string]string(name='headers'),
  body: ListAIImageInfoResponseBody(name='body'),
}

/**
  * You can call this operation to query AI processing results about images of a specified video. Images of different videos cannot be queried in one request.
  * - The smart thumbnail feature is not supported. You cannot call this operation.
  * - You can call this operation to query AI processing results about images of a specified video. Images of different videos cannot be queried in one request.
  * ### QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits on API operations in ApsaraVideo VoD](~~342790~~).
  *
 */
async function listAIImageInfo(request: ListAIImageInfoRequest): ListAIImageInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListAIImageInfo', 'POST', '/', 'json', false, 'json', request);
}

model ListAIJobRequest {
  jobIds: string(name='JobIds', description='The time when the job is complete. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='a718a3a1e8bb42ee3bc88921e94****,aasdcsfg782740asd3****,k2l3ibaskod98wrns9d****', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: string(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: string(name='ResourceOwnerId', position='Query'),
}

model ListAIJobResponseBody = {
  AIJobList?: {
    AIJob?: [ 
    {
      code?: string(name='Code', description='Queries AI jobs. After a job is submitted, ApsaraVideo VOD asynchronously processes the job. You can call this operation to query the job information in real time.', example='0'),
      completeTime?: string(name='CompleteTime', description='The ID of the request.', example='2020-06-28T02:04:47Z'),
      creationTime?: string(name='CreationTime', description='The status of the job. Valid values:

*   **success**: The job is complete.
*   **fail**: The job failed.
*   **init**: The job is being initialized.
*   **Processing**: The job is in progress.', example='2020-06-28T02:04:32Z'),
      data?: string(name='Data', description='{"OrigASRData":{"AsrTextList":\\[{"EndTime":700,"StartTime":0,"Text":"Yes.","ChannelId":0,"SpeechRate":85},{"EndTime":3750,"StartTime":1630,"Text":"No.","ChannelId":0,"SpeechRate":28},{"EndTime":5910,"StartTime":4020,"Text":"Of course.","ChannelId":0,"SpeechRate":95},{"EndTime":12750,"StartTime":10090,"Text":"Message.","ChannelId":0,"SpeechRate":45},{"EndTime":25230,"StartTime":13590,"Text":"Hello, good afternoon.","ChannelId":0,"SpeechRate":20},{"EndTime":30000,"StartTime":28220,"Text":"Yes.","ChannelId":0,"SpeechRate":33}],"Duration":"30016"}}', example='The information about the jobs.'),
      jobId?: string(name='JobId', description='The ID of the video.', example='a718a3a1e8bb42ee3bc88921e94****'),
      mediaId?: string(name='MediaId', example='3D3D12340d9401fab46a0b847****'),
      message?: string(name='Message', example='OK'),
      status?: string(name='Status', description='The error message. This parameter is returned if the value of Status is fail.', example='success'),
      type?: string(name='Type', description='The returned data. The value is a JSON string.

For more information, see [AITemplateConfig](~~89863~~).', example='AIVideoTag'),
    }
  ](name='AIJob')
  }(name='AIJobList', description='The list of job IDs. You can obtain the job ID from the PlayInfo parameter in the response to the [GetPlayInfo](~~56124~~) operation.

>  You can specify a maximum of 10 job IDs in a request. Separate multiple IDs with commas (,).'),
  nonExistAIJobIds?: {
    string?: [ string ](name='String')
  }(name='NonExistAIJobIds', description='The error code. This parameter is returned if the value of Status is fail.'),
  requestId?: string(name='RequestId', description='The ID of the job.', example='8233A0E4-E112-44*****58-2BCED1B88173'),
}

model ListAIJobResponse = {
  headers: map[string]string(name='headers'),
  body: ListAIJobResponseBody(name='body'),
}

/**
  * The IDs of the jobs that do not exist.
  *
 */
async function listAIJob(request: ListAIJobRequest): ListAIJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListAIJob', 'POST', '/', 'json', false, 'json', request);
}

model ListAITemplateRequest {
  templateType: string(name='TemplateType', description='Indicates whether the template is the default AI template. Valid values:

*   **Default**
*   **NotDefault**', example='AIMediaAudit', position='Query'),
}

model ListAITemplateResponseBody = {
  requestId?: string(name='RequestId', description='The source of the AI template. Valid values:

*   **System**
*   **Custom**', example='75B7BC67-FB8C-4653-4788-F4B01ED2****'),
  templateInfoList?: [ 
    {
      creationTime?: string(name='CreationTime', description='The type of the AI template. Valid values:

*   **AIMediaAudit**: automated review
*   **AIImage**: smart thumbnail', example='2020-07-08T06:50:45Z'),
      isDefault?: string(name='IsDefault', description='Details of the AI template.', example='NoDefault'),
      modifyTime?: string(name='ModifyTime', example='2020-07-08T06:58:45Z'),
      source?: string(name='Source', description='Queries AI templates.', example='Custom'),
      templateConfig?: string(name='TemplateConfig', description='The ID of the request.', example='{"AuditRange":["text-title","video"],"AuditContent":["screen"],"AuditItem":["terrorism","porn"],"AuditAutoBlock":"yes"}'),
      templateId?: string(name='TemplateId', example='1706a0063dd733f6a823ef32e0a5****'),
      templateName?: string(name='TemplateName', description='The time when the AI template was modified. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='DemoAITemplate'),
      templateType?: string(name='TemplateType', description='The detailed configurations of the AI template. The value is a JSON string. For more information, see [AITemplateConfig](~~89863~~#title-vd3-499-o36).', example='AIMediaAudit'),
    }
  ](name='TemplateInfoList', description='The name of the AI template.'),
}

model ListAITemplateResponse = {
  headers: map[string]string(name='headers'),
  body: ListAITemplateResponseBody(name='body'),
}

/**
  * The returned result.
  *
 */
async function listAITemplate(request: ListAITemplateRequest): ListAITemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListAITemplate', 'POST', '/', 'json', false, 'json', request);
}

model ListAppInfoRequest {
  pageNo?: int32(name='PageNo', description='The operation that you want to perform. Set the value to **ListAppInfo**.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The type of the application. Valid values:

*   **System**
*   **Custom**', example='10', position='Query'),
  status?: string(name='Status', description='The details of each application.', example='Normal', position='Query'),
}

model ListAppInfoResponseBody = {
  appInfoList?: [ 
    {
      appId?: string(name='AppId', example='app-****'),
      appName?: string(name='AppName', description='Queries the applications that you are authorized to manage based on query conditions.', example='test'),
      creationTime?: string(name='CreationTime', description='The ID of the request.', example='2019-03-01T08:00:00Z'),
      description?: string(name='Description', description='WB01210940', example='my first app.'),
      modificationTime?: string(name='ModificationTime', example='2019-03-01T09:00:00Z'),
      status?: string(name='Status', description='The time when the application was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='Normal'),
      type?: string(name='Type', description='The ID of the application.', example='System'),
    }
  ](name='AppInfoList', description='The status of the application. After an application is created, it enters the **Normal** state. Valid values:

*   **Normal**
*   **Disable**'),
  requestId?: string(name='RequestId', description='The last time when the application was modified. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='25818875-5F78-4A13-4D5C-D7393642****'),
  total?: int32(name='Total', description='The status of the application. Valid values:

*   **Normal**
*   **Disable**', example='10'),
}

model ListAppInfoResponse = {
  headers: map[string]string(name='headers'),
  body: ListAppInfoResponseBody(name='body'),
}

/**
  * The description of the application.
  *
 */
async function listAppInfo(request: ListAppInfoRequest): ListAppInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListAppInfo', 'POST', '/', 'json', false, 'json', request);
}

model ListAppPoliciesForIdentityRequest {
  appId?: string(name='AppId', description='The ID of the application.', example='app-****', position='Query'),
  identityName?: string(name='IdentityName', description='The type of the identity. Valid values:

*   **RamUser**: a RAM user.
*   **RamRole**: a RAM role.', example='test****name', position='Query'),
  identityType?: string(name='IdentityType', description='The type of the policy. Valid values:

*   **System**
*   **Custom**', example='RamUser', position='Query'),
}

model ListAppPoliciesForIdentityResponseBody = {
  appPolicyList?: [ 
    {
      appId?: string(name='AppId', description='The ID of the request.', example='app-****'),
      creationTime?: string(name='CreationTime', description='The last time when the application policy was modified. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2019-01-01T01:01:01Z'),
      description?: string(name='Description', description='The content of the policy.', example='App full access permission'),
      modificationTime?: string(name='ModificationTime', example='2019-01-01T01:08:01Z'),
      policyName?: string(name='PolicyName', description='Queries the application policies that are attached to the specified identity. The identity may be a RAM user or RAM role.', example='VODAppFullAccess'),
      policyType?: string(name='PolicyType', example='System'),
      policyValue?: string(name='PolicyValue', description='The details of each policy.

**

**Note** A maximum of 100 entries can be returned.', example='****'),
    }
  ](name='AppPolicyList', description='The description of the policy.'),
  requestId?: string(name='RequestId', description='The time when the application policy was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='C9F3E715-B3B8-4D*****27-3A70346F0E04'),
}

model ListAppPoliciesForIdentityResponse = {
  headers: map[string]string(name='headers'),
  body: ListAppPoliciesForIdentityResponseBody(name='body'),
}

/**
  * The name of the identity.
  * *   Specifies the ID of the RAM user when the IdentityType parameter is set to RamUser.
  * *   Specifies the name of the RAM role when the IdentityType parameter is set to RamRole.
  *
 */
async function listAppPoliciesForIdentity(request: ListAppPoliciesForIdentityRequest): ListAppPoliciesForIdentityResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListAppPoliciesForIdentity', 'POST', '/', 'json', false, 'json', request);
}

model ListAuditSecurityIpRequest {
  securityGroupName?: string(name='SecurityGroupName', description='The time when the review security group was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='Default', position='Query'),
}

model ListAuditSecurityIpResponseBody = {
  requestId?: string(name='RequestId', description='The name of the review security group.', example='664BBD08-C7DB-4E*****73-9D0958D9A899'),
  securityIpList?: [ 
    {
      creationTime?: string(name='CreationTime', description='The operation that you want to perform. Set the value to **ListAuditSecurityIp**.', example='2018-05-22T06:54:23Z'),
      ips?: string(name='Ips', description='Queries the IP addresses in a review security group.', example='30.27.14.0/24,30.39.127.245'),
      modificationTime?: string(name='ModificationTime', example='2018-05-22T06:55:14Z'),
      securityGroupName?: string(name='SecurityGroupName', example='Default'),
    }
  ](name='SecurityIpList', description='The ID of the request.'),
}

model ListAuditSecurityIpResponse = {
  headers: map[string]string(name='headers'),
  body: ListAuditSecurityIpResponseBody(name='body'),
}

async function listAuditSecurityIp(request: ListAuditSecurityIpRequest): ListAuditSecurityIpResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListAuditSecurityIp', 'POST', '/', 'json', false, 'json', request);
}

model ListDynamicImageRequest {
  videoId: string(name='VideoId', description='The size of the animated sticker file. Unit: byte.', example='2e114f1100590c3193918fd449a****', position='Query'),
}

model ListDynamicImageResponseBody = {
  dynamicImageList?: [ 
    {
      creationTime?: string(name='CreationTime', description='The job ID for creating the animated sticker.', example='2020-07-28T02:01:06Z'),
      duration?: string(name='Duration', example='2'),
      dynamicImageId?: string(name='DynamicImageId', example='2b4e51df60323ef43d6e336ecf****'),
      fileSize?: string(name='FileSize', example='119866'),
      fileURL?: string(name='FileURL', description='The time when the animated sticker was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='https://example.aliyundoc.com/2e114f110059*****0c3193918fd449a/image/dynamic/2b4e51df60*****323ef43d6e336ecf.webp?auth_key=1597296785-0-0-4a48e85*****bd2bb358e0b3cade'),
      format?: string(name='Format', example='webp'),
      fps?: string(name='Fps', description='Queries the information about animated stickers of a video based on the video ID.', example='10'),
      height?: string(name='Height', description='The frame rate of the animated sticker. Unit: frames per second.', example='360'),
      jobId?: string(name='JobId', description='The ID of the request.', example='2bf4390af9e5491c09cc720ad****'),
      videoId?: string(name='VideoId', description='The duration of the animated sticker. Unit: seconds.', example='2e114f1100590c3193918fd449a****'),
      width?: string(name='Width', description='The list of animated stickers.', example='640'),
    }
  ](name='DynamicImageList', description='The format of the animated sticker. Valid values: gif and webp.'),
  requestId?: string(name='RequestId', description='The operation that you want to perform. Set the value to **ListDynamicImage**.', example='570189B6-572E-4953-13B4278EE0D8****'),
}

model ListDynamicImageResponse = {
  headers: map[string]string(name='headers'),
  body: ListDynamicImageResponseBody(name='body'),
}

async function listDynamicImage(request: ListDynamicImageRequest): ListDynamicImageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListDynamicImage', 'POST', '/', 'json', false, 'json', request);
}

model ListLiveRecordVideoRequest {
  appName?: string(name='AppName', description='The name of the application that was used to record the live stream.', example='testApp', position='Query'),
  domainName?: string(name='DomainName', description='The domain name of the recorded live stream.', example='example.aliyundoc.com', position='Query'),
  endTime?: string(name='EndTime', description='The end of the time range to query. The query is performed based on the time range during which the required live streams were recorded. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.', example='2017-01-11T13:00:00Z', position='Query'),
  pageNo?: int32(name='PageNo', description='The number of the page to return. Default value: **1**.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Maximum value: **100**. Default value: **10**.', example='10', position='Query'),
  sortBy?: string(name='SortBy', description='The sorting rule of results. Valid values:
*   **CreationTime:Desc**: sorts the results based on the creation time in descending order. This is the default value.
*   **CreationTime:Asc**: sorts the results based on the creation time in ascending order.', example='CreationTime:Desc', position='Query'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. The query is performed based on the time range during which the required live streams were recorded. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.', example='2017-01-11T12:00:00Z', position='Query'),
  streamName?: string(name='StreamName', description='The name of the recorded live stream.', example='live-test', position='Query'),
}

model ListLiveRecordVideoResponseBody = {
  liveRecordVideoList?: {
    liveRecordVideo?: [ 
    {
      appName?: string(name='AppName', description='The name of the application.', example='testApp'),
      domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
      playlistId?: string(name='PlaylistId', description='The ID of the playlist.', example='****'),
      recordEndTime?: string(name='RecordEndTime', description='The end of the time range in which data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2017-12-08T08:44:56Z'),
      recordStartTime?: string(name='RecordStartTime', description='The beginning of the time range in which data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2017-12-08T07:40:56Z'),
      streamName?: string(name='StreamName', description='The name of the live stream.', example='live-test'),
      video?: {
        cateId?: int32(name='CateId', description='The ID of the video category.', example='78'),
        cateName?: string(name='CateName', description='The name of the video category.', example='Category name'),
        coverURL?: string(name='CoverURL', description='The thumbnail URL of the video.', example='https://example.aliyundoc.com/coversample.jpg'),
        creationTime?: string(name='CreationTime', description='The time when the video was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2017-12-08T07:40:56Z'),
        description?: string(name='Description', description='The description of the video.', example='Description of the ApsaraVideo VOD video'),
        duration?: float(name='Duration', description='The duration of the video. Unit: seconds.', example='135.6'),
        modifyTime?: string(name='ModifyTime', description='The last time when the video was updated. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2017-12-08T09:40:56Z'),
        size?: long(name='Size', description='The size of the mezzanine file. Unit: byte.', example='10897890'),
        snapshots?: {
          snapshot?: [ string ](name='Snapshot')
        }(name='Snapshots', description='The array of video snapshot URLs.'),
        status?: string(name='Status', description='The status of the video. Valid values:
*   **Uploading:**: indicates that the video is being uploaded.
*   **UploadFail**: indicates that the video failed to be uploaded.
*   **UploadSucces**: indicates that the video was uploaded.
*   **Transcoding**: indicates that the video is being transcoded.
*   **TranscodeFail**: indicates that the video failed to be transcoded.
*   **Blocked**: indicates that the video is blocked.
*   **Normal**: indicates that the video is in a normal state.', example='Normal'),
        tags?: string(name='Tags', description='The tags of the video. Separate multiple tags with commas (,).', example='tag1, tag2'),
        templateGroupId?: string(name='TemplateGroupId', description='The ID of the transcoding template group.', example='1'),
        title?: string(name='Title', description='The title of the video.', example='Title of the ApsaraVideo VOD video'),
        videoId?: string(name='VideoId', description='The ID of the video.', example='93ab850b4f6f*****54b6e91d24d81d4'),
      }(name='Video', description='The information about the video.'),
    }
  ](name='LiveRecordVideo')
  }(name='LiveRecordVideoList', description='The list of videos.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='25818875-5F78-4A13-****-D7393642CA58'),
  total?: int32(name='Total', description='The total number of videos returned.', example='123'),
}

model ListLiveRecordVideoResponse = {
  headers: map[string]string(name='headers'),
  body: ListLiveRecordVideoResponseBody(name='body'),
}

/**
  * You can query a maximum of 5,000 videos based on the specified filter condition.
  *
 */
async function listLiveRecordVideo(request: ListLiveRecordVideoRequest): ListLiveRecordVideoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListLiveRecordVideo', 'POST', '/', 'json', false, 'json', request);
}

model ListSnapshotsRequest {
  authTimeout?: string(name='AuthTimeout', description='The validity period of the snapshot URL. Unit: seconds. Default value: **3600**. Minimum value: **3600**.

*   This parameter only takes effect when [URL authentication](~~57007~~) is enabled.
*   If the specified validity period is less than **3600** seconds, the default value is **3600**.
*   If an Object Storage Service (OSS) URL is returned, the maximum validity period is limited to **2592000** seconds (30 days) to reduce security risks of the origin.', example='3600', position='Query'),
  pageNo?: string(name='PageNo', description='The number of the page to turn. Default value: **1**.', example='1', position='Query'),
  pageSize?: string(name='PageSize', description='The number of entries to return on each page. Default value: **20**. Maximum value: **100**.', example='20', position='Query'),
  snapshotType?: string(name='SnapshotType', description='The type of snapshots that are returned. Valid values:

*   **CoverSnapshot**: thumbnail snapshot
*   **NormalSnapshot**: normal snapshot
*   **SpriteSnapshot**: sprite snapshot
*   **SpriteOriginSnapshot**: sprite source snapshot
*   **WebVttSnapshot**: WebVTT snapshot', example='CoverSnapshot', position='Query'),
  videoId: string(name='VideoId', description='The ID of the video.', example='d3e680e618708fbf2cae7cc931****', position='Query'),
}

model ListSnapshotsResponseBody = {
  mediaSnapshot?: {
    creationTime?: string(name='CreationTime', description='The time when the snapshot job was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2017-12-20T12:23:45Z'),
    jobId?: string(name='JobId', description='The ID of the snapshot job.', example='ad90a501b1b9472374ad005046****'),
    regular?: string(name='Regular', description='The rule for generating snapshot URLs.', example='http://example.aliyundoc.com/snapshot/sample{SnapshotCount}.jpg'),
    snapshots?: {
      snapshot?: [ 
      {
        index?: long(name='Index', description='The index of the snapshot.', example='1'),
        url?: string(name='Url', description='The URL of the snapshot.', example='http://example.aliyundoc.com/snapshot/sample00001****.jpg'),
      }
    ](name='Snapshot')
    }(name='Snapshots', description='The snapshot data.'),
    total?: long(name='Total', description='The total number of snapshots.', example='100'),
  }(name='MediaSnapshot', description='The snapshot data of the media.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='25818875-5F78-4AF6-D7393642CA58****'),
}

model ListSnapshotsResponse = {
  headers: map[string]string(name='headers'),
  body: ListSnapshotsResponseBody(name='body'),
}

/**
  * If multiple snapshots of a video exist, the data of the latest snapshot is returned.
  *
 */
async function listSnapshots(request: ListSnapshotsRequest): ListSnapshotsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListSnapshots', 'POST', '/', 'json', false, 'json', request);
}

model ListTranscodeTaskRequest {
  endTime?: string(name='EndTime', description='The time when the transcoding task was complete. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2019-01-23T12:40:12Z', position='Query'),
  pageNo?: int32(name='PageNo', description='The number of the page to return. You can specify a page number to return data from the specified page. Default value: **1**.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The operation that you want to perform. Set the value to **ListTranscodeTask**', example='10', position='Query'),
  startTime?: string(name='StartTime', description='The ID of the audio or video file.', example='2019-01-23T12:35:12Z', position='Query'),
  videoId: string(name='VideoId', description='The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.', example='d4860fcc6a5*****bce9fed52e893824', position='Query'),
}

model ListTranscodeTaskResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the transcoding template group.', example='25818875-5F78-4A*****F6-D7393642CA58'),
  transcodeTaskList?: [ 
    {
      completeTime?: string(name='CompleteTime', description='Queries transcoding tasks based on the media ID. This operation does not return specific job information.', example='2019-01-23T12:40:12Z'),
      creationTime?: string(name='CreationTime', description='The ID of the audio or video file. You can use one of the following methods to obtain the ID of the file:

*   Log on to the [ApsaraVideo VOD](https://vod.console.aliyun.com) console. In the left-side navigation pane, choose **Media Files** > **Audio/Video**. On the Video and Audio page, view the ID of the audio or video file. This method is applicable to files that are uploaded by using the ApsaraVideo VOD console.
*   Obtain the value of VideoId from the response to the [CreateUploadVideo](~~55407~~) operation that you call to obtain the upload URL and credential.
*   Obtain the value of VideoId by calling the [SearchMedia](~~86044~~) operation. This method is applicable to files that have been uploaded.', example='2019-01-23T12:35:12Z'),
      taskStatus?: string(name='TaskStatus', description='The number of entries to return on each page. Maximum value: **50**. Default value: **10**.', example='Processing'),
      transcodeTaskId?: string(name='TranscodeTaskId', example='b1b65ab107*****ba3dbb900f6c1fe0'),
      transcodeTemplateGroupId?: string(name='TranscodeTemplateGroupId', example='b500c7094bd24*****f3e9900752d7c3'),
      trigger?: string(name='Trigger', description='The status of the transcoding task. Valid values:

*   **Processing**: In progress.
*   **Partial**: Some transcoding jobs were complete.
*   **CompleteAllSucc**: All transcoding jobs were successful.
*   **CompleteAllFail**: All transcoding jobs failed. If an exception occurs in the source file, no transcoding job is initiated and the transcoding task fails.
*   **CompletePartialSucc**: All transcoding jobs were complete but only some were successful.', example='Auto'),
      videoId?: string(name='VideoId', description='The ID of the request.', example='d4860fcc6a5*****bce9fed52e893824'),
    }
  ](name='TranscodeTaskList', description='The ID of the transcoding task.'),
}

model ListTranscodeTaskResponse = {
  headers: map[string]string(name='headers'),
  body: ListTranscodeTaskResponseBody(name='body'),
}

/**
  * The time when the transcoding task was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
  *
 */
async function listTranscodeTask(request: ListTranscodeTaskRequest): ListTranscodeTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTranscodeTask', 'POST', '/', 'json', false, 'json', request);
}

model ListTranscodeTemplateGroupRequest {
  appId?: string(name='AppId', description='The name of the template group.', example='app-****', position='Query'),
}

model ListTranscodeTemplateGroupResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the transcoding template group.', example='25818875-5F78-4A*****F6-D7393642CA58'),
  transcodeTemplateGroupList?: [ 
    {
      appId?: string(name='AppId', description='The operation that you want to perform. Set the value to **ListTranscodeTemplateGroup**.', example='app-****'),
      creationTime?: string(name='CreationTime', description='The time when the template group was modified. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2018-12-05T10:20:09Z'),
      isDefault?: string(name='IsDefault', description='The ID of the request.', example='Default'),
      locked?: string(name='Locked', example='Disabled'),
      modifyTime?: string(name='ModifyTime', example='2018-12-05T10:22:09Z'),
      name?: string(name='Name', description='Queries transcoding template groups.', example='test'),
      transcodeTemplateGroupId?: string(name='TranscodeTemplateGroupId', description='The ID of the application.', example='17a9889fc66852*****d791c886700932'),
    }
  ](name='TranscodeTemplateGroupList', description='The lock status of the transcoding template group. Valid values:

*   **Disabled**: The template group is not locked.
*   **Enabled**: The template group is locked.'),
}

model ListTranscodeTemplateGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ListTranscodeTemplateGroupResponseBody(name='body'),
}

/**
  * The ID of the application. Default value: **app-1000000**. For more information, see [Overview](~~113600~~).
  *
 */
async function listTranscodeTemplateGroup(request: ListTranscodeTemplateGroupRequest): ListTranscodeTemplateGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTranscodeTemplateGroup', 'POST', '/', 'json', false, 'json', request);
}

model ListVodTemplateRequest {
  appId?: string(name='AppId', description='The snapshot templates.', example='app-****', position='Query'),
  templateType: string(name='TemplateType', description='Indicates whether the template is the default one. Valid values:

*   **Default**: The template is the default one.
*   **NotDefault**: The template is not the default one.', example='Snapshot', position='Query'),
}

model ListVodTemplateResponseBody = {
  requestId?: string(name='RequestId', description='The time when the template was modified. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2A56B75B-B7E6-48*****27-A9BEAA3E50A8'),
  vodTemplateInfoList?: [ 
    {
      appId?: string(name='AppId', description='The name of the template.', example='app-****'),
      creationTime?: string(name='CreationTime', description='The ID of the application.', example='2018-11-30T08:05:59:57Z'),
      isDefault?: string(name='IsDefault', description='The type of the template. Set the value to **Snapshot**.', example='NotDefault'),
      modifyTime?: string(name='ModifyTime', example='2018-11-30T09:05:59:97Z'),
      name?: string(name='Name', example='test'),
      templateConfig?: string(name='TemplateConfig', description='Queries snapshot templates.', example='{\\"SnapshotConfig\\":{\\"Count\\":10,\\"SpecifiedOffsetTime\\":0,\\"Interval\\":1},\\"SnapshotType\\":\\"NormalSnapshot\\"}'),
      templateType?: string(name='TemplateType', description='The detailed configurations of the template. The value is a JSON-formatted string. For more information about the data structure, see the "SnapshotTemplateConfig" section of the [Media processing parameters](~~98618~~) topic.', example='Snapshot'),
      vodTemplateId?: string(name='VodTemplateId', description='The ID of the request.', example='7c49f2f42b1c*****0969fcd446690'),
    }
  ](name='VodTemplateInfoList', description='The operation that you want to perform. Set the value to **ListVodTemplate**.'),
}

model ListVodTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: ListVodTemplateResponseBody(name='body'),
}

async function listVodTemplate(request: ListVodTemplateRequest): ListVodTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListVodTemplate', 'POST', '/', 'json', false, 'json', request);
}

model ListWatermarkRequest {
  appId?: string(name='AppId', example='app-****', position='Query'),
}

model ListWatermarkResponseBody = {
  requestId?: string(name='RequestId', example='25818875-5F78-4A*****F6-D7393642CA58'),
  watermarkInfos?: [ 
    {
      appId?: string(name='AppId', example='app-****'),
      creationTime?: string(name='CreationTime', example='2018-11-07T09:05:52Z'),
      fileUrl?: string(name='FileUrl', example='https://outin-3262681cd*****89f4b3e7.oss-cn-shanghai.aliyuncs.com/image/cover/8CC8B715E6F8A72EC6B-6-2.png?Expires=1541600583&OSSAccessKeyId=****&Signature=gmf1eYMoDVg%2BHQCb4UGozB****'),
      isDefault?: string(name='IsDefault', example='NotDefault'),
      name?: string(name='Name'),
      type?: string(name='Type', example='Text'),
      watermarkConfig?: string(name='WatermarkConfig'),
      watermarkId?: string(name='WatermarkId', example='9bcc8bfadb843*****109a2671d0df97'),
    }
  ](name='WatermarkInfos'),
}

model ListWatermarkResponse = {
  headers: map[string]string(name='headers'),
  body: ListWatermarkResponseBody(name='body'),
}

async function listWatermark(request: ListWatermarkRequest): ListWatermarkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListWatermark', 'POST', '/', 'json', false, 'json', request);
}

model MoveAppResourceRequest {
  resourceIds: string(name='ResourceIds', description='The operation that you want to perform. Set the value to **MoveAppResource**.', example='9afb4****06de180880e,f7bba****caa546cfe2ba', position='Query'),
  resourceType: string(name='ResourceType', description='The ID of the request.', example='video', position='Query'),
  targetAppId: string(name='TargetAppId', description='The ID of the resource. You can specify a maximum of 20 IDs at a time. Separate them with commas (,).', example='app-****', position='Query'),
}

model MoveAppResourceResponseBody = {
  failedResourceIds?: [ string ](name='FailedResourceIds'),
  nonExistResourceIds?: [ string ](name='NonExistResourceIds'),
  requestId?: string(name='RequestId', description='Migrates one or more resources from an application to another application.', example='25818875-5F78-4A13-BEF6-****'),
}

model MoveAppResourceResponse = {
  headers: map[string]string(name='headers'),
  body: MoveAppResourceResponseBody(name='body'),
}

async function moveAppResource(request: MoveAppResourceRequest): MoveAppResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'MoveAppResource', 'POST', '/', 'json', false, 'json', request);
}

model PreloadVodObjectCachesRequest {
  objectPath: string(name='ObjectPath', example='vod.test.com/test.txt', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model PreloadVodObjectCachesResponseBody = {
  preloadTaskId?: string(name='PreloadTaskId', example='9524****'),
  requestId?: string(name='RequestId', example='E5BD4B50-7A02-493A-*****-97B9024B4135'),
}

model PreloadVodObjectCachesResponse = {
  headers: map[string]string(name='headers'),
  body: PreloadVodObjectCachesResponseBody(name='body'),
}

/**
  * The operation that you want to perform. Set the value to **PreloadVodObjectCaches**.
  *
 */
async function preloadVodObjectCaches(request: PreloadVodObjectCachesRequest): PreloadVodObjectCachesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PreloadVodObjectCaches', 'POST', '/', 'json', false, 'json', request);
}

model ProduceEditingProjectVideoRequest {
  coverURL?: string(name='CoverURL', description='>ApsaraVideo VOD sends a FileUploadComplete event notification after video production is complete, which is similar to the action that is performed after video upload. After the produced video is transcoded, ApsaraVideo VOD sends the StreamTranscodeComplete and TranscodeComplete event notifications.', example='https://example.aliyundoc.com/6AB4D0E1E1C7446888351****.png', position='Query'),
  description?: string(name='Description', description='The description of the online editing project.', example='The ID of the request.', position='Query'),
  mediaMetadata?: string(name='MediaMetadata', description='Produces a video from one or more mezzanine files. You can directly submit mezzanine files by specifying the Timeline parameter. Alternatively, you can submit mezzanine files after you create an online editing project.', example='58928', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  produceConfig?: string(name='ProduceConfig', description='朴灵', example='{"TemplateGroupId":"6d11e25ea30a4c465435c74****"}', position='Query'),
  projectId?: string(name='ProjectId', description='The thumbnail URL of the online editing project.', example='fb2101bf24b4cb318787dc****', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  timeline?: string(name='Timeline', description='The ID of the produced video.

> *   This operation returns the ID of the produced video in synchronous mode.
> *   If this operation returns the MediaId parameter, the video production task is being asynchronously processed.', example='{"VideoTracks":[{"VideoTrackClips":[{"MediaId":"cc3308ac59615a54328bc3443****"},{"MediaId":"da87a9cff645cd88bc6d8326e4****"}]}]}', position='Query'),
  title?: string(name='Title', description='The metadata of the produced video, in JSON format. For more information about the structure, see [MediaMetadata](~~52839~~).', example='The ID of the online editing project.', position='Query'),
  userData?: string(name='UserData', example='{"Extend":{"width":1280,"id":"028a8e56b1ebf6bb7afc74****","height":720},"MessageCallback":{"CallbackURL":"https://example.aliyundoc.com/2016-08-15/proxy/httpcallback/testcallback/","CallbackType":"http"}}', position='Query'),
}

model ProduceEditingProjectVideoResponseBody = {
  mediaId?: string(name='MediaId', example='006204a11bb386bb25491f95f****'),
  projectId?: string(name='ProjectId', example='fb2101bf24b4cb318787dc****'),
  requestId?: string(name='RequestId', example='25818875-5F78-4AF6-D7393642CA58****'),
}

model ProduceEditingProjectVideoResponse = {
  headers: map[string]string(name='headers'),
  body: ProduceEditingProjectVideoResponseBody(name='body'),
}

/**
  * The title of the online editing project.
  *
 */
async function produceEditingProjectVideo(request: ProduceEditingProjectVideoRequest): ProduceEditingProjectVideoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ProduceEditingProjectVideo', 'POST', '/', 'json', false, 'json', request);
}

model RefreshMediaPlayUrlsRequest {
  definitions?: string(name='Definitions', description='Specifies the type of the refresh or prefetch operation. Default value: Single. Valid values:

*   **Single**: Only one latest transcoded stream is refreshed or prefetched for each resolution and format.
*   **Multiple**: All transcoded streams are refreshed or prefetched for each resolution and format.', example='HD, SD', position='Query'),
  formats?: string(name='Formats', description='Specifies the types of media streams you want to refresh or prefetch. You can specify multiple types. Separate multiple types with commas (,). If you leave this parameter empty, media streams in all types are refreshed or prefetched by default. Valid values:

*   **video**
*   **audio**', example='mp4,m3u8', position='Query'),
  mediaIds: string(name='MediaIds', description='Specifies whether to refresh or prefetch the playback URLs of the TS files of the M3U8 media stream. Default value: false. Valid values:

*   **false**
*   **true**', example='ca3a8f6e4957b658067095869****, a6e49sfgd23p5g9ja7095863****', position='Query'),
  resultType?: string(name='ResultType', description='The IDs of the media files that you want to refresh or prefetch. You can specify a maximum of 20 IDs. Separate multiple IDs with commas (,). You can use one of the following methods to obtain the ID:

*   Log on to the [ApsaraVideo VOD](https://vod.console.aliyun.com) console. In the left-side navigation pane, choose **Media Files** > **Audio/Video**. On the Video and Audio page, view the ID of the audio or video file. This method is applicable to files that are uploaded by using the ApsaraVideo VOD console.
*   Obtain the value of VideoId from the response to the [CreateUploadVideo](~~55407~~) operation that you call to upload media files.
*   Obtain the value of VideoId from the response to the [SearchMedia](~~86044~~) operation that you call to query the media ID after the media file is uploaded.', example='Single', position='Query'),
  sliceCount?: int32(name='SliceCount', description='The IDs of the media files that cannot be operated on. In most cases, media files cannot be operated on because you are not authorized to perform the operations. For more information, see [Overview](~~113600~~).', example='5', position='Query'),
  sliceFlag?: boolean(name='SliceFlag', description='The ID of the refresh or prefetch task.', example='false', position='Query'),
  streamType?: string(name='StreamType', description='The custom configurations such as callback configurations and upload acceleration configurations. The value is a JSON string. For more information, see [Request parameter](~~86952~~).
> 
- The callback configurations take effect only after you specify the HTTP callback URL and select specific callback events in the ApsaraVideo VOD console. For more information about how to configure HTTP callback settings in the ApsaraVideo VOD console, see [Configure callback settings](~~86071~~).
- You must submit a ticket to enable the upload acceleration feature. For more information, see [Overview](~~55396~~).', example='video', position='Query'),
  taskType: string(name='TaskType', description='The IDs of the media files that do not exist.', example='Preload', position='Query'),
  userData?: string(name='UserData', description='Specifies the resolutions of the media streams you want to refresh or prefetch. You can specify multiple resolutions. Separate multiple resolutions with commas (,). If you leave this parameter empty, media streams in all resolutions are refreshed or prefetched by default.

>  The value must be supported in the **Definition** section in [Parameters for media assets](~~124671~~).', example='{"MessageCallback":{"CallbackURL":"http://example.aliyundoc.com"}, "Extend":{"localId":"xxx","test":"www"}}', position='Query'),
}

model RefreshMediaPlayUrlsResponseBody = {
  forbiddenMediaIds?: string(name='ForbiddenMediaIds', description='没有多应用权限的视频ID', example='a6e49sfgd23p5g9ja7095863****'),
  mediaRefreshJobId?: string(name='MediaRefreshJobId', description='Submits media refresh or prefetch tasks based on the media IDs.', example='41d465e31957****'),
  nonExistMediaIds?: string(name='NonExistMediaIds', description='不存在的媒资ID', example='ca3a8f6e4957b658067095869****'),
  requestId?: string(name='RequestId', example='25818875-5F78-4AF6-04D5-D7393642****'),
}

model RefreshMediaPlayUrlsResponse = {
  headers: map[string]string(name='headers'),
  body: RefreshMediaPlayUrlsResponseBody(name='body'),
}

/**
  * The formats of the media streams you want to refresh or prefetch. You can specify multiple formats. Separate multiple formats with commas (,). If you leave this parameter empty, media streams in all formats are refreshed or prefetched by default. Valid values:
  * *   **mp4**
  * *   **m3u8**
  * *   **mp3**
  * *   **flv**
  * *   **webm**
  * *   **ts**
  *
 */
async function refreshMediaPlayUrls(request: RefreshMediaPlayUrlsRequest): RefreshMediaPlayUrlsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RefreshMediaPlayUrls', 'POST', '/', 'json', false, 'json', request);
}

model RefreshUploadVideoRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  videoId: string(name='VideoId', description='The operation that you want to perform. Set the value to **RefreshUploadVideo**.', example='c6a23a870c8c4ffcd40cbd381333****', position='Query'),
}

model RefreshUploadVideoResponseBody = {
  requestId?: string(name='RequestId', description='Obtains a new upload credential after the video upload times out.', example='25818875-5F78-4A43-7DF6-D7393642****'),
  uploadAddress?: string(name='UploadAddress', example='eyJTZWN1cml0eVRiQ0FJU3p3TjFxNkZ0NUIyeW****'),
  uploadAuth?: string(name='UploadAuth', example='FJU3p3TZ0NUIyeW****'),
  videoId?: string(name='VideoId', example='c6a23a870c8c4ffcd40cbd381333****'),
}

model RefreshUploadVideoResponse = {
  headers: map[string]string(name='headers'),
  body: RefreshUploadVideoResponseBody(name='body'),
}

/**
  * The upload credential.
  * > The upload credential returned by this operation is Base64-encoded. Before you can use an SDK or an API operation to upload a media asset based on the upload credential, you must decode the upload credential by using the Base64 algorithm. You must parse the upload credential only if you use native OSS SDKs or OSS API for uploads.
  *
 */
async function refreshUploadVideo(request: RefreshUploadVideoRequest): RefreshUploadVideoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RefreshUploadVideo', 'POST', '/', 'json', false, 'json', request);
}

model RefreshVodObjectCachesRequest {
  objectPath: string(name='ObjectPath', description='The granularity of the resources to be refreshed. Valid values:

*   **File**: refreshes one or more files. This is the default value.
*   **Directory**: refreshes the files under one or more directories.', example='abc.com/image/1.png', position='Query'),
  objectType?: string(name='ObjectType', description='Refreshes files on Alibaba Cloud CDN nodes. You can refresh multiple files at a time based on URLs.', example='File', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model RefreshVodObjectCachesResponseBody = {
  refreshTaskId?: string(name='RefreshTaskId', example='70422*****2904'),
  requestId?: string(name='RequestId', example='D61E4801-EAFF-4A63-****-FBF6CE1CFD1C'),
}

model RefreshVodObjectCachesResponse = {
  headers: map[string]string(name='headers'),
  body: RefreshVodObjectCachesResponseBody(name='body'),
}

/**
  * The ID of the refresh task. Separate multiple task IDs with commas (,).
  *
 */
async function refreshVodObjectCaches(request: RefreshVodObjectCachesRequest): RefreshVodObjectCachesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RefreshVodObjectCaches', 'POST', '/', 'json', false, 'json', request);
}

model RegisterMediaRequest {
  registerMetadatas: string(name='RegisterMetadatas', description='The metadata of the media file that you want to register. The value is a JSON string. You can specify the metadata for a maximum of 10 media files at a time. For more information about the metadata of media files, see the **RegisterMetadata** section of this topic.', example='[{"FileURL":"https://****.oss-cn-shanghai.aliyuncs.com/video/test/video123.m3u8","Title":"VideoName"}]', position='Query'),
  templateGroupId?: string(name='TemplateGroupId', description='The ID of the transcoding template group. You can use one of the following methods to obtain the ID of the transcoding template group:
*   Log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com). In the left-side navigation pane, choose **Configuration Management** > **Media Processing** > **Transcoding Template Groups**. On the Transcoding Template Groups page, you can view the ID of the transcoding template group.
*   View the value of the TranscodeTemplateGroupId parameter returned by the [AddTranscodeTemplateGroup](~~102665~~) operation that you called to create a transcoding template group.
*   View the value of the TranscodeTemplateGroupId parameter returned by the [ListTranscodeTemplateGroup](~~102669~~) operation that you called to query a transcoding template group.
> *   If you do not need to transcode the media file, set the TemplateGroupId parameter to VOD_NO_TRANSCODE. Otherwise, an exception occurs during video playback. If you need to transcode the media file, specify the ID of the transcoding template group.
> *   If both the WorkflowId and TemplateGroupId parameters are set, the value of the WorkflowId parameter takes effect. For more information, see [Workflows](~~115347~~).', example='ca3a8f6e49c87b65806709586****', position='Query'),
  userData?: string(name='UserData', description='The custom configurations such as callback configurations. The value is a JSON string. For more information, see the "UserData: specifies the custom configurations for media upload" section of the [Request parameters](~~86952#section\\_6fg_qll_v3w~~) topic.', example='{"Extend":{"localId":"****","test":"www"}}', position='Query'),
  workflowId?: string(name='WorkflowId', description='The ID of the workflow. To view the ID of the workflow, log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com). In the left-side navigation pane, choose **Configuration Management** > **Media Processing** > **Workflows**.
> If both the WorkflowId and TemplateGroupId parameters are set, the value of the WorkflowId parameter takes effect. For more information, see [Workflows](~~115347~~).', example='637adc2b7ba51a83d841606f8****', position='Query'),
}

model RegisterMediaResponseBody = {
  failedFileURLs?: [ string ](name='FailedFileURLs', description='The URLs of the media files that failed to be registered.'),
  registeredMediaList?: [ 
    {
      fileURL?: string(name='FileURL', description='The OSS URL of the media file.', example='http://****.oss-cn-shanghai.aliyuncs.com/vod_sample_01.mp4'),
      mediaId?: string(name='MediaId', description='The ID of the media file that is registered with ApsaraVideo VOD. If the registered media file is an audio or video file, the value of the VideoId parameter returned by ApsaraVideo VOD takes effect.', example='d97af32828084d1896683b1aa38****'),
      newRegister?: boolean(name='NewRegister', description='Indicates whether the media file is newly registered or repeatedly registered. Valid values:  
- **true**: The media file is newly registered.
- **false**: The media file is repeatedly registered.', example='false'),
    }
  ](name='RegisteredMediaList', description='The media files that are registered, including newly registered and repeatedly registered media files.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='14F43C5C-8033-448B-AD04F64E5098****'),
}

model RegisterMediaResponse = {
  headers: map[string]string(name='headers'),
  body: RegisterMediaResponseBody(name='body'),
}

/**
  * After you store an audio or video file in an Object Storage Service (OSS) bucket that is used for ApsaraVideo VOD, you can call the RegisterMedia operation to register the media file. After the media file is registered, you can use the media ID associated with the media file to submit transcoding jobs and snapshot jobs in ApsaraVideo VOD. For more information, see [SubmitTranscodeJobs](~~68570~~) and [SubmitSnapshotJob](~~72213~~).
  * > *   You can register up to 10 OSS media files that have the same storage location at a time.
  * > *   If you use the ApsaraVideo VOD console to upload a media file and do not specify a transcoding template group ID, ApsaraVideo VOD uses the default transcoding template group to transcode the media file. However, if you do not specify a transcoding template group ID when you call the RegisterMedia operation, ApsaraVideo VOD does not automatically transcode the media file after the media file is registered. If you specify a transcoding template group ID, ApsaraVideo VOD uses the specified transcoding template group to transcode the media file.
  * > *   If the media file that you want to register is registered before, this operation returns only the unique media ID that is associated with the media file. No further processing is performed.
  *
 */
async function registerMedia(request: RegisterMediaRequest): RegisterMediaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RegisterMedia', 'POST', '/', 'json', false, 'json', request);
}

model SearchEditingProjectRequest {
  endTime?: string(name='EndTime', description='The beginning of the time range to query. The query is performed based on the time range during which the required online editing projects were created. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.', example='2017-01-11T13:00:00Z', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: string(name='OwnerId', position='Query'),
  pageNo?: int32(name='PageNo', description='The status of the online editing project. Separate multiple states with commas (,). By default, all online editing projects are queried.

Valid values:

*   **Normal**: indicates that the online editing project is in draft.
*   **Producing**: indicates that the video is being produced.
*   **Produced**: indicates that the video was produced.
*   **ProduceFailed**: indicates that the video failed to be produced.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The title of the online editing project.', example='10', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: string(name='ResourceOwnerId', position='Query'),
  sortBy?: string(name='SortBy', description='The title of the online editing project.', example='CreationTime:Desc', position='Query'),
  startTime?: string(name='StartTime', description='The region where the online editing project was created.', example='2017-01-11T12:00:00Z', position='Query'),
  status?: string(name='Status', description='The list of online editing projects.', example='Normal', position='Query'),
  title?: string(name='Title', description='The duration of the online editing project, which must be consistent with the duration of the timeline.

> The Timeline parameter is not included in response parameters.', example='test', position='Query'),
}

model SearchEditingProjectResponseBody = {
  projectList?: {
    project?: [ 
    {
      coverURL?: string(name='CoverURL', description='The ID of the online editing project.', example='cover_url'),
      creationTime?: string(name='CreationTime', description='The end of the time range to query. The query is performed based on the time range during which the required online editing projects were created. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.', example='2017-01-11T12:00:00Z'),
      description?: string(name='Description', description='The thumbnail URL of the online editing project.', example='The ID of the request.'),
      duration?: float(name='Duration', example='22.65'),
      modifiedTime?: string(name='ModifiedTime', description='The number of the page to return. Default value: **1**.', example='2017-01-11T13:00:00Z'),
      projectId?: string(name='ProjectId', description='Queries online editing projects.', example='25cfc178d2de4*****e77aebed6afcd'),
      regionId?: string(name='RegionId', example='cn-shanghai'),
      status?: string(name='Status', description='The sorting rule of results. Valid values:

*   **CreationTime:Desc**: sorts the results based on the creation time in descending order. This is the default value.
*   **CreationTime:Asc**: sorts the results based on the creation time in ascending order.', example='Normal'),
      storageLocation?: string(name='StorageLocation', description='The path of the Object Storage Service (OSS) bucket where the produced video is stored.

> To view the path of the OSS bucket, log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com/?spm=a2c4g.11186623.2.15.6948257eaZ4m54#/vod/settings/censored), and choose **Configuration Management** > **Media Management** > **Storage**. On the Storage page, you can view the path of the OSS bucket.', example='location_s'),
      title?: string(name='Title'),
    }
  ](name='Project')
  }(name='ProjectList', description='The number of entries to return on each page. Default value: **10**. Maximum value: **100**.'),
  requestId?: string(name='RequestId', description='The operation that you want to perform. Set the value to **SearchEditingProject**.', example='9262E3DA-07FA-48*****62-FCBB6BC61D08'),
  total?: int32(name='Total', description='The time when the online editing project was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2'),
}

model SearchEditingProjectResponse = {
  headers: map[string]string(name='headers'),
  body: SearchEditingProjectResponseBody(name='body'),
}

async function searchEditingProject(request: SearchEditingProjectRequest): SearchEditingProjectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SearchEditingProject', 'POST', '/', 'json', false, 'json', request);
}

model SearchMediaRequest {
  fields?: string(name='Fields', description='The level of the category.', example='Title,CoverURL', position='Query'),
  match?: string(name='Match', description='The operation that you want to perform. Set the value to **SearchMedia**.', example='field = value', position='Query'),
  pageNo?: int32(name='PageNo', description='Details about media assets.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The preprocessing status. Only preprocessed videos can be used for live streaming in the production studio. Valid values:

*   **UnPreprocess**
*   **Preprocessing**
*   **PreprocessSucceed**
*   **PreprocessFailed**', example='10', position='Query'),
  scrollToken?: string(name='ScrollToken', description='The size of the video file.', example='24e0fba7188fae707e146esa54****', position='Query'),
  searchType?: string(name='SearchType', description='The ID of the parent category.', example='video', position='Query'),
  sortBy?: string(name='SortBy', description='The list of sprite snapshots.', example='CreationTime:Desc', position='Query'),
}

model SearchMediaResponseBody = {
  mediaList?: [ 
    {
      aiData?: {
        aiLabelInfo?: [ 
          {
            category?: string(name='Category', description='分类'),
            labelId?: string(name='LabelId', description='实体ID'),
            labelName?: string(name='LabelName', description='实体名称'),
            occurrences?: [ 
              {
                from?: double(name='From', description='片段起始时间'),
                score?: double(name='Score', description='打分'),
                to?: double(name='To', description='片段结束时间'),
              }
            ](name='Occurrences', description='片段列表'),
          }
        ](name='AiLabelInfo', description='AI标签信息列表'),
        ocrInfo?: [ 
          {
            content?: string(name='Content', description='文本内容'),
            from?: double(name='From', description='片段起始时间'),
            to?: double(name='To', description='片段结束时间'),
          }
        ](name='OcrInfo', description='字幕信息列表'),
      }(name='AiData', description='AI详细信息'),
      aiRoughData?: {
        aiCategory?: string(name='AiCategory', description='视频AI分类'),
        aiJobId?: string(name='AiJobId', description='AI任务ID'),
        saveType?: string(name='SaveType', description='保存类型'),
        status?: string(name='Status', description='数据状态'),
      }(name='AiRoughData', description='AI简介数据'),
      attachedMedia?: {
        appId?: string(name='AppId', example='app-****'),
        businessType?: string(name='BusinessType', example='watermark'),
        categories?: [ 
          {
            cateId?: long(name='CateId', example='10027394'),
            cateName?: string(name='CateName'),
            level?: long(name='Level', example='1'),
            parentId?: long(name='ParentId', example='-1'),
          }
        ](name='Categories'),
        creationTime?: string(name='CreationTime', description='The ID of the request.', example='2018-07-19T03:45:25Z'),
        description?: string(name='Description'),
        mediaId?: string(name='MediaId', example='a82a2cd7d4e147ba0ed6c1ee372****'),
        modificationTime?: string(name='ModificationTime', example='2018-07-19T03:48:25Z'),
        status?: string(name='Status', description='The endpoint of the OSS bucket in which the audio file is stored.', example='Normal'),
        storageLocation?: string(name='StorageLocation', description='Queries the information about media assets such as video, audio, and image files, and auxiliary media assets.', example='outin-bfefbb90a47c11*****7426.oss-cn-shanghai.aliyuncs.com'),
        tags?: string(name='Tags'),
        title?: string(name='Title'),
        URL?: string(name='URL', example='https://example.com/****.png'),
      }(name='AttachedMedia', description='The URL of the thumbnail.'),
      audio?: {
        appId?: string(name='AppId', description='The number of the page to return. Default value: **1**.

> If the value of this parameter exceeds **200**, we recommend that you set the ScrollToken parameter as well.', example='app-****'),
        audioId?: string(name='AudioId', description='The name of the category.', example='a82a2cd7d4e147bbed6c1ee372****'),
        cateId?: long(name='CateId', description='The size of the audio file.', example='10000123'),
        cateName?: string(name='CateName', description='The status of the auxiliary media asset. Valid values:

*   **Uploading**: The auxiliary media asset is being uploaded. This is the initial status.
*   **Normal**: The auxiliary media asset is uploaded.
*   **UploadFail**: The auxiliary media asset fails to be uploaded.', example='ceshi'),
        coverURL?: string(name='CoverURL', description='The type of the auxiliary media asset. Valid values:

*   **watermark**
*   **subtitle**
*   **material**', example='http://example.com/image04.jpg'),
        creationTime?: string(name='CreationTime', description='The sort field and order. Separate multiple values with commas (,). Default value: CreationTime:Desc. Valid values:

*   **CreationTime:Desc**: The results are sorted in reverse chronological order based on the creation time.
*   **CreationTime:Asc**: The results are sorted in chronological order based on the creation time.

> * For more information about the sort field, see "Sort field" in the [Search for media asset information](~~99179~~) topic.
> * To obtain the first 5,000 data records that meet the specified filter criteria, you can specify a maximum of three sort fields.
> * To obtain all the data records that meet the specified filter criteria, you can specify only one sort field.', example='2018-07-19T03:45:25Z'),
        description?: string(name='Description', description='The tags of the video file.', example='The pagination identifier.'),
        downloadSwitch?: string(name='DownloadSwitch', description='The number of entries to return on each page. Default value: **10**. Maximum value: **100**.', example='on'),
        duration?: float(name='Duration', description='The time when the audio file was updated. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='123'),
        mediaSource?: string(name='MediaSource', description='The URL of the auxiliary media asset.', example='general'),
        modificationTime?: string(name='ModificationTime', description='The duration of the audio file.', example='2018-07-19T03:48:25Z'),
        preprocessStatus?: string(name='PreprocessStatus', description='The ID of the auxiliary media asset.', example='UnPreprocess'),
        restoreExpiration?: string(name='RestoreExpiration'),
        restoreStatus?: string(name='RestoreStatus'),
        size?: long(name='Size', description='The name of the category.', example='123'),
        snapshots?: [ string ](name='Snapshots', description='[Details about audio files](~~86991~~).'),
        spriteSnapshots?: [ string ](name='SpriteSnapshots', description='The time when the image file was updated. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.'),
        status?: string(name='Status', description='The endpoint of the OSS bucket in which the auxiliary media asset is stored.', example='Normal'),
        storageClass?: string(name='StorageClass'),
        storageLocation?: string(name='StorageLocation', description='The name of the category.', example='outin-aaa*****aa.oss-cn-shanghai.aliyuncs.com'),
        tags?: string(name='Tags', description='The source. Valid values:

*   **general**: The video file is uploaded by using ApsaraVideo VOD.
*   **short_video**: The video file is uploaded by using the short video SDK.
*   **editing**: The video file is produced after online editing.
*   **live**: The video stream is recorded and uploaded as a file.', example='tag1,tag2'),
        title?: string(name='Title', description='The total number of data records that meet the specified filter criteria.', example='The title of the video file.'),
        transcodeMode?: string(name='TranscodeMode', description='The time when the auxiliary media asset was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='FastTranscode'),
      }(name='Audio', description='The time when the auxiliary media asset was updated. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.'),
      creationTime?: string(name='CreationTime', description='The title of the auxiliary media asset.', example='2018-07-19T03:45:25Z'),
      image?: {
        appId?: string(name='AppId', description='The ID of the image file.', example='app-****'),
        cateId?: long(name='CateId', description='The ID of the application.', example='1000123'),
        cateName?: string(name='CateName', description='The duration of the video file. Unit: seconds.', example='The list of automatic snapshots.'),
        creationTime?: string(name='CreationTime', description='The category ID of the image file.', example='2018-07-19T03:45:25Z'),
        description?: string(name='Description', description='The URL of the thumbnail.', example='The tags of the auxiliary media asset.'),
        imageId?: string(name='ImageId', description='The ID of the audio file.', example='11130843741se99wqmoes****'),
        modificationTime?: string(name='ModificationTime', description='The type of the media asset. Valid values:

*   **video**
*   **audio**
*   **image**
*   **attached**', example='2018-07-19T03:48:25Z'),
        status?: string(name='Status', description='The time when the video file was updated. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='Uploading'),
        storageLocation?: string(name='StorageLocation', description='The ID of the video file.', example='outin-bfefbb90a47c******163e1c7426.oss-cn-shanghai.aliyuncs.com'),
        tags?: string(name='Tags', description='[Details about auxiliary media assets](~~86991~~).', example='tag1'),
        title?: string(name='Title', description='The category ID of the video file.', example='image1'),
        URL?: string(name='URL', description='The ID of the application.', example='https://example.com/****.png'),
      }(name='Image', description='The pagination identifier. The identifier can be up to 32 characters in length.

The first time you call this operation for each new search, you do not need to specify this parameter. The value of this parameter is returned each time data records that meet the specified filter criteria are found. The value is used to record the current position of queried data. Record the returned parameter value and set this parameter according to the following requirements during the next search:

*   If SearchType is set to **video** or **audio** and you need to traverse all data that meets the filter criteria, you must set the ScrollToken parameter.
*   If the value of the PageNo parameter exceeds **200**, we recommend that you set this parameter to optimize search performance.'),
      mediaId?: string(name='MediaId', description='The description of the video file.', example='a82a2cd7d4e147bbed6c1ee372****'),
      mediaType?: string(name='MediaType', description='The status of the audio file. Valid values:

*   **Uploading**
*   **Normal**
*   **UploadFail**
*   **Deleted**', example='video'),
      video?: {
        appId?: string(name='AppId', description='[Details about video files](~~86991~~).', example='app-****'),
        cateId?: long(name='CateId', description='The ID of the application.', example='10000123'),
        cateName?: string(name='CateName', description='The filter condition. For more information about the syntax, see [Protocol for media asset search](~~86991~~).', example='video1'),
        coverURL?: string(name='CoverURL', description='The endpoint of the OSS bucket in which the image file is stored.', example='https://example.aliyundoc.com/image01.png'),
        creationTime?: string(name='CreationTime', description='The time when the media asset was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2018-07-19T03:45:25Z'),
        description?: string(name='Description', description='The title of the image file.', example='The description of the audio file.'),
        downloadSwitch?: string(name='DownloadSwitch', description='The download switch. The audio file can be downloaded offline only when the download switch is turned on. Valid values:

*   **on**
*   **off**', example='on'),
        duration?: float(name='Duration', description='The category ID of the audio file.', example='123'),
        mediaSource?: string(name='MediaSource', description='The status of the video file. Valid values:

*   **Uploading**
*   **UploadFail**
*   **UploadSucc**
*   **Transcoding**
*   **TranscodeFail**
*   **Blocked**
*   **Normal**', example='general'),
        modificationTime?: string(name='ModificationTime', description='The time when the audio file was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2018-07-19T03:48:25Z'),
        preprocessStatus?: string(name='PreprocessStatus', description='The ID of the application.', example='Preprocessing'),
        restoreExpiration?: string(name='RestoreExpiration'),
        restoreStatus?: string(name='RestoreStatus'),
        size?: long(name='Size', description='The name of the category.', example='123'),
        snapshots?: [ string ](name='Snapshots', description='The title of the audio file.'),
        spriteSnapshots?: [ string ](name='SpriteSnapshots', description='The time when the image file was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.'),
        status?: string(name='Status', description='The description of the image file.', example='UploadSucc'),
        storageClass?: string(name='StorageClass'),
        storageLocation?: string(name='StorageLocation', description='The download switch. The video file can be downloaded offline only when the download switch is turned on. Valid values:

*   **on**
*   **off**', example='outin-bfefbb90a47c******163e1c7426.oss-cn-shanghai.aliyuncs.com'),
        tags?: string(name='Tags', description='The category ID of the auxiliary media asset.', example='tag1'),
        title?: string(name='Title', description='The URL of the image file.', example='ceshi'),
        transcodeMode?: string(name='TranscodeMode', description='The time when the video file was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='FastTranscode'),
        videoId?: string(name='VideoId', description='The media asset fields to return in the query results.

By default, only the basic media asset fields are returned. You can specify additional media asset fields that need to be returned in the request. For more information, see the "API examples" section of the [Search for media asset information](~~99179~~) topic.', example='a82a2asdasqadaf3faa0ed6c1ee372****'),
      }(name='Video', description='The list of category IDs.'),
    }
  ](name='MediaList', description='The tags of the audio file.'),
  requestId?: string(name='RequestId', description='The type of the media asset that you want to query. Default value: video. Valid values:

*   **video**
*   **audio**
*   **image**
*   **attached**

> If this parameter is set to **video** or **audio** and you want to traverse all data that meets the filter criteria, you must set the ScrollToken parameter.', example='3E0CEF83-FB09-4E34-BA1451814B03****'),
  scrollToken?: string(name='ScrollToken', description='The transcoding mode. Default value: FastTranscode. Valid values:

*   **FastTranscode**: The video file is immediately transcoded after it is uploaded. You cannot play the file before it is transcoded.
*   **NoTranscode**: The video file can be played without being transcoded. You can immediately play the file after it is uploaded.
*   **AsyncTranscode**: The video file can be immediately played and asynchronously transcoded after it is uploaded.', example='24e0fba7188fae707e146esa54****'),
  total?: long(name='Total', description='The tags of the image file.', example='10'),
}

model SearchMediaResponse = {
  headers: map[string]string(name='headers'),
  body: SearchMediaResponseBody(name='body'),
}

/**
  * The preprocessing status. Valid values:
  * *   **UnPreprocess**
  * *   **Preprocessing**
  * *   **PreprocessSucceed**
  * *   **PreprocessFailed**
  *
 */
async function searchMedia(request: SearchMediaRequest): SearchMediaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SearchMedia', 'POST', '/', 'json', false, 'json', request);
}

model SetAuditSecurityIpRequest {
  ips: string(name='Ips', description='Manages the IP addresses in review security groups.', example='192.168.0.1', position='Query'),
  operateMode?: string(name='OperateMode', example='Cover', position='Query'),
  securityGroupName?: string(name='SecurityGroupName', description='The IP addresses to be added to a review security group. You can add a maximum of 100 IP addresses to each review security group. Separate multiple IP addresses with commas (,). You can enter individual IP addresses or a CIDR block.

*   Individual IP address: for example, 10.23.12.24
*   CIDR block: for example, 10.23.12.24/24, where /24 indicates that the prefix of the CIDR block is 24 bits in length. You can replace 24 with a value that ranges from `1 to 32`.', example='Default', position='Query'),
}

model SetAuditSecurityIpResponseBody = {
  requestId?: string(name='RequestId', example='25818875-5F78-4AF6-D7393642CA58****'),
}

model SetAuditSecurityIpResponse = {
  headers: map[string]string(name='headers'),
  body: SetAuditSecurityIpResponseBody(name='body'),
}

/**
  * The name of the review security group. Default value: **Default**. You can specify a maximum of 10 review security groups.
  *
 */
async function setAuditSecurityIp(request: SetAuditSecurityIpRequest): SetAuditSecurityIpResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetAuditSecurityIp', 'POST', '/', 'json', false, 'json', request);
}

model SetCrossdomainContentRequest {
  content: string(name='Content', description='The URL of the Object Storage Service (OSS) bucket.', example='&lt;cross-domain-policy&gt;&lt;allow-access-from domain="*"/&gt;&lt;allow-http-request-headers-from domain="*" headers="*" secure="false"/&gt;&lt;/cross-domain-policy&gt;', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: string(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: string(name='ResourceOwnerId', position='Query'),
  resourceRealOwnerId?: string(name='ResourceRealOwnerId', example='3461111', position='Query'),
  storageLocation: string(name='StorageLocation', description='Updates the cross-domain policy file crossdomain.xml.', example='outin-67870fd5b****1e98a3900163e1c35d5.oss-cn-shanghai.aliyuncs.com', position='Query'),
}

model SetCrossdomainContentResponseBody = {
  requestId?: string(name='RequestId', example='25818875-5F78-4A13-****-D7393642CA58'),
}

model SetCrossdomainContentResponse = {
  headers: map[string]string(name='headers'),
  body: SetCrossdomainContentResponseBody(name='body'),
}

/**
  * The ID of the request.
  *
 */
async function setCrossdomainContent(request: SetCrossdomainContentRequest): SetCrossdomainContentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetCrossdomainContent', 'POST', '/', 'json', false, 'json', request);
}

model SetDefaultAITemplateRequest {
  templateId: string(name='TemplateId', description='Specifies an AI template as the default template.', example='1706a0063dd733f6a823ef32e0a5****', position='Query'),
}

model SetDefaultAITemplateResponseBody = {
  requestId?: string(name='RequestId', example='8E70E3F8-E2EE-47BC-4677-379D6F28****'),
  templateId?: string(name='TemplateId', example='1706a0063dd733f6a823ef32e0a5****'),
}

model SetDefaultAITemplateResponse = {
  headers: map[string]string(name='headers'),
  body: SetDefaultAITemplateResponseBody(name='body'),
}

/**
  * The ID of the request.
  *
 */
async function setDefaultAITemplate(request: SetDefaultAITemplateRequest): SetDefaultAITemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetDefaultAITemplate', 'POST', '/', 'json', false, 'json', request);
}

model SetDefaultTranscodeTemplateGroupRequest {
  transcodeTemplateGroupId: string(name='TranscodeTemplateGroupId', example='d58079958be8d*****b699ab7ab6e1bf', position='Query'),
}

model SetDefaultTranscodeTemplateGroupResponseBody = {
  requestId?: string(name='RequestId', example='25818875-5F78-4A*****F6-D7393642CA58'),
}

model SetDefaultTranscodeTemplateGroupResponse = {
  headers: map[string]string(name='headers'),
  body: SetDefaultTranscodeTemplateGroupResponseBody(name='body'),
}

async function setDefaultTranscodeTemplateGroup(request: SetDefaultTranscodeTemplateGroupRequest): SetDefaultTranscodeTemplateGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetDefaultTranscodeTemplateGroup', 'POST', '/', 'json', false, 'json', request);
}

model SetDefaultWatermarkRequest {
  watermarkId: string(name='WatermarkId', example='9bcc8bfadb843f*****09a2671d0df97', position='Query'),
}

model SetDefaultWatermarkResponseBody = {
  requestId?: string(name='RequestId', example='25818875-5F78-4A*****F6-D7393642CA58'),
}

model SetDefaultWatermarkResponse = {
  headers: map[string]string(name='headers'),
  body: SetDefaultWatermarkResponseBody(name='body'),
}

async function setDefaultWatermark(request: SetDefaultWatermarkRequest): SetDefaultWatermarkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetDefaultWatermark', 'POST', '/', 'json', false, 'json', request);
}

model SetEditingProjectMaterialsRequest {
  materialIds: string(name='MaterialIds', example='9e3101bf24bf41c*****123318788ca', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: string(name='OwnerId', position='Query'),
  projectId: string(name='ProjectId', description='Sets materials to be edited for an online editing project.', example='fb2101bf24bf4*****754cb318787dc', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: string(name='ResourceOwnerId', position='Query'),
}

model SetEditingProjectMaterialsResponseBody = {
  requestId?: string(name='RequestId', example='746FFA07-8BBB-46*****B1-3E94E3B2915E'),
}

model SetEditingProjectMaterialsResponse = {
  headers: map[string]string(name='headers'),
  body: SetEditingProjectMaterialsResponseBody(name='body'),
}

async function setEditingProjectMaterials(request: SetEditingProjectMaterialsRequest): SetEditingProjectMaterialsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetEditingProjectMaterials', 'POST', '/', 'json', false, 'json', request);
}

model SetMessageCallbackRequest {
  appId?: string(name='AppId', description='The ID of the application. If you do not set this parameter, the default value **app-1000000** is used.', example='app-1000000', position='Query'),
  authKey?: string(name='AuthKey', description='The cryptographic key. This parameter only takes effect when the CallbackType parameter is set to HTTP. The key can be up to 32 characters in length and must contain uppercase letters, lowercase letters, and digits.', example='dsf346dvet', position='Query'),
  authSwitch?: string(name='AuthSwitch', description='Specifies whether to enable callback authentication. This parameter only takes effect when the CallbackType parameter is set to HTTP. Valid values:

*   **on**: enables authentication.
*   **off**: disables authentication.', example='on', position='Query'),
  callbackType?: string(name='CallbackType', description='The callback method. Valid values:

*   **HTTP**
*   **MNS**', example='HTTP', position='Query'),
  callbackURL?: string(name='CallbackURL', description='The callback URL. This parameter only takes effect when the CallbackType parameter is set to HTTP.', example='http://developer.aliyundoc.com', position='Query'),
  eventTypeList?: string(name='EventTypeList', description='The type of the callback event. If you do not set this parameter, notifications for all types of events are disabled. If you set this parameter to ALL, notifications for all types of events are enabled. You can specify the event types for which notifications are enabled. Separate multiple event types with commas (,). For more information about the valid values of this parameter, see [Event type](~~55627~~).', example='FileUploadComplete', position='Query'),
  mnsEndpoint?: string(name='MnsEndpoint', description='The public endpoint of Message Service (MNS). This parameter only takes effect when the CallbackType parameter is set to MNS. For more information, see [Endpoint](~~27480#concept-2028913~~ "An endpoint is the address that you specify for a subscription to receive messages. When messages are published to a topic, Message Service (MNS) pushes the messages to the specified endpoints. You can specify the same endpoint for multiple subscriptions.").', example='http://****.mns.cn-shanghai.aliyuncs.com/', position='Query'),
  mnsQueueName?: string(name='MnsQueueName', description='The name of the MNS queue. This parameter only takes effect when the CallbackType parameter is set to MNS.', example='quene_name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
}

model SetMessageCallbackResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='25818875-5F78-4AF6-D7393642CA58****'),
}

model SetMessageCallbackResponse = {
  headers: map[string]string(name='headers'),
  body: SetMessageCallbackResponseBody(name='body'),
}

/**
  * ## Usage note
  * ApsaraVideo VOD supports the HTTP and MNS callback methods. For more information, see [Event notification](~~55627~~).
  *
 */
async function setMessageCallback(request: SetMessageCallbackRequest): SetMessageCallbackResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetMessageCallback', 'POST', '/', 'json', false, 'json', request);
}

model SetVodDomainCertificateRequest {
  certName?: string(name='CertName', description='The name of the certificate.', example='cert_name', position='Query'),
  domainName: string(name='DomainName', description='The domain name that is secured by the certificate. The domain name must use HTTPS acceleration.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  SSLPri?: string(name='SSLPri', description='The private key. This parameter is required only if you enable the SSL certificate.', example='****', position='Query'),
  SSLProtocol: string(name='SSLProtocol', description='Specifies whether to enable the SSL certificate. Default value: off. Valid values:

*   **on**
*   **off**', example='off', position='Query'),
  SSLPub?: string(name='SSLPub', description='The content of the certificate. This parameter is required only if you enable the SSL certificate.', example='****', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model SetVodDomainCertificateResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-****-6C044FE73368'),
}

model SetVodDomainCertificateResponse = {
  headers: map[string]string(name='headers'),
  body: SetVodDomainCertificateResponseBody(name='body'),
}

/**
  * > This operation is available only in the **China (Shanghai)** region.
  *
 */
async function setVodDomainCertificate(request: SetVodDomainCertificateRequest): SetVodDomainCertificateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetVodDomainCertificate', 'POST', '/', 'json', false, 'json', request);
}

model SubmitAIImageAuditJobRequest {
  mediaAuditConfiguration?: string(name='MediaAuditConfiguration', example='{"ResourceType":"****_short_video"}', position='Query'),
  mediaId: string(name='MediaId', description='Submits an automated review task for an image. After the task is submitted, the task is processed in an asynchronous manner. The operation may return a response before the task is complete.', example='f1aa3024aee64*****6dc8ca20dbc320', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: string(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: string(name='ResourceOwnerId', position='Query'),
  templateId: string(name='TemplateId', example='VOD-0003-00****', position='Query'),
}

model SubmitAIImageAuditJobResponseBody = {
  jobId?: string(name='JobId', example='b1aa3024aee64*****6dc8ca20dbc328'),
  requestId?: string(name='RequestId', example='6F42D500-1956-4B*****30-C09E755F4F4B'),
}

model SubmitAIImageAuditJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitAIImageAuditJobResponseBody(name='body'),
}

async function submitAIImageAuditJob(request: SubmitAIImageAuditJobRequest): SubmitAIImageAuditJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SubmitAIImageAuditJob', 'POST', '/', 'json', false, 'json', request);
}

model SubmitAIImageJobRequest {
  AIPipelineId?: string(name='AIPipelineId', description='The ID of the request.', example='6492025b8f*****6ba5bb755a33438', position='Query'),
  AITemplateId: string(name='AITemplateId', description='The user data.

*   The value must be a JSON string.
*   You must specify the MessageCallback or Extend parameter.
*   The value can contain a maximum of 512 bytes.

For more information, see the "UserData: specifies the custom configurations for media upload" section of the [Request parameters](~~86952~~) topic.', example='ef1a8842cb9f*****cea80cad902e416', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: string(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: string(name='ResourceOwnerId', position='Query'),
  userData?: string(name='UserData', description='The ID of the pipeline that is used for the AI processing job.

<props="china">> This parameter is optional if you have specified a default pipeline ID. If you need to submit image AI processing jobs in a batch to a specific pipeline, [submit a ticket](https://smartservice.console.aliyun.com/service/create-ticket?product=vod) to contact Alibaba Cloud technical support.</props>
<props="intl">> This parameter is optional if you have specified a default pipeline ID. If you need to submit image AI processing jobs in a batch to a specific pipeline, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12672711.top-nav.ditem-sub.3cd51fa3WvRsjz#/ticket/add/?productId=1270) to contact Alibaba Cloud technical support.</props>', example='{"Extend":{"localId":"****","test":"www"}}', position='Query'),
  videoId: string(name='VideoId', description='The ID of the AI template. You can use one of the following methods to obtain the ID:

*   Obtain the value of TemplateId from the response to the [AddAITemplate](~~102930~~) that you call to create the template.
*   Obtain the value of TemplateId from the response to the [ListAITemplate](~~102936~~) operation after you create the template.', example='357a8748c5774*****89d2726e6436aa', position='Query'),
}

model SubmitAIImageJobResponseBody = {
  jobId?: string(name='JobId', example='cf08a2c6e11e*****de1711b738b9067'),
  requestId?: string(name='RequestId', example='218A6807-A21E-43*****54-C0512880B0B0'),
}

model SubmitAIImageJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitAIImageJobResponseBody(name='body'),
}

/**
  * The returned data.
  *
 */
async function submitAIImageJob(request: SubmitAIImageJobRequest): SubmitAIImageJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SubmitAIImageJob', 'POST', '/', 'json', false, 'json', request);
}

model SubmitAIJobRequest {
  config?: string(name='Config', description='The configurations of the AI job. The value is a JSON string.', example='{"AIVideoTag": {"AnalyseTypes": "Face,ASR"} }', position='Query'),
  mediaId?: string(name='MediaId', description='The type of the AI job. Separate multiple types with commas (,). Valid values:

*   **AIMediaDNA**: The media fingerprinting job.
*   **AIVideoTag**: The smart tagging job.', example='3D3D12340d9401fab46a0b847****', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: string(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: string(name='ResourceOwnerId', position='Query'),
  types?: string(name='Types', description='The ID of the AI job.', example='AIVideoTag', position='Query'),
  userData?: string(name='UserData', description='The custom settings. The value is a JSON string. For more information, see [Request parameters](~~86952#h2--userdata-div-id-userdata-div-3~~).', example='{"Extend":{"localId":"***","test":"www"}}', position='Query'),
}

model SubmitAIJobResponseBody = {
  AIJobList?: {
    AIJob?: [ 
    {
      jobId?: string(name='JobId', example='9e82640c85114bf5af23edfaf****'),
      mediaId?: string(name='MediaId', example='3D3D12340d92c641401fab46a0b847****'),
      type?: string(name='Type', description='SubmitAIJob', example='AIVideoTag'),
    }
  ](name='AIJob')
  }(name='AIJobList', description='The ID of the video.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='25818875-5F78-4A13-BEF6-D73936****'),
}

model SubmitAIJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitAIJobResponseBody(name='body'),
}

/**
  * The returned data.
  *
 */
async function submitAIJob(request: SubmitAIJobRequest): SubmitAIJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SubmitAIJob', 'POST', '/', 'json', false, 'json', request);
}

model SubmitAIMediaAuditJobRequest {
  mediaAuditConfiguration?: string(name='MediaAuditConfiguration', description='Submits an automated review task. After a task is submitted, the task is processed in an asynchronous manner. The operation may return a response before the task is complete.', example='{"ResourceType":"****_movie"}', position='Query'),
  mediaId: string(name='MediaId', description='The type of the media file. Only **video** is supported.', example='fe028d09441afffb138cd7ee****', position='Query'),
  mediaType?: string(name='MediaType', description='The configuration information about the review task.

*   Other configuration items of the review task. Only the ResourceType field is supported. This field is used to specify the type of media files. You can adjust review standards and rules based on the type of media files.
*   If you want to adjust review standards and rules based on ResourceType, submit a ticket to request technical support.
*   The value of ResourceType can contain only letters, digits, and underscores (\\_).', example='video', position='Query'),
  templateId?: string(name='TemplateId', description='The ID of the request.', example='a07a7f7d7d10eb9fd999e56ecc****', position='Query'),
  userData?: string(name='UserData', description='The operation that you want to perform. Set the value to **SubmitAIMediaAuditJob**.', example='{"MessageCallback":{"CallbackURL":"http://test.test.com"},"Extend":{"localId":"xxx","test":"www"}}', position='Query'),
}

model SubmitAIMediaAuditJobResponseBody = {
  jobId?: string(name='JobId', example='bdbc266af6893943a70176d92e99****'),
  mediaId?: string(name='MediaId', example='fe028d09441afffb138cd7ee****'),
  requestId?: string(name='RequestId', example='F4631053-8D9F-42B2-4A67281DB88E****'),
}

model SubmitAIMediaAuditJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitAIMediaAuditJobResponseBody(name='body'),
}

async function submitAIMediaAuditJob(request: SubmitAIMediaAuditJobRequest): SubmitAIMediaAuditJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SubmitAIMediaAuditJob', 'POST', '/', 'json', false, 'json', request);
}

model SubmitDynamicImageJobRequest {
  dynamicImageTemplateId: string(name='DynamicImageTemplateId', description='The ID of the animated image template.', example='1a443dc52ef10abc4794d700*****', position='Query'),
  overrideParams?: string(name='OverrideParams', description='The ID of the animated image job.', example='{"Watermarks":[{"Content":"UserID: 666**","WatermarkId":"8ca03c884944bd05efccc312367****"}]}', position='Query'),
  videoId: string(name='VideoId', description='The returned data.', example='7d2fbc3e273441bdb0e08e55f8****', position='Query'),
}

model SubmitDynamicImageJobResponseBody = {
  dynamicImageJob?: {
    jobId?: string(name='JobId', description='The operation that you want to perform. Set the value to **SubmitDynamicImageJob**.', example='ad90a501b1bfb72374ad0050746****'),
  }(name='DynamicImageJob', description='The ID of the request.'),
  requestId?: string(name='RequestId', description='The parameters used for overriding. The value is a JSON-formatted string. For more information, see the "OverrideParams" section of the [Media processing parameters](~~98618~~) topic. The parameters are used to replace the parameters in the animated image template. For more information, see the [Basic data types](~~52839~~) topic.', example='25818875-5F78-74A6-BEF6-D7393642****'),
}

model SubmitDynamicImageJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitDynamicImageJobResponseBody(name='body'),
}

/**
  * The ID of the video.
  *
 */
async function submitDynamicImageJob(request: SubmitDynamicImageJobRequest): SubmitDynamicImageJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SubmitDynamicImageJob', 'POST', '/', 'json', false, 'json', request);
}

model SubmitMediaDNADeleteJobRequest {
  mediaId: string(name='MediaId', description='Deletes a video fingerprinting job.', example='656eaaa8c43a4597******1f09a36', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: string(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: string(name='ResourceOwnerId', position='Query'),
}

model SubmitMediaDNADeleteJobResponseBody = {
  jobId?: string(name='JobId', example='6805B2EC-CE87-****-8FF6-9C0E97719A26'),
  requestId?: string(name='RequestId', example='e5b1a2e7bee******b632c2710b9423f'),
}

model SubmitMediaDNADeleteJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitMediaDNADeleteJobResponseBody(name='body'),
}

/**
  * The ID of the request.
  *
 */
async function submitMediaDNADeleteJob(request: SubmitMediaDNADeleteJobRequest): SubmitMediaDNADeleteJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SubmitMediaDNADeleteJob', 'POST', '/', 'json', false, 'json', request);
}

model SubmitPreprocessJobsRequest {
  preprocessType: string(name='PreprocessType', example='LivePreprocess', position='Query'),
  videoId: string(name='VideoId', description='The operation that you want to perform. Set the value to **SubmitPreprocessJobs**.', example='d3e680e618708efbf2cae7cc9312****', position='Query'),
}

model SubmitPreprocessJobsResponseBody = {
  preprocessJobs?: {
    preprocessJob?: [ 
    {
      jobId?: string(name='JobId', example='bb396607fd11fee9effbb99c4****'),
    }
  ](name='PreprocessJob')
  }(name='PreprocessJobs'),
  requestId?: string(name='RequestId', example='E4EBD2BF-5EB0-4476-8829-9D94E1B1****'),
}

model SubmitPreprocessJobsResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitPreprocessJobsResponseBody(name='body'),
}

/**
  * The ID of the job.
  *
 */
async function submitPreprocessJobs(request: SubmitPreprocessJobsRequest): SubmitPreprocessJobsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SubmitPreprocessJobs', 'POST', '/', 'json', false, 'json', request);
}

model SubmitSnapshotJobRequest {
  count?: long(name='Count', description='The snapshot interval. The value must be **greater than or equal to 0**. Unit: seconds. If you set this parameter to **0**, snapshots are taken at even intervals based on the video duration divided by the value of the Count parameter. Default value: **1**.', example='1', position='Query'),
  height?: string(name='Height', description='The ID of the snapshot job.', example='720', position='Query'),
  interval?: long(name='Interval', description='The custom configurations, including the configuration of transparent data transmission and callback configurations. The value is a JSON-formatted string. For more information, see [UserData](~~86952~~).

**

**Note** The callback configurations take effect only when you specify the HTTP callback URL and select the specific callback events in the ApsaraVideo VOD console.', example='1', position='Query'),
  snapshotTemplateId?: string(name='SnapshotTemplateId', description='The height of each snapshot. Valid values: `[8,4096]`. By default, the height of the video mezzanine file is used. Unit: pixel.', example='f5b228fe693bf55bd87b789****', position='Query'),
  specifiedOffsetTime?: long(name='SpecifiedOffsetTime', description='The operation that you want to perform. Set the value to **SubmitSnapshotJob**.', example='0', position='Query'),
  spriteSnapshotConfig?: string(name='SpriteSnapshotConfig', description='The ID of the video.', example='{\\"CellWidth\\": 120, \\"CellHeight\\": 68, \\"Columns\\": 3,\\"Lines\\": 10, \\"Padding\\": 20, \\"Margin\\": 50}', position='Query'),
  userData?: string(name='UserData', description='The ID of the request.', example='{"MessageCallback":{"CallbackURL":"http://.example.aliyundoc.com"},"Extend":{"localId":"xxx","example":"www"}}', position='Query'),
  videoId?: string(name='VideoId', description='The sprite snapshot configuration. If you set this parameter, sprite snapshots are generated. For more information, see [SpriteSnapshotConfig](~~86952~~).', example='d3e680e618708efbf2cae7cc9312****', position='Query'),
  width?: string(name='Width', description='The maximum number of snapshots. Default value: **1**.', example='1280', position='Query'),
}

model SubmitSnapshotJobResponseBody = {
  requestId?: string(name='RequestId', description='Submits a snapshot job for a video and starts asynchronous snapshot processing.', example='25818875-5F78-5EB0-4AF6-D7393642****'),
  snapshotJob?: {
    jobId?: string(name='JobId', example='ad90a501b1b94b72374ad0050464****'),
  }(name='SnapshotJob'),
}

model SubmitSnapshotJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitSnapshotJobResponseBody(name='body'),
}

/**
  * The ID of the snapshot template.
  * *   We recommend that you create a snapshot template before you specify the ID of the snapshot template.
  * *   If you set the SnapshotTemplateId parameter, all the other request parameters except the Action and VideoId parameters are ignored.
  * *   For more information about how to create a snapshot template, see [AddVodTemplate](~~99406~~).
  *
 */
async function submitSnapshotJob(request: SubmitSnapshotJobRequest): SubmitSnapshotJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SubmitSnapshotJob', 'POST', '/', 'json', false, 'json', request);
}

model SubmitTranscodeJobsRequest {
  encryptConfig?: string(name='EncryptConfig', description='The ID of the video.
> The VideoId parameter is required.', example='{"CipherText":"ZjJmZGViNzUtZWY1Mi00Y2RlLTk3****", "DecryptKeyUri":"http://demo.aliyundoc.com?CipherText=ZjJmZGViNzUtZWY1Mi00Y2RlLTk3****","KeyServiceType":"KMS"}', position='Query'),
  overrideParams?: string(name='OverrideParams', description='The transcoding jobs.
> This parameter is not returned for HLS packaging tasks. You must asynchronously receive the transcoding result.', example='{"Watermarks":[{"WatermarkId":"af2afe4761992c47dae973374****","FileUrl":"http://developer.aliyundoc.com/image/image.png"},{"WatermarkId":"e8e5b8038d7ada85b376c2707****","Content":"watermark test"}]}', position='Query'),
  pipelineId?: string(name='PipelineId', description='The priority of the current transcoding job in all queued jobs.
*   Valid values: **1** to **10**.
*   A value of **10** indicates the highest priority.
*   Default value: **6**.
> This parameter specifies the priority of only the current transcoding job in all queued jobs and does not affect the priorities of jobs that are running.', example='d3e680e618708erf45fbf2cae7c****', position='Query'),
  priority?: string(name='Priority', description='The encryption configurations. The value is a JSON-formatted string. This parameter is required only when HLS encryption is used.
> *   In the JSON-formatted string of the [EncryptConfig](~~86952~~) parameter, you must set the **CipherText** parameter to an AES-128 ciphertext key that is generated by calling the [GenerateDataKey](~~28948~~) operation. Otherwise, the transcoding job that uses HLS encryption fails. For more information about how to use HLS encryption, see [HLS encryption](~~68612~~).
> *   Regardless of whether HLS encryption or Alibaba Cloud proprietary cryptography is required, you must enable HLS encryption for the template group that is specified by the **TemplateGroupId** parameter. Otherwise, HLS encryption cannot be used.', example='6', position='Query'),
  templateGroupId: string(name='TemplateGroupId', description='The parameters used for overriding. The value is a JSON-formatted string. You can set this parameter to override the watermark or subtitle that is associated with the transcoding template. You can override the file URL of an image watermark, the content of a text watermark, the URL of a subtitle file, and the encoding format of a subtitle file. For more information about the data structure, see the "OverrideParams" section of the [Media processing parameters](~~98618~~) topic.', example='0e408c803baf658ee637790c5d9f****', position='Query'),
  userData?: string(name='UserData', description='The detailed information of the job.', example='{"Extend":{"localId":"****","test":"***"}}', position='Query'),
  videoId?: string(name='VideoId', description='The operation that you want to perform. Set the value to **SubmitTranscodeJobs**.', example='142710f878bd42508932f660d7b1****', position='Query'),
}

model SubmitTranscodeJobsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the transcoding job that was submitted.', example='E4EBD2BF-5EB0-4476-8829-9D94E1B1****'),
  transcodeJobs?: {
    transcodeJob?: [ 
    {
      jobId?: string(name='JobId', example='d8921ce8505716cfe86fb112c4****'),
    }
  ](name='TranscodeJob')
  }(name='TranscodeJobs', description='Submits a transcoding job and starts asynchronous transcoding.'),
  transcodeTaskId?: string(name='TranscodeTaskId', description='The ID of the request.', example='9f4a0df7da2c8a81c8c0408c84****'),
}

model SubmitTranscodeJobsResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitTranscodeJobsResponseBody(name='body'),
}

/**
  * The ID of the transcoding template group used when the video is transcoded. To specify a transcoding template group, you can log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com/?spm=a2c4g.11186623.2.18.2f1a2267jCybwh#/vod/settings/transcode/vod) and view the ID of the transcoding template group on the Transcode page.
  *
 */
async function submitTranscodeJobs(request: SubmitTranscodeJobsRequest): SubmitTranscodeJobsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SubmitTranscodeJobs', 'POST', '/', 'json', false, 'json', request);
}

model SubmitWorkflowJobRequest {
  mediaId?: string(name='MediaId', example='058b39e75269da42b08f00459****', position='Query'),
  workflowId: string(name='WorkflowId', example='34d577eade633860bdf1237****', position='Query'),
}

model SubmitWorkflowJobResponseBody = {
  requestId?: string(name='RequestId', example='A01C8FF4-C106-4431-418F973DADB7****'),
}

model SubmitWorkflowJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitWorkflowJobResponseBody(name='body'),
}

async function submitWorkflowJob(request: SubmitWorkflowJobRequest): SubmitWorkflowJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SubmitWorkflowJob', 'POST', '/', 'json', false, 'json', request);
}

model UpdateAITemplateRequest {
  templateConfig: string(name='TemplateConfig', description='The ID of the request.', example='{"AuditItem":["terrorism","porn"],"AuditRange":["text-title","video"],"AuditContent":["screen"],"AuditAutoBlock":"yes"}', position='Query'),
  templateId: string(name='TemplateId', description='The name of the AI template. The name can be up to 128 bytes in length.', example='1706a0063dd733f6a823ef32e0a5****', position='Query'),
  templateName: string(name='TemplateName', description='The detailed configurations of the AI template. The value is a JSON string. For more information, see [AITemplateConfig](https://help.aliyun.com/document_detail/89863.html#title-vd3-499-o36).', example='DemoAITemplate', position='Query'),
}

model UpdateAITemplateResponseBody = {
  requestId?: string(name='RequestId', example='25818875-5F78-4A13-BEF6-****'),
  templateId?: string(name='TemplateId', example='1706a0063dd733f6a823ef32e0a5****'),
}

model UpdateAITemplateResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAITemplateResponseBody(name='body'),
}

/**
  * The returned result.
  *
 */
async function updateAITemplate(request: UpdateAITemplateRequest): UpdateAITemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateAITemplate', 'POST', '/', 'json', false, 'json', request);
}

model UpdateAppInfoRequest {
  appId: string(name='AppId', example='app-****', position='Query'),
  appName?: string(name='AppName', example='test', position='Query'),
  description?: string(name='Description', example='my first app.', position='Query'),
  status?: string(name='Status', example='Disable', position='Query'),
}

model UpdateAppInfoResponseBody = {
  requestId?: string(name='RequestId', example='25818875-5F78-4A13-DF45-D7393642****'),
}

model UpdateAppInfoResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAppInfoResponseBody(name='body'),
}

/**
  * The ID of the request.
  *
 */
async function updateAppInfo(request: UpdateAppInfoRequest): UpdateAppInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateAppInfo', 'POST', '/', 'json', false, 'json', request);
}

model UpdateAttachedMediaInfosRequest {
  updateContent: string(name='UpdateContent', description='Modifies the information about multiple auxiliary media assets at a time.', position='Query'),
}

model UpdateAttachedMediaInfosResponseBody = {
  nonExistMediaIds?: [ string ](name='NonExistMediaIds'),
  requestId?: string(name='RequestId', example='25818875-5F78-4DF6-D7393642CA58****'),
}

model UpdateAttachedMediaInfosResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAttachedMediaInfosResponseBody(name='body'),
}

/**
  * The ID of the request.
  *
 */
async function updateAttachedMediaInfos(request: UpdateAttachedMediaInfosRequest): UpdateAttachedMediaInfosResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateAttachedMediaInfos', 'POST', '/', 'json', false, 'json', request);
}

model UpdateCategoryRequest {
  cateId: long(name='CateId', example='10020****', position='Query'),
  cateName: string(name='CateName', description='Modifies a video category.', position='Query'),
}

model UpdateCategoryResponseBody = {
  requestId?: string(name='RequestId', example='25818875-5F78-4AF6-D7393642CA58****'),
}

model UpdateCategoryResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateCategoryResponseBody(name='body'),
}

async function updateCategory(request: UpdateCategoryRequest): UpdateCategoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateCategory', 'POST', '/', 'json', false, 'json', request);
}

model UpdateEditingProjectRequest {
  coverURL?: string(name='CoverURL', example='https://****.com/6AB4D0E1E1C7446888****.png', position='Query'),
  description?: string(name='Description', example='testtimeline001desciption', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: string(name='OwnerId', position='Query'),
  projectId: string(name='ProjectId', description='Modifies an online editing project.', example='4ee4b97e27*****b525142a6b2', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: string(name='ResourceOwnerId', position='Query'),
  timeline?: string(name='Timeline', example='{"VideoTracks":[{"VideoTrackClips":[{"MediaId":"cc3308ac500c*****a54328bc3443"},{"MediaId":"da87a9cff64*****d88bc6d8326e4"}]}]}', position='Query'),
  title?: string(name='Title', example='testtimeline', position='Query'),
}

model UpdateEditingProjectResponseBody = {
  requestId?: string(name='RequestId', example='25818875-5F78-4A*****F6-D7393642CA58'),
}

model UpdateEditingProjectResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateEditingProjectResponseBody(name='body'),
}

async function updateEditingProject(request: UpdateEditingProjectRequest): UpdateEditingProjectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateEditingProject', 'POST', '/', 'json', false, 'json', request);
}

model UpdateImageInfosRequest {
  updateContent: string(name='UpdateContent', description='The new information about the one or more images. You can modify the information about up to 20 images at a time. For more information, see the **UpdateContent** section of this topic.

> The values of the nested parameters Title, Description, and Tags under the UpdateContent parameter cannot contain emoticons.', example='[{"ImageId":"ff8fe57e3461416c6a267a4e09****","Title":"test title","Description":"test description","Tags":"tag1,tag2"}]', position='Query'),
}

model UpdateImageInfosResponseBody = {
  nonExistImageIds?: {
    imageId?: [ string ](name='ImageId')
  }(name='NonExistImageIds', description='The IDs of the images that do not exist.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='25818875-5F78-4AF6-D7393642CA58****'),
}

model UpdateImageInfosResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateImageInfosResponseBody(name='body'),
}

async function updateImageInfos(request: UpdateImageInfosRequest): UpdateImageInfosResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateImageInfos', 'POST', '/', 'json', false, 'json', request);
}

model UpdateTranscodeTemplateGroupRequest {
  locked?: string(name='Locked', example='locked', position='Query'),
  name?: string(name='Name', description='The operation that you want to perform. Set the value to **UpdateTranscodeTemplateGroup**.', example='transcodetemplate', position='Query'),
  transcodeTemplateGroupId: string(name='TranscodeTemplateGroupId', example='4c71a339fe*****52b4fa6f4527', position='Query'),
  transcodeTemplateList?: string(name='TranscodeTemplateList', description='Modifies a transcoding template group. You can modify the configurations of the specified transcoding templates in a transcoding template group.', example='[{"Video":{"Bitrate":"400","Codec":"H.264","Fps":"30"},"Audio":{"Codec":"AAC","Bitrate":"64","Definition":"SD","EncryptType":"Private","Container":{"Format":"m3u8"},"PackageType":"HLSPackage"}}]', position='Query'),
}

model UpdateTranscodeTemplateGroupResponseBody = {
  requestId?: string(name='RequestId', example='25818875-5F78-4A*****F6-D7393642CA58'),
  transcodeTemplateGroupId?: string(name='TranscodeTemplateGroupId', example='34e908aa4024a*****f7821c31f93a2a'),
}

model UpdateTranscodeTemplateGroupResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateTranscodeTemplateGroupResponseBody(name='body'),
}

/**
  * The ID of the transcoding template group.
  *
 */
async function updateTranscodeTemplateGroup(request: UpdateTranscodeTemplateGroupRequest): UpdateTranscodeTemplateGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateTranscodeTemplateGroup', 'POST', '/', 'json', false, 'json', request);
}

model UpdateVideoInfoRequest {
  cateId?: long(name='CateId', example='384761111', position='Query'),
  coverURL?: string(name='CoverURL', example='https://example.aliyundoc.com/****.jpg', position='Query'),
  description?: string(name='Description', position='Query'),
  tags?: string(name='Tags', description='The URL of the video thumbnail.', example='Modifies the information about a video.', position='Query'),
  title?: string(name='Title', description='The ID of the request.', example='The operation that you want to perform. Set the value to **UpdateVideoInfo**.', position='Query'),
  videoId: string(name='VideoId', description='The description of the video.

*   The value can be up to 1,024 bytes in length.
*   The string must be encoded in the UTF-8 format.', example='2deda93265312baf9b0ed810d****', position='Query'),
}

model UpdateVideoInfoResponseBody = {
  requestId?: string(name='RequestId', example='25818875-5F78-4AF6-D7393642CA58****'),
}

model UpdateVideoInfoResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateVideoInfoResponseBody(name='body'),
}

/**
  * The ID of the video.
  *
 */
async function updateVideoInfo(request: UpdateVideoInfoRequest): UpdateVideoInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateVideoInfo', 'POST', '/', 'json', false, 'json', request);
}

model UpdateVideoInfosRequest {
  updateContent: string(name='UpdateContent', description='The new information about audios or videos. You can modify the information about up to 20 audios or videos at a time. Separate multiple audios or videos with commas (,). When you modify the information exceed 20 audios or videos at a time, the update will fail with an error code **CountExceededMax**.

The value is a JSON string. For more information, see the **UpdateContent** section of this topic.', example='[{"VideoId":"f45cf4eba5cb90233389558c39****","Title":"test title1"},{"VideoId":"f45cf4eba5c84233389558c36****","Title":"test title2"}]', position='Query'),
}

model UpdateVideoInfosResponseBody = {
  forbiddenVideoIds?: [ string ](name='ForbiddenVideoIds', description='The IDs of the videos that cannot be modified. Generally, videos cannot be modified if you do not have required [permissions](~~113600~~).'),
  nonExistVideoIds?: [ string ](name='NonExistVideoIds', description='The IDs of the videos that do not exist.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='25818875-5F78-4AF6-D7393642CA58****'),
}

model UpdateVideoInfosResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateVideoInfosResponseBody(name='body'),
}

/**
  * The specific parameter of a video is updated only when a new value is passed in the parameter.
  *
 */
async function updateVideoInfos(request: UpdateVideoInfosRequest): UpdateVideoInfosResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateVideoInfos', 'POST', '/', 'json', false, 'json', request);
}

model UpdateVodDomainRequest {
  domainName: string(name='DomainName', description='The accelerated domain name.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  sources?: string(name='Sources', description='The information about the addresses of origin servers.', example='[{"content":"1.1.1.1","type":"ipaddr","priority":"20","port":80}]', position='Query'),
  topLevelDomain?: string(name='TopLevelDomain', description='The top-level domain.', example='example.com', position='Query'),
}

model UpdateVodDomainResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='15C66C7B-671A-4297-****-2C4477247A74'),
}

model UpdateVodDomainResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateVodDomainResponseBody(name='body'),
}

/**
  * > This operation is available only in the **China (Shanghai)** region.
  *
 */
async function updateVodDomain(request: UpdateVodDomainRequest): UpdateVodDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateVodDomain', 'POST', '/', 'json', false, 'json', request);
}

model UpdateVodTemplateRequest {
  name?: string(name='Name', description='The name of the template.

*   The name can be up to 128 bytes in length.
*   The value must be encoded in UTF-8.', example='test', position='Query'),
  templateConfig?: string(name='TemplateConfig', description='Modifies a snapshot template.', example='{"SnapshotConfig":{"Count":10,"SpecifiedOffsetTime":0,"Interval":1}', position='Query'),
  vodTemplateId: string(name='VodTemplateId', description='The operation that you want to perform. Set the value to **UpdateVodTemplate**.', example='8c75a02e339b*****0b0d2c48171a22', position='Query'),
}

model UpdateVodTemplateResponseBody = {
  requestId?: string(name='RequestId', example='25818875-5F78-4A*****F6-D7393642CA58'),
  vodTemplateId?: string(name='VodTemplateId', example='8c75a02e339b*****0b0d2c48171a22'),
}

model UpdateVodTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateVodTemplateResponseBody(name='body'),
}

async function updateVodTemplate(request: UpdateVodTemplateRequest): UpdateVodTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateVodTemplate', 'POST', '/', 'json', false, 'json', request);
}

model UpdateWatermarkRequest {
  name?: string(name='Name', description='The name of the watermark. Only letters and digits are supported.
*   The name can be up to 128 bytes in length.
*   The value must be encoded in UTF-8.', example='test', position='Query'),
  watermarkConfig: string(name='WatermarkConfig', description='The configurations such as the position and effect of the text watermark or image watermark. The value is a JSON-formatted string.
> The value of this parameter varies with the watermark type. For more information about the data structure, see the "WatermarkConfig" section of the [Media processing parameters](~~98618~~) topic.', example='{"Width":"55","Height":"55","Dx":"9","Dy":"9","ReferPos":"BottonLeft","Type":"Image"}', position='Query'),
  watermarkId: string(name='WatermarkId', description='The ID of the watermark.', example='af2afe4761992c*****bd947dae97337', position='Query'),
}

model UpdateWatermarkResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='25818875-5F78-4A*****F6-D7393642CA58'),
  watermarkInfo?: {
    creationTime?: string(name='CreationTime', description='The time when the watermark was added. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2018-11-06T08:03:17Z'),
    fileUrl?: string(name='FileUrl', description='The Object Storage Service (OSS) URL or Content Delivery Network (CDN) URL of the watermark file. A text watermark does not have a file URL.', example='https://outin-32****9f4b3e7.oss-cn-shanghai.aliyuncs.com/image/cover/E6C3448CC8B715E6F8A72EC6B-6-2.png?Expires=1541600583&OSSAccessKeyId=****&Signature=gmf1eYMoDVg%2BHQCb4UGozBW****'),
    isDefault?: string(name='IsDefault', description='Indicates whether the watermark is the default one. Valid values:
*   **Default**: The watermark is the default one.
*   **NotDefault**: The watermark is not the default one.', example='NotDefault'),
    name?: string(name='Name', description='The name of the watermark.', example='image watermark test'),
    type?: string(name='Type', description='The type of the watermark. Valid values:
*   **Image**: This is the default value.
*   **Text**', example='Text'),
    watermarkConfig?: string(name='WatermarkConfig', description='The configurations such as the position and effect of the text watermark or image watermark. The value is a JSON-formatted string.
> The value of this parameter varies with the watermark type. For more information about the data structure, see the "WatermarkConfig" section of the [Media processing parameters](~~98618~~) topic.', example='{"Width":"55","Height":"55","Dx":"9","Dy":"9","ReferPos":"BottonLeft","Type":"Image"}'),
    watermarkId?: string(name='WatermarkId', description='The ID of the watermark.', example='505e2e287ea*****ecfddd386d384'),
  }(name='WatermarkInfo', description='The information about the watermark.'),
}

model UpdateWatermarkResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateWatermarkResponseBody(name='body'),
}

/**
  * You can modify only the name and configurations of a watermark.
  *
 */
async function updateWatermark(request: UpdateWatermarkRequest): UpdateWatermarkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateWatermark', 'POST', '/', 'json', false, 'json', request);
}

model UploadMediaByURLRequest {
  appId?: string(name='AppId', description='## UploadMetadata

| Parameter | Type | Required | Description |
| --------- | ---- | -------- | ----------- |
| SourceURL | String | Yes | The URL of the source file to be uploaded. |
| Title | String | Yes | The title of the media file. The title can be up to 128 bytes in length. The value must be encoded in UTF-8. |
| FileSize | String | No | The size of the media file. |
| Description | String | No | The description of the media file. The description can be up to 1,024 bytes in length. The value must be encoded in UTF-8. |
| CoverURL | String | No | The URL of the custom thumbnail of the media file. |
| CateId | String | No | The category ID of the media file. To view the category ID of the media file, log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com/). In the left-side navigation pane, choose **Configuration Management** > **Media Management** > **Categories**. |
| Tags | String | No | The one or more tags of the media file. Each tag can be up to 32 bytes in length. You can set a maximum of 16 tags. Separate multiple tags with commas (,). The value must be encoded in UTF-8. |
| TemplateGroupId | String | No | The ID of the transcoding template group. If both the request parameter TemplateGroupId and the nested parameter TemplateGroupId are set, the value of the nested parameter takes effect. |
| WorkflowId | String | No | The ID of the workflow. If both the WorkflowId and TemplateGroupId parameters are set, the value of the WorkflowId parameter takes effect. For more information, see [Workflows](https://www.alibabacloud.com/help/en/apsaravideo-for-vod/latest/workflows). |
| FileExtension | String | No | The file name extension of the media file. For more information about file name extensions supported by ApsaraVideo VOD, see [Overview](https://www.alibabacloud.com/help/en/apsaravideo-for-vod/latest/upload-medias-overview). |
> - Do not include emoticons in the nested parameters, such as Title, Description, and Tags, under the UploadMetadata parameter.
- If you set the TemplateGroupId parameter to VOD_NO_TRANSCODE to upload videos, only the videos in the format of MP4, FLV, MP3, M3U8, or WebM can be played. Videos in the other formats are supported only for storage. You can identify the video format based on the file name extension. If you want to use ApsaraVideo Player, the version must be 3.1.0 or later.
- If you set the TemplateGroupId parameter to VOD_NO_TRANSCODE, only the [FileUploadComplete](https://www.alibabacloud.com/help/en/apsaravideo-for-vod/latest/fileuploadcomplete) but not the [StreamTranscodeComplete](https://www.alibabacloud.com/help/en/apsaravideo-for-vod/latest/streamtranscodecomplete) event notification is returned after the media file is uploaded.
- If a callback is configured, ApsaraVideo VOD sends an [UploadByURLComplete](https://www.alibabacloud.com/help/en/apsaravideo-for-vod/latest/uploadbyurlcomplete) event notification after the media file is uploaded, in addition to the FileUploadComplete and StreamTranscodeComplete event notifications.
- If you specify multiple media files at a time, ApsaraVideo VOD sends an event notification for each media file after the media file is uploaded.', example='app-****', position='Query'),
  storageLocation?: string(name='StorageLocation', description='The URL of the source file.
* The URL must contain a file name extension, such as mp4 in `https://****.mp4`.
    * If the URL does not contain a file name extension, you can specify one by setting the `FileExtension` parameter under the `UploadMetadatas` parameter.
    * If the URL contains a file name extension and the `FileExtension` parameter is set, the value of the `FileExtension` parameter is used.
    * For more information about file name extensions supported by ApsaraVideo VOD, see [Overview](~~55396~~).
* URL encoding is required. Separate multiple URLs with commas (,). You can specify a maximum of 20 URLs.
* Special characters may cause upload failures. Therefore, encode URLs before you separate them with commas (,).', example='outin-bfefbb90a47c******163e1c7426.oss-cn-shanghai.aliyuncs.com', position='Query'),
  templateGroupId?: string(name='TemplateGroupId', description='The information about one or more upload jobs.', example='ca3a8f6e4957b65806709586****', position='Query'),
  uploadMetadatas?: string(name='UploadMetadatas', description='The metadata of the media file to be uploaded. The value is a JSON string.
* This parameter takes effect only if the value of the SourceURL parameter matches the URL that is specified by the UploadURLs parameter.
* The JSON-formatted data, such as `[UploadMetadata, UploadMetadata,…]`, must be converted into a JSON string.
* For more information, see the **UploadMetadata** section.', example='[{"SourceURL":"https://example.aliyundoc.com/video01.mp4","Title":"urlUploadTest"}]', position='Query'),
  uploadURLs: string(name='UploadURLs', description='The ID of the application. Default value: **app-1000000**. For more information, see [Overview](~~113600~~).', example='https://****.mp4', position='Query'),
  userData?: string(name='UserData', description='The ID of the request.', example='{"MessageCallback":{"CallbackURL":"http://example.aliyundoc.com"},"Extend":{"localId":"xxx","test":"www"}}', position='Query'),
  workflowId?: string(name='WorkflowId', description='> This operation is used to asynchronously upload media files. Upload jobs are queued for execution after they are submitted. The completion time of an upload job varies with the number of jobs in the queue.', example='e1e243b42548248197d6f74f9****', position='Query'),
}

model UploadMediaByURLResponseBody = {
  requestId?: string(name='RequestId', example='25818875-5F78-4AF6-D7393642CA58****'),
  uploadJobs?: [ 
    {
      jobId?: string(name='JobId', example='ad90a501b1b94fb72374ad005046****'),
      sourceURL?: string(name='SourceURL', example='http://example****.mp4'),
    }
  ](name='UploadJobs'),
}

model UploadMediaByURLResponse = {
  headers: map[string]string(name='headers'),
  body: UploadMediaByURLResponseBody(name='body'),
}

/**
  * The ID of the workflow. To view the ID of the workflow, log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com). In the left-side navigation pane, choose **Configuration Management** > **Media Processing** > **Workflows**.
  * > If both the WorkflowId and TemplateGroupId parameters are set, the value of the WorkflowId parameter takes effect. For more information, see [Workflows](~~115347~~).
  *
 */
async function uploadMediaByURL(request: UploadMediaByURLRequest): UploadMediaByURLResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UploadMediaByURL', 'POST', '/', 'json', false, 'json', request);
}

model UploadStreamByURLRequest {
  definition: string(name='Definition', description='The media ID in ApsaraVideo VOD.', example='HD', position='Query'),
  fileExtension?: string(name='FileExtension', description='The quality of the video stream.

For more information about valid values of this parameter, see [Parameters for media assets](~~124671~~).', example='mp4', position='Query'),
  HDRType?: string(name='HDRType', description='The file name extension of the transcoded stream.

For more information, see the Supported media file formats section in [Overview](~~55396~~).

If you set a value for this parameter, the file name extension specified in StreamURL is overwritten.

>  This parameter is required if you do not specify a file name extension in StreamURL.', example='HDR10', position='Query'),
  mediaId: string(name='MediaId', description='The URL of the OSS object.', example='ca3a8f6e49*****57b65806709586', position='Query'),
  streamURL: string(name='StreamURL', description='The basic information.', example='https://example.com/lesson-01.mp4', position='Query'),
  userData?: string(name='UserData', description='The ID of the request.', example='{"MessageCallback":{"CallbackURL":"http://aliyundoc.com"}, "Extend":{"localId":"xxx","test":"www"}}', position='Query'),
}

model UploadStreamByURLResponseBody = {
  fileURL?: string(name='FileURL', example='http://outin-31059bcee7810a200163e1c8dba****.oss-cn-shanghai.aliyuncs.com/lesson-01.mp4'),
  requestId?: string(name='RequestId', description='Uploads transcoded streams to ApsaraVideo VOD from external storage.', example='7AE96389-DF1E-598D-816B-7B40F13B4620'),
  sourceURL?: string(name='SourceURL', example='https://example.com/lesson-01.mp4'),
  streamJobId?: string(name='StreamJobId', description='UploadStreamByURL', example='e304b34fb3d959f92baef97b6496****'),
}

model UploadStreamByURLResponse = {
  headers: map[string]string(name='headers'),
  body: UploadStreamByURLResponseBody(name='body'),
}

/**
  * The URL of the transcoded stream.
  * If URL authentication is required, you must pass authentication information in this parameter and make sure that the URL can be accessed over the Internet.
  *
 */
async function uploadStreamByURL(request: UploadStreamByURLRequest): UploadStreamByURLResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UploadStreamByURL', 'POST', '/', 'json', false, 'json', request);
}

model VerifyVodDomainOwnerRequest {
  domainName: string(name='DomainName', description='The DNS verification method that is used to verify the ownership of the specified domain name.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  verifyType: string(name='VerifyType', description='Verifies the ownership of a specified domain name.', example='dnsCheck', position='Query'),
}

model VerifyVodDomainOwnerResponseBody = {
  content?: string(name='Content', example='verify_dffeb661*********a59c32cd91f'),
  requestId?: string(name='RequestId', example='E4EBD2BF-5EB0-4476-8829-9D94E1B1****'),
}

model VerifyVodDomainOwnerResponse = {
  headers: map[string]string(name='headers'),
  body: VerifyVodDomainOwnerResponseBody(name='body'),
}

async function verifyVodDomainOwner(request: VerifyVodDomainOwnerRequest): VerifyVodDomainOwnerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'VerifyVodDomainOwner', 'POST', '/', 'json', false, 'json', request);
}

