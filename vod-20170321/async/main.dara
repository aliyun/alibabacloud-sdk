/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'vod';
  @version = '2017-03-21';
  @endpointRule = 'regional';
  @endpointMap = {
    ap-northeast-2-pop = 'vod.aliyuncs.com',
    ap-southeast-2 = 'vod.aliyuncs.com',
    ap-southeast-3 = 'vod.aliyuncs.com',
    cn-beijing-finance-1 = 'vod.aliyuncs.com',
    cn-beijing-finance-pop = 'vod.aliyuncs.com',
    cn-beijing-gov-1 = 'vod.aliyuncs.com',
    cn-beijing-nu16-b01 = 'vod.aliyuncs.com',
    cn-chengdu = 'vod.aliyuncs.com',
    cn-edge-1 = 'vod.aliyuncs.com',
    cn-fujian = 'vod.aliyuncs.com',
    cn-haidian-cm12-c01 = 'vod.aliyuncs.com',
    cn-hangzhou = 'vod.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'vod.aliyuncs.com',
    cn-hangzhou-finance = 'vod.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'vod.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'vod.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'vod.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'vod.aliyuncs.com',
    cn-hangzhou-test-306 = 'vod.aliyuncs.com',
    cn-hongkong = 'vod.aliyuncs.com',
    cn-hongkong-finance-pop = 'vod.aliyuncs.com',
    cn-huhehaote = 'vod.aliyuncs.com',
    cn-huhehaote-nebula-1 = 'vod.aliyuncs.com',
    cn-qingdao = 'vod.aliyuncs.com',
    cn-qingdao-nebula = 'vod.aliyuncs.com',
    cn-shanghai-et15-b01 = 'vod.aliyuncs.com',
    cn-shanghai-et2-b01 = 'vod.aliyuncs.com',
    cn-shanghai-finance-1 = 'vod.aliyuncs.com',
    cn-shanghai-inner = 'vod.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'vod.aliyuncs.com',
    cn-shenzhen-finance-1 = 'vod.aliyuncs.com',
    cn-shenzhen-inner = 'vod.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'vod.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'vod.aliyuncs.com',
    cn-wuhan = 'vod.aliyuncs.com',
    cn-wulanchabu = 'vod.aliyuncs.com',
    cn-yushanfang = 'vod.aliyuncs.com',
    cn-zhangbei = 'vod.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'vod.aliyuncs.com',
    cn-zhangjiakou = 'vod.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'vod.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'vod.aliyuncs.com',
    eu-west-1 = 'vod.aliyuncs.com',
    eu-west-1-oxs = 'vod.aliyuncs.com',
    me-east-1 = 'vod.aliyuncs.com',
    rus-west-1-pop = 'vod.aliyuncs.com',
    us-east-1 = 'vod.aliyuncs.com',
    us-west-1 = 'vod.aliyuncs.com',
  };
}

function close(): void {
  @handler.close();
}

model AddAITemplateRequest {
  templateConfig: string(name='TemplateConfig', position='Query'),
  templateName: string(name='TemplateName', position='Query'),
  templateType: string(name='TemplateType', position='Query'),
}

model AddAITemplateResponseBody = {
  requestId?: string(name='RequestId'),
  templateId?: string(name='TemplateId'),
}

model AddAITemplateResponse = {
  headers: map[string]string(name='headers'),
  body: AddAITemplateResponseBody(name='body'),
}

async function addAITemplate(request: AddAITemplateRequest): AddAITemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddAITemplate', 'POST', '/', 'json', false, 'json', request);
}

model AddCategoryRequest {
  cateName: string(name='CateName', position='Query'),
  parentId?: long(name='ParentId', position='Query'),
  type?: string(name='Type', position='Query'),
}

model AddCategoryResponseBody = {
  category?: {
    cateId?: long(name='CateId'),
    cateName?: string(name='CateName'),
    level?: long(name='Level'),
    parentId?: long(name='ParentId'),
    type?: string(name='Type'),
  }(name='Category'),
  requestId?: string(name='RequestId'),
}

model AddCategoryResponse = {
  headers: map[string]string(name='headers'),
  body: AddCategoryResponseBody(name='body'),
}

async function addCategory(request: AddCategoryRequest): AddCategoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddCategory', 'POST', '/', 'json', false, 'json', request);
}

model AddEditingProjectRequest {
  coverURL?: string(name='CoverURL', position='Query'),
  description?: string(name='Description', position='Query'),
  division?: string(name='Division', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: string(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: string(name='ResourceOwnerId', position='Query'),
  timeline?: string(name='Timeline', position='Query'),
  title: string(name='Title', position='Query'),
}

model AddEditingProjectResponseBody = {
  project?: {
    creationTime?: string(name='CreationTime'),
    description?: string(name='Description'),
    modifiedTime?: string(name='ModifiedTime'),
    projectId?: string(name='ProjectId'),
    status?: string(name='Status'),
    title?: string(name='Title'),
  }(name='Project'),
  requestId?: string(name='RequestId'),
}

model AddEditingProjectResponse = {
  headers: map[string]string(name='headers'),
  body: AddEditingProjectResponseBody(name='body'),
}

async function addEditingProject(request: AddEditingProjectRequest): AddEditingProjectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddEditingProject', 'POST', '/', 'json', false, 'json', request);
}

model AddTranscodeTemplateGroupRequest {
  appId?: string(name='AppId', position='Query'),
  name?: string(name='Name', position='Query'),
  transcodeTemplateGroupId?: string(name='TranscodeTemplateGroupId', position='Query'),
  transcodeTemplateList?: string(name='TranscodeTemplateList', position='Query'),
}

model AddTranscodeTemplateGroupResponseBody = {
  requestId?: string(name='RequestId'),
  transcodeTemplateGroupId?: string(name='TranscodeTemplateGroupId'),
}

model AddTranscodeTemplateGroupResponse = {
  headers: map[string]string(name='headers'),
  body: AddTranscodeTemplateGroupResponseBody(name='body'),
}

async function addTranscodeTemplateGroup(request: AddTranscodeTemplateGroupRequest): AddTranscodeTemplateGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddTranscodeTemplateGroup', 'POST', '/', 'json', false, 'json', request);
}

model AddVodDomainRequest {
  checkUrl?: string(name='CheckUrl', position='Query'),
  domainName: string(name='DomainName', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  scope?: string(name='Scope', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  sources: string(name='Sources', position='Query'),
  topLevelDomain?: string(name='TopLevelDomain', position='Query'),
}

model AddVodDomainResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddVodDomainResponse = {
  headers: map[string]string(name='headers'),
  body: AddVodDomainResponseBody(name='body'),
}

async function addVodDomain(request: AddVodDomainRequest): AddVodDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddVodDomain', 'POST', '/', 'json', false, 'json', request);
}

model AddVodTemplateRequest {
  appId?: string(name='AppId', position='Query'),
  name: string(name='Name', position='Query'),
  templateConfig: string(name='TemplateConfig', position='Query'),
  templateType: string(name='TemplateType', position='Query'),
}

model AddVodTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  vodTemplateId?: string(name='VodTemplateId'),
}

model AddVodTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: AddVodTemplateResponseBody(name='body'),
}

async function addVodTemplate(request: AddVodTemplateRequest): AddVodTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddVodTemplate', 'POST', '/', 'json', false, 'json', request);
}

model AddWatermarkRequest {
  appId?: string(name='AppId', position='Query'),
  fileUrl?: string(name='FileUrl', position='Query'),
  name: string(name='Name', position='Query'),
  type: string(name='Type', position='Query'),
  watermarkConfig: string(name='WatermarkConfig', position='Query'),
}

model AddWatermarkResponseBody = {
  requestId?: string(name='RequestId'),
  watermarkInfo?: {
    creationTime?: string(name='CreationTime'),
    fileUrl?: string(name='FileUrl'),
    isDefault?: string(name='IsDefault'),
    name?: string(name='Name'),
    type?: string(name='Type'),
    watermarkConfig?: string(name='WatermarkConfig'),
    watermarkId?: string(name='WatermarkId'),
  }(name='WatermarkInfo'),
}

model AddWatermarkResponse = {
  headers: map[string]string(name='headers'),
  body: AddWatermarkResponseBody(name='body'),
}

async function addWatermark(request: AddWatermarkRequest): AddWatermarkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddWatermark', 'POST', '/', 'json', false, 'json', request);
}

model AttachAppPolicyToIdentityRequest {
  appId?: string(name='AppId', position='Query'),
  identityName: string(name='IdentityName', position='Query'),
  identityType: string(name='IdentityType', position='Query'),
  policyNames: string(name='PolicyNames', position='Query'),
}

model AttachAppPolicyToIdentityResponseBody = {
  failedPolicyNames?: [ string ](name='FailedPolicyNames'),
  nonExistPolicyNames?: [ string ](name='NonExistPolicyNames'),
  requestId?: string(name='RequestId'),
}

model AttachAppPolicyToIdentityResponse = {
  headers: map[string]string(name='headers'),
  body: AttachAppPolicyToIdentityResponseBody(name='body'),
}

async function attachAppPolicyToIdentity(request: AttachAppPolicyToIdentityRequest): AttachAppPolicyToIdentityResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AttachAppPolicyToIdentity', 'POST', '/', 'json', false, 'json', request);
}

model BatchSetVodDomainConfigsRequest {
  domainNames: string(name='DomainNames', position='Query'),
  functions: string(name='Functions', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model BatchSetVodDomainConfigsResponseBody = {
  requestId?: string(name='RequestId'),
}

model BatchSetVodDomainConfigsResponse = {
  headers: map[string]string(name='headers'),
  body: BatchSetVodDomainConfigsResponseBody(name='body'),
}

async function batchSetVodDomainConfigs(request: BatchSetVodDomainConfigsRequest): BatchSetVodDomainConfigsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'BatchSetVodDomainConfigs', 'POST', '/', 'json', false, 'json', request);
}

model BatchStartVodDomainRequest {
  domainNames: string(name='DomainNames', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model BatchStartVodDomainResponseBody = {
  requestId?: string(name='RequestId'),
}

model BatchStartVodDomainResponse = {
  headers: map[string]string(name='headers'),
  body: BatchStartVodDomainResponseBody(name='body'),
}

async function batchStartVodDomain(request: BatchStartVodDomainRequest): BatchStartVodDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'BatchStartVodDomain', 'POST', '/', 'json', false, 'json', request);
}

model BatchStopVodDomainRequest {
  domainNames: string(name='DomainNames', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model BatchStopVodDomainResponseBody = {
  requestId?: string(name='RequestId'),
}

model BatchStopVodDomainResponse = {
  headers: map[string]string(name='headers'),
  body: BatchStopVodDomainResponseBody(name='body'),
}

async function batchStopVodDomain(request: BatchStopVodDomainRequest): BatchStopVodDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'BatchStopVodDomain', 'POST', '/', 'json', false, 'json', request);
}

model CancelUrlUploadJobsRequest {
  jobIds?: string(name='JobIds', position='Query'),
  uploadUrls?: string(name='UploadUrls', position='Query'),
}

model CancelUrlUploadJobsResponseBody = {
  canceledJobs?: [ string ](name='CanceledJobs'),
  nonExists?: [ string ](name='NonExists'),
  requestId?: string(name='RequestId'),
}

model CancelUrlUploadJobsResponse = {
  headers: map[string]string(name='headers'),
  body: CancelUrlUploadJobsResponseBody(name='body'),
}

async function cancelUrlUploadJobs(request: CancelUrlUploadJobsRequest): CancelUrlUploadJobsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CancelUrlUploadJobs', 'POST', '/', 'json', false, 'json', request);
}

model CreateAppInfoRequest {
  appName: string(name='AppName', position='Query'),
  description?: string(name='Description', position='Query'),
}

model CreateAppInfoResponseBody = {
  appId?: string(name='AppId'),
  requestId?: string(name='RequestId'),
}

model CreateAppInfoResponse = {
  headers: map[string]string(name='headers'),
  body: CreateAppInfoResponseBody(name='body'),
}

async function createAppInfo(request: CreateAppInfoRequest): CreateAppInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateAppInfo', 'POST', '/', 'json', false, 'json', request);
}

model CreateAuditRequest {
  auditContent: string(name='AuditContent', position='Query'),
}

model CreateAuditResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateAuditResponse = {
  headers: map[string]string(name='headers'),
  body: CreateAuditResponseBody(name='body'),
}

async function createAudit(request: CreateAuditRequest): CreateAuditResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateAudit', 'POST', '/', 'json', false, 'json', request);
}

model CreateUploadAttachedMediaRequest {
  appId?: string(name='AppId', position='Query'),
  businessType: string(name='BusinessType', position='Query'),
  cateIds?: string(name='CateIds', position='Query'),
  description?: string(name='Description', position='Query'),
  fileName?: string(name='FileName', position='Query'),
  fileSize?: string(name='FileSize', position='Query'),
  mediaExt?: string(name='MediaExt', position='Query'),
  storageLocation?: string(name='StorageLocation', position='Query'),
  tags?: string(name='Tags', position='Query'),
  title?: string(name='Title', position='Query'),
  userData?: string(name='UserData', position='Query'),
}

model CreateUploadAttachedMediaResponseBody = {
  fileURL?: string(name='FileURL'),
  mediaId?: string(name='MediaId'),
  mediaURL?: string(name='MediaURL'),
  requestId?: string(name='RequestId'),
  uploadAddress?: string(name='UploadAddress'),
  uploadAuth?: string(name='UploadAuth'),
}

model CreateUploadAttachedMediaResponse = {
  headers: map[string]string(name='headers'),
  body: CreateUploadAttachedMediaResponseBody(name='body'),
}

async function createUploadAttachedMedia(request: CreateUploadAttachedMediaRequest): CreateUploadAttachedMediaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateUploadAttachedMedia', 'POST', '/', 'json', false, 'json', request);
}

model CreateUploadImageRequest {
  appId?: string(name='AppId', position='Query'),
  cateId?: long(name='CateId', position='Query'),
  description?: string(name='Description', position='Query'),
  imageExt?: string(name='ImageExt', position='Query'),
  imageType: string(name='ImageType', position='Query'),
  originalFileName?: string(name='OriginalFileName', position='Query'),
  storageLocation?: string(name='StorageLocation', position='Query'),
  tags?: string(name='Tags', position='Query'),
  title?: string(name='Title', position='Query'),
  userData?: string(name='UserData', position='Query'),
}

model CreateUploadImageResponseBody = {
  fileURL?: string(name='FileURL'),
  imageId?: string(name='ImageId'),
  imageURL?: string(name='ImageURL'),
  requestId?: string(name='RequestId'),
  uploadAddress?: string(name='UploadAddress'),
  uploadAuth?: string(name='UploadAuth'),
}

model CreateUploadImageResponse = {
  headers: map[string]string(name='headers'),
  body: CreateUploadImageResponseBody(name='body'),
}

async function createUploadImage(request: CreateUploadImageRequest): CreateUploadImageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateUploadImage', 'POST', '/', 'json', false, 'json', request);
}

model CreateUploadVideoRequest {
  appId?: string(name='AppId', position='Query'),
  cateId?: long(name='CateId', position='Query'),
  coverURL?: string(name='CoverURL', position='Query'),
  description?: string(name='Description', position='Query'),
  fileName: string(name='FileName', position='Query'),
  fileSize?: long(name='FileSize', position='Query'),
  storageLocation?: string(name='StorageLocation', position='Query'),
  tags?: string(name='Tags', position='Query'),
  templateGroupId?: string(name='TemplateGroupId', position='Query'),
  title: string(name='Title', position='Query'),
  userData?: string(name='UserData', position='Query'),
  workflowId?: string(name='WorkflowId', position='Query'),
}

model CreateUploadVideoResponseBody = {
  requestId?: string(name='RequestId'),
  uploadAddress?: string(name='UploadAddress'),
  uploadAuth?: string(name='UploadAuth'),
  videoId?: string(name='VideoId'),
}

model CreateUploadVideoResponse = {
  headers: map[string]string(name='headers'),
  body: CreateUploadVideoResponseBody(name='body'),
}

async function createUploadVideo(request: CreateUploadVideoRequest): CreateUploadVideoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateUploadVideo', 'POST', '/', 'json', false, 'json', request);
}

model DecryptKMSDataKeyRequest {
  cipherText: string(name='CipherText', description='待解密的密文。', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: string(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: string(name='ResourceOwnerId', position='Query'),
}

model DecryptKMSDataKeyResponseBody = {
  keyId?: string(name='KeyId'),
  plaintext?: string(name='Plaintext'),
  requestId?: string(name='RequestId'),
}

model DecryptKMSDataKeyResponse = {
  headers: map[string]string(name='headers'),
  body: DecryptKMSDataKeyResponseBody(name='body'),
}

async function decryptKMSDataKey(request: DecryptKMSDataKeyRequest): DecryptKMSDataKeyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DecryptKMSDataKey', 'POST', '/', 'json', false, 'json', request);
}

model DeleteAIImageInfosRequest {
  AIImageInfoIds: string(name='AIImageInfoIds', position='Query'),
}

model DeleteAIImageInfosResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteAIImageInfosResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAIImageInfosResponseBody(name='body'),
}

async function deleteAIImageInfos(request: DeleteAIImageInfosRequest): DeleteAIImageInfosResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteAIImageInfos', 'POST', '/', 'json', false, 'json', request);
}

model DeleteAITemplateRequest {
  templateId: string(name='TemplateId', position='Query'),
}

model DeleteAITemplateResponseBody = {
  requestId?: string(name='RequestId'),
  templateId?: string(name='TemplateId'),
}

model DeleteAITemplateResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAITemplateResponseBody(name='body'),
}

async function deleteAITemplate(request: DeleteAITemplateRequest): DeleteAITemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteAITemplate', 'POST', '/', 'json', false, 'json', request);
}

model DeleteAppInfoRequest {
  appId: string(name='AppId', position='Query'),
}

model DeleteAppInfoResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteAppInfoResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAppInfoResponseBody(name='body'),
}

async function deleteAppInfo(request: DeleteAppInfoRequest): DeleteAppInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteAppInfo', 'POST', '/', 'json', false, 'json', request);
}

model DeleteAttachedMediaRequest {
  mediaIds?: string(name='MediaIds', position='Query'),
}

model DeleteAttachedMediaResponseBody = {
  nonExistMediaIds?: [ string ](name='NonExistMediaIds'),
  requestId?: string(name='RequestId'),
}

model DeleteAttachedMediaResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAttachedMediaResponseBody(name='body'),
}

async function deleteAttachedMedia(request: DeleteAttachedMediaRequest): DeleteAttachedMediaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteAttachedMedia', 'POST', '/', 'json', false, 'json', request);
}

model DeleteCategoryRequest {
  cateId: long(name='CateId', position='Query'),
}

model DeleteCategoryResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteCategoryResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteCategoryResponseBody(name='body'),
}

async function deleteCategory(request: DeleteCategoryRequest): DeleteCategoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteCategory', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDynamicImageRequest {
  dynamicImageIds?: string(name='DynamicImageIds', position='Query'),
  videoId: string(name='VideoId', position='Query'),
}

model DeleteDynamicImageResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDynamicImageResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDynamicImageResponseBody(name='body'),
}

async function deleteDynamicImage(request: DeleteDynamicImageRequest): DeleteDynamicImageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDynamicImage', 'POST', '/', 'json', false, 'json', request);
}

model DeleteEditingProjectRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: string(name='OwnerId', position='Query'),
  projectIds: string(name='ProjectIds', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: string(name='ResourceOwnerId', position='Query'),
}

model DeleteEditingProjectResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteEditingProjectResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteEditingProjectResponseBody(name='body'),
}

async function deleteEditingProject(request: DeleteEditingProjectRequest): DeleteEditingProjectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteEditingProject', 'POST', '/', 'json', false, 'json', request);
}

model DeleteImageRequest {
  deleteImageType: string(name='DeleteImageType', position='Query'),
  imageIds?: string(name='ImageIds', position='Query'),
  imageType?: string(name='ImageType', position='Query'),
  imageURLs?: string(name='ImageURLs', position='Query'),
  videoId?: string(name='VideoId', position='Query'),
}

model DeleteImageResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteImageResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteImageResponseBody(name='body'),
}

async function deleteImage(request: DeleteImageRequest): DeleteImageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteImage', 'POST', '/', 'json', false, 'json', request);
}

model DeleteMessageCallbackRequest {
  appId?: string(name='AppId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
}

model DeleteMessageCallbackResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteMessageCallbackResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteMessageCallbackResponseBody(name='body'),
}

async function deleteMessageCallback(request: DeleteMessageCallbackRequest): DeleteMessageCallbackResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteMessageCallback', 'POST', '/', 'json', false, 'json', request);
}

model DeleteMezzaninesRequest {
  force?: boolean(name='Force', position='Query'),
  videoIds: string(name='VideoIds', position='Query'),
}

model DeleteMezzaninesResponseBody = {
  nonExistVideoIds?: [ string ](name='NonExistVideoIds'),
  requestId?: string(name='RequestId'),
  unRemoveableVideoIds?: [ string ](name='UnRemoveableVideoIds'),
}

model DeleteMezzaninesResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteMezzaninesResponseBody(name='body'),
}

async function deleteMezzanines(request: DeleteMezzaninesRequest): DeleteMezzaninesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteMezzanines', 'POST', '/', 'json', false, 'json', request);
}

model DeleteMultipartUploadRequest {
  mediaId: string(name='MediaId', position='Query'),
  mediaType: string(name='MediaType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
}

model DeleteMultipartUploadResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteMultipartUploadResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteMultipartUploadResponseBody(name='body'),
}

async function deleteMultipartUpload(request: DeleteMultipartUploadRequest): DeleteMultipartUploadResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteMultipartUpload', 'POST', '/', 'json', false, 'json', request);
}

model DeleteStreamRequest {
  jobIds: string(name='JobIds', position='Query'),
  videoId: string(name='VideoId', position='Query'),
}

model DeleteStreamResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteStreamResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteStreamResponseBody(name='body'),
}

async function deleteStream(request: DeleteStreamRequest): DeleteStreamResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteStream', 'POST', '/', 'json', false, 'json', request);
}

model DeleteTranscodeTemplateGroupRequest {
  forceDelGroup?: string(name='ForceDelGroup', position='Query'),
  transcodeTemplateGroupId: string(name='TranscodeTemplateGroupId', position='Query'),
  transcodeTemplateIds?: string(name='TranscodeTemplateIds', position='Query'),
}

model DeleteTranscodeTemplateGroupResponseBody = {
  nonExistTranscodeTemplateIds?: [ string ](name='NonExistTranscodeTemplateIds'),
  requestId?: string(name='RequestId'),
}

model DeleteTranscodeTemplateGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteTranscodeTemplateGroupResponseBody(name='body'),
}

async function deleteTranscodeTemplateGroup(request: DeleteTranscodeTemplateGroupRequest): DeleteTranscodeTemplateGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteTranscodeTemplateGroup', 'POST', '/', 'json', false, 'json', request);
}

model DeleteVideoRequest {
  videoIds: string(name='VideoIds', position='Query'),
}

model DeleteVideoResponseBody = {
  forbiddenVideoIds?: [ string ](name='ForbiddenVideoIds'),
  nonExistVideoIds?: [ string ](name='NonExistVideoIds'),
  requestId?: string(name='RequestId'),
}

model DeleteVideoResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVideoResponseBody(name='body'),
}

async function deleteVideo(request: DeleteVideoRequest): DeleteVideoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteVideo', 'POST', '/', 'json', false, 'json', request);
}

model DeleteVodDomainRequest {
  domainName: string(name='DomainName', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DeleteVodDomainResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVodDomainResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVodDomainResponseBody(name='body'),
}

async function deleteVodDomain(request: DeleteVodDomainRequest): DeleteVodDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteVodDomain', 'POST', '/', 'json', false, 'json', request);
}

model DeleteVodSpecificConfigRequest {
  configId: string(name='ConfigId', position='Query'),
  domainName: string(name='DomainName', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DeleteVodSpecificConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVodSpecificConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVodSpecificConfigResponseBody(name='body'),
}

async function deleteVodSpecificConfig(request: DeleteVodSpecificConfigRequest): DeleteVodSpecificConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteVodSpecificConfig', 'POST', '/', 'json', false, 'json', request);
}

model DeleteVodTemplateRequest {
  vodTemplateId: string(name='VodTemplateId', position='Query'),
}

model DeleteVodTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  vodTemplateId?: string(name='VodTemplateId'),
}

model DeleteVodTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVodTemplateResponseBody(name='body'),
}

async function deleteVodTemplate(request: DeleteVodTemplateRequest): DeleteVodTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteVodTemplate', 'POST', '/', 'json', false, 'json', request);
}

model DeleteWatermarkRequest {
  watermarkId: string(name='WatermarkId', position='Query'),
}

model DeleteWatermarkResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteWatermarkResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteWatermarkResponseBody(name='body'),
}

async function deleteWatermark(request: DeleteWatermarkRequest): DeleteWatermarkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteWatermark', 'POST', '/', 'json', false, 'json', request);
}

model DescribePlayTopVideosRequest {
  bizDate: string(name='BizDate', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNo?: long(name='PageNo', position='Query'),
  pageSize?: long(name='PageSize', minimum=10, maximum=1000, position='Query'),
}

model DescribePlayTopVideosResponseBody = {
  pageNo?: long(name='PageNo'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  topPlayVideos?: {
    topPlayVideoStatis?: [ 
    {
      playDuration?: string(name='PlayDuration'),
      title?: string(name='Title'),
      uv?: string(name='UV'),
      vv?: string(name='VV'),
      videoId?: string(name='VideoId'),
    }
  ](name='TopPlayVideoStatis')
  }(name='TopPlayVideos'),
  totalNum?: long(name='TotalNum'),
}

model DescribePlayTopVideosResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePlayTopVideosResponseBody(name='body'),
}

async function describePlayTopVideos(request: DescribePlayTopVideosRequest): DescribePlayTopVideosResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePlayTopVideos', 'POST', '/', 'json', false, 'json', request);
}

model DescribePlayUserAvgRequest {
  endTime: string(name='EndTime', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  startTime: string(name='StartTime', position='Query'),
}

model DescribePlayUserAvgResponseBody = {
  requestId?: string(name='RequestId'),
  userPlayStatisAvgs?: {
    userPlayStatisAvg?: [ 
    {
      avgPlayCount?: string(name='AvgPlayCount'),
      avgPlayDuration?: string(name='AvgPlayDuration'),
      date?: string(name='Date'),
    }
  ](name='UserPlayStatisAvg')
  }(name='UserPlayStatisAvgs'),
}

model DescribePlayUserAvgResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePlayUserAvgResponseBody(name='body'),
}

async function describePlayUserAvg(request: DescribePlayUserAvgRequest): DescribePlayUserAvgResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePlayUserAvg', 'POST', '/', 'json', false, 'json', request);
}

model DescribePlayUserTotalRequest {
  endTime: string(name='EndTime', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  startTime: string(name='StartTime', position='Query'),
}

model DescribePlayUserTotalResponseBody = {
  requestId?: string(name='RequestId'),
  userPlayStatisTotals?: {
    userPlayStatisTotal?: [ 
    {
      date?: string(name='Date'),
      playDuration?: string(name='PlayDuration'),
      playRange?: string(name='PlayRange'),
      uv?: {
        android?: string(name='Android'),
        flash?: string(name='Flash'),
        HTML5?: string(name='HTML5'),
        iOS?: string(name='iOS'),
      }(name='UV'),
      vv?: {
        android?: string(name='Android'),
        flash?: string(name='Flash'),
        HTML5?: string(name='HTML5'),
        iOS?: string(name='iOS'),
      }(name='VV'),
    }
  ](name='UserPlayStatisTotal')
  }(name='UserPlayStatisTotals'),
}

model DescribePlayUserTotalResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePlayUserTotalResponseBody(name='body'),
}

async function describePlayUserTotal(request: DescribePlayUserTotalRequest): DescribePlayUserTotalResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePlayUserTotal', 'POST', '/', 'json', false, 'json', request);
}

model DescribePlayVideoStatisRequest {
  endTime: string(name='EndTime', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  startTime: string(name='StartTime', position='Query'),
  videoId: string(name='VideoId', position='Query'),
}

model DescribePlayVideoStatisResponseBody = {
  requestId?: string(name='RequestId'),
  videoPlayStatisDetails?: {
    videoPlayStatisDetail?: [ 
    {
      date?: string(name='Date'),
      playDuration?: string(name='PlayDuration'),
      playRange?: string(name='PlayRange'),
      title?: string(name='Title'),
      uv?: string(name='UV'),
      vv?: string(name='VV'),
    }
  ](name='VideoPlayStatisDetail')
  }(name='VideoPlayStatisDetails'),
}

model DescribePlayVideoStatisResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePlayVideoStatisResponseBody(name='body'),
}

async function describePlayVideoStatis(request: DescribePlayVideoStatisRequest): DescribePlayVideoStatisResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePlayVideoStatis', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVodAIDataRequest {
  AIType?: string(name='AIType', position='Query'),
  endTime: string(name='EndTime', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  region?: string(name='Region', position='Query'),
  startTime: string(name='StartTime', position='Query'),
}

model DescribeVodAIDataResponseBody = {
  AIData?: {
    AIDataItem?: [ 
    {
      data?: {
        dataItem?: [ 
        {
          name?: string(name='Name'),
          value?: string(name='Value'),
        }
      ](name='DataItem')
      }(name='Data'),
      timeStamp?: string(name='TimeStamp'),
    }
  ](name='AIDataItem')
  }(name='AIData'),
  dataInterval?: string(name='DataInterval'),
  requestId?: string(name='RequestId'),
}

model DescribeVodAIDataResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVodAIDataResponseBody(name='body'),
}

async function describeVodAIData(request: DescribeVodAIDataRequest): DescribeVodAIDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVodAIData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVodCertificateListRequest {
  domainName?: string(name='DomainName', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DescribeVodCertificateListResponseBody = {
  certificateListModel?: {
    certList?: {
      cert?: [ 
      {
        certId?: long(name='CertId'),
        certName?: string(name='CertName'),
        common?: string(name='Common'),
        fingerprint?: string(name='Fingerprint'),
        issuer?: string(name='Issuer'),
        lastTime?: long(name='LastTime'),
      }
    ](name='Cert')
    }(name='CertList'),
    count?: int32(name='Count'),
  }(name='CertificateListModel'),
  requestId?: string(name='RequestId'),
}

model DescribeVodCertificateListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVodCertificateListResponseBody(name='body'),
}

async function describeVodCertificateList(request: DescribeVodCertificateListRequest): DescribeVodCertificateListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVodCertificateList', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVodDomainBpsDataRequest {
  domainName?: string(name='DomainName', position='Query'),
  endTime?: string(name='EndTime', position='Query'),
  interval?: string(name='Interval', position='Query'),
  ispNameEn?: string(name='IspNameEn', position='Query'),
  locationNameEn?: string(name='LocationNameEn', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
}

model DescribeVodDomainBpsDataResponseBody = {
  bpsDataPerInterval?: {
    dataModule?: [ 
    {
      domesticValue?: string(name='DomesticValue'),
      httpsDomesticValue?: string(name='HttpsDomesticValue'),
      httpsOverseasValue?: string(name='HttpsOverseasValue'),
      httpsValue?: string(name='HttpsValue'),
      overseasValue?: string(name='OverseasValue'),
      timeStamp?: string(name='TimeStamp'),
      value?: string(name='Value'),
    }
  ](name='DataModule')
  }(name='BpsDataPerInterval'),
  dataInterval?: string(name='DataInterval'),
  domainName?: string(name='DomainName'),
  endTime?: string(name='EndTime'),
  ispNameEn?: string(name='IspNameEn'),
  locationNameEn?: string(name='LocationNameEn'),
  requestId?: string(name='RequestId'),
  startTime?: string(name='StartTime'),
}

model DescribeVodDomainBpsDataResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVodDomainBpsDataResponseBody(name='body'),
}

async function describeVodDomainBpsData(request: DescribeVodDomainBpsDataRequest): DescribeVodDomainBpsDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVodDomainBpsData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVodDomainCertificateInfoRequest {
  domainName: string(name='DomainName', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
}

model DescribeVodDomainCertificateInfoResponseBody = {
  certInfos?: {
    certInfo?: [ 
    {
      certDomainName?: string(name='CertDomainName'),
      certExpireTime?: string(name='CertExpireTime'),
      certLife?: string(name='CertLife'),
      certName?: string(name='CertName'),
      certOrg?: string(name='CertOrg'),
      certType?: string(name='CertType'),
      domainName?: string(name='DomainName'),
      serverCertificateStatus?: string(name='ServerCertificateStatus'),
      status?: string(name='Status'),
    }
  ](name='CertInfo')
  }(name='CertInfos'),
  requestId?: string(name='RequestId'),
}

model DescribeVodDomainCertificateInfoResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVodDomainCertificateInfoResponseBody(name='body'),
}

async function describeVodDomainCertificateInfo(request: DescribeVodDomainCertificateInfoRequest): DescribeVodDomainCertificateInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVodDomainCertificateInfo', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVodDomainConfigsRequest {
  domainName: string(name='DomainName', position='Query'),
  functionNames: string(name='FunctionNames', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DescribeVodDomainConfigsResponseBody = {
  domainConfigs?: {
    domainConfig?: [ 
    {
      configId?: string(name='ConfigId'),
      functionArgs?: {
        functionArg?: [ 
        {
          argName?: string(name='ArgName'),
          argValue?: string(name='ArgValue'),
        }
      ](name='FunctionArg')
      }(name='FunctionArgs'),
      functionName?: string(name='FunctionName'),
      status?: string(name='Status'),
    }
  ](name='DomainConfig')
  }(name='DomainConfigs'),
  requestId?: string(name='RequestId'),
}

model DescribeVodDomainConfigsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVodDomainConfigsResponseBody(name='body'),
}

async function describeVodDomainConfigs(request: DescribeVodDomainConfigsRequest): DescribeVodDomainConfigsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVodDomainConfigs', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVodDomainDetailRequest {
  domainName: string(name='DomainName', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DescribeVodDomainDetailResponseBody = {
  domainDetail?: {
    certName?: string(name='CertName'),
    cname?: string(name='Cname'),
    description?: string(name='Description'),
    domainName?: string(name='DomainName'),
    domainStatus?: string(name='DomainStatus'),
    gmtCreated?: string(name='GmtCreated'),
    gmtModified?: string(name='GmtModified'),
    SSLProtocol?: string(name='SSLProtocol'),
    SSLPub?: string(name='SSLPub'),
    scope?: string(name='Scope'),
    sources?: {
      source?: [ 
      {
        content?: string(name='Content'),
        enabled?: string(name='Enabled'),
        port?: int32(name='Port'),
        priority?: string(name='Priority'),
        type?: string(name='Type'),
      }
    ](name='Source')
    }(name='Sources'),
    weight?: string(name='Weight'),
  }(name='DomainDetail'),
  requestId?: string(name='RequestId'),
}

model DescribeVodDomainDetailResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVodDomainDetailResponseBody(name='body'),
}

async function describeVodDomainDetail(request: DescribeVodDomainDetailRequest): DescribeVodDomainDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVodDomainDetail', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVodDomainLogRequest {
  domainName: string(name='DomainName', position='Query'),
  endTime?: string(name='EndTime', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: long(name='PageNumber', minimum=1, position='Query'),
  pageSize?: long(name='PageSize', minimum=1, maximum=1000, position='Query'),
  startTime?: string(name='StartTime', position='Query'),
}

model DescribeVodDomainLogResponseBody = {
  domainLogDetails?: {
    domainLogDetail?: [ 
    {
      domainName?: string(name='DomainName'),
      logCount?: long(name='LogCount'),
      logInfos?: {
        logInfoDetail?: [ 
        {
          endTime?: string(name='EndTime'),
          logName?: string(name='LogName'),
          logPath?: string(name='LogPath'),
          logSize?: long(name='LogSize'),
          startTime?: string(name='StartTime'),
        }
      ](name='LogInfoDetail')
      }(name='LogInfos'),
      pageInfos?: {
        pageNumber?: long(name='PageNumber'),
        pageSize?: long(name='PageSize'),
        total?: long(name='Total'),
      }(name='PageInfos'),
    }
  ](name='DomainLogDetail')
  }(name='DomainLogDetails'),
  requestId?: string(name='RequestId'),
}

model DescribeVodDomainLogResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVodDomainLogResponseBody(name='body'),
}

async function describeVodDomainLog(request: DescribeVodDomainLogRequest): DescribeVodDomainLogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVodDomainLog', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVodDomainTrafficDataRequest {
  domainName?: string(name='DomainName', position='Query'),
  endTime?: string(name='EndTime', position='Query'),
  interval?: string(name='Interval', position='Query'),
  ispNameEn?: string(name='IspNameEn', position='Query'),
  locationNameEn?: string(name='LocationNameEn', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
}

model DescribeVodDomainTrafficDataResponseBody = {
  dataInterval?: string(name='DataInterval'),
  domainName?: string(name='DomainName'),
  endTime?: string(name='EndTime'),
  requestId?: string(name='RequestId'),
  startTime?: string(name='StartTime'),
  totalTraffic?: string(name='TotalTraffic'),
  trafficDataPerInterval?: {
    dataModule?: [ 
    {
      domesticValue?: string(name='DomesticValue'),
      httpsDomesticValue?: string(name='HttpsDomesticValue'),
      httpsOverseasValue?: string(name='HttpsOverseasValue'),
      httpsValue?: string(name='HttpsValue'),
      overseasValue?: string(name='OverseasValue'),
      timeStamp?: string(name='TimeStamp'),
      value?: string(name='Value'),
    }
  ](name='DataModule')
  }(name='TrafficDataPerInterval'),
}

model DescribeVodDomainTrafficDataResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVodDomainTrafficDataResponseBody(name='body'),
}

async function describeVodDomainTrafficData(request: DescribeVodDomainTrafficDataRequest): DescribeVodDomainTrafficDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVodDomainTrafficData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVodDomainUsageDataRequest {
  area?: string(name='Area', position='Query'),
  domainName?: string(name='DomainName', position='Query'),
  endTime: string(name='EndTime', position='Query'),
  field: string(name='Field', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  startTime: string(name='StartTime', position='Query'),
  type?: string(name='Type', position='Query'),
}

model DescribeVodDomainUsageDataResponseBody = {
  area?: string(name='Area'),
  dataInterval?: string(name='DataInterval'),
  domainName?: string(name='DomainName'),
  endTime?: string(name='EndTime'),
  requestId?: string(name='RequestId'),
  startTime?: string(name='StartTime'),
  type?: string(name='Type'),
  usageDataPerInterval?: {
    dataModule?: [ 
    {
      timeStamp?: string(name='TimeStamp'),
      value?: string(name='Value'),
    }
  ](name='DataModule')
  }(name='UsageDataPerInterval'),
}

model DescribeVodDomainUsageDataResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVodDomainUsageDataResponseBody(name='body'),
}

async function describeVodDomainUsageData(request: DescribeVodDomainUsageDataRequest): DescribeVodDomainUsageDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVodDomainUsageData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVodRefreshQuotaRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DescribeVodRefreshQuotaResponseBody = {
  blockQuota?: string(name='BlockQuota'),
  dirQuota?: string(name='DirQuota'),
  dirRemain?: string(name='DirRemain'),
  preloadQuota?: string(name='PreloadQuota'),
  preloadRemain?: string(name='PreloadRemain'),
  requestId?: string(name='RequestId'),
  urlQuota?: string(name='UrlQuota'),
  urlRemain?: string(name='UrlRemain'),
  blockRemain?: string(name='blockRemain'),
}

model DescribeVodRefreshQuotaResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVodRefreshQuotaResponseBody(name='body'),
}

async function describeVodRefreshQuota(request: DescribeVodRefreshQuotaRequest): DescribeVodRefreshQuotaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVodRefreshQuota', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVodRefreshTasksRequest {
  domainName?: string(name='DomainName', position='Query'),
  endTime?: string(name='EndTime', position='Query'),
  objectPath?: string(name='ObjectPath', position='Query'),
  objectType?: string(name='ObjectType', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=42949672, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=50, position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
  status?: string(name='Status', position='Query'),
  taskId?: string(name='TaskId', position='Query'),
}

model DescribeVodRefreshTasksResponseBody = {
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  tasks?: {
    task?: [ 
    {
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      objectPath?: string(name='ObjectPath'),
      objectType?: string(name='ObjectType'),
      process?: string(name='Process'),
      status?: string(name='Status'),
      taskId?: string(name='TaskId'),
    }
  ](name='Task')
  }(name='Tasks'),
  totalCount?: long(name='TotalCount'),
}

model DescribeVodRefreshTasksResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVodRefreshTasksResponseBody(name='body'),
}

async function describeVodRefreshTasks(request: DescribeVodRefreshTasksRequest): DescribeVodRefreshTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVodRefreshTasks', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVodStorageDataRequest {
  endTime: string(name='EndTime', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  region?: string(name='Region', position='Query'),
  startTime: string(name='StartTime', position='Query'),
  storage?: string(name='Storage', position='Query'),
  storageType?: string(name='StorageType', position='Query'),
}

model DescribeVodStorageDataResponseBody = {
  dataInterval?: string(name='DataInterval'),
  requestId?: string(name='RequestId'),
  storageData?: {
    storageDataItem?: [ 
    {
      networkOut?: string(name='NetworkOut'),
      storageUtilization?: string(name='StorageUtilization'),
      timeStamp?: string(name='TimeStamp'),
    }
  ](name='StorageDataItem')
  }(name='StorageData'),
}

model DescribeVodStorageDataResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVodStorageDataResponseBody(name='body'),
}

async function describeVodStorageData(request: DescribeVodStorageDataRequest): DescribeVodStorageDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVodStorageData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVodTranscodeDataRequest {
  endTime: string(name='EndTime', position='Query'),
  interval?: string(name='Interval', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  region?: string(name='Region', position='Query'),
  specification?: string(name='Specification', position='Query'),
  startTime: string(name='StartTime', position='Query'),
  storage?: string(name='Storage', position='Query'),
}

model DescribeVodTranscodeDataResponseBody = {
  dataInterval?: string(name='DataInterval'),
  requestId?: string(name='RequestId'),
  transcodeData?: {
    transcodeDataItem?: [ 
    {
      data?: {
        dataItem?: [ 
        {
          name?: string(name='Name'),
          value?: string(name='Value'),
        }
      ](name='DataItem')
      }(name='Data'),
      timeStamp?: string(name='TimeStamp'),
    }
  ](name='TranscodeDataItem')
  }(name='TranscodeData'),
}

model DescribeVodTranscodeDataResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVodTranscodeDataResponseBody(name='body'),
}

async function describeVodTranscodeData(request: DescribeVodTranscodeDataRequest): DescribeVodTranscodeDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVodTranscodeData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVodUserDomainsRequest {
  domainName?: string(name='DomainName', position='Query'),
  domainSearchType?: string(name='DomainSearchType', position='Query'),
  domainStatus?: string(name='DomainStatus', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=500, position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model DescribeVodUserDomainsResponseBody = {
  domains?: {
    pageData?: [ 
    {
      cname?: string(name='Cname'),
      description?: string(name='Description'),
      domainName?: string(name='DomainName'),
      domainStatus?: string(name='DomainStatus'),
      gmtCreated?: string(name='GmtCreated'),
      gmtModified?: string(name='GmtModified'),
      sandbox?: string(name='Sandbox'),
      sources?: {
        source?: [ 
        {
          content?: string(name='Content'),
          port?: int32(name='Port'),
          priority?: string(name='Priority'),
          type?: string(name='Type'),
        }
      ](name='Source')
      }(name='Sources'),
      sslProtocol?: string(name='SslProtocol'),
    }
  ](name='PageData')
  }(name='Domains'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribeVodUserDomainsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVodUserDomainsResponseBody(name='body'),
}

async function describeVodUserDomains(request: DescribeVodUserDomainsRequest): DescribeVodUserDomainsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVodUserDomains', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVodVerifyContentRequest {
  domainName: string(name='DomainName', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
}

model DescribeVodVerifyContentResponseBody = {
  content?: string(name='Content'),
  requestId?: string(name='RequestId'),
}

model DescribeVodVerifyContentResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVodVerifyContentResponseBody(name='body'),
}

async function describeVodVerifyContent(request: DescribeVodVerifyContentRequest): DescribeVodVerifyContentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVodVerifyContent', 'POST', '/', 'json', false, 'json', request);
}

model DetachAppPolicyFromIdentityRequest {
  appId?: string(name='AppId', position='Query'),
  identityName: string(name='IdentityName', position='Query'),
  identityType: string(name='IdentityType', position='Query'),
  policyNames: string(name='PolicyNames', position='Query'),
}

model DetachAppPolicyFromIdentityResponseBody = {
  failedPolicyNames?: [ string ](name='FailedPolicyNames'),
  nonExistPolicyNames?: [ string ](name='NonExistPolicyNames'),
  requestId?: string(name='RequestId'),
}

model DetachAppPolicyFromIdentityResponse = {
  headers: map[string]string(name='headers'),
  body: DetachAppPolicyFromIdentityResponseBody(name='body'),
}

async function detachAppPolicyFromIdentity(request: DetachAppPolicyFromIdentityRequest): DetachAppPolicyFromIdentityResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DetachAppPolicyFromIdentity', 'POST', '/', 'json', false, 'json', request);
}

model GenerateKMSDataKeyRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: string(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: string(name='ResourceOwnerId', position='Query'),
}

model GenerateKMSDataKeyResponseBody = {
  ciphertextBlob?: string(name='CiphertextBlob'),
  keyId?: string(name='KeyId'),
  plaintext?: string(name='Plaintext'),
  requestId?: string(name='RequestId'),
}

model GenerateKMSDataKeyResponse = {
  headers: map[string]string(name='headers'),
  body: GenerateKMSDataKeyResponseBody(name='body'),
}

async function generateKMSDataKey(request: GenerateKMSDataKeyRequest): GenerateKMSDataKeyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GenerateKMSDataKey', 'POST', '/', 'json', false, 'json', request);
}

model GetAIImageJobsRequest {
  jobIds: string(name='JobIds', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: string(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: string(name='ResourceOwnerId', position='Query'),
}

model GetAIImageJobsResponseBody = {
  AIImageJobList?: [ 
    {
      AIImageResult?: string(name='AIImageResult'),
      code?: string(name='Code'),
      creationTime?: string(name='CreationTime'),
      jobId?: string(name='JobId'),
      message?: string(name='Message'),
      status?: string(name='Status'),
      templateConfig?: string(name='TemplateConfig'),
      templateId?: string(name='TemplateId'),
      userData?: string(name='UserData'),
      videoId?: string(name='VideoId'),
    }
  ](name='AIImageJobList'),
  requestId?: string(name='RequestId'),
}

model GetAIImageJobsResponse = {
  headers: map[string]string(name='headers'),
  body: GetAIImageJobsResponseBody(name='body'),
}

async function getAIImageJobs(request: GetAIImageJobsRequest): GetAIImageJobsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetAIImageJobs', 'POST', '/', 'json', false, 'json', request);
}

model GetAIMediaAuditJobRequest {
  jobId: string(name='JobId', position='Query'),
}

model GetAIMediaAuditJobResponseBody = {
  mediaAuditJob?: {
    code?: string(name='Code'),
    completeTime?: string(name='CompleteTime'),
    creationTime?: string(name='CreationTime'),
    data?: {
      abnormalModules?: string(name='AbnormalModules'),
      audioResult?: [ 
        {
          label?: string(name='Label'),
          scene?: string(name='Scene'),
          score?: string(name='Score'),
          suggestion?: string(name='Suggestion'),
        }
      ](name='AudioResult'),
      imageResult?: [ 
        {
          label?: string(name='Label'),
          result?: [ 
            {
              label?: string(name='Label'),
              scene?: string(name='Scene'),
              score?: string(name='Score'),
              suggestion?: string(name='Suggestion'),
            }
          ](name='Result'),
          suggestion?: string(name='Suggestion'),
          type?: string(name='Type'),
          url?: string(name='Url'),
        }
      ](name='ImageResult'),
      label?: string(name='Label'),
      suggestion?: string(name='Suggestion'),
      textResult?: [ 
        {
          content?: string(name='Content'),
          label?: string(name='Label'),
          scene?: string(name='Scene'),
          score?: string(name='Score'),
          suggestion?: string(name='Suggestion'),
          type?: string(name='Type'),
        }
      ](name='TextResult'),
      videoResult?: {
        adResult?: {
          averageScore?: string(name='AverageScore'),
          counterList?: [ 
            {
              count?: int32(name='Count'),
              label?: string(name='Label'),
            }
          ](name='CounterList'),
          label?: string(name='Label'),
          maxScore?: string(name='MaxScore'),
          suggestion?: string(name='Suggestion'),
          topList?: [ 
            {
              label?: string(name='Label'),
              score?: string(name='Score'),
              timestamp?: string(name='Timestamp'),
              url?: string(name='Url'),
            }
          ](name='TopList'),
        }(name='AdResult'),
        label?: string(name='Label'),
        liveResult?: {
          averageScore?: string(name='AverageScore'),
          counterList?: [ 
            {
              count?: int32(name='Count'),
              label?: string(name='Label'),
            }
          ](name='CounterList'),
          label?: string(name='Label'),
          maxScore?: string(name='MaxScore'),
          suggestion?: string(name='Suggestion'),
          topList?: [ 
            {
              label?: string(name='Label'),
              score?: string(name='Score'),
              timestamp?: string(name='Timestamp'),
              url?: string(name='Url'),
            }
          ](name='TopList'),
        }(name='LiveResult'),
        logoResult?: {
          averageScore?: string(name='AverageScore'),
          counterList?: [ 
            {
              count?: int32(name='Count'),
              label?: string(name='Label'),
            }
          ](name='CounterList'),
          label?: string(name='Label'),
          maxScore?: string(name='MaxScore'),
          suggestion?: string(name='Suggestion'),
          topList?: [ 
            {
              label?: string(name='Label'),
              score?: string(name='Score'),
              timestamp?: string(name='Timestamp'),
              url?: string(name='Url'),
            }
          ](name='TopList'),
        }(name='LogoResult'),
        pornResult?: {
          averageScore?: string(name='AverageScore'),
          counterList?: [ 
            {
              count?: int32(name='Count'),
              label?: string(name='Label'),
            }
          ](name='CounterList'),
          label?: string(name='Label'),
          maxScore?: string(name='MaxScore'),
          suggestion?: string(name='Suggestion'),
          topList?: [ 
            {
              label?: string(name='Label'),
              score?: string(name='Score'),
              timestamp?: string(name='Timestamp'),
              url?: string(name='Url'),
            }
          ](name='TopList'),
        }(name='PornResult'),
        suggestion?: string(name='Suggestion'),
        terrorismResult?: {
          averageScore?: string(name='AverageScore'),
          counterList?: [ 
            {
              count?: int32(name='Count'),
              label?: string(name='Label'),
            }
          ](name='CounterList'),
          label?: string(name='Label'),
          maxScore?: string(name='MaxScore'),
          suggestion?: string(name='Suggestion'),
          topList?: [ 
            {
              label?: string(name='Label'),
              score?: string(name='Score'),
              timestamp?: string(name='Timestamp'),
              url?: string(name='Url'),
            }
          ](name='TopList'),
        }(name='TerrorismResult'),
      }(name='VideoResult'),
    }(name='Data'),
    jobId?: string(name='JobId'),
    mediaId?: string(name='MediaId'),
    message?: string(name='Message'),
    status?: string(name='Status'),
    type?: string(name='Type'),
  }(name='MediaAuditJob'),
  requestId?: string(name='RequestId'),
}

model GetAIMediaAuditJobResponse = {
  headers: map[string]string(name='headers'),
  body: GetAIMediaAuditJobResponseBody(name='body'),
}

async function getAIMediaAuditJob(request: GetAIMediaAuditJobRequest): GetAIMediaAuditJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetAIMediaAuditJob', 'POST', '/', 'json', false, 'json', request);
}

model GetAITemplateRequest {
  templateId: string(name='TemplateId', position='Query'),
}

model GetAITemplateResponseBody = {
  requestId?: string(name='RequestId'),
  templateInfo?: {
    creationTime?: string(name='CreationTime'),
    isDefault?: string(name='IsDefault'),
    modifyTime?: string(name='ModifyTime'),
    source?: string(name='Source'),
    templateConfig?: string(name='TemplateConfig'),
    templateId?: string(name='TemplateId'),
    templateName?: string(name='TemplateName'),
    templateType?: string(name='TemplateType'),
  }(name='TemplateInfo'),
}

model GetAITemplateResponse = {
  headers: map[string]string(name='headers'),
  body: GetAITemplateResponseBody(name='body'),
}

async function getAITemplate(request: GetAITemplateRequest): GetAITemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetAITemplate', 'POST', '/', 'json', false, 'json', request);
}

model GetAIVideoTagResultRequest {
  mediaId: string(name='MediaId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: string(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: string(name='ResourceOwnerId', position='Query'),
}

model GetAIVideoTagResultResponseBody = {
  requestId?: string(name='RequestId'),
  videoTagResult?: {
    category?: [ 
      {
        tag?: string(name='Tag'),
      }
    ](name='Category'),
    keyword?: [ 
      {
        tag?: string(name='Tag'),
        times?: [ string ](name='Times'),
      }
    ](name='Keyword'),
    location?: [ 
      {
        tag?: string(name='Tag'),
        times?: [ string ](name='Times'),
      }
    ](name='Location'),
    person?: [ 
      {
        faceUrl?: string(name='FaceUrl'),
        tag?: string(name='Tag'),
        times?: [ string ](name='Times'),
      }
    ](name='Person'),
    time?: [ 
      {
        tag?: string(name='Tag'),
        times?: [ string ](name='Times'),
      }
    ](name='Time'),
  }(name='VideoTagResult'),
}

model GetAIVideoTagResultResponse = {
  headers: map[string]string(name='headers'),
  body: GetAIVideoTagResultResponseBody(name='body'),
}

async function getAIVideoTagResult(request: GetAIVideoTagResultRequest): GetAIVideoTagResultResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetAIVideoTagResult', 'POST', '/', 'json', false, 'json', request);
}

model GetAppInfosRequest {
  appIds: string(name='AppIds', position='Query'),
}

model GetAppInfosResponseBody = {
  appInfoList?: [ 
    {
      appId?: string(name='AppId'),
      appName?: string(name='AppName'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      modificationTime?: string(name='ModificationTime'),
      status?: string(name='Status'),
      type?: string(name='Type'),
    }
  ](name='AppInfoList'),
  nonExistAppIds?: [ string ](name='NonExistAppIds'),
  requestId?: string(name='RequestId'),
}

model GetAppInfosResponse = {
  headers: map[string]string(name='headers'),
  body: GetAppInfosResponseBody(name='body'),
}

async function getAppInfos(request: GetAppInfosRequest): GetAppInfosResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetAppInfos', 'POST', '/', 'json', false, 'json', request);
}

model GetAttachedMediaInfoRequest {
  authTimeout?: long(name='AuthTimeout', position='Query'),
  mediaIds: string(name='MediaIds', position='Query'),
  outputType?: string(name='OutputType', position='Query'),
}

model GetAttachedMediaInfoResponseBody = {
  attachedMediaList?: [ 
    {
      appId?: string(name='AppId'),
      categories?: [ 
        {
          cateId?: long(name='CateId'),
          cateName?: string(name='CateName'),
          level?: long(name='Level'),
          parentId?: long(name='ParentId'),
        }
      ](name='Categories'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      mediaId?: string(name='MediaId'),
      modificationTime?: string(name='ModificationTime'),
      status?: string(name='Status'),
      storageLocation?: string(name='StorageLocation'),
      tags?: string(name='Tags'),
      title?: string(name='Title'),
      type?: string(name='Type'),
      URL?: string(name='URL'),
    }
  ](name='AttachedMediaList'),
  nonExistMediaIds?: [ string ](name='NonExistMediaIds'),
  requestId?: string(name='RequestId'),
}

model GetAttachedMediaInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetAttachedMediaInfoResponseBody(name='body'),
}

async function getAttachedMediaInfo(request: GetAttachedMediaInfoRequest): GetAttachedMediaInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetAttachedMediaInfo', 'POST', '/', 'json', false, 'json', request);
}

model GetAuditHistoryRequest {
  pageNo?: long(name='PageNo', position='Query'),
  pageSize?: long(name='PageSize', position='Query'),
  sortBy?: string(name='SortBy', position='Query'),
  videoId: string(name='VideoId', position='Query'),
}

model GetAuditHistoryResponseBody = {
  histories?: [ 
    {
      auditor?: string(name='Auditor'),
      comment?: string(name='Comment'),
      creationTime?: string(name='CreationTime'),
      reason?: string(name='Reason'),
      status?: string(name='Status'),
    }
  ](name='Histories'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
  total?: long(name='Total'),
}

model GetAuditHistoryResponse = {
  headers: map[string]string(name='headers'),
  body: GetAuditHistoryResponseBody(name='body'),
}

async function getAuditHistory(request: GetAuditHistoryRequest): GetAuditHistoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetAuditHistory', 'POST', '/', 'json', false, 'json', request);
}

model GetCategoriesRequest {
  cateId?: long(name='CateId', position='Query'),
  pageNo?: long(name='PageNo', position='Query'),
  pageSize?: long(name='PageSize', position='Query'),
  sortBy?: string(name='SortBy', position='Query'),
  type?: string(name='Type', position='Query'),
}

model GetCategoriesResponseBody = {
  category?: {
    cateId?: long(name='CateId'),
    cateName?: string(name='CateName'),
    level?: long(name='Level'),
    parentId?: long(name='ParentId'),
    type?: string(name='Type'),
  }(name='Category'),
  requestId?: string(name='RequestId'),
  subCategories?: {
    category?: [ 
    {
      cateId?: long(name='CateId'),
      cateName?: string(name='CateName'),
      level?: long(name='Level'),
      parentId?: long(name='ParentId'),
      subTotal?: long(name='SubTotal'),
      type?: string(name='Type'),
    }
  ](name='Category')
  }(name='SubCategories'),
  subTotal?: long(name='SubTotal'),
}

model GetCategoriesResponse = {
  headers: map[string]string(name='headers'),
  body: GetCategoriesResponseBody(name='body'),
}

async function getCategories(request: GetCategoriesRequest): GetCategoriesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetCategories', 'POST', '/', 'json', false, 'json', request);
}

model GetDefaultAITemplateRequest {
  templateType: string(name='TemplateType', position='Query'),
}

model GetDefaultAITemplateResponseBody = {
  requestId?: string(name='RequestId'),
  templateInfo?: {
    creationTime?: string(name='CreationTime'),
    isDefault?: string(name='IsDefault'),
    modifyTime?: string(name='ModifyTime'),
    source?: string(name='Source'),
    templateConfig?: string(name='TemplateConfig'),
    templateId?: string(name='TemplateId'),
    templateName?: string(name='TemplateName'),
    templateType?: string(name='TemplateType'),
  }(name='TemplateInfo'),
}

model GetDefaultAITemplateResponse = {
  headers: map[string]string(name='headers'),
  body: GetDefaultAITemplateResponseBody(name='body'),
}

async function getDefaultAITemplate(request: GetDefaultAITemplateRequest): GetDefaultAITemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetDefaultAITemplate', 'POST', '/', 'json', false, 'json', request);
}

model GetEditingProjectRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: string(name='OwnerId', position='Query'),
  projectId: string(name='ProjectId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: string(name='ResourceOwnerId', position='Query'),
}

model GetEditingProjectResponseBody = {
  project?: {
    coverURL?: string(name='CoverURL'),
    creationTime?: string(name='CreationTime'),
    description?: string(name='Description'),
    modifiedTime?: string(name='ModifiedTime'),
    projectId?: string(name='ProjectId'),
    regionId?: string(name='RegionId'),
    status?: string(name='Status'),
    storageLocation?: string(name='StorageLocation'),
    timeline?: string(name='Timeline'),
    title?: string(name='Title'),
  }(name='Project'),
  requestId?: string(name='RequestId'),
}

model GetEditingProjectResponse = {
  headers: map[string]string(name='headers'),
  body: GetEditingProjectResponseBody(name='body'),
}

async function getEditingProject(request: GetEditingProjectRequest): GetEditingProjectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetEditingProject', 'POST', '/', 'json', false, 'json', request);
}

model GetEditingProjectMaterialsRequest {
  materialType?: string(name='MaterialType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: string(name='OwnerId', position='Query'),
  projectId: string(name='ProjectId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: string(name='ResourceOwnerId', position='Query'),
  type?: string(name='Type', position='Query'),
}

model GetEditingProjectMaterialsResponseBody = {
  materialList?: {
    material?: [ 
    {
      cateId?: int32(name='CateId'),
      cateName?: string(name='CateName'),
      coverURL?: string(name='CoverURL'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      duration?: float(name='Duration'),
      materialId?: string(name='MaterialId'),
      materialType?: string(name='MaterialType'),
      modifiedTime?: string(name='ModifiedTime'),
      size?: long(name='Size'),
      snapshots?: {
        snapshot?: [ string ](name='Snapshot')
      }(name='Snapshots'),
      source?: string(name='Source'),
      spriteConfig?: string(name='SpriteConfig'),
      sprites?: {
        sprite?: [ string ](name='Sprite')
      }(name='Sprites'),
      status?: string(name='Status'),
      tags?: string(name='Tags'),
      title?: string(name='Title'),
    }
  ](name='Material')
  }(name='MaterialList'),
  requestId?: string(name='RequestId'),
}

model GetEditingProjectMaterialsResponse = {
  headers: map[string]string(name='headers'),
  body: GetEditingProjectMaterialsResponseBody(name='body'),
}

async function getEditingProjectMaterials(request: GetEditingProjectMaterialsRequest): GetEditingProjectMaterialsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetEditingProjectMaterials', 'POST', '/', 'json', false, 'json', request);
}

model GetImageInfoRequest {
  authTimeout?: long(name='AuthTimeout', position='Query'),
  imageId: string(name='ImageId', position='Query'),
  outputType?: string(name='OutputType', position='Query'),
}

model GetImageInfoResponseBody = {
  imageInfo?: {
    appId?: string(name='AppId'),
    cateId?: long(name='CateId'),
    cateName?: string(name='CateName'),
    creationTime?: string(name='CreationTime'),
    description?: string(name='Description'),
    imageId?: string(name='ImageId'),
    imageType?: string(name='ImageType'),
    mezzanine?: {
      fileSize?: string(name='FileSize'),
      fileURL?: string(name='FileURL'),
      height?: int32(name='Height'),
      originalFileName?: string(name='OriginalFileName'),
      width?: int32(name='Width'),
    }(name='Mezzanine'),
    status?: string(name='Status'),
    storageLocation?: string(name='StorageLocation'),
    tags?: string(name='Tags'),
    title?: string(name='Title'),
    URL?: string(name='URL'),
  }(name='ImageInfo'),
  requestId?: string(name='RequestId'),
}

model GetImageInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetImageInfoResponseBody(name='body'),
}

async function getImageInfo(request: GetImageInfoRequest): GetImageInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetImageInfo', 'POST', '/', 'json', false, 'json', request);
}

model GetImageInfosRequest {
  authTimeout?: long(name='AuthTimeout', position='Query'),
  imageIds: string(name='ImageIds', position='Query'),
  outputType?: string(name='OutputType', position='Query'),
}

model GetImageInfosResponseBody = {
  imageInfo?: [ 
    {
      appId?: string(name='AppId'),
      cateId?: long(name='CateId'),
      cateName?: string(name='CateName'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      imageId?: string(name='ImageId'),
      imageType?: string(name='ImageType'),
      mezzanine?: {
        fileSize?: string(name='FileSize'),
        fileURL?: string(name='FileURL'),
        height?: int32(name='Height'),
        originalFileName?: string(name='OriginalFileName'),
        width?: int32(name='Width'),
      }(name='Mezzanine'),
      status?: string(name='Status'),
      storageLocation?: string(name='StorageLocation'),
      tags?: string(name='Tags'),
      title?: string(name='Title'),
      URL?: string(name='URL'),
    }
  ](name='ImageInfo'),
  nonExistImageIds?: [ string ](name='NonExistImageIds'),
  requestId?: string(name='RequestId'),
}

model GetImageInfosResponse = {
  headers: map[string]string(name='headers'),
  body: GetImageInfosResponseBody(name='body'),
}

async function getImageInfos(request: GetImageInfosRequest): GetImageInfosResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetImageInfos', 'POST', '/', 'json', false, 'json', request);
}

model GetMediaAuditAudioResultDetailRequest {
  mediaId: string(name='MediaId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: string(name='OwnerId', position='Query'),
  pageNo?: int32(name='PageNo', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: string(name='ResourceOwnerId', position='Query'),
}

model GetMediaAuditAudioResultDetailResponseBody = {
  mediaAuditAudioResultDetail?: {
    list?: [ 
      {
        endTime?: long(name='EndTime'),
        label?: string(name='Label'),
        startTime?: long(name='StartTime'),
        text?: string(name='Text'),
      }
    ](name='List'),
    pageTotal?: int32(name='PageTotal'),
    total?: int32(name='Total'),
  }(name='MediaAuditAudioResultDetail'),
  requestId?: string(name='RequestId'),
}

model GetMediaAuditAudioResultDetailResponse = {
  headers: map[string]string(name='headers'),
  body: GetMediaAuditAudioResultDetailResponseBody(name='body'),
}

async function getMediaAuditAudioResultDetail(request: GetMediaAuditAudioResultDetailRequest): GetMediaAuditAudioResultDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMediaAuditAudioResultDetail', 'POST', '/', 'json', false, 'json', request);
}

model GetMediaAuditResultRequest {
  mediaId: string(name='MediaId', position='Query'),
}

model GetMediaAuditResultResponseBody = {
  mediaAuditResult?: {
    abnormalModules?: string(name='AbnormalModules'),
    audioResult?: [ 
      {
        label?: string(name='Label'),
        scene?: string(name='Scene'),
        score?: string(name='Score'),
        suggestion?: string(name='Suggestion'),
      }
    ](name='AudioResult'),
    imageResult?: [ 
      {
        label?: string(name='Label'),
        result?: [ 
          {
            label?: string(name='Label'),
            scene?: string(name='Scene'),
            score?: string(name='Score'),
            suggestion?: string(name='Suggestion'),
          }
        ](name='Result'),
        suggestion?: string(name='Suggestion'),
        type?: string(name='Type'),
        url?: string(name='Url'),
      }
    ](name='ImageResult'),
    label?: string(name='Label'),
    suggestion?: string(name='Suggestion'),
    textResult?: [ 
      {
        content?: string(name='Content'),
        label?: string(name='Label'),
        scene?: string(name='Scene'),
        score?: string(name='Score'),
        suggestion?: string(name='Suggestion'),
        type?: string(name='Type'),
      }
    ](name='TextResult'),
    videoResult?: {
      adResult?: {
        averageScore?: string(name='AverageScore'),
        counterList?: [ 
          {
            count?: int32(name='Count'),
            label?: string(name='Label'),
          }
        ](name='CounterList'),
        label?: string(name='Label'),
        maxScore?: string(name='MaxScore'),
        suggestion?: string(name='Suggestion'),
        topList?: [ 
          {
            label?: string(name='Label'),
            score?: string(name='Score'),
            timestamp?: string(name='Timestamp'),
            url?: string(name='Url'),
          }
        ](name='TopList'),
      }(name='AdResult'),
      label?: string(name='Label'),
      liveResult?: {
        averageScore?: string(name='AverageScore'),
        counterList?: [ 
          {
            count?: int32(name='Count'),
            label?: string(name='Label'),
          }
        ](name='CounterList'),
        label?: string(name='Label'),
        maxScore?: string(name='MaxScore'),
        suggestion?: string(name='Suggestion'),
        topList?: [ 
          {
            label?: string(name='Label'),
            score?: string(name='Score'),
            timestamp?: string(name='Timestamp'),
            url?: string(name='Url'),
          }
        ](name='TopList'),
      }(name='LiveResult'),
      logoResult?: {
        averageScore?: string(name='AverageScore'),
        counterList?: [ 
          {
            count?: int32(name='Count'),
            label?: string(name='Label'),
          }
        ](name='CounterList'),
        label?: string(name='Label'),
        maxScore?: string(name='MaxScore'),
        suggestion?: string(name='Suggestion'),
        topList?: [ 
          {
            label?: string(name='Label'),
            score?: string(name='Score'),
            timestamp?: string(name='Timestamp'),
            url?: string(name='Url'),
          }
        ](name='TopList'),
      }(name='LogoResult'),
      pornResult?: {
        averageScore?: string(name='AverageScore'),
        counterList?: [ 
          {
            count?: int32(name='Count'),
            label?: string(name='Label'),
          }
        ](name='CounterList'),
        label?: string(name='Label'),
        maxScore?: string(name='MaxScore'),
        suggestion?: string(name='Suggestion'),
        topList?: [ 
          {
            label?: string(name='Label'),
            score?: string(name='Score'),
            timestamp?: string(name='Timestamp'),
            url?: string(name='Url'),
          }
        ](name='TopList'),
      }(name='PornResult'),
      suggestion?: string(name='Suggestion'),
      terrorismResult?: {
        averageScore?: string(name='AverageScore'),
        counterList?: [ 
          {
            count?: int32(name='Count'),
            label?: string(name='Label'),
          }
        ](name='CounterList'),
        label?: string(name='Label'),
        maxScore?: string(name='MaxScore'),
        suggestion?: string(name='Suggestion'),
        topList?: [ 
          {
            label?: string(name='Label'),
            score?: string(name='Score'),
            timestamp?: string(name='Timestamp'),
            url?: string(name='Url'),
          }
        ](name='TopList'),
      }(name='TerrorismResult'),
    }(name='VideoResult'),
  }(name='MediaAuditResult'),
  requestId?: string(name='RequestId'),
}

model GetMediaAuditResultResponse = {
  headers: map[string]string(name='headers'),
  body: GetMediaAuditResultResponseBody(name='body'),
}

async function getMediaAuditResult(request: GetMediaAuditResultRequest): GetMediaAuditResultResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMediaAuditResult', 'POST', '/', 'json', false, 'json', request);
}

model GetMediaAuditResultDetailRequest {
  mediaId: string(name='MediaId', position='Query'),
  pageNo: int32(name='PageNo', position='Query'),
}

model GetMediaAuditResultDetailResponseBody = {
  mediaAuditResultDetail?: {
    list?: [ 
      {
        adLabel?: string(name='AdLabel'),
        adScore?: string(name='AdScore'),
        liveLabel?: string(name='LiveLabel'),
        liveScore?: string(name='LiveScore'),
        logoLabel?: string(name='LogoLabel'),
        logoScore?: string(name='LogoScore'),
        pornLabel?: string(name='PornLabel'),
        pornScore?: string(name='PornScore'),
        terrorismLabel?: string(name='TerrorismLabel'),
        terrorismScore?: string(name='TerrorismScore'),
        timestamp?: string(name='Timestamp'),
        url?: string(name='Url'),
      }
    ](name='List'),
    total?: int32(name='Total'),
  }(name='MediaAuditResultDetail'),
  requestId?: string(name='RequestId'),
}

model GetMediaAuditResultDetailResponse = {
  headers: map[string]string(name='headers'),
  body: GetMediaAuditResultDetailResponseBody(name='body'),
}

async function getMediaAuditResultDetail(request: GetMediaAuditResultDetailRequest): GetMediaAuditResultDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMediaAuditResultDetail', 'POST', '/', 'json', false, 'json', request);
}

model GetMediaAuditResultTimelineRequest {
  mediaId: string(name='MediaId', position='Query'),
}

model GetMediaAuditResultTimelineResponseBody = {
  mediaAuditResultTimeline?: {
    ad?: [ 
      {
        label?: string(name='Label'),
        score?: string(name='Score'),
        timestamp?: string(name='Timestamp'),
      }
    ](name='Ad'),
    live?: [ 
      {
        label?: string(name='Label'),
        score?: string(name='Score'),
        timestamp?: string(name='Timestamp'),
      }
    ](name='Live'),
    logo?: [ 
      {
        label?: string(name='Label'),
        score?: string(name='Score'),
        timestamp?: string(name='Timestamp'),
      }
    ](name='Logo'),
    porn?: [ 
      {
        label?: string(name='Label'),
        score?: string(name='Score'),
        timestamp?: string(name='Timestamp'),
      }
    ](name='Porn'),
    terrorism?: [ 
      {
        label?: string(name='Label'),
        score?: string(name='Score'),
        timestamp?: string(name='Timestamp'),
      }
    ](name='Terrorism'),
  }(name='MediaAuditResultTimeline'),
  requestId?: string(name='RequestId'),
}

model GetMediaAuditResultTimelineResponse = {
  headers: map[string]string(name='headers'),
  body: GetMediaAuditResultTimelineResponseBody(name='body'),
}

async function getMediaAuditResultTimeline(request: GetMediaAuditResultTimelineRequest): GetMediaAuditResultTimelineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMediaAuditResultTimeline', 'POST', '/', 'json', false, 'json', request);
}

model GetMediaDNAResultRequest {
  mediaId: string(name='MediaId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: string(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: string(name='ResourceOwnerId', position='Query'),
}

model GetMediaDNAResultResponseBody = {
  DNAResult?: {
    videoDNA?: [ 
      {
        detail?: [ 
          {
            duplication?: {
              duration?: string(name='Duration'),
              start?: string(name='Start'),
            }(name='Duplication'),
            input?: {
              duration?: string(name='Duration'),
              start?: string(name='Start'),
            }(name='Input'),
          }
        ](name='Detail'),
        primaryKey?: string(name='PrimaryKey'),
        similarity?: string(name='Similarity'),
      }
    ](name='VideoDNA'),
  }(name='DNAResult'),
  requestId?: string(name='RequestId'),
}

model GetMediaDNAResultResponse = {
  headers: map[string]string(name='headers'),
  body: GetMediaDNAResultResponseBody(name='body'),
}

async function getMediaDNAResult(request: GetMediaDNAResultRequest): GetMediaDNAResultResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMediaDNAResult', 'POST', '/', 'json', false, 'json', request);
}

model GetMediaRefreshJobsRequest {
  mediaId?: string(name='MediaId', description='媒资ID', position='Query'),
  mediaRefreshJobId: string(name='MediaRefreshJobId', description='媒资刷新预热任务ID', position='Query'),
}

model GetMediaRefreshJobsResponseBody = {
  mediaRefreshJobs?: [ 
    {
      errorCode?: string(name='ErrorCode'),
      errorMessage?: string(name='ErrorMessage'),
      filterPolicy?: string(name='FilterPolicy'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      mediaId?: string(name='MediaId'),
      mediaRefreshJobId?: string(name='MediaRefreshJobId'),
      status?: string(name='Status'),
      successPlayUrls?: string(name='SuccessPlayUrls'),
      taskIds?: string(name='TaskIds'),
      taskType?: string(name='TaskType'),
      userData?: string(name='UserData'),
    }
  ](name='MediaRefreshJobs'),
  requestId?: string(name='RequestId'),
}

model GetMediaRefreshJobsResponse = {
  headers: map[string]string(name='headers'),
  body: GetMediaRefreshJobsResponseBody(name='body'),
}

async function getMediaRefreshJobs(request: GetMediaRefreshJobsRequest): GetMediaRefreshJobsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMediaRefreshJobs', 'GET', '/', 'json', false, 'json', request);
}

model GetMessageCallbackRequest {
  appId?: string(name='AppId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
}

model GetMessageCallbackResponseBody = {
  messageCallback?: {
    appId?: string(name='AppId'),
    authKey?: string(name='AuthKey'),
    authSwitch?: string(name='AuthSwitch'),
    callbackType?: string(name='CallbackType'),
    callbackURL?: string(name='CallbackURL'),
    eventTypeList?: string(name='EventTypeList'),
    mnsEndpoint?: string(name='MnsEndpoint'),
    mnsQueueName?: string(name='MnsQueueName'),
  }(name='MessageCallback'),
  requestId?: string(name='RequestId'),
}

model GetMessageCallbackResponse = {
  headers: map[string]string(name='headers'),
  body: GetMessageCallbackResponseBody(name='body'),
}

async function getMessageCallback(request: GetMessageCallbackRequest): GetMessageCallbackResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMessageCallback', 'POST', '/', 'json', false, 'json', request);
}

model GetMezzanineInfoRequest {
  additionType?: string(name='AdditionType', position='Query'),
  authTimeout?: long(name='AuthTimeout', position='Query'),
  outputType?: string(name='OutputType', position='Query'),
  videoId: string(name='VideoId', position='Query'),
}

model GetMezzanineInfoResponseBody = {
  mezzanine?: {
    audioStreamList?: [ 
      {
        bitrate?: string(name='Bitrate'),
        channelLayout?: string(name='ChannelLayout'),
        channels?: string(name='Channels'),
        codecLongName?: string(name='CodecLongName'),
        codecName?: string(name='CodecName'),
        codecTag?: string(name='CodecTag'),
        codecTagString?: string(name='CodecTagString'),
        codecTimeBase?: string(name='CodecTimeBase'),
        duration?: string(name='Duration'),
        index?: string(name='Index'),
        lang?: string(name='Lang'),
        numFrames?: string(name='NumFrames'),
        sampleFmt?: string(name='SampleFmt'),
        sampleRate?: string(name='SampleRate'),
        startTime?: string(name='StartTime'),
        timebase?: string(name='Timebase'),
      }
    ](name='AudioStreamList'),
    bitrate?: string(name='Bitrate'),
    creationTime?: string(name='CreationTime'),
    duration?: string(name='Duration'),
    fileName?: string(name='FileName'),
    fileURL?: string(name='FileURL'),
    fps?: string(name='Fps'),
    height?: long(name='Height'),
    outputType?: string(name='OutputType'),
    size?: long(name='Size'),
    status?: string(name='Status'),
    videoId?: string(name='VideoId'),
    videoStreamList?: [ 
      {
        avgFPS?: string(name='AvgFPS'),
        bitrate?: string(name='Bitrate'),
        codecLongName?: string(name='CodecLongName'),
        codecName?: string(name='CodecName'),
        codecTag?: string(name='CodecTag'),
        codecTagString?: string(name='CodecTagString'),
        codecTimeBase?: string(name='CodecTimeBase'),
        dar?: string(name='Dar'),
        duration?: string(name='Duration'),
        fps?: string(name='Fps'),
        HDRType?: string(name='HDRType', description='视频流HDR类型'),
        hasBFrames?: string(name='HasBFrames'),
        height?: string(name='Height'),
        index?: string(name='Index'),
        lang?: string(name='Lang'),
        level?: string(name='Level'),
        numFrames?: string(name='NumFrames'),
        pixFmt?: string(name='PixFmt'),
        profile?: string(name='Profile'),
        rotate?: string(name='Rotate'),
        sar?: string(name='Sar'),
        startTime?: string(name='StartTime'),
        timebase?: string(name='Timebase'),
        width?: string(name='Width'),
      }
    ](name='VideoStreamList'),
    width?: long(name='Width'),
  }(name='Mezzanine'),
  requestId?: string(name='RequestId'),
}

model GetMezzanineInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetMezzanineInfoResponseBody(name='body'),
}

async function getMezzanineInfo(request: GetMezzanineInfoRequest): GetMezzanineInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMezzanineInfo', 'POST', '/', 'json', false, 'json', request);
}

model GetPlayInfoRequest {
  additionType?: string(name='AdditionType', position='Query'),
  authTimeout?: long(name='AuthTimeout', position='Query'),
  definition?: string(name='Definition', position='Query'),
  formats?: string(name='Formats', position='Query'),
  outputType?: string(name='OutputType', position='Query'),
  playConfig?: string(name='PlayConfig', position='Query'),
  reAuthInfo?: string(name='ReAuthInfo', position='Query'),
  resultType?: string(name='ResultType', position='Query'),
  streamType?: string(name='StreamType', position='Query'),
  videoId: string(name='VideoId', position='Query'),
}

model GetPlayInfoResponseBody = {
  playInfoList?: {
    playInfo?: [ 
    {
      bitDepth?: int32(name='BitDepth', description='颜色位深'),
      bitrate?: string(name='Bitrate'),
      creationTime?: string(name='CreationTime'),
      definition?: string(name='Definition'),
      duration?: string(name='Duration'),
      encrypt?: long(name='Encrypt'),
      encryptType?: string(name='EncryptType'),
      format?: string(name='Format'),
      fps?: string(name='Fps'),
      HDRType?: string(name='HDRType', description='视频流HDR类型'),
      height?: long(name='Height'),
      jobId?: string(name='JobId'),
      modificationTime?: string(name='ModificationTime'),
      narrowBandType?: string(name='NarrowBandType'),
      playURL?: string(name='PlayURL'),
      size?: long(name='Size'),
      specification?: string(name='Specification'),
      status?: string(name='Status'),
      streamType?: string(name='StreamType'),
      watermarkId?: string(name='WatermarkId'),
      width?: long(name='Width'),
    }
  ](name='PlayInfo')
  }(name='PlayInfoList'),
  requestId?: string(name='RequestId'),
  videoBase?: {
    coverURL?: string(name='CoverURL'),
    creationTime?: string(name='CreationTime'),
    danMuURL?: string(name='DanMuURL'),
    duration?: string(name='Duration'),
    mediaType?: string(name='MediaType'),
    status?: string(name='Status'),
    title?: string(name='Title'),
    videoId?: string(name='VideoId'),
  }(name='VideoBase'),
}

model GetPlayInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetPlayInfoResponseBody(name='body'),
}

async function getPlayInfo(request: GetPlayInfoRequest): GetPlayInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetPlayInfo', 'POST', '/', 'json', false, 'json', request);
}

model GetTranscodeSummaryRequest {
  videoIds: string(name='VideoIds', position='Query'),
}

model GetTranscodeSummaryResponseBody = {
  nonExistVideoIds?: [ string ](name='NonExistVideoIds'),
  requestId?: string(name='RequestId'),
  transcodeSummaryList?: [ 
    {
      completeTime?: string(name='CompleteTime'),
      creationTime?: string(name='CreationTime'),
      transcodeJobInfoSummaryList?: [ 
        {
          bitrate?: string(name='Bitrate'),
          completeTime?: string(name='CompleteTime'),
          creationTime?: string(name='CreationTime'),
          duration?: string(name='Duration'),
          errorCode?: string(name='ErrorCode'),
          errorMessage?: string(name='ErrorMessage'),
          filesize?: long(name='Filesize'),
          format?: string(name='Format'),
          fps?: string(name='Fps'),
          height?: string(name='Height'),
          transcodeJobStatus?: string(name='TranscodeJobStatus'),
          transcodeProgress?: long(name='TranscodeProgress'),
          transcodeTemplateId?: string(name='TranscodeTemplateId'),
          watermarkIdList?: [ string ](name='WatermarkIdList'),
          width?: string(name='Width'),
        }
      ](name='TranscodeJobInfoSummaryList'),
      transcodeStatus?: string(name='TranscodeStatus'),
      transcodeTemplateGroupId?: string(name='TranscodeTemplateGroupId'),
      videoId?: string(name='VideoId'),
    }
  ](name='TranscodeSummaryList'),
}

model GetTranscodeSummaryResponse = {
  headers: map[string]string(name='headers'),
  body: GetTranscodeSummaryResponseBody(name='body'),
}

async function getTranscodeSummary(request: GetTranscodeSummaryRequest): GetTranscodeSummaryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetTranscodeSummary', 'POST', '/', 'json', false, 'json', request);
}

model GetTranscodeTaskRequest {
  transcodeTaskId: string(name='TranscodeTaskId', position='Query'),
}

model GetTranscodeTaskResponseBody = {
  requestId?: string(name='RequestId'),
  transcodeTask?: {
    completeTime?: string(name='CompleteTime'),
    creationTime?: string(name='CreationTime'),
    taskStatus?: string(name='TaskStatus'),
    transcodeJobInfoList?: [ 
      {
        completeTime?: string(name='CompleteTime'),
        creationTime?: string(name='CreationTime'),
        definition?: string(name='Definition'),
        errorCode?: string(name='ErrorCode'),
        errorMessage?: string(name='ErrorMessage'),
        inputFileUrl?: string(name='InputFileUrl'),
        outputFile?: {
          audioStreamList?: string(name='AudioStreamList'),
          bitrate?: string(name='Bitrate'),
          duration?: string(name='Duration'),
          encryption?: string(name='Encryption'),
          filesize?: long(name='Filesize'),
          format?: string(name='Format'),
          fps?: string(name='Fps'),
          height?: string(name='Height'),
          outputFileUrl?: string(name='OutputFileUrl'),
          subtitleStreamList?: string(name='SubtitleStreamList'),
          videoStreamList?: string(name='VideoStreamList'),
          watermarkIdList?: [ string ](name='WatermarkIdList'),
          width?: string(name='Width'),
        }(name='OutputFile'),
        priority?: string(name='Priority'),
        transcodeJobId?: string(name='TranscodeJobId'),
        transcodeJobStatus?: string(name='TranscodeJobStatus'),
        transcodeProgress?: long(name='TranscodeProgress'),
        transcodeTemplateId?: string(name='TranscodeTemplateId'),
      }
    ](name='TranscodeJobInfoList'),
    transcodeTaskId?: string(name='TranscodeTaskId'),
    transcodeTemplateGroupId?: string(name='TranscodeTemplateGroupId'),
    trigger?: string(name='Trigger'),
    videoId?: string(name='VideoId'),
  }(name='TranscodeTask'),
}

model GetTranscodeTaskResponse = {
  headers: map[string]string(name='headers'),
  body: GetTranscodeTaskResponseBody(name='body'),
}

async function getTranscodeTask(request: GetTranscodeTaskRequest): GetTranscodeTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetTranscodeTask', 'POST', '/', 'json', false, 'json', request);
}

model GetTranscodeTemplateGroupRequest {
  transcodeTemplateGroupId: string(name='TranscodeTemplateGroupId', position='Query'),
}

model GetTranscodeTemplateGroupResponseBody = {
  requestId?: string(name='RequestId'),
  transcodeTemplateGroup?: {
    appId?: string(name='AppId'),
    creationTime?: string(name='CreationTime'),
    isDefault?: string(name='IsDefault'),
    locked?: string(name='Locked'),
    modifyTime?: string(name='ModifyTime'),
    name?: string(name='Name'),
    transcodeTemplateGroupId?: string(name='TranscodeTemplateGroupId'),
    transcodeTemplateList?: [ 
      {
        audio?: string(name='Audio'),
        clip?: string(name='Clip'),
        container?: string(name='Container'),
        definition?: string(name='Definition'),
        encryptSetting?: string(name='EncryptSetting'),
        muxConfig?: string(name='MuxConfig'),
        packageSetting?: string(name='PackageSetting'),
        rotate?: string(name='Rotate'),
        subtitleList?: string(name='SubtitleList'),
        templateName?: string(name='TemplateName'),
        transConfig?: string(name='TransConfig'),
        transcodeFileRegular?: string(name='TranscodeFileRegular'),
        transcodeTemplateId?: string(name='TranscodeTemplateId'),
        type?: string(name='Type'),
        video?: string(name='Video'),
        watermarkIds?: [ string ](name='WatermarkIds'),
      }
    ](name='TranscodeTemplateList'),
  }(name='TranscodeTemplateGroup'),
}

model GetTranscodeTemplateGroupResponse = {
  headers: map[string]string(name='headers'),
  body: GetTranscodeTemplateGroupResponseBody(name='body'),
}

async function getTranscodeTemplateGroup(request: GetTranscodeTemplateGroupRequest): GetTranscodeTemplateGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetTranscodeTemplateGroup', 'POST', '/', 'json', false, 'json', request);
}

model GetURLUploadInfosRequest {
  jobIds?: string(name='JobIds', position='Query'),
  uploadURLs?: string(name='UploadURLs', position='Query'),
}

model GetURLUploadInfosResponseBody = {
  nonExists?: [ string ](name='NonExists'),
  requestId?: string(name='RequestId'),
  URLUploadInfoList?: [ 
    {
      completeTime?: string(name='CompleteTime'),
      creationTime?: string(name='CreationTime'),
      errorCode?: string(name='ErrorCode'),
      errorMessage?: string(name='ErrorMessage'),
      fileSize?: string(name='FileSize'),
      jobId?: string(name='JobId'),
      mediaId?: string(name='MediaId'),
      status?: string(name='Status'),
      uploadURL?: string(name='UploadURL'),
      userData?: string(name='UserData'),
    }
  ](name='URLUploadInfoList'),
}

model GetURLUploadInfosResponse = {
  headers: map[string]string(name='headers'),
  body: GetURLUploadInfosResponseBody(name='body'),
}

async function getURLUploadInfos(request: GetURLUploadInfosRequest): GetURLUploadInfosResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetURLUploadInfos', 'POST', '/', 'json', false, 'json', request);
}

model GetUploadDetailsRequest {
  mediaIds: string(name='MediaIds', position='Query'),
  mediaType?: string(name='MediaType', position='Query'),
}

model GetUploadDetailsResponseBody = {
  forbiddenMediaIds?: [ string ](name='ForbiddenMediaIds'),
  nonExistMediaIds?: [ string ](name='NonExistMediaIds'),
  requestId?: string(name='RequestId'),
  uploadDetails?: [ 
    {
      completionTime?: string(name='CompletionTime'),
      creationTime?: string(name='CreationTime'),
      deviceModel?: string(name='DeviceModel'),
      fileSize?: long(name='FileSize'),
      mediaId?: string(name='MediaId'),
      modificationTime?: string(name='ModificationTime'),
      status?: string(name='Status'),
      title?: string(name='Title'),
      uploadIP?: string(name='UploadIP'),
      uploadRatio?: float(name='UploadRatio'),
      uploadSize?: long(name='UploadSize'),
      uploadSource?: string(name='UploadSource'),
      uploadStatus?: string(name='UploadStatus'),
    }
  ](name='UploadDetails'),
}

model GetUploadDetailsResponse = {
  headers: map[string]string(name='headers'),
  body: GetUploadDetailsResponseBody(name='body'),
}

async function getUploadDetails(request: GetUploadDetailsRequest): GetUploadDetailsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetUploadDetails', 'POST', '/', 'json', false, 'json', request);
}

model GetVideoInfoRequest {
  videoId: string(name='VideoId', position='Query'),
}

model GetVideoInfoResponseBody = {
  requestId?: string(name='RequestId'),
  video?: {
    appId?: string(name='AppId'),
    auditStatus?: string(name='AuditStatus'),
    cateId?: long(name='CateId'),
    cateName?: string(name='CateName'),
    coverURL?: string(name='CoverURL'),
    creationTime?: string(name='CreationTime'),
    customMediaInfo?: string(name='CustomMediaInfo'),
    description?: string(name='Description'),
    duration?: float(name='Duration'),
    modificationTime?: string(name='ModificationTime'),
    regionId?: string(name='RegionId'),
    size?: long(name='Size'),
    snapshots?: {
      snapshot?: [ string ](name='Snapshot')
    }(name='Snapshots'),
    status?: string(name='Status'),
    storageLocation?: string(name='StorageLocation'),
    tags?: string(name='Tags'),
    templateGroupId?: string(name='TemplateGroupId'),
    title?: string(name='Title'),
    videoId?: string(name='VideoId'),
  }(name='Video'),
}

model GetVideoInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetVideoInfoResponseBody(name='body'),
}

async function getVideoInfo(request: GetVideoInfoRequest): GetVideoInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetVideoInfo', 'POST', '/', 'json', false, 'json', request);
}

model GetVideoInfosRequest {
  videoIds: string(name='VideoIds', position='Query'),
}

model GetVideoInfosResponseBody = {
  nonExistVideoIds?: [ string ](name='NonExistVideoIds'),
  requestId?: string(name='RequestId'),
  videoList?: [ 
    {
      appId?: string(name='AppId'),
      cateId?: long(name='CateId'),
      cateName?: string(name='CateName'),
      coverURL?: string(name='CoverURL'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      duration?: float(name='Duration'),
      modificationTime?: string(name='ModificationTime'),
      size?: long(name='Size'),
      snapshots?: [ string ](name='Snapshots'),
      status?: string(name='Status'),
      storageLocation?: string(name='StorageLocation'),
      tags?: string(name='Tags'),
      templateGroupId?: string(name='TemplateGroupId'),
      title?: string(name='Title'),
      videoId?: string(name='VideoId'),
    }
  ](name='VideoList'),
}

model GetVideoInfosResponse = {
  headers: map[string]string(name='headers'),
  body: GetVideoInfosResponseBody(name='body'),
}

async function getVideoInfos(request: GetVideoInfosRequest): GetVideoInfosResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetVideoInfos', 'POST', '/', 'json', false, 'json', request);
}

model GetVideoListRequest {
  cateId?: long(name='CateId', position='Query'),
  endTime?: string(name='EndTime', position='Query'),
  pageNo?: int32(name='PageNo', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  sortBy?: string(name='SortBy', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
  status?: string(name='Status', position='Query'),
  storageLocation?: string(name='StorageLocation', position='Query'),
}

model GetVideoListResponseBody = {
  requestId?: string(name='RequestId'),
  total?: int32(name='Total'),
  videoList?: {
    video?: [ 
    {
      appId?: string(name='AppId'),
      cateId?: long(name='CateId'),
      cateName?: string(name='CateName'),
      coverURL?: string(name='CoverURL'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      duration?: float(name='Duration'),
      modificationTime?: string(name='ModificationTime'),
      size?: long(name='Size'),
      snapshots?: {
        snapshot?: [ string ](name='Snapshot')
      }(name='Snapshots'),
      status?: string(name='Status'),
      storageLocation?: string(name='StorageLocation'),
      tags?: string(name='Tags'),
      title?: string(name='Title'),
      videoId?: string(name='VideoId'),
    }
  ](name='Video')
  }(name='VideoList'),
}

model GetVideoListResponse = {
  headers: map[string]string(name='headers'),
  body: GetVideoListResponseBody(name='body'),
}

async function getVideoList(request: GetVideoListRequest): GetVideoListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetVideoList', 'POST', '/', 'json', false, 'json', request);
}

model GetVideoPlayAuthRequest {
  apiVersion?: string(name='ApiVersion', position='Query'),
  authInfoTimeout?: long(name='AuthInfoTimeout', position='Query'),
  videoId: string(name='VideoId', position='Query'),
}

model GetVideoPlayAuthResponseBody = {
  playAuth?: string(name='PlayAuth'),
  requestId?: string(name='RequestId'),
  videoMeta?: {
    coverURL?: string(name='CoverURL'),
    duration?: float(name='Duration'),
    status?: string(name='Status'),
    title?: string(name='Title'),
    videoId?: string(name='VideoId'),
  }(name='VideoMeta'),
}

model GetVideoPlayAuthResponse = {
  headers: map[string]string(name='headers'),
  body: GetVideoPlayAuthResponseBody(name='body'),
}

async function getVideoPlayAuth(request: GetVideoPlayAuthRequest): GetVideoPlayAuthResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetVideoPlayAuth', 'POST', '/', 'json', false, 'json', request);
}

model GetVodTemplateRequest {
  vodTemplateId: string(name='VodTemplateId', position='Query'),
}

model GetVodTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  vodTemplateInfo?: {
    creationTime?: string(name='CreationTime'),
    isDefault?: string(name='IsDefault'),
    modifyTime?: string(name='ModifyTime'),
    name?: string(name='Name'),
    templateConfig?: string(name='TemplateConfig'),
    templateType?: string(name='TemplateType'),
    vodTemplateId?: string(name='VodTemplateId'),
  }(name='VodTemplateInfo'),
}

model GetVodTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: GetVodTemplateResponseBody(name='body'),
}

async function getVodTemplate(request: GetVodTemplateRequest): GetVodTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetVodTemplate', 'POST', '/', 'json', false, 'json', request);
}

model GetWatermarkRequest {
  watermarkId: string(name='WatermarkId', position='Query'),
}

model GetWatermarkResponseBody = {
  requestId?: string(name='RequestId'),
  watermarkInfo?: {
    appId?: string(name='AppId'),
    creationTime?: string(name='CreationTime'),
    fileUrl?: string(name='FileUrl'),
    isDefault?: string(name='IsDefault'),
    name?: string(name='Name'),
    type?: string(name='Type'),
    watermarkConfig?: string(name='WatermarkConfig'),
    watermarkId?: string(name='WatermarkId'),
  }(name='WatermarkInfo'),
}

model GetWatermarkResponse = {
  headers: map[string]string(name='headers'),
  body: GetWatermarkResponseBody(name='body'),
}

async function getWatermark(request: GetWatermarkRequest): GetWatermarkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetWatermark', 'POST', '/', 'json', false, 'json', request);
}

model ListAIImageInfoRequest {
  videoId: string(name='VideoId', position='Query'),
}

model ListAIImageInfoResponseBody = {
  AIImageInfoList?: [ 
    {
      AIImageInfoId?: string(name='AIImageInfoId'),
      creationTime?: string(name='CreationTime'),
      fileURL?: string(name='FileURL'),
      format?: string(name='Format'),
      jobId?: string(name='JobId'),
      score?: string(name='Score'),
      version?: string(name='Version'),
      videoId?: string(name='VideoId'),
    }
  ](name='AIImageInfoList'),
  requestId?: string(name='RequestId'),
}

model ListAIImageInfoResponse = {
  headers: map[string]string(name='headers'),
  body: ListAIImageInfoResponseBody(name='body'),
}

async function listAIImageInfo(request: ListAIImageInfoRequest): ListAIImageInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListAIImageInfo', 'POST', '/', 'json', false, 'json', request);
}

model ListAIJobRequest {
  jobIds: string(name='JobIds', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: string(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: string(name='ResourceOwnerId', position='Query'),
}

model ListAIJobResponseBody = {
  AIJobList?: {
    AIJob?: [ 
    {
      code?: string(name='Code'),
      completeTime?: string(name='CompleteTime'),
      creationTime?: string(name='CreationTime'),
      data?: string(name='Data'),
      jobId?: string(name='JobId'),
      mediaId?: string(name='MediaId'),
      message?: string(name='Message'),
      status?: string(name='Status'),
      type?: string(name='Type'),
    }
  ](name='AIJob')
  }(name='AIJobList'),
  nonExistAIJobIds?: {
    string?: [ string ](name='String')
  }(name='NonExistAIJobIds'),
  requestId?: string(name='RequestId'),
}

model ListAIJobResponse = {
  headers: map[string]string(name='headers'),
  body: ListAIJobResponseBody(name='body'),
}

async function listAIJob(request: ListAIJobRequest): ListAIJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListAIJob', 'POST', '/', 'json', false, 'json', request);
}

model ListAITemplateRequest {
  templateType: string(name='TemplateType', position='Query'),
}

model ListAITemplateResponseBody = {
  requestId?: string(name='RequestId'),
  templateInfoList?: [ 
    {
      creationTime?: string(name='CreationTime'),
      isDefault?: string(name='IsDefault'),
      modifyTime?: string(name='ModifyTime'),
      source?: string(name='Source'),
      templateConfig?: string(name='TemplateConfig'),
      templateId?: string(name='TemplateId'),
      templateName?: string(name='TemplateName'),
      templateType?: string(name='TemplateType'),
    }
  ](name='TemplateInfoList'),
}

model ListAITemplateResponse = {
  headers: map[string]string(name='headers'),
  body: ListAITemplateResponseBody(name='body'),
}

async function listAITemplate(request: ListAITemplateRequest): ListAITemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListAITemplate', 'POST', '/', 'json', false, 'json', request);
}

model ListAppInfoRequest {
  pageNo?: int32(name='PageNo', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  status?: string(name='Status', position='Query'),
}

model ListAppInfoResponseBody = {
  appInfoList?: [ 
    {
      appId?: string(name='AppId'),
      appName?: string(name='AppName'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      modificationTime?: string(name='ModificationTime'),
      status?: string(name='Status'),
      type?: string(name='Type'),
    }
  ](name='AppInfoList'),
  requestId?: string(name='RequestId'),
  total?: int32(name='Total'),
}

model ListAppInfoResponse = {
  headers: map[string]string(name='headers'),
  body: ListAppInfoResponseBody(name='body'),
}

async function listAppInfo(request: ListAppInfoRequest): ListAppInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListAppInfo', 'POST', '/', 'json', false, 'json', request);
}

model ListAppPoliciesForIdentityRequest {
  appId?: string(name='AppId', position='Query'),
  identityName?: string(name='IdentityName', position='Query'),
  identityType?: string(name='IdentityType', position='Query'),
}

model ListAppPoliciesForIdentityResponseBody = {
  appPolicyList?: [ 
    {
      appId?: string(name='AppId'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      modificationTime?: string(name='ModificationTime'),
      policyName?: string(name='PolicyName'),
      policyType?: string(name='PolicyType'),
      policyValue?: string(name='PolicyValue'),
    }
  ](name='AppPolicyList'),
  requestId?: string(name='RequestId'),
}

model ListAppPoliciesForIdentityResponse = {
  headers: map[string]string(name='headers'),
  body: ListAppPoliciesForIdentityResponseBody(name='body'),
}

async function listAppPoliciesForIdentity(request: ListAppPoliciesForIdentityRequest): ListAppPoliciesForIdentityResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListAppPoliciesForIdentity', 'POST', '/', 'json', false, 'json', request);
}

model ListAuditSecurityIpRequest {
  securityGroupName?: string(name='SecurityGroupName', position='Query'),
}

model ListAuditSecurityIpResponseBody = {
  requestId?: string(name='RequestId'),
  securityIpList?: [ 
    {
      creationTime?: string(name='CreationTime'),
      ips?: string(name='Ips'),
      modificationTime?: string(name='ModificationTime'),
      securityGroupName?: string(name='SecurityGroupName'),
    }
  ](name='SecurityIpList'),
}

model ListAuditSecurityIpResponse = {
  headers: map[string]string(name='headers'),
  body: ListAuditSecurityIpResponseBody(name='body'),
}

async function listAuditSecurityIp(request: ListAuditSecurityIpRequest): ListAuditSecurityIpResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListAuditSecurityIp', 'POST', '/', 'json', false, 'json', request);
}

model ListDynamicImageRequest {
  videoId: string(name='VideoId', position='Query'),
}

model ListDynamicImageResponseBody = {
  dynamicImageList?: [ 
    {
      creationTime?: string(name='CreationTime'),
      duration?: string(name='Duration'),
      dynamicImageId?: string(name='DynamicImageId'),
      fileSize?: string(name='FileSize'),
      fileURL?: string(name='FileURL'),
      format?: string(name='Format'),
      fps?: string(name='Fps'),
      height?: string(name='Height'),
      jobId?: string(name='JobId'),
      videoId?: string(name='VideoId'),
      width?: string(name='Width'),
    }
  ](name='DynamicImageList'),
  requestId?: string(name='RequestId'),
}

model ListDynamicImageResponse = {
  headers: map[string]string(name='headers'),
  body: ListDynamicImageResponseBody(name='body'),
}

async function listDynamicImage(request: ListDynamicImageRequest): ListDynamicImageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListDynamicImage', 'POST', '/', 'json', false, 'json', request);
}

model ListLiveRecordVideoRequest {
  appName?: string(name='AppName', position='Query'),
  domainName?: string(name='DomainName', position='Query'),
  endTime?: string(name='EndTime', position='Query'),
  pageNo?: int32(name='PageNo', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  sortBy?: string(name='SortBy', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
  streamName?: string(name='StreamName', position='Query'),
}

model ListLiveRecordVideoResponseBody = {
  liveRecordVideoList?: {
    liveRecordVideo?: [ 
    {
      appName?: string(name='AppName'),
      domainName?: string(name='DomainName'),
      playlistId?: string(name='PlaylistId'),
      recordEndTime?: string(name='RecordEndTime'),
      recordStartTime?: string(name='RecordStartTime'),
      streamName?: string(name='StreamName'),
      video?: {
        cateId?: int32(name='CateId'),
        cateName?: string(name='CateName'),
        coverURL?: string(name='CoverURL'),
        creationTime?: string(name='CreationTime'),
        description?: string(name='Description'),
        duration?: float(name='Duration'),
        modifyTime?: string(name='ModifyTime'),
        size?: long(name='Size'),
        snapshots?: {
          snapshot?: [ string ](name='Snapshot')
        }(name='Snapshots'),
        status?: string(name='Status'),
        tags?: string(name='Tags'),
        templateGroupId?: string(name='TemplateGroupId'),
        title?: string(name='Title'),
        videoId?: string(name='VideoId'),
      }(name='Video'),
    }
  ](name='LiveRecordVideo')
  }(name='LiveRecordVideoList'),
  requestId?: string(name='RequestId'),
  total?: int32(name='Total'),
}

model ListLiveRecordVideoResponse = {
  headers: map[string]string(name='headers'),
  body: ListLiveRecordVideoResponseBody(name='body'),
}

async function listLiveRecordVideo(request: ListLiveRecordVideoRequest): ListLiveRecordVideoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListLiveRecordVideo', 'POST', '/', 'json', false, 'json', request);
}

model ListSnapshotsRequest {
  authTimeout?: string(name='AuthTimeout', position='Query'),
  pageNo?: string(name='PageNo', position='Query'),
  pageSize?: string(name='PageSize', position='Query'),
  snapshotType?: string(name='SnapshotType', position='Query'),
  videoId: string(name='VideoId', position='Query'),
}

model ListSnapshotsResponseBody = {
  mediaSnapshot?: {
    creationTime?: string(name='CreationTime'),
    jobId?: string(name='JobId'),
    regular?: string(name='Regular'),
    snapshots?: {
      snapshot?: [ 
      {
        index?: long(name='Index'),
        url?: string(name='Url'),
      }
    ](name='Snapshot')
    }(name='Snapshots'),
    total?: long(name='Total'),
  }(name='MediaSnapshot'),
  requestId?: string(name='RequestId'),
}

model ListSnapshotsResponse = {
  headers: map[string]string(name='headers'),
  body: ListSnapshotsResponseBody(name='body'),
}

async function listSnapshots(request: ListSnapshotsRequest): ListSnapshotsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListSnapshots', 'POST', '/', 'json', false, 'json', request);
}

model ListTranscodeTaskRequest {
  endTime?: string(name='EndTime', position='Query'),
  pageNo?: int32(name='PageNo', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
  videoId: string(name='VideoId', position='Query'),
}

model ListTranscodeTaskResponseBody = {
  requestId?: string(name='RequestId'),
  transcodeTaskList?: [ 
    {
      completeTime?: string(name='CompleteTime'),
      creationTime?: string(name='CreationTime'),
      taskStatus?: string(name='TaskStatus'),
      transcodeTaskId?: string(name='TranscodeTaskId'),
      transcodeTemplateGroupId?: string(name='TranscodeTemplateGroupId'),
      trigger?: string(name='Trigger'),
      videoId?: string(name='VideoId'),
    }
  ](name='TranscodeTaskList'),
}

model ListTranscodeTaskResponse = {
  headers: map[string]string(name='headers'),
  body: ListTranscodeTaskResponseBody(name='body'),
}

async function listTranscodeTask(request: ListTranscodeTaskRequest): ListTranscodeTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTranscodeTask', 'POST', '/', 'json', false, 'json', request);
}

model ListTranscodeTemplateGroupRequest {
  appId?: string(name='AppId', position='Query'),
}

model ListTranscodeTemplateGroupResponseBody = {
  requestId?: string(name='RequestId'),
  transcodeTemplateGroupList?: [ 
    {
      appId?: string(name='AppId'),
      creationTime?: string(name='CreationTime'),
      isDefault?: string(name='IsDefault'),
      locked?: string(name='Locked'),
      modifyTime?: string(name='ModifyTime'),
      name?: string(name='Name'),
      transcodeTemplateGroupId?: string(name='TranscodeTemplateGroupId'),
    }
  ](name='TranscodeTemplateGroupList'),
}

model ListTranscodeTemplateGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ListTranscodeTemplateGroupResponseBody(name='body'),
}

async function listTranscodeTemplateGroup(request: ListTranscodeTemplateGroupRequest): ListTranscodeTemplateGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTranscodeTemplateGroup', 'POST', '/', 'json', false, 'json', request);
}

model ListVodTemplateRequest {
  appId?: string(name='AppId', position='Query'),
  templateType: string(name='TemplateType', position='Query'),
}

model ListVodTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  vodTemplateInfoList?: [ 
    {
      appId?: string(name='AppId'),
      creationTime?: string(name='CreationTime'),
      isDefault?: string(name='IsDefault'),
      modifyTime?: string(name='ModifyTime'),
      name?: string(name='Name'),
      templateConfig?: string(name='TemplateConfig'),
      templateType?: string(name='TemplateType'),
      vodTemplateId?: string(name='VodTemplateId'),
    }
  ](name='VodTemplateInfoList'),
}

model ListVodTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: ListVodTemplateResponseBody(name='body'),
}

async function listVodTemplate(request: ListVodTemplateRequest): ListVodTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListVodTemplate', 'POST', '/', 'json', false, 'json', request);
}

model ListWatermarkRequest {
  appId?: string(name='AppId', position='Query'),
}

model ListWatermarkResponseBody = {
  requestId?: string(name='RequestId'),
  watermarkInfos?: [ 
    {
      appId?: string(name='AppId'),
      creationTime?: string(name='CreationTime'),
      fileUrl?: string(name='FileUrl'),
      isDefault?: string(name='IsDefault'),
      name?: string(name='Name'),
      type?: string(name='Type'),
      watermarkConfig?: string(name='WatermarkConfig'),
      watermarkId?: string(name='WatermarkId'),
    }
  ](name='WatermarkInfos'),
}

model ListWatermarkResponse = {
  headers: map[string]string(name='headers'),
  body: ListWatermarkResponseBody(name='body'),
}

async function listWatermark(request: ListWatermarkRequest): ListWatermarkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListWatermark', 'POST', '/', 'json', false, 'json', request);
}

model MoveAppResourceRequest {
  resourceIds: string(name='ResourceIds', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
  targetAppId: string(name='TargetAppId', position='Query'),
}

model MoveAppResourceResponseBody = {
  failedResourceIds?: [ string ](name='FailedResourceIds'),
  nonExistResourceIds?: [ string ](name='NonExistResourceIds'),
  requestId?: string(name='RequestId'),
}

model MoveAppResourceResponse = {
  headers: map[string]string(name='headers'),
  body: MoveAppResourceResponseBody(name='body'),
}

async function moveAppResource(request: MoveAppResourceRequest): MoveAppResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'MoveAppResource', 'POST', '/', 'json', false, 'json', request);
}

model PreloadVodObjectCachesRequest {
  objectPath: string(name='ObjectPath', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model PreloadVodObjectCachesResponseBody = {
  preloadTaskId?: string(name='PreloadTaskId'),
  requestId?: string(name='RequestId'),
}

model PreloadVodObjectCachesResponse = {
  headers: map[string]string(name='headers'),
  body: PreloadVodObjectCachesResponseBody(name='body'),
}

async function preloadVodObjectCaches(request: PreloadVodObjectCachesRequest): PreloadVodObjectCachesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PreloadVodObjectCaches', 'POST', '/', 'json', false, 'json', request);
}

model ProduceEditingProjectVideoRequest {
  coverURL?: string(name='CoverURL', position='Query'),
  description?: string(name='Description', position='Query'),
  mediaMetadata?: string(name='MediaMetadata', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  produceConfig?: string(name='ProduceConfig', position='Query'),
  projectId?: string(name='ProjectId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  timeline?: string(name='Timeline', position='Query'),
  title?: string(name='Title', position='Query'),
  userData?: string(name='UserData', position='Query'),
}

model ProduceEditingProjectVideoResponseBody = {
  mediaId?: string(name='MediaId'),
  projectId?: string(name='ProjectId'),
  requestId?: string(name='RequestId'),
}

model ProduceEditingProjectVideoResponse = {
  headers: map[string]string(name='headers'),
  body: ProduceEditingProjectVideoResponseBody(name='body'),
}

async function produceEditingProjectVideo(request: ProduceEditingProjectVideoRequest): ProduceEditingProjectVideoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ProduceEditingProjectVideo', 'POST', '/', 'json', false, 'json', request);
}

model RefreshMediaPlayUrlsRequest {
  definitions?: string(name='Definitions', description='播放流清晰度', position='Query'),
  formats?: string(name='Formats', description='播放流格式', position='Query'),
  mediaIds: string(name='MediaIds', description='媒资ID列表', position='Query'),
  resultType?: string(name='ResultType', description='结果类型：Single或Multiple', position='Query'),
  sliceCount?: int32(name='SliceCount', description='M3U8文件的ts链接数量', position='Query'),
  sliceFlag?: boolean(name='SliceFlag', description='M3U8文件是否获取ts链接', position='Query'),
  streamType?: string(name='StreamType', description='播放流类型：视频或音频', position='Query'),
  taskType: string(name='TaskType', description='Refresh: 刷新。Preload: 预热', position='Query'),
  userData?: string(name='UserData', description='回调设置', position='Query'),
}

model RefreshMediaPlayUrlsResponseBody = {
  forbiddenMediaIds?: string(name='ForbiddenMediaIds', description='没有多应用权限的视频ID'),
  mediaRefreshJobId?: string(name='MediaRefreshJobId', description='刷新预热任务ID'),
  nonExistMediaIds?: string(name='NonExistMediaIds', description='不存在的媒资ID'),
  requestId?: string(name='RequestId'),
}

model RefreshMediaPlayUrlsResponse = {
  headers: map[string]string(name='headers'),
  body: RefreshMediaPlayUrlsResponseBody(name='body'),
}

async function refreshMediaPlayUrls(request: RefreshMediaPlayUrlsRequest): RefreshMediaPlayUrlsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RefreshMediaPlayUrls', 'POST', '/', 'json', false, 'json', request);
}

model RefreshUploadVideoRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  videoId: string(name='VideoId', position='Query'),
}

model RefreshUploadVideoResponseBody = {
  requestId?: string(name='RequestId'),
  uploadAddress?: string(name='UploadAddress'),
  uploadAuth?: string(name='UploadAuth'),
  videoId?: string(name='VideoId'),
}

model RefreshUploadVideoResponse = {
  headers: map[string]string(name='headers'),
  body: RefreshUploadVideoResponseBody(name='body'),
}

async function refreshUploadVideo(request: RefreshUploadVideoRequest): RefreshUploadVideoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RefreshUploadVideo', 'POST', '/', 'json', false, 'json', request);
}

model RefreshVodObjectCachesRequest {
  objectPath: string(name='ObjectPath', position='Query'),
  objectType?: string(name='ObjectType', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model RefreshVodObjectCachesResponseBody = {
  refreshTaskId?: string(name='RefreshTaskId'),
  requestId?: string(name='RequestId'),
}

model RefreshVodObjectCachesResponse = {
  headers: map[string]string(name='headers'),
  body: RefreshVodObjectCachesResponseBody(name='body'),
}

async function refreshVodObjectCaches(request: RefreshVodObjectCachesRequest): RefreshVodObjectCachesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RefreshVodObjectCaches', 'POST', '/', 'json', false, 'json', request);
}

model RegisterMediaRequest {
  registerMetadatas: string(name='RegisterMetadatas', position='Query'),
  templateGroupId?: string(name='TemplateGroupId', position='Query'),
  userData?: string(name='UserData', position='Query'),
  workflowId?: string(name='WorkflowId', position='Query'),
}

model RegisterMediaResponseBody = {
  failedFileURLs?: [ string ](name='FailedFileURLs'),
  registeredMediaList?: [ 
    {
      fileURL?: string(name='FileURL'),
      mediaId?: string(name='MediaId'),
      newRegister?: boolean(name='NewRegister'),
    }
  ](name='RegisteredMediaList'),
  requestId?: string(name='RequestId'),
}

model RegisterMediaResponse = {
  headers: map[string]string(name='headers'),
  body: RegisterMediaResponseBody(name='body'),
}

async function registerMedia(request: RegisterMediaRequest): RegisterMediaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RegisterMedia', 'POST', '/', 'json', false, 'json', request);
}

model SearchEditingProjectRequest {
  endTime?: string(name='EndTime', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: string(name='OwnerId', position='Query'),
  pageNo?: int32(name='PageNo', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: string(name='ResourceOwnerId', position='Query'),
  sortBy?: string(name='SortBy', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
  status?: string(name='Status', position='Query'),
  title?: string(name='Title', position='Query'),
}

model SearchEditingProjectResponseBody = {
  projectList?: {
    project?: [ 
    {
      coverURL?: string(name='CoverURL'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      duration?: float(name='Duration'),
      modifiedTime?: string(name='ModifiedTime'),
      projectId?: string(name='ProjectId'),
      regionId?: string(name='RegionId'),
      status?: string(name='Status'),
      storageLocation?: string(name='StorageLocation'),
      title?: string(name='Title'),
    }
  ](name='Project')
  }(name='ProjectList'),
  requestId?: string(name='RequestId'),
  total?: int32(name='Total'),
}

model SearchEditingProjectResponse = {
  headers: map[string]string(name='headers'),
  body: SearchEditingProjectResponseBody(name='body'),
}

async function searchEditingProject(request: SearchEditingProjectRequest): SearchEditingProjectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SearchEditingProject', 'POST', '/', 'json', false, 'json', request);
}

model SearchMediaRequest {
  fields?: string(name='Fields', position='Query'),
  match?: string(name='Match', position='Query'),
  pageNo?: int32(name='PageNo', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  scrollToken?: string(name='ScrollToken', position='Query'),
  searchType?: string(name='SearchType', position='Query'),
  sortBy?: string(name='SortBy', position='Query'),
}

model SearchMediaResponseBody = {
  mediaList?: [ 
    {
      attachedMedia?: {
        appId?: string(name='AppId'),
        businessType?: string(name='BusinessType'),
        categories?: [ 
          {
            cateId?: long(name='CateId'),
            cateName?: string(name='CateName'),
            level?: long(name='Level'),
            parentId?: long(name='ParentId'),
          }
        ](name='Categories'),
        creationTime?: string(name='CreationTime'),
        description?: string(name='Description'),
        mediaId?: string(name='MediaId'),
        modificationTime?: string(name='ModificationTime'),
        status?: string(name='Status'),
        storageLocation?: string(name='StorageLocation'),
        tags?: string(name='Tags'),
        title?: string(name='Title'),
        URL?: string(name='URL'),
      }(name='AttachedMedia'),
      audio?: {
        appId?: string(name='AppId'),
        audioId?: string(name='AudioId'),
        cateId?: long(name='CateId'),
        cateName?: string(name='CateName'),
        coverURL?: string(name='CoverURL'),
        creationTime?: string(name='CreationTime'),
        description?: string(name='Description'),
        downloadSwitch?: string(name='DownloadSwitch'),
        duration?: float(name='Duration'),
        mediaSource?: string(name='MediaSource'),
        modificationTime?: string(name='ModificationTime'),
        preprocessStatus?: string(name='PreprocessStatus'),
        size?: long(name='Size'),
        snapshots?: [ string ](name='Snapshots'),
        spriteSnapshots?: [ string ](name='SpriteSnapshots'),
        status?: string(name='Status'),
        storageLocation?: string(name='StorageLocation'),
        tags?: string(name='Tags'),
        title?: string(name='Title'),
        transcodeMode?: string(name='TranscodeMode'),
      }(name='Audio'),
      creationTime?: string(name='CreationTime'),
      image?: {
        appId?: string(name='AppId'),
        cateId?: long(name='CateId'),
        cateName?: string(name='CateName'),
        creationTime?: string(name='CreationTime'),
        description?: string(name='Description'),
        imageId?: string(name='ImageId'),
        modificationTime?: string(name='ModificationTime'),
        status?: string(name='Status'),
        storageLocation?: string(name='StorageLocation'),
        tags?: string(name='Tags'),
        title?: string(name='Title'),
        URL?: string(name='URL'),
      }(name='Image'),
      mediaId?: string(name='MediaId'),
      mediaType?: string(name='MediaType'),
      video?: {
        appId?: string(name='AppId'),
        cateId?: long(name='CateId'),
        cateName?: string(name='CateName'),
        coverURL?: string(name='CoverURL'),
        creationTime?: string(name='CreationTime'),
        description?: string(name='Description'),
        downloadSwitch?: string(name='DownloadSwitch'),
        duration?: float(name='Duration'),
        mediaSource?: string(name='MediaSource'),
        modificationTime?: string(name='ModificationTime'),
        preprocessStatus?: string(name='PreprocessStatus'),
        size?: long(name='Size'),
        snapshots?: [ string ](name='Snapshots'),
        spriteSnapshots?: [ string ](name='SpriteSnapshots'),
        status?: string(name='Status'),
        storageLocation?: string(name='StorageLocation'),
        tags?: string(name='Tags'),
        title?: string(name='Title'),
        transcodeMode?: string(name='TranscodeMode'),
        videoId?: string(name='VideoId'),
      }(name='Video'),
    }
  ](name='MediaList'),
  requestId?: string(name='RequestId'),
  scrollToken?: string(name='ScrollToken'),
  total?: long(name='Total'),
}

model SearchMediaResponse = {
  headers: map[string]string(name='headers'),
  body: SearchMediaResponseBody(name='body'),
}

async function searchMedia(request: SearchMediaRequest): SearchMediaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SearchMedia', 'POST', '/', 'json', false, 'json', request);
}

model SetAuditSecurityIpRequest {
  ips: string(name='Ips', position='Query'),
  operateMode?: string(name='OperateMode', position='Query'),
  securityGroupName?: string(name='SecurityGroupName', position='Query'),
}

model SetAuditSecurityIpResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetAuditSecurityIpResponse = {
  headers: map[string]string(name='headers'),
  body: SetAuditSecurityIpResponseBody(name='body'),
}

async function setAuditSecurityIp(request: SetAuditSecurityIpRequest): SetAuditSecurityIpResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetAuditSecurityIp', 'POST', '/', 'json', false, 'json', request);
}

model SetCrossdomainContentRequest {
  content: string(name='Content', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: string(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: string(name='ResourceOwnerId', position='Query'),
  resourceRealOwnerId?: string(name='ResourceRealOwnerId', position='Query'),
  storageLocation: string(name='StorageLocation', position='Query'),
}

model SetCrossdomainContentResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetCrossdomainContentResponse = {
  headers: map[string]string(name='headers'),
  body: SetCrossdomainContentResponseBody(name='body'),
}

async function setCrossdomainContent(request: SetCrossdomainContentRequest): SetCrossdomainContentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetCrossdomainContent', 'POST', '/', 'json', false, 'json', request);
}

model SetDefaultAITemplateRequest {
  templateId: string(name='TemplateId', position='Query'),
}

model SetDefaultAITemplateResponseBody = {
  requestId?: string(name='RequestId'),
  templateId?: string(name='TemplateId'),
}

model SetDefaultAITemplateResponse = {
  headers: map[string]string(name='headers'),
  body: SetDefaultAITemplateResponseBody(name='body'),
}

async function setDefaultAITemplate(request: SetDefaultAITemplateRequest): SetDefaultAITemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetDefaultAITemplate', 'POST', '/', 'json', false, 'json', request);
}

model SetDefaultTranscodeTemplateGroupRequest {
  transcodeTemplateGroupId: string(name='TranscodeTemplateGroupId', position='Query'),
}

model SetDefaultTranscodeTemplateGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetDefaultTranscodeTemplateGroupResponse = {
  headers: map[string]string(name='headers'),
  body: SetDefaultTranscodeTemplateGroupResponseBody(name='body'),
}

async function setDefaultTranscodeTemplateGroup(request: SetDefaultTranscodeTemplateGroupRequest): SetDefaultTranscodeTemplateGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetDefaultTranscodeTemplateGroup', 'POST', '/', 'json', false, 'json', request);
}

model SetDefaultWatermarkRequest {
  watermarkId: string(name='WatermarkId', position='Query'),
}

model SetDefaultWatermarkResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetDefaultWatermarkResponse = {
  headers: map[string]string(name='headers'),
  body: SetDefaultWatermarkResponseBody(name='body'),
}

async function setDefaultWatermark(request: SetDefaultWatermarkRequest): SetDefaultWatermarkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetDefaultWatermark', 'POST', '/', 'json', false, 'json', request);
}

model SetEditingProjectMaterialsRequest {
  materialIds: string(name='MaterialIds', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: string(name='OwnerId', position='Query'),
  projectId: string(name='ProjectId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: string(name='ResourceOwnerId', position='Query'),
}

model SetEditingProjectMaterialsResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetEditingProjectMaterialsResponse = {
  headers: map[string]string(name='headers'),
  body: SetEditingProjectMaterialsResponseBody(name='body'),
}

async function setEditingProjectMaterials(request: SetEditingProjectMaterialsRequest): SetEditingProjectMaterialsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetEditingProjectMaterials', 'POST', '/', 'json', false, 'json', request);
}

model SetMessageCallbackRequest {
  appId?: string(name='AppId', position='Query'),
  authKey?: string(name='AuthKey', position='Query'),
  authSwitch?: string(name='AuthSwitch', position='Query'),
  callbackType?: string(name='CallbackType', position='Query'),
  callbackURL?: string(name='CallbackURL', position='Query'),
  eventTypeList?: string(name='EventTypeList', position='Query'),
  mnsEndpoint?: string(name='MnsEndpoint', position='Query'),
  mnsQueueName?: string(name='MnsQueueName', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
}

model SetMessageCallbackResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetMessageCallbackResponse = {
  headers: map[string]string(name='headers'),
  body: SetMessageCallbackResponseBody(name='body'),
}

async function setMessageCallback(request: SetMessageCallbackRequest): SetMessageCallbackResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetMessageCallback', 'POST', '/', 'json', false, 'json', request);
}

model SetVodDomainCertificateRequest {
  certName?: string(name='CertName', position='Query'),
  domainName: string(name='DomainName', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  SSLPri?: string(name='SSLPri', position='Query'),
  SSLProtocol: string(name='SSLProtocol', position='Query'),
  SSLPub?: string(name='SSLPub', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model SetVodDomainCertificateResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetVodDomainCertificateResponse = {
  headers: map[string]string(name='headers'),
  body: SetVodDomainCertificateResponseBody(name='body'),
}

async function setVodDomainCertificate(request: SetVodDomainCertificateRequest): SetVodDomainCertificateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetVodDomainCertificate', 'POST', '/', 'json', false, 'json', request);
}

model SubmitAIImageAuditJobRequest {
  mediaAuditConfiguration?: string(name='MediaAuditConfiguration', position='Query'),
  mediaId: string(name='MediaId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: string(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: string(name='ResourceOwnerId', position='Query'),
  templateId: string(name='TemplateId', position='Query'),
}

model SubmitAIImageAuditJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model SubmitAIImageAuditJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitAIImageAuditJobResponseBody(name='body'),
}

async function submitAIImageAuditJob(request: SubmitAIImageAuditJobRequest): SubmitAIImageAuditJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SubmitAIImageAuditJob', 'POST', '/', 'json', false, 'json', request);
}

model SubmitAIImageJobRequest {
  AIPipelineId?: string(name='AIPipelineId', position='Query'),
  AITemplateId: string(name='AITemplateId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: string(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: string(name='ResourceOwnerId', position='Query'),
  userData?: string(name='UserData', position='Query'),
  videoId: string(name='VideoId', position='Query'),
}

model SubmitAIImageJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model SubmitAIImageJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitAIImageJobResponseBody(name='body'),
}

async function submitAIImageJob(request: SubmitAIImageJobRequest): SubmitAIImageJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SubmitAIImageJob', 'POST', '/', 'json', false, 'json', request);
}

model SubmitAIJobRequest {
  config?: string(name='Config', position='Query'),
  mediaId?: string(name='MediaId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: string(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: string(name='ResourceOwnerId', position='Query'),
  types?: string(name='Types', position='Query'),
  userData?: string(name='UserData', position='Query'),
}

model SubmitAIJobResponseBody = {
  AIJobList?: {
    AIJob?: [ 
    {
      jobId?: string(name='JobId'),
      mediaId?: string(name='MediaId'),
      type?: string(name='Type'),
    }
  ](name='AIJob')
  }(name='AIJobList'),
  requestId?: string(name='RequestId'),
}

model SubmitAIJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitAIJobResponseBody(name='body'),
}

async function submitAIJob(request: SubmitAIJobRequest): SubmitAIJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SubmitAIJob', 'POST', '/', 'json', false, 'json', request);
}

model SubmitAIMediaAuditJobRequest {
  mediaAuditConfiguration?: string(name='MediaAuditConfiguration', position='Query'),
  mediaId: string(name='MediaId', position='Query'),
  mediaType?: string(name='MediaType', position='Query'),
  templateId?: string(name='TemplateId', position='Query'),
  userData?: string(name='UserData', position='Query'),
}

model SubmitAIMediaAuditJobResponseBody = {
  jobId?: string(name='JobId'),
  mediaId?: string(name='MediaId'),
  requestId?: string(name='RequestId'),
}

model SubmitAIMediaAuditJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitAIMediaAuditJobResponseBody(name='body'),
}

async function submitAIMediaAuditJob(request: SubmitAIMediaAuditJobRequest): SubmitAIMediaAuditJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SubmitAIMediaAuditJob', 'POST', '/', 'json', false, 'json', request);
}

model SubmitDynamicImageJobRequest {
  dynamicImageTemplateId: string(name='DynamicImageTemplateId', position='Query'),
  overrideParams?: string(name='OverrideParams', position='Query'),
  videoId: string(name='VideoId', position='Query'),
}

model SubmitDynamicImageJobResponseBody = {
  dynamicImageJob?: {
    jobId?: string(name='JobId'),
  }(name='DynamicImageJob'),
  requestId?: string(name='RequestId'),
}

model SubmitDynamicImageJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitDynamicImageJobResponseBody(name='body'),
}

async function submitDynamicImageJob(request: SubmitDynamicImageJobRequest): SubmitDynamicImageJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SubmitDynamicImageJob', 'POST', '/', 'json', false, 'json', request);
}

model SubmitMediaDNADeleteJobRequest {
  mediaId: string(name='MediaId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: string(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: string(name='ResourceOwnerId', position='Query'),
}

model SubmitMediaDNADeleteJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model SubmitMediaDNADeleteJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitMediaDNADeleteJobResponseBody(name='body'),
}

async function submitMediaDNADeleteJob(request: SubmitMediaDNADeleteJobRequest): SubmitMediaDNADeleteJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SubmitMediaDNADeleteJob', 'POST', '/', 'json', false, 'json', request);
}

model SubmitPreprocessJobsRequest {
  preprocessType: string(name='PreprocessType', position='Query'),
  videoId: string(name='VideoId', position='Query'),
}

model SubmitPreprocessJobsResponseBody = {
  preprocessJobs?: {
    preprocessJob?: [ 
    {
      jobId?: string(name='JobId'),
    }
  ](name='PreprocessJob')
  }(name='PreprocessJobs'),
  requestId?: string(name='RequestId'),
}

model SubmitPreprocessJobsResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitPreprocessJobsResponseBody(name='body'),
}

async function submitPreprocessJobs(request: SubmitPreprocessJobsRequest): SubmitPreprocessJobsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SubmitPreprocessJobs', 'POST', '/', 'json', false, 'json', request);
}

model SubmitSnapshotJobRequest {
  count?: long(name='Count', position='Query'),
  height?: string(name='Height', position='Query'),
  interval?: long(name='Interval', position='Query'),
  snapshotTemplateId?: string(name='SnapshotTemplateId', position='Query'),
  specifiedOffsetTime?: long(name='SpecifiedOffsetTime', position='Query'),
  spriteSnapshotConfig?: string(name='SpriteSnapshotConfig', position='Query'),
  userData?: string(name='UserData', position='Query'),
  videoId?: string(name='VideoId', position='Query'),
  width?: string(name='Width', position='Query'),
}

model SubmitSnapshotJobResponseBody = {
  requestId?: string(name='RequestId'),
  snapshotJob?: {
    jobId?: string(name='JobId'),
  }(name='SnapshotJob'),
}

model SubmitSnapshotJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitSnapshotJobResponseBody(name='body'),
}

async function submitSnapshotJob(request: SubmitSnapshotJobRequest): SubmitSnapshotJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SubmitSnapshotJob', 'POST', '/', 'json', false, 'json', request);
}

model SubmitTranscodeJobsRequest {
  encryptConfig?: string(name='EncryptConfig', position='Query'),
  overrideParams?: string(name='OverrideParams', position='Query'),
  pipelineId?: string(name='PipelineId', position='Query'),
  priority?: string(name='Priority', position='Query'),
  templateGroupId: string(name='TemplateGroupId', position='Query'),
  userData?: string(name='UserData', position='Query'),
  videoId?: string(name='VideoId', position='Query'),
}

model SubmitTranscodeJobsResponseBody = {
  requestId?: string(name='RequestId'),
  transcodeJobs?: {
    transcodeJob?: [ 
    {
      jobId?: string(name='JobId'),
    }
  ](name='TranscodeJob')
  }(name='TranscodeJobs'),
  transcodeTaskId?: string(name='TranscodeTaskId'),
}

model SubmitTranscodeJobsResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitTranscodeJobsResponseBody(name='body'),
}

async function submitTranscodeJobs(request: SubmitTranscodeJobsRequest): SubmitTranscodeJobsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SubmitTranscodeJobs', 'POST', '/', 'json', false, 'json', request);
}

model SubmitWorkflowJobRequest {
  mediaId?: string(name='MediaId', position='Query'),
  workflowId: string(name='WorkflowId', position='Query'),
}

model SubmitWorkflowJobResponseBody = {
  requestId?: string(name='RequestId'),
}

model SubmitWorkflowJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitWorkflowJobResponseBody(name='body'),
}

async function submitWorkflowJob(request: SubmitWorkflowJobRequest): SubmitWorkflowJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SubmitWorkflowJob', 'POST', '/', 'json', false, 'json', request);
}

model UpdateAITemplateRequest {
  templateConfig: string(name='TemplateConfig', position='Query'),
  templateId: string(name='TemplateId', position='Query'),
  templateName: string(name='TemplateName', position='Query'),
}

model UpdateAITemplateResponseBody = {
  requestId?: string(name='RequestId'),
  templateId?: string(name='TemplateId'),
}

model UpdateAITemplateResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAITemplateResponseBody(name='body'),
}

async function updateAITemplate(request: UpdateAITemplateRequest): UpdateAITemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateAITemplate', 'POST', '/', 'json', false, 'json', request);
}

model UpdateAppInfoRequest {
  appId: string(name='AppId', position='Query'),
  appName?: string(name='AppName', position='Query'),
  description?: string(name='Description', position='Query'),
  status?: string(name='Status', position='Query'),
}

model UpdateAppInfoResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateAppInfoResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAppInfoResponseBody(name='body'),
}

async function updateAppInfo(request: UpdateAppInfoRequest): UpdateAppInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateAppInfo', 'POST', '/', 'json', false, 'json', request);
}

model UpdateAttachedMediaInfosRequest {
  updateContent: string(name='UpdateContent', position='Query'),
}

model UpdateAttachedMediaInfosResponseBody = {
  nonExistMediaIds?: [ string ](name='NonExistMediaIds'),
  requestId?: string(name='RequestId'),
}

model UpdateAttachedMediaInfosResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAttachedMediaInfosResponseBody(name='body'),
}

async function updateAttachedMediaInfos(request: UpdateAttachedMediaInfosRequest): UpdateAttachedMediaInfosResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateAttachedMediaInfos', 'POST', '/', 'json', false, 'json', request);
}

model UpdateCategoryRequest {
  cateId: long(name='CateId', position='Query'),
  cateName: string(name='CateName', position='Query'),
}

model UpdateCategoryResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateCategoryResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateCategoryResponseBody(name='body'),
}

async function updateCategory(request: UpdateCategoryRequest): UpdateCategoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateCategory', 'POST', '/', 'json', false, 'json', request);
}

model UpdateEditingProjectRequest {
  coverURL?: string(name='CoverURL', position='Query'),
  description?: string(name='Description', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: string(name='OwnerId', position='Query'),
  projectId: string(name='ProjectId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: string(name='ResourceOwnerId', position='Query'),
  timeline?: string(name='Timeline', position='Query'),
  title?: string(name='Title', position='Query'),
}

model UpdateEditingProjectResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateEditingProjectResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateEditingProjectResponseBody(name='body'),
}

async function updateEditingProject(request: UpdateEditingProjectRequest): UpdateEditingProjectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateEditingProject', 'POST', '/', 'json', false, 'json', request);
}

model UpdateImageInfosRequest {
  updateContent: string(name='UpdateContent', position='Query'),
}

model UpdateImageInfosResponseBody = {
  nonExistImageIds?: {
    imageId?: [ string ](name='ImageId')
  }(name='NonExistImageIds'),
  requestId?: string(name='RequestId'),
}

model UpdateImageInfosResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateImageInfosResponseBody(name='body'),
}

async function updateImageInfos(request: UpdateImageInfosRequest): UpdateImageInfosResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateImageInfos', 'POST', '/', 'json', false, 'json', request);
}

model UpdateTranscodeTemplateGroupRequest {
  locked?: string(name='Locked', position='Query'),
  name?: string(name='Name', position='Query'),
  transcodeTemplateGroupId: string(name='TranscodeTemplateGroupId', position='Query'),
  transcodeTemplateList?: string(name='TranscodeTemplateList', position='Query'),
}

model UpdateTranscodeTemplateGroupResponseBody = {
  requestId?: string(name='RequestId'),
  transcodeTemplateGroupId?: string(name='TranscodeTemplateGroupId'),
}

model UpdateTranscodeTemplateGroupResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateTranscodeTemplateGroupResponseBody(name='body'),
}

async function updateTranscodeTemplateGroup(request: UpdateTranscodeTemplateGroupRequest): UpdateTranscodeTemplateGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateTranscodeTemplateGroup', 'POST', '/', 'json', false, 'json', request);
}

model UpdateVideoInfoRequest {
  cateId?: long(name='CateId', position='Query'),
  coverURL?: string(name='CoverURL', position='Query'),
  description?: string(name='Description', position='Query'),
  tags?: string(name='Tags', position='Query'),
  title?: string(name='Title', position='Query'),
  videoId: string(name='VideoId', position='Query'),
}

model UpdateVideoInfoResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateVideoInfoResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateVideoInfoResponseBody(name='body'),
}

async function updateVideoInfo(request: UpdateVideoInfoRequest): UpdateVideoInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateVideoInfo', 'POST', '/', 'json', false, 'json', request);
}

model UpdateVideoInfosRequest {
  updateContent: string(name='UpdateContent', position='Query'),
}

model UpdateVideoInfosResponseBody = {
  forbiddenVideoIds?: [ string ](name='ForbiddenVideoIds'),
  nonExistVideoIds?: [ string ](name='NonExistVideoIds'),
  requestId?: string(name='RequestId'),
}

model UpdateVideoInfosResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateVideoInfosResponseBody(name='body'),
}

async function updateVideoInfos(request: UpdateVideoInfosRequest): UpdateVideoInfosResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateVideoInfos', 'POST', '/', 'json', false, 'json', request);
}

model UpdateVodDomainRequest {
  domainName: string(name='DomainName', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  sources?: string(name='Sources', position='Query'),
  topLevelDomain?: string(name='TopLevelDomain', position='Query'),
}

model UpdateVodDomainResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateVodDomainResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateVodDomainResponseBody(name='body'),
}

async function updateVodDomain(request: UpdateVodDomainRequest): UpdateVodDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateVodDomain', 'POST', '/', 'json', false, 'json', request);
}

model UpdateVodTemplateRequest {
  name?: string(name='Name', position='Query'),
  templateConfig?: string(name='TemplateConfig', position='Query'),
  vodTemplateId: string(name='VodTemplateId', position='Query'),
}

model UpdateVodTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  vodTemplateId?: string(name='VodTemplateId'),
}

model UpdateVodTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateVodTemplateResponseBody(name='body'),
}

async function updateVodTemplate(request: UpdateVodTemplateRequest): UpdateVodTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateVodTemplate', 'POST', '/', 'json', false, 'json', request);
}

model UpdateWatermarkRequest {
  name?: string(name='Name', position='Query'),
  watermarkConfig: string(name='WatermarkConfig', position='Query'),
  watermarkId: string(name='WatermarkId', position='Query'),
}

model UpdateWatermarkResponseBody = {
  requestId?: string(name='RequestId'),
  watermarkInfo?: {
    creationTime?: string(name='CreationTime'),
    fileUrl?: string(name='FileUrl'),
    isDefault?: string(name='IsDefault'),
    name?: string(name='Name'),
    type?: string(name='Type'),
    watermarkConfig?: string(name='WatermarkConfig'),
    watermarkId?: string(name='WatermarkId'),
  }(name='WatermarkInfo'),
}

model UpdateWatermarkResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateWatermarkResponseBody(name='body'),
}

async function updateWatermark(request: UpdateWatermarkRequest): UpdateWatermarkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateWatermark', 'POST', '/', 'json', false, 'json', request);
}

model UploadMediaByURLRequest {
  appId?: string(name='AppId', position='Query'),
  storageLocation?: string(name='StorageLocation', position='Query'),
  templateGroupId?: string(name='TemplateGroupId', position='Query'),
  uploadMetadatas?: string(name='UploadMetadatas', position='Query'),
  uploadURLs: string(name='UploadURLs', position='Query'),
  userData?: string(name='UserData', position='Query'),
  workflowId?: string(name='WorkflowId', position='Query'),
}

model UploadMediaByURLResponseBody = {
  requestId?: string(name='RequestId'),
  uploadJobs?: [ 
    {
      jobId?: string(name='JobId'),
      sourceURL?: string(name='SourceURL'),
    }
  ](name='UploadJobs'),
}

model UploadMediaByURLResponse = {
  headers: map[string]string(name='headers'),
  body: UploadMediaByURLResponseBody(name='body'),
}

async function uploadMediaByURL(request: UploadMediaByURLRequest): UploadMediaByURLResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UploadMediaByURL', 'POST', '/', 'json', false, 'json', request);
}

model UploadStreamByURLRequest {
  definition: string(name='Definition', position='Query'),
  fileExtension?: string(name='FileExtension', position='Query'),
  HDRType?: string(name='HDRType', description='视频流HDR类型', position='Query'),
  mediaId: string(name='MediaId', position='Query'),
  streamURL: string(name='StreamURL', position='Query'),
  userData?: string(name='UserData', position='Query'),
}

model UploadStreamByURLResponseBody = {
  fileURL?: string(name='FileURL'),
  requestId?: string(name='RequestId'),
  sourceURL?: string(name='SourceURL'),
  streamJobId?: string(name='StreamJobId'),
}

model UploadStreamByURLResponse = {
  headers: map[string]string(name='headers'),
  body: UploadStreamByURLResponseBody(name='body'),
}

async function uploadStreamByURL(request: UploadStreamByURLRequest): UploadStreamByURLResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UploadStreamByURL', 'POST', '/', 'json', false, 'json', request);
}

model VerifyVodDomainOwnerRequest {
  domainName: string(name='DomainName', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  verifyType: string(name='VerifyType', position='Query'),
}

model VerifyVodDomainOwnerResponseBody = {
  content?: string(name='Content'),
  requestId?: string(name='RequestId'),
}

model VerifyVodDomainOwnerResponse = {
  headers: map[string]string(name='headers'),
  body: VerifyVodDomainOwnerResponseBody(name='body'),
}

async function verifyVodDomainOwner(request: VerifyVodDomainOwnerRequest): VerifyVodDomainOwnerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'VerifyVodDomainOwner', 'POST', '/', 'json', false, 'json', request);
}

