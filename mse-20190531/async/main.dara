/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'mse';
  @version = '2019-05-31';
  @endpointRule = 'regional';
  @endpointMap = {
  };
}

function close(): void {
  @handler.close();
}

model GatewayDomain {
  certIdentifier?: string(name='CertIdentifier', description='使用的证书Id'),
  gatewayId?: long(name='GatewayId', description='网关ID'),
  gatewayName?: string(name='GatewayName', description='网关名称'),
  gatewayUniqueId?: string(name='GatewayUniqueId', description='网关唯一标识'),
  gmtCreate?: string(name='GmtCreate', description='创建时间'),
  gmtModified?: string(name='GmtModified', description='修改时间'),
  id?: long(name='Id', description='Domain Id'),
  mustHttps?: string(name='MustHttps', description='是否强制跳转'),
  name?: string(name='Name', description='Domain Name'),
  protocol?: string(name='Protocol', description='domainn的协议'),
}

model GatewayOption {
  disableHttp2Alpn?: boolean(name='DisableHttp2Alpn', description='是否禁用http'),
  enableHardwareAcceleration?: boolean(name='EnableHardwareAcceleration', description='是否开启硬件加速'),
  enableWaf?: boolean(name='EnableWaf', description='是否开启waf'),
  logConfigDetails?: {
    logEnabled: boolean(name='LogEnabled', description='是否开启日志投递'),
    logStoreName?: string(name='LogStoreName', description='投递的目标logstore'),
    projectName?: string(name='ProjectName', description='投递的目标project'),
  }(name='LogConfigDetails', description='日志配置详情'),
  traceDetails?: {
    sample?: long(name='Sample', description='trace 采样率'),
    traceEnabled: boolean(name='TraceEnabled', description='trace是否开启'),
  }(name='TraceDetails', description='xtrace config option'),
}

model GatewayService {
  gatewayTrafficPolicy?: TrafficPolicy(name='GatewayTrafficPolicy', description='服务的策略'),
  gatewayUniqueId?: string(name='GatewayUniqueId', description='网关uniqueId'),
  groupName?: string(name='GroupName', description='服务所属group'),
  id?: long(name='Id', description='服务id'),
  metaInfo?: string(name='MetaInfo', description='元信息'),
  name?: string(name='Name', description='服务名'),
  namespace?: string(name='Namespace', description='服务所属namesapce'),
  sourceType?: string(name='SourceType', description='服务来源'),
}

model TrafficPolicy {
  loadBalancerSettings?: {
    consistentHashLBConfig?: {
      consistentHashLBType?: string(name='ConsistentHashLBType', description='HEADER, COOKIE, SOURCE_IP, QUERY_PARAMETER'),
      httpCookie?: {
        name?: string(name='Name', description='cookie名'),
        path?: string(name='Path', description='cookie path'),
        TTL?: string(name='TTL', description='cookie生命周期'),
      }(name='HttpCookie', description='使用cookie时配置'),
      parameterName?: string(name='ParameterName', description='使用根据header和参数路由时生效'),
    }(name='ConsistentHashLBConfig', description='一致性hash相关配置'),
    loadbalancerType?: string(name='LoadbalancerType', description='负载均衡类型，枚举类可为ROUND_ROBIN, LEAST_CONN,RANDOM, CONSISTENT_HASH'),
    warmupDuration?: long(name='WarmupDuration', description='预热时间(单位/s)'),
  }(name='LoadBalancerSettings', description='负载均衡相关配置'),
  tlsSetting?: {
    caCertContent?: string(name='CaCertContent', description='ca证书内容'),
    certId?: string(name='CertId', description='使用的证书id，仅当为mutual时需要填写'),
    sni?: string(name='Sni', description='到后端服务些带'),
    tlsMode: string(name='TlsMode', description='tls模式。为枚举类，可为NONE, SIMPLE, MUITUAL'),
  }(name='TlsSetting', description='tls相关配置'),
}

model AddAuthResourceRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  authId?: long(name='AuthId', position='Query'),
  domainId?: long(name='DomainId', position='Query'),
  gatewayUniqueId?: string(name='GatewayUniqueId', position='Query'),
  matchType?: string(name='MatchType', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  path?: string(name='Path', position='Query'),
}

model AddAuthResourceResponseBody = {
  code?: int32(name='Code'),
  data?: long(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model AddAuthResourceResponse = {
  headers: map[string]string(name='headers'),
  body: AddAuthResourceResponseBody(name='body'),
}

async function addAuthResource(request: AddAuthResourceRequest): AddAuthResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddAuthResource', 'POST', '/', 'json', false, 'json', request);
}

model AddBlackWhiteListRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  content?: string(name='Content', position='Query'),
  gatewayUniqueId?: string(name='GatewayUniqueId', position='Query'),
  isWhite?: boolean(name='IsWhite', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  name?: string(name='Name', position='Query'),
  note?: string(name='Note', position='Query'),
  resourceIdJsonList?: string(name='ResourceIdJsonList', position='Query'),
  resourceType?: string(name='ResourceType', position='Query'),
  status?: string(name='Status', position='Query'),
  type?: string(name='Type', position='Query'),
}

model AddBlackWhiteListResponseBody = {
  code?: int32(name='Code'),
  data?: long(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model AddBlackWhiteListResponse = {
  headers: map[string]string(name='headers'),
  body: AddBlackWhiteListResponseBody(name='body'),
}

async function addBlackWhiteList(request: AddBlackWhiteListRequest): AddBlackWhiteListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddBlackWhiteList', 'POST', '/', 'json', false, 'json', request);
}

model AddGatewayRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  enableHardwareAcceleration?: boolean(name='EnableHardwareAcceleration', description='是否开启硬件加速', position='Query'),
  enableSls?: boolean(name='EnableSls', description='是否开启SLS日志投递', position='Query'),
  enableXtrace?: boolean(name='EnableXtrace', description='是否开启xtrace', position='Query'),
  enterpriseSecurityGroup?: boolean(name='EnterpriseSecurityGroup', description='是否企业安全组类型', position='Query'),
  internetSlbSpec?: string(name='InternetSlbSpec', description='外网SLB规格', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  name?: string(name='Name', description='网关名称', position='Query'),
  region: string(name='Region', description='地域', position='Query'),
  replica: int32(name='Replica', description='节点数量', position='Query'),
  slbSpec?: string(name='SlbSpec', description='内网SLB规格', position='Query'),
  spec: string(name='Spec', description='节点规格', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key', description='标签键'),
      value?: string(name='Value', description='标签值'),
    }
  ](name='Tag', description='标签列表，最多包含20个子项', position='Query'),
  vSwitchId: string(name='VSwitchId', description='主交换机ID', position='Query'),
  vSwitchId2?: string(name='VSwitchId2', description='备交换机ID', position='Query'),
  vpc: string(name='Vpc', description='专有网络ID', position='Query'),
  xtraceRatio?: string(name='XtraceRatio', description='xtrace采样率，取值[0,100]', position='Query'),
}

model AddGatewayResponseBody = {
  code?: int32(name='Code'),
  data?: {
    gatewayUniqueId?: string(name='GatewayUniqueId'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model AddGatewayResponse = {
  headers: map[string]string(name='headers'),
  body: AddGatewayResponseBody(name='body'),
}

async function addGateway(request: AddGatewayRequest): AddGatewayResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddGateway', 'POST', '/', 'json', false, 'json', request);
}

model AddGatewayDomainRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  certIdentifier?: string(name='CertIdentifier', position='Query'),
  gatewayUniqueId?: string(name='GatewayUniqueId', position='Query'),
  http2?: string(name='Http2', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  mustHttps?: boolean(name='MustHttps', position='Query'),
  name?: string(name='Name', position='Query'),
  protocol?: string(name='Protocol', position='Query'),
  tlsMax?: string(name='TlsMax', position='Query'),
  tlsMin?: string(name='TlsMin', position='Query'),
}

model AddGatewayDomainResponseBody = {
  code?: int32(name='Code'),
  data?: long(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model AddGatewayDomainResponse = {
  headers: map[string]string(name='headers'),
  body: AddGatewayDomainResponseBody(name='body'),
}

async function addGatewayDomain(request: AddGatewayDomainRequest): AddGatewayDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddGatewayDomain', 'POST', '/', 'json', false, 'json', request);
}

model AddGatewayRouteRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  destinationType?: string(name='DestinationType', position='Query'),
  directResponseJSON?: {
    body?: string(name='Body'),
    code?: long(name='Code'),
  }(name='DirectResponseJSON', shrink='json', position='Query'),
  domainId?: long(name='DomainId', position='Query'),
  domainIdListJSON?: string(name='DomainIdListJSON', position='Query'),
  enableWaf?: boolean(name='EnableWaf', position='Query'),
  fallback?: boolean(name='Fallback', position='Query'),
  fallbackServices?: [ 
    {
      agreementType?: string(name='AgreementType'),
      groupName?: string(name='GroupName'),
      name?: string(name='Name'),
      namespace?: string(name='Namespace'),
      percent?: int32(name='Percent'),
      serviceId?: long(name='ServiceId'),
      servicePort?: int32(name='ServicePort'),
      sourceType?: string(name='SourceType'),
      version?: string(name='Version'),
    }
  ](name='FallbackServices', shrink='json', position='Query'),
  gatewayId?: long(name='GatewayId', position='Query'),
  gatewayUniqueId?: string(name='GatewayUniqueId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  name?: string(name='Name', position='Query'),
  predicates?: {
    headerPredicates?: [ 
      {
        key?: string(name='Key'),
        type?: string(name='Type'),
        value?: string(name='Value'),
      }
    ](name='HeaderPredicates'),
    methodPredicates?: [ string ](name='MethodPredicates'),
    pathPredicates?: {
      ignoreCase?: boolean(name='IgnoreCase'),
      path?: string(name='Path'),
      type?: string(name='Type'),
    }(name='PathPredicates'),
    queryPredicates?: [ 
      {
        key?: string(name='Key'),
        type?: string(name='Type'),
        value?: string(name='Value'),
      }
    ](name='QueryPredicates'),
  }(name='Predicates', shrink='json', position='Query'),
  redirectJSON?: {
    code?: int32(name='Code'),
    host?: string(name='Host'),
    path?: string(name='Path'),
  }(name='RedirectJSON', shrink='json', position='Query'),
  routeOrder?: int32(name='RouteOrder', position='Query'),
  services?: [ 
    {
      agreementType?: string(name='AgreementType'),
      groupName?: string(name='GroupName'),
      httpDubboTranscoder?: {
        dubboServiceGroup?: string(name='DubboServiceGroup'),
        dubboServiceName?: string(name='DubboServiceName'),
        dubboServiceVersion?: string(name='DubboServiceVersion'),
        mothedMapList?: [ 
          {
            dubboMothedName?: string(name='DubboMothedName'),
            httpMothed?: string(name='HttpMothed'),
            mothedpath?: string(name='Mothedpath'),
            paramMapsList?: [ 
              {
                extractKey?: string(name='ExtractKey'),
                extractKeySpec?: string(name='ExtractKeySpec'),
                mappingType?: string(name='MappingType'),
              }
            ](name='ParamMapsList'),
            passThroughAllHeaders?: string(name='PassThroughAllHeaders'),
            passThroughList?: [ string ](name='PassThroughList'),
          }
        ](name='MothedMapList'),
      }(name='HttpDubboTranscoder'),
      name?: string(name='Name'),
      namespace?: string(name='Namespace'),
      percent?: int32(name='Percent'),
      serviceId?: long(name='ServiceId'),
      servicePort?: int32(name='ServicePort'),
      sourceType?: string(name='SourceType'),
      version?: string(name='Version'),
    }
  ](name='Services', shrink='json', position='Query'),
}

model AddGatewayRouteResponseBody = {
  code?: int32(name='Code'),
  data?: long(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model AddGatewayRouteResponse = {
  headers: map[string]string(name='headers'),
  body: AddGatewayRouteResponseBody(name='body'),
}

async function addGatewayRoute(request: AddGatewayRouteRequest): AddGatewayRouteResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddGatewayRoute', 'POST', '/', 'json', false, 'json', request);
}

model AddGatewayServiceVersionRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  gatewayUniqueId?: string(name='GatewayUniqueId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  serviceId?: long(name='ServiceId', position='Query'),
  serviceVersion?: string(name='ServiceVersion', position='Query'),
}

model AddGatewayServiceVersionResponseBody = {
  code?: int32(name='Code'),
  data?: long(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model AddGatewayServiceVersionResponse = {
  headers: map[string]string(name='headers'),
  body: AddGatewayServiceVersionResponseBody(name='body'),
}

async function addGatewayServiceVersion(request: AddGatewayServiceVersionRequest): AddGatewayServiceVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddGatewayServiceVersion', 'POST', '/', 'json', false, 'json', request);
}

model AddGatewaySlbRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  gatewayUniqueId: string(name='GatewayUniqueId', position='Query'),
  httpPort?: int32(name='HttpPort', position='Query'),
  httpsPort?: int32(name='HttpsPort', position='Query'),
  httpsVServerGroupId?: string(name='HttpsVServerGroupId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  serviceWeight?: int32(name='ServiceWeight', position='Query'),
  slbId: string(name='SlbId', position='Query'),
  type?: string(name='Type', position='Query'),
  vServerGroupId?: string(name='VServerGroupId', position='Query'),
}

model AddGatewaySlbResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model AddGatewaySlbResponse = {
  headers: map[string]string(name='headers'),
  body: AddGatewaySlbResponseBody(name='body'),
}

async function addGatewaySlb(request: AddGatewaySlbRequest): AddGatewaySlbResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddGatewaySlb', 'POST', '/', 'json', false, 'json', request);
}

model AddMockRuleRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  consumerAppIds: string(name='ConsumerAppIds', position='Query'),
  dubboMockItems: string(name='DubboMockItems', position='Query'),
  enable?: boolean(name='Enable', position='Query'),
  extraJson: string(name='ExtraJson', position='Query'),
  mockType?: long(name='MockType', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  name: string(name='Name', position='Query'),
  providerAppId?: string(name='ProviderAppId', position='Query'),
  providerAppName?: string(name='ProviderAppName', position='Query'),
  region: string(name='Region', position='Query'),
  scMockItems: string(name='ScMockItems', position='Query'),
  source: string(name='Source', position='Query'),
}

model AddMockRuleResponseBody = {
  code?: int32(name='Code'),
  data?: {
    accountId?: string(name='AccountId'),
    consumerAppId?: string(name='ConsumerAppId'),
    consumerAppName?: string(name='ConsumerAppName'),
    enable?: boolean(name='Enable'),
    extraJson?: string(name='ExtraJson'),
    id?: long(name='Id'),
    mockType?: long(name='MockType'),
    name?: string(name='Name'),
    namespaceId?: string(name='NamespaceId'),
    providerAppId?: string(name='ProviderAppId'),
    providerAppName?: string(name='ProviderAppName'),
    region?: string(name='Region'),
    scMockItemJson?: string(name='ScMockItemJson'),
    source?: string(name='Source'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AddMockRuleResponse = {
  headers: map[string]string(name='headers'),
  body: AddMockRuleResponseBody(name='body'),
}

async function addMockRule(request: AddMockRuleRequest): AddMockRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddMockRule', 'POST', '/', 'json', false, 'json', request);
}

model AddSSLCertRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  certIdentifier?: string(name='CertIdentifier', position='Query'),
  domainId?: long(name='DomainId', position='Query'),
  gatewayUniqueId?: string(name='GatewayUniqueId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
}

model AddSSLCertResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model AddSSLCertResponse = {
  headers: map[string]string(name='headers'),
  body: AddSSLCertResponseBody(name='body'),
}

async function addSSLCert(request: AddSSLCertRequest): AddSSLCertResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddSSLCert', 'POST', '/', 'json', false, 'json', request);
}

model AddSecurityGroupRuleRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  description?: string(name='Description', position='Query'),
  gatewayUniqueId: string(name='GatewayUniqueId', description='网关ID', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  portRange: string(name='PortRange', description='端口范围', position='Query'),
  securityGroupId: string(name='SecurityGroupId', description='安全组ID', position='Query'),
}

model AddSecurityGroupRuleResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model AddSecurityGroupRuleResponse = {
  headers: map[string]string(name='headers'),
  body: AddSecurityGroupRuleResponseBody(name='body'),
}

async function addSecurityGroupRule(request: AddSecurityGroupRuleRequest): AddSecurityGroupRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddSecurityGroupRule', 'POST', '/', 'json', false, 'json', request);
}

model AddServiceSourceRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  address?: string(name='Address', position='Query'),
  gatewayUniqueId?: string(name='GatewayUniqueId', position='Query'),
  groupList?: [ string ](name='GroupList', shrink='json', position='Query'),
  ingressOptionsRequest?: {
    enableIngress?: boolean(name='EnableIngress'),
    ingressClass?: string(name='IngressClass'),
    watchNamespace?: string(name='WatchNamespace'),
  }(name='IngressOptionsRequest', shrink='json', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  name?: string(name='Name', position='Query'),
  source?: string(name='Source', position='Query'),
  type?: string(name='Type', position='Query'),
}

model AddServiceSourceResponseBody = {
  code?: int32(name='Code'),
  data?: long(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model AddServiceSourceResponse = {
  headers: map[string]string(name='headers'),
  body: AddServiceSourceResponseBody(name='body'),
}

async function addServiceSource(request: AddServiceSourceRequest): AddServiceSourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddServiceSource', 'POST', '/', 'json', false, 'json', request);
}

model ApplyGatewayRouteRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  gatewayUniqueId?: string(name='GatewayUniqueId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  routeId?: string(name='RouteId', position='Query'),
}

model ApplyGatewayRouteResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model ApplyGatewayRouteResponse = {
  headers: map[string]string(name='headers'),
  body: ApplyGatewayRouteResponseBody(name='body'),
}

async function applyGatewayRoute(request: ApplyGatewayRouteRequest): ApplyGatewayRouteResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ApplyGatewayRoute', 'POST', '/', 'json', false, 'json', request);
}

model ApplyTagPoliciesRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  appId: string(name='AppId', position='Query'),
  enable?: boolean(name='Enable', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  namespaceId?: string(name='NamespaceId', position='Query'),
  region: string(name='Region', position='Query'),
  rules?: string(name='Rules', position='Query'),
  source: string(name='Source', position='Query'),
}

model ApplyTagPoliciesResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      carryData?: boolean(name='CarryData'),
      enable?: boolean(name='Enable'),
      id?: long(name='Id'),
      instanceNum?: int32(name='InstanceNum'),
      name?: string(name='Name'),
      rate?: int32(name='Rate'),
      remove?: boolean(name='Remove'),
      rules?: string(name='Rules'),
      status?: int32(name='Status'),
      tag?: string(name='Tag'),
    }
  ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ApplyTagPoliciesResponse = {
  headers: map[string]string(name='headers'),
  body: ApplyTagPoliciesResponseBody(name='body'),
}

async function applyTagPolicies(request: ApplyTagPoliciesRequest): ApplyTagPoliciesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ApplyTagPolicies', 'POST', '/', 'json', false, 'json', request);
}

model CloneNacosConfigRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  ids: string(name='Ids', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  originNamespaceId?: string(name='OriginNamespaceId', position='Query'),
  policy: string(name='Policy', position='Query'),
  targetNamespaceId?: string(name='TargetNamespaceId', position='Query'),
}

model CloneNacosConfigResponseBody = {
  code?: int32(name='Code'),
  data?: {
    failData?: [ 
      {
        dataId?: string(name='DataId'),
        group?: string(name='Group'),
      }
    ](name='FailData'),
    skipCount?: int32(name='SkipCount'),
    skipData?: [ 
      {
        dataId?: string(name='DataId'),
        group?: string(name='Group'),
      }
    ](name='SkipData'),
    succCount?: int32(name='SuccCount'),
  }(name='Data'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CloneNacosConfigResponse = {
  headers: map[string]string(name='headers'),
  body: CloneNacosConfigResponseBody(name='body'),
}

async function cloneNacosConfig(request: CloneNacosConfigRequest): CloneNacosConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CloneNacosConfig', 'POST', '/', 'json', false, 'json', request);
}

model CreateApplicationRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  appName: string(name='AppName', position='Query'),
  extraInfo?: string(name='ExtraInfo', position='Query'),
  language?: string(name='Language', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  region: string(name='Region', position='Query'),
  sentinelEnable?: string(name='SentinelEnable', position='Query'),
  source?: string(name='Source', position='Query'),
  switchEnable?: string(name='SwitchEnable', position='Query'),
}

model CreateApplicationResponseBody = {
  code?: int32(name='Code'),
  data?: {
    appId?: string(name='AppId'),
    appName?: string(name='AppName'),
    createTime?: long(name='CreateTime'),
    extraInfo?: string(name='ExtraInfo'),
    language?: string(name='Language'),
    licenseKey?: string(name='LicenseKey'),
    regionId?: string(name='RegionId'),
    source?: string(name='Source'),
    status?: int32(name='Status'),
    updateTime?: long(name='UpdateTime'),
    userId?: string(name='UserId'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model CreateApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: CreateApplicationResponseBody(name='body'),
}

async function createApplication(request: CreateApplicationRequest): CreateApplicationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateApplication', 'POST', '/', 'json', false, 'json', request);
}

model CreateClusterRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  clusterSpecification: string(name='ClusterSpecification', position='Query'),
  clusterType: string(name='ClusterType', position='Query'),
  clusterVersion: string(name='ClusterVersion', position='Query'),
  connectionType?: string(name='ConnectionType', position='Query'),
  diskType?: string(name='DiskType', position='Query'),
  instanceCount: int32(name='InstanceCount', position='Query'),
  instanceName?: string(name='InstanceName', description='实例名称', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  mseVersion?: string(name='MseVersion', description='用于区分基础/专业版本', position='Query'),
  netType: string(name='NetType', position='Query'),
  privateSlbSpecification?: string(name='PrivateSlbSpecification', position='Query'),
  pubNetworkFlow?: string(name='PubNetworkFlow', position='Query'),
  pubSlbSpecification?: string(name='PubSlbSpecification', position='Query'),
  region?: string(name='Region', position='Query'),
  requestPars?: string(name='RequestPars', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key', description='标签键'),
      value?: string(name='Value', description='标签值'),
    }
  ](name='Tag', description='标签列表，最多包含20个子项', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
}

model CreateClusterResponseBody = {
  errorCode?: string(name='ErrorCode'),
  instanceId?: string(name='InstanceId'),
  message?: string(name='Message'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateClusterResponse = {
  headers: map[string]string(name='headers'),
  body: CreateClusterResponseBody(name='body'),
}

async function createCluster(request: CreateClusterRequest): CreateClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateCluster', 'POST', '/', 'json', false, 'json', request);
}

model CreateEngineNamespaceRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  clusterId?: string(name='ClusterId', position='Query'),
  desc?: string(name='Desc', position='Query'),
  id?: string(name='Id', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  name: string(name='Name', position='Query'),
  serviceCount?: int32(name='ServiceCount', position='Query'),
}

model CreateEngineNamespaceResponseBody = {
  clusterId?: string(name='ClusterId'),
  data?: {
    configCount?: int32(name='ConfigCount'),
    namespace?: string(name='Namespace'),
    namespaceDesc?: string(name='NamespaceDesc'),
    namespaceShowName?: string(name='NamespaceShowName'),
    quota?: int32(name='Quota'),
    serviceCount?: int32(name='ServiceCount'),
    type?: int32(name='Type'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateEngineNamespaceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateEngineNamespaceResponseBody(name='body'),
}

async function createEngineNamespace(request: CreateEngineNamespaceRequest): CreateEngineNamespaceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateEngineNamespace', 'POST', '/', 'json', false, 'json', request);
}

model CreateMseServiceApplicationRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  appName: string(name='AppName', position='Query'),
  extraInfo?: string(name='ExtraInfo', position='Query'),
  language?: string(name='Language', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  mseVersion?: string(name='MseVersion', position='Query'),
  region: string(name='Region', position='Query'),
  sentinelEnable?: string(name='SentinelEnable', position='Query'),
  source?: string(name='Source', position='Query'),
  switchEnable?: string(name='SwitchEnable', position='Query'),
}

model CreateMseServiceApplicationResponseBody = {
  code?: int32(name='Code'),
  data?: {
    appId?: string(name='AppId'),
    appName?: string(name='AppName'),
    createTime?: long(name='CreateTime'),
    extraInfo?: string(name='ExtraInfo'),
    language?: string(name='Language'),
    licenseKey?: string(name='LicenseKey'),
    regionId?: string(name='RegionId'),
    source?: string(name='Source'),
    status?: int32(name='Status'),
    updateTime?: long(name='UpdateTime'),
    userId?: string(name='UserId'),
    version?: string(name='Version'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model CreateMseServiceApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: CreateMseServiceApplicationResponseBody(name='body'),
}

async function createMseServiceApplication(request: CreateMseServiceApplicationRequest): CreateMseServiceApplicationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateMseServiceApplication', 'POST', '/', 'json', false, 'json', request);
}

model CreateNacosConfigRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  appName?: string(name='AppName', position='Query'),
  betaIps?: string(name='BetaIps', position='Query'),
  content?: string(name='Content', position='Query'),
  dataId: string(name='DataId', position='Query'),
  desc?: string(name='Desc', position='Query'),
  group: string(name='Group', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  namespaceId?: string(name='NamespaceId', position='Query'),
  tags?: string(name='Tags', position='Query'),
  type?: string(name='Type', position='Query'),
}

model CreateNacosConfigResponseBody = {
  code?: string(name='Code'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateNacosConfigResponse = {
  headers: map[string]string(name='headers'),
  body: CreateNacosConfigResponseBody(name='body'),
}

async function createNacosConfig(request: CreateNacosConfigRequest): CreateNacosConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateNacosConfig', 'POST', '/', 'json', false, 'json', request);
}

model CreateNacosInstanceRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  clusterName?: string(name='ClusterName', description='Nacos集群名', position='Query'),
  enabled: boolean(name='Enabled', description='服务禁用标志', position='Query'),
  ephemeral: boolean(name='Ephemeral', description='临时节点标志', position='Query'),
  groupName: string(name='GroupName', description='分组名', position='Query'),
  instanceId: string(name='InstanceId', description='实例id', position='Query'),
  ip: string(name='Ip', description='Nacos实例ip', position='Query'),
  metadata?: string(name='Metadata', description='节点元数据', position='Body'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  namespaceId?: string(name='NamespaceId', description='命名空间id', position='Query'),
  port: int32(name='Port', description='Nacos实例端口', minimum=0, maximum=65535, position='Query'),
  serviceName: string(name='ServiceName', description='服务名', position='Query'),
  weight: string(name='Weight', description='权重', position='Query'),
}

model CreateNacosInstanceResponseBody = {
  code?: int32(name='Code', description='响应码'),
  data?: string(name='Data', description='修改结果'),
  httpStatusCode?: int32(name='HttpStatusCode', description='http状态码'),
  message?: string(name='Message', description='响应信息'),
  requestId?: string(name='RequestId', description='请求id'),
  success?: boolean(name='Success', description='成功标志'),
}

model CreateNacosInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateNacosInstanceResponseBody(name='body'),
}

async function createNacosInstance(request: CreateNacosInstanceRequest): CreateNacosInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateNacosInstance', 'POST', '/', 'json', true, 'form', request);
}

model CreateNacosServiceRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  clusterId?: string(name='ClusterId', position='Query'),
  ephemeral?: boolean(name='Ephemeral', position='Query'),
  groupName?: string(name='GroupName', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  namespaceId?: string(name='NamespaceId', position='Query'),
  protectThreshold?: string(name='ProtectThreshold', position='Query'),
  serviceName: string(name='ServiceName', position='Query'),
}

model CreateNacosServiceResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateNacosServiceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateNacosServiceResponseBody(name='body'),
}

async function createNacosService(request: CreateNacosServiceRequest): CreateNacosServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateNacosService', 'POST', '/', 'json', false, 'json', request);
}

model CreateOrUpdateSwimmingLaneRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  enable?: boolean(name='Enable', description='是否开启。', position='Query'),
  enableRules?: boolean(name='EnableRules', position='Query'),
  entryRule?: string(name='EntryRule', description='json string', position='Query'),
  entryRules?: [ 
    {
      condition?: string(name='Condition'),
      enable?: boolean(name='Enable'),
      path?: string(name='Path'),
      paths?: [ string ](name='Paths'),
      priority?: int32(name='Priority'),
      restItems?: [ 
        {
          cond?: string(name='Cond'),
          datum?: string(name='Datum'),
          divisor?: int32(name='Divisor'),
          name?: string(name='Name'),
          nameList?: [ string ](name='NameList'),
          operator?: string(name='Operator'),
          rate?: int32(name='Rate'),
          remainder?: int32(name='Remainder'),
          type?: string(name='Type'),
          value?: string(name='Value'),
        }
      ](name='RestItems'),
    }
  ](name='EntryRules', description='SwimmingLane', position='Query'),
  gmtCreate?: string(name='GmtCreate', description='创建时间', position='Query'),
  gmtModified?: string(name='GmtModified', description='更新时间', position='Query'),
  groupId?: long(name='GroupId', description='所属泳道组', position='Query'),
  id?: long(name='Id', description='主键ID。由SP生成(数据库自增主键)。', position='Query'),
  licenseKey?: string(name='LicenseKey', description='格式为UUID。比如48bd91e9-41d5-4dae-8a9a-439611742b45', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  name?: string(name='Name', description='名称', position='Query'),
  regionId?: string(name='RegionId', description='region', position='Query'),
  source?: string(name='Source', description='来源。可选值为: EDAS。', position='Query'),
  status?: int32(name='Status', description='0 未生效', position='Query'),
  tag?: string(name='Tag', description='标识', position='Query'),
  userId?: string(name='UserId', description='EDAS账号。格式为数字，比如1362469756373809。', position='Query'),
}

model CreateOrUpdateSwimmingLaneResponseBody = {
  code?: int32(name='Code', description='code仅仅用来和success同步'),
  data?: any(name='Data'),
  dynamicMessage?: string(name='DynamicMessage', description='动态错误信息中的占位符'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateOrUpdateSwimmingLaneResponse = {
  headers: map[string]string(name='headers'),
  body: CreateOrUpdateSwimmingLaneResponseBody(name='body'),
}

async function createOrUpdateSwimmingLane(request: CreateOrUpdateSwimmingLaneRequest): CreateOrUpdateSwimmingLaneResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateOrUpdateSwimmingLane', 'POST', '/', 'json', false, 'json', request);
}

model CreateOrUpdateSwimmingLaneGroupRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  appIds?: string(name='AppIds', description='应用集合。以 "," 分割应用 id', position='Query'),
  dbGrayEnable?: boolean(name='DbGrayEnable', position='Query'),
  enable?: boolean(name='Enable', description='是否开启。', position='Query'),
  entryApp?: string(name='EntryApp', description='入口应用。格式 "来源系统:id"，比如 EDAS:UUID 或者 CSB:UUID', position='Query'),
  gmtCreate?: string(name='GmtCreate', description='创建时间', position='Query'),
  gmtModified?: string(name='GmtModified', description='更新时间', position='Query'),
  id?: long(name='Id', description='主键ID。由SP生成(数据库自增主键)。', position='Query'),
  licenseKey?: string(name='LicenseKey', description='mse licenseKey', position='Query'),
  messageQueueFilterSide?: string(name='MessageQueueFilterSide', position='Query'),
  messageQueueGrayEnable?: boolean(name='MessageQueueGrayEnable', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  name?: string(name='Name', description='名称', position='Query'),
  region?: string(name='Region', description='region', position='Query'),
  source?: string(name='Source', description='来源。可选值为: EDAS。', position='Query'),
  status?: int32(name='Status', description='0 未生效', position='Query'),
  userId?: string(name='UserId', description='阿里云账号。格式为数字，比如1362469756373809。', position='Query'),
}

model CreateOrUpdateSwimmingLaneGroupResponseBody = {
  code?: int32(name='Code', description='code仅仅用来和success同步'),
  data?: any(name='Data'),
  dynamicMessage?: string(name='DynamicMessage', description='动态错误信息中的占位符'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateOrUpdateSwimmingLaneGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateOrUpdateSwimmingLaneGroupResponseBody(name='body'),
}

async function createOrUpdateSwimmingLaneGroup(request: CreateOrUpdateSwimmingLaneGroupRequest): CreateOrUpdateSwimmingLaneGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateOrUpdateSwimmingLaneGroup', 'POST', '/', 'json', false, 'json', request);
}

model CreateZnodeRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  clusterId?: string(name='ClusterId', position='Query'),
  data?: string(name='Data', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  path?: string(name='Path', position='Query'),
}

model CreateZnodeResponseBody = {
  data?: {
    data?: string(name='Data'),
    dir?: boolean(name='Dir'),
    name?: string(name='Name'),
    path?: string(name='Path'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateZnodeResponse = {
  headers: map[string]string(name='headers'),
  body: CreateZnodeResponseBody(name='body'),
}

async function createZnode(request: CreateZnodeRequest): CreateZnodeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateZnode', 'POST', '/', 'json', false, 'json', request);
}

model DeleteAuthResourceRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  gatewayUniqueId?: string(name='GatewayUniqueId', position='Query'),
  id?: long(name='Id', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
}

model DeleteAuthResourceResponseBody = {
  code?: int32(name='Code'),
  data?: {
    authId?: long(name='AuthId'),
    domainId?: long(name='DomainId'),
    domainName?: string(name='DomainName'),
    gatewayId?: long(name='GatewayId'),
    gatewayUniqueId?: string(name='GatewayUniqueId'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    id?: long(name='Id'),
    isWhite?: boolean(name='IsWhite'),
    path?: string(name='Path'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model DeleteAuthResourceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAuthResourceResponseBody(name='body'),
}

async function deleteAuthResource(request: DeleteAuthResourceRequest): DeleteAuthResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteAuthResource', 'POST', '/', 'json', false, 'json', request);
}

model DeleteClusterRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
}

model DeleteClusterResponseBody = {
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteClusterResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteClusterResponseBody(name='body'),
}

async function deleteCluster(request: DeleteClusterRequest): DeleteClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteCluster', 'POST', '/', 'json', false, 'json', request);
}

model DeleteEngineNamespaceRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  clusterId?: string(name='ClusterId', position='Query'),
  id?: string(name='Id', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
}

model DeleteEngineNamespaceResponseBody = {
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteEngineNamespaceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteEngineNamespaceResponseBody(name='body'),
}

async function deleteEngineNamespace(request: DeleteEngineNamespaceRequest): DeleteEngineNamespaceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteEngineNamespace', 'POST', '/', 'json', false, 'json', request);
}

model DeleteGatewayRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  deleteSlb?: boolean(name='DeleteSlb', position='Query'),
  gatewayUniqueId?: string(name='GatewayUniqueId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
}

model DeleteGatewayResponseBody = {
  code?: int32(name='Code'),
  data?: {
    gatewayUniqueId?: string(name='GatewayUniqueId'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    id?: long(name='Id'),
    name?: string(name='Name'),
    primaryUser?: string(name='PrimaryUser'),
    region?: string(name='Region'),
    replica?: int32(name='Replica'),
    securityGroup?: string(name='SecurityGroup'),
    spec?: string(name='Spec'),
    status?: int32(name='Status'),
    vpc?: string(name='Vpc'),
    vswitch?: string(name='Vswitch'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model DeleteGatewayResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteGatewayResponseBody(name='body'),
}

async function deleteGateway(request: DeleteGatewayRequest): DeleteGatewayResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteGateway', 'POST', '/', 'json', false, 'json', request);
}

model DeleteGatewayDomainRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  gatewayUniqueId?: string(name='GatewayUniqueId', position='Query'),
  id?: string(name='Id', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
}

model DeleteGatewayDomainResponseBody = {
  code?: int32(name='Code'),
  data?: {
    certIdentifier?: string(name='CertIdentifier'),
    gatewayId?: long(name='GatewayId'),
    gatewayUniqueId?: string(name='GatewayUniqueId'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    id?: long(name='Id'),
    mustHttps?: boolean(name='MustHttps'),
    name?: string(name='Name'),
    protocol?: string(name='Protocol'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model DeleteGatewayDomainResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteGatewayDomainResponseBody(name='body'),
}

async function deleteGatewayDomain(request: DeleteGatewayDomainRequest): DeleteGatewayDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteGatewayDomain', 'POST', '/', 'json', false, 'json', request);
}

model DeleteGatewayRouteRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  gatewayUniqueId?: string(name='GatewayUniqueId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  routeId?: string(name='RouteId', position='Query'),
}

model DeleteGatewayRouteResponseBody = {
  code?: int32(name='Code'),
  data?: {
    defaultServiceId?: long(name='DefaultServiceId'),
    gatewayId?: long(name='GatewayId'),
    gatewayUniqueId?: string(name='GatewayUniqueId'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    id?: long(name='Id'),
    name?: string(name='Name'),
    predicates?: string(name='Predicates'),
    routeOrder?: int32(name='RouteOrder'),
    status?: int32(name='Status'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model DeleteGatewayRouteResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteGatewayRouteResponseBody(name='body'),
}

async function deleteGatewayRoute(request: DeleteGatewayRouteRequest): DeleteGatewayRouteResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteGatewayRoute', 'POST', '/', 'json', false, 'json', request);
}

model DeleteGatewayServiceRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  gatewayId?: long(name='GatewayId', position='Query'),
  gatewayUniqueId?: string(name='GatewayUniqueId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  serviceId?: string(name='ServiceId', position='Query'),
}

model DeleteGatewayServiceResponseBody = {
  code?: int32(name='Code'),
  data?: {
    gatewayId?: long(name='GatewayId'),
    gatewayUniqueId?: string(name='GatewayUniqueId'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    groupName?: string(name='GroupName'),
    id?: long(name='Id'),
    ips?: [ string ](name='Ips'),
    metaInfo?: string(name='MetaInfo'),
    name?: string(name='Name'),
    namespace?: string(name='Namespace'),
    serviceNameInRegistry?: string(name='ServiceNameInRegistry'),
    sourceId?: long(name='SourceId'),
    sourceType?: string(name='SourceType'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model DeleteGatewayServiceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteGatewayServiceResponseBody(name='body'),
}

async function deleteGatewayService(request: DeleteGatewayServiceRequest): DeleteGatewayServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteGatewayService', 'POST', '/', 'json', false, 'json', request);
}

model DeleteGatewayServiceVersionRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  gatewayUniqueId?: string(name='GatewayUniqueId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  serviceId?: long(name='ServiceId', position='Query'),
  serviceVersion?: string(name='ServiceVersion', position='Query'),
}

model DeleteGatewayServiceVersionResponseBody = {
  code?: int32(name='Code'),
  data?: long(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model DeleteGatewayServiceVersionResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteGatewayServiceVersionResponseBody(name='body'),
}

async function deleteGatewayServiceVersion(request: DeleteGatewayServiceVersionRequest): DeleteGatewayServiceVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteGatewayServiceVersion', 'POST', '/', 'json', false, 'json', request);
}

model DeleteGatewaySlbRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  deleteSlb?: boolean(name='DeleteSlb', position='Query'),
  gatewayUniqueId?: string(name='GatewayUniqueId', position='Query'),
  id?: string(name='Id', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
}

model DeleteGatewaySlbResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model DeleteGatewaySlbResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteGatewaySlbResponseBody(name='body'),
}

async function deleteGatewaySlb(request: DeleteGatewaySlbRequest): DeleteGatewaySlbResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteGatewaySlb', 'POST', '/', 'json', false, 'json', request);
}

model DeleteNacosConfigRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  beta?: boolean(name='Beta', position='Query'),
  dataId: string(name='DataId', position='Query'),
  group: string(name='Group', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  namespaceId?: string(name='NamespaceId', position='Query'),
}

model DeleteNacosConfigResponseBody = {
  code?: string(name='Code'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteNacosConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteNacosConfigResponseBody(name='body'),
}

async function deleteNacosConfig(request: DeleteNacosConfigRequest): DeleteNacosConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteNacosConfig', 'POST', '/', 'json', false, 'json', request);
}

model DeleteNacosConfigsRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  ids: string(name='Ids', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  namespaceId: string(name='NamespaceId', position='Query'),
}

model DeleteNacosConfigsResponseBody = {
  code?: int32(name='Code'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteNacosConfigsResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteNacosConfigsResponseBody(name='body'),
}

async function deleteNacosConfigs(request: DeleteNacosConfigsRequest): DeleteNacosConfigsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteNacosConfigs', 'POST', '/', 'json', false, 'json', request);
}

model DeleteNacosInstanceRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  clusterName?: string(name='ClusterName', position='Query'),
  ephemeral: boolean(name='Ephemeral', position='Query'),
  groupName: string(name='GroupName', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  ip: string(name='Ip', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  namespaceId?: string(name='NamespaceId', position='Query'),
  port: int32(name='Port', position='Query'),
  serviceName: string(name='ServiceName', position='Query'),
}

model DeleteNacosInstanceResponseBody = {
  code?: int32(name='Code', description='code仅仅用来和success同步'),
  data?: string(name='Data'),
  dynamicMessage?: string(name='DynamicMessage', description='动态错误信息中的占位符'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteNacosInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteNacosInstanceResponseBody(name='body'),
}

async function deleteNacosInstance(request: DeleteNacosInstanceRequest): DeleteNacosInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteNacosInstance', 'POST', '/', 'json', false, 'json', request);
}

model DeleteNacosServiceRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  groupName: string(name='GroupName', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  namespaceId?: string(name='NamespaceId', position='Query'),
  serviceName: string(name='ServiceName', position='Query'),
}

model DeleteNacosServiceResponseBody = {
  code?: int32(name='Code', description='响应码'),
  data?: string(name='Data', description='删除服务的结果'),
  httpStatusCode?: int32(name='HttpStatusCode', description='http状态码'),
  message?: string(name='Message', description='响应信息'),
  requestId?: string(name='RequestId', description='请求id'),
  success?: boolean(name='Success', description='成功标志'),
}

model DeleteNacosServiceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteNacosServiceResponseBody(name='body'),
}

async function deleteNacosService(request: DeleteNacosServiceRequest): DeleteNacosServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteNacosService', 'POST', '/', 'json', false, 'json', request);
}

model DeleteSecurityGroupRuleRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  gatewayUniqueId?: string(name='GatewayUniqueId', position='Query'),
  id?: long(name='Id', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
}

model DeleteSecurityGroupRuleResponseBody = {
  code?: int32(name='Code'),
  data?: {
    description?: string(name='Description'),
    gatewayId?: long(name='GatewayId'),
    gatewayUniqueId?: string(name='GatewayUniqueId'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    id?: long(name='Id'),
    ipProtocol?: string(name='IpProtocol'),
    portRange?: string(name='PortRange'),
    securityGroupId?: string(name='SecurityGroupId'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model DeleteSecurityGroupRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSecurityGroupRuleResponseBody(name='body'),
}

async function deleteSecurityGroupRule(request: DeleteSecurityGroupRuleRequest): DeleteSecurityGroupRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteSecurityGroupRule', 'POST', '/', 'json', false, 'json', request);
}

model DeleteServiceSourceRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  gatewayUniqueId?: string(name='GatewayUniqueId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  sourceId?: long(name='SourceId', position='Query'),
}

model DeleteServiceSourceResponseBody = {
  code?: int32(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model DeleteServiceSourceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteServiceSourceResponseBody(name='body'),
}

async function deleteServiceSource(request: DeleteServiceSourceRequest): DeleteServiceSourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteServiceSource', 'POST', '/', 'json', false, 'json', request);
}

model DeleteSwimmingLaneRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  laneId: long(name='LaneId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
}

model DeleteSwimmingLaneResponseBody = {
  code?: int32(name='Code', description='code仅仅用来和success同步'),
  data?: any(name='Data'),
  dynamicMessage?: string(name='DynamicMessage', description='动态错误信息中的占位符'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteSwimmingLaneResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSwimmingLaneResponseBody(name='body'),
}

async function deleteSwimmingLane(request: DeleteSwimmingLaneRequest): DeleteSwimmingLaneResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteSwimmingLane', 'POST', '/', 'json', false, 'json', request);
}

model DeleteSwimmingLaneGroupRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  groupId: long(name='GroupId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
}

model DeleteSwimmingLaneGroupResponseBody = {
  code?: int32(name='Code', description='code仅仅用来和success同步'),
  data?: any(name='Data'),
  dynamicMessage?: string(name='DynamicMessage', description='动态错误信息中的占位符'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteSwimmingLaneGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSwimmingLaneGroupResponseBody(name='body'),
}

async function deleteSwimmingLaneGroup(request: DeleteSwimmingLaneGroupRequest): DeleteSwimmingLaneGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteSwimmingLaneGroup', 'POST', '/', 'json', false, 'json', request);
}

model DeleteZnodeRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  clusterId: string(name='ClusterId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  path: string(name='Path', position='Query'),
  requestPars?: string(name='RequestPars', position='Query'),
}

model DeleteZnodeResponseBody = {
  data?: {
    data?: string(name='Data'),
    dir?: boolean(name='Dir'),
    name?: string(name='Name'),
    path?: string(name='Path'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteZnodeResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteZnodeResponseBody(name='body'),
}

async function deleteZnode(request: DeleteZnodeRequest): DeleteZnodeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteZnode', 'POST', '/', 'json', false, 'json', request);
}

model ExportNacosConfigRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  appName?: string(name='AppName', position='Query'),
  dataId?: string(name='DataId', position='Query'),
  group?: string(name='Group', position='Query'),
  ids?: string(name='Ids', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  namespaceId?: string(name='NamespaceId', position='Query'),
}

model ExportNacosConfigResponseBody = {
  code?: int32(name='Code'),
  data?: {
    url?: string(name='Url'),
  }(name='Data'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ExportNacosConfigResponse = {
  headers: map[string]string(name='headers'),
  body: ExportNacosConfigResponseBody(name='body'),
}

async function exportNacosConfig(request: ExportNacosConfigRequest): ExportNacosConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ExportNacosConfig', 'POST', '/', 'json', false, 'json', request);
}

model GetAppMessageQueueRouteRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  appId: string(name='AppId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  region: string(name='Region', position='Query'),
}

model GetAppMessageQueueRouteResponseBody = {
  code?: int32(name='Code'),
  data?: {
    appId?: string(name='AppId'),
    enable?: boolean(name='Enable'),
    filterSide?: string(name='FilterSide'),
    region?: string(name='Region'),
    tags?: [ string ](name='Tags'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetAppMessageQueueRouteResponse = {
  headers: map[string]string(name='headers'),
  body: GetAppMessageQueueRouteResponseBody(name='body'),
}

async function getAppMessageQueueRoute(request: GetAppMessageQueueRouteRequest): GetAppMessageQueueRouteResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetAppMessageQueueRoute', 'POST', '/', 'json', false, 'json', request);
}

model GetApplicationListRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  appId?: string(name='AppId', position='Query'),
  appName?: string(name='AppName', position='Query'),
  language?: string(name='Language', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  pageNumber: int32(name='PageNumber', position='Query'),
  pageSize: int32(name='PageSize', position='Query'),
  region: string(name='Region', position='Query'),
  sentinelEnable?: boolean(name='SentinelEnable', position='Query'),
  source?: string(name='Source', position='Query'),
  switchEnable?: boolean(name='SwitchEnable', position='Query'),
}

model GetApplicationListResponseBody = {
  code?: int32(name='Code'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    result?: [ 
      {
        appId?: string(name='AppId'),
        appName?: string(name='AppName'),
        extraInfo?: string(name='ExtraInfo'),
        instancesNumber?: int32(name='InstancesNumber'),
        language?: string(name='Language'),
        licenseKey?: string(name='LicenseKey'),
        regionId?: string(name='RegionId'),
        source?: string(name='Source'),
        status?: long(name='Status'),
        userId?: string(name='UserId'),
      }
    ](name='Result'),
    totalSize?: int32(name='TotalSize'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetApplicationListResponse = {
  headers: map[string]string(name='headers'),
  body: GetApplicationListResponseBody(name='body'),
}

async function getApplicationList(request: GetApplicationListRequest): GetApplicationListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetApplicationList', 'POST', '/', 'json', false, 'json', request);
}

model GetBlackWhiteListRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  gatewayUniqueId?: string(name='GatewayUniqueId', position='Query'),
  isWhite?: boolean(name='IsWhite', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  resourceType?: string(name='ResourceType', position='Query'),
  type?: string(name='Type', position='Query'),
}

model GetBlackWhiteListResponseBody = {
  code?: int32(name='Code'),
  data?: {
    content?: string(name='Content'),
    gatewayId?: long(name='GatewayId'),
    gatewayUniqueId?: string(name='GatewayUniqueId'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    id?: long(name='Id'),
    isWhite?: boolean(name='IsWhite'),
    resourceId?: long(name='ResourceId'),
    resourceType?: string(name='ResourceType'),
    status?: string(name='Status'),
    type?: string(name='Type'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model GetBlackWhiteListResponse = {
  headers: map[string]string(name='headers'),
  body: GetBlackWhiteListResponseBody(name='body'),
}

async function getBlackWhiteList(request: GetBlackWhiteListRequest): GetBlackWhiteListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetBlackWhiteList', 'POST', '/', 'json', false, 'json', request);
}

model GetEngineNamepaceRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  clusterId?: string(name='ClusterId', position='Query'),
  id?: string(name='Id', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
}

model GetEngineNamepaceResponseBody = {
  configCount?: string(name='ConfigCount'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  namespace?: string(name='Namespace'),
  namespaceDesc?: string(name='NamespaceDesc'),
  namespaceShowName?: string(name='NamespaceShowName'),
  quota?: string(name='Quota'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  type?: string(name='Type'),
}

model GetEngineNamepaceResponse = {
  headers: map[string]string(name='headers'),
  body: GetEngineNamepaceResponseBody(name='body'),
}

async function getEngineNamepace(request: GetEngineNamepaceRequest): GetEngineNamepaceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetEngineNamepace', 'POST', '/', 'json', false, 'json', request);
}

model GetGatewayRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  gatewayUniqueId?: string(name='GatewayUniqueId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
}

model GetGatewayResponseBody = {
  code?: int32(name='Code'),
  data?: {
    chargeType?: string(name='ChargeType'),
    endDate?: string(name='EndDate'),
    gatewayUniqueId?: string(name='GatewayUniqueId'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    id?: long(name='Id'),
    instanceId?: string(name='InstanceId'),
    logConfigDetails?: {
      logEnabled?: boolean(name='LogEnabled'),
      logStoreName?: string(name='LogStoreName'),
      projectName?: string(name='ProjectName'),
    }(name='LogConfigDetails'),
    mseTag?: string(name='MseTag'),
    name?: string(name='Name'),
    primaryUser?: string(name='PrimaryUser'),
    region?: string(name='Region'),
    replica?: int32(name='Replica'),
    securityGroup?: string(name='SecurityGroup'),
    spec?: string(name='Spec'),
    status?: int32(name='Status'),
    statusDesc?: string(name='StatusDesc'),
    vpc?: string(name='Vpc'),
    vswitch?: string(name='Vswitch'),
    vswitch2?: string(name='Vswitch2'),
    xtraceDetails?: {
      sample?: int32(name='Sample'),
      traceOn?: boolean(name='TraceOn'),
    }(name='XtraceDetails'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model GetGatewayResponse = {
  headers: map[string]string(name='headers'),
  body: GetGatewayResponseBody(name='body'),
}

async function getGateway(request: GetGatewayRequest): GetGatewayResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetGateway', 'POST', '/', 'json', false, 'json', request);
}

model GetGatewayDomainDetailRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  gatewayUniqueId?: string(name='GatewayUniqueId', position='Query'),
  id?: string(name='Id', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
}

model GetGatewayDomainDetailResponseBody = {
  code?: int32(name='Code'),
  data?: {
    afterDate?: long(name='AfterDate'),
    algorithm?: string(name='Algorithm'),
    beforeDate?: long(name='BeforeDate'),
    certIdentifier?: string(name='CertIdentifier'),
    certName?: string(name='CertName'),
    commonName?: string(name='CommonName'),
    gatewayId?: long(name='GatewayId'),
    gatewayUniqueId?: string(name='GatewayUniqueId'),
    gmtAfter?: string(name='GmtAfter'),
    gmtBefore?: string(name='GmtBefore'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    http2?: string(name='Http2'),
    id?: long(name='Id'),
    issuer?: string(name='Issuer'),
    mustHttps?: boolean(name='MustHttps'),
    name?: string(name='Name'),
    protocol?: string(name='Protocol'),
    sans?: string(name='Sans'),
    tlsMax?: string(name='TlsMax'),
    tlsMin?: string(name='TlsMin'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model GetGatewayDomainDetailResponse = {
  headers: map[string]string(name='headers'),
  body: GetGatewayDomainDetailResponseBody(name='body'),
}

async function getGatewayDomainDetail(request: GetGatewayDomainDetailRequest): GetGatewayDomainDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetGatewayDomainDetail', 'POST', '/', 'json', false, 'json', request);
}

model GetGatewayOptionRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  gatewayId?: long(name='GatewayId', position='Query'),
  gatewayUniqueId?: string(name='GatewayUniqueId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
}

model GetGatewayOptionResponseBody = {
  code?: int32(name='Code'),
  data?: GatewayOption(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model GetGatewayOptionResponse = {
  headers: map[string]string(name='headers'),
  body: GetGatewayOptionResponseBody(name='body'),
}

async function getGatewayOption(request: GetGatewayOptionRequest): GetGatewayOptionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetGatewayOption', 'POST', '/', 'json', false, 'json', request);
}

model GetGatewayRouteDetailRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  gatewayUniqueId?: string(name='GatewayUniqueId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  routeId?: long(name='RouteId', position='Query'),
}

model GetGatewayRouteDetailResponseBody = {
  code?: int32(name='Code'),
  data?: {
    ahasStatus?: int32(name='AhasStatus'),
    cors?: {
      allowCredentials?: boolean(name='AllowCredentials'),
      allowHeaders?: string(name='AllowHeaders'),
      allowMethods?: string(name='AllowMethods'),
      allowOrigins?: string(name='AllowOrigins'),
      exposeHeaders?: string(name='ExposeHeaders'),
      status?: string(name='Status'),
      timeUnit?: string(name='TimeUnit'),
      unitNum?: long(name='UnitNum'),
    }(name='Cors'),
    defaultServiceId?: long(name='DefaultServiceId'),
    defaultServiceName?: string(name='DefaultServiceName'),
    destinationType?: string(name='DestinationType'),
    directResponse?: {
      body?: string(name='Body'),
      code?: int32(name='Code'),
    }(name='DirectResponse'),
    domainId?: long(name='DomainId'),
    domainIdList?: [ long ](name='DomainIdList'),
    domainName?: string(name='DomainName'),
    domainNameList?: [ string ](name='DomainNameList'),
    enableWaf?: boolean(name='EnableWaf'),
    fallback?: boolean(name='Fallback'),
    fallbackServices?: [ 
      {
        agreementType?: string(name='AgreementType'),
        groupName?: string(name='GroupName'),
        name?: string(name='Name'),
        namespace?: string(name='Namespace'),
        percent?: int32(name='Percent'),
        serviceId?: long(name='ServiceId'),
        serviceName?: string(name='ServiceName'),
        servicePort?: int32(name='ServicePort'),
        sourceType?: string(name='SourceType'),
        version?: string(name='Version'),
      }
    ](name='FallbackServices'),
    gatewayId?: long(name='GatewayId'),
    gatewayUniqueId?: string(name='GatewayUniqueId'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    HTTPRewrite?: {
      host?: string(name='Host'),
      path?: string(name='Path'),
      pathType?: string(name='PathType'),
      pattern?: string(name='Pattern'),
      status?: string(name='Status'),
      substitution?: string(name='Substitution'),
    }(name='HTTPRewrite'),
    headerOp?: {
      headerOpItems?: [ 
        {
          directionType?: string(name='DirectionType'),
          key?: string(name='Key'),
          opType?: string(name='OpType'),
          value?: string(name='Value'),
        }
      ](name='HeaderOpItems'),
      status?: string(name='Status'),
    }(name='HeaderOp'),
    id?: long(name='Id'),
    name?: string(name='Name'),
    predicates?: string(name='Predicates'),
    redirect?: {
      code?: int32(name='Code'),
      host?: string(name='Host'),
      path?: string(name='Path'),
    }(name='Redirect'),
    retry?: {
      attempts?: int32(name='Attempts'),
      httpCodes?: [ string ](name='HttpCodes'),
      retryOn?: [ string ](name='RetryOn'),
      status?: string(name='Status'),
    }(name='Retry'),
    routeOrder?: int32(name='RouteOrder'),
    routePredicates?: {
      headerPredicates?: [ 
        {
          key?: string(name='Key'),
          type?: string(name='Type'),
          value?: string(name='Value'),
        }
      ](name='HeaderPredicates'),
      methodPredicates?: [ string ](name='MethodPredicates'),
      pathPredicates?: {
        ignoreCase?: boolean(name='IgnoreCase'),
        path?: string(name='Path'),
        type?: string(name='Type'),
      }(name='PathPredicates'),
      queryPredicates?: [ 
        {
          key?: string(name='Key'),
          type?: string(name='Type'),
          value?: string(name='Value'),
        }
      ](name='QueryPredicates'),
    }(name='RoutePredicates'),
    routeServices?: [ 
      {
        agreementType?: string(name='AgreementType'),
        groupName?: string(name='GroupName'),
        name?: string(name='Name'),
        namespace?: string(name='Namespace'),
        percent?: int32(name='Percent'),
        serviceId?: long(name='ServiceId'),
        serviceName?: string(name='ServiceName'),
        servicePort?: int32(name='ServicePort'),
        sourceType?: string(name='SourceType'),
        version?: string(name='Version'),
      }
    ](name='RouteServices'),
    services?: string(name='Services'),
    status?: int32(name='Status'),
    timeout?: {
      status?: string(name='Status'),
      timeUnit?: string(name='TimeUnit'),
      unitNum?: int32(name='UnitNum'),
    }(name='Timeout'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model GetGatewayRouteDetailResponse = {
  headers: map[string]string(name='headers'),
  body: GetGatewayRouteDetailResponseBody(name='body'),
}

async function getGatewayRouteDetail(request: GetGatewayRouteDetailRequest): GetGatewayRouteDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetGatewayRouteDetail', 'POST', '/', 'json', false, 'json', request);
}

model GetGatewayServiceDetailRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  gatewayUniqueId?: string(name='GatewayUniqueId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  serviceId?: long(name='ServiceId', position='Query'),
}

model GetGatewayServiceDetailResponseBody = {
  code?: int32(name='Code'),
  data?: {
    gatewayId?: long(name='GatewayId'),
    gatewayTrafficPolicy?: TrafficPolicy(name='GatewayTrafficPolicy'),
    gatewayUniqueId?: string(name='GatewayUniqueId'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    groupName?: string(name='GroupName'),
    healthCheck?: string(name='HealthCheck'),
    healthStatus?: string(name='HealthStatus'),
    id?: long(name='Id'),
    ips?: [ string ](name='Ips'),
    labelDetails?: [ 
      {
        key?: string(name='Key'),
        values?: [ string ](name='Values'),
      }
    ](name='LabelDetails'),
    metaInfo?: string(name='MetaInfo'),
    name?: string(name='Name'),
    namespace?: string(name='Namespace'),
    portTrafficPolicyList?: [ 
      {
        gatewayUniqueId?: string(name='GatewayUniqueId'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        id?: long(name='Id'),
        serviceId?: long(name='ServiceId'),
        servicePort?: int32(name='ServicePort'),
        trafficPolicy?: TrafficPolicy(name='TrafficPolicy'),
      }
    ](name='PortTrafficPolicyList'),
    ports?: [ int32 ](name='Ports'),
    serviceNameInRegistry?: string(name='ServiceNameInRegistry'),
    serviceProtocol?: string(name='ServiceProtocol'),
    sourceId?: long(name='SourceId'),
    sourceType?: string(name='SourceType'),
    versionDetails?: [ 
      {
        endpointNum?: int32(name='EndpointNum'),
        endpointNumPercent?: string(name='EndpointNumPercent'),
        serviceVersion?: {
          labels?: [ 
            {
              key?: string(name='Key'),
              value?: string(name='Value'),
            }
          ](name='Labels'),
          name?: string(name='Name'),
        }(name='ServiceVersion'),
      }
    ](name='VersionDetails'),
    versions?: [ 
      {
        label?: string(name='Label'),
        type?: string(name='Type'),
        value?: string(name='Value'),
      }
    ](name='Versions'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model GetGatewayServiceDetailResponse = {
  headers: map[string]string(name='headers'),
  body: GetGatewayServiceDetailResponseBody(name='body'),
}

async function getGatewayServiceDetail(request: GetGatewayServiceDetailRequest): GetGatewayServiceDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetGatewayServiceDetail', 'POST', '/', 'json', false, 'json', request);
}

model GetGovernanceKubernetesClusterRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  clusterId: string(name='ClusterId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model GetGovernanceKubernetesClusterResponseBody = {
  code?: int32(name='Code'),
  data?: {
    clusterId?: string(name='ClusterId'),
    clusterName?: string(name='ClusterName'),
    k8sVersion?: string(name='K8sVersion'),
    namespaceInfos?: string(name='NamespaceInfos'),
    namespaces?: [ 
      {
        name?: string(name='Name'),
        tags?: string(name='Tags'),
      }
    ](name='Namespaces'),
    pilotStartTime?: string(name='PilotStartTime'),
    region?: string(name='Region'),
    updateTime?: string(name='UpdateTime'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetGovernanceKubernetesClusterResponse = {
  headers: map[string]string(name='headers'),
  body: GetGovernanceKubernetesClusterResponseBody(name='body'),
}

async function getGovernanceKubernetesCluster(request: GetGovernanceKubernetesClusterRequest): GetGovernanceKubernetesClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetGovernanceKubernetesCluster', 'POST', '/', 'json', false, 'json', request);
}

model GetImageRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  versionCode: string(name='VersionCode', description='集群版本', position='Query'),
}

model GetImageResponseBody = {
  data?: {
    currentVersionFullShowName?: string(name='CurrentVersionFullShowName', description='当前集群镜像版本的4位全名'),
    maxVersionChangelogUrl?: string(name='MaxVersionChangelogUrl', description='可升级的最大版本变更日志url'),
    maxVersionCode?: string(name='MaxVersionCode', description='可升级的增量版本Code'),
    maxVersionFullShowName?: string(name='MaxVersionFullShowName', description='可升级的增量版本全名'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model GetImageResponse = {
  headers: map[string]string(name='headers'),
  body: GetImageResponseBody(name='body'),
}

async function getImage(request: GetImageRequest): GetImageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetImage', 'POST', '/', 'json', false, 'json', request);
}

model GetImportFileUrlRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  contentType?: string(name='ContentType', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  namespaceId?: string(name='NamespaceId', position='Query'),
}

model GetImportFileUrlResponseBody = {
  code?: int32(name='Code'),
  data?: {
    url?: string(name='Url'),
  }(name='Data'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetImportFileUrlResponse = {
  headers: map[string]string(name='headers'),
  body: GetImportFileUrlResponseBody(name='body'),
}

async function getImportFileUrl(request: GetImportFileUrlRequest): GetImportFileUrlResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetImportFileUrl', 'POST', '/', 'json', false, 'json', request);
}

model GetKubernetesSourceRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  gatewayUniqueId?: string(name='GatewayUniqueId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
}

model GetKubernetesSourceResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      cluster?: string(name='Cluster'),
      name?: string(name='Name'),
    }
  ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model GetKubernetesSourceResponse = {
  headers: map[string]string(name='headers'),
  body: GetKubernetesSourceResponseBody(name='body'),
}

async function getKubernetesSource(request: GetKubernetesSourceRequest): GetKubernetesSourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetKubernetesSource', 'POST', '/', 'json', false, 'json', request);
}

model GetMseFeatureSwitchRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
}

model GetMseFeatureSwitchResponseBody = {
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: map[string]any(name='Result'),
  success?: boolean(name='Success'),
}

model GetMseFeatureSwitchResponse = {
  headers: map[string]string(name='headers'),
  body: GetMseFeatureSwitchResponseBody(name='body'),
}

async function getMseFeatureSwitch(request: GetMseFeatureSwitchRequest): GetMseFeatureSwitchResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMseFeatureSwitch', 'POST', '/', 'json', false, 'json', request);
}

model GetMseSourceRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  gatewayUniqueId: string(name='GatewayUniqueId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  type?: string(name='Type', position='Query'),
}

model GetMseSourceResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      address?: string(name='Address'),
      clusterId?: string(name='ClusterId'),
      instanceId?: string(name='InstanceId'),
      name?: string(name='Name'),
      type?: string(name='Type'),
    }
  ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model GetMseSourceResponse = {
  headers: map[string]string(name='headers'),
  body: GetMseSourceResponseBody(name='body'),
}

async function getMseSource(request: GetMseSourceRequest): GetMseSourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMseSource', 'POST', '/', 'json', false, 'json', request);
}

model GetNacosConfigRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  beta?: boolean(name='Beta', position='Query'),
  dataId: string(name='DataId', position='Query'),
  group: string(name='Group', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  namespaceId?: string(name='NamespaceId', position='Query'),
}

model GetNacosConfigResponseBody = {
  configuration?: {
    appName?: string(name='AppName'),
    betaIps?: string(name='BetaIps'),
    content?: string(name='Content'),
    dataId?: string(name='DataId'),
    desc?: string(name='Desc'),
    encryptedDataKey?: string(name='EncryptedDataKey'),
    group?: string(name='Group'),
    md5?: string(name='Md5'),
    tags?: string(name='Tags'),
    type?: string(name='Type'),
  }(name='Configuration'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetNacosConfigResponse = {
  headers: map[string]string(name='headers'),
  body: GetNacosConfigResponseBody(name='body'),
}

async function getNacosConfig(request: GetNacosConfigRequest): GetNacosConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetNacosConfig', 'POST', '/', 'json', false, 'json', request);
}

model GetNacosHistoryConfigRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  dataId: string(name='DataId', position='Query'),
  group: string(name='Group', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  namespaceId?: string(name='NamespaceId', position='Query'),
  nid: string(name='Nid', position='Query'),
}

model GetNacosHistoryConfigResponseBody = {
  configuration?: {
    appName?: string(name='AppName'),
    content?: string(name='Content'),
    dataId?: string(name='DataId'),
    encryptedDataKey?: string(name='EncryptedDataKey'),
    group?: string(name='Group'),
    md5?: string(name='Md5'),
    opType?: string(name='OpType'),
  }(name='Configuration'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetNacosHistoryConfigResponse = {
  headers: map[string]string(name='headers'),
  body: GetNacosHistoryConfigResponseBody(name='body'),
}

async function getNacosHistoryConfig(request: GetNacosHistoryConfigRequest): GetNacosHistoryConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetNacosHistoryConfig', 'POST', '/', 'json', false, 'json', request);
}

model GetOverviewRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  period?: int32(name='Period', position='Query'),
  region?: string(name='Region', position='Query'),
}

model GetOverviewResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model GetOverviewResponse = {
  headers: map[string]string(name='headers'),
  body: GetOverviewResponseBody(name='body'),
}

async function getOverview(request: GetOverviewRequest): GetOverviewResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetOverview', 'POST', '/', 'json', false, 'json', request);
}

model GetPluginConfigRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  gatewayUniqueId: string(name='GatewayUniqueId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  pluginId: long(name='PluginId', position='Query'),
}

model GetPluginConfigResponseBody = {
  code?: int32(name='Code', description='code仅仅用来和success同步'),
  data?: {
    category?: int32(name='Category'),
    configCheck?: string(name='ConfigCheck'),
    gatewayConfigList?: [ 
      {
        config?: string(name='Config'),
        configLevel?: int32(name='ConfigLevel'),
        enable?: boolean(name='Enable'),
        gatewayId?: long(name='GatewayId'),
        gatewayUniqueId?: string(name='GatewayUniqueId'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        id?: long(name='Id'),
        pluginId?: long(name='PluginId'),
      }
    ](name='GatewayConfigList'),
    id?: long(name='Id'),
    imageName?: string(name='ImageName'),
    mode?: int32(name='Mode'),
    name?: string(name='Name'),
    phase?: int32(name='Phase'),
    primaryUser?: string(name='PrimaryUser'),
    priority?: int32(name='Priority'),
    publishState?: int32(name='PublishState'),
    readme?: string(name='Readme'),
    readmeEn?: string(name='ReadmeEn'),
    status?: string(name='Status'),
    summary?: string(name='Summary'),
    type?: int32(name='Type'),
    version?: string(name='Version'),
    wasmLang?: int32(name='WasmLang'),
  }(name='Data'),
  dynamicCode?: string(name='DynamicCode', description='动态错误信息中的占位符'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetPluginConfigResponse = {
  headers: map[string]string(name='headers'),
  body: GetPluginConfigResponseBody(name='body'),
}

async function getPluginConfig(request: GetPluginConfigRequest): GetPluginConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetPluginConfig', 'POST', '/', 'json', false, 'json', request);
}

model GetPluginsRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  category?: int32(name='Category', position='Query'),
  enableOnly?: boolean(name='EnableOnly', position='Query'),
  gatewayUniqueId: string(name='GatewayUniqueId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  name?: string(name='Name', position='Query'),
}

model GetPluginsResponseBody = {
  code?: int32(name='Code', description='code仅仅用来和success同步'),
  data?: [ 
    {
      category?: int32(name='Category'),
      configCheck?: string(name='ConfigCheck'),
      id?: long(name='Id'),
      name?: string(name='Name'),
      phase?: int32(name='Phase'),
      primaryUser?: string(name='PrimaryUser'),
      priority?: int32(name='Priority'),
      publishState?: int32(name='PublishState'),
      status?: string(name='Status'),
      summary?: string(name='Summary'),
      version?: string(name='Version'),
      wasmFile?: string(name='WasmFile'),
      wasmLang?: int32(name='WasmLang'),
    }
  ](name='Data'),
  dynamicCode?: string(name='DynamicCode', description='动态错误信息中的占位符'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetPluginsResponse = {
  headers: map[string]string(name='headers'),
  body: GetPluginsResponseBody(name='body'),
}

async function getPlugins(request: GetPluginsRequest): GetPluginsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetPlugins', 'POST', '/', 'json', false, 'json', request);
}

model GetServiceListRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  appId?: string(name='AppId', position='Query'),
  ip?: string(name='Ip', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  region?: string(name='Region', position='Query'),
  serviceName?: string(name='ServiceName', position='Query'),
  serviceType?: string(name='ServiceType', position='Query'),
}

model GetServiceListResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      dubboApplicationName?: string(name='DubboApplicationName'),
      edasAppName?: string(name='EdasAppName'),
      group?: string(name='Group'),
      metadata?: map[string]any(name='Metadata'),
      methods?: [ 
        {
          methodController?: string(name='MethodController'),
          name?: string(name='Name'),
          parameterTypes?: [ string ](name='ParameterTypes'),
          paths?: [ string ](name='Paths'),
          requestMethods?: [ string ](name='RequestMethods'),
          returnType?: string(name='ReturnType'),
        }
      ](name='Methods'),
      registryType?: string(name='RegistryType'),
      serviceName?: string(name='ServiceName'),
      serviceType?: string(name='ServiceType'),
      springApplicationName?: string(name='SpringApplicationName'),
      version?: string(name='Version'),
    }
  ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetServiceListResponse = {
  headers: map[string]string(name='headers'),
  body: GetServiceListResponseBody(name='body'),
}

async function getServiceList(request: GetServiceListRequest): GetServiceListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetServiceList', 'POST', '/', 'json', false, 'json', request);
}

model GetServiceListenersRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  clusterId?: string(name='ClusterId', description='当前查询服务的集群标识', position='Query'),
  clusterName?: string(name='ClusterName', description='查询服务下某个集群的实例列表是所需要的参数', position='Query'),
  groupName?: string(name='GroupName', description='服务所在的分组', position='Query'),
  hasIpCount?: string(name='HasIpCount', position='Query'),
  instanceId?: string(name='InstanceId', description='当前查询服务的集群标识', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  namespaceId?: string(name='NamespaceId', description='服务所在的 namespace', position='Query'),
  pageNum?: int32(name='PageNum', description='查询第几页', position='Query'),
  pageSize?: int32(name='PageSize', description='每页展示条数', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  requestPars?: string(name='RequestPars', position='Query'),
  serviceName?: string(name='ServiceName', description='查询指定的服务名信息', position='Query'),
}

model GetServiceListenersResponseBody = {
  data?: [ 
    {
      addr?: string(name='Addr', description='地址'),
      agent?: string(name='Agent', description='客户端版本'),
      app?: string(name='App', description='应用'),
      cluster?: string(name='Cluster', description='集群名称'),
      ip?: string(name='IP', description='ip地址'),
      namespaceId?: string(name='NamespaceId', description='命名空间id'),
      port?: string(name='Port', description='端口号'),
      serviceName?: string(name='ServiceName', description='服务名称'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber', description='实例列表的页码'),
  pageSize?: int32(name='PageSize', description='输入时设置的每页行数'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount', description='查询到的实例总数'),
}

model GetServiceListenersResponse = {
  headers: map[string]string(name='headers'),
  body: GetServiceListenersResponseBody(name='body'),
}

async function getServiceListeners(request: GetServiceListenersRequest): GetServiceListenersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetServiceListeners', 'POST', '/', 'json', false, 'json', request);
}

model GetTagsBySwimmingLaneGroupIdRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  groupId: long(name='GroupId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
}

model GetTagsBySwimmingLaneGroupIdResponseBody = {
  code?: int32(name='Code', description='code仅仅用来和success同步'),
  data?: any(name='Data'),
  dynamicMessage?: string(name='DynamicMessage', description='动态错误信息中的占位符'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetTagsBySwimmingLaneGroupIdResponse = {
  headers: map[string]string(name='headers'),
  body: GetTagsBySwimmingLaneGroupIdResponseBody(name='body'),
}

async function getTagsBySwimmingLaneGroupId(request: GetTagsBySwimmingLaneGroupIdRequest): GetTagsBySwimmingLaneGroupIdResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetTagsBySwimmingLaneGroupId', 'POST', '/', 'json', false, 'json', request);
}

model ImportNacosConfigRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  fileUrl: string(name='FileUrl', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  namespaceId?: string(name='NamespaceId', position='Query'),
  policy?: string(name='Policy', position='Query'),
}

model ImportNacosConfigResponseBody = {
  code?: int32(name='Code'),
  data?: {
    failData?: [ 
      {
        dataId?: string(name='DataId'),
        group?: string(name='Group'),
      }
    ](name='FailData'),
    skipCount?: int32(name='SkipCount'),
    skipData?: [ 
      {
        dataId?: string(name='DataId'),
        group?: string(name='Group'),
      }
    ](name='SkipData'),
    succCount?: int32(name='SuccCount'),
  }(name='Data'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ImportNacosConfigResponse = {
  headers: map[string]string(name='headers'),
  body: ImportNacosConfigResponseBody(name='body'),
}

async function importNacosConfig(request: ImportNacosConfigRequest): ImportNacosConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ImportNacosConfig', 'POST', '/', 'json', false, 'json', request);
}

model ImportServicesRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  gatewayUniqueId?: string(name='GatewayUniqueId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  serviceList?: [ 
    {
      groupName?: string(name='GroupName'),
      ips?: [ string ](name='Ips'),
      name?: string(name='Name'),
      namespace?: string(name='Namespace'),
      servicePort?: long(name='ServicePort', description='服务的端口'),
      serviceProtocol?: string(name='ServiceProtocol', description='服务的协议版本'),
    }
  ](name='ServiceList', shrink='json', position='Query'),
  sourceType?: string(name='SourceType', description='服务来源', position='Query'),
  tlsSetting?: string(name='TlsSetting', position='Query'),
}

model ImportServicesResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model ImportServicesResponse = {
  headers: map[string]string(name='headers'),
  body: ImportServicesResponseBody(name='body'),
}

async function importServices(request: ImportServicesRequest): ImportServicesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ImportServices', 'POST', '/', 'json', false, 'json', request);
}

model ListAnsInstancesRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  clusterId?: string(name='ClusterId', position='Query'),
  clusterName?: string(name='ClusterName', position='Query'),
  groupName?: string(name='GroupName', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  namespaceId?: string(name='NamespaceId', position='Query'),
  pageNum: int32(name='PageNum', position='Query'),
  pageSize: int32(name='PageSize', position='Query'),
  requestPars?: string(name='RequestPars', position='Query'),
  serviceName: string(name='ServiceName', position='Query'),
}

model ListAnsInstancesResponseBody = {
  data?: [ 
    {
      app?: string(name='App'),
      clusterName?: string(name='ClusterName'),
      datumKey?: string(name='DatumKey'),
      defaultKey?: string(name='DefaultKey'),
      enabled?: boolean(name='Enabled'),
      ephemeral?: boolean(name='Ephemeral'),
      failCount?: int32(name='FailCount'),
      healthy?: boolean(name='Healthy'),
      instanceHeartBeatInterval?: int32(name='InstanceHeartBeatInterval'),
      instanceHeartBeatTimeOut?: int32(name='InstanceHeartBeatTimeOut'),
      instanceId?: string(name='InstanceId'),
      ip?: string(name='Ip'),
      ipDeleteTimeout?: int32(name='IpDeleteTimeout'),
      lastBeat?: long(name='LastBeat'),
      marked?: boolean(name='Marked'),
      metadata?: map[string]any(name='Metadata'),
      okCount?: int32(name='OkCount'),
      port?: int32(name='Port'),
      serviceName?: string(name='ServiceName'),
      weight?: int32(name='Weight'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListAnsInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: ListAnsInstancesResponseBody(name='body'),
}

async function listAnsInstances(request: ListAnsInstancesRequest): ListAnsInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListAnsInstances', 'GET', '/', 'json', false, 'json', request);
}

model ListAnsServiceClustersRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  clusterId?: string(name='ClusterId', position='Query'),
  clusterName?: string(name='ClusterName', position='Query'),
  groupName?: string(name='GroupName', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  namespaceId?: string(name='NamespaceId', position='Query'),
  pageNum: int32(name='PageNum', position='Query'),
  pageSize: int32(name='PageSize', position='Query'),
  requestPars?: string(name='RequestPars', position='Query'),
  serviceName?: string(name='ServiceName', position='Query'),
}

model ListAnsServiceClustersResponseBody = {
  data?: {
    clusters?: [ 
      {
        defaultCheckPort?: int32(name='DefaultCheckPort'),
        defaultPort?: int32(name='DefaultPort'),
        healthCheckerType?: string(name='HealthCheckerType'),
        metadata?: map[string]any(name='Metadata'),
        name?: string(name='Name'),
        serviceName?: string(name='ServiceName'),
        useIPPort4Check?: boolean(name='UseIPPort4Check'),
      }
    ](name='Clusters'),
    ephemeral?: boolean(name='Ephemeral'),
    groupName?: string(name='GroupName'),
    metadata?: map[string]any(name='Metadata'),
    name?: string(name='Name'),
    protectThreshold?: float(name='ProtectThreshold'),
    selectorType?: string(name='SelectorType'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListAnsServiceClustersResponse = {
  headers: map[string]string(name='headers'),
  body: ListAnsServiceClustersResponseBody(name='body'),
}

async function listAnsServiceClusters(request: ListAnsServiceClustersRequest): ListAnsServiceClustersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListAnsServiceClusters', 'GET', '/', 'json', false, 'json', request);
}

model ListAnsServicesRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  clusterId?: string(name='ClusterId', position='Query'),
  groupName?: string(name='GroupName', position='Query'),
  hasIpCount?: string(name='HasIpCount', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  namespaceId?: string(name='NamespaceId', position='Query'),
  pageNum: int32(name='PageNum', position='Query'),
  pageSize: int32(name='PageSize', position='Query'),
  requestPars?: string(name='RequestPars', position='Query'),
  serviceName?: string(name='ServiceName', position='Query'),
}

model ListAnsServicesResponseBody = {
  data?: [ 
    {
      clusterCount?: int32(name='ClusterCount'),
      groupName?: string(name='GroupName'),
      healthyInstanceCount?: int32(name='HealthyInstanceCount'),
      ipCount?: int32(name='IpCount'),
      name?: string(name='Name'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListAnsServicesResponse = {
  headers: map[string]string(name='headers'),
  body: ListAnsServicesResponseBody(name='body'),
}

async function listAnsServices(request: ListAnsServicesRequest): ListAnsServicesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListAnsServices', 'GET', '/', 'json', false, 'json', request);
}

model ListAppBySwimmingLaneGroupTagRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  groupId: long(name='GroupId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  tag: string(name='Tag', position='Query'),
}

model ListAppBySwimmingLaneGroupTagResponseBody = {
  code?: int32(name='Code', description='code仅仅用来和success同步'),
  data?: any(name='Data'),
  dynamicMessage?: string(name='DynamicMessage', description='动态错误信息中的占位符'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListAppBySwimmingLaneGroupTagResponse = {
  headers: map[string]string(name='headers'),
  body: ListAppBySwimmingLaneGroupTagResponseBody(name='body'),
}

async function listAppBySwimmingLaneGroupTag(request: ListAppBySwimmingLaneGroupTagRequest): ListAppBySwimmingLaneGroupTagResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListAppBySwimmingLaneGroupTag', 'POST', '/', 'json', false, 'json', request);
}

model ListApplicationsWithTagRulesRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  appId?: string(name='AppId', position='Query'),
  appName?: string(name='AppName', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  pageNumber: int32(name='PageNumber', position='Query'),
  pageSize: int32(name='PageSize', position='Query'),
  region: string(name='Region', position='Query'),
  source: string(name='Source', position='Query'),
}

model ListApplicationsWithTagRulesResponseBody = {
  code?: int32(name='Code'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    result?: [ 
      {
        appId?: string(name='AppId'),
        appName?: string(name='AppName'),
        routeRules?: [ 
          {
            carryData?: boolean(name='CarryData'),
            enable?: boolean(name='Enable'),
            gmtModified?: string(name='GmtModified'),
            id?: long(name='Id'),
            instanceNum?: int32(name='InstanceNum'),
            name?: string(name='Name'),
            rate?: int32(name='Rate'),
            remove?: boolean(name='Remove'),
            rules?: string(name='Rules'),
            status?: int32(name='Status'),
            tag?: string(name='Tag'),
          }
        ](name='RouteRules'),
        routeStatus?: long(name='RouteStatus'),
      }
    ](name='Result'),
    totalSize?: int32(name='TotalSize'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListApplicationsWithTagRulesResponse = {
  headers: map[string]string(name='headers'),
  body: ListApplicationsWithTagRulesResponseBody(name='body'),
}

async function listApplicationsWithTagRules(request: ListApplicationsWithTagRulesRequest): ListApplicationsWithTagRulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListApplicationsWithTagRules', 'GET', '/', 'json', false, 'json', request);
}

model ListClusterConnectionTypesRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
}

model ListClusterConnectionTypesResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      showName?: string(name='ShowName'),
    }
  ](name='Data'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListClusterConnectionTypesResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterConnectionTypesResponseBody(name='body'),
}

async function listClusterConnectionTypes(request: ListClusterConnectionTypesRequest): ListClusterConnectionTypesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListClusterConnectionTypes', 'POST', '/', 'json', false, 'json', request);
}

model ListClusterTypesRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  connectType?: string(name='ConnectType', description='网络连接类型', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  mseVersion?: string(name='MseVersion', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model ListClusterTypesResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      showName?: string(name='ShowName'),
    }
  ](name='Data'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListClusterTypesResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterTypesResponseBody(name='body'),
}

async function listClusterTypes(request: ListClusterTypesRequest): ListClusterTypesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListClusterTypes', 'POST', '/', 'json', false, 'json', request);
}

model ListClusterVersionsRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  clusterType?: string(name='ClusterType', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  mseVersion?: string(name='MseVersion', position='Query'),
}

model ListClusterVersionsResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      clusterType?: string(name='ClusterType'),
      code?: string(name='Code'),
      showName?: string(name='ShowName'),
    }
  ](name='Data'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListClusterVersionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterVersionsResponseBody(name='body'),
}

async function listClusterVersions(request: ListClusterVersionsRequest): ListClusterVersionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListClusterVersions', 'POST', '/', 'json', false, 'json', request);
}

model ListClustersRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  clusterAliasName?: string(name='ClusterAliasName', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  pageNum: int32(name='PageNum', position='Query'),
  pageSize: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  requestPars?: string(name='RequestPars', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model ListClustersResponseBody = {
  data?: [ 
    {
      appVersion?: string(name='AppVersion'),
      canUpdate?: boolean(name='CanUpdate'),
      chargeType?: string(name='ChargeType'),
      clusterAliasName?: string(name='ClusterAliasName'),
      clusterName?: string(name='ClusterName'),
      clusterType?: string(name='ClusterType'),
      createTime?: string(name='CreateTime'),
      endDate?: string(name='EndDate'),
      initStatus?: string(name='InitStatus'),
      instanceCount?: long(name='InstanceCount'),
      instanceId?: string(name='InstanceId'),
      internetAddress?: string(name='InternetAddress'),
      internetDomain?: string(name='InternetDomain'),
      intranetAddress?: string(name='IntranetAddress'),
      intranetDomain?: string(name='IntranetDomain'),
      mseVersion?: string(name='MseVersion'),
      resourceGroupId?: string(name='ResourceGroupId'),
      tags?: map[string]any(name='Tags'),
      versionCode?: string(name='VersionCode'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListClustersResponse = {
  headers: map[string]string(name='headers'),
  body: ListClustersResponseBody(name='body'),
}

async function listClusters(request: ListClustersRequest): ListClustersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListClusters', 'GET', '/', 'json', false, 'json', request);
}

model ListEngineNamespacesRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
}

model ListEngineNamespacesResponseBody = {
  data?: [ 
    {
      configCount?: int32(name='ConfigCount'),
      namespace?: string(name='Namespace'),
      namespaceDesc?: string(name='NamespaceDesc'),
      namespaceShowName?: string(name='NamespaceShowName'),
      quota?: int32(name='Quota'),
      serviceCount?: string(name='ServiceCount'),
      type?: int32(name='Type'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListEngineNamespacesResponse = {
  headers: map[string]string(name='headers'),
  body: ListEngineNamespacesResponseBody(name='body'),
}

async function listEngineNamespaces(request: ListEngineNamespacesRequest): ListEngineNamespacesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListEngineNamespaces', 'GET', '/', 'json', false, 'json', request);
}

model ListEurekaInstancesRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  clusterId?: string(name='ClusterId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  pageNum: int32(name='PageNum', position='Query'),
  pageSize: int32(name='PageSize', position='Query'),
  requestPars?: string(name='RequestPars', position='Query'),
  serviceName: string(name='ServiceName', position='Query'),
}

model ListEurekaInstancesResponseBody = {
  data?: [ 
    {
      app?: string(name='App'),
      durationInSecs?: int32(name='DurationInSecs'),
      homePageUrl?: string(name='HomePageUrl'),
      hostName?: string(name='HostName'),
      instanceId?: string(name='InstanceId'),
      ipAddr?: string(name='IpAddr'),
      lastDirtyTimestamp?: long(name='LastDirtyTimestamp'),
      lastUpdatedTimestamp?: long(name='LastUpdatedTimestamp'),
      metadata?: map[string]any(name='Metadata'),
      port?: int32(name='Port'),
      renewalIntervalInSecs?: int32(name='RenewalIntervalInSecs'),
      securePort?: int32(name='SecurePort'),
      status?: string(name='Status'),
      vipAddress?: string(name='VipAddress'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListEurekaInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: ListEurekaInstancesResponseBody(name='body'),
}

async function listEurekaInstances(request: ListEurekaInstancesRequest): ListEurekaInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListEurekaInstances', 'GET', '/', 'json', false, 'json', request);
}

model ListEurekaServicesRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  clusterId: string(name='ClusterId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  pageNum: int32(name='PageNum', position='Query'),
  pageSize: int32(name='PageSize', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  requestPars?: string(name='RequestPars', position='Query'),
}

model ListEurekaServicesResponseBody = {
  data?: [ 
    {
      instancesId?: [ string ](name='InstancesId'),
      name?: string(name='Name'),
      upStatus?: string(name='UpStatus'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListEurekaServicesResponse = {
  headers: map[string]string(name='headers'),
  body: ListEurekaServicesResponseBody(name='body'),
}

async function listEurekaServices(request: ListEurekaServicesRequest): ListEurekaServicesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListEurekaServices', 'GET', '/', 'json', false, 'json', request);
}

model ListGatewayRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  descSort?: boolean(name='DescSort', position='Query'),
  filterParams?: {
    gatewayType?: string(name='GatewayType'),
    gatewayUniqueId?: string(name='GatewayUniqueId'),
    instanceId?: string(name='InstanceId'),
    mseTag?: string(name='MseTag'),
    name?: string(name='Name'),
    vpc?: string(name='Vpc'),
  }(name='FilterParams', shrink='json', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  orderItem?: string(name='OrderItem', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
}

model ListGatewayResponseBody = {
  code?: int32(name='Code'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    result?: [ 
      {
        ahasOn?: boolean(name='AhasOn'),
        appVersion?: string(name='AppVersion'),
        armsOn?: boolean(name='ArmsOn'),
        chargeType?: string(name='ChargeType'),
        currentVersion?: string(name='CurrentVersion'),
        endDate?: string(name='EndDate'),
        gatewayType?: string(name='GatewayType'),
        gatewayUniqueId?: string(name='GatewayUniqueId'),
        gatewayVersion?: string(name='GatewayVersion'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        id?: long(name='Id'),
        initConfig?: {
          enableWaf?: boolean(name='EnableWaf'),
          supportWaf?: boolean(name='SupportWaf'),
        }(name='InitConfig'),
        instanceId?: string(name='InstanceId'),
        internetSlb?: [ 
          {
            gatewaySlbMode?: string(name='GatewaySlbMode'),
            gatewaySlbStatus?: string(name='GatewaySlbStatus'),
            internetNetworkFlow?: string(name='InternetNetworkFlow'),
            slbId?: string(name='SlbId'),
            slbIp?: string(name='SlbIp'),
            slbPort?: string(name='SlbPort'),
            slbSpec?: string(name='SlbSpec'),
            statusDesc?: string(name='StatusDesc'),
            type?: string(name='Type'),
          }
        ](name='InternetSlb'),
        latestVersion?: string(name='LatestVersion'),
        mseTag?: string(name='MseTag'),
        mustUpgrade?: boolean(name='MustUpgrade'),
        name?: string(name='Name'),
        primaryUser?: string(name='PrimaryUser'),
        region?: string(name='Region'),
        replica?: int32(name='Replica'),
        rollBack?: boolean(name='RollBack'),
        slb?: [ 
          {
            gatewaySlbMode?: string(name='GatewaySlbMode'),
            gatewaySlbStatus?: string(name='GatewaySlbStatus'),
            slbId?: string(name='SlbId'),
            slbIp?: string(name='SlbIp'),
            slbPort?: string(name='SlbPort'),
            slbSpec?: string(name='SlbSpec'),
            statusDesc?: string(name='StatusDesc'),
            type?: string(name='Type'),
          }
        ](name='Slb'),
        spec?: string(name='Spec'),
        status?: int32(name='Status'),
        statusDesc?: string(name='StatusDesc'),
        supportWasm?: boolean(name='SupportWasm'),
        tag?: string(name='Tag'),
        upgrade?: boolean(name='Upgrade'),
        vswitch2?: string(name='Vswitch2'),
      }
    ](name='Result'),
    totalSize?: long(name='TotalSize'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model ListGatewayResponse = {
  headers: map[string]string(name='headers'),
  body: ListGatewayResponseBody(name='body'),
}

async function listGateway(request: ListGatewayRequest): ListGatewayResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListGateway', 'POST', '/', 'json', false, 'json', request);
}

model ListGatewayDomainRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  gatewayUniqueId?: string(name='GatewayUniqueId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  type?: string(name='Type', position='Query'),
}

model ListGatewayDomainResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      certBeforeDate?: string(name='CertBeforeDate'),
      certIdentifier?: string(name='CertIdentifier'),
      comment?: {
        status?: string(name='Status'),
      }(name='Comment'),
      gatewayId?: long(name='GatewayId'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      http2?: string(name='Http2'),
      id?: long(name='Id'),
      mustHttps?: boolean(name='MustHttps'),
      name?: string(name='Name'),
      protocol?: string(name='Protocol'),
      status?: int32(name='Status'),
      tlsMax?: string(name='TlsMax'),
      tlsMin?: string(name='TlsMin'),
      type?: string(name='Type'),
    }
  ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model ListGatewayDomainResponse = {
  headers: map[string]string(name='headers'),
  body: ListGatewayDomainResponseBody(name='body'),
}

async function listGatewayDomain(request: ListGatewayDomainRequest): ListGatewayDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListGatewayDomain', 'POST', '/', 'json', false, 'json', request);
}

model ListGatewayRouteRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  descSort?: boolean(name='DescSort', position='Query'),
  filterParams?: {
    defaultServiceId?: long(name='DefaultServiceId'),
    domainId?: long(name='DomainId'),
    domainName?: string(name='DomainName'),
    gatewayId?: long(name='GatewayId'),
    gatewayUniqueId: string(name='GatewayUniqueId'),
    name?: string(name='Name'),
    routeOrder?: int32(name='RouteOrder'),
    status?: int32(name='Status'),
  }(name='FilterParams', shrink='json', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  orderItem?: string(name='OrderItem', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
}

model ListGatewayRouteResponseBody = {
  code?: int32(name='Code'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    result?: [ 
      {
        comment?: {
          status?: string(name='Status'),
        }(name='Comment'),
        defaultServiceId?: long(name='DefaultServiceId'),
        defaultServiceName?: string(name='DefaultServiceName'),
        destinationType?: string(name='DestinationType'),
        directResponse?: {
          body?: string(name='Body'),
          code?: int32(name='Code'),
        }(name='DirectResponse'),
        domainId?: long(name='DomainId'),
        domainIdList?: [ long ](name='DomainIdList'),
        domainName?: string(name='DomainName'),
        domainNameList?: [ string ](name='DomainNameList'),
        enableWaf?: string(name='EnableWaf'),
        fallback?: boolean(name='Fallback'),
        fallbackServices?: [ 
          {
            agreementType?: string(name='AgreementType'),
            groupName?: string(name='GroupName'),
            name?: string(name='Name'),
            namespace?: string(name='Namespace'),
            percent?: int32(name='Percent'),
            serviceId?: long(name='ServiceId'),
            serviceName?: string(name='ServiceName'),
            servicePort?: int32(name='ServicePort'),
            sourceType?: string(name='SourceType'),
            version?: string(name='Version'),
          }
        ](name='FallbackServices'),
        gatewayId?: long(name='GatewayId'),
        gatewayUniqueId?: string(name='GatewayUniqueId'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        id?: long(name='Id'),
        name?: string(name='Name'),
        predicates?: string(name='Predicates'),
        redirect?: {
          code?: int32(name='Code'),
          host?: string(name='Host'),
          path?: string(name='Path'),
        }(name='Redirect'),
        routeOrder?: int32(name='RouteOrder'),
        routePredicates?: {
          headerPredicates?: [ 
            {
              key?: string(name='Key'),
              type?: string(name='Type'),
              value?: string(name='Value'),
            }
          ](name='HeaderPredicates'),
          methodPredicates?: [ string ](name='MethodPredicates'),
          pathPredicates?: {
            ignoreCase?: boolean(name='IgnoreCase'),
            path?: string(name='Path'),
            type?: string(name='Type'),
          }(name='PathPredicates'),
          queryPredicates?: [ 
            {
              key?: string(name='Key'),
              type?: string(name='Type'),
              value?: string(name='Value'),
            }
          ](name='QueryPredicates'),
        }(name='RoutePredicates'),
        routeServices?: [ 
          {
            agreementType?: string(name='AgreementType'),
            groupName?: string(name='GroupName'),
            httpDubboTranscoder?: {
              dubboServiceGroup?: string(name='DubboServiceGroup'),
              dubboServiceName?: string(name='DubboServiceName'),
              dubboServiceVersion?: string(name='DubboServiceVersion'),
              mothedMapList?: [ 
                {
                  dubboMothedName?: string(name='DubboMothedName'),
                  httpMothed?: string(name='HttpMothed'),
                  mothedpath?: string(name='Mothedpath'),
                  paramMapsList?: [ 
                    {
                      extractKey?: string(name='ExtractKey'),
                      extractKeySpec?: string(name='ExtractKeySpec'),
                      mappingType?: string(name='MappingType'),
                    }
                  ](name='ParamMapsList'),
                  passThroughAllHeaders?: string(name='PassThroughAllHeaders'),
                  passThroughList?: [ string ](name='PassThroughList'),
                }
              ](name='MothedMapList'),
            }(name='HttpDubboTranscoder'),
            name?: string(name='Name'),
            namespace?: string(name='Namespace'),
            percent?: int32(name='Percent'),
            serviceId?: long(name='ServiceId'),
            serviceName?: string(name='ServiceName'),
            servicePort?: int32(name='ServicePort'),
            sourceType?: string(name='SourceType'),
            version?: string(name='Version'),
          }
        ](name='RouteServices'),
        services?: string(name='Services'),
        status?: int32(name='Status'),
        type?: string(name='Type'),
      }
    ](name='Result'),
    totalSize?: long(name='TotalSize'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model ListGatewayRouteResponse = {
  headers: map[string]string(name='headers'),
  body: ListGatewayRouteResponseBody(name='body'),
}

async function listGatewayRoute(request: ListGatewayRouteRequest): ListGatewayRouteResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListGatewayRoute', 'POST', '/', 'json', false, 'json', request);
}

model ListGatewayServiceRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  descSort?: boolean(name='DescSort', position='Query'),
  filterParams?: {
    gatewayUniqueId?: string(name='GatewayUniqueId'),
    groupName?: string(name='GroupName'),
    name?: string(name='Name'),
    namespace?: string(name='Namespace'),
    serviceProtocol?: string(name='ServiceProtocol'),
    sourceType?: string(name='SourceType'),
  }(name='FilterParams', shrink='json', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  orderItem?: string(name='OrderItem', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
}

model ListGatewayServiceResponseBody = {
  code?: int32(name='Code'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    result?: [ 
      {
        gatewayId?: long(name='GatewayId'),
        gatewayTrafficPolicy?: {
          loadBalancerSettings?: {
            consistentHashLBConfig?: {
              consistentHashLBType?: string(name='ConsistentHashLBType', description='HEADER, COOKIE, SOURCE_IP, QUERY_PARAMETER'),
              httpCookie?: {
                name?: string(name='Name'),
                path?: string(name='Path'),
                ttl?: string(name='Ttl'),
              }(name='HttpCookie'),
              minimumRingSize?: long(name='MinimumRingSize'),
              parameterName?: string(name='ParameterName'),
            }(name='ConsistentHashLBConfig'),
            loadbalancerType?: string(name='LoadbalancerType', description='ROUND_ROBIN, LEAST_CONN, RANDOM, CONSISTENT_HASH'),
            warmupDuration?: int32(name='WarmupDuration'),
          }(name='LoadBalancerSettings'),
          tls?: {
            caCertContent?: string(name='CaCertContent'),
            caCertId?: string(name='CaCertId'),
            certId?: string(name='CertId'),
            mode?: string(name='Mode', description='DISABLE, SIMPLE, MUTUAL, ISTIO_MUTUAL'),
            sni?: string(name='Sni'),
            subjectAltNames?: [ string ](name='SubjectAltNames'),
          }(name='Tls'),
        }(name='GatewayTrafficPolicy'),
        gatewayUniqueId?: string(name='GatewayUniqueId'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        groupName?: string(name='GroupName'),
        healehStatus?: string(name='HealehStatus'),
        healthCheck?: boolean(name='HealthCheck'),
        healthCheckInfo?: {
          check?: boolean(name='Check'),
          expectedStatuses?: [ int32 ](name='ExpectedStatuses'),
          healthyThreshold?: int32(name='HealthyThreshold'),
          httpHost?: string(name='HttpHost'),
          httpPath?: string(name='HttpPath'),
          interval?: int32(name='Interval'),
          protocol?: string(name='Protocol'),
          timeout?: int32(name='Timeout'),
          unhealthyThreshold?: int32(name='UnhealthyThreshold'),
        }(name='HealthCheckInfo'),
        healthStatus?: string(name='HealthStatus'),
        id?: long(name='Id'),
        ips?: [ string ](name='Ips'),
        metaInfo?: string(name='MetaInfo'),
        name?: string(name='Name'),
        namespace?: string(name='Namespace'),
        ports?: [ int32 ](name='Ports'),
        serviceNameInRegistry?: string(name='ServiceNameInRegistry'),
        servicePort?: long(name='ServicePort'),
        serviceProtocol?: string(name='ServiceProtocol'),
        sourceId?: long(name='SourceId'),
        sourceType?: string(name='SourceType'),
        unhealthyEndpoints?: [ string ](name='UnhealthyEndpoints'),
        versions?: [ 
          {
            name?: string(name='Name'),
          }
        ](name='Versions'),
      }
    ](name='Result'),
    totalSize?: long(name='TotalSize'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model ListGatewayServiceResponse = {
  headers: map[string]string(name='headers'),
  body: ListGatewayServiceResponseBody(name='body'),
}

async function listGatewayService(request: ListGatewayServiceRequest): ListGatewayServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListGatewayService', 'POST', '/', 'json', false, 'json', request);
}

model ListGatewaySlbRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  gatewayUniqueId?: string(name='GatewayUniqueId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
}

model ListGatewaySlbResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      editEnable?: boolean(name='EditEnable'),
      gatewayId?: string(name='GatewayId'),
      gatewaySlbMode?: string(name='GatewaySlbMode'),
      gatewaySlbStatus?: string(name='GatewaySlbStatus'),
      gmtCreate?: string(name='GmtCreate'),
      httpPort?: int32(name='HttpPort'),
      httpsPort?: int32(name='HttpsPort'),
      httpsVServerGroupId?: string(name='HttpsVServerGroupId'),
      id?: string(name='Id'),
      serviceWeight?: int32(name='ServiceWeight'),
      slbId?: string(name='SlbId'),
      slbIp?: string(name='SlbIp'),
      slbPort?: string(name='SlbPort'),
      statusDesc?: string(name='StatusDesc'),
      type?: string(name='Type'),
      vServerGroupId?: string(name='VServerGroupId'),
    }
  ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model ListGatewaySlbResponse = {
  headers: map[string]string(name='headers'),
  body: ListGatewaySlbResponseBody(name='body'),
}

async function listGatewaySlb(request: ListGatewaySlbRequest): ListGatewaySlbResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListGatewaySlb', 'POST', '/', 'json', false, 'json', request);
}

model ListInstanceCountRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  clusterType?: string(name='ClusterType', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  mseVersion?: string(name='MseVersion', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  requestPars?: string(name='RequestPars', position='Query'),
}

model ListInstanceCountResponseBody = {
  code?: int32(name='Code', description='code仅仅用来和success同步'),
  data?: [ int32 ](name='Data'),
  dynamicCode?: string(name='DynamicCode', description='动态错误信息中的占位符'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListInstanceCountResponse = {
  headers: map[string]string(name='headers'),
  body: ListInstanceCountResponseBody(name='body'),
}

async function listInstanceCount(request: ListInstanceCountRequest): ListInstanceCountResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListInstanceCount', 'POST', '/', 'json', false, 'json', request);
}

model ListInstancesRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  region: string(name='Region', position='Query'),
  userId: string(name='UserId', position='Query'),
}

model ListInstancesResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      appClusterId?: string(name='AppClusterId'),
      appVersion?: string(name='AppVersion'),
      dbPassword?: string(name='DbPassword'),
      dbUrl?: string(name='DbUrl'),
      dbUserName?: string(name='DbUserName'),
      endDate?: string(name='EndDate'),
      environmentId?: long(name='EnvironmentId'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      id?: long(name='Id'),
      imageVersion?: string(name='ImageVersion'),
      instanceId?: string(name='InstanceId'),
      isCreatedRedis?: boolean(name='IsCreatedRedis'),
      isCreatedSlb?: boolean(name='IsCreatedSlb'),
      k8sResourceId?: long(name='K8sResourceId'),
      name?: string(name='Name'),
      nameServer?: string(name='NameServer'),
      nameServerPublic?: string(name='NameServerPublic'),
      orderId?: string(name='OrderId'),
      podCidr?: string(name='PodCidr'),
      primaryUser?: string(name='PrimaryUser'),
      region?: string(name='Region'),
      replica?: long(name='Replica'),
      seataServerUniqueId?: string(name='SeataServerUniqueId'),
      securityGroup?: string(name='SecurityGroup'),
      spec?: string(name='Spec'),
      startDate?: string(name='StartDate'),
      status?: long(name='Status'),
      statusDesc?: string(name='StatusDesc'),
      storeMode?: string(name='StoreMode'),
      vpc?: string(name='Vpc'),
      vswitch?: string(name='Vswitch'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model ListInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: ListInstancesResponseBody(name='body'),
}

async function listInstances(request: ListInstancesRequest): ListInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListInstances', 'GET', '/', 'json', false, 'json', request);
}

model ListListenersByConfigRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  dataId: string(name='DataId', position='Query'),
  group: string(name='Group', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  namespaceId?: string(name='NamespaceId', position='Query'),
  requestPars?: string(name='RequestPars', position='Query'),
}

model ListListenersByConfigResponseBody = {
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  listeners?: [ 
    {
      ip?: string(name='Ip'),
      md5?: string(name='Md5'),
      status?: string(name='Status'),
    }
  ](name='Listeners'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListListenersByConfigResponse = {
  headers: map[string]string(name='headers'),
  body: ListListenersByConfigResponseBody(name='body'),
}

async function listListenersByConfig(request: ListListenersByConfigRequest): ListListenersByConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListListenersByConfig', 'POST', '/', 'json', false, 'json', request);
}

model ListListenersByIpRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  ip: string(name='Ip', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  namespaceId?: string(name='NamespaceId', position='Query'),
  requestPars?: string(name='RequestPars', position='Query'),
}

model ListListenersByIpResponseBody = {
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  listeners?: [ 
    {
      dataId?: string(name='DataId'),
      group?: string(name='Group'),
      md5?: string(name='Md5'),
    }
  ](name='Listeners'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListListenersByIpResponse = {
  headers: map[string]string(name='headers'),
  body: ListListenersByIpResponseBody(name='body'),
}

async function listListenersByIp(request: ListListenersByIpRequest): ListListenersByIpResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListListenersByIp', 'POST', '/', 'json', false, 'json', request);
}

model ListNacosConfigsRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  appName?: string(name='AppName', position='Query'),
  dataId?: string(name='DataId', position='Query'),
  group?: string(name='Group', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  namespaceId?: string(name='NamespaceId', position='Query'),
  pageNum: int32(name='PageNum', position='Query'),
  pageSize: int32(name='PageSize', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  requestPars?: string(name='RequestPars', position='Query'),
  tags?: string(name='Tags', position='Query'),
}

model ListNacosConfigsResponseBody = {
  code?: int32(name='Code'),
  configurations?: [ 
    {
      appName?: string(name='AppName'),
      dataId?: string(name='DataId'),
      group?: string(name='Group'),
      id?: string(name='Id'),
    }
  ](name='Configurations'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListNacosConfigsResponse = {
  headers: map[string]string(name='headers'),
  body: ListNacosConfigsResponseBody(name='body'),
}

async function listNacosConfigs(request: ListNacosConfigsRequest): ListNacosConfigsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListNacosConfigs', 'POST', '/', 'json', false, 'json', request);
}

model ListNacosHistoryConfigsRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  dataId?: string(name='DataId', position='Query'),
  group?: string(name='Group', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  namespaceId?: string(name='NamespaceId', position='Query'),
  pageNum: int32(name='PageNum', position='Query'),
  pageSize: int32(name='PageSize', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  requestPars?: string(name='RequestPars', position='Query'),
}

model ListNacosHistoryConfigsResponseBody = {
  errorCode?: string(name='ErrorCode'),
  historyItems?: [ 
    {
      appName?: string(name='AppName'),
      dataId?: string(name='DataId'),
      group?: string(name='Group'),
      id?: long(name='Id'),
      lastModifiedTime?: long(name='LastModifiedTime'),
      opType?: string(name='OpType'),
    }
  ](name='HistoryItems'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListNacosHistoryConfigsResponse = {
  headers: map[string]string(name='headers'),
  body: ListNacosHistoryConfigsResponseBody(name='body'),
}

async function listNacosHistoryConfigs(request: ListNacosHistoryConfigsRequest): ListNacosHistoryConfigsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListNacosHistoryConfigs', 'POST', '/', 'json', false, 'json', request);
}

model ListSSLCertRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  gatewayUniqueId?: string(name='GatewayUniqueId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
}

model ListSSLCertResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      afterDate?: string(name='AfterDate'),
      algorithm?: string(name='Algorithm'),
      beforeDate?: string(name='BeforeDate'),
      certIdentifier?: string(name='CertIdentifier'),
      certName?: string(name='CertName'),
      commonName?: string(name='CommonName'),
      gmtAfter?: string(name='GmtAfter'),
      gmtBefore?: string(name='GmtBefore'),
      issuer?: string(name='Issuer'),
      sans?: string(name='Sans'),
    }
  ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model ListSSLCertResponse = {
  headers: map[string]string(name='headers'),
  body: ListSSLCertResponseBody(name='body'),
}

async function listSSLCert(request: ListSSLCertRequest): ListSSLCertResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListSSLCert', 'POST', '/', 'json', false, 'json', request);
}

model ListSecurityGroupRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  gatewayUniqueId: string(name='GatewayUniqueId', description='网关ID', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
}

model ListSecurityGroupResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      securityGroupId?: string(name='SecurityGroupId'),
      securityGroupName?: string(name='SecurityGroupName'),
      securityGroupType?: string(name='SecurityGroupType'),
      vpcId?: string(name='VpcId'),
    }
  ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model ListSecurityGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ListSecurityGroupResponseBody(name='body'),
}

async function listSecurityGroup(request: ListSecurityGroupRequest): ListSecurityGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListSecurityGroup', 'POST', '/', 'json', false, 'json', request);
}

model ListSecurityGroupRuleRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  gatewayUniqueId: string(name='GatewayUniqueId', description='网关ID', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
}

model ListSecurityGroupRuleResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      description?: string(name='Description'),
      gatewayId?: long(name='GatewayId'),
      gatewayUniqueId?: string(name='GatewayUniqueId'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      id?: string(name='Id'),
      ipProtocol?: string(name='IpProtocol'),
      portRange?: string(name='PortRange'),
      securityGroupId?: string(name='SecurityGroupId'),
    }
  ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model ListSecurityGroupRuleResponse = {
  headers: map[string]string(name='headers'),
  body: ListSecurityGroupRuleResponseBody(name='body'),
}

async function listSecurityGroupRule(request: ListSecurityGroupRuleRequest): ListSecurityGroupRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListSecurityGroupRule', 'POST', '/', 'json', false, 'json', request);
}

model ListServiceSourceRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  gatewayUniqueId?: string(name='GatewayUniqueId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
}

model ListServiceSourceResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      address?: string(name='Address'),
      bindingWithGateway?: int32(name='BindingWithGateway'),
      gatewayId?: long(name='GatewayId'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      id?: long(name='Id'),
      ingressOptions?: {
        enableIngress?: boolean(name='EnableIngress'),
        ingressClass?: string(name='IngressClass'),
        watchNamespace?: string(name='WatchNamespace'),
      }(name='IngressOptions'),
      name?: string(name='Name'),
      source?: string(name='Source'),
      sourceUniqueId?: string(name='SourceUniqueId'),
      type?: string(name='Type'),
    }
  ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model ListServiceSourceResponse = {
  headers: map[string]string(name='headers'),
  body: ListServiceSourceResponseBody(name='body'),
}

async function listServiceSource(request: ListServiceSourceRequest): ListServiceSourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListServiceSource', 'POST', '/', 'json', false, 'json', request);
}

model ListTagResourcesRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  nextToken?: string(name='NextToken', description='下一个查询开始Token', position='Query'),
  regionId: string(name='RegionId', description='地域', position='Query'),
  resourceId?: [ string ](name='ResourceId', description='资源ID,最多 50个子项', position='Query'),
  resourceType: string(name='ResourceType', description='资源类型', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key', description='标签键'),
      value?: string(name='Value', description='标签值'),
    }
  ](name='Tag', description='标签列表，最多包含20个子项', position='Query'),
}

model ListTagResourcesResponseBody = {
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  nextToken?: string(name='NextToken', description='下一个查询开始Token，NextToken为空说明没有下一个'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  tagResources?: {
    tagResource?: [ 
    {
      resourceId?: string(name='ResourceId', description='资源ID'),
      resourceType?: string(name='ResourceType', description='资源类型'),
      tagKey?: string(name='TagKey', description='标签键'),
      tagValue?: string(name='TagValue', description='标签值'),
    }
  ](name='TagResource')
  }(name='TagResources', description='资源列表'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTagResources', 'POST', '/', 'json', false, 'json', request);
}

model ListUserInstancesRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  region: string(name='Region', position='Query'),
  userId: string(name='UserId', position='Query'),
}

model ListUserInstancesResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      appClusterId?: string(name='AppClusterId'),
      appVersion?: string(name='AppVersion'),
      dbPassword?: string(name='DbPassword'),
      dbUrl?: string(name='DbUrl'),
      dbUserName?: string(name='DbUserName'),
      endDate?: string(name='EndDate'),
      environmentId?: long(name='EnvironmentId'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      id?: long(name='Id'),
      imageVersion?: string(name='ImageVersion'),
      instanceId?: string(name='InstanceId'),
      isCreatedRedis?: boolean(name='IsCreatedRedis'),
      k8sResourceId?: long(name='K8sResourceId'),
      name?: string(name='Name'),
      nameServer?: string(name='NameServer'),
      orderId?: string(name='OrderId'),
      podCidr?: string(name='PodCidr'),
      primaryUser?: string(name='PrimaryUser'),
      region?: string(name='Region'),
      replica?: long(name='Replica'),
      seataServerUniqueId?: string(name='SeataServerUniqueId'),
      securityGroup?: string(name='SecurityGroup'),
      spec?: string(name='Spec'),
      startDate?: string(name='StartDate'),
      status?: long(name='Status'),
      statusDesc?: string(name='StatusDesc'),
      storeMode?: string(name='StoreMode'),
      vpc?: string(name='Vpc'),
      vswitch?: string(name='Vswitch'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model ListUserInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: ListUserInstancesResponseBody(name='body'),
}

async function listUserInstances(request: ListUserInstancesRequest): ListUserInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListUserInstances', 'GET', '/', 'json', false, 'json', request);
}

model ListVgroupsRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  region: string(name='Region', position='Query'),
  userId: string(name='UserId', position='Query'),
}

model ListVgroupsResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      id?: long(name='Id'),
      name?: string(name='Name'),
      nameServer?: string(name='NameServer'),
      primaryUser?: string(name='PrimaryUser'),
      region?: string(name='Region'),
      seataServerUniqueId?: string(name='SeataServerUniqueId'),
    }
  ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model ListVgroupsResponse = {
  headers: map[string]string(name='headers'),
  body: ListVgroupsResponseBody(name='body'),
}

async function listVgroups(request: ListVgroupsRequest): ListVgroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListVgroups', 'GET', '/', 'json', false, 'json', request);
}

model ListZnodeChildrenRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  clusterId: string(name='ClusterId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  path: string(name='Path', position='Query'),
}

model ListZnodeChildrenResponseBody = {
  data?: [ 
    {
      data?: string(name='Data'),
      dir?: boolean(name='Dir'),
      name?: string(name='Name'),
      path?: string(name='Path'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListZnodeChildrenResponse = {
  headers: map[string]string(name='headers'),
  body: ListZnodeChildrenResponseBody(name='body'),
}

async function listZnodeChildren(request: ListZnodeChildrenRequest): ListZnodeChildrenResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListZnodeChildren', 'GET', '/', 'json', false, 'json', request);
}

model ModifyGovernanceKubernetesClusterRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  clusterId: string(name='ClusterId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  namespaceInfos: string(name='NamespaceInfos', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ModifyGovernanceKubernetesClusterResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ModifyGovernanceKubernetesClusterResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyGovernanceKubernetesClusterResponseBody(name='body'),
}

async function modifyGovernanceKubernetesCluster(request: ModifyGovernanceKubernetesClusterRequest): ModifyGovernanceKubernetesClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyGovernanceKubernetesCluster', 'POST', '/', 'json', false, 'json', request);
}

model ModifyLosslessRuleRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  aligned: boolean(name='Aligned', description='K8s生命周期与微服务生命周期对齐', position='Query'),
  appId: string(name='AppId', description='应用id', position='Query'),
  appName?: string(name='AppName', position='Query'),
  delayTime: long(name='DelayTime', description='延迟注册时间', position='Query'),
  enable: boolean(name='Enable', position='Query'),
  funcType: long(name='FuncType', description='预热曲线斜率', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  related: boolean(name='Related', description='是否关联服务预热', position='Query'),
  shutdownWaitSeconds?: int32(name='ShutdownWaitSeconds', position='Query'),
  source?: string(name='Source', position='Query'),
  warmupTime: long(name='WarmupTime', description='预热时长', position='Query'),
}

model ModifyLosslessRuleResponseBody = {
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model ModifyLosslessRuleResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyLosslessRuleResponseBody(name='body'),
}

async function modifyLosslessRule(request: ModifyLosslessRuleRequest): ModifyLosslessRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyLosslessRule', 'POST', '/', 'json', false, 'json', request);
}

model OfflineGatewayRouteRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  gatewayUniqueId?: string(name='GatewayUniqueId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  routeId?: string(name='RouteId', position='Query'),
}

model OfflineGatewayRouteResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model OfflineGatewayRouteResponse = {
  headers: map[string]string(name='headers'),
  body: OfflineGatewayRouteResponseBody(name='body'),
}

async function offlineGatewayRoute(request: OfflineGatewayRouteRequest): OfflineGatewayRouteResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OfflineGatewayRoute', 'POST', '/', 'json', false, 'json', request);
}

model PullServicesRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  gatewayUniqueId?: string(name='GatewayUniqueId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  namespace?: string(name='Namespace', position='Query'),
  sourceType?: string(name='SourceType', position='Query'),
}

model PullServicesResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      groupName?: string(name='GroupName'),
      namespace?: string(name='Namespace'),
      namespaceShowName?: string(name='NamespaceShowName'),
      services?: [ 
        {
          groupName?: string(name='GroupName'),
          name?: string(name='Name'),
          namespace?: string(name='Namespace'),
          sourceId?: string(name='SourceId'),
          sourceType?: string(name='SourceType'),
        }
      ](name='Services'),
    }
  ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model PullServicesResponse = {
  headers: map[string]string(name='headers'),
  body: PullServicesResponseBody(name='body'),
}

async function pullServices(request: PullServicesRequest): PullServicesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PullServices', 'POST', '/', 'json', false, 'json', request);
}

model QueryAllSwimmingLaneRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  groupId: long(name='GroupId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
}

model QueryAllSwimmingLaneResponseBody = {
  code?: int32(name='Code', description='code仅仅用来和success同步'),
  data?: any(name='Data'),
  dynamicMessage?: string(name='DynamicMessage', description='动态错误信息中的占位符'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryAllSwimmingLaneResponse = {
  headers: map[string]string(name='headers'),
  body: QueryAllSwimmingLaneResponseBody(name='body'),
}

async function queryAllSwimmingLane(request: QueryAllSwimmingLaneRequest): QueryAllSwimmingLaneResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryAllSwimmingLane', 'POST', '/', 'json', false, 'json', request);
}

model QueryAllSwimmingLaneGroupRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
}

model QueryAllSwimmingLaneGroupResponseBody = {
  code?: int32(name='Code', description='code仅仅用来和success同步'),
  data?: any(name='Data'),
  dynamicMessage?: string(name='DynamicMessage', description='动态错误信息中的占位符'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryAllSwimmingLaneGroupResponse = {
  headers: map[string]string(name='headers'),
  body: QueryAllSwimmingLaneGroupResponseBody(name='body'),
}

async function queryAllSwimmingLaneGroup(request: QueryAllSwimmingLaneGroupRequest): QueryAllSwimmingLaneGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryAllSwimmingLaneGroup', 'POST', '/', 'json', false, 'json', request);
}

model QueryBusinessLocationsRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
}

model QueryBusinessLocationsResponseBody = {
  data?: [ 
    {
      cnName?: string(name='CnName'),
      description?: string(name='Description'),
      districtCnName?: string(name='DistrictCnName'),
      districtEnName?: string(name='DistrictEnName'),
      districtId?: string(name='DistrictId'),
      districtOrdering?: int32(name='DistrictOrdering'),
      districtShowName?: string(name='DistrictShowName'),
      enDescription?: string(name='EnDescription'),
      enName?: string(name='EnName'),
      name?: string(name='Name'),
      ordering?: int32(name='Ordering'),
      showName?: string(name='ShowName'),
      type?: string(name='Type'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model QueryBusinessLocationsResponse = {
  headers: map[string]string(name='headers'),
  body: QueryBusinessLocationsResponseBody(name='body'),
}

async function queryBusinessLocations(request: QueryBusinessLocationsRequest): QueryBusinessLocationsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryBusinessLocations', 'GET', '/', 'json', false, 'json', request);
}

model QueryClusterDetailRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  aclSwitch?: boolean(name='AclSwitch', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  orderId?: string(name='OrderId', position='Query'),
}

model QueryClusterDetailResponseBody = {
  data?: {
    aclEntryList?: string(name='AclEntryList'),
    aclId?: string(name='AclId'),
    appVersion?: string(name='AppVersion'),
    chargeType?: string(name='ChargeType'),
    clusterAliasName?: string(name='ClusterAliasName'),
    clusterName?: string(name='ClusterName'),
    clusterSpecification?: string(name='ClusterSpecification'),
    clusterType?: string(name='ClusterType'),
    clusterVersion?: string(name='ClusterVersion'),
    connectionType?: string(name='ConnectionType'),
    cpu?: int32(name='Cpu'),
    createTime?: string(name='CreateTime'),
    diskCapacity?: long(name='DiskCapacity'),
    diskType?: string(name='DiskType'),
    healthStatus?: string(name='HealthStatus'),
    initCostTime?: long(name='InitCostTime'),
    initStatus?: string(name='InitStatus'),
    instanceCount?: int32(name='InstanceCount'),
    instanceId?: string(name='InstanceId'),
    instanceModels?: [ 
      {
        creationTimestamp?: string(name='CreationTimestamp'),
        healthStatus?: string(name='HealthStatus'),
        internetIp?: string(name='InternetIp'),
        ip?: string(name='Ip'),
        podName?: string(name='PodName'),
        role?: string(name='Role'),
        singleTunnelVip?: string(name='SingleTunnelVip'),
        zone?: string(name='Zone'),
      }
    ](name='InstanceModels'),
    internetAddress?: string(name='InternetAddress'),
    internetDomain?: string(name='InternetDomain'),
    internetPort?: string(name='InternetPort'),
    intranetAddress?: string(name='IntranetAddress'),
    intranetDomain?: string(name='IntranetDomain'),
    intranetPort?: string(name='IntranetPort'),
    memoryCapacity?: long(name='MemoryCapacity'),
    mseVersion?: string(name='MseVersion'),
    netType?: string(name='NetType'),
    orderClusterVersion?: string(name='OrderClusterVersion'),
    payInfo?: string(name='PayInfo'),
    pubNetworkFlow?: string(name='PubNetworkFlow'),
    regionId?: string(name='RegionId'),
    resourceGroupId?: string(name='ResourceGroupId'),
    tags?: map[string]any(name='Tags'),
    vSwitchId?: string(name='VSwitchId'),
    vpcId?: string(name='VpcId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryClusterDetailResponse = {
  headers: map[string]string(name='headers'),
  body: QueryClusterDetailResponseBody(name='body'),
}

async function queryClusterDetail(request: QueryClusterDetailRequest): QueryClusterDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryClusterDetail', 'POST', '/', 'json', false, 'json', request);
}

model QueryClusterDiskSpecificationRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  clusterType?: string(name='ClusterType', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
}

model QueryClusterDiskSpecificationResponseBody = {
  code?: int32(name='Code'),
  data?: {
    max?: int32(name='Max'),
    min?: int32(name='Min'),
    step?: int32(name='Step'),
  }(name='Data'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryClusterDiskSpecificationResponse = {
  headers: map[string]string(name='headers'),
  body: QueryClusterDiskSpecificationResponseBody(name='body'),
}

async function queryClusterDiskSpecification(request: QueryClusterDiskSpecificationRequest): QueryClusterDiskSpecificationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryClusterDiskSpecification', 'POST', '/', 'json', false, 'json', request);
}

model QueryClusterSpecificationRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  connectType?: string(name='ConnectType', description='网络连接类型', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  mseVersion?: string(name='MseVersion', position='Query'),
}

model QueryClusterSpecificationResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      clusterSpecificationName?: string(name='ClusterSpecificationName'),
      cpuCapacity?: string(name='CpuCapacity'),
      diskCapacity?: string(name='DiskCapacity'),
      instanceCount?: string(name='InstanceCount'),
      maxCon?: string(name='MaxCon'),
      maxTps?: string(name='MaxTps'),
      memoryCapacity?: string(name='MemoryCapacity'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryClusterSpecificationResponse = {
  headers: map[string]string(name='headers'),
  body: QueryClusterSpecificationResponseBody(name='body'),
}

async function queryClusterSpecification(request: QueryClusterSpecificationRequest): QueryClusterSpecificationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryClusterSpecification', 'POST', '/', 'json', false, 'json', request);
}

model QueryConfigRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  clusterId?: string(name='ClusterId', position='Query'),
  configType?: string(name='ConfigType', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  requestPars?: string(name='RequestPars', position='Query'),
}

model QueryConfigResponseBody = {
  code?: int32(name='Code'),
  data?: {
    autopurgePurgeInterval?: string(name='AutopurgePurgeInterval'),
    autopurgeSnapRetainCount?: string(name='AutopurgeSnapRetainCount'),
    clusterName?: string(name='ClusterName'),
    configAuthEnabled?: boolean(name='ConfigAuthEnabled'),
    configAuthSupported?: boolean(name='ConfigAuthSupported'),
    configSecretEnabled?: boolean(name='ConfigSecretEnabled'),
    configSecretSupported?: boolean(name='ConfigSecretSupported'),
    initLimit?: string(name='InitLimit'),
    juteMaxbuffer?: string(name='JuteMaxbuffer'),
    jvmFlagsCustom?: string(name='JvmFlagsCustom'),
    MCPEnabled?: boolean(name='MCPEnabled'),
    MCPSupported?: boolean(name='MCPSupported'),
    maxClientCnxns?: string(name='MaxClientCnxns'),
    maxSessionTimeout?: string(name='MaxSessionTimeout', description='最大超时时间'),
    minSessionTimeout?: string(name='MinSessionTimeout', description='最小超时时间'),
    namingAuthEnabled?: boolean(name='NamingAuthEnabled'),
    namingAuthSupported?: boolean(name='NamingAuthSupported'),
    namingCreateServiceSupported?: boolean(name='NamingCreateServiceSupported'),
    openSuperAcl?: boolean(name='OpenSuperAcl'),
    passWord?: string(name='PassWord'),
    restartFlag?: boolean(name='RestartFlag'),
    snapshotCount?: string(name='SnapshotCount'),
    syncLimit?: string(name='SyncLimit'),
    tickTime?: string(name='TickTime'),
    userName?: string(name='UserName'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryConfigResponse = {
  headers: map[string]string(name='headers'),
  body: QueryConfigResponseBody(name='body'),
}

async function queryConfig(request: QueryConfigRequest): QueryConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryConfig', 'GET', '/', 'json', false, 'json', request);
}

model QueryGatewayRegionRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
}

model QueryGatewayRegionResponseBody = {
  code?: int32(name='Code'),
  data?: [ string ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model QueryGatewayRegionResponse = {
  headers: map[string]string(name='headers'),
  body: QueryGatewayRegionResponseBody(name='body'),
}

async function queryGatewayRegion(request: QueryGatewayRegionRequest): QueryGatewayRegionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryGatewayRegion', 'POST', '/', 'json', false, 'json', request);
}

model QueryGatewayTypeRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
}

model QueryGatewayTypeResponseBody = {
  code?: int32(name='Code'),
  data?: [ string ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model QueryGatewayTypeResponse = {
  headers: map[string]string(name='headers'),
  body: QueryGatewayTypeResponseBody(name='body'),
}

async function queryGatewayType(request: QueryGatewayTypeRequest): QueryGatewayTypeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryGatewayType', 'POST', '/', 'json', false, 'json', request);
}

model QueryGovernanceKubernetesClusterRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  clusterId?: string(name='ClusterId', description='Kubernetes集群Id', position='Query'),
  clusterName?: string(name='ClusterName', description='Kubernetes集群名', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  pageNumber: int32(name='PageNumber', description='当前页码', position='Query'),
  pageSize: int32(name='PageSize', description='每页元素数量', minimum=5, maximum=100, position='Query'),
}

model QueryGovernanceKubernetesClusterResponseBody = {
  code?: int32(name='Code', description='后端状态码'),
  data?: {
    pageNumber?: int32(name='PageNumber', description='当前页码'),
    pageSize?: int32(name='PageSize', description='页大小'),
    result?: [ 
      {
        clusterId?: string(name='ClusterId', description='Kubernetes集群Id'),
        clusterName?: string(name='ClusterName', description='Kubernetes集群名'),
        k8sVersion?: string(name='K8sVersion', description='Kubernetes集群版本'),
        namespaceInfos?: string(name='NamespaceInfos', description='Kubernetes集群命名空间信息（json格式）'),
        pilotStartTime?: string(name='PilotStartTime', description='pilot启动时间'),
        region?: string(name='Region', description='Kubernetes集群所在的地域'),
      }
    ](name='Result'),
    totalSize?: int32(name='TotalSize', description='页码总数'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success', description='是否成功'),
}

model QueryGovernanceKubernetesClusterResponse = {
  headers: map[string]string(name='headers'),
  body: QueryGovernanceKubernetesClusterResponseBody(name='body'),
}

async function queryGovernanceKubernetesCluster(request: QueryGovernanceKubernetesClusterRequest): QueryGovernanceKubernetesClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryGovernanceKubernetesCluster', 'GET', '/', 'json', false, 'json', request);
}

model QueryMonitorRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  endTime: long(name='EndTime', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  monitorType: string(name='MonitorType', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  requestPars?: string(name='RequestPars', position='Query'),
  startTime: long(name='StartTime', position='Query'),
  step?: long(name='Step', position='Query'),
}

model QueryMonitorResponseBody = {
  data?: [ 
    {
      clusterNamePrefix?: string(name='clusterNamePrefix'),
      podName?: string(name='podName'),
      values?: [  map[string]any ](name='values'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryMonitorResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMonitorResponseBody(name='body'),
}

async function queryMonitor(request: QueryMonitorRequest): QueryMonitorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryMonitor', 'GET', '/', 'json', false, 'json', request);
}

model QuerySlbSpecRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
}

model QuerySlbSpecResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      id?: int32(name='Id'),
      maxConnection?: string(name='MaxConnection'),
      name?: string(name='Name'),
      newConnectionPerSecond?: string(name='NewConnectionPerSecond'),
      qps?: string(name='Qps'),
      spec?: string(name='Spec'),
    }
  ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model QuerySlbSpecResponse = {
  headers: map[string]string(name='headers'),
  body: QuerySlbSpecResponseBody(name='body'),
}

async function querySlbSpec(request: QuerySlbSpecRequest): QuerySlbSpecResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QuerySlbSpec', 'GET', '/', 'json', false, 'json', request);
}

model QuerySwimmingLaneByIdRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  laneId: long(name='LaneId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
}

model QuerySwimmingLaneByIdResponseBody = {
  code?: int32(name='Code', description='code仅仅用来和success同步'),
  data?: any(name='Data'),
  dynamicMessage?: string(name='DynamicMessage', description='动态错误信息中的占位符'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QuerySwimmingLaneByIdResponse = {
  headers: map[string]string(name='headers'),
  body: QuerySwimmingLaneByIdResponseBody(name='body'),
}

async function querySwimmingLaneById(request: QuerySwimmingLaneByIdRequest): QuerySwimmingLaneByIdResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QuerySwimmingLaneById', 'POST', '/', 'json', false, 'json', request);
}

model QueryZnodeDetailRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  clusterId?: string(name='ClusterId', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  path: string(name='Path', position='Query'),
  requestPars?: string(name='RequestPars', position='Query'),
}

model QueryZnodeDetailResponseBody = {
  data?: {
    data?: string(name='Data'),
    dir?: boolean(name='Dir'),
    name?: string(name='Name'),
    path?: string(name='Path'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model QueryZnodeDetailResponse = {
  headers: map[string]string(name='headers'),
  body: QueryZnodeDetailResponseBody(name='body'),
}

async function queryZnodeDetail(request: QueryZnodeDetailRequest): QueryZnodeDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryZnodeDetail', 'GET', '/', 'json', false, 'json', request);
}

model RestartClusterRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  clusterId?: string(name='ClusterId', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  podNameList?: string(name='PodNameList', position='Query'),
  requestPars?: string(name='RequestPars', position='Query'),
}

model RestartClusterResponseBody = {
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RestartClusterResponse = {
  headers: map[string]string(name='headers'),
  body: RestartClusterResponseBody(name='body'),
}

async function restartCluster(request: RestartClusterRequest): RestartClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RestartCluster', 'POST', '/', 'json', false, 'json', request);
}

model RetryClusterRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  requestPars?: string(name='RequestPars', position='Query'),
}

model RetryClusterResponseBody = {
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RetryClusterResponse = {
  headers: map[string]string(name='headers'),
  body: RetryClusterResponseBody(name='body'),
}

async function retryCluster(request: RetryClusterRequest): RetryClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RetryCluster', 'POST', '/', 'json', false, 'json', request);
}

model SelectGatewaySlbRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  gatewayUniqueId?: string(name='GatewayUniqueId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  name?: string(name='Name', position='Query'),
  type?: string(name='Type', position='Query'),
}

model SelectGatewaySlbResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      slbId?: string(name='SlbId'),
      slbName?: string(name='SlbName'),
    }
  ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model SelectGatewaySlbResponse = {
  headers: map[string]string(name='headers'),
  body: SelectGatewaySlbResponseBody(name='body'),
}

async function selectGatewaySlb(request: SelectGatewaySlbRequest): SelectGatewaySlbResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SelectGatewaySlb', 'POST', '/', 'json', false, 'json', request);
}

model TagResourcesRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  regionId: string(name='RegionId', description='地域', position='Query'),
  resourceId?: [ string ](name='ResourceId', position='Query'),
  resourceType: string(name='ResourceType', description='资源类型', position='Query'),
  tag: [ 
    {
      key?: string(name='Key', description='标签键'),
      value?: string(name='Value', description='标签值'),
    }
  ](name='Tag', description='标签列表，最多包含20个子项', position='Query'),
}

model TagResourcesResponseBody = {
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'TagResources', 'POST', '/', 'json', false, 'json', request);
}

model UntagResourcesRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  all?: boolean(name='All', description='是否全部删除，只针对TagKey.N为空时有效。 取值范围： true  false True False  默认是 false', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  regionId: string(name='RegionId', description='地域', position='Query'),
  resourceId: [ string ](name='ResourceId', description='资源ID，最多50个子项', position='Query'),
  resourceType: string(name='ResourceType', description='资源类型', position='Query'),
  tagKey?: [ string ](name='TagKey', description='标签键，最多20个子项', position='Query'),
}

model UntagResourcesResponseBody = {
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UntagResources', 'POST', '/', 'json', false, 'json', request);
}

model UpdateAclRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  aclEntryList?: string(name='AclEntryList', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
}

model UpdateAclResponseBody = {
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateAclResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAclResponseBody(name='body'),
}

async function updateAcl(request: UpdateAclRequest): UpdateAclResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateAcl', 'POST', '/', 'json', false, 'json', request);
}

model UpdateBlackWhiteListRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  content?: string(name='Content', position='Query'),
  gatewayUniqueId?: string(name='GatewayUniqueId', position='Query'),
  id?: long(name='Id', position='Query'),
  isWhite?: boolean(name='IsWhite', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  name?: string(name='Name', position='Query'),
  note?: string(name='Note', position='Query'),
  resourceIdJsonList?: string(name='ResourceIdJsonList', position='Query'),
  resourceType?: string(name='ResourceType', position='Query'),
  status?: string(name='Status', position='Query'),
  type?: string(name='Type', position='Query'),
}

model UpdateBlackWhiteListResponseBody = {
  code?: int32(name='Code'),
  data?: long(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model UpdateBlackWhiteListResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateBlackWhiteListResponseBody(name='body'),
}

async function updateBlackWhiteList(request: UpdateBlackWhiteListRequest): UpdateBlackWhiteListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateBlackWhiteList', 'POST', '/', 'json', false, 'json', request);
}

model UpdateClusterRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  clusterAliasName?: string(name='ClusterAliasName', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  requestPars?: string(name='RequestPars', position='Query'),
}

model UpdateClusterResponseBody = {
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: string(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateClusterResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateClusterResponseBody(name='body'),
}

async function updateCluster(request: UpdateClusterRequest): UpdateClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateCluster', 'POST', '/', 'json', false, 'json', request);
}

model UpdateClusterSpecRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  clusterId?: string(name='ClusterId', description='网关名称', position='Query'),
  clusterSpecification: string(name='ClusterSpecification', position='Query'),
  instanceCount: int32(name='InstanceCount', description='节点数量', position='Query'),
  instanceId: string(name='InstanceId', description='节点规格', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
}

model UpdateClusterSpecResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model UpdateClusterSpecResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateClusterSpecResponseBody(name='body'),
}

async function updateClusterSpec(request: UpdateClusterSpecRequest): UpdateClusterSpecResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateClusterSpec', 'POST', '/', 'json', false, 'json', request);
}

model UpdateConfigRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  autopurgePurgeInterval?: string(name='AutopurgePurgeInterval', position='Query'),
  autopurgeSnapRetainCount?: string(name='AutopurgeSnapRetainCount', position='Query'),
  clusterId?: string(name='ClusterId', position='Query'),
  configAuthEnabled?: boolean(name='ConfigAuthEnabled', position='Query'),
  configSecretEnabled?: boolean(name='ConfigSecretEnabled', position='Query'),
  configType?: string(name='ConfigType', position='Query'),
  initLimit?: string(name='InitLimit', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  juteMaxbuffer?: string(name='JuteMaxbuffer', position='Query'),
  MCPEnabled?: boolean(name='MCPEnabled', position='Query'),
  maxClientCnxns?: string(name='MaxClientCnxns', position='Query'),
  maxSessionTimeout?: string(name='MaxSessionTimeout', description='最大超时时间', position='Query'),
  minSessionTimeout?: string(name='MinSessionTimeout', description='最小超时时间', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  namingAuthEnabled?: boolean(name='NamingAuthEnabled', position='Query'),
  openSuperAcl?: string(name='OpenSuperAcl', position='Body'),
  passWord?: string(name='PassWord', position='Query'),
  requestPars?: string(name='RequestPars', position='Query'),
  snapshotCount?: string(name='SnapshotCount', position='Query'),
  syncLimit?: string(name='SyncLimit', position='Query'),
  tickTime?: string(name='TickTime', position='Query'),
  userName?: string(name='UserName', position='Query'),
}

model UpdateConfigResponseBody = {
  code?: int32(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateConfigResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateConfigResponseBody(name='body'),
}

async function updateConfig(request: UpdateConfigRequest): UpdateConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateConfig', 'POST', '/', 'json', true, 'form', request);
}

model UpdateEngineNamespaceRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  clusterId?: string(name='ClusterId', position='Query'),
  desc?: string(name='Desc', position='Query'),
  id: string(name='Id', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  name: string(name='Name', position='Query'),
  serviceCount?: int32(name='ServiceCount', position='Query'),
}

model UpdateEngineNamespaceResponseBody = {
  data?: {
    configCount?: int32(name='ConfigCount'),
    namespace?: string(name='Namespace'),
    namespaceDesc?: string(name='NamespaceDesc'),
    namespaceShowName?: string(name='NamespaceShowName'),
    quota?: int32(name='Quota'),
    type?: int32(name='Type'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateEngineNamespaceResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateEngineNamespaceResponseBody(name='body'),
}

async function updateEngineNamespace(request: UpdateEngineNamespaceRequest): UpdateEngineNamespaceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateEngineNamespace', 'POST', '/', 'json', false, 'json', request);
}

model UpdateGatewayDomainRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  certIdentifier?: string(name='CertIdentifier', position='Query'),
  gatewayUniqueId?: string(name='GatewayUniqueId', position='Query'),
  http2?: string(name='Http2', position='Query'),
  id?: long(name='Id', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  mustHttps?: boolean(name='MustHttps', position='Query'),
  protocol?: string(name='Protocol', position='Query'),
  tlsMax?: string(name='TlsMax', position='Query'),
  tlsMin?: string(name='TlsMin', position='Query'),
}

model UpdateGatewayDomainResponseBody = {
  code?: int32(name='Code'),
  data?: long(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model UpdateGatewayDomainResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateGatewayDomainResponseBody(name='body'),
}

async function updateGatewayDomain(request: UpdateGatewayDomainRequest): UpdateGatewayDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateGatewayDomain', 'POST', '/', 'json', false, 'json', request);
}

model UpdateGatewayNameRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  gatewayUniqueId?: string(name='GatewayUniqueId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  name?: string(name='Name', position='Query'),
}

model UpdateGatewayNameResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model UpdateGatewayNameResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateGatewayNameResponseBody(name='body'),
}

async function updateGatewayName(request: UpdateGatewayNameRequest): UpdateGatewayNameResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateGatewayName', 'POST', '/', 'json', false, 'json', request);
}

model UpdateGatewayOptionRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  gatewayId?: long(name='GatewayId', position='Query'),
  gatewayOption?: GatewayOption(name='GatewayOption', shrink='json', position='Query'),
  gatewayUniqueId?: string(name='GatewayUniqueId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
}

model UpdateGatewayOptionResponseBody = {
  code?: int32(name='Code'),
  data?: GatewayOption(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model UpdateGatewayOptionResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateGatewayOptionResponseBody(name='body'),
}

async function updateGatewayOption(request: UpdateGatewayOptionRequest): UpdateGatewayOptionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateGatewayOption', 'POST', '/', 'json', false, 'json', request);
}

model UpdateGatewayRouteRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  destinationType?: string(name='DestinationType', position='Query'),
  directResponseJSON?: {
    body?: string(name='Body'),
    code?: long(name='Code'),
  }(name='DirectResponseJSON', shrink='json', position='Query'),
  domainIdListJSON?: string(name='DomainIdListJSON', position='Query'),
  enableWaf?: boolean(name='EnableWaf', position='Query'),
  fallback?: boolean(name='Fallback', position='Query'),
  fallbackServices?: [ 
    {
      agreementType?: string(name='AgreementType'),
      groupName?: string(name='GroupName'),
      name?: string(name='Name'),
      namespace?: string(name='Namespace'),
      percent?: int32(name='Percent'),
      serviceId?: long(name='ServiceId'),
      servicePort?: int32(name='ServicePort'),
      sourceType?: string(name='SourceType'),
      version?: string(name='Version'),
    }
  ](name='FallbackServices', shrink='json', position='Query'),
  gatewayId?: long(name='GatewayId', position='Query'),
  gatewayUniqueId?: string(name='GatewayUniqueId', position='Query'),
  id?: long(name='Id', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  name?: string(name='Name', position='Query'),
  predicates?: {
    headerPredicates?: [ 
      {
        key?: string(name='Key'),
        type?: string(name='Type'),
        value?: string(name='Value'),
      }
    ](name='HeaderPredicates'),
    methodPredicates?: [ string ](name='MethodPredicates'),
    pathPredicates?: {
      ignoreCase?: boolean(name='IgnoreCase'),
      path?: string(name='Path'),
      type?: string(name='Type'),
    }(name='PathPredicates'),
    queryPredicates?: [ 
      {
        key?: string(name='Key'),
        type?: string(name='Type'),
        value?: string(name='Value'),
      }
    ](name='QueryPredicates'),
  }(name='Predicates', shrink='json', position='Query'),
  redirectJSON?: {
    code?: int32(name='Code'),
    host?: string(name='Host'),
    path?: string(name='Path'),
  }(name='RedirectJSON', shrink='json', position='Query'),
  routeOrder?: int32(name='RouteOrder', position='Query'),
  services?: [ 
    {
      agreementType?: string(name='AgreementType'),
      groupName?: string(name='GroupName'),
      httpDubboTranscoder?: {
        dubboServiceGroup?: string(name='DubboServiceGroup'),
        dubboServiceName?: string(name='DubboServiceName'),
        dubboServiceVersion?: string(name='DubboServiceVersion'),
        mothedMapList?: [ 
          {
            dubboMothedName?: string(name='DubboMothedName'),
            httpMothed?: string(name='HttpMothed'),
            mothedpath?: string(name='Mothedpath'),
            paramMapsList?: [ 
              {
                extractKey?: string(name='ExtractKey'),
                extractKeySpec?: string(name='ExtractKeySpec'),
                mappingType?: string(name='MappingType'),
              }
            ](name='ParamMapsList'),
            passThroughAllHeaders?: string(name='PassThroughAllHeaders'),
            passThroughList?: [ string ](name='PassThroughList'),
          }
        ](name='MothedMapList'),
      }(name='HttpDubboTranscoder'),
      name?: string(name='Name'),
      namespace?: string(name='Namespace'),
      percent?: int32(name='Percent'),
      serviceId?: long(name='ServiceId'),
      servicePort?: int32(name='ServicePort'),
      sourceType?: string(name='SourceType'),
      version?: string(name='Version'),
    }
  ](name='Services', shrink='json', position='Query'),
}

model UpdateGatewayRouteResponseBody = {
  code?: int32(name='Code'),
  data?: long(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model UpdateGatewayRouteResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateGatewayRouteResponseBody(name='body'),
}

async function updateGatewayRoute(request: UpdateGatewayRouteRequest): UpdateGatewayRouteResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateGatewayRoute', 'POST', '/', 'json', false, 'json', request);
}

model UpdateGatewayRouteCORSRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  corsJSON?: {
    allowCredentials?: boolean(name='AllowCredentials'),
    allowHeaders?: string(name='AllowHeaders'),
    allowMethods?: string(name='AllowMethods'),
    allowOrigins?: string(name='AllowOrigins'),
    exposeHeaders?: string(name='ExposeHeaders'),
    status?: string(name='Status'),
    timeUnit?: string(name='TimeUnit'),
    unitNum?: long(name='UnitNum'),
  }(name='CorsJSON', shrink='json', position='Query'),
  gatewayId?: long(name='GatewayId', position='Query'),
  gatewayUniqueId?: string(name='GatewayUniqueId', position='Query'),
  id?: long(name='Id', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
}

model UpdateGatewayRouteCORSResponseBody = {
  code?: int32(name='Code'),
  data?: long(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model UpdateGatewayRouteCORSResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateGatewayRouteCORSResponseBody(name='body'),
}

async function updateGatewayRouteCORS(request: UpdateGatewayRouteCORSRequest): UpdateGatewayRouteCORSResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateGatewayRouteCORS', 'POST', '/', 'json', false, 'json', request);
}

model UpdateGatewayRouteHTTPRewriteRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  gatewayId?: long(name='GatewayId', position='Query'),
  gatewayUniqueId?: string(name='GatewayUniqueId', position='Query'),
  httpRewriteJSON?: string(name='HttpRewriteJSON', position='Query'),
  id?: long(name='Id', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
}

model UpdateGatewayRouteHTTPRewriteResponseBody = {
  code?: int32(name='Code'),
  data?: long(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model UpdateGatewayRouteHTTPRewriteResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateGatewayRouteHTTPRewriteResponseBody(name='body'),
}

async function updateGatewayRouteHTTPRewrite(request: UpdateGatewayRouteHTTPRewriteRequest): UpdateGatewayRouteHTTPRewriteResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateGatewayRouteHTTPRewrite', 'POST', '/', 'json', false, 'json', request);
}

model UpdateGatewayRouteHeaderOpRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  gatewayId?: long(name='GatewayId', position='Query'),
  gatewayUniqueId?: string(name='GatewayUniqueId', position='Query'),
  headerOpJSON?: string(name='HeaderOpJSON', position='Query'),
  id?: long(name='Id', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
}

model UpdateGatewayRouteHeaderOpResponseBody = {
  code?: int32(name='Code'),
  data?: long(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model UpdateGatewayRouteHeaderOpResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateGatewayRouteHeaderOpResponseBody(name='body'),
}

async function updateGatewayRouteHeaderOp(request: UpdateGatewayRouteHeaderOpRequest): UpdateGatewayRouteHeaderOpResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateGatewayRouteHeaderOp', 'POST', '/', 'json', false, 'json', request);
}

model UpdateGatewayRouteRetryRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  gatewayId?: long(name='GatewayId', position='Query'),
  gatewayUniqueId?: string(name='GatewayUniqueId', position='Query'),
  id?: long(name='Id', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  retryJSON?: {
    attempts?: int32(name='Attempts'),
    httpCodes?: [ string ](name='HttpCodes'),
    retryOn?: [ string ](name='RetryOn'),
    status?: string(name='Status'),
  }(name='RetryJSON', shrink='json', position='Query'),
}

model UpdateGatewayRouteRetryResponseBody = {
  code?: int32(name='Code'),
  data?: long(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model UpdateGatewayRouteRetryResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateGatewayRouteRetryResponseBody(name='body'),
}

async function updateGatewayRouteRetry(request: UpdateGatewayRouteRetryRequest): UpdateGatewayRouteRetryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateGatewayRouteRetry', 'POST', '/', 'json', false, 'json', request);
}

model UpdateGatewayRouteTimeoutRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  gatewayId?: long(name='GatewayId', position='Query'),
  gatewayUniqueId?: string(name='GatewayUniqueId', position='Query'),
  id?: long(name='Id', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  timeoutJSON?: {
    status?: string(name='Status'),
    timeUnit?: string(name='TimeUnit'),
    unitNum?: int32(name='UnitNum'),
  }(name='TimeoutJSON', shrink='json', position='Query'),
}

model UpdateGatewayRouteTimeoutResponseBody = {
  code?: int32(name='Code'),
  data?: long(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model UpdateGatewayRouteTimeoutResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateGatewayRouteTimeoutResponseBody(name='body'),
}

async function updateGatewayRouteTimeout(request: UpdateGatewayRouteTimeoutRequest): UpdateGatewayRouteTimeoutResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateGatewayRouteTimeout', 'POST', '/', 'json', false, 'json', request);
}

model UpdateGatewayRouteWafStatusRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  enableWaf?: boolean(name='EnableWaf', position='Query'),
  gatewayUniqueId?: string(name='GatewayUniqueId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  routeId?: long(name='RouteId', position='Query'),
}

model UpdateGatewayRouteWafStatusResponseBody = {
  code?: int32(name='Code'),
  data?: {
    cors?: {
      allowCredentials?: boolean(name='AllowCredentials'),
      allowHeaders?: string(name='AllowHeaders'),
      allowMethods?: string(name='AllowMethods'),
      allowOrigins?: string(name='AllowOrigins'),
      exposeHeaders?: string(name='ExposeHeaders'),
      status?: string(name='Status'),
      timeUnit?: string(name='TimeUnit'),
      unitNum?: long(name='UnitNum'),
    }(name='Cors'),
    defaultServiceId?: long(name='DefaultServiceId'),
    defaultServiceName?: string(name='DefaultServiceName'),
    destinationType?: string(name='DestinationType'),
    directResponse?: {
      body?: string(name='Body'),
      code?: int32(name='Code'),
    }(name='DirectResponse'),
    domainId?: long(name='DomainId'),
    domainIdList?: [ long ](name='DomainIdList'),
    domainName?: string(name='DomainName'),
    domainNameList?: [ string ](name='DomainNameList'),
    enableWaf?: boolean(name='EnableWaf'),
    gatewayId?: long(name='GatewayId'),
    gatewayUniqueId?: string(name='GatewayUniqueId'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    HTTPRewrite?: {
      host?: string(name='Host'),
      path?: string(name='Path'),
      pathType?: string(name='PathType'),
      pattern?: string(name='Pattern'),
      status?: string(name='Status'),
      substitution?: string(name='Substitution'),
    }(name='HTTPRewrite'),
    headerOp?: {
      headerOpItems?: [ 
        {
          directionType?: string(name='DirectionType'),
          key?: string(name='Key'),
          opType?: string(name='OpType'),
          value?: string(name='Value'),
        }
      ](name='HeaderOpItems'),
      status?: string(name='Status'),
    }(name='HeaderOp'),
    id?: long(name='Id'),
    name?: string(name='Name'),
    predicates?: string(name='Predicates'),
    redirect?: {
      code?: int32(name='Code'),
      host?: string(name='Host'),
      path?: string(name='Path'),
    }(name='Redirect'),
    retry?: {
      attempts?: int32(name='Attempts'),
      httpCodes?: [ string ](name='HttpCodes'),
      retryOn?: [ string ](name='RetryOn'),
      status?: string(name='Status'),
    }(name='Retry'),
    routeOrder?: int32(name='RouteOrder'),
    routePredicates?: {
      headerPredicates?: [ 
        {
          key?: string(name='Key'),
          type?: string(name='Type'),
          value?: string(name='Value'),
        }
      ](name='HeaderPredicates'),
      methodPredicates?: [ string ](name='MethodPredicates'),
      pathPredicates?: {
        ignoreCase?: boolean(name='IgnoreCase'),
        path?: string(name='Path'),
        type?: string(name='Type'),
      }(name='PathPredicates'),
      queryPredicates?: [ 
        {
          key?: string(name='Key'),
          type?: string(name='Type'),
          value?: string(name='Value'),
        }
      ](name='QueryPredicates'),
    }(name='RoutePredicates'),
    routeServices?: [ 
      {
        groupName?: string(name='GroupName'),
        name?: string(name='Name'),
        namespace?: string(name='Namespace'),
        percent?: int32(name='Percent'),
        serviceId?: long(name='ServiceId'),
        serviceName?: string(name='ServiceName'),
        sourceType?: string(name='SourceType'),
        version?: string(name='Version'),
      }
    ](name='RouteServices'),
    services?: string(name='Services'),
    status?: int32(name='Status'),
    timeout?: {
      status?: string(name='Status'),
      timeUnit?: string(name='TimeUnit'),
      unitNum?: int32(name='UnitNum'),
    }(name='Timeout'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model UpdateGatewayRouteWafStatusResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateGatewayRouteWafStatusResponseBody(name='body'),
}

async function updateGatewayRouteWafStatus(request: UpdateGatewayRouteWafStatusRequest): UpdateGatewayRouteWafStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateGatewayRouteWafStatus', 'POST', '/', 'json', false, 'json', request);
}

model UpdateGatewayServiceTrafficPolicyRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  gatewayId?: long(name='GatewayId', position='Query'),
  gatewayTrafficPolicy?: TrafficPolicy(name='GatewayTrafficPolicy', shrink='json', position='Query'),
  gatewayUniqueId?: string(name='GatewayUniqueId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  serviceId?: long(name='ServiceId', position='Query'),
}

model UpdateGatewayServiceTrafficPolicyResponseBody = {
  code?: int32(name='Code'),
  data?: GatewayService(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model UpdateGatewayServiceTrafficPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateGatewayServiceTrafficPolicyResponseBody(name='body'),
}

async function updateGatewayServiceTrafficPolicy(request: UpdateGatewayServiceTrafficPolicyRequest): UpdateGatewayServiceTrafficPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateGatewayServiceTrafficPolicy', 'POST', '/', 'json', false, 'json', request);
}

model UpdateGatewayServiceVersionRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  gatewayUniqueId?: string(name='GatewayUniqueId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  serviceId?: long(name='ServiceId', position='Query'),
  serviceVersion?: string(name='ServiceVersion', position='Query'),
}

model UpdateGatewayServiceVersionResponseBody = {
  code?: int32(name='Code'),
  data?: long(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model UpdateGatewayServiceVersionResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateGatewayServiceVersionResponseBody(name='body'),
}

async function updateGatewayServiceVersion(request: UpdateGatewayServiceVersionRequest): UpdateGatewayServiceVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateGatewayServiceVersion', 'POST', '/', 'json', false, 'json', request);
}

model UpdateGatewaySpecRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  gatewayUniqueId: string(name='GatewayUniqueId', description='网关名称', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  replica: int32(name='Replica', description='节点数量', position='Query'),
  spec: string(name='Spec', description='节点规格', position='Query'),
}

model UpdateGatewaySpecResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model UpdateGatewaySpecResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateGatewaySpecResponseBody(name='body'),
}

async function updateGatewaySpec(request: UpdateGatewaySpecRequest): UpdateGatewaySpecResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateGatewaySpec', 'POST', '/', 'json', false, 'json', request);
}

model UpdateImageRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  clusterId: string(name='ClusterId', description='目标集群的id', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  versionCode: string(name='VersionCode', description='想修改的镜像版本code', position='Query'),
}

model UpdateImageResponseBody = {
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model UpdateImageResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateImageResponseBody(name='body'),
}

async function updateImage(request: UpdateImageRequest): UpdateImageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateImage', 'POST', '/', 'json', false, 'json', request);
}

model UpdateMessageQueueRouteRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  appId?: string(name='AppId', position='Query'),
  enable?: boolean(name='Enable', position='Query'),
  filterSide?: string(name='FilterSide', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  region: string(name='Region', position='Query'),
  tags: [ string ](name='Tags', shrink='json', position='Query'),
}

model UpdateMessageQueueRouteResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateMessageQueueRouteResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateMessageQueueRouteResponseBody(name='body'),
}

async function updateMessageQueueRoute(request: UpdateMessageQueueRouteRequest): UpdateMessageQueueRouteResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateMessageQueueRoute', 'POST', '/', 'json', false, 'json', request);
}

model UpdateNacosClusterRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  checkPort?: int32(name='CheckPort', description='健康检查端口', position='Query'),
  clusterName: string(name='ClusterName', description='Nacos集群名', position='Query'),
  groupName: string(name='GroupName', description='分组名', position='Query'),
  healthChecker?: string(name='HealthChecker', description='健康检查类型', position='Query'),
  instanceId: string(name='InstanceId', description='实例id', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  namespaceId?: string(name='NamespaceId', description='命名空间id', position='Query'),
  serviceName: string(name='ServiceName', description='服务名', position='Query'),
  useInstancePortForCheck?: boolean(name='UseInstancePortForCheck', description='是否使用实例端口进行健康检查', position='Query'),
}

model UpdateNacosClusterResponseBody = {
  code?: int32(name='Code', description='响应码'),
  data?: string(name='Data', description='修改结果'),
  httpStatusCode?: int32(name='HttpStatusCode', description='http状态码'),
  message?: string(name='Message', description='响应信息'),
  requestId?: string(name='RequestId', description='请求id'),
  success?: boolean(name='Success', description='成功标志'),
}

model UpdateNacosClusterResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateNacosClusterResponseBody(name='body'),
}

async function updateNacosCluster(request: UpdateNacosClusterRequest): UpdateNacosClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateNacosCluster', 'POST', '/', 'json', false, 'json', request);
}

model UpdateNacosConfigRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  appName?: string(name='AppName', position='Query'),
  betaIps?: string(name='BetaIps', position='Query'),
  content?: string(name='Content', position='Query'),
  dataId: string(name='DataId', position='Query'),
  desc?: string(name='Desc', position='Query'),
  encryptedDataKey?: string(name='EncryptedDataKey', position='Query'),
  group: string(name='Group', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  md5?: string(name='Md5', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  namespaceId?: string(name='NamespaceId', position='Query'),
  tags?: string(name='Tags', position='Query'),
  type?: string(name='Type', position='Query'),
}

model UpdateNacosConfigResponseBody = {
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateNacosConfigResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateNacosConfigResponseBody(name='body'),
}

async function updateNacosConfig(request: UpdateNacosConfigRequest): UpdateNacosConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateNacosConfig', 'POST', '/', 'json', false, 'json', request);
}

model UpdateNacosInstanceRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  clusterName?: string(name='ClusterName', description='Nacos集群名', position='Query'),
  enabled: boolean(name='Enabled', description='服务禁用标志', position='Query'),
  ephemeral: boolean(name='Ephemeral', description='临时节点标志', position='Query'),
  groupName: string(name='GroupName', description='分组名', position='Query'),
  instanceId: string(name='InstanceId', description='实例id', position='Query'),
  ip: string(name='Ip', description='Nacos实例ip', position='Query'),
  metadata?: string(name='Metadata', description='节点元数据', position='Body'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  namespaceId?: string(name='NamespaceId', description='命名空间id', position='Query'),
  port: int32(name='Port', description='Nacos实例端口', position='Query'),
  serviceName: string(name='ServiceName', description='服务名', position='Query'),
  weight: string(name='Weight', description='权重', position='Query'),
}

model UpdateNacosInstanceResponseBody = {
  code?: int32(name='Code', description='响应码'),
  data?: string(name='Data', description='修改结果'),
  httpStatusCode?: int32(name='HttpStatusCode', description='http状态码'),
  message?: string(name='Message', description='响应信息'),
  requestId?: string(name='RequestId', description='请求id'),
  success?: boolean(name='Success', description='成功标志'),
}

model UpdateNacosInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateNacosInstanceResponseBody(name='body'),
}

async function updateNacosInstance(request: UpdateNacosInstanceRequest): UpdateNacosInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateNacosInstance', 'POST', '/', 'json', true, 'form', request);
}

model UpdateNacosServiceRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  clusterId?: string(name='ClusterId', position='Query'),
  groupName?: string(name='GroupName', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  namespaceId?: string(name='NamespaceId', position='Query'),
  protectThreshold?: string(name='ProtectThreshold', position='Query'),
  serviceName: string(name='ServiceName', position='Query'),
}

model UpdateNacosServiceResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateNacosServiceResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateNacosServiceResponseBody(name='body'),
}

async function updateNacosService(request: UpdateNacosServiceRequest): UpdateNacosServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateNacosService', 'POST', '/', 'json', false, 'json', request);
}

model UpdatePluginConfigRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  config?: string(name='Config', position='Query'),
  configLevel?: int32(name='ConfigLevel', position='Query'),
  enable?: boolean(name='Enable', position='Query'),
  gatewayId?: long(name='GatewayId', position='Query'),
  gatewayUniqueId: string(name='GatewayUniqueId', position='Query'),
  gmtCreate?: string(name='GmtCreate', position='Query'),
  gmtModified?: string(name='GmtModified', position='Query'),
  id?: long(name='Id', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  pluginId: long(name='PluginId', position='Query'),
}

model UpdatePluginConfigResponseBody = {
  code?: int32(name='Code', description='code仅仅用来和success同步'),
  data?: long(name='Data'),
  dynamicMessage?: string(name='DynamicMessage', description='动态错误信息中的占位符'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdatePluginConfigResponse = {
  headers: map[string]string(name='headers'),
  body: UpdatePluginConfigResponseBody(name='body'),
}

async function updatePluginConfig(request: UpdatePluginConfigRequest): UpdatePluginConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdatePluginConfig', 'POST', '/', 'json', false, 'json', request);
}

model UpdateSSLCertRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  certIdentifier?: string(name='CertIdentifier', position='Query'),
  domainId?: long(name='DomainId', position='Query'),
  gatewayUniqueId?: string(name='GatewayUniqueId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
}

model UpdateSSLCertResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model UpdateSSLCertResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateSSLCertResponseBody(name='body'),
}

async function updateSSLCert(request: UpdateSSLCertRequest): UpdateSSLCertResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateSSLCert', 'POST', '/', 'json', false, 'json', request);
}

model UpdateServiceSourceRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  address?: string(name='Address', position='Query'),
  gatewayId?: long(name='GatewayId', position='Query'),
  gatewayUniqueId?: string(name='GatewayUniqueId', position='Query'),
  id?: long(name='Id', position='Query'),
  ingressOptionsRequest?: {
    enableIngress?: boolean(name='EnableIngress'),
    ingressClass?: string(name='IngressClass'),
    watchNamespace?: string(name='WatchNamespace'),
  }(name='IngressOptionsRequest', shrink='json', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  name?: string(name='Name', position='Query'),
  source?: string(name='Source', position='Query'),
  type?: string(name='Type', position='Query'),
}

model UpdateServiceSourceResponseBody = {
  code?: int32(name='Code'),
  data?: long(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model UpdateServiceSourceResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateServiceSourceResponseBody(name='body'),
}

async function updateServiceSource(request: UpdateServiceSourceRequest): UpdateServiceSourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateServiceSource', 'POST', '/', 'json', false, 'json', request);
}

model UpdateZnodeRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  clusterId: string(name='ClusterId', position='Query'),
  data: string(name='Data', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  path: string(name='Path', position='Query'),
  requestPars?: string(name='RequestPars', position='Query'),
}

model UpdateZnodeResponseBody = {
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateZnodeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateZnodeResponseBody(name='body'),
}

async function updateZnode(request: UpdateZnodeRequest): UpdateZnodeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateZnode', 'POST', '/', 'json', false, 'json', request);
}

model UpgradeClusterRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  mseSessionId?: string(name='MseSessionId', position='Query'),
  requestPars?: string(name='RequestPars', position='Query'),
  upgradeVersion: string(name='UpgradeVersion', position='Query'),
}

model UpgradeClusterResponseBody = {
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpgradeClusterResponse = {
  headers: map[string]string(name='headers'),
  body: UpgradeClusterResponseBody(name='body'),
}

async function upgradeCluster(request: UpgradeClusterRequest): UpgradeClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpgradeCluster', 'POST', '/', 'json', false, 'json', request);
}

