/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('mse', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model GatewayOption {
  disableHttp2Alpn?: boolean(name='DisableHttp2Alpn', description='是否禁用http'),
  enableHardwareAcceleration?: boolean(name='EnableHardwareAcceleration', description='是否开启硬件加速'),
  logConfigDetails?: {
    logEnabled?: boolean(name='LogEnabled', description='是否开启日志投递'),
    logStoreName?: string(name='LogStoreName', description='投递的目标logstore'),
    projectName?: string(name='ProjectName', description='投递的目标project'),
  }(name='LogConfigDetails', description='日志配置详情'),
  traceDetails?: {
    sample?: long(name='Sample', description='trace 采样率'),
    traceEnabled?: boolean(name='TraceEnabled', description='trace是否开启'),
  }(name='TraceDetails', description='xtrace config option'),
}

model GatewayService {
  gatewayTrafficPolicy?: TrafficPolicy(name='GatewayTrafficPolicy', description='服务的策略'),
  gatewayUniqueId?: string(name='GatewayUniqueId', description='网关uniqueId'),
  groupName?: string(name='GroupName', description='服务所属group'),
  id?: long(name='Id', description='服务id'),
  metaInfo?: string(name='MetaInfo', description='元信息'),
  name?: string(name='Name', description='服务名'),
  namespace?: string(name='Namespace', description='服务所属namesapce'),
  sourceType?: string(name='SourceType', description='服务来源'),
}

model TrafficPolicy {
  loadBalancerSettings?: {
    consistentHashLBConfig?: {
      consistentHashLBType?: string(name='ConsistentHashLBType', description='HEADER, COOKIE, SOURCE_IP, QUERY_PARAMETER'),
      httpCookie?: {
        name?: string(name='Name', description='cookie名'),
        path?: string(name='Path', description='cookie path'),
        TTL?: string(name='TTL', description='cookie生命周期'),
      }(name='HttpCookie', description='使用cookie时配置'),
      parameterName?: string(name='ParameterName', description='使用根据header和参数路由时生效'),
    }(name='ConsistentHashLBConfig', description='一致性hash相关配置'),
    loadbalancerType?: string(name='LoadbalancerType', description='负载均衡类型，枚举类可为ROUND_ROBIN, LEAST_CONN,RANDOM, CONSISTENT_HASH'),
  }(name='LoadBalancerSettings', description='负载均衡相关配置'),
  tlsSetting?: {
    caCertContent?: string(name='CaCertContent', description='ca证书内容'),
    certId?: string(name='CertId', description='使用的证书id，仅当为mutual时需要填写'),
    sni?: string(name='Sni', description='到后端服务些带'),
    tlsMode?: string(name='TlsMode', description='tls模式。为枚举类，可为NONE, SIMPLE, MUITUAL'),
  }(name='TlsSetting', description='tls相关配置'),
}

model AddAuthResourceRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  authId?: long(name='AuthId'),
  domainId?: long(name='DomainId'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  path?: string(name='Path'),
}

model AddAuthResourceResponseBody = {
  code?: int32(name='Code'),
  data?: long(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model AddAuthResourceResponse = {
  headers: map[string]string(name='headers'),
  body: AddAuthResourceResponseBody(name='body'),
}

async function addAuthResourceWithOptions(request: AddAuthResourceRequest, runtime: Util.RuntimeOptions): AddAuthResourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.authId)) {
    query['AuthId'] = request.authId;
  }
  if (!Util.isUnset(request.domainId)) {
    query['DomainId'] = request.domainId;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.path)) {
    query['Path'] = request.path;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddAuthResource',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addAuthResource(request: AddAuthResourceRequest): AddAuthResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return addAuthResourceWithOptions(request, runtime);
}

model AddBlackWhiteListRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  content?: string(name='Content'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  isWhite?: boolean(name='IsWhite'),
  resourceType?: string(name='ResourceType'),
  status?: string(name='Status'),
  type?: string(name='Type'),
}

model AddBlackWhiteListResponseBody = {
  code?: int32(name='Code'),
  data?: long(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model AddBlackWhiteListResponse = {
  headers: map[string]string(name='headers'),
  body: AddBlackWhiteListResponseBody(name='body'),
}

async function addBlackWhiteListWithOptions(request: AddBlackWhiteListRequest, runtime: Util.RuntimeOptions): AddBlackWhiteListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.content)) {
    query['Content'] = request.content;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.isWhite)) {
    query['IsWhite'] = request.isWhite;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddBlackWhiteList',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addBlackWhiteList(request: AddBlackWhiteListRequest): AddBlackWhiteListResponse {
  var runtime = new Util.RuntimeOptions{};
  return addBlackWhiteListWithOptions(request, runtime);
}

model AddGatewayRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  enterpriseSecurityGroup?: boolean(name='EnterpriseSecurityGroup', description='是否企业安全组类型'),
  internetSlbSpec?: string(name='InternetSlbSpec', description='外网SLB规格'),
  name?: string(name='Name', description='网关名称'),
  region?: string(name='Region', description='地域'),
  replica?: int32(name='Replica', description='节点数量'),
  slbSpec?: string(name='SlbSpec', description='内网SLB规格'),
  spec?: string(name='Spec', description='节点规格'),
  vSwitchId?: string(name='VSwitchId', description='主交换机ID'),
  vSwitchId2?: string(name='VSwitchId2', description='备交换机ID'),
  vpc?: string(name='Vpc', description='专有网络ID'),
}

model AddGatewayResponseBody = {
  code?: int32(name='Code'),
  data?: {
    gatewayUniqueId?: string(name='GatewayUniqueId'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model AddGatewayResponse = {
  headers: map[string]string(name='headers'),
  body: AddGatewayResponseBody(name='body'),
}

async function addGatewayWithOptions(request: AddGatewayRequest, runtime: Util.RuntimeOptions): AddGatewayResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.enterpriseSecurityGroup)) {
    query['EnterpriseSecurityGroup'] = request.enterpriseSecurityGroup;
  }
  if (!Util.isUnset(request.internetSlbSpec)) {
    query['InternetSlbSpec'] = request.internetSlbSpec;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.replica)) {
    query['Replica'] = request.replica;
  }
  if (!Util.isUnset(request.slbSpec)) {
    query['SlbSpec'] = request.slbSpec;
  }
  if (!Util.isUnset(request.spec)) {
    query['Spec'] = request.spec;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.vSwitchId2)) {
    query['VSwitchId2'] = request.vSwitchId2;
  }
  if (!Util.isUnset(request.vpc)) {
    query['Vpc'] = request.vpc;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddGateway',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addGateway(request: AddGatewayRequest): AddGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return addGatewayWithOptions(request, runtime);
}

model AddGatewayDomainRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  certIdentifier?: string(name='CertIdentifier'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  mustHttps?: boolean(name='MustHttps'),
  name?: string(name='Name'),
  protocol?: string(name='Protocol'),
}

model AddGatewayDomainResponseBody = {
  code?: int32(name='Code'),
  data?: long(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model AddGatewayDomainResponse = {
  headers: map[string]string(name='headers'),
  body: AddGatewayDomainResponseBody(name='body'),
}

async function addGatewayDomainWithOptions(request: AddGatewayDomainRequest, runtime: Util.RuntimeOptions): AddGatewayDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.certIdentifier)) {
    query['CertIdentifier'] = request.certIdentifier;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.mustHttps)) {
    query['MustHttps'] = request.mustHttps;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.protocol)) {
    query['Protocol'] = request.protocol;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddGatewayDomain',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addGatewayDomain(request: AddGatewayDomainRequest): AddGatewayDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return addGatewayDomainWithOptions(request, runtime);
}

model AddGatewayServiceVersionRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  serviceId?: long(name='ServiceId'),
  serviceVersion?: string(name='ServiceVersion'),
}

model AddGatewayServiceVersionResponseBody = {
  code?: int32(name='Code'),
  data?: long(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model AddGatewayServiceVersionResponse = {
  headers: map[string]string(name='headers'),
  body: AddGatewayServiceVersionResponseBody(name='body'),
}

async function addGatewayServiceVersionWithOptions(request: AddGatewayServiceVersionRequest, runtime: Util.RuntimeOptions): AddGatewayServiceVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.serviceId)) {
    query['ServiceId'] = request.serviceId;
  }
  if (!Util.isUnset(request.serviceVersion)) {
    query['ServiceVersion'] = request.serviceVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddGatewayServiceVersion',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addGatewayServiceVersion(request: AddGatewayServiceVersionRequest): AddGatewayServiceVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return addGatewayServiceVersionWithOptions(request, runtime);
}

model AddGatewaySlbRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  slbId?: string(name='SlbId'),
  type?: string(name='Type'),
}

model AddGatewaySlbResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model AddGatewaySlbResponse = {
  headers: map[string]string(name='headers'),
  body: AddGatewaySlbResponseBody(name='body'),
}

async function addGatewaySlbWithOptions(request: AddGatewaySlbRequest, runtime: Util.RuntimeOptions): AddGatewaySlbResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.slbId)) {
    query['SlbId'] = request.slbId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddGatewaySlb',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addGatewaySlb(request: AddGatewaySlbRequest): AddGatewaySlbResponse {
  var runtime = new Util.RuntimeOptions{};
  return addGatewaySlbWithOptions(request, runtime);
}

model AddMockRuleRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  consumerAppIds?: string(name='ConsumerAppIds'),
  dubboMockItems?: string(name='DubboMockItems'),
  enable?: boolean(name='Enable'),
  extraJson?: string(name='ExtraJson'),
  mockType?: long(name='MockType'),
  name?: string(name='Name'),
  providerAppId?: string(name='ProviderAppId'),
  providerAppName?: string(name='ProviderAppName'),
  region?: string(name='Region'),
  scMockItems?: string(name='ScMockItems'),
  source?: string(name='Source'),
}

model AddMockRuleResponseBody = {
  code?: int32(name='Code'),
  data?: {
    accountId?: string(name='AccountId'),
    consumerAppId?: string(name='ConsumerAppId'),
    consumerAppName?: string(name='ConsumerAppName'),
    enable?: boolean(name='Enable'),
    extraJson?: string(name='ExtraJson'),
    id?: long(name='Id'),
    mockType?: long(name='MockType'),
    name?: string(name='Name'),
    namespaceId?: string(name='NamespaceId'),
    providerAppId?: string(name='ProviderAppId'),
    providerAppName?: string(name='ProviderAppName'),
    region?: string(name='Region'),
    scMockItemJson?: string(name='ScMockItemJson'),
    source?: string(name='Source'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AddMockRuleResponse = {
  headers: map[string]string(name='headers'),
  body: AddMockRuleResponseBody(name='body'),
}

async function addMockRuleWithOptions(request: AddMockRuleRequest, runtime: Util.RuntimeOptions): AddMockRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.consumerAppIds)) {
    query['ConsumerAppIds'] = request.consumerAppIds;
  }
  if (!Util.isUnset(request.dubboMockItems)) {
    query['DubboMockItems'] = request.dubboMockItems;
  }
  if (!Util.isUnset(request.enable)) {
    query['Enable'] = request.enable;
  }
  if (!Util.isUnset(request.extraJson)) {
    query['ExtraJson'] = request.extraJson;
  }
  if (!Util.isUnset(request.mockType)) {
    query['MockType'] = request.mockType;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.providerAppId)) {
    query['ProviderAppId'] = request.providerAppId;
  }
  if (!Util.isUnset(request.providerAppName)) {
    query['ProviderAppName'] = request.providerAppName;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.scMockItems)) {
    query['ScMockItems'] = request.scMockItems;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddMockRule',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addMockRule(request: AddMockRuleRequest): AddMockRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return addMockRuleWithOptions(request, runtime);
}

model AddSSLCertRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  certIdentifier?: string(name='CertIdentifier'),
  domainId?: long(name='DomainId'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
}

model AddSSLCertResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model AddSSLCertResponse = {
  headers: map[string]string(name='headers'),
  body: AddSSLCertResponseBody(name='body'),
}

async function addSSLCertWithOptions(request: AddSSLCertRequest, runtime: Util.RuntimeOptions): AddSSLCertResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddSSLCert',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addSSLCert(request: AddSSLCertRequest): AddSSLCertResponse {
  var runtime = new Util.RuntimeOptions{};
  return addSSLCertWithOptions(request, runtime);
}

model AddServiceSourceRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  address?: string(name='Address'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  name?: string(name='Name'),
  source?: string(name='Source'),
  type?: string(name='Type'),
}

model AddServiceSourceResponseBody = {
  code?: int32(name='Code'),
  data?: long(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model AddServiceSourceResponse = {
  headers: map[string]string(name='headers'),
  body: AddServiceSourceResponseBody(name='body'),
}

async function addServiceSourceWithOptions(request: AddServiceSourceRequest, runtime: Util.RuntimeOptions): AddServiceSourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.address)) {
    query['Address'] = request.address;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddServiceSource',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addServiceSource(request: AddServiceSourceRequest): AddServiceSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return addServiceSourceWithOptions(request, runtime);
}

model CloneNacosConfigRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  ids?: string(name='Ids'),
  instanceId?: string(name='InstanceId'),
  originNamespaceId?: string(name='OriginNamespaceId'),
  policy?: string(name='Policy'),
  targetNamespaceId?: string(name='TargetNamespaceId'),
}

model CloneNacosConfigResponseBody = {
  code?: int32(name='Code'),
  data?: {
    failData?: [ 
      {
        dataId?: string(name='DataId'),
        group?: string(name='Group'),
      }
    ](name='FailData'),
    skipCount?: int32(name='SkipCount'),
    skipData?: [ 
      {
        dataId?: string(name='DataId'),
        group?: string(name='Group'),
      }
    ](name='SkipData'),
    succCount?: int32(name='SuccCount'),
  }(name='Data'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CloneNacosConfigResponse = {
  headers: map[string]string(name='headers'),
  body: CloneNacosConfigResponseBody(name='body'),
}

async function cloneNacosConfigWithOptions(request: CloneNacosConfigRequest, runtime: Util.RuntimeOptions): CloneNacosConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.ids)) {
    query['Ids'] = request.ids;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.originNamespaceId)) {
    query['OriginNamespaceId'] = request.originNamespaceId;
  }
  if (!Util.isUnset(request.policy)) {
    query['Policy'] = request.policy;
  }
  if (!Util.isUnset(request.targetNamespaceId)) {
    query['TargetNamespaceId'] = request.targetNamespaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CloneNacosConfig',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cloneNacosConfig(request: CloneNacosConfigRequest): CloneNacosConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return cloneNacosConfigWithOptions(request, runtime);
}

model CreateAlarmRuleRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  aggregates?: string(name='Aggregates'),
  alarmAliasName?: string(name='AlarmAliasName'),
  alarmItem?: string(name='AlarmItem'),
  alertWay?: map[string]any(name='AlertWay'),
  contactGroupIds?: map[string]any(name='ContactGroupIds'),
  instanceId?: string(name='InstanceId'),
  NValue?: int32(name='NValue'),
  operator?: string(name='Operator'),
  value?: float(name='Value'),
}

model CreateAlarmRuleShrinkRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  aggregates?: string(name='Aggregates'),
  alarmAliasName?: string(name='AlarmAliasName'),
  alarmItem?: string(name='AlarmItem'),
  alertWayShrink?: string(name='AlertWay'),
  contactGroupIdsShrink?: string(name='ContactGroupIds'),
  instanceId?: string(name='InstanceId'),
  NValue?: int32(name='NValue'),
  operator?: string(name='Operator'),
  value?: float(name='Value'),
}

model CreateAlarmRuleResponseBody = {
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateAlarmRuleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateAlarmRuleResponseBody(name='body'),
}

async function createAlarmRuleWithOptions(tmpReq: CreateAlarmRuleRequest, runtime: Util.RuntimeOptions): CreateAlarmRuleResponse {
  Util.validateModel(tmpReq);
  var request = new CreateAlarmRuleShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.alertWay)) {
    request.alertWayShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.alertWay, 'AlertWay', 'json');
  }
  if (!Util.isUnset(tmpReq.contactGroupIds)) {
    request.contactGroupIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.contactGroupIds, 'ContactGroupIds', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.aggregates)) {
    query['Aggregates'] = request.aggregates;
  }
  if (!Util.isUnset(request.alarmAliasName)) {
    query['AlarmAliasName'] = request.alarmAliasName;
  }
  if (!Util.isUnset(request.alarmItem)) {
    query['AlarmItem'] = request.alarmItem;
  }
  if (!Util.isUnset(request.alertWayShrink)) {
    query['AlertWay'] = request.alertWayShrink;
  }
  if (!Util.isUnset(request.contactGroupIdsShrink)) {
    query['ContactGroupIds'] = request.contactGroupIdsShrink;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.NValue)) {
    query['NValue'] = request.NValue;
  }
  if (!Util.isUnset(request.operator)) {
    query['Operator'] = request.operator;
  }
  if (!Util.isUnset(request.value)) {
    query['Value'] = request.value;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateAlarmRule',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createAlarmRule(request: CreateAlarmRuleRequest): CreateAlarmRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAlarmRuleWithOptions(request, runtime);
}

model CreateApplicationRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  appName?: string(name='AppName'),
  extraInfo?: string(name='ExtraInfo'),
  language?: string(name='Language'),
  region?: string(name='Region'),
  source?: string(name='Source'),
}

model CreateApplicationResponseBody = {
  code?: int32(name='Code'),
  data?: {
    appId?: string(name='AppId'),
    appName?: string(name='AppName'),
    createTime?: long(name='CreateTime'),
    extraInfo?: string(name='ExtraInfo'),
    language?: string(name='Language'),
    licenseKey?: string(name='LicenseKey'),
    regionId?: string(name='RegionId'),
    source?: string(name='Source'),
    status?: int32(name='Status'),
    updateTime?: long(name='UpdateTime'),
    userId?: string(name='UserId'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model CreateApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: CreateApplicationResponseBody(name='body'),
}

async function createApplicationWithOptions(request: CreateApplicationRequest, runtime: Util.RuntimeOptions): CreateApplicationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.extraInfo)) {
    query['ExtraInfo'] = request.extraInfo;
  }
  if (!Util.isUnset(request.language)) {
    query['Language'] = request.language;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateApplication',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createApplication(request: CreateApplicationRequest): CreateApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return createApplicationWithOptions(request, runtime);
}

model CreateClusterRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterSpecification?: string(name='ClusterSpecification'),
  clusterType?: string(name='ClusterType'),
  clusterVersion?: string(name='ClusterVersion'),
  connectionType?: string(name='ConnectionType'),
  diskCapacity?: int32(name='DiskCapacity'),
  diskType?: string(name='DiskType'),
  instanceCount?: int32(name='InstanceCount'),
  mseVersion?: string(name='MseVersion', description='用于区分基础/专业版本'),
  netType?: string(name='NetType'),
  privateSlbSpecification?: string(name='PrivateSlbSpecification'),
  pubNetworkFlow?: string(name='PubNetworkFlow'),
  pubSlbSpecification?: string(name='PubSlbSpecification'),
  region?: string(name='Region'),
  requestPars?: string(name='RequestPars'),
  vSwitchId?: string(name='VSwitchId'),
  vpcId?: string(name='VpcId'),
}

model CreateClusterResponseBody = {
  errorCode?: string(name='ErrorCode'),
  instanceId?: string(name='InstanceId'),
  message?: string(name='Message'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateClusterResponse = {
  headers: map[string]string(name='headers'),
  body: CreateClusterResponseBody(name='body'),
}

async function createClusterWithOptions(request: CreateClusterRequest, runtime: Util.RuntimeOptions): CreateClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clusterSpecification)) {
    query['ClusterSpecification'] = request.clusterSpecification;
  }
  if (!Util.isUnset(request.clusterType)) {
    query['ClusterType'] = request.clusterType;
  }
  if (!Util.isUnset(request.clusterVersion)) {
    query['ClusterVersion'] = request.clusterVersion;
  }
  if (!Util.isUnset(request.connectionType)) {
    query['ConnectionType'] = request.connectionType;
  }
  if (!Util.isUnset(request.diskCapacity)) {
    query['DiskCapacity'] = request.diskCapacity;
  }
  if (!Util.isUnset(request.diskType)) {
    query['DiskType'] = request.diskType;
  }
  if (!Util.isUnset(request.instanceCount)) {
    query['InstanceCount'] = request.instanceCount;
  }
  if (!Util.isUnset(request.mseVersion)) {
    query['MseVersion'] = request.mseVersion;
  }
  if (!Util.isUnset(request.netType)) {
    query['NetType'] = request.netType;
  }
  if (!Util.isUnset(request.privateSlbSpecification)) {
    query['PrivateSlbSpecification'] = request.privateSlbSpecification;
  }
  if (!Util.isUnset(request.pubNetworkFlow)) {
    query['PubNetworkFlow'] = request.pubNetworkFlow;
  }
  if (!Util.isUnset(request.pubSlbSpecification)) {
    query['PubSlbSpecification'] = request.pubSlbSpecification;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.requestPars)) {
    query['RequestPars'] = request.requestPars;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateCluster',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createCluster(request: CreateClusterRequest): CreateClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return createClusterWithOptions(request, runtime);
}

model CreateEngineNamespaceRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterId?: string(name='ClusterId'),
  desc?: string(name='Desc'),
  instanceId?: string(name='InstanceId'),
  name?: string(name='Name'),
  serviceCount?: int32(name='ServiceCount'),
}

model CreateEngineNamespaceResponseBody = {
  clusterId?: string(name='ClusterId'),
  data?: {
    configCount?: int32(name='ConfigCount'),
    namespace?: string(name='Namespace'),
    namespaceDesc?: string(name='NamespaceDesc'),
    namespaceShowName?: string(name='NamespaceShowName'),
    quota?: int32(name='Quota'),
    serviceCount?: int32(name='ServiceCount'),
    type?: int32(name='Type'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateEngineNamespaceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateEngineNamespaceResponseBody(name='body'),
}

async function createEngineNamespaceWithOptions(request: CreateEngineNamespaceRequest, runtime: Util.RuntimeOptions): CreateEngineNamespaceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.desc)) {
    query['Desc'] = request.desc;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.serviceCount)) {
    query['ServiceCount'] = request.serviceCount;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateEngineNamespace',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createEngineNamespace(request: CreateEngineNamespaceRequest): CreateEngineNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createEngineNamespaceWithOptions(request, runtime);
}

model CreateNacosConfigRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  appName?: string(name='AppName'),
  betaIps?: string(name='BetaIps'),
  content?: string(name='Content'),
  dataId?: string(name='DataId'),
  desc?: string(name='Desc'),
  group?: string(name='Group'),
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
  tags?: string(name='Tags'),
  type?: string(name='Type'),
}

model CreateNacosConfigResponseBody = {
  code?: string(name='Code'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateNacosConfigResponse = {
  headers: map[string]string(name='headers'),
  body: CreateNacosConfigResponseBody(name='body'),
}

async function createNacosConfigWithOptions(request: CreateNacosConfigRequest, runtime: Util.RuntimeOptions): CreateNacosConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.betaIps)) {
    query['BetaIps'] = request.betaIps;
  }
  if (!Util.isUnset(request.content)) {
    query['Content'] = request.content;
  }
  if (!Util.isUnset(request.dataId)) {
    query['DataId'] = request.dataId;
  }
  if (!Util.isUnset(request.desc)) {
    query['Desc'] = request.desc;
  }
  if (!Util.isUnset(request.group)) {
    query['Group'] = request.group;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateNacosConfig',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createNacosConfig(request: CreateNacosConfigRequest): CreateNacosConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return createNacosConfigWithOptions(request, runtime);
}

model CreateNacosInstanceRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterName?: string(name='ClusterName', description='Nacos集群名'),
  enabled?: boolean(name='Enabled', description='服务禁用标志'),
  ephemeral?: boolean(name='Ephemeral', description='临时节点标志'),
  groupName?: string(name='GroupName', description='分组名'),
  instanceId?: string(name='InstanceId', description='实例id'),
  ip?: string(name='Ip', description='Nacos实例ip'),
  metadata?: string(name='Metadata', description='节点元数据'),
  namespaceId?: string(name='NamespaceId', description='命名空间id'),
  port?: int32(name='Port', description='Nacos实例端口'),
  serviceName?: string(name='ServiceName', description='服务名'),
  weight?: string(name='Weight', description='权重'),
}

model CreateNacosInstanceResponseBody = {
  code?: int32(name='Code', description='响应码'),
  data?: string(name='Data', description='修改结果'),
  httpStatusCode?: int32(name='HttpStatusCode', description='http状态码'),
  message?: string(name='Message', description='响应信息'),
  requestId?: string(name='RequestId', description='请求id'),
  success?: boolean(name='Success', description='成功标志'),
}

model CreateNacosInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateNacosInstanceResponseBody(name='body'),
}

async function createNacosInstanceWithOptions(request: CreateNacosInstanceRequest, runtime: Util.RuntimeOptions): CreateNacosInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.enabled)) {
    query['Enabled'] = request.enabled;
  }
  if (!Util.isUnset(request.ephemeral)) {
    query['Ephemeral'] = request.ephemeral;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ip)) {
    query['Ip'] = request.ip;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  if (!Util.isUnset(request.port)) {
    query['Port'] = request.port;
  }
  if (!Util.isUnset(request.serviceName)) {
    query['ServiceName'] = request.serviceName;
  }
  if (!Util.isUnset(request.weight)) {
    query['Weight'] = request.weight;
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.metadata)) {
    body['Metadata'] = request.metadata;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateNacosInstance',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createNacosInstance(request: CreateNacosInstanceRequest): CreateNacosInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createNacosInstanceWithOptions(request, runtime);
}

model CreateNacosServiceRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterId?: string(name='ClusterId'),
  ephemeral?: boolean(name='Ephemeral'),
  groupName?: string(name='GroupName'),
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
  protectThreshold?: string(name='ProtectThreshold'),
  serviceName?: string(name='ServiceName'),
}

model CreateNacosServiceResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateNacosServiceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateNacosServiceResponseBody(name='body'),
}

async function createNacosServiceWithOptions(request: CreateNacosServiceRequest, runtime: Util.RuntimeOptions): CreateNacosServiceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.ephemeral)) {
    query['Ephemeral'] = request.ephemeral;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  if (!Util.isUnset(request.protectThreshold)) {
    query['ProtectThreshold'] = request.protectThreshold;
  }
  if (!Util.isUnset(request.serviceName)) {
    query['ServiceName'] = request.serviceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateNacosService',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createNacosService(request: CreateNacosServiceRequest): CreateNacosServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createNacosServiceWithOptions(request, runtime);
}

model CreateOrUpdateSwimmingLaneRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  enable?: boolean(name='Enable', description='是否开启。'),
  enableRules?: boolean(name='EnableRules'),
  entryRule?: string(name='EntryRule', description='json string'),
  entryRules?: [ 
    {
      condition?: string(name='Condition'),
      enable?: boolean(name='Enable'),
      path?: string(name='Path'),
      priority?: int32(name='Priority'),
      restItems?: [ 
        {
          cond?: string(name='Cond'),
          datum?: string(name='Datum'),
          divisor?: int32(name='Divisor'),
          name?: string(name='Name'),
          nameList?: [ string ](name='NameList'),
          operator?: string(name='Operator'),
          rate?: int32(name='Rate'),
          remainder?: int32(name='Remainder'),
          type?: string(name='Type'),
          value?: string(name='Value'),
        }
      ](name='RestItems'),
    }
  ](name='EntryRules', description='SwimmingLane'),
  gmtCreate?: string(name='GmtCreate', description='创建时间'),
  gmtModified?: string(name='GmtModified', description='更新时间'),
  groupId?: long(name='GroupId', description='所属泳道组'),
  id?: long(name='Id', description='主键ID。由SP生成(数据库自增主键)。'),
  licenseKey?: string(name='LicenseKey', description='格式为UUID。比如48bd91e9-41d5-4dae-8a9a-439611742b45'),
  name?: string(name='Name', description='名称'),
  regionId?: string(name='RegionId', description='region'),
  source?: string(name='Source', description='来源。可选值为: EDAS。'),
  status?: int32(name='Status', description='0 未生效'),
  tag?: string(name='Tag', description='标识'),
  userId?: string(name='UserId', description='EDAS账号。格式为数字，比如1362469756373809。'),
}

model CreateOrUpdateSwimmingLaneResponseBody = {
  code?: int32(name='Code', description='code仅仅用来和success同步'),
  data?: any(name='Data'),
  dynamicMessage?: string(name='DynamicMessage', description='动态错误信息中的占位符'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateOrUpdateSwimmingLaneResponse = {
  headers: map[string]string(name='headers'),
  body: CreateOrUpdateSwimmingLaneResponseBody(name='body'),
}

async function createOrUpdateSwimmingLaneWithOptions(request: CreateOrUpdateSwimmingLaneRequest, runtime: Util.RuntimeOptions): CreateOrUpdateSwimmingLaneResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.enable)) {
    query['Enable'] = request.enable;
  }
  if (!Util.isUnset(request.enableRules)) {
    query['EnableRules'] = request.enableRules;
  }
  if (!Util.isUnset(request.entryRule)) {
    query['EntryRule'] = request.entryRule;
  }
  if (!Util.isUnset(request.entryRules)) {
    query['EntryRules'] = request.entryRules;
  }
  if (!Util.isUnset(request.gmtCreate)) {
    query['GmtCreate'] = request.gmtCreate;
  }
  if (!Util.isUnset(request.gmtModified)) {
    query['GmtModified'] = request.gmtModified;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.licenseKey)) {
    query['LicenseKey'] = request.licenseKey;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateOrUpdateSwimmingLane',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createOrUpdateSwimmingLane(request: CreateOrUpdateSwimmingLaneRequest): CreateOrUpdateSwimmingLaneResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOrUpdateSwimmingLaneWithOptions(request, runtime);
}

model CreateOrUpdateSwimmingLaneGroupRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  appIds?: string(name='AppIds', description='应用集合。以 "," 分割应用 id'),
  enable?: boolean(name='Enable', description='是否开启。'),
  entryApp?: string(name='EntryApp', description='入口应用。格式 "来源系统:id"，比如 EDAS:UUID 或者 CSB:UUID'),
  gmtCreate?: string(name='GmtCreate', description='创建时间'),
  gmtModified?: string(name='GmtModified', description='更新时间'),
  id?: long(name='Id', description='主键ID。由SP生成(数据库自增主键)。'),
  licenseKey?: string(name='LicenseKey', description='mse licenseKey'),
  name?: string(name='Name', description='名称'),
  region?: string(name='Region', description='region'),
  source?: string(name='Source', description='来源。可选值为: EDAS。'),
  status?: int32(name='Status', description='0 未生效'),
  userId?: string(name='UserId', description='阿里云账号。格式为数字，比如1362469756373809。'),
}

model CreateOrUpdateSwimmingLaneGroupResponseBody = {
  code?: int32(name='Code', description='code仅仅用来和success同步'),
  data?: any(name='Data'),
  dynamicMessage?: string(name='DynamicMessage', description='动态错误信息中的占位符'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateOrUpdateSwimmingLaneGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateOrUpdateSwimmingLaneGroupResponseBody(name='body'),
}

async function createOrUpdateSwimmingLaneGroupWithOptions(request: CreateOrUpdateSwimmingLaneGroupRequest, runtime: Util.RuntimeOptions): CreateOrUpdateSwimmingLaneGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.appIds)) {
    query['AppIds'] = request.appIds;
  }
  if (!Util.isUnset(request.enable)) {
    query['Enable'] = request.enable;
  }
  if (!Util.isUnset(request.entryApp)) {
    query['EntryApp'] = request.entryApp;
  }
  if (!Util.isUnset(request.gmtCreate)) {
    query['GmtCreate'] = request.gmtCreate;
  }
  if (!Util.isUnset(request.gmtModified)) {
    query['GmtModified'] = request.gmtModified;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.licenseKey)) {
    query['LicenseKey'] = request.licenseKey;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateOrUpdateSwimmingLaneGroup',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createOrUpdateSwimmingLaneGroup(request: CreateOrUpdateSwimmingLaneGroupRequest): CreateOrUpdateSwimmingLaneGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOrUpdateSwimmingLaneGroupWithOptions(request, runtime);
}

model CreateZnodeRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterId?: string(name='ClusterId'),
  data?: string(name='Data'),
  path?: string(name='Path'),
}

model CreateZnodeResponseBody = {
  data?: {
    data?: string(name='Data'),
    dir?: boolean(name='Dir'),
    name?: string(name='Name'),
    path?: string(name='Path'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateZnodeResponse = {
  headers: map[string]string(name='headers'),
  body: CreateZnodeResponseBody(name='body'),
}

async function createZnodeWithOptions(request: CreateZnodeRequest, runtime: Util.RuntimeOptions): CreateZnodeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.data)) {
    query['Data'] = request.data;
  }
  if (!Util.isUnset(request.path)) {
    query['Path'] = request.path;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateZnode',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createZnode(request: CreateZnodeRequest): CreateZnodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return createZnodeWithOptions(request, runtime);
}

model DeleteAlarmRuleRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  alarmRuleId?: string(name='AlarmRuleId'),
  requestPars?: string(name='RequestPars'),
}

model DeleteAlarmRuleResponseBody = {
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteAlarmRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAlarmRuleResponseBody(name='body'),
}

async function deleteAlarmRuleWithOptions(request: DeleteAlarmRuleRequest, runtime: Util.RuntimeOptions): DeleteAlarmRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.alarmRuleId)) {
    query['AlarmRuleId'] = request.alarmRuleId;
  }
  if (!Util.isUnset(request.requestPars)) {
    query['RequestPars'] = request.requestPars;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAlarmRule',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteAlarmRule(request: DeleteAlarmRuleRequest): DeleteAlarmRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAlarmRuleWithOptions(request, runtime);
}

model DeleteAuthResourceRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  id?: long(name='Id'),
}

model DeleteAuthResourceResponseBody = {
  code?: int32(name='Code'),
  data?: {
    authId?: long(name='AuthId'),
    domainId?: long(name='DomainId'),
    domainName?: string(name='DomainName'),
    gatewayId?: long(name='GatewayId'),
    gatewayUniqueId?: string(name='GatewayUniqueId'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    id?: long(name='Id'),
    isWhite?: boolean(name='IsWhite'),
    path?: string(name='Path'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model DeleteAuthResourceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAuthResourceResponseBody(name='body'),
}

async function deleteAuthResourceWithOptions(request: DeleteAuthResourceRequest, runtime: Util.RuntimeOptions): DeleteAuthResourceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAuthResource',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteAuthResource(request: DeleteAuthResourceRequest): DeleteAuthResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAuthResourceWithOptions(request, runtime);
}

model DeleteClusterRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  instanceId?: string(name='InstanceId'),
}

model DeleteClusterResponseBody = {
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteClusterResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteClusterResponseBody(name='body'),
}

async function deleteClusterWithOptions(request: DeleteClusterRequest, runtime: Util.RuntimeOptions): DeleteClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCluster',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteCluster(request: DeleteClusterRequest): DeleteClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteClusterWithOptions(request, runtime);
}

model DeleteEngineNamespaceRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterId?: string(name='ClusterId'),
  id?: string(name='Id'),
  instanceId?: string(name='InstanceId'),
}

model DeleteEngineNamespaceResponseBody = {
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteEngineNamespaceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteEngineNamespaceResponseBody(name='body'),
}

async function deleteEngineNamespaceWithOptions(request: DeleteEngineNamespaceRequest, runtime: Util.RuntimeOptions): DeleteEngineNamespaceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteEngineNamespace',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteEngineNamespace(request: DeleteEngineNamespaceRequest): DeleteEngineNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteEngineNamespaceWithOptions(request, runtime);
}

model DeleteGatewayRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  deleteSlb?: boolean(name='DeleteSlb'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
}

model DeleteGatewayResponseBody = {
  code?: int32(name='Code'),
  data?: {
    gatewayUniqueId?: string(name='GatewayUniqueId'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    id?: long(name='Id'),
    name?: string(name='Name'),
    primaryUser?: string(name='PrimaryUser'),
    region?: string(name='Region'),
    replica?: int32(name='Replica'),
    securityGroup?: string(name='SecurityGroup'),
    spec?: string(name='Spec'),
    status?: int32(name='Status'),
    vpc?: string(name='Vpc'),
    vswitch?: string(name='Vswitch'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model DeleteGatewayResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteGatewayResponseBody(name='body'),
}

async function deleteGatewayWithOptions(request: DeleteGatewayRequest, runtime: Util.RuntimeOptions): DeleteGatewayResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGateway',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteGateway(request: DeleteGatewayRequest): DeleteGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGatewayWithOptions(request, runtime);
}

model DeleteGatewayDomainRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  id?: string(name='Id'),
}

model DeleteGatewayDomainResponseBody = {
  code?: int32(name='Code'),
  data?: {
    certIdentifier?: int32(name='CertIdentifier'),
    gatewayId?: long(name='GatewayId'),
    gatewayUniqueId?: string(name='GatewayUniqueId'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    id?: long(name='Id'),
    mustHttps?: boolean(name='MustHttps'),
    name?: string(name='Name'),
    protocol?: string(name='Protocol'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model DeleteGatewayDomainResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteGatewayDomainResponseBody(name='body'),
}

async function deleteGatewayDomainWithOptions(request: DeleteGatewayDomainRequest, runtime: Util.RuntimeOptions): DeleteGatewayDomainResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGatewayDomain',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteGatewayDomain(request: DeleteGatewayDomainRequest): DeleteGatewayDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGatewayDomainWithOptions(request, runtime);
}

model DeleteGatewayServiceVersionRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  serviceId?: long(name='ServiceId'),
  serviceVersion?: string(name='ServiceVersion'),
}

model DeleteGatewayServiceVersionResponseBody = {
  code?: int32(name='Code'),
  data?: long(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model DeleteGatewayServiceVersionResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteGatewayServiceVersionResponseBody(name='body'),
}

async function deleteGatewayServiceVersionWithOptions(request: DeleteGatewayServiceVersionRequest, runtime: Util.RuntimeOptions): DeleteGatewayServiceVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.serviceId)) {
    query['ServiceId'] = request.serviceId;
  }
  if (!Util.isUnset(request.serviceVersion)) {
    query['ServiceVersion'] = request.serviceVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGatewayServiceVersion',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteGatewayServiceVersion(request: DeleteGatewayServiceVersionRequest): DeleteGatewayServiceVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGatewayServiceVersionWithOptions(request, runtime);
}

model DeleteGatewaySlbRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  deleteSlb?: boolean(name='DeleteSlb'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  id?: string(name='Id'),
}

model DeleteGatewaySlbResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model DeleteGatewaySlbResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteGatewaySlbResponseBody(name='body'),
}

async function deleteGatewaySlbWithOptions(request: DeleteGatewaySlbRequest, runtime: Util.RuntimeOptions): DeleteGatewaySlbResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGatewaySlb',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteGatewaySlb(request: DeleteGatewaySlbRequest): DeleteGatewaySlbResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGatewaySlbWithOptions(request, runtime);
}

model DeleteNacosConfigRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  beta?: boolean(name='Beta'),
  dataId?: string(name='DataId'),
  group?: string(name='Group'),
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
}

model DeleteNacosConfigResponseBody = {
  code?: string(name='Code'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteNacosConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteNacosConfigResponseBody(name='body'),
}

async function deleteNacosConfigWithOptions(request: DeleteNacosConfigRequest, runtime: Util.RuntimeOptions): DeleteNacosConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.beta)) {
    query['Beta'] = request.beta;
  }
  if (!Util.isUnset(request.dataId)) {
    query['DataId'] = request.dataId;
  }
  if (!Util.isUnset(request.group)) {
    query['Group'] = request.group;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteNacosConfig',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteNacosConfig(request: DeleteNacosConfigRequest): DeleteNacosConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteNacosConfigWithOptions(request, runtime);
}

model DeleteNacosConfigsRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  ids?: string(name='Ids'),
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
}

model DeleteNacosConfigsResponseBody = {
  code?: int32(name='Code'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteNacosConfigsResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteNacosConfigsResponseBody(name='body'),
}

async function deleteNacosConfigsWithOptions(request: DeleteNacosConfigsRequest, runtime: Util.RuntimeOptions): DeleteNacosConfigsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.ids)) {
    query['Ids'] = request.ids;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteNacosConfigs',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteNacosConfigs(request: DeleteNacosConfigsRequest): DeleteNacosConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteNacosConfigsWithOptions(request, runtime);
}

model DeleteNacosServiceRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  groupName?: string(name='GroupName'),
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
  serviceName?: string(name='ServiceName'),
}

model DeleteNacosServiceResponseBody = {
  code?: int32(name='Code', description='响应码'),
  data?: string(name='Data', description='删除服务的结果'),
  httpStatusCode?: int32(name='HttpStatusCode', description='http状态码'),
  message?: string(name='Message', description='响应信息'),
  requestId?: string(name='RequestId', description='请求id'),
  success?: boolean(name='Success', description='成功标志'),
}

model DeleteNacosServiceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteNacosServiceResponseBody(name='body'),
}

async function deleteNacosServiceWithOptions(request: DeleteNacosServiceRequest, runtime: Util.RuntimeOptions): DeleteNacosServiceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  if (!Util.isUnset(request.serviceName)) {
    query['ServiceName'] = request.serviceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteNacosService',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteNacosService(request: DeleteNacosServiceRequest): DeleteNacosServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteNacosServiceWithOptions(request, runtime);
}

model DeleteServiceSourceRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  sourceId?: long(name='SourceId'),
}

model DeleteServiceSourceResponseBody = {
  code?: int32(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model DeleteServiceSourceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteServiceSourceResponseBody(name='body'),
}

async function deleteServiceSourceWithOptions(request: DeleteServiceSourceRequest, runtime: Util.RuntimeOptions): DeleteServiceSourceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteServiceSource',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteServiceSource(request: DeleteServiceSourceRequest): DeleteServiceSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteServiceSourceWithOptions(request, runtime);
}

model DeleteSwimmingLaneRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  laneId?: long(name='LaneId'),
}

model DeleteSwimmingLaneResponseBody = {
  code?: int32(name='Code', description='code仅仅用来和success同步'),
  data?: any(name='Data'),
  dynamicMessage?: string(name='DynamicMessage', description='动态错误信息中的占位符'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteSwimmingLaneResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSwimmingLaneResponseBody(name='body'),
}

async function deleteSwimmingLaneWithOptions(request: DeleteSwimmingLaneRequest, runtime: Util.RuntimeOptions): DeleteSwimmingLaneResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.laneId)) {
    query['LaneId'] = request.laneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSwimmingLane',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSwimmingLane(request: DeleteSwimmingLaneRequest): DeleteSwimmingLaneResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSwimmingLaneWithOptions(request, runtime);
}

model DeleteSwimmingLaneGroupRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  groupId?: long(name='GroupId'),
}

model DeleteSwimmingLaneGroupResponseBody = {
  code?: int32(name='Code', description='code仅仅用来和success同步'),
  data?: any(name='Data'),
  dynamicMessage?: string(name='DynamicMessage', description='动态错误信息中的占位符'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteSwimmingLaneGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSwimmingLaneGroupResponseBody(name='body'),
}

async function deleteSwimmingLaneGroupWithOptions(request: DeleteSwimmingLaneGroupRequest, runtime: Util.RuntimeOptions): DeleteSwimmingLaneGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSwimmingLaneGroup',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSwimmingLaneGroup(request: DeleteSwimmingLaneGroupRequest): DeleteSwimmingLaneGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSwimmingLaneGroupWithOptions(request, runtime);
}

model DeleteZnodeRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterId?: string(name='ClusterId'),
  path?: string(name='Path'),
  requestPars?: string(name='RequestPars'),
}

model DeleteZnodeResponseBody = {
  data?: {
    data?: string(name='Data'),
    dir?: boolean(name='Dir'),
    name?: string(name='Name'),
    path?: string(name='Path'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteZnodeResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteZnodeResponseBody(name='body'),
}

async function deleteZnodeWithOptions(request: DeleteZnodeRequest, runtime: Util.RuntimeOptions): DeleteZnodeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.path)) {
    query['Path'] = request.path;
  }
  if (!Util.isUnset(request.requestPars)) {
    query['RequestPars'] = request.requestPars;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteZnode',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteZnode(request: DeleteZnodeRequest): DeleteZnodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteZnodeWithOptions(request, runtime);
}

model ExportNacosConfigRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  appName?: string(name='AppName'),
  dataId?: string(name='DataId'),
  group?: string(name='Group'),
  ids?: string(name='Ids'),
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
}

model ExportNacosConfigResponseBody = {
  code?: int32(name='Code'),
  data?: {
    url?: string(name='Url'),
  }(name='Data'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ExportNacosConfigResponse = {
  headers: map[string]string(name='headers'),
  body: ExportNacosConfigResponseBody(name='body'),
}

async function exportNacosConfigWithOptions(request: ExportNacosConfigRequest, runtime: Util.RuntimeOptions): ExportNacosConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.dataId)) {
    query['DataId'] = request.dataId;
  }
  if (!Util.isUnset(request.group)) {
    query['Group'] = request.group;
  }
  if (!Util.isUnset(request.ids)) {
    query['Ids'] = request.ids;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ExportNacosConfig',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function exportNacosConfig(request: ExportNacosConfigRequest): ExportNacosConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return exportNacosConfigWithOptions(request, runtime);
}

model GetBlackWhiteListRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  isWhite?: boolean(name='IsWhite'),
  resourceType?: string(name='ResourceType'),
  type?: string(name='Type'),
}

model GetBlackWhiteListResponseBody = {
  code?: int32(name='Code'),
  data?: {
    content?: string(name='Content'),
    gatewayId?: long(name='GatewayId'),
    gatewayUniqueId?: string(name='GatewayUniqueId'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    id?: long(name='Id'),
    isWhite?: boolean(name='IsWhite'),
    resourceId?: long(name='ResourceId'),
    resourceType?: string(name='ResourceType'),
    status?: string(name='Status'),
    type?: string(name='Type'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model GetBlackWhiteListResponse = {
  headers: map[string]string(name='headers'),
  body: GetBlackWhiteListResponseBody(name='body'),
}

async function getBlackWhiteListWithOptions(request: GetBlackWhiteListRequest, runtime: Util.RuntimeOptions): GetBlackWhiteListResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetBlackWhiteList',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getBlackWhiteList(request: GetBlackWhiteListRequest): GetBlackWhiteListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getBlackWhiteListWithOptions(request, runtime);
}

model GetEngineNamepaceRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterId?: string(name='ClusterId'),
  id?: string(name='Id'),
  instanceId?: string(name='InstanceId'),
}

model GetEngineNamepaceResponseBody = {
  configCount?: string(name='ConfigCount'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  namespace?: string(name='Namespace'),
  namespaceDesc?: string(name='NamespaceDesc'),
  namespaceShowName?: string(name='NamespaceShowName'),
  quota?: string(name='Quota'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  type?: string(name='Type'),
}

model GetEngineNamepaceResponse = {
  headers: map[string]string(name='headers'),
  body: GetEngineNamepaceResponseBody(name='body'),
}

async function getEngineNamepaceWithOptions(request: GetEngineNamepaceRequest, runtime: Util.RuntimeOptions): GetEngineNamepaceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetEngineNamepace',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getEngineNamepace(request: GetEngineNamepaceRequest): GetEngineNamepaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getEngineNamepaceWithOptions(request, runtime);
}

model GetGatewayRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
}

model GetGatewayResponseBody = {
  code?: int32(name='Code'),
  data?: {
    chargeType?: string(name='ChargeType'),
    endDate?: string(name='EndDate'),
    gatewayUniqueId?: string(name='GatewayUniqueId'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    id?: long(name='Id'),
    instanceId?: string(name='InstanceId'),
    logConfigDetails?: {
      logEnabled?: boolean(name='LogEnabled'),
      logStoreName?: string(name='LogStoreName'),
      projectName?: string(name='ProjectName'),
    }(name='LogConfigDetails'),
    name?: string(name='Name'),
    primaryUser?: string(name='PrimaryUser'),
    region?: string(name='Region'),
    replica?: int32(name='Replica'),
    securityGroup?: string(name='SecurityGroup'),
    spec?: string(name='Spec'),
    status?: int32(name='Status'),
    vpc?: string(name='Vpc'),
    vswitch?: string(name='Vswitch'),
    vswitch2?: string(name='Vswitch2'),
    xtraceDetails?: {
      sample?: int32(name='Sample'),
      traceOn?: boolean(name='TraceOn'),
    }(name='XtraceDetails'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model GetGatewayResponse = {
  headers: map[string]string(name='headers'),
  body: GetGatewayResponseBody(name='body'),
}

async function getGatewayWithOptions(request: GetGatewayRequest, runtime: Util.RuntimeOptions): GetGatewayResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetGateway',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getGateway(request: GetGatewayRequest): GetGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return getGatewayWithOptions(request, runtime);
}

model GetGatewayDomainDetailRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  id?: string(name='Id'),
}

model GetGatewayDomainDetailResponseBody = {
  code?: int32(name='Code'),
  data?: {
    afterDate?: long(name='AfterDate'),
    algorithm?: string(name='Algorithm'),
    beforeDate?: long(name='BeforeDate'),
    certIdentifier?: int32(name='CertIdentifier'),
    certName?: string(name='CertName'),
    commonName?: string(name='CommonName'),
    gatewayId?: long(name='GatewayId'),
    gatewayUniqueId?: string(name='GatewayUniqueId'),
    gmtAfter?: string(name='GmtAfter'),
    gmtBefore?: string(name='GmtBefore'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    id?: long(name='Id'),
    issuer?: string(name='Issuer'),
    mustHttps?: boolean(name='MustHttps'),
    name?: string(name='Name'),
    protocol?: string(name='Protocol'),
    sans?: string(name='Sans'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model GetGatewayDomainDetailResponse = {
  headers: map[string]string(name='headers'),
  body: GetGatewayDomainDetailResponseBody(name='body'),
}

async function getGatewayDomainDetailWithOptions(request: GetGatewayDomainDetailRequest, runtime: Util.RuntimeOptions): GetGatewayDomainDetailResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetGatewayDomainDetail',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getGatewayDomainDetail(request: GetGatewayDomainDetailRequest): GetGatewayDomainDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getGatewayDomainDetailWithOptions(request, runtime);
}

model GetGatewayOptionRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayId?: long(name='GatewayId'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
}

model GetGatewayOptionResponseBody = {
  code?: int32(name='Code'),
  data?: GatewayOption(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model GetGatewayOptionResponse = {
  headers: map[string]string(name='headers'),
  body: GetGatewayOptionResponseBody(name='body'),
}

async function getGatewayOptionWithOptions(request: GetGatewayOptionRequest, runtime: Util.RuntimeOptions): GetGatewayOptionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.gatewayId)) {
    query['GatewayId'] = request.gatewayId;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetGatewayOption',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getGatewayOption(request: GetGatewayOptionRequest): GetGatewayOptionResponse {
  var runtime = new Util.RuntimeOptions{};
  return getGatewayOptionWithOptions(request, runtime);
}

model GetGatewayServiceDetailRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  serviceId?: long(name='ServiceId'),
}

model GetGatewayServiceDetailResponseBody = {
  code?: int32(name='Code'),
  data?: {
    gatewayId?: long(name='GatewayId'),
    gatewayTrafficPolicy?: TrafficPolicy(name='GatewayTrafficPolicy'),
    gatewayUniqueId?: string(name='GatewayUniqueId'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    groupName?: string(name='GroupName'),
    id?: long(name='Id'),
    ips?: [ string ](name='Ips'),
    labelDetails?: [ 
      {
        key?: string(name='Key'),
        values?: [ string ](name='Values'),
      }
    ](name='LabelDetails'),
    metaInfo?: string(name='MetaInfo'),
    name?: string(name='Name'),
    namespace?: string(name='Namespace'),
    serviceNameInRegistry?: string(name='ServiceNameInRegistry'),
    sourceId?: long(name='SourceId'),
    sourceType?: string(name='SourceType'),
    versionDetails?: [ 
      {
        endpointNum?: int32(name='EndpointNum'),
        endpointNumPercent?: string(name='EndpointNumPercent'),
        serviceVersion?: {
          labels?: [ 
            {
              key?: string(name='Key'),
              value?: string(name='Value'),
            }
          ](name='Labels'),
          name?: string(name='Name'),
        }(name='ServiceVersion'),
      }
    ](name='VersionDetails'),
    versions?: [ 
      {
        label?: string(name='Label'),
        type?: string(name='Type'),
        value?: string(name='Value'),
      }
    ](name='Versions'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model GetGatewayServiceDetailResponse = {
  headers: map[string]string(name='headers'),
  body: GetGatewayServiceDetailResponseBody(name='body'),
}

async function getGatewayServiceDetailWithOptions(request: GetGatewayServiceDetailRequest, runtime: Util.RuntimeOptions): GetGatewayServiceDetailResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetGatewayServiceDetail',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getGatewayServiceDetail(request: GetGatewayServiceDetailRequest): GetGatewayServiceDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getGatewayServiceDetailWithOptions(request, runtime);
}

model GetGovernanceKubernetesClusterRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterId?: string(name='ClusterId'),
  regionId?: string(name='RegionId'),
}

model GetGovernanceKubernetesClusterResponseBody = {
  code?: int32(name='Code'),
  data?: {
    clusterId?: string(name='ClusterId'),
    clusterName?: string(name='ClusterName'),
    k8sVersion?: string(name='K8sVersion'),
    namespaceInfos?: string(name='NamespaceInfos'),
    namespaces?: [ 
      {
        name?: string(name='Name'),
        tags?: string(name='Tags'),
      }
    ](name='Namespaces'),
    pilotStartTime?: string(name='PilotStartTime'),
    region?: string(name='Region'),
    updateTime?: string(name='UpdateTime'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetGovernanceKubernetesClusterResponse = {
  headers: map[string]string(name='headers'),
  body: GetGovernanceKubernetesClusterResponseBody(name='body'),
}

async function getGovernanceKubernetesClusterWithOptions(request: GetGovernanceKubernetesClusterRequest, runtime: Util.RuntimeOptions): GetGovernanceKubernetesClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetGovernanceKubernetesCluster',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getGovernanceKubernetesCluster(request: GetGovernanceKubernetesClusterRequest): GetGovernanceKubernetesClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return getGovernanceKubernetesClusterWithOptions(request, runtime);
}

model GetGovernanceKubernetesClusterListRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterId?: string(name='ClusterId'),
  clusterName?: string(name='ClusterName'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model GetGovernanceKubernetesClusterListResponseBody = {
  code?: int32(name='Code'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    result?: [ 
      {
        clusterId?: string(name='ClusterId'),
        clusterName?: string(name='ClusterName'),
        k8sVersion?: string(name='K8sVersion'),
        namespaceInfos?: string(name='NamespaceInfos'),
        pilotStartTime?: string(name='PilotStartTime'),
        region?: string(name='Region'),
      }
    ](name='Result'),
    totalSize?: int32(name='TotalSize'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetGovernanceKubernetesClusterListResponse = {
  headers: map[string]string(name='headers'),
  body: GetGovernanceKubernetesClusterListResponseBody(name='body'),
}

async function getGovernanceKubernetesClusterListWithOptions(request: GetGovernanceKubernetesClusterListRequest, runtime: Util.RuntimeOptions): GetGovernanceKubernetesClusterListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetGovernanceKubernetesClusterList',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getGovernanceKubernetesClusterList(request: GetGovernanceKubernetesClusterListRequest): GetGovernanceKubernetesClusterListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getGovernanceKubernetesClusterListWithOptions(request, runtime);
}

model GetImageRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  versionCode?: string(name='VersionCode', description='集群版本'),
}

model GetImageResponseBody = {
  data?: {
    currentVersionFullShowName?: string(name='CurrentVersionFullShowName', description='当前集群镜像版本的4位全名'),
    maxVersionChangelogUrl?: string(name='MaxVersionChangelogUrl', description='可升级的最大版本变更日志url'),
    maxVersionCode?: string(name='MaxVersionCode', description='可升级的增量版本Code'),
    maxVersionFullShowName?: string(name='MaxVersionFullShowName', description='可升级的增量版本全名'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model GetImageResponse = {
  headers: map[string]string(name='headers'),
  body: GetImageResponseBody(name='body'),
}

async function getImageWithOptions(request: GetImageRequest, runtime: Util.RuntimeOptions): GetImageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.versionCode)) {
    query['VersionCode'] = request.versionCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetImage',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getImage(request: GetImageRequest): GetImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return getImageWithOptions(request, runtime);
}

model GetImportFileUrlRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  contentType?: string(name='ContentType'),
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
}

model GetImportFileUrlResponseBody = {
  code?: int32(name='Code'),
  data?: {
    url?: string(name='Url'),
  }(name='Data'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetImportFileUrlResponse = {
  headers: map[string]string(name='headers'),
  body: GetImportFileUrlResponseBody(name='body'),
}

async function getImportFileUrlWithOptions(request: GetImportFileUrlRequest, runtime: Util.RuntimeOptions): GetImportFileUrlResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.contentType)) {
    query['ContentType'] = request.contentType;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetImportFileUrl',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getImportFileUrl(request: GetImportFileUrlRequest): GetImportFileUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  return getImportFileUrlWithOptions(request, runtime);
}

model GetKubernetesSourceRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
}

model GetKubernetesSourceResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      cluster?: string(name='Cluster'),
      name?: string(name='Name'),
    }
  ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model GetKubernetesSourceResponse = {
  headers: map[string]string(name='headers'),
  body: GetKubernetesSourceResponseBody(name='body'),
}

async function getKubernetesSourceWithOptions(request: GetKubernetesSourceRequest, runtime: Util.RuntimeOptions): GetKubernetesSourceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetKubernetesSource',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getKubernetesSource(request: GetKubernetesSourceRequest): GetKubernetesSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getKubernetesSourceWithOptions(request, runtime);
}

model GetMseFeatureSwitchRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
}

model GetMseFeatureSwitchResponseBody = {
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: map[string]any(name='Result'),
  success?: boolean(name='Success'),
}

model GetMseFeatureSwitchResponse = {
  headers: map[string]string(name='headers'),
  body: GetMseFeatureSwitchResponseBody(name='body'),
}

async function getMseFeatureSwitchWithOptions(request: GetMseFeatureSwitchRequest, runtime: Util.RuntimeOptions): GetMseFeatureSwitchResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMseFeatureSwitch',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMseFeatureSwitch(request: GetMseFeatureSwitchRequest): GetMseFeatureSwitchResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMseFeatureSwitchWithOptions(request, runtime);
}

model GetMseSourceRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
}

model GetMseSourceResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      address?: string(name='Address'),
      clusterId?: string(name='ClusterId'),
      instanceId?: string(name='InstanceId'),
      name?: string(name='Name'),
      type?: string(name='Type'),
    }
  ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model GetMseSourceResponse = {
  headers: map[string]string(name='headers'),
  body: GetMseSourceResponseBody(name='body'),
}

async function getMseSourceWithOptions(request: GetMseSourceRequest, runtime: Util.RuntimeOptions): GetMseSourceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMseSource',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMseSource(request: GetMseSourceRequest): GetMseSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMseSourceWithOptions(request, runtime);
}

model GetNacosConfigRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  beta?: boolean(name='Beta'),
  dataId?: string(name='DataId'),
  group?: string(name='Group'),
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
}

model GetNacosConfigResponseBody = {
  configuration?: {
    appName?: string(name='AppName'),
    betaIps?: string(name='BetaIps'),
    content?: string(name='Content'),
    dataId?: string(name='DataId'),
    desc?: string(name='Desc'),
    encryptedDataKey?: string(name='EncryptedDataKey'),
    group?: string(name='Group'),
    md5?: string(name='Md5'),
    tags?: string(name='Tags'),
    type?: string(name='Type'),
  }(name='Configuration'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetNacosConfigResponse = {
  headers: map[string]string(name='headers'),
  body: GetNacosConfigResponseBody(name='body'),
}

async function getNacosConfigWithOptions(request: GetNacosConfigRequest, runtime: Util.RuntimeOptions): GetNacosConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.beta)) {
    query['Beta'] = request.beta;
  }
  if (!Util.isUnset(request.dataId)) {
    query['DataId'] = request.dataId;
  }
  if (!Util.isUnset(request.group)) {
    query['Group'] = request.group;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetNacosConfig',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getNacosConfig(request: GetNacosConfigRequest): GetNacosConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return getNacosConfigWithOptions(request, runtime);
}

model GetNacosHistoryConfigRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  dataId?: string(name='DataId'),
  group?: string(name='Group'),
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
  nid?: string(name='Nid'),
}

model GetNacosHistoryConfigResponseBody = {
  configuration?: {
    appName?: string(name='AppName'),
    content?: string(name='Content'),
    dataId?: string(name='DataId'),
    encryptedDataKey?: string(name='EncryptedDataKey'),
    group?: string(name='Group'),
    md5?: string(name='Md5'),
    opType?: string(name='OpType'),
  }(name='Configuration'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetNacosHistoryConfigResponse = {
  headers: map[string]string(name='headers'),
  body: GetNacosHistoryConfigResponseBody(name='body'),
}

async function getNacosHistoryConfigWithOptions(request: GetNacosHistoryConfigRequest, runtime: Util.RuntimeOptions): GetNacosHistoryConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.dataId)) {
    query['DataId'] = request.dataId;
  }
  if (!Util.isUnset(request.group)) {
    query['Group'] = request.group;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  if (!Util.isUnset(request.nid)) {
    query['Nid'] = request.nid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetNacosHistoryConfig',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getNacosHistoryConfig(request: GetNacosHistoryConfigRequest): GetNacosHistoryConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return getNacosHistoryConfigWithOptions(request, runtime);
}

model GetOverviewRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  period?: int32(name='Period'),
  region?: string(name='Region'),
}

model GetOverviewResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model GetOverviewResponse = {
  headers: map[string]string(name='headers'),
  body: GetOverviewResponseBody(name='body'),
}

async function getOverviewWithOptions(request: GetOverviewRequest, runtime: Util.RuntimeOptions): GetOverviewResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetOverview',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getOverview(request: GetOverviewRequest): GetOverviewResponse {
  var runtime = new Util.RuntimeOptions{};
  return getOverviewWithOptions(request, runtime);
}

model GetTagsBySwimmingLaneGroupIdRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  groupId?: long(name='GroupId'),
}

model GetTagsBySwimmingLaneGroupIdResponseBody = {
  code?: int32(name='Code', description='code仅仅用来和success同步'),
  data?: any(name='Data'),
  dynamicMessage?: string(name='DynamicMessage', description='动态错误信息中的占位符'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetTagsBySwimmingLaneGroupIdResponse = {
  headers: map[string]string(name='headers'),
  body: GetTagsBySwimmingLaneGroupIdResponseBody(name='body'),
}

async function getTagsBySwimmingLaneGroupIdWithOptions(request: GetTagsBySwimmingLaneGroupIdRequest, runtime: Util.RuntimeOptions): GetTagsBySwimmingLaneGroupIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTagsBySwimmingLaneGroupId',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTagsBySwimmingLaneGroupId(request: GetTagsBySwimmingLaneGroupIdRequest): GetTagsBySwimmingLaneGroupIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTagsBySwimmingLaneGroupIdWithOptions(request, runtime);
}

model ImportNacosConfigRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  fileUrl?: string(name='FileUrl'),
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
  policy?: string(name='Policy'),
}

model ImportNacosConfigResponseBody = {
  code?: int32(name='Code'),
  data?: {
    failData?: [ 
      {
        dataId?: string(name='DataId'),
        group?: string(name='Group'),
      }
    ](name='FailData'),
    skipCount?: int32(name='SkipCount'),
    skipData?: [ 
      {
        dataId?: string(name='DataId'),
        group?: string(name='Group'),
      }
    ](name='SkipData'),
    succCount?: int32(name='SuccCount'),
  }(name='Data'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ImportNacosConfigResponse = {
  headers: map[string]string(name='headers'),
  body: ImportNacosConfigResponseBody(name='body'),
}

async function importNacosConfigWithOptions(request: ImportNacosConfigRequest, runtime: Util.RuntimeOptions): ImportNacosConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.fileUrl)) {
    query['FileUrl'] = request.fileUrl;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  if (!Util.isUnset(request.policy)) {
    query['Policy'] = request.policy;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ImportNacosConfig',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function importNacosConfig(request: ImportNacosConfigRequest): ImportNacosConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return importNacosConfigWithOptions(request, runtime);
}

model ImportServicesRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  serviceList?: [ 
    {
      groupName?: string(name='GroupName'),
      ips?: [ string ](name='Ips'),
      name?: string(name='Name'),
      namespace?: string(name='Namespace'),
      servicePort?: long(name='ServicePort', description='服务的端口'),
      serviceProtocol?: string(name='ServiceProtocol', description='服务的协议版本'),
    }
  ](name='ServiceList'),
  sourceId?: string(name='SourceId'),
  sourceType?: string(name='SourceType', description='服务来源'),
}

model ImportServicesShrinkRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  serviceListShrink?: string(name='ServiceList'),
  sourceId?: string(name='SourceId'),
  sourceType?: string(name='SourceType', description='服务来源'),
}

model ImportServicesResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model ImportServicesResponse = {
  headers: map[string]string(name='headers'),
  body: ImportServicesResponseBody(name='body'),
}

async function importServicesWithOptions(tmpReq: ImportServicesRequest, runtime: Util.RuntimeOptions): ImportServicesResponse {
  Util.validateModel(tmpReq);
  var request = new ImportServicesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.serviceList)) {
    request.serviceListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.serviceList, 'ServiceList', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.serviceListShrink)) {
    query['ServiceList'] = request.serviceListShrink;
  }
  if (!Util.isUnset(request.sourceId)) {
    query['SourceId'] = request.sourceId;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ImportServices',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function importServices(request: ImportServicesRequest): ImportServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return importServicesWithOptions(request, runtime);
}

model ListAlarmContactGroupsRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  requestPars?: string(name='RequestPars'),
}

model ListAlarmContactGroupsResponseBody = {
  data?: [ 
    {
      contactGroupId?: string(name='ContactGroupId'),
      contactGroupName?: string(name='ContactGroupName'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListAlarmContactGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: ListAlarmContactGroupsResponseBody(name='body'),
}

async function listAlarmContactGroupsWithOptions(request: ListAlarmContactGroupsRequest, runtime: Util.RuntimeOptions): ListAlarmContactGroupsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAlarmContactGroups',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAlarmContactGroups(request: ListAlarmContactGroupsRequest): ListAlarmContactGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAlarmContactGroupsWithOptions(request, runtime);
}

model ListAlarmHistoriesRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  alarmMseType?: string(name='AlarmMseType'),
  alarmName?: string(name='AlarmName'),
  endTime?: long(name='EndTime'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  requestPars?: string(name='RequestPars'),
  startTime?: long(name='StartTime'),
}

model ListAlarmHistoriesResponseBody = {
  data?: [ 
    {
      alarmContent?: string(name='AlarmContent'),
      alarmDingDing?: string(name='AlarmDingDing'),
      alarmEmail?: string(name='AlarmEmail'),
      alarmName?: string(name='AlarmName'),
      alarmPhone?: string(name='AlarmPhone'),
      alarmTime?: string(name='AlarmTime'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListAlarmHistoriesResponse = {
  headers: map[string]string(name='headers'),
  body: ListAlarmHistoriesResponseBody(name='body'),
}

async function listAlarmHistoriesWithOptions(request: ListAlarmHistoriesRequest, runtime: Util.RuntimeOptions): ListAlarmHistoriesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAlarmHistories',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAlarmHistories(request: ListAlarmHistoriesRequest): ListAlarmHistoriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAlarmHistoriesWithOptions(request, runtime);
}

model ListAlarmItemsRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  requestPars?: string(name='RequestPars'),
}

model ListAlarmItemsResponseBody = {
  data?: [ 
    {
      alarmCode?: string(name='AlarmCode'),
      alarmDesc?: string(name='AlarmDesc'),
      clusterType?: string(name='ClusterType'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListAlarmItemsResponse = {
  headers: map[string]string(name='headers'),
  body: ListAlarmItemsResponseBody(name='body'),
}

async function listAlarmItemsWithOptions(request: ListAlarmItemsRequest, runtime: Util.RuntimeOptions): ListAlarmItemsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAlarmItems',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAlarmItems(request: ListAlarmItemsRequest): ListAlarmItemsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAlarmItemsWithOptions(request, runtime);
}

model ListAlarmRulesRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  alarmMseType?: string(name='AlarmMseType'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  requestPars?: string(name='RequestPars'),
}

model ListAlarmRulesResponseBody = {
  data?: [ 
    {
      alarmName?: string(name='AlarmName'),
      alarmRuleDetail?: string(name='AlarmRuleDetail'),
      alarmRuleId?: string(name='AlarmRuleId'),
      alarmStatus?: string(name='AlarmStatus'),
      createTime?: string(name='CreateTime'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListAlarmRulesResponse = {
  headers: map[string]string(name='headers'),
  body: ListAlarmRulesResponseBody(name='body'),
}

async function listAlarmRulesWithOptions(request: ListAlarmRulesRequest, runtime: Util.RuntimeOptions): ListAlarmRulesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAlarmRules',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAlarmRules(request: ListAlarmRulesRequest): ListAlarmRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAlarmRulesWithOptions(request, runtime);
}

model ListAnsInstancesRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterId?: string(name='ClusterId'),
  clusterName?: string(name='ClusterName'),
  groupName?: string(name='GroupName'),
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  requestPars?: string(name='RequestPars'),
  serviceName?: string(name='ServiceName'),
}

model ListAnsInstancesResponseBody = {
  data?: [ 
    {
      app?: string(name='App'),
      clusterName?: string(name='ClusterName'),
      datumKey?: string(name='DatumKey'),
      defaultKey?: string(name='DefaultKey'),
      enabled?: boolean(name='Enabled'),
      ephemeral?: boolean(name='Ephemeral'),
      failCount?: int32(name='FailCount'),
      healthy?: boolean(name='Healthy'),
      instanceHeartBeatInterval?: int32(name='InstanceHeartBeatInterval'),
      instanceHeartBeatTimeOut?: int32(name='InstanceHeartBeatTimeOut'),
      instanceId?: string(name='InstanceId'),
      ip?: string(name='Ip'),
      ipDeleteTimeout?: int32(name='IpDeleteTimeout'),
      lastBeat?: long(name='LastBeat'),
      marked?: boolean(name='Marked'),
      metadata?: map[string]any(name='Metadata'),
      okCount?: int32(name='OkCount'),
      port?: int32(name='Port'),
      serviceName?: string(name='ServiceName'),
      weight?: int32(name='Weight'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListAnsInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: ListAnsInstancesResponseBody(name='body'),
}

async function listAnsInstancesWithOptions(request: ListAnsInstancesRequest, runtime: Util.RuntimeOptions): ListAnsInstancesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAnsInstances',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAnsInstances(request: ListAnsInstancesRequest): ListAnsInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAnsInstancesWithOptions(request, runtime);
}

model ListAnsServiceClustersRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterId?: string(name='ClusterId'),
  clusterName?: string(name='ClusterName'),
  groupName?: string(name='GroupName'),
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  requestPars?: string(name='RequestPars'),
  serviceName?: string(name='ServiceName'),
}

model ListAnsServiceClustersResponseBody = {
  data?: {
    clusters?: [ 
      {
        defaultCheckPort?: int32(name='DefaultCheckPort'),
        defaultPort?: int32(name='DefaultPort'),
        healthCheckerType?: string(name='HealthCheckerType'),
        metadata?: map[string]any(name='Metadata'),
        name?: string(name='Name'),
        serviceName?: string(name='ServiceName'),
        useIPPort4Check?: boolean(name='UseIPPort4Check'),
      }
    ](name='Clusters'),
    ephemeral?: boolean(name='Ephemeral'),
    groupName?: string(name='GroupName'),
    metadata?: map[string]any(name='Metadata'),
    name?: string(name='Name'),
    protectThreshold?: float(name='ProtectThreshold'),
    selectorType?: string(name='SelectorType'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListAnsServiceClustersResponse = {
  headers: map[string]string(name='headers'),
  body: ListAnsServiceClustersResponseBody(name='body'),
}

async function listAnsServiceClustersWithOptions(request: ListAnsServiceClustersRequest, runtime: Util.RuntimeOptions): ListAnsServiceClustersResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAnsServiceClusters',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAnsServiceClusters(request: ListAnsServiceClustersRequest): ListAnsServiceClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAnsServiceClustersWithOptions(request, runtime);
}

model ListAnsServicesRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterId?: string(name='ClusterId'),
  groupName?: string(name='GroupName'),
  hasIpCount?: string(name='HasIpCount'),
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  requestPars?: string(name='RequestPars'),
  serviceName?: string(name='ServiceName'),
}

model ListAnsServicesResponseBody = {
  data?: [ 
    {
      clusterCount?: int32(name='ClusterCount'),
      groupName?: string(name='GroupName'),
      healthyInstanceCount?: int32(name='HealthyInstanceCount'),
      ipCount?: int32(name='IpCount'),
      name?: string(name='Name'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListAnsServicesResponse = {
  headers: map[string]string(name='headers'),
  body: ListAnsServicesResponseBody(name='body'),
}

async function listAnsServicesWithOptions(request: ListAnsServicesRequest, runtime: Util.RuntimeOptions): ListAnsServicesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAnsServices',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAnsServices(request: ListAnsServicesRequest): ListAnsServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAnsServicesWithOptions(request, runtime);
}

model ListAppBySwimmingLaneGroupTagRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  groupId?: long(name='GroupId'),
  tag?: string(name='Tag'),
}

model ListAppBySwimmingLaneGroupTagResponseBody = {
  code?: int32(name='Code', description='code仅仅用来和success同步'),
  data?: any(name='Data'),
  dynamicMessage?: string(name='DynamicMessage', description='动态错误信息中的占位符'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListAppBySwimmingLaneGroupTagResponse = {
  headers: map[string]string(name='headers'),
  body: ListAppBySwimmingLaneGroupTagResponseBody(name='body'),
}

async function listAppBySwimmingLaneGroupTagWithOptions(request: ListAppBySwimmingLaneGroupTagRequest, runtime: Util.RuntimeOptions): ListAppBySwimmingLaneGroupTagResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAppBySwimmingLaneGroupTag',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAppBySwimmingLaneGroupTag(request: ListAppBySwimmingLaneGroupTagRequest): ListAppBySwimmingLaneGroupTagResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAppBySwimmingLaneGroupTagWithOptions(request, runtime);
}

model ListClusterConnectionTypesRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
}

model ListClusterConnectionTypesResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      showName?: string(name='ShowName'),
    }
  ](name='Data'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListClusterConnectionTypesResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterConnectionTypesResponseBody(name='body'),
}

async function listClusterConnectionTypesWithOptions(request: ListClusterConnectionTypesRequest, runtime: Util.RuntimeOptions): ListClusterConnectionTypesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListClusterConnectionTypes',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listClusterConnectionTypes(request: ListClusterConnectionTypesRequest): ListClusterConnectionTypesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClusterConnectionTypesWithOptions(request, runtime);
}

model ListClusterTypesRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  connectType?: string(name='ConnectType', description='网络连接类型'),
  regionId?: string(name='RegionId'),
}

model ListClusterTypesResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      showName?: string(name='ShowName'),
    }
  ](name='Data'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListClusterTypesResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterTypesResponseBody(name='body'),
}

async function listClusterTypesWithOptions(request: ListClusterTypesRequest, runtime: Util.RuntimeOptions): ListClusterTypesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.connectType)) {
    query['ConnectType'] = request.connectType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListClusterTypes',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listClusterTypes(request: ListClusterTypesRequest): ListClusterTypesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClusterTypesWithOptions(request, runtime);
}

model ListClusterVersionsRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterType?: string(name='ClusterType'),
}

model ListClusterVersionsResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      clusterType?: string(name='ClusterType'),
      code?: string(name='Code'),
      showName?: string(name='ShowName'),
    }
  ](name='Data'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListClusterVersionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterVersionsResponseBody(name='body'),
}

async function listClusterVersionsWithOptions(request: ListClusterVersionsRequest, runtime: Util.RuntimeOptions): ListClusterVersionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clusterType)) {
    query['ClusterType'] = request.clusterType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListClusterVersions',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listClusterVersions(request: ListClusterVersionsRequest): ListClusterVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClusterVersionsWithOptions(request, runtime);
}

model ListClustersRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterAliasName?: string(name='ClusterAliasName'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  requestPars?: string(name='RequestPars'),
}

model ListClustersResponseBody = {
  data?: [ 
    {
      appVersion?: string(name='AppVersion'),
      canUpdate?: boolean(name='CanUpdate'),
      chargeType?: string(name='ChargeType'),
      clusterAliasName?: string(name='ClusterAliasName'),
      clusterName?: string(name='ClusterName'),
      clusterType?: string(name='ClusterType'),
      createTime?: string(name='CreateTime'),
      endDate?: string(name='EndDate'),
      initStatus?: string(name='InitStatus'),
      instanceCount?: long(name='InstanceCount'),
      instanceId?: string(name='InstanceId'),
      internetAddress?: string(name='InternetAddress'),
      internetDomain?: string(name='InternetDomain'),
      intranetAddress?: string(name='IntranetAddress'),
      intranetDomain?: string(name='IntranetDomain'),
      versionCode?: string(name='VersionCode'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListClustersResponse = {
  headers: map[string]string(name='headers'),
  body: ListClustersResponseBody(name='body'),
}

async function listClustersWithOptions(request: ListClustersRequest, runtime: Util.RuntimeOptions): ListClustersResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListClusters',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listClusters(request: ListClustersRequest): ListClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClustersWithOptions(request, runtime);
}

model ListEngineNamespacesRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  instanceId?: string(name='InstanceId'),
}

model ListEngineNamespacesResponseBody = {
  data?: [ 
    {
      configCount?: int32(name='ConfigCount'),
      namespace?: string(name='Namespace'),
      namespaceDesc?: string(name='NamespaceDesc'),
      namespaceShowName?: string(name='NamespaceShowName'),
      quota?: int32(name='Quota'),
      serviceCount?: string(name='ServiceCount'),
      type?: int32(name='Type'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListEngineNamespacesResponse = {
  headers: map[string]string(name='headers'),
  body: ListEngineNamespacesResponseBody(name='body'),
}

async function listEngineNamespacesWithOptions(request: ListEngineNamespacesRequest, runtime: Util.RuntimeOptions): ListEngineNamespacesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListEngineNamespaces',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listEngineNamespaces(request: ListEngineNamespacesRequest): ListEngineNamespacesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEngineNamespacesWithOptions(request, runtime);
}

model ListEurekaInstancesRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterId?: string(name='ClusterId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  requestPars?: string(name='RequestPars'),
  serviceName?: string(name='ServiceName'),
}

model ListEurekaInstancesResponseBody = {
  data?: [ 
    {
      app?: string(name='App'),
      durationInSecs?: int32(name='DurationInSecs'),
      homePageUrl?: string(name='HomePageUrl'),
      hostName?: string(name='HostName'),
      instanceId?: string(name='InstanceId'),
      ipAddr?: string(name='IpAddr'),
      lastDirtyTimestamp?: long(name='LastDirtyTimestamp'),
      lastUpdatedTimestamp?: long(name='LastUpdatedTimestamp'),
      metadata?: map[string]any(name='Metadata'),
      port?: int32(name='Port'),
      renewalIntervalInSecs?: int32(name='RenewalIntervalInSecs'),
      securePort?: int32(name='SecurePort'),
      status?: string(name='Status'),
      vipAddress?: string(name='VipAddress'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListEurekaInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: ListEurekaInstancesResponseBody(name='body'),
}

async function listEurekaInstancesWithOptions(request: ListEurekaInstancesRequest, runtime: Util.RuntimeOptions): ListEurekaInstancesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListEurekaInstances',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listEurekaInstances(request: ListEurekaInstancesRequest): ListEurekaInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEurekaInstancesWithOptions(request, runtime);
}

model ListEurekaServicesRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterId?: string(name='ClusterId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  requestPars?: string(name='RequestPars'),
}

model ListEurekaServicesResponseBody = {
  data?: [ 
    {
      instancesId?: [ string ](name='InstancesId'),
      name?: string(name='Name'),
      upStatus?: string(name='UpStatus'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListEurekaServicesResponse = {
  headers: map[string]string(name='headers'),
  body: ListEurekaServicesResponseBody(name='body'),
}

async function listEurekaServicesWithOptions(request: ListEurekaServicesRequest, runtime: Util.RuntimeOptions): ListEurekaServicesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListEurekaServices',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listEurekaServices(request: ListEurekaServicesRequest): ListEurekaServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEurekaServicesWithOptions(request, runtime);
}

model ListGatewayRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  descSort?: boolean(name='DescSort'),
  filterParams?: {
    gatewayType?: string(name='GatewayType'),
    gatewayUniqueId?: string(name='GatewayUniqueId'),
    instanceId?: string(name='InstanceId'),
    name?: string(name='Name'),
    vpc?: string(name='Vpc'),
  }(name='FilterParams'),
  orderItem?: string(name='OrderItem'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListGatewayShrinkRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  descSort?: boolean(name='DescSort'),
  filterParamsShrink?: string(name='FilterParams'),
  orderItem?: string(name='OrderItem'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListGatewayResponseBody = {
  code?: int32(name='Code'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    result?: [ 
      {
        ahasOn?: boolean(name='AhasOn'),
        armsOn?: boolean(name='ArmsOn'),
        chargeType?: string(name='ChargeType'),
        currentVersion?: string(name='CurrentVersion'),
        endDate?: string(name='EndDate'),
        gatewayType?: string(name='GatewayType'),
        gatewayUniqueId?: string(name='GatewayUniqueId'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        id?: long(name='Id'),
        instanceId?: string(name='InstanceId'),
        internetSlb?: [ 
          {
            gatewaySlbMode?: string(name='GatewaySlbMode'),
            gatewaySlbStatus?: string(name='GatewaySlbStatus'),
            internetNetworkFlow?: string(name='InternetNetworkFlow'),
            slbId?: string(name='SlbId'),
            slbIp?: string(name='SlbIp'),
            slbPort?: string(name='SlbPort'),
            slbSpec?: string(name='SlbSpec'),
            statusDesc?: string(name='StatusDesc'),
            type?: string(name='Type'),
          }
        ](name='InternetSlb'),
        latestVersion?: string(name='LatestVersion'),
        mustUpgrade?: boolean(name='MustUpgrade'),
        name?: string(name='Name'),
        primaryUser?: string(name='PrimaryUser'),
        region?: string(name='Region'),
        replica?: int32(name='Replica'),
        slb?: [ 
          {
            gatewaySlbMode?: string(name='GatewaySlbMode'),
            gatewaySlbStatus?: string(name='GatewaySlbStatus'),
            slbId?: string(name='SlbId'),
            slbIp?: string(name='SlbIp'),
            slbPort?: string(name='SlbPort'),
            slbSpec?: string(name='SlbSpec'),
            statusDesc?: string(name='StatusDesc'),
            type?: string(name='Type'),
          }
        ](name='Slb'),
        spec?: string(name='Spec'),
        status?: int32(name='Status'),
        statusDesc?: string(name='StatusDesc'),
        tag?: string(name='Tag'),
        upgrade?: boolean(name='Upgrade'),
        vswitch2?: string(name='Vswitch2'),
      }
    ](name='Result'),
    totalSize?: long(name='TotalSize'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model ListGatewayResponse = {
  headers: map[string]string(name='headers'),
  body: ListGatewayResponseBody(name='body'),
}

async function listGatewayWithOptions(tmpReq: ListGatewayRequest, runtime: Util.RuntimeOptions): ListGatewayResponse {
  Util.validateModel(tmpReq);
  var request = new ListGatewayShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.filterParams)) {
    request.filterParamsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.filterParams, 'FilterParams', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.descSort)) {
    query['DescSort'] = request.descSort;
  }
  if (!Util.isUnset(request.filterParamsShrink)) {
    query['FilterParams'] = request.filterParamsShrink;
  }
  if (!Util.isUnset(request.orderItem)) {
    query['OrderItem'] = request.orderItem;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListGateway',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listGateway(request: ListGatewayRequest): ListGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return listGatewayWithOptions(request, runtime);
}

model ListGatewayDomainRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
}

model ListGatewayDomainResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      certBeforeDate?: string(name='CertBeforeDate'),
      certIdentifier?: string(name='CertIdentifier'),
      gatewayId?: long(name='GatewayId'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      id?: long(name='Id'),
      mustHttps?: boolean(name='MustHttps'),
      name?: string(name='Name'),
      protocol?: string(name='Protocol'),
    }
  ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model ListGatewayDomainResponse = {
  headers: map[string]string(name='headers'),
  body: ListGatewayDomainResponseBody(name='body'),
}

async function listGatewayDomainWithOptions(request: ListGatewayDomainRequest, runtime: Util.RuntimeOptions): ListGatewayDomainResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListGatewayDomain',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listGatewayDomain(request: ListGatewayDomainRequest): ListGatewayDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return listGatewayDomainWithOptions(request, runtime);
}

model ListGatewayServiceRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  descSort?: boolean(name='DescSort'),
  filterParams?: {
    gatewayUniqueId?: string(name='GatewayUniqueId'),
    groupName?: string(name='GroupName'),
    name?: string(name='Name'),
    namespace?: string(name='Namespace'),
    sourceType?: string(name='SourceType'),
  }(name='FilterParams'),
  orderItem?: string(name='OrderItem'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListGatewayServiceShrinkRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  descSort?: boolean(name='DescSort'),
  filterParamsShrink?: string(name='FilterParams'),
  orderItem?: string(name='OrderItem'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListGatewayServiceResponseBody = {
  code?: int32(name='Code'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    result?: [ 
      {
        gatewayId?: long(name='GatewayId'),
        gatewayUniqueId?: string(name='GatewayUniqueId'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        groupName?: string(name='GroupName'),
        id?: long(name='Id'),
        ips?: [ string ](name='Ips'),
        metaInfo?: string(name='MetaInfo'),
        name?: string(name='Name'),
        namespace?: string(name='Namespace'),
        serviceNameInRegistry?: string(name='ServiceNameInRegistry'),
        servicePort?: long(name='ServicePort'),
        serviceProtocol?: string(name='ServiceProtocol'),
        sourceId?: long(name='SourceId'),
        sourceType?: string(name='SourceType'),
        versions?: [ 
          {
            name?: string(name='Name'),
          }
        ](name='Versions'),
      }
    ](name='Result'),
    totalSize?: long(name='TotalSize'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model ListGatewayServiceResponse = {
  headers: map[string]string(name='headers'),
  body: ListGatewayServiceResponseBody(name='body'),
}

async function listGatewayServiceWithOptions(tmpReq: ListGatewayServiceRequest, runtime: Util.RuntimeOptions): ListGatewayServiceResponse {
  Util.validateModel(tmpReq);
  var request = new ListGatewayServiceShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.filterParams)) {
    request.filterParamsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.filterParams, 'FilterParams', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.descSort)) {
    query['DescSort'] = request.descSort;
  }
  if (!Util.isUnset(request.filterParamsShrink)) {
    query['FilterParams'] = request.filterParamsShrink;
  }
  if (!Util.isUnset(request.orderItem)) {
    query['OrderItem'] = request.orderItem;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListGatewayService',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listGatewayService(request: ListGatewayServiceRequest): ListGatewayServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return listGatewayServiceWithOptions(request, runtime);
}

model ListGatewaySlbRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
}

model ListGatewaySlbResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      gatewayId?: string(name='GatewayId'),
      gatewaySlbMode?: string(name='GatewaySlbMode'),
      gatewaySlbStatus?: string(name='GatewaySlbStatus'),
      gmtCreate?: string(name='GmtCreate'),
      id?: string(name='Id'),
      slbId?: string(name='SlbId'),
      slbIp?: string(name='SlbIp'),
      slbPort?: string(name='SlbPort'),
      statusDesc?: string(name='StatusDesc'),
      type?: string(name='Type'),
    }
  ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model ListGatewaySlbResponse = {
  headers: map[string]string(name='headers'),
  body: ListGatewaySlbResponseBody(name='body'),
}

async function listGatewaySlbWithOptions(request: ListGatewaySlbRequest, runtime: Util.RuntimeOptions): ListGatewaySlbResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListGatewaySlb',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listGatewaySlb(request: ListGatewaySlbRequest): ListGatewaySlbResponse {
  var runtime = new Util.RuntimeOptions{};
  return listGatewaySlbWithOptions(request, runtime);
}

model ListListenersByConfigRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  dataId?: string(name='DataId'),
  group?: string(name='Group'),
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
  requestPars?: string(name='RequestPars'),
}

model ListListenersByConfigResponseBody = {
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  listeners?: [ 
    {
      ip?: string(name='Ip'),
      md5?: string(name='Md5'),
    }
  ](name='Listeners'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListListenersByConfigResponse = {
  headers: map[string]string(name='headers'),
  body: ListListenersByConfigResponseBody(name='body'),
}

async function listListenersByConfigWithOptions(request: ListListenersByConfigRequest, runtime: Util.RuntimeOptions): ListListenersByConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.dataId)) {
    query['DataId'] = request.dataId;
  }
  if (!Util.isUnset(request.group)) {
    query['Group'] = request.group;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  if (!Util.isUnset(request.requestPars)) {
    query['RequestPars'] = request.requestPars;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListListenersByConfig',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listListenersByConfig(request: ListListenersByConfigRequest): ListListenersByConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return listListenersByConfigWithOptions(request, runtime);
}

model ListListenersByIpRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  instanceId?: string(name='InstanceId'),
  ip?: string(name='Ip'),
  namespaceId?: string(name='NamespaceId'),
  requestPars?: string(name='RequestPars'),
}

model ListListenersByIpResponseBody = {
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  listeners?: [ 
    {
      dataId?: string(name='DataId'),
      group?: string(name='Group'),
      md5?: string(name='Md5'),
    }
  ](name='Listeners'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListListenersByIpResponse = {
  headers: map[string]string(name='headers'),
  body: ListListenersByIpResponseBody(name='body'),
}

async function listListenersByIpWithOptions(request: ListListenersByIpRequest, runtime: Util.RuntimeOptions): ListListenersByIpResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ip)) {
    query['Ip'] = request.ip;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  if (!Util.isUnset(request.requestPars)) {
    query['RequestPars'] = request.requestPars;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListListenersByIp',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listListenersByIp(request: ListListenersByIpRequest): ListListenersByIpResponse {
  var runtime = new Util.RuntimeOptions{};
  return listListenersByIpWithOptions(request, runtime);
}

model ListNacosConfigsRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  appName?: string(name='AppName'),
  dataId?: string(name='DataId'),
  group?: string(name='Group'),
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  requestPars?: string(name='RequestPars'),
  tags?: string(name='Tags'),
}

model ListNacosConfigsResponseBody = {
  code?: int32(name='Code'),
  configurations?: [ 
    {
      appName?: string(name='AppName'),
      dataId?: string(name='DataId'),
      group?: string(name='Group'),
      id?: string(name='Id'),
    }
  ](name='Configurations'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListNacosConfigsResponse = {
  headers: map[string]string(name='headers'),
  body: ListNacosConfigsResponseBody(name='body'),
}

async function listNacosConfigsWithOptions(request: ListNacosConfigsRequest, runtime: Util.RuntimeOptions): ListNacosConfigsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.dataId)) {
    query['DataId'] = request.dataId;
  }
  if (!Util.isUnset(request.group)) {
    query['Group'] = request.group;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.requestPars)) {
    query['RequestPars'] = request.requestPars;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListNacosConfigs',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listNacosConfigs(request: ListNacosConfigsRequest): ListNacosConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNacosConfigsWithOptions(request, runtime);
}

model ListNacosHistoryConfigsRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  dataId?: string(name='DataId'),
  group?: string(name='Group'),
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  requestPars?: string(name='RequestPars'),
}

model ListNacosHistoryConfigsResponseBody = {
  errorCode?: string(name='ErrorCode'),
  historyItems?: [ 
    {
      appName?: string(name='AppName'),
      dataId?: string(name='DataId'),
      group?: string(name='Group'),
      id?: long(name='Id'),
      lastModifiedTime?: long(name='LastModifiedTime'),
      opType?: string(name='OpType'),
    }
  ](name='HistoryItems'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListNacosHistoryConfigsResponse = {
  headers: map[string]string(name='headers'),
  body: ListNacosHistoryConfigsResponseBody(name='body'),
}

async function listNacosHistoryConfigsWithOptions(request: ListNacosHistoryConfigsRequest, runtime: Util.RuntimeOptions): ListNacosHistoryConfigsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.dataId)) {
    query['DataId'] = request.dataId;
  }
  if (!Util.isUnset(request.group)) {
    query['Group'] = request.group;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.requestPars)) {
    query['RequestPars'] = request.requestPars;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListNacosHistoryConfigs',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listNacosHistoryConfigs(request: ListNacosHistoryConfigsRequest): ListNacosHistoryConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNacosHistoryConfigsWithOptions(request, runtime);
}

model ListSSLCertRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
}

model ListSSLCertResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      afterDate?: string(name='AfterDate'),
      algorithm?: string(name='Algorithm'),
      beforeDate?: string(name='BeforeDate'),
      certIdentifier?: string(name='CertIdentifier'),
      certName?: string(name='CertName'),
      commonName?: string(name='CommonName'),
      gmtAfter?: string(name='GmtAfter'),
      gmtBefore?: string(name='GmtBefore'),
      issuer?: string(name='Issuer'),
      sans?: string(name='Sans'),
    }
  ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model ListSSLCertResponse = {
  headers: map[string]string(name='headers'),
  body: ListSSLCertResponseBody(name='body'),
}

async function listSSLCertWithOptions(request: ListSSLCertRequest, runtime: Util.RuntimeOptions): ListSSLCertResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSSLCert',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSSLCert(request: ListSSLCertRequest): ListSSLCertResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSSLCertWithOptions(request, runtime);
}

model ListServiceSourceRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
}

model ListServiceSourceResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      address?: string(name='Address'),
      bindingWithGateway?: int32(name='BindingWithGateway'),
      gatewayId?: long(name='GatewayId'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      id?: long(name='Id'),
      name?: string(name='Name'),
      source?: string(name='Source'),
      sourceUniqueId?: string(name='SourceUniqueId'),
      type?: string(name='Type'),
    }
  ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model ListServiceSourceResponse = {
  headers: map[string]string(name='headers'),
  body: ListServiceSourceResponseBody(name='body'),
}

async function listServiceSourceWithOptions(request: ListServiceSourceRequest, runtime: Util.RuntimeOptions): ListServiceSourceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListServiceSource',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listServiceSource(request: ListServiceSourceRequest): ListServiceSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return listServiceSourceWithOptions(request, runtime);
}

model ListZnodeChildrenRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterId?: string(name='ClusterId'),
  path?: string(name='Path'),
}

model ListZnodeChildrenResponseBody = {
  data?: [ 
    {
      data?: string(name='Data'),
      dir?: boolean(name='Dir'),
      name?: string(name='Name'),
      path?: string(name='Path'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListZnodeChildrenResponse = {
  headers: map[string]string(name='headers'),
  body: ListZnodeChildrenResponseBody(name='body'),
}

async function listZnodeChildrenWithOptions(request: ListZnodeChildrenRequest, runtime: Util.RuntimeOptions): ListZnodeChildrenResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListZnodeChildren',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listZnodeChildren(request: ListZnodeChildrenRequest): ListZnodeChildrenResponse {
  var runtime = new Util.RuntimeOptions{};
  return listZnodeChildrenWithOptions(request, runtime);
}

model ModifyGovernanceKubernetesClusterRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterId?: string(name='ClusterId'),
  namespaceInfos?: string(name='NamespaceInfos'),
  regionId?: string(name='RegionId'),
}

model ModifyGovernanceKubernetesClusterResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ModifyGovernanceKubernetesClusterResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyGovernanceKubernetesClusterResponseBody(name='body'),
}

async function modifyGovernanceKubernetesClusterWithOptions(request: ModifyGovernanceKubernetesClusterRequest, runtime: Util.RuntimeOptions): ModifyGovernanceKubernetesClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.namespaceInfos)) {
    query['NamespaceInfos'] = request.namespaceInfos;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyGovernanceKubernetesCluster',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyGovernanceKubernetesCluster(request: ModifyGovernanceKubernetesClusterRequest): ModifyGovernanceKubernetesClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyGovernanceKubernetesClusterWithOptions(request, runtime);
}

model PullServicesRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  sourceId?: string(name='SourceId'),
  sourceType?: string(name='SourceType'),
}

model PullServicesResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      groupName?: string(name='GroupName'),
      namespace?: string(name='Namespace'),
      services?: [ 
        {
          groupName?: string(name='GroupName'),
          name?: string(name='Name'),
          namespace?: string(name='Namespace'),
          sourceId?: string(name='SourceId'),
          sourceType?: string(name='SourceType'),
        }
      ](name='Services'),
    }
  ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model PullServicesResponse = {
  headers: map[string]string(name='headers'),
  body: PullServicesResponseBody(name='body'),
}

async function pullServicesWithOptions(request: PullServicesRequest, runtime: Util.RuntimeOptions): PullServicesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PullServices',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function pullServices(request: PullServicesRequest): PullServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return pullServicesWithOptions(request, runtime);
}

model QueryAllSwimmingLaneRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  groupId?: long(name='GroupId'),
}

model QueryAllSwimmingLaneResponseBody = {
  code?: int32(name='Code', description='code仅仅用来和success同步'),
  data?: any(name='Data'),
  dynamicMessage?: string(name='DynamicMessage', description='动态错误信息中的占位符'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryAllSwimmingLaneResponse = {
  headers: map[string]string(name='headers'),
  body: QueryAllSwimmingLaneResponseBody(name='body'),
}

async function queryAllSwimmingLaneWithOptions(request: QueryAllSwimmingLaneRequest, runtime: Util.RuntimeOptions): QueryAllSwimmingLaneResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryAllSwimmingLane',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryAllSwimmingLane(request: QueryAllSwimmingLaneRequest): QueryAllSwimmingLaneResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryAllSwimmingLaneWithOptions(request, runtime);
}

model QueryAllSwimmingLaneGroupRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
}

model QueryAllSwimmingLaneGroupResponseBody = {
  code?: int32(name='Code', description='code仅仅用来和success同步'),
  data?: any(name='Data'),
  dynamicMessage?: string(name='DynamicMessage', description='动态错误信息中的占位符'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryAllSwimmingLaneGroupResponse = {
  headers: map[string]string(name='headers'),
  body: QueryAllSwimmingLaneGroupResponseBody(name='body'),
}

async function queryAllSwimmingLaneGroupWithOptions(request: QueryAllSwimmingLaneGroupRequest, runtime: Util.RuntimeOptions): QueryAllSwimmingLaneGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryAllSwimmingLaneGroup',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryAllSwimmingLaneGroup(request: QueryAllSwimmingLaneGroupRequest): QueryAllSwimmingLaneGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryAllSwimmingLaneGroupWithOptions(request, runtime);
}

model QueryBusinessLocationsRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
}

model QueryBusinessLocationsResponseBody = {
  data?: [ 
    {
      cnName?: string(name='CnName'),
      description?: string(name='Description'),
      districtCnName?: string(name='DistrictCnName'),
      districtEnName?: string(name='DistrictEnName'),
      districtId?: string(name='DistrictId'),
      districtOrdering?: int32(name='DistrictOrdering'),
      districtShowName?: string(name='DistrictShowName'),
      enDescription?: string(name='EnDescription'),
      enName?: string(name='EnName'),
      name?: string(name='Name'),
      ordering?: int32(name='Ordering'),
      showName?: string(name='ShowName'),
      type?: string(name='Type'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model QueryBusinessLocationsResponse = {
  headers: map[string]string(name='headers'),
  body: QueryBusinessLocationsResponseBody(name='body'),
}

async function queryBusinessLocationsWithOptions(request: QueryBusinessLocationsRequest, runtime: Util.RuntimeOptions): QueryBusinessLocationsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryBusinessLocations',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryBusinessLocations(request: QueryBusinessLocationsRequest): QueryBusinessLocationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryBusinessLocationsWithOptions(request, runtime);
}

model QueryClusterDetailRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  instanceId?: string(name='InstanceId'),
  orderId?: string(name='OrderId'),
}

model QueryClusterDetailResponseBody = {
  data?: {
    aclEntryList?: string(name='AclEntryList'),
    aclId?: string(name='AclId'),
    appVersion?: string(name='AppVersion'),
    chargeType?: string(name='ChargeType'),
    clusterAliasName?: string(name='ClusterAliasName'),
    clusterName?: string(name='ClusterName'),
    clusterSpecification?: string(name='ClusterSpecification'),
    clusterType?: string(name='ClusterType'),
    clusterVersion?: string(name='ClusterVersion'),
    connectionType?: string(name='ConnectionType'),
    cpu?: int32(name='Cpu'),
    createTime?: string(name='CreateTime'),
    diskCapacity?: long(name='DiskCapacity'),
    diskType?: string(name='DiskType'),
    healthStatus?: string(name='HealthStatus'),
    initCostTime?: long(name='InitCostTime'),
    initStatus?: string(name='InitStatus'),
    instanceCount?: int32(name='InstanceCount'),
    instanceId?: string(name='InstanceId'),
    instanceModels?: [ 
      {
        creationTimestamp?: string(name='CreationTimestamp'),
        healthStatus?: string(name='HealthStatus'),
        internetIp?: string(name='InternetIp'),
        ip?: string(name='Ip'),
        podName?: string(name='PodName'),
        role?: string(name='Role'),
        singleTunnelVip?: string(name='SingleTunnelVip'),
      }
    ](name='InstanceModels'),
    internetAddress?: string(name='InternetAddress'),
    internetDomain?: string(name='InternetDomain'),
    internetPort?: string(name='InternetPort'),
    intranetAddress?: string(name='IntranetAddress'),
    intranetDomain?: string(name='IntranetDomain'),
    intranetPort?: string(name='IntranetPort'),
    memoryCapacity?: long(name='MemoryCapacity'),
    mseVersion?: string(name='MseVersion'),
    netType?: string(name='NetType'),
    payInfo?: string(name='PayInfo'),
    pubNetworkFlow?: string(name='PubNetworkFlow'),
    regionId?: string(name='RegionId'),
    vSwitchId?: string(name='VSwitchId'),
    vpcId?: string(name='VpcId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryClusterDetailResponse = {
  headers: map[string]string(name='headers'),
  body: QueryClusterDetailResponseBody(name='body'),
}

async function queryClusterDetailWithOptions(request: QueryClusterDetailRequest, runtime: Util.RuntimeOptions): QueryClusterDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryClusterDetail',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryClusterDetail(request: QueryClusterDetailRequest): QueryClusterDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryClusterDetailWithOptions(request, runtime);
}

model QueryClusterDiskSpecificationRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterType?: string(name='ClusterType'),
}

model QueryClusterDiskSpecificationResponseBody = {
  code?: int32(name='Code'),
  data?: {
    max?: int32(name='Max'),
    min?: int32(name='Min'),
    step?: int32(name='Step'),
  }(name='Data'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryClusterDiskSpecificationResponse = {
  headers: map[string]string(name='headers'),
  body: QueryClusterDiskSpecificationResponseBody(name='body'),
}

async function queryClusterDiskSpecificationWithOptions(request: QueryClusterDiskSpecificationRequest, runtime: Util.RuntimeOptions): QueryClusterDiskSpecificationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clusterType)) {
    query['ClusterType'] = request.clusterType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryClusterDiskSpecification',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryClusterDiskSpecification(request: QueryClusterDiskSpecificationRequest): QueryClusterDiskSpecificationResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryClusterDiskSpecificationWithOptions(request, runtime);
}

model QueryClusterSpecificationRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  connectType?: string(name='ConnectType', description='网络连接类型'),
}

model QueryClusterSpecificationResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      clusterSpecificationName?: string(name='ClusterSpecificationName'),
      cpuCapacity?: string(name='CpuCapacity'),
      diskCapacity?: string(name='DiskCapacity'),
      instanceCount?: string(name='InstanceCount'),
      maxCon?: string(name='MaxCon'),
      maxTps?: string(name='MaxTps'),
      memoryCapacity?: string(name='MemoryCapacity'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryClusterSpecificationResponse = {
  headers: map[string]string(name='headers'),
  body: QueryClusterSpecificationResponseBody(name='body'),
}

async function queryClusterSpecificationWithOptions(request: QueryClusterSpecificationRequest, runtime: Util.RuntimeOptions): QueryClusterSpecificationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.connectType)) {
    query['ConnectType'] = request.connectType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryClusterSpecification',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryClusterSpecification(request: QueryClusterSpecificationRequest): QueryClusterSpecificationResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryClusterSpecificationWithOptions(request, runtime);
}

model QueryConfigRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterId?: string(name='ClusterId'),
  configType?: string(name='ConfigType'),
  instanceId?: string(name='InstanceId'),
  requestPars?: string(name='RequestPars'),
}

model QueryConfigResponseBody = {
  code?: int32(name='Code'),
  data?: {
    autopurgePurgeInterval?: string(name='AutopurgePurgeInterval'),
    autopurgeSnapRetainCount?: string(name='AutopurgeSnapRetainCount'),
    clusterName?: string(name='ClusterName'),
    configAuthEnabled?: boolean(name='ConfigAuthEnabled'),
    configAuthSupported?: boolean(name='ConfigAuthSupported'),
    configSecretEnabled?: boolean(name='ConfigSecretEnabled'),
    configSecretSupported?: boolean(name='ConfigSecretSupported'),
    initLimit?: string(name='InitLimit'),
    juteMaxbuffer?: string(name='JuteMaxbuffer'),
    jvmFlagsCustom?: string(name='JvmFlagsCustom'),
    MCPEnabled?: boolean(name='MCPEnabled'),
    MCPSupported?: boolean(name='MCPSupported'),
    maxClientCnxns?: string(name='MaxClientCnxns'),
    maxSessionTimeout?: string(name='MaxSessionTimeout', description='最大超时时间'),
    minSessionTimeout?: string(name='MinSessionTimeout', description='最小超时时间'),
    namingCreateServiceSupported?: boolean(name='NamingCreateServiceSupported'),
    openSuperAcl?: boolean(name='OpenSuperAcl'),
    passWord?: string(name='PassWord'),
    restartFlag?: boolean(name='RestartFlag'),
    syncLimit?: string(name='SyncLimit'),
    tickTime?: string(name='TickTime'),
    userName?: string(name='UserName'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryConfigResponse = {
  headers: map[string]string(name='headers'),
  body: QueryConfigResponseBody(name='body'),
}

async function queryConfigWithOptions(request: QueryConfigRequest, runtime: Util.RuntimeOptions): QueryConfigResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryConfig',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryConfig(request: QueryConfigRequest): QueryConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryConfigWithOptions(request, runtime);
}

model QueryGatewayRegionRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
}

model QueryGatewayRegionResponseBody = {
  code?: int32(name='Code'),
  data?: [ string ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model QueryGatewayRegionResponse = {
  headers: map[string]string(name='headers'),
  body: QueryGatewayRegionResponseBody(name='body'),
}

async function queryGatewayRegionWithOptions(request: QueryGatewayRegionRequest, runtime: Util.RuntimeOptions): QueryGatewayRegionResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryGatewayRegion',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryGatewayRegion(request: QueryGatewayRegionRequest): QueryGatewayRegionResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryGatewayRegionWithOptions(request, runtime);
}

model QueryGatewayTypeRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
}

model QueryGatewayTypeResponseBody = {
  code?: int32(name='Code'),
  data?: [ string ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model QueryGatewayTypeResponse = {
  headers: map[string]string(name='headers'),
  body: QueryGatewayTypeResponseBody(name='body'),
}

async function queryGatewayTypeWithOptions(request: QueryGatewayTypeRequest, runtime: Util.RuntimeOptions): QueryGatewayTypeResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryGatewayType',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryGatewayType(request: QueryGatewayTypeRequest): QueryGatewayTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryGatewayTypeWithOptions(request, runtime);
}

model QueryGovernanceKubernetesClusterRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterId?: string(name='ClusterId'),
  clusterName?: string(name='ClusterName'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model QueryGovernanceKubernetesClusterResponseBody = {
  code?: int32(name='Code'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    result?: [ 
      {
        clusterId?: string(name='ClusterId'),
        clusterName?: string(name='ClusterName'),
        k8sVersion?: string(name='K8sVersion'),
        namespaceInfos?: string(name='NamespaceInfos'),
        pilotStartTime?: string(name='PilotStartTime'),
        region?: string(name='Region'),
      }
    ](name='Result'),
    totalSize?: int32(name='TotalSize'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryGovernanceKubernetesClusterResponse = {
  headers: map[string]string(name='headers'),
  body: QueryGovernanceKubernetesClusterResponseBody(name='body'),
}

async function queryGovernanceKubernetesClusterWithOptions(request: QueryGovernanceKubernetesClusterRequest, runtime: Util.RuntimeOptions): QueryGovernanceKubernetesClusterResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryGovernanceKubernetesCluster',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryGovernanceKubernetesCluster(request: QueryGovernanceKubernetesClusterRequest): QueryGovernanceKubernetesClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryGovernanceKubernetesClusterWithOptions(request, runtime);
}

model QueryMonitorRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  endTime?: long(name='EndTime'),
  instanceId?: string(name='InstanceId'),
  monitorType?: string(name='MonitorType'),
  requestPars?: string(name='RequestPars'),
  startTime?: long(name='StartTime'),
  step?: long(name='Step'),
}

model QueryMonitorResponseBody = {
  data?: string(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryMonitorResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMonitorResponseBody(name='body'),
}

async function queryMonitorWithOptions(request: QueryMonitorRequest, runtime: Util.RuntimeOptions): QueryMonitorResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryMonitor',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryMonitor(request: QueryMonitorRequest): QueryMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMonitorWithOptions(request, runtime);
}

model QuerySlbSpecRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
}

model QuerySlbSpecResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      id?: int32(name='Id'),
      maxConnection?: string(name='MaxConnection'),
      name?: string(name='Name'),
      newConnectionPerSecond?: string(name='NewConnectionPerSecond'),
      qps?: string(name='Qps'),
      spec?: string(name='Spec'),
    }
  ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model QuerySlbSpecResponse = {
  headers: map[string]string(name='headers'),
  body: QuerySlbSpecResponseBody(name='body'),
}

async function querySlbSpecWithOptions(request: QuerySlbSpecRequest, runtime: Util.RuntimeOptions): QuerySlbSpecResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QuerySlbSpec',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function querySlbSpec(request: QuerySlbSpecRequest): QuerySlbSpecResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySlbSpecWithOptions(request, runtime);
}

model QuerySwimmingLaneByIdRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  laneId?: long(name='LaneId'),
}

model QuerySwimmingLaneByIdResponseBody = {
  code?: int32(name='Code', description='code仅仅用来和success同步'),
  data?: any(name='Data'),
  dynamicMessage?: string(name='DynamicMessage', description='动态错误信息中的占位符'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QuerySwimmingLaneByIdResponse = {
  headers: map[string]string(name='headers'),
  body: QuerySwimmingLaneByIdResponseBody(name='body'),
}

async function querySwimmingLaneByIdWithOptions(request: QuerySwimmingLaneByIdRequest, runtime: Util.RuntimeOptions): QuerySwimmingLaneByIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.laneId)) {
    query['LaneId'] = request.laneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QuerySwimmingLaneById',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function querySwimmingLaneById(request: QuerySwimmingLaneByIdRequest): QuerySwimmingLaneByIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySwimmingLaneByIdWithOptions(request, runtime);
}

model QueryZnodeDetailRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterId?: string(name='ClusterId'),
  path?: string(name='Path'),
  requestPars?: string(name='RequestPars'),
}

model QueryZnodeDetailResponseBody = {
  data?: {
    data?: string(name='Data'),
    dir?: boolean(name='Dir'),
    name?: string(name='Name'),
    path?: string(name='Path'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model QueryZnodeDetailResponse = {
  headers: map[string]string(name='headers'),
  body: QueryZnodeDetailResponseBody(name='body'),
}

async function queryZnodeDetailWithOptions(request: QueryZnodeDetailRequest, runtime: Util.RuntimeOptions): QueryZnodeDetailResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryZnodeDetail',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryZnodeDetail(request: QueryZnodeDetailRequest): QueryZnodeDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryZnodeDetailWithOptions(request, runtime);
}

model RestartClusterRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterId?: string(name='ClusterId'),
  instanceId?: string(name='InstanceId'),
  podNameList?: string(name='PodNameList'),
  requestPars?: string(name='RequestPars'),
}

model RestartClusterResponseBody = {
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RestartClusterResponse = {
  headers: map[string]string(name='headers'),
  body: RestartClusterResponseBody(name='body'),
}

async function restartClusterWithOptions(request: RestartClusterRequest, runtime: Util.RuntimeOptions): RestartClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.podNameList)) {
    query['PodNameList'] = request.podNameList;
  }
  if (!Util.isUnset(request.requestPars)) {
    query['RequestPars'] = request.requestPars;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RestartCluster',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function restartCluster(request: RestartClusterRequest): RestartClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return restartClusterWithOptions(request, runtime);
}

model RetryClusterRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  instanceId?: string(name='InstanceId'),
  requestPars?: string(name='RequestPars'),
}

model RetryClusterResponseBody = {
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RetryClusterResponse = {
  headers: map[string]string(name='headers'),
  body: RetryClusterResponseBody(name='body'),
}

async function retryClusterWithOptions(request: RetryClusterRequest, runtime: Util.RuntimeOptions): RetryClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.requestPars)) {
    query['RequestPars'] = request.requestPars;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RetryCluster',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function retryCluster(request: RetryClusterRequest): RetryClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return retryClusterWithOptions(request, runtime);
}

model ScalingClusterRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterSpecification?: string(name='ClusterSpecification'),
  cpu?: int32(name='Cpu'),
  instanceCount?: int32(name='InstanceCount'),
  instanceId?: string(name='InstanceId'),
  memoryCapacity?: long(name='MemoryCapacity'),
}

model ScalingClusterResponseBody = {
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ScalingClusterResponse = {
  headers: map[string]string(name='headers'),
  body: ScalingClusterResponseBody(name='body'),
}

async function scalingClusterWithOptions(request: ScalingClusterRequest, runtime: Util.RuntimeOptions): ScalingClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clusterSpecification)) {
    query['ClusterSpecification'] = request.clusterSpecification;
  }
  if (!Util.isUnset(request.cpu)) {
    query['Cpu'] = request.cpu;
  }
  if (!Util.isUnset(request.instanceCount)) {
    query['InstanceCount'] = request.instanceCount;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.memoryCapacity)) {
    query['MemoryCapacity'] = request.memoryCapacity;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ScalingCluster',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function scalingCluster(request: ScalingClusterRequest): ScalingClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return scalingClusterWithOptions(request, runtime);
}

model SelectGatewaySlbRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  name?: string(name='Name'),
  type?: string(name='Type'),
}

model SelectGatewaySlbResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      slbId?: string(name='SlbId'),
      slbName?: string(name='SlbName'),
    }
  ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model SelectGatewaySlbResponse = {
  headers: map[string]string(name='headers'),
  body: SelectGatewaySlbResponseBody(name='body'),
}

async function selectGatewaySlbWithOptions(request: SelectGatewaySlbRequest, runtime: Util.RuntimeOptions): SelectGatewaySlbResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SelectGatewaySlb',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function selectGatewaySlb(request: SelectGatewaySlbRequest): SelectGatewaySlbResponse {
  var runtime = new Util.RuntimeOptions{};
  return selectGatewaySlbWithOptions(request, runtime);
}

model UpdateAclRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  aclEntryList?: string(name='AclEntryList'),
  instanceId?: string(name='InstanceId'),
}

model UpdateAclResponseBody = {
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateAclResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAclResponseBody(name='body'),
}

async function updateAclWithOptions(request: UpdateAclRequest, runtime: Util.RuntimeOptions): UpdateAclResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.aclEntryList)) {
    query['AclEntryList'] = request.aclEntryList;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAcl',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAcl(request: UpdateAclRequest): UpdateAclResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAclWithOptions(request, runtime);
}

model UpdateBlackWhiteListRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  content?: string(name='Content'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  id?: long(name='Id'),
  isWhite?: boolean(name='IsWhite'),
  resourceType?: string(name='ResourceType'),
  status?: string(name='Status'),
  type?: string(name='Type'),
}

model UpdateBlackWhiteListResponseBody = {
  code?: int32(name='Code'),
  data?: long(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model UpdateBlackWhiteListResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateBlackWhiteListResponseBody(name='body'),
}

async function updateBlackWhiteListWithOptions(request: UpdateBlackWhiteListRequest, runtime: Util.RuntimeOptions): UpdateBlackWhiteListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.content)) {
    query['Content'] = request.content;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.isWhite)) {
    query['IsWhite'] = request.isWhite;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateBlackWhiteList',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateBlackWhiteList(request: UpdateBlackWhiteListRequest): UpdateBlackWhiteListResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateBlackWhiteListWithOptions(request, runtime);
}

model UpdateClusterRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterAliasName?: string(name='ClusterAliasName'),
  instanceId?: string(name='InstanceId'),
  requestPars?: string(name='RequestPars'),
}

model UpdateClusterResponseBody = {
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateClusterResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateClusterResponseBody(name='body'),
}

async function updateClusterWithOptions(request: UpdateClusterRequest, runtime: Util.RuntimeOptions): UpdateClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clusterAliasName)) {
    query['ClusterAliasName'] = request.clusterAliasName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.requestPars)) {
    query['RequestPars'] = request.requestPars;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateCluster',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateCluster(request: UpdateClusterRequest): UpdateClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateClusterWithOptions(request, runtime);
}

model UpdateConfigRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  autopurgePurgeInterval?: string(name='AutopurgePurgeInterval'),
  autopurgeSnapRetainCount?: string(name='AutopurgeSnapRetainCount'),
  clusterId?: string(name='ClusterId'),
  configAuthEnabled?: boolean(name='ConfigAuthEnabled'),
  configSecretEnabled?: boolean(name='ConfigSecretEnabled'),
  configType?: string(name='ConfigType'),
  initLimit?: string(name='InitLimit'),
  instanceId?: string(name='InstanceId'),
  juteMaxbuffer?: string(name='JuteMaxbuffer'),
  MCPEnabled?: boolean(name='MCPEnabled'),
  maxClientCnxns?: string(name='MaxClientCnxns'),
  maxSessionTimeout?: string(name='MaxSessionTimeout', description='最大超时时间'),
  minSessionTimeout?: string(name='MinSessionTimeout', description='最小超时时间'),
  openSuperAcl?: string(name='OpenSuperAcl'),
  passWord?: string(name='PassWord'),
  requestPars?: string(name='RequestPars'),
  syncLimit?: string(name='SyncLimit'),
  tickTime?: string(name='TickTime'),
  userName?: string(name='UserName'),
}

model UpdateConfigResponseBody = {
  code?: int32(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateConfigResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateConfigResponseBody(name='body'),
}

async function updateConfigWithOptions(request: UpdateConfigRequest, runtime: Util.RuntimeOptions): UpdateConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.autopurgePurgeInterval)) {
    query['AutopurgePurgeInterval'] = request.autopurgePurgeInterval;
  }
  if (!Util.isUnset(request.autopurgeSnapRetainCount)) {
    query['AutopurgeSnapRetainCount'] = request.autopurgeSnapRetainCount;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.configAuthEnabled)) {
    query['ConfigAuthEnabled'] = request.configAuthEnabled;
  }
  if (!Util.isUnset(request.configSecretEnabled)) {
    query['ConfigSecretEnabled'] = request.configSecretEnabled;
  }
  if (!Util.isUnset(request.configType)) {
    query['ConfigType'] = request.configType;
  }
  if (!Util.isUnset(request.initLimit)) {
    query['InitLimit'] = request.initLimit;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.juteMaxbuffer)) {
    query['JuteMaxbuffer'] = request.juteMaxbuffer;
  }
  if (!Util.isUnset(request.MCPEnabled)) {
    query['MCPEnabled'] = request.MCPEnabled;
  }
  if (!Util.isUnset(request.maxClientCnxns)) {
    query['MaxClientCnxns'] = request.maxClientCnxns;
  }
  if (!Util.isUnset(request.maxSessionTimeout)) {
    query['MaxSessionTimeout'] = request.maxSessionTimeout;
  }
  if (!Util.isUnset(request.minSessionTimeout)) {
    query['MinSessionTimeout'] = request.minSessionTimeout;
  }
  if (!Util.isUnset(request.passWord)) {
    query['PassWord'] = request.passWord;
  }
  if (!Util.isUnset(request.requestPars)) {
    query['RequestPars'] = request.requestPars;
  }
  if (!Util.isUnset(request.syncLimit)) {
    query['SyncLimit'] = request.syncLimit;
  }
  if (!Util.isUnset(request.tickTime)) {
    query['TickTime'] = request.tickTime;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.openSuperAcl)) {
    body['OpenSuperAcl'] = request.openSuperAcl;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateConfig',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateConfig(request: UpdateConfigRequest): UpdateConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateConfigWithOptions(request, runtime);
}

model UpdateEngineNamespaceRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterId?: string(name='ClusterId'),
  desc?: string(name='Desc'),
  id?: string(name='Id'),
  instanceId?: string(name='InstanceId'),
  name?: string(name='Name'),
  serviceCount?: int32(name='ServiceCount'),
}

model UpdateEngineNamespaceResponseBody = {
  data?: {
    configCount?: int32(name='ConfigCount'),
    namespace?: string(name='Namespace'),
    namespaceDesc?: string(name='NamespaceDesc'),
    namespaceShowName?: string(name='NamespaceShowName'),
    quota?: int32(name='Quota'),
    type?: int32(name='Type'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateEngineNamespaceResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateEngineNamespaceResponseBody(name='body'),
}

async function updateEngineNamespaceWithOptions(request: UpdateEngineNamespaceRequest, runtime: Util.RuntimeOptions): UpdateEngineNamespaceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.desc)) {
    query['Desc'] = request.desc;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.serviceCount)) {
    query['ServiceCount'] = request.serviceCount;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateEngineNamespace',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateEngineNamespace(request: UpdateEngineNamespaceRequest): UpdateEngineNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateEngineNamespaceWithOptions(request, runtime);
}

model UpdateGatewayDomainRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  certIdentifier?: string(name='CertIdentifier'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  id?: long(name='Id'),
  mustHttps?: boolean(name='MustHttps'),
  protocol?: string(name='Protocol'),
}

model UpdateGatewayDomainResponseBody = {
  code?: int32(name='Code'),
  data?: long(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model UpdateGatewayDomainResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateGatewayDomainResponseBody(name='body'),
}

async function updateGatewayDomainWithOptions(request: UpdateGatewayDomainRequest, runtime: Util.RuntimeOptions): UpdateGatewayDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.certIdentifier)) {
    query['CertIdentifier'] = request.certIdentifier;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.mustHttps)) {
    query['MustHttps'] = request.mustHttps;
  }
  if (!Util.isUnset(request.protocol)) {
    query['Protocol'] = request.protocol;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateGatewayDomain',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateGatewayDomain(request: UpdateGatewayDomainRequest): UpdateGatewayDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateGatewayDomainWithOptions(request, runtime);
}

model UpdateGatewayNameRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  name?: string(name='Name'),
}

model UpdateGatewayNameResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model UpdateGatewayNameResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateGatewayNameResponseBody(name='body'),
}

async function updateGatewayNameWithOptions(request: UpdateGatewayNameRequest, runtime: Util.RuntimeOptions): UpdateGatewayNameResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateGatewayName',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateGatewayName(request: UpdateGatewayNameRequest): UpdateGatewayNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateGatewayNameWithOptions(request, runtime);
}

model UpdateGatewayOptionRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayId?: long(name='GatewayId'),
  gatewayOption?: GatewayOption(name='GatewayOption'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
}

model UpdateGatewayOptionShrinkRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayId?: long(name='GatewayId'),
  gatewayOptionShrink?: string(name='GatewayOption'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
}

model UpdateGatewayOptionResponseBody = {
  code?: int32(name='Code'),
  data?: GatewayOption(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model UpdateGatewayOptionResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateGatewayOptionResponseBody(name='body'),
}

async function updateGatewayOptionWithOptions(tmpReq: UpdateGatewayOptionRequest, runtime: Util.RuntimeOptions): UpdateGatewayOptionResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateGatewayOptionShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.gatewayOption)) {
    request.gatewayOptionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.gatewayOption, 'GatewayOption', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.gatewayId)) {
    query['GatewayId'] = request.gatewayId;
  }
  if (!Util.isUnset(request.gatewayOptionShrink)) {
    query['GatewayOption'] = request.gatewayOptionShrink;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateGatewayOption',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateGatewayOption(request: UpdateGatewayOptionRequest): UpdateGatewayOptionResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateGatewayOptionWithOptions(request, runtime);
}

model UpdateGatewayRouteHTTPRewriteRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayId?: long(name='GatewayId'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  httpRewriteJSON?: string(name='HttpRewriteJSON'),
  id?: long(name='Id'),
}

model UpdateGatewayRouteHTTPRewriteResponseBody = {
  code?: int32(name='Code'),
  data?: long(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model UpdateGatewayRouteHTTPRewriteResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateGatewayRouteHTTPRewriteResponseBody(name='body'),
}

async function updateGatewayRouteHTTPRewriteWithOptions(request: UpdateGatewayRouteHTTPRewriteRequest, runtime: Util.RuntimeOptions): UpdateGatewayRouteHTTPRewriteResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.gatewayId)) {
    query['GatewayId'] = request.gatewayId;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.httpRewriteJSON)) {
    query['HttpRewriteJSON'] = request.httpRewriteJSON;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateGatewayRouteHTTPRewrite',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateGatewayRouteHTTPRewrite(request: UpdateGatewayRouteHTTPRewriteRequest): UpdateGatewayRouteHTTPRewriteResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateGatewayRouteHTTPRewriteWithOptions(request, runtime);
}

model UpdateGatewayServiceVersionRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  serviceId?: long(name='ServiceId'),
  serviceVersion?: string(name='ServiceVersion'),
}

model UpdateGatewayServiceVersionResponseBody = {
  code?: int32(name='Code'),
  data?: long(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model UpdateGatewayServiceVersionResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateGatewayServiceVersionResponseBody(name='body'),
}

async function updateGatewayServiceVersionWithOptions(request: UpdateGatewayServiceVersionRequest, runtime: Util.RuntimeOptions): UpdateGatewayServiceVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.serviceId)) {
    query['ServiceId'] = request.serviceId;
  }
  if (!Util.isUnset(request.serviceVersion)) {
    query['ServiceVersion'] = request.serviceVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateGatewayServiceVersion',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateGatewayServiceVersion(request: UpdateGatewayServiceVersionRequest): UpdateGatewayServiceVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateGatewayServiceVersionWithOptions(request, runtime);
}

model UpdateImageRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterId?: string(name='ClusterId', description='目标集群的id'),
  versionCode?: string(name='VersionCode', description='想修改的镜像版本code'),
}

model UpdateImageResponseBody = {
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model UpdateImageResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateImageResponseBody(name='body'),
}

async function updateImageWithOptions(request: UpdateImageRequest, runtime: Util.RuntimeOptions): UpdateImageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.versionCode)) {
    query['VersionCode'] = request.versionCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateImage',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateImage(request: UpdateImageRequest): UpdateImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateImageWithOptions(request, runtime);
}

model UpdateNacosClusterRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  checkPort?: int32(name='CheckPort', description='健康检查端口'),
  clusterName?: string(name='ClusterName', description='Nacos集群名'),
  groupName?: string(name='GroupName', description='分组名'),
  healthChecker?: string(name='HealthChecker', description='健康检查类型'),
  instanceId?: string(name='InstanceId', description='实例id'),
  namespaceId?: string(name='NamespaceId', description='命名空间id'),
  serviceName?: string(name='ServiceName', description='服务名'),
  useInstancePortForCheck?: boolean(name='UseInstancePortForCheck', description='是否使用实例端口进行健康检查'),
}

model UpdateNacosClusterResponseBody = {
  code?: int32(name='Code', description='响应码'),
  data?: string(name='Data', description='修改结果'),
  httpStatusCode?: int32(name='HttpStatusCode', description='http状态码'),
  message?: string(name='Message', description='响应信息'),
  requestId?: string(name='RequestId', description='请求id'),
  success?: boolean(name='Success', description='成功标志'),
}

model UpdateNacosClusterResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateNacosClusterResponseBody(name='body'),
}

async function updateNacosClusterWithOptions(request: UpdateNacosClusterRequest, runtime: Util.RuntimeOptions): UpdateNacosClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.checkPort)) {
    query['CheckPort'] = request.checkPort;
  }
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.healthChecker)) {
    query['HealthChecker'] = request.healthChecker;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  if (!Util.isUnset(request.serviceName)) {
    query['ServiceName'] = request.serviceName;
  }
  if (!Util.isUnset(request.useInstancePortForCheck)) {
    query['UseInstancePortForCheck'] = request.useInstancePortForCheck;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateNacosCluster',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateNacosCluster(request: UpdateNacosClusterRequest): UpdateNacosClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateNacosClusterWithOptions(request, runtime);
}

model UpdateNacosConfigRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  appName?: string(name='AppName'),
  betaIps?: string(name='BetaIps'),
  content?: string(name='Content'),
  dataId?: string(name='DataId'),
  desc?: string(name='Desc'),
  encryptedDataKey?: string(name='EncryptedDataKey'),
  group?: string(name='Group'),
  instanceId?: string(name='InstanceId'),
  md5?: string(name='Md5'),
  namespaceId?: string(name='NamespaceId'),
  tags?: string(name='Tags'),
  type?: string(name='Type'),
}

model UpdateNacosConfigResponseBody = {
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateNacosConfigResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateNacosConfigResponseBody(name='body'),
}

async function updateNacosConfigWithOptions(request: UpdateNacosConfigRequest, runtime: Util.RuntimeOptions): UpdateNacosConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.betaIps)) {
    query['BetaIps'] = request.betaIps;
  }
  if (!Util.isUnset(request.content)) {
    query['Content'] = request.content;
  }
  if (!Util.isUnset(request.dataId)) {
    query['DataId'] = request.dataId;
  }
  if (!Util.isUnset(request.desc)) {
    query['Desc'] = request.desc;
  }
  if (!Util.isUnset(request.encryptedDataKey)) {
    query['EncryptedDataKey'] = request.encryptedDataKey;
  }
  if (!Util.isUnset(request.group)) {
    query['Group'] = request.group;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.md5)) {
    query['Md5'] = request.md5;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateNacosConfig',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateNacosConfig(request: UpdateNacosConfigRequest): UpdateNacosConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateNacosConfigWithOptions(request, runtime);
}

model UpdateNacosInstanceRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterName?: string(name='ClusterName', description='Nacos集群名'),
  enabled?: boolean(name='Enabled', description='服务禁用标志'),
  ephemeral?: boolean(name='Ephemeral', description='临时节点标志'),
  groupName?: string(name='GroupName', description='分组名'),
  instanceId?: string(name='InstanceId', description='实例id'),
  ip?: string(name='Ip', description='Nacos实例ip'),
  metadata?: string(name='Metadata', description='节点元数据'),
  namespaceId?: string(name='NamespaceId', description='命名空间id'),
  port?: int32(name='Port', description='Nacos实例端口'),
  serviceName?: string(name='ServiceName', description='服务名'),
  weight?: string(name='Weight', description='权重'),
}

model UpdateNacosInstanceResponseBody = {
  code?: int32(name='Code', description='响应码'),
  data?: string(name='Data', description='修改结果'),
  httpStatusCode?: int32(name='HttpStatusCode', description='http状态码'),
  message?: string(name='Message', description='响应信息'),
  requestId?: string(name='RequestId', description='请求id'),
  success?: boolean(name='Success', description='成功标志'),
}

model UpdateNacosInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateNacosInstanceResponseBody(name='body'),
}

async function updateNacosInstanceWithOptions(request: UpdateNacosInstanceRequest, runtime: Util.RuntimeOptions): UpdateNacosInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.enabled)) {
    query['Enabled'] = request.enabled;
  }
  if (!Util.isUnset(request.ephemeral)) {
    query['Ephemeral'] = request.ephemeral;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ip)) {
    query['Ip'] = request.ip;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  if (!Util.isUnset(request.port)) {
    query['Port'] = request.port;
  }
  if (!Util.isUnset(request.serviceName)) {
    query['ServiceName'] = request.serviceName;
  }
  if (!Util.isUnset(request.weight)) {
    query['Weight'] = request.weight;
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.metadata)) {
    body['Metadata'] = request.metadata;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateNacosInstance',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateNacosInstance(request: UpdateNacosInstanceRequest): UpdateNacosInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateNacosInstanceWithOptions(request, runtime);
}

model UpdateNacosServiceRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterId?: string(name='ClusterId'),
  groupName?: string(name='GroupName'),
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
  protectThreshold?: string(name='ProtectThreshold'),
  serviceName?: string(name='ServiceName'),
}

model UpdateNacosServiceResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateNacosServiceResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateNacosServiceResponseBody(name='body'),
}

async function updateNacosServiceWithOptions(request: UpdateNacosServiceRequest, runtime: Util.RuntimeOptions): UpdateNacosServiceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  if (!Util.isUnset(request.protectThreshold)) {
    query['ProtectThreshold'] = request.protectThreshold;
  }
  if (!Util.isUnset(request.serviceName)) {
    query['ServiceName'] = request.serviceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateNacosService',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateNacosService(request: UpdateNacosServiceRequest): UpdateNacosServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateNacosServiceWithOptions(request, runtime);
}

model UpdateSSLCertRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  certIdentifier?: string(name='CertIdentifier'),
  domainId?: long(name='DomainId'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
}

model UpdateSSLCertResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model UpdateSSLCertResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateSSLCertResponseBody(name='body'),
}

async function updateSSLCertWithOptions(request: UpdateSSLCertRequest, runtime: Util.RuntimeOptions): UpdateSSLCertResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSSLCert',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateSSLCert(request: UpdateSSLCertRequest): UpdateSSLCertResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSSLCertWithOptions(request, runtime);
}

model UpdateZnodeRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterId?: string(name='ClusterId'),
  data?: string(name='Data'),
  path?: string(name='Path'),
  requestPars?: string(name='RequestPars'),
}

model UpdateZnodeResponseBody = {
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateZnodeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateZnodeResponseBody(name='body'),
}

async function updateZnodeWithOptions(request: UpdateZnodeRequest, runtime: Util.RuntimeOptions): UpdateZnodeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.data)) {
    query['Data'] = request.data;
  }
  if (!Util.isUnset(request.path)) {
    query['Path'] = request.path;
  }
  if (!Util.isUnset(request.requestPars)) {
    query['RequestPars'] = request.requestPars;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateZnode',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateZnode(request: UpdateZnodeRequest): UpdateZnodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateZnodeWithOptions(request, runtime);
}

model UpgradeClusterRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  instanceId?: string(name='InstanceId'),
  requestPars?: string(name='RequestPars'),
  upgradeVersion?: string(name='UpgradeVersion'),
}

model UpgradeClusterResponseBody = {
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpgradeClusterResponse = {
  headers: map[string]string(name='headers'),
  body: UpgradeClusterResponseBody(name='body'),
}

async function upgradeClusterWithOptions(request: UpgradeClusterRequest, runtime: Util.RuntimeOptions): UpgradeClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.requestPars)) {
    query['RequestPars'] = request.requestPars;
  }
  if (!Util.isUnset(request.upgradeVersion)) {
    query['UpgradeVersion'] = request.upgradeVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpgradeCluster',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function upgradeCluster(request: UpgradeClusterRequest): UpgradeClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeClusterWithOptions(request, runtime);
}

