/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  @endpointMap = {
    cn-chengdu = 'mse.cn-chegndu.aliyuncs.com',
    ap-northeast-1 = 'mse. ap-northeast-1.aliyuncs.com',
    cn-shanghai-finance-1 = 'msefinance-share.cn-shanghai-finance-1.aliyuncs.com',
    cn-shenzhen-finance-1 = 'msefinance-share.cn-shenzhen-finance-1.aliyuncs.com',
  };
  checkConfig(config);
  @endpoint = getEndpoint('mse', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model ListAlarmHistoriesRequest {
  requestPars?: string(name='RequestPars'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  alarmMseType?: string(name='AlarmMseType'),
  startTime?: long(name='StartTime'),
  endTime?: long(name='EndTime'),
  alarmName?: string(name='AlarmName'),
}

model ListAlarmHistoriesResponseBody = {
  httpCode?: string(name='HttpCode'),
  totalCount?: int32(name='TotalCount'),
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  data?: [ 
    {
      alarmTime?: string(name='AlarmTime'),
      alarmEmail?: string(name='AlarmEmail'),
      alarmDingDing?: string(name='AlarmDingDing'),
      alarmPhone?: string(name='AlarmPhone'),
      alarmName?: string(name='AlarmName'),
      alarmContent?: string(name='AlarmContent'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model ListAlarmHistoriesResponse = {
  headers: map[string]string(name='headers'),
  body: ListAlarmHistoriesResponseBody(name='body'),
}

async function listAlarmHistoriesWithOptions(request: ListAlarmHistoriesRequest, runtime: Util.RuntimeOptions): ListAlarmHistoriesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListAlarmHistories', '2019-05-31', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listAlarmHistories(request: ListAlarmHistoriesRequest): ListAlarmHistoriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAlarmHistoriesWithOptions(request, runtime);
}

model GetGovernanceKubernetesClusterListRequest {
  clusterName?: string(name='ClusterName'),
  clusterId?: string(name='ClusterId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model GetGovernanceKubernetesClusterListResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    result?: [ 
      {
        clusterName?: string(name='ClusterName'),
        clusterId?: string(name='ClusterId'),
        region?: string(name='Region'),
        k8sVersion?: string(name='K8sVersion'),
        namespaceInfos?: string(name='NamespaceInfos'),
        pilotStartTime?: string(name='PilotStartTime'),
      }
    ](name='Result'),
    totalSize?: int32(name='TotalSize'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
  }(name='Data'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model GetGovernanceKubernetesClusterListResponse = {
  headers: map[string]string(name='headers'),
  body: GetGovernanceKubernetesClusterListResponseBody(name='body'),
}

async function getGovernanceKubernetesClusterListWithOptions(request: GetGovernanceKubernetesClusterListRequest, runtime: Util.RuntimeOptions): GetGovernanceKubernetesClusterListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetGovernanceKubernetesClusterList', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getGovernanceKubernetesClusterList(request: GetGovernanceKubernetesClusterListRequest): GetGovernanceKubernetesClusterListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getGovernanceKubernetesClusterListWithOptions(request, runtime);
}

model ListClusterConnectionTypesResponseBody = {
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  data?: [ 
    {
      showName?: string(name='ShowName'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model ListClusterConnectionTypesResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterConnectionTypesResponseBody(name='body'),
}

async function listClusterConnectionTypesWithOptions(runtime: Util.RuntimeOptions): ListClusterConnectionTypesResponse {
  var req = new OpenApi.OpenApiRequest{};
  return doRPCRequest('ListClusterConnectionTypes', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listClusterConnectionTypes(): ListClusterConnectionTypesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClusterConnectionTypesWithOptions(runtime);
}

model CreateEngineNamespaceRequest {
  clusterId?: string(name='ClusterId'),
  name?: string(name='Name'),
  desc?: string(name='Desc'),
  instanceId?: string(name='InstanceId'),
  serviceCount?: int32(name='ServiceCount'),
}

model CreateEngineNamespaceResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  clusterId?: string(name='ClusterId'),
  data?: {
    type?: int32(name='Type'),
    namespaceShowName?: string(name='NamespaceShowName'),
    quota?: int32(name='Quota'),
    namespace?: string(name='Namespace'),
    namespaceDesc?: string(name='NamespaceDesc'),
    configCount?: int32(name='ConfigCount'),
    serviceCount?: int32(name='ServiceCount'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model CreateEngineNamespaceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateEngineNamespaceResponseBody(name='body'),
}

async function createEngineNamespaceWithOptions(request: CreateEngineNamespaceRequest, runtime: Util.RuntimeOptions): CreateEngineNamespaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateEngineNamespace', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createEngineNamespace(request: CreateEngineNamespaceRequest): CreateEngineNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createEngineNamespaceWithOptions(request, runtime);
}

model ListClusterVersionsRequest {
  clusterType?: string(name='ClusterType'),
}

model ListClusterVersionsResponseBody = {
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  data?: [ 
    {
      showName?: string(name='ShowName'),
      clusterType?: string(name='ClusterType'),
      code?: string(name='Code'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model ListClusterVersionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterVersionsResponseBody(name='body'),
}

async function listClusterVersionsWithOptions(request: ListClusterVersionsRequest, runtime: Util.RuntimeOptions): ListClusterVersionsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListClusterVersions', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listClusterVersions(request: ListClusterVersionsRequest): ListClusterVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClusterVersionsWithOptions(request, runtime);
}

model ListEngineNamespacesRequest {
  instanceId?: string(name='InstanceId'),
}

model ListEngineNamespacesResponseBody = {
  httpCode?: string(name='HttpCode'),
  totalCount?: int32(name='TotalCount'),
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  data?: [ 
    {
      type?: int32(name='Type'),
      namespaceShowName?: string(name='NamespaceShowName'),
      quota?: int32(name='Quota'),
      namespace?: string(name='Namespace'),
      namespaceDesc?: string(name='NamespaceDesc'),
      configCount?: int32(name='ConfigCount'),
      serviceCount?: string(name='ServiceCount'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model ListEngineNamespacesResponse = {
  headers: map[string]string(name='headers'),
  body: ListEngineNamespacesResponseBody(name='body'),
}

async function listEngineNamespacesWithOptions(request: ListEngineNamespacesRequest, runtime: Util.RuntimeOptions): ListEngineNamespacesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListEngineNamespaces', '2019-05-31', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listEngineNamespaces(request: ListEngineNamespacesRequest): ListEngineNamespacesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEngineNamespacesWithOptions(request, runtime);
}

model CreateApplicationRequest {
  appName?: string(name='AppName'),
  region?: string(name='Region'),
  source?: string(name='Source'),
  language?: string(name='Language'),
  extraInfo?: string(name='ExtraInfo'),
}

model CreateApplicationResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    status?: int32(name='Status'),
    extraInfo?: string(name='ExtraInfo'),
    appName?: string(name='AppName'),
    updateTime?: long(name='UpdateTime'),
    licenseKey?: string(name='LicenseKey'),
    createTime?: long(name='CreateTime'),
    appId?: string(name='AppId'),
    userId?: string(name='UserId'),
    source?: string(name='Source'),
    language?: string(name='Language'),
    regionId?: string(name='RegionId'),
  }(name='Data'),
  code?: int32(name='Code'),
  success?: string(name='Success'),
  httpStatusCode?: int32(name='HttpStatusCode'),
}

model CreateApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: CreateApplicationResponseBody(name='body'),
}

async function createApplicationWithOptions(request: CreateApplicationRequest, runtime: Util.RuntimeOptions): CreateApplicationResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateApplication', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createApplication(request: CreateApplicationRequest): CreateApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return createApplicationWithOptions(request, runtime);
}

model GetOverviewRequest {
  period?: int32(name='Period'),
  region?: string(name='Region'),
}

model GetOverviewResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
  code?: int32(name='Code'),
  success?: string(name='Success'),
  httpStatusCode?: int32(name='HttpStatusCode'),
}

model GetOverviewResponse = {
  headers: map[string]string(name='headers'),
  body: GetOverviewResponseBody(name='body'),
}

async function getOverviewWithOptions(request: GetOverviewRequest, runtime: Util.RuntimeOptions): GetOverviewResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetOverview', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getOverview(request: GetOverviewRequest): GetOverviewResponse {
  var runtime = new Util.RuntimeOptions{};
  return getOverviewWithOptions(request, runtime);
}

model QueryMonitorRequest {
  requestPars?: string(name='RequestPars'),
  monitorType?: string(name='MonitorType'),
  startTime?: long(name='StartTime'),
  endTime?: long(name='EndTime'),
  step?: long(name='Step'),
  instanceId?: string(name='InstanceId'),
}

model QueryMonitorResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model QueryMonitorResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMonitorResponseBody(name='body'),
}

async function queryMonitorWithOptions(request: QueryMonitorRequest, runtime: Util.RuntimeOptions): QueryMonitorResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('QueryMonitor', '2019-05-31', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function queryMonitor(request: QueryMonitorRequest): QueryMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMonitorWithOptions(request, runtime);
}

model ScalingClusterRequest {
  instanceCount?: int32(name='InstanceCount'),
  cpu?: int32(name='Cpu'),
  memoryCapacity?: long(name='MemoryCapacity'),
  clusterSpecification?: string(name='ClusterSpecification'),
  instanceId?: string(name='InstanceId'),
}

model ScalingClusterResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model ScalingClusterResponse = {
  headers: map[string]string(name='headers'),
  body: ScalingClusterResponseBody(name='body'),
}

async function scalingClusterWithOptions(request: ScalingClusterRequest, runtime: Util.RuntimeOptions): ScalingClusterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ScalingCluster', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function scalingCluster(request: ScalingClusterRequest): ScalingClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return scalingClusterWithOptions(request, runtime);
}

model ListAnsServicesRequest {
  requestPars?: string(name='RequestPars'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  clusterId?: string(name='ClusterId'),
  serviceName?: string(name='ServiceName'),
  groupName?: string(name='GroupName'),
  hasIpCount?: string(name='HasIpCount'),
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
}

model ListAnsServicesResponseBody = {
  httpCode?: string(name='HttpCode'),
  totalCount?: int32(name='TotalCount'),
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  data?: [ 
    {
      healthyInstanceCount?: int32(name='HealthyInstanceCount'),
      groupName?: string(name='GroupName'),
      ipCount?: int32(name='IpCount'),
      name?: string(name='Name'),
      clusterCount?: int32(name='ClusterCount'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model ListAnsServicesResponse = {
  headers: map[string]string(name='headers'),
  body: ListAnsServicesResponseBody(name='body'),
}

async function listAnsServicesWithOptions(request: ListAnsServicesRequest, runtime: Util.RuntimeOptions): ListAnsServicesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListAnsServices', '2019-05-31', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listAnsServices(request: ListAnsServicesRequest): ListAnsServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAnsServicesWithOptions(request, runtime);
}

model ListZnodeChildrenRequest {
  path?: string(name='Path'),
  clusterId?: string(name='ClusterId'),
}

model ListZnodeChildrenResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: [ 
    {
      data?: string(name='Data'),
      path?: string(name='Path'),
      dir?: boolean(name='Dir'),
      name?: string(name='Name'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model ListZnodeChildrenResponse = {
  headers: map[string]string(name='headers'),
  body: ListZnodeChildrenResponseBody(name='body'),
}

async function listZnodeChildrenWithOptions(request: ListZnodeChildrenRequest, runtime: Util.RuntimeOptions): ListZnodeChildrenResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListZnodeChildren', '2019-05-31', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listZnodeChildren(request: ListZnodeChildrenRequest): ListZnodeChildrenResponse {
  var runtime = new Util.RuntimeOptions{};
  return listZnodeChildrenWithOptions(request, runtime);
}

model DeleteEngineNamespaceRequest {
  id?: string(name='Id'),
  instanceId?: string(name='InstanceId'),
  clusterId?: string(name='ClusterId'),
}

model DeleteEngineNamespaceResponseBody = {
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model DeleteEngineNamespaceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteEngineNamespaceResponseBody(name='body'),
}

async function deleteEngineNamespaceWithOptions(request: DeleteEngineNamespaceRequest, runtime: Util.RuntimeOptions): DeleteEngineNamespaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteEngineNamespace', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteEngineNamespace(request: DeleteEngineNamespaceRequest): DeleteEngineNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteEngineNamespaceWithOptions(request, runtime);
}

model DeleteZnodeRequest {
  requestPars?: string(name='RequestPars'),
  clusterId?: string(name='ClusterId'),
  path?: string(name='Path'),
}

model DeleteZnodeResponseBody = {
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    data?: string(name='Data'),
    path?: string(name='Path'),
    dir?: boolean(name='Dir'),
    name?: string(name='Name'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model DeleteZnodeResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteZnodeResponseBody(name='body'),
}

async function deleteZnodeWithOptions(request: DeleteZnodeRequest, runtime: Util.RuntimeOptions): DeleteZnodeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteZnode', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteZnode(request: DeleteZnodeRequest): DeleteZnodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteZnodeWithOptions(request, runtime);
}

model ExportNacosConfigRequest {
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
  ids?: string(name='Ids'),
  dataId?: string(name='DataId'),
  group?: string(name='Group'),
  appName?: string(name='AppName'),
}

model ExportNacosConfigResponseBody = {
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  data?: {
    url?: string(name='Url'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model ExportNacosConfigResponse = {
  headers: map[string]string(name='headers'),
  body: ExportNacosConfigResponseBody(name='body'),
}

async function exportNacosConfigWithOptions(request: ExportNacosConfigRequest, runtime: Util.RuntimeOptions): ExportNacosConfigResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ExportNacosConfig', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function exportNacosConfig(request: ExportNacosConfigRequest): ExportNacosConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return exportNacosConfigWithOptions(request, runtime);
}

model ListNacosHistoryConfigsRequest {
  requestPars?: string(name='RequestPars'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
  dataId?: string(name='DataId'),
  group?: string(name='Group'),
  namespaceId?: string(name='NamespaceId'),
}

model ListNacosHistoryConfigsResponseBody = {
  httpCode?: string(name='HttpCode'),
  totalCount?: int32(name='TotalCount'),
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  historyItems?: [ 
    {
      appName?: string(name='AppName'),
      dataId?: string(name='DataId'),
      group?: string(name='Group'),
      lastModifiedTime?: long(name='LastModifiedTime'),
      id?: long(name='Id'),
      opType?: string(name='OpType'),
    }
  ](name='HistoryItems'),
}

model ListNacosHistoryConfigsResponse = {
  headers: map[string]string(name='headers'),
  body: ListNacosHistoryConfigsResponseBody(name='body'),
}

async function listNacosHistoryConfigsWithOptions(request: ListNacosHistoryConfigsRequest, runtime: Util.RuntimeOptions): ListNacosHistoryConfigsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListNacosHistoryConfigs', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listNacosHistoryConfigs(request: ListNacosHistoryConfigsRequest): ListNacosHistoryConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNacosHistoryConfigsWithOptions(request, runtime);
}

model AddMockRuleRequest {
  name?: string(name='Name'),
  region?: string(name='Region'),
  source?: string(name='Source'),
  providerAppId?: string(name='ProviderAppId'),
  providerAppName?: string(name='ProviderAppName'),
  extraJson?: string(name='ExtraJson'),
  scMockItems?: string(name='ScMockItems'),
  dubboMockItems?: string(name='DubboMockItems'),
  consumerAppIds?: string(name='ConsumerAppIds'),
  enable?: boolean(name='Enable'),
}

model AddMockRuleResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    namespaceId?: string(name='NamespaceId'),
    scMockItemJson?: string(name='ScMockItemJson'),
    consumerAppName?: string(name='ConsumerAppName'),
    consumerAppId?: string(name='ConsumerAppId'),
    accountId?: string(name='AccountId'),
    extraJson?: string(name='ExtraJson'),
    source?: string(name='Source'),
    region?: string(name='Region'),
    providerAppId?: string(name='ProviderAppId'),
    providerAppName?: string(name='ProviderAppName'),
    name?: string(name='Name'),
    id?: long(name='Id'),
    enable?: boolean(name='Enable'),
  }(name='Data'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model AddMockRuleResponse = {
  headers: map[string]string(name='headers'),
  body: AddMockRuleResponseBody(name='body'),
}

async function addMockRuleWithOptions(request: AddMockRuleRequest, runtime: Util.RuntimeOptions): AddMockRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddMockRule', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addMockRule(request: AddMockRuleRequest): AddMockRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return addMockRuleWithOptions(request, runtime);
}

model ListListenersByConfigRequest {
  requestPars?: string(name='RequestPars'),
  instanceId?: string(name='InstanceId'),
  dataId?: string(name='DataId'),
  group?: string(name='Group'),
  namespaceId?: string(name='NamespaceId'),
}

model ListListenersByConfigResponseBody = {
  httpCode?: string(name='HttpCode'),
  totalCount?: int32(name='TotalCount'),
  listeners?: [ 
    {
      ip?: string(name='Ip'),
      md5?: string(name='Md5'),
    }
  ](name='Listeners'),
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model ListListenersByConfigResponse = {
  headers: map[string]string(name='headers'),
  body: ListListenersByConfigResponseBody(name='body'),
}

async function listListenersByConfigWithOptions(request: ListListenersByConfigRequest, runtime: Util.RuntimeOptions): ListListenersByConfigResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListListenersByConfig', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listListenersByConfig(request: ListListenersByConfigRequest): ListListenersByConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return listListenersByConfigWithOptions(request, runtime);
}

model GetGovernanceKubernetesClusterRequest {
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
}

model GetGovernanceKubernetesClusterResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    clusterId?: string(name='ClusterId'),
    clusterName?: string(name='ClusterName'),
    region?: string(name='Region'),
    k8sVersion?: string(name='K8sVersion'),
    namespaceInfos?: string(name='NamespaceInfos'),
    pilotStartTime?: string(name='PilotStartTime'),
    updateTime?: string(name='UpdateTime'),
    namespaces?: [ 
      {
        name?: string(name='Name'),
        tags?: string(name='Tags'),
      }
    ](name='Namespaces'),
  }(name='Data'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model GetGovernanceKubernetesClusterResponse = {
  headers: map[string]string(name='headers'),
  body: GetGovernanceKubernetesClusterResponseBody(name='body'),
}

async function getGovernanceKubernetesClusterWithOptions(request: GetGovernanceKubernetesClusterRequest, runtime: Util.RuntimeOptions): GetGovernanceKubernetesClusterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetGovernanceKubernetesCluster', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getGovernanceKubernetesCluster(request: GetGovernanceKubernetesClusterRequest): GetGovernanceKubernetesClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return getGovernanceKubernetesClusterWithOptions(request, runtime);
}

model QueryGatewayTypeResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
  data?: [ string ](name='Data'),
}

model QueryGatewayTypeResponse = {
  headers: map[string]string(name='headers'),
  body: QueryGatewayTypeResponseBody(name='body'),
}

async function queryGatewayTypeWithOptions(runtime: Util.RuntimeOptions): QueryGatewayTypeResponse {
  var req = new OpenApi.OpenApiRequest{};
  return doRPCRequest('QueryGatewayType', '2019-05-31', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function queryGatewayType(): QueryGatewayTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryGatewayTypeWithOptions(runtime);
}

model QueryClusterSpecificationResponseBody = {
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  data?: [ 
    {
      clusterSpecificationName?: string(name='ClusterSpecificationName'),
      diskCapacity?: string(name='DiskCapacity'),
      memoryCapacity?: string(name='MemoryCapacity'),
      instanceCount?: string(name='InstanceCount'),
      maxTps?: string(name='MaxTps'),
      maxCon?: string(name='MaxCon'),
      cpuCapacity?: string(name='CpuCapacity'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model QueryClusterSpecificationResponse = {
  headers: map[string]string(name='headers'),
  body: QueryClusterSpecificationResponseBody(name='body'),
}

async function queryClusterSpecificationWithOptions(runtime: Util.RuntimeOptions): QueryClusterSpecificationResponse {
  var req = new OpenApi.OpenApiRequest{};
  return doRPCRequest('QueryClusterSpecification', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryClusterSpecification(): QueryClusterSpecificationResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryClusterSpecificationWithOptions(runtime);
}

model ModifyGovernanceKubernetesClusterRequest {
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  namespaceInfos?: string(name='NamespaceInfos'),
}

model ModifyGovernanceKubernetesClusterResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: boolean(name='Data'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model ModifyGovernanceKubernetesClusterResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyGovernanceKubernetesClusterResponseBody(name='body'),
}

async function modifyGovernanceKubernetesClusterWithOptions(request: ModifyGovernanceKubernetesClusterRequest, runtime: Util.RuntimeOptions): ModifyGovernanceKubernetesClusterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyGovernanceKubernetesCluster', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyGovernanceKubernetesCluster(request: ModifyGovernanceKubernetesClusterRequest): ModifyGovernanceKubernetesClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyGovernanceKubernetesClusterWithOptions(request, runtime);
}

model ImportNacosConfigRequest {
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
  policy?: string(name='Policy'),
  fileUrl?: string(name='FileUrl'),
}

model ImportNacosConfigResponseBody = {
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  data?: {
    succCount?: int32(name='SuccCount'),
    failData?: [ 
      {
        dataId?: string(name='DataId'),
        group?: string(name='Group'),
      }
    ](name='FailData'),
    skipCount?: int32(name='SkipCount'),
    skipData?: [ 
      {
        dataId?: string(name='DataId'),
        group?: string(name='Group'),
      }
    ](name='SkipData'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model ImportNacosConfigResponse = {
  headers: map[string]string(name='headers'),
  body: ImportNacosConfigResponseBody(name='body'),
}

async function importNacosConfigWithOptions(request: ImportNacosConfigRequest, runtime: Util.RuntimeOptions): ImportNacosConfigResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ImportNacosConfig', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function importNacosConfig(request: ImportNacosConfigRequest): ImportNacosConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return importNacosConfigWithOptions(request, runtime);
}

model CreateZnodeRequest {
  clusterId?: string(name='ClusterId'),
  path?: string(name='Path'),
  data?: string(name='Data'),
}

model CreateZnodeResponseBody = {
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    data?: string(name='Data'),
    path?: string(name='Path'),
    dir?: boolean(name='Dir'),
    name?: string(name='Name'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model CreateZnodeResponse = {
  headers: map[string]string(name='headers'),
  body: CreateZnodeResponseBody(name='body'),
}

async function createZnodeWithOptions(request: CreateZnodeRequest, runtime: Util.RuntimeOptions): CreateZnodeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateZnode', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createZnode(request: CreateZnodeRequest): CreateZnodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return createZnodeWithOptions(request, runtime);
}

model QueryClusterDiskSpecificationRequest {
  clusterType?: string(name='ClusterType'),
}

model QueryClusterDiskSpecificationResponseBody = {
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  data?: {
    step?: int32(name='Step'),
    max?: int32(name='Max'),
    min?: int32(name='Min'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model QueryClusterDiskSpecificationResponse = {
  headers: map[string]string(name='headers'),
  body: QueryClusterDiskSpecificationResponseBody(name='body'),
}

async function queryClusterDiskSpecificationWithOptions(request: QueryClusterDiskSpecificationRequest, runtime: Util.RuntimeOptions): QueryClusterDiskSpecificationResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryClusterDiskSpecification', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryClusterDiskSpecification(request: QueryClusterDiskSpecificationRequest): QueryClusterDiskSpecificationResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryClusterDiskSpecificationWithOptions(request, runtime);
}

model ListNacosConfigsRequest {
  requestPars?: string(name='RequestPars'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
  dataId?: string(name='DataId'),
  group?: string(name='Group'),
  appName?: string(name='AppName'),
  tags?: string(name='Tags'),
  namespaceId?: string(name='NamespaceId'),
}

model ListNacosConfigsResponseBody = {
  httpCode?: string(name='HttpCode'),
  totalCount?: int32(name='TotalCount'),
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  errorCode?: string(name='ErrorCode'),
  configurations?: [ 
    {
      appName?: string(name='AppName'),
      dataId?: string(name='DataId'),
      id?: string(name='Id'),
      group?: string(name='Group'),
    }
  ](name='Configurations'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model ListNacosConfigsResponse = {
  headers: map[string]string(name='headers'),
  body: ListNacosConfigsResponseBody(name='body'),
}

async function listNacosConfigsWithOptions(request: ListNacosConfigsRequest, runtime: Util.RuntimeOptions): ListNacosConfigsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListNacosConfigs', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listNacosConfigs(request: ListNacosConfigsRequest): ListNacosConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNacosConfigsWithOptions(request, runtime);
}

model QueryConfigRequest {
  requestPars?: string(name='RequestPars'),
  clusterId?: string(name='ClusterId'),
  configType?: string(name='ConfigType'),
  instanceId?: string(name='InstanceId'),
}

model QueryConfigResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    maxClientCnxns?: string(name='MaxClientCnxns'),
    configAuthSupported?: boolean(name='ConfigAuthSupported'),
    initLimit?: string(name='InitLimit'),
    MCPEnabled?: boolean(name='MCPEnabled'),
    openSuperAcl?: boolean(name='OpenSuperAcl'),
    restartFlag?: boolean(name='RestartFlag'),
    jvmFlagsCustom?: string(name='JvmFlagsCustom'),
    autopurgePurgeInterval?: string(name='AutopurgePurgeInterval'),
    autopurgeSnapRetainCount?: string(name='AutopurgeSnapRetainCount'),
    syncLimit?: string(name='SyncLimit'),
    configAuthEnabled?: boolean(name='ConfigAuthEnabled'),
    clusterName?: string(name='ClusterName'),
    MCPSupported?: boolean(name='MCPSupported'),
    juteMaxbuffer?: string(name='JuteMaxbuffer'),
    tickTime?: string(name='TickTime'),
    passWord?: string(name='PassWord'),
    userName?: string(name='UserName'),
    configSecretSupported?: boolean(name='ConfigSecretSupported'),
    configSecretEnabled?: boolean(name='ConfigSecretEnabled'),
  }(name='Data'),
  success?: boolean(name='Success'),
  code?: int32(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
}

model QueryConfigResponse = {
  headers: map[string]string(name='headers'),
  body: QueryConfigResponseBody(name='body'),
}

async function queryConfigWithOptions(request: QueryConfigRequest, runtime: Util.RuntimeOptions): QueryConfigResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('QueryConfig', '2019-05-31', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function queryConfig(request: QueryConfigRequest): QueryConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryConfigWithOptions(request, runtime);
}

model ListClusterTypesRequest {
  regionId?: string(name='RegionId'),
}

model ListClusterTypesResponseBody = {
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  data?: [ 
    {
      showName?: string(name='ShowName'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model ListClusterTypesResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterTypesResponseBody(name='body'),
}

async function listClusterTypesWithOptions(request: ListClusterTypesRequest, runtime: Util.RuntimeOptions): ListClusterTypesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListClusterTypes', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listClusterTypes(request: ListClusterTypesRequest): ListClusterTypesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClusterTypesWithOptions(request, runtime);
}

model DeleteNacosConfigsRequest {
  instanceId?: string(name='InstanceId'),
  ids?: string(name='Ids'),
  namespaceId?: string(name='NamespaceId'),
}

model DeleteNacosConfigsResponseBody = {
  httpCode?: string(name='HttpCode'),
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  errorCode?: string(name='ErrorCode'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model DeleteNacosConfigsResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteNacosConfigsResponseBody(name='body'),
}

async function deleteNacosConfigsWithOptions(request: DeleteNacosConfigsRequest, runtime: Util.RuntimeOptions): DeleteNacosConfigsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteNacosConfigs', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteNacosConfigs(request: DeleteNacosConfigsRequest): DeleteNacosConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteNacosConfigsWithOptions(request, runtime);
}

model UpdateNacosConfigRequest {
  instanceId?: string(name='InstanceId'),
  dataId?: string(name='DataId'),
  group?: string(name='Group'),
  appName?: string(name='AppName'),
  tags?: string(name='Tags'),
  desc?: string(name='Desc'),
  type?: string(name='Type'),
  content?: string(name='Content'),
  namespaceId?: string(name='NamespaceId'),
  md5?: string(name='Md5'),
  betaIps?: string(name='BetaIps'),
  encryptedDataKey?: string(name='EncryptedDataKey'),
}

model UpdateNacosConfigResponseBody = {
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model UpdateNacosConfigResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateNacosConfigResponseBody(name='body'),
}

async function updateNacosConfigWithOptions(request: UpdateNacosConfigRequest, runtime: Util.RuntimeOptions): UpdateNacosConfigResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateNacosConfig', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateNacosConfig(request: UpdateNacosConfigRequest): UpdateNacosConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateNacosConfigWithOptions(request, runtime);
}

model GetMseFeatureSwitchResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: map[string]any(name='Result'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model GetMseFeatureSwitchResponse = {
  headers: map[string]string(name='headers'),
  body: GetMseFeatureSwitchResponseBody(name='body'),
}

async function getMseFeatureSwitchWithOptions(runtime: Util.RuntimeOptions): GetMseFeatureSwitchResponse {
  var req = new OpenApi.OpenApiRequest{};
  return doRPCRequest('GetMseFeatureSwitch', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getMseFeatureSwitch(): GetMseFeatureSwitchResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMseFeatureSwitchWithOptions(runtime);
}

model UpdateClusterRequest {
  requestPars?: string(name='RequestPars'),
  clusterAliasName?: string(name='ClusterAliasName'),
  instanceId?: string(name='InstanceId'),
}

model UpdateClusterResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model UpdateClusterResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateClusterResponseBody(name='body'),
}

async function updateClusterWithOptions(request: UpdateClusterRequest, runtime: Util.RuntimeOptions): UpdateClusterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateCluster', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateCluster(request: UpdateClusterRequest): UpdateClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateClusterWithOptions(request, runtime);
}

model CreateClusterRequest {
  pubNetworkFlow?: string(name='PubNetworkFlow'),
  pubSlbSpecification?: string(name='PubSlbSpecification'),
  diskType?: string(name='DiskType'),
  vpcId?: string(name='VpcId'),
  netType?: string(name='NetType'),
  vSwitchId?: string(name='VSwitchId'),
  instanceCount?: int32(name='InstanceCount'),
  clusterSpecification?: string(name='ClusterSpecification'),
  clusterVersion?: string(name='ClusterVersion'),
  clusterType?: string(name='ClusterType'),
  region?: string(name='Region'),
  privateSlbSpecification?: string(name='PrivateSlbSpecification'),
  connectionType?: string(name='ConnectionType'),
  requestPars?: string(name='RequestPars'),
  diskCapacity?: int32(name='DiskCapacity'),
}

model CreateClusterResponseBody = {
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  instanceId?: string(name='InstanceId'),
  errorCode?: string(name='ErrorCode'),
  orderId?: string(name='OrderId'),
  success?: boolean(name='Success'),
}

model CreateClusterResponse = {
  headers: map[string]string(name='headers'),
  body: CreateClusterResponseBody(name='body'),
}

async function createClusterWithOptions(request: CreateClusterRequest, runtime: Util.RuntimeOptions): CreateClusterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateCluster', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createCluster(request: CreateClusterRequest): CreateClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return createClusterWithOptions(request, runtime);
}

model ListEurekaServicesRequest {
  requestPars?: string(name='RequestPars'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  clusterId?: string(name='ClusterId'),
  regionId?: string(name='RegionId'),
}

model ListEurekaServicesResponseBody = {
  httpCode?: string(name='HttpCode'),
  totalCount?: int32(name='TotalCount'),
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  data?: [ 
    {
      instancesId?: [ string ](name='InstancesId'),
      name?: string(name='Name'),
      upStatus?: string(name='UpStatus'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model ListEurekaServicesResponse = {
  headers: map[string]string(name='headers'),
  body: ListEurekaServicesResponseBody(name='body'),
}

async function listEurekaServicesWithOptions(request: ListEurekaServicesRequest, runtime: Util.RuntimeOptions): ListEurekaServicesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListEurekaServices', '2019-05-31', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listEurekaServices(request: ListEurekaServicesRequest): ListEurekaServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEurekaServicesWithOptions(request, runtime);
}

model DeleteClusterRequest {
  instanceId?: string(name='InstanceId'),
}

model DeleteClusterResponseBody = {
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model DeleteClusterResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteClusterResponseBody(name='body'),
}

async function deleteClusterWithOptions(request: DeleteClusterRequest, runtime: Util.RuntimeOptions): DeleteClusterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteCluster', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteCluster(request: DeleteClusterRequest): DeleteClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteClusterWithOptions(request, runtime);
}

model GetEngineNamepaceRequest {
  id?: string(name='Id'),
  instanceId?: string(name='InstanceId'),
  clusterId?: string(name='ClusterId'),
}

model GetEngineNamepaceResponseBody = {
  httpCode?: string(name='HttpCode'),
  type?: string(name='Type'),
  quota?: string(name='Quota'),
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  configCount?: string(name='ConfigCount'),
  namespaceShowName?: string(name='NamespaceShowName'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  namespaceDesc?: string(name='NamespaceDesc'),
  namespace?: string(name='Namespace'),
}

model GetEngineNamepaceResponse = {
  headers: map[string]string(name='headers'),
  body: GetEngineNamepaceResponseBody(name='body'),
}

async function getEngineNamepaceWithOptions(request: GetEngineNamepaceRequest, runtime: Util.RuntimeOptions): GetEngineNamepaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetEngineNamepace', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getEngineNamepace(request: GetEngineNamepaceRequest): GetEngineNamepaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getEngineNamepaceWithOptions(request, runtime);
}

model UpdateZnodeRequest {
  requestPars?: string(name='RequestPars'),
  clusterId?: string(name='ClusterId'),
  path?: string(name='Path'),
  data?: string(name='Data'),
}

model UpdateZnodeResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model UpdateZnodeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateZnodeResponseBody(name='body'),
}

async function updateZnodeWithOptions(request: UpdateZnodeRequest, runtime: Util.RuntimeOptions): UpdateZnodeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateZnode', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateZnode(request: UpdateZnodeRequest): UpdateZnodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateZnodeWithOptions(request, runtime);
}

model QueryClusterDetailRequest {
  instanceId?: string(name='InstanceId'),
  orderId?: string(name='OrderId'),
}

model QueryClusterDetailResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    vpcId?: string(name='VpcId'),
    createTime?: string(name='CreateTime'),
    intranetAddress?: string(name='IntranetAddress'),
    diskType?: string(name='DiskType'),
    pubNetworkFlow?: string(name='PubNetworkFlow'),
    diskCapacity?: long(name='DiskCapacity'),
    memoryCapacity?: long(name='MemoryCapacity'),
    clusterAliasName?: string(name='ClusterAliasName'),
    instanceCount?: int32(name='InstanceCount'),
    intranetPort?: string(name='IntranetPort'),
    instanceModels?: [ 
      {
        podName?: string(name='PodName'),
        singleTunnelVip?: string(name='SingleTunnelVip'),
        internetIp?: string(name='InternetIp'),
        ip?: string(name='Ip'),
        role?: string(name='Role'),
        healthStatus?: string(name='HealthStatus'),
      }
    ](name='InstanceModels'),
    intranetDomain?: string(name='IntranetDomain'),
    internetDomain?: string(name='InternetDomain'),
    payInfo?: string(name='PayInfo'),
    internetAddress?: string(name='InternetAddress'),
    instanceId?: string(name='InstanceId'),
    aclEntryList?: string(name='AclEntryList'),
    healthStatus?: string(name='HealthStatus'),
    initCostTime?: long(name='InitCostTime'),
    regionId?: string(name='RegionId'),
    aclId?: string(name='AclId'),
    cpu?: int32(name='Cpu'),
    clusterType?: string(name='ClusterType'),
    clusterName?: string(name='ClusterName'),
    initStatus?: string(name='InitStatus'),
    internetPort?: string(name='InternetPort'),
    appVersion?: string(name='AppVersion'),
    netType?: string(name='NetType'),
    clusterVersion?: string(name='ClusterVersion'),
    clusterSpecification?: string(name='ClusterSpecification'),
    vSwitchId?: string(name='VSwitchId'),
    connectionType?: string(name='ConnectionType'),
    mseVersion?: string(name='MseVersion'),
    chargeType?: string(name='ChargeType'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model QueryClusterDetailResponse = {
  headers: map[string]string(name='headers'),
  body: QueryClusterDetailResponseBody(name='body'),
}

async function queryClusterDetailWithOptions(request: QueryClusterDetailRequest, runtime: Util.RuntimeOptions): QueryClusterDetailResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryClusterDetail', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryClusterDetail(request: QueryClusterDetailRequest): QueryClusterDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryClusterDetailWithOptions(request, runtime);
}

model DeleteNacosServiceRequest {
  instanceId?: string(name='InstanceId'),
  serviceName?: string(name='ServiceName'),
  groupName?: string(name='GroupName'),
  namespaceId?: string(name='NamespaceId'),
}

model DeleteNacosServiceResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode', description='http'),
  requestId?: string(name='RequestId', description='id'),
  message?: string(name='Message', description=''),
  code?: int32(name='Code', description=''),
  success?: boolean(name='Success', description=''),
  data?: string(name='Data', description=''),
}

model DeleteNacosServiceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteNacosServiceResponseBody(name='body'),
}

async function deleteNacosServiceWithOptions(request: DeleteNacosServiceRequest, runtime: Util.RuntimeOptions): DeleteNacosServiceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteNacosService', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteNacosService(request: DeleteNacosServiceRequest): DeleteNacosServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteNacosServiceWithOptions(request, runtime);
}

model ListAnsServiceClustersRequest {
  requestPars?: string(name='RequestPars'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  clusterId?: string(name='ClusterId'),
  serviceName?: string(name='ServiceName'),
  groupName?: string(name='GroupName'),
  namespaceId?: string(name='NamespaceId'),
  clusterName?: string(name='ClusterName'),
}

model ListAnsServiceClustersResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    protectThreshold?: float(name='ProtectThreshold'),
    groupName?: string(name='GroupName'),
    clusters?: [ 
      {
        defaultCheckPort?: int32(name='DefaultCheckPort'),
        healthCheckerType?: string(name='HealthCheckerType'),
        useIPPort4Check?: boolean(name='UseIPPort4Check'),
        serviceName?: string(name='ServiceName'),
        name?: string(name='Name'),
        defaultPort?: int32(name='DefaultPort'),
        metadata?: map[string]any(name='Metadata'),
      }
    ](name='Clusters'),
    name?: string(name='Name'),
    selectorType?: string(name='SelectorType'),
    metadata?: map[string]any(name='Metadata'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model ListAnsServiceClustersResponse = {
  headers: map[string]string(name='headers'),
  body: ListAnsServiceClustersResponseBody(name='body'),
}

async function listAnsServiceClustersWithOptions(request: ListAnsServiceClustersRequest, runtime: Util.RuntimeOptions): ListAnsServiceClustersResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListAnsServiceClusters', '2019-05-31', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listAnsServiceClusters(request: ListAnsServiceClustersRequest): ListAnsServiceClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAnsServiceClustersWithOptions(request, runtime);
}

model GetNacosConfigRequest {
  instanceId?: string(name='InstanceId'),
  dataId?: string(name='DataId'),
  group?: string(name='Group'),
  namespaceId?: string(name='NamespaceId'),
  beta?: boolean(name='Beta'),
}

model GetNacosConfigResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  configuration?: {
    type?: string(name='Type'),
    appName?: string(name='AppName'),
    tags?: string(name='Tags'),
    md5?: string(name='Md5'),
    dataId?: string(name='DataId'),
    content?: string(name='Content'),
    group?: string(name='Group'),
    desc?: string(name='Desc'),
    encryptedDataKey?: string(name='EncryptedDataKey'),
    betaIps?: string(name='BetaIps'),
  }(name='Configuration'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model GetNacosConfigResponse = {
  headers: map[string]string(name='headers'),
  body: GetNacosConfigResponseBody(name='body'),
}

async function getNacosConfigWithOptions(request: GetNacosConfigRequest, runtime: Util.RuntimeOptions): GetNacosConfigResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetNacosConfig', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getNacosConfig(request: GetNacosConfigRequest): GetNacosConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return getNacosConfigWithOptions(request, runtime);
}

model CloneNacosConfigRequest {
  instanceId?: string(name='InstanceId'),
  originNamespaceId?: string(name='OriginNamespaceId'),
  targetNamespaceId?: string(name='TargetNamespaceId'),
  policy?: string(name='Policy'),
  ids?: string(name='Ids'),
}

model CloneNacosConfigResponseBody = {
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  data?: {
    succCount?: int32(name='SuccCount'),
    failData?: [ 
      {
        dataId?: string(name='DataId'),
        group?: string(name='Group'),
      }
    ](name='FailData'),
    skipCount?: int32(name='SkipCount'),
    skipData?: [ 
      {
        dataId?: string(name='DataId'),
        group?: string(name='Group'),
      }
    ](name='SkipData'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model CloneNacosConfigResponse = {
  headers: map[string]string(name='headers'),
  body: CloneNacosConfigResponseBody(name='body'),
}

async function cloneNacosConfigWithOptions(request: CloneNacosConfigRequest, runtime: Util.RuntimeOptions): CloneNacosConfigResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CloneNacosConfig', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function cloneNacosConfig(request: CloneNacosConfigRequest): CloneNacosConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return cloneNacosConfigWithOptions(request, runtime);
}

model CreateAlarmRuleRequest {
  instanceId?: string(name='InstanceId'),
  alarmAliasName?: string(name='AlarmAliasName'),
  alertWay?: map[string]any(name='AlertWay'),
  contactGroupIds?: map[string]any(name='ContactGroupIds'),
  alarmItem?: string(name='AlarmItem'),
  operator?: string(name='Operator'),
  aggregates?: string(name='Aggregates'),
  NValue?: int32(name='NValue'),
  value?: float(name='Value'),
}

model CreateAlarmRuleShrinkRequest {
  instanceId?: string(name='InstanceId'),
  alarmAliasName?: string(name='AlarmAliasName'),
  alertWayShrink?: string(name='AlertWay'),
  contactGroupIdsShrink?: string(name='ContactGroupIds'),
  alarmItem?: string(name='AlarmItem'),
  operator?: string(name='Operator'),
  aggregates?: string(name='Aggregates'),
  NValue?: int32(name='NValue'),
  value?: float(name='Value'),
}

model CreateAlarmRuleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model CreateAlarmRuleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateAlarmRuleResponseBody(name='body'),
}

async function createAlarmRuleWithOptions(tmpReq: CreateAlarmRuleRequest, runtime: Util.RuntimeOptions): CreateAlarmRuleResponse {
  Util.validateModel(tmpReq);
  var request = new CreateAlarmRuleShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.alertWay)) {
    request.alertWayShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.alertWay, 'AlertWay', 'json');
  }
  if (!Util.isUnset(tmpReq.contactGroupIds)) {
    request.contactGroupIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.contactGroupIds, 'ContactGroupIds', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateAlarmRule', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createAlarmRule(request: CreateAlarmRuleRequest): CreateAlarmRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAlarmRuleWithOptions(request, runtime);
}

model ListListenersByIpRequest {
  requestPars?: string(name='RequestPars'),
  instanceId?: string(name='InstanceId'),
  ip?: string(name='Ip'),
  namespaceId?: string(name='NamespaceId'),
}

model ListListenersByIpResponseBody = {
  httpCode?: string(name='HttpCode'),
  totalCount?: int32(name='TotalCount'),
  listeners?: [ 
    {
      md5?: string(name='Md5'),
      dataId?: string(name='DataId'),
      group?: string(name='Group'),
    }
  ](name='Listeners'),
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model ListListenersByIpResponse = {
  headers: map[string]string(name='headers'),
  body: ListListenersByIpResponseBody(name='body'),
}

async function listListenersByIpWithOptions(request: ListListenersByIpRequest, runtime: Util.RuntimeOptions): ListListenersByIpResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListListenersByIp', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listListenersByIp(request: ListListenersByIpRequest): ListListenersByIpResponse {
  var runtime = new Util.RuntimeOptions{};
  return listListenersByIpWithOptions(request, runtime);
}

model CreateGovernanceKubernetesClusterRequest {
  clusterName?: string(name='ClusterName'),
  clusterId?: string(name='ClusterId'),
  regionId?: string(name='RegionId'),
  k8sVersion?: string(name='K8sVersion'),
  pilotStartTime?: long(name='PilotStartTime'),
  nameSpaceInfos?: string(name='NameSpaceInfos'),
}

model CreateGovernanceKubernetesClusterResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: long(name='Data'),
  code?: int32(name='Code'),
  success?: string(name='Success'),
  httpStatusCode?: int32(name='HttpStatusCode'),
}

model CreateGovernanceKubernetesClusterResponse = {
  headers: map[string]string(name='headers'),
  body: CreateGovernanceKubernetesClusterResponseBody(name='body'),
}

async function createGovernanceKubernetesClusterWithOptions(request: CreateGovernanceKubernetesClusterRequest, runtime: Util.RuntimeOptions): CreateGovernanceKubernetesClusterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateGovernanceKubernetesCluster', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createGovernanceKubernetesCluster(request: CreateGovernanceKubernetesClusterRequest): CreateGovernanceKubernetesClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return createGovernanceKubernetesClusterWithOptions(request, runtime);
}

model ListEurekaInstancesRequest {
  requestPars?: string(name='RequestPars'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  clusterId?: string(name='ClusterId'),
  serviceName?: string(name='ServiceName'),
}

model ListEurekaInstancesResponseBody = {
  httpCode?: string(name='HttpCode'),
  totalCount?: int32(name='TotalCount'),
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  data?: [ 
    {
      status?: string(name='Status'),
      lastDirtyTimestamp?: long(name='LastDirtyTimestamp'),
      ipAddr?: string(name='IpAddr'),
      homePageUrl?: string(name='HomePageUrl'),
      hostName?: string(name='HostName'),
      instanceId?: string(name='InstanceId'),
      port?: int32(name='Port'),
      securePort?: int32(name='SecurePort'),
      app?: string(name='App'),
      durationInSecs?: int32(name='DurationInSecs'),
      lastUpdatedTimestamp?: long(name='LastUpdatedTimestamp'),
      renewalIntervalInSecs?: int32(name='RenewalIntervalInSecs'),
      vipAddress?: string(name='VipAddress'),
      metadata?: map[string]any(name='Metadata'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model ListEurekaInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: ListEurekaInstancesResponseBody(name='body'),
}

async function listEurekaInstancesWithOptions(request: ListEurekaInstancesRequest, runtime: Util.RuntimeOptions): ListEurekaInstancesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListEurekaInstances', '2019-05-31', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listEurekaInstances(request: ListEurekaInstancesRequest): ListEurekaInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEurekaInstancesWithOptions(request, runtime);
}

model DeleteNacosConfigRequest {
  instanceId?: string(name='InstanceId'),
  dataId?: string(name='DataId'),
  group?: string(name='Group'),
  namespaceId?: string(name='NamespaceId'),
  beta?: boolean(name='Beta'),
}

model DeleteNacosConfigResponseBody = {
  httpCode?: string(name='HttpCode'),
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  errorCode?: string(name='ErrorCode'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DeleteNacosConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteNacosConfigResponseBody(name='body'),
}

async function deleteNacosConfigWithOptions(request: DeleteNacosConfigRequest, runtime: Util.RuntimeOptions): DeleteNacosConfigResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteNacosConfig', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteNacosConfig(request: DeleteNacosConfigRequest): DeleteNacosConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteNacosConfigWithOptions(request, runtime);
}

model UpdateEngineNamespaceRequest {
  name?: string(name='Name'),
  desc?: string(name='Desc'),
  serviceCount?: int32(name='ServiceCount'),
  id?: string(name='Id'),
  clusterId?: string(name='ClusterId'),
  instanceId?: string(name='InstanceId'),
}

model UpdateEngineNamespaceResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    type?: int32(name='Type'),
    namespaceShowName?: string(name='NamespaceShowName'),
    quota?: int32(name='Quota'),
    namespace?: string(name='Namespace'),
    namespaceDesc?: string(name='NamespaceDesc'),
    configCount?: int32(name='ConfigCount'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model UpdateEngineNamespaceResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateEngineNamespaceResponseBody(name='body'),
}

async function updateEngineNamespaceWithOptions(request: UpdateEngineNamespaceRequest, runtime: Util.RuntimeOptions): UpdateEngineNamespaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateEngineNamespace', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateEngineNamespace(request: UpdateEngineNamespaceRequest): UpdateEngineNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateEngineNamespaceWithOptions(request, runtime);
}

model ListClustersRequest {
  requestPars?: string(name='RequestPars'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  clusterAliasName?: string(name='ClusterAliasName'),
  regionId?: string(name='RegionId'),
}

model ListClustersResponseBody = {
  httpCode?: string(name='HttpCode'),
  totalCount?: int32(name='TotalCount'),
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  data?: [ 
    {
      endDate?: string(name='EndDate'),
      intranetDomain?: string(name='IntranetDomain'),
      internetDomain?: string(name='InternetDomain'),
      createTime?: string(name='CreateTime'),
      chargeType?: string(name='ChargeType'),
      intranetAddress?: string(name='IntranetAddress'),
      instanceId?: string(name='InstanceId'),
      internetAddress?: string(name='InternetAddress'),
      clusterAliasName?: string(name='ClusterAliasName'),
      clusterType?: string(name='ClusterType'),
      initStatus?: string(name='InitStatus'),
      appVersion?: string(name='AppVersion'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model ListClustersResponse = {
  headers: map[string]string(name='headers'),
  body: ListClustersResponseBody(name='body'),
}

async function listClustersWithOptions(request: ListClustersRequest, runtime: Util.RuntimeOptions): ListClustersResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListClusters', '2019-05-31', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listClusters(request: ListClustersRequest): ListClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClustersWithOptions(request, runtime);
}

model QueryZnodeDetailRequest {
  requestPars?: string(name='RequestPars'),
  clusterId?: string(name='ClusterId'),
  path?: string(name='Path'),
}

model QueryZnodeDetailResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    data?: string(name='Data'),
    path?: string(name='Path'),
    dir?: boolean(name='Dir'),
    name?: string(name='Name'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  success?: string(name='Success'),
}

model QueryZnodeDetailResponse = {
  headers: map[string]string(name='headers'),
  body: QueryZnodeDetailResponseBody(name='body'),
}

async function queryZnodeDetailWithOptions(request: QueryZnodeDetailRequest, runtime: Util.RuntimeOptions): QueryZnodeDetailResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('QueryZnodeDetail', '2019-05-31', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function queryZnodeDetail(request: QueryZnodeDetailRequest): QueryZnodeDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryZnodeDetailWithOptions(request, runtime);
}

model UpdateNacosInstanceRequest {
  instanceId?: string(name='InstanceId', description='id'),
  serviceName?: string(name='ServiceName', description=''),
  groupName?: string(name='GroupName', description=''),
  namespaceId?: string(name='NamespaceId', description='id'),
  clusterName?: string(name='ClusterName', description='Nacos'),
  ip?: string(name='Ip', description='Nacosip'),
  port?: int32(name='Port', description='Nacos'),
  ephemeral?: boolean(name='Ephemeral', description=''),
  weight?: string(name='Weight', description=''),
  enabled?: boolean(name='Enabled', description=''),
  metadata?: string(name='Metadata', description=''),
}

model UpdateNacosInstanceResponseBody = {
  httpStatusCode?: int32(name='HttpStatusCode', description='http'),
  requestId?: string(name='RequestId', description='id'),
  message?: string(name='Message', description=''),
  code?: int32(name='Code', description=''),
  success?: boolean(name='Success', description=''),
  data?: string(name='Data', description=''),
}

model UpdateNacosInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateNacosInstanceResponseBody(name='body'),
}

async function updateNacosInstanceWithOptions(request: UpdateNacosInstanceRequest, runtime: Util.RuntimeOptions): UpdateNacosInstanceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateNacosInstance', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateNacosInstance(request: UpdateNacosInstanceRequest): UpdateNacosInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateNacosInstanceWithOptions(request, runtime);
}

model DeleteAlarmRuleRequest {
  requestPars?: string(name='RequestPars'),
  alarmRuleId?: string(name='AlarmRuleId'),
}

model DeleteAlarmRuleResponseBody = {
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model DeleteAlarmRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAlarmRuleResponseBody(name='body'),
}

async function deleteAlarmRuleWithOptions(request: DeleteAlarmRuleRequest, runtime: Util.RuntimeOptions): DeleteAlarmRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteAlarmRule', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteAlarmRule(request: DeleteAlarmRuleRequest): DeleteAlarmRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAlarmRuleWithOptions(request, runtime);
}

model GetImportFileUrlRequest {
  contentType?: string(name='ContentType'),
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
}

model GetImportFileUrlResponseBody = {
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  data?: {
    url?: string(name='Url'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model GetImportFileUrlResponse = {
  headers: map[string]string(name='headers'),
  body: GetImportFileUrlResponseBody(name='body'),
}

async function getImportFileUrlWithOptions(request: GetImportFileUrlRequest, runtime: Util.RuntimeOptions): GetImportFileUrlResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetImportFileUrl', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getImportFileUrl(request: GetImportFileUrlRequest): GetImportFileUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  return getImportFileUrlWithOptions(request, runtime);
}

model ListAlarmRulesRequest {
  requestPars?: string(name='RequestPars'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  alarmMseType?: string(name='AlarmMseType'),
}

model ListAlarmRulesResponseBody = {
  httpCode?: string(name='HttpCode'),
  totalCount?: int32(name='TotalCount'),
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  data?: [ 
    {
      alarmStatus?: string(name='AlarmStatus'),
      alarmRuleId?: string(name='AlarmRuleId'),
      createTime?: string(name='CreateTime'),
      alarmRuleDetail?: string(name='AlarmRuleDetail'),
      alarmName?: string(name='AlarmName'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model ListAlarmRulesResponse = {
  headers: map[string]string(name='headers'),
  body: ListAlarmRulesResponseBody(name='body'),
}

async function listAlarmRulesWithOptions(request: ListAlarmRulesRequest, runtime: Util.RuntimeOptions): ListAlarmRulesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListAlarmRules', '2019-05-31', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listAlarmRules(request: ListAlarmRulesRequest): ListAlarmRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAlarmRulesWithOptions(request, runtime);
}

model QueryBusinessLocationsResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: [ 
    {
      ordering?: int32(name='Ordering'),
      type?: string(name='Type'),
      districtEnName?: string(name='DistrictEnName'),
      showName?: string(name='ShowName'),
      districtCnName?: string(name='DistrictCnName'),
      enName?: string(name='EnName'),
      districtId?: string(name='DistrictId'),
      districtShowName?: string(name='DistrictShowName'),
      description?: string(name='Description'),
      enDescription?: string(name='EnDescription'),
      cnName?: string(name='CnName'),
      name?: string(name='Name'),
      districtOrdering?: int32(name='DistrictOrdering'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  success?: string(name='Success'),
}

model QueryBusinessLocationsResponse = {
  headers: map[string]string(name='headers'),
  body: QueryBusinessLocationsResponseBody(name='body'),
}

async function queryBusinessLocationsWithOptions(runtime: Util.RuntimeOptions): QueryBusinessLocationsResponse {
  var req = new OpenApi.OpenApiRequest{};
  return doRPCRequest('QueryBusinessLocations', '2019-05-31', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function queryBusinessLocations(): QueryBusinessLocationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryBusinessLocationsWithOptions(runtime);
}

model UpdateConfigRequest {
  requestPars?: string(name='RequestPars'),
  clusterId?: string(name='ClusterId'),
  configType?: string(name='ConfigType'),
  tickTime?: string(name='TickTime'),
  initLimit?: string(name='InitLimit'),
  syncLimit?: string(name='SyncLimit'),
  maxClientCnxns?: string(name='MaxClientCnxns'),
  openSuperAcl?: string(name='OpenSuperAcl'),
  userName?: string(name='UserName'),
  passWord?: string(name='PassWord'),
  juteMaxbuffer?: string(name='JuteMaxbuffer'),
  autopurgePurgeInterval?: string(name='AutopurgePurgeInterval'),
  autopurgeSnapRetainCount?: string(name='AutopurgeSnapRetainCount'),
  configAuthEnabled?: boolean(name='ConfigAuthEnabled'),
  MCPEnabled?: boolean(name='MCPEnabled'),
  instanceId?: string(name='InstanceId'),
  configSecretEnabled?: boolean(name='ConfigSecretEnabled'),
}

model UpdateConfigResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  code?: int32(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
}

model UpdateConfigResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateConfigResponseBody(name='body'),
}

async function updateConfigWithOptions(request: UpdateConfigRequest, runtime: Util.RuntimeOptions): UpdateConfigResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateConfig', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateConfig(request: UpdateConfigRequest): UpdateConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateConfigWithOptions(request, runtime);
}

model GetNacosHistoryConfigRequest {
  instanceId?: string(name='InstanceId'),
  dataId?: string(name='DataId'),
  group?: string(name='Group'),
  namespaceId?: string(name='NamespaceId'),
  nid?: string(name='Nid'),
}

model GetNacosHistoryConfigResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  configuration?: {
    appName?: string(name='AppName'),
    md5?: string(name='Md5'),
    dataId?: string(name='DataId'),
    content?: string(name='Content'),
    group?: string(name='Group'),
    opType?: string(name='OpType'),
    encryptedDataKey?: string(name='EncryptedDataKey'),
  }(name='Configuration'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model GetNacosHistoryConfigResponse = {
  headers: map[string]string(name='headers'),
  body: GetNacosHistoryConfigResponseBody(name='body'),
}

async function getNacosHistoryConfigWithOptions(request: GetNacosHistoryConfigRequest, runtime: Util.RuntimeOptions): GetNacosHistoryConfigResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetNacosHistoryConfig', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getNacosHistoryConfig(request: GetNacosHistoryConfigRequest): GetNacosHistoryConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return getNacosHistoryConfigWithOptions(request, runtime);
}

model UpdateAclRequest {
  aclEntryList?: string(name='AclEntryList'),
  instanceId?: string(name='InstanceId'),
}

model UpdateAclResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model UpdateAclResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAclResponseBody(name='body'),
}

async function updateAclWithOptions(request: UpdateAclRequest, runtime: Util.RuntimeOptions): UpdateAclResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateAcl', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateAcl(request: UpdateAclRequest): UpdateAclResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAclWithOptions(request, runtime);
}

model QuerySlbSpecResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
  data?: [ 
    {
      id?: int32(name='Id'),
      spec?: string(name='Spec'),
      name?: string(name='Name'),
      maxConnection?: string(name='MaxConnection'),
      newConnectionPerSecond?: string(name='NewConnectionPerSecond'),
      qps?: string(name='Qps'),
    }
  ](name='Data'),
}

model QuerySlbSpecResponse = {
  headers: map[string]string(name='headers'),
  body: QuerySlbSpecResponseBody(name='body'),
}

async function querySlbSpecWithOptions(runtime: Util.RuntimeOptions): QuerySlbSpecResponse {
  var req = new OpenApi.OpenApiRequest{};
  return doRPCRequest('QuerySlbSpec', '2019-05-31', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function querySlbSpec(): QuerySlbSpecResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySlbSpecWithOptions(runtime);
}

model RestartClusterRequest {
  requestPars?: string(name='RequestPars'),
  instanceId?: string(name='InstanceId'),
  clusterId?: string(name='ClusterId'),
}

model RestartClusterResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model RestartClusterResponse = {
  headers: map[string]string(name='headers'),
  body: RestartClusterResponseBody(name='body'),
}

async function restartClusterWithOptions(request: RestartClusterRequest, runtime: Util.RuntimeOptions): RestartClusterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RestartCluster', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function restartCluster(request: RestartClusterRequest): RestartClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return restartClusterWithOptions(request, runtime);
}

model CreateNacosConfigRequest {
  instanceId?: string(name='InstanceId'),
  dataId?: string(name='DataId'),
  group?: string(name='Group'),
  appName?: string(name='AppName'),
  tags?: string(name='Tags'),
  desc?: string(name='Desc'),
  type?: string(name='Type'),
  content?: string(name='Content'),
  namespaceId?: string(name='NamespaceId'),
  betaIps?: string(name='BetaIps'),
}

model CreateNacosConfigResponseBody = {
  httpCode?: string(name='HttpCode'),
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  errorCode?: string(name='ErrorCode'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model CreateNacosConfigResponse = {
  headers: map[string]string(name='headers'),
  body: CreateNacosConfigResponseBody(name='body'),
}

async function createNacosConfigWithOptions(request: CreateNacosConfigRequest, runtime: Util.RuntimeOptions): CreateNacosConfigResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateNacosConfig', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createNacosConfig(request: CreateNacosConfigRequest): CreateNacosConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return createNacosConfigWithOptions(request, runtime);
}

model UpgradeClusterRequest {
  requestPars?: string(name='RequestPars'),
  instanceId?: string(name='InstanceId'),
  upgradeVersion?: string(name='UpgradeVersion'),
}

model UpgradeClusterResponseBody = {
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model UpgradeClusterResponse = {
  headers: map[string]string(name='headers'),
  body: UpgradeClusterResponseBody(name='body'),
}

async function upgradeClusterWithOptions(request: UpgradeClusterRequest, runtime: Util.RuntimeOptions): UpgradeClusterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpgradeCluster', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function upgradeCluster(request: UpgradeClusterRequest): UpgradeClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeClusterWithOptions(request, runtime);
}

model ListAnsInstancesRequest {
  requestPars?: string(name='RequestPars'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  clusterId?: string(name='ClusterId'),
  serviceName?: string(name='ServiceName'),
  groupName?: string(name='GroupName'),
  namespaceId?: string(name='NamespaceId'),
  clusterName?: string(name='ClusterName'),
}

model ListAnsInstancesResponseBody = {
  httpCode?: string(name='HttpCode'),
  totalCount?: int32(name='TotalCount'),
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  data?: [ 
    {
      defaultKey?: string(name='DefaultKey'),
      ephemeral?: boolean(name='Ephemeral'),
      marked?: boolean(name='Marked'),
      ip?: string(name='Ip'),
      instanceId?: string(name='InstanceId'),
      port?: int32(name='Port'),
      lastBeat?: long(name='LastBeat'),
      okCount?: int32(name='OkCount'),
      weight?: int32(name='Weight'),
      instanceHeartBeatInterval?: int32(name='InstanceHeartBeatInterval'),
      ipDeleteTimeout?: int32(name='IpDeleteTimeout'),
      app?: string(name='App'),
      failCount?: int32(name='FailCount'),
      healthy?: boolean(name='Healthy'),
      enabled?: boolean(name='Enabled'),
      datumKey?: string(name='DatumKey'),
      clusterName?: string(name='ClusterName'),
      instanceHeartBeatTimeOut?: int32(name='InstanceHeartBeatTimeOut'),
      serviceName?: string(name='ServiceName'),
      metadata?: map[string]any(name='Metadata'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model ListAnsInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: ListAnsInstancesResponseBody(name='body'),
}

async function listAnsInstancesWithOptions(request: ListAnsInstancesRequest, runtime: Util.RuntimeOptions): ListAnsInstancesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListAnsInstances', '2019-05-31', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listAnsInstances(request: ListAnsInstancesRequest): ListAnsInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAnsInstancesWithOptions(request, runtime);
}

model ListAlarmItemsRequest {
  requestPars?: string(name='RequestPars'),
}

model ListAlarmItemsResponseBody = {
  httpCode?: string(name='HttpCode'),
  totalCount?: int32(name='TotalCount'),
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  data?: [ 
    {
      alarmDesc?: string(name='AlarmDesc'),
      clusterType?: string(name='ClusterType'),
      alarmCode?: string(name='AlarmCode'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model ListAlarmItemsResponse = {
  headers: map[string]string(name='headers'),
  body: ListAlarmItemsResponseBody(name='body'),
}

async function listAlarmItemsWithOptions(request: ListAlarmItemsRequest, runtime: Util.RuntimeOptions): ListAlarmItemsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListAlarmItems', '2019-05-31', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listAlarmItems(request: ListAlarmItemsRequest): ListAlarmItemsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAlarmItemsWithOptions(request, runtime);
}

model RetryClusterRequest {
  requestPars?: string(name='RequestPars'),
  instanceId?: string(name='InstanceId'),
}

model RetryClusterResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model RetryClusterResponse = {
  headers: map[string]string(name='headers'),
  body: RetryClusterResponseBody(name='body'),
}

async function retryClusterWithOptions(request: RetryClusterRequest, runtime: Util.RuntimeOptions): RetryClusterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RetryCluster', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function retryCluster(request: RetryClusterRequest): RetryClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return retryClusterWithOptions(request, runtime);
}

model ListAlarmContactGroupsRequest {
  requestPars?: string(name='RequestPars'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
}

model ListAlarmContactGroupsResponseBody = {
  httpCode?: string(name='HttpCode'),
  totalCount?: int32(name='TotalCount'),
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  data?: [ 
    {
      contactGroupName?: string(name='ContactGroupName'),
      contactGroupId?: string(name='ContactGroupId'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model ListAlarmContactGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: ListAlarmContactGroupsResponseBody(name='body'),
}

async function listAlarmContactGroupsWithOptions(request: ListAlarmContactGroupsRequest, runtime: Util.RuntimeOptions): ListAlarmContactGroupsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListAlarmContactGroups', '2019-05-31', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listAlarmContactGroups(request: ListAlarmContactGroupsRequest): ListAlarmContactGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAlarmContactGroupsWithOptions(request, runtime);
}

