/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @signatureAlgorithm = 'v2';
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('mse', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model GatewayDomain {
  certIdentifier?: string(name='CertIdentifier'),
  gatewayId?: long(name='GatewayId'),
  gatewayName?: string(name='GatewayName'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  gmtCreate?: string(name='GmtCreate'),
  gmtModified?: string(name='GmtModified'),
  id?: long(name='Id'),
  mustHttps?: string(name='MustHttps'),
  name?: string(name='Name'),
  protocol?: string(name='Protocol'),
}

model GatewayOption {
  disableHttp2Alpn?: boolean(name='DisableHttp2Alpn'),
  enableHardwareAcceleration?: boolean(name='EnableHardwareAcceleration'),
  enableWaf?: boolean(name='EnableWaf'),
  logConfigDetails?: {
    logEnabled?: boolean(name='LogEnabled'),
    logStoreName?: string(name='LogStoreName'),
    projectName?: string(name='ProjectName'),
  }(name='LogConfigDetails'),
  traceDetails?: {
    sample?: long(name='Sample'),
    traceEnabled?: boolean(name='TraceEnabled'),
  }(name='TraceDetails'),
}

model GatewayService {
  gatewayTrafficPolicy?: TrafficPolicy(name='GatewayTrafficPolicy'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  groupName?: string(name='GroupName'),
  id?: long(name='Id'),
  metaInfo?: string(name='MetaInfo'),
  name?: string(name='Name'),
  namespace?: string(name='Namespace'),
  sourceType?: string(name='SourceType'),
}

model TrafficPolicy {
  loadBalancerSettings?: {
    consistentHashLBConfig?: {
      consistentHashLBType?: string(name='ConsistentHashLBType'),
      httpCookie?: {
        name?: string(name='Name'),
        path?: string(name='Path'),
        TTL?: string(name='TTL'),
      }(name='HttpCookie'),
      parameterName?: string(name='ParameterName'),
    }(name='ConsistentHashLBConfig'),
    loadbalancerType?: string(name='LoadbalancerType'),
    warmupDuration?: long(name='WarmupDuration'),
  }(name='LoadBalancerSettings'),
  tlsSetting?: {
    caCertContent?: string(name='CaCertContent'),
    certId?: string(name='CertId'),
    sni?: string(name='Sni'),
    tlsMode?: string(name='TlsMode'),
  }(name='TlsSetting'),
}

model AddAuthResourceRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  authId?: long(name='AuthId'),
  domainId?: long(name='DomainId'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  matchType?: string(name='MatchType'),
  path?: string(name='Path'),
}

model AddAuthResourceResponseBody = {
  code?: int32(name='Code'),
  data?: long(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AddAuthResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddAuthResourceResponseBody(name='body'),
}

async function addAuthResourceWithOptions(request: AddAuthResourceRequest, runtime: Util.RuntimeOptions): AddAuthResourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.authId)) {
    query['AuthId'] = request.authId;
  }
  if (!Util.isUnset(request.domainId)) {
    query['DomainId'] = request.domainId;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.matchType)) {
    query['MatchType'] = request.matchType;
  }
  if (!Util.isUnset(request.path)) {
    query['Path'] = request.path;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddAuthResource',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addAuthResource(request: AddAuthResourceRequest): AddAuthResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return addAuthResourceWithOptions(request, runtime);
}

model AddBlackWhiteListRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  content?: string(name='Content'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  isWhite?: boolean(name='IsWhite'),
  name?: string(name='Name'),
  note?: string(name='Note'),
  resourceIdJsonList?: string(name='ResourceIdJsonList'),
  resourceType?: string(name='ResourceType'),
  status?: string(name='Status'),
  type?: string(name='Type'),
}

model AddBlackWhiteListResponseBody = {
  code?: int32(name='Code'),
  data?: long(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AddBlackWhiteListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddBlackWhiteListResponseBody(name='body'),
}

async function addBlackWhiteListWithOptions(request: AddBlackWhiteListRequest, runtime: Util.RuntimeOptions): AddBlackWhiteListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.content)) {
    query['Content'] = request.content;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.isWhite)) {
    query['IsWhite'] = request.isWhite;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.note)) {
    query['Note'] = request.note;
  }
  if (!Util.isUnset(request.resourceIdJsonList)) {
    query['ResourceIdJsonList'] = request.resourceIdJsonList;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddBlackWhiteList',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addBlackWhiteList(request: AddBlackWhiteListRequest): AddBlackWhiteListResponse {
  var runtime = new Util.RuntimeOptions{};
  return addBlackWhiteListWithOptions(request, runtime);
}

model AddGatewayRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  enableHardwareAcceleration?: boolean(name='EnableHardwareAcceleration'),
  enableSls?: boolean(name='EnableSls'),
  enableXtrace?: boolean(name='EnableXtrace'),
  enterpriseSecurityGroup?: boolean(name='EnterpriseSecurityGroup'),
  internetSlbSpec?: string(name='InternetSlbSpec'),
  name?: string(name='Name'),
  region?: string(name='Region'),
  replica?: int32(name='Replica'),
  resourceGroupId?: string(name='ResourceGroupId'),
  slbSpec?: string(name='SlbSpec'),
  spec?: string(name='Spec'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  vSwitchId?: string(name='VSwitchId'),
  vSwitchId2?: string(name='VSwitchId2'),
  vpc?: string(name='Vpc'),
  xtraceRatio?: string(name='XtraceRatio'),
}

model AddGatewayResponseBody = {
  code?: int32(name='Code'),
  data?: {
    gatewayUniqueId?: string(name='GatewayUniqueId'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AddGatewayResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddGatewayResponseBody(name='body'),
}

async function addGatewayWithOptions(request: AddGatewayRequest, runtime: Util.RuntimeOptions): AddGatewayResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.enableHardwareAcceleration)) {
    query['EnableHardwareAcceleration'] = request.enableHardwareAcceleration;
  }
  if (!Util.isUnset(request.enableSls)) {
    query['EnableSls'] = request.enableSls;
  }
  if (!Util.isUnset(request.enableXtrace)) {
    query['EnableXtrace'] = request.enableXtrace;
  }
  if (!Util.isUnset(request.enterpriseSecurityGroup)) {
    query['EnterpriseSecurityGroup'] = request.enterpriseSecurityGroup;
  }
  if (!Util.isUnset(request.internetSlbSpec)) {
    query['InternetSlbSpec'] = request.internetSlbSpec;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.replica)) {
    query['Replica'] = request.replica;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.slbSpec)) {
    query['SlbSpec'] = request.slbSpec;
  }
  if (!Util.isUnset(request.spec)) {
    query['Spec'] = request.spec;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.vSwitchId2)) {
    query['VSwitchId2'] = request.vSwitchId2;
  }
  if (!Util.isUnset(request.vpc)) {
    query['Vpc'] = request.vpc;
  }
  if (!Util.isUnset(request.xtraceRatio)) {
    query['XtraceRatio'] = request.xtraceRatio;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddGateway',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addGateway(request: AddGatewayRequest): AddGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return addGatewayWithOptions(request, runtime);
}

model AddGatewayDomainRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  certIdentifier?: string(name='CertIdentifier'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  http2?: string(name='Http2'),
  mustHttps?: boolean(name='MustHttps'),
  name?: string(name='Name'),
  protocol?: string(name='Protocol'),
  tlsMax?: string(name='TlsMax'),
  tlsMin?: string(name='TlsMin'),
}

model AddGatewayDomainResponseBody = {
  code?: int32(name='Code'),
  data?: long(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AddGatewayDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddGatewayDomainResponseBody(name='body'),
}

async function addGatewayDomainWithOptions(request: AddGatewayDomainRequest, runtime: Util.RuntimeOptions): AddGatewayDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.certIdentifier)) {
    query['CertIdentifier'] = request.certIdentifier;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.http2)) {
    query['Http2'] = request.http2;
  }
  if (!Util.isUnset(request.mustHttps)) {
    query['MustHttps'] = request.mustHttps;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.protocol)) {
    query['Protocol'] = request.protocol;
  }
  if (!Util.isUnset(request.tlsMax)) {
    query['TlsMax'] = request.tlsMax;
  }
  if (!Util.isUnset(request.tlsMin)) {
    query['TlsMin'] = request.tlsMin;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddGatewayDomain',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addGatewayDomain(request: AddGatewayDomainRequest): AddGatewayDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return addGatewayDomainWithOptions(request, runtime);
}

model AddGatewayRouteRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  destinationType?: string(name='DestinationType'),
  directResponseJSON?: {
    body?: string(name='Body'),
    code?: long(name='Code'),
  }(name='DirectResponseJSON'),
  domainId?: long(name='DomainId'),
  domainIdListJSON?: string(name='DomainIdListJSON'),
  enableWaf?: boolean(name='EnableWaf'),
  fallback?: boolean(name='Fallback'),
  fallbackServices?: [ 
    {
      agreementType?: string(name='AgreementType'),
      groupName?: string(name='GroupName'),
      name?: string(name='Name'),
      namespace?: string(name='Namespace'),
      percent?: int32(name='Percent'),
      serviceId?: long(name='ServiceId'),
      servicePort?: int32(name='ServicePort'),
      sourceType?: string(name='SourceType'),
      version?: string(name='Version'),
    }
  ](name='FallbackServices'),
  gatewayId?: long(name='GatewayId'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  name?: string(name='Name'),
  predicates?: {
    headerPredicates?: [ 
      {
        key?: string(name='Key'),
        type?: string(name='Type'),
        value?: string(name='Value'),
      }
    ](name='HeaderPredicates'),
    methodPredicates?: [ string ](name='MethodPredicates'),
    pathPredicates?: {
      ignoreCase?: boolean(name='IgnoreCase'),
      path?: string(name='Path'),
      type?: string(name='Type'),
    }(name='PathPredicates'),
    queryPredicates?: [ 
      {
        key?: string(name='Key'),
        type?: string(name='Type'),
        value?: string(name='Value'),
      }
    ](name='QueryPredicates'),
  }(name='Predicates'),
  redirectJSON?: {
    code?: int32(name='Code'),
    host?: string(name='Host'),
    path?: string(name='Path'),
  }(name='RedirectJSON'),
  routeOrder?: int32(name='RouteOrder'),
  services?: [ 
    {
      agreementType?: string(name='AgreementType'),
      groupName?: string(name='GroupName'),
      httpDubboTranscoder?: {
        dubboServiceGroup?: string(name='DubboServiceGroup'),
        dubboServiceName?: string(name='DubboServiceName'),
        dubboServiceVersion?: string(name='DubboServiceVersion'),
        mothedMapList?: [ 
          {
            dubboMothedName?: string(name='DubboMothedName'),
            httpMothed?: string(name='HttpMothed'),
            mothedpath?: string(name='Mothedpath'),
            paramMapsList?: [ 
              {
                extractKey?: string(name='ExtractKey'),
                extractKeySpec?: string(name='ExtractKeySpec'),
                mappingType?: string(name='MappingType'),
              }
            ](name='ParamMapsList'),
            passThroughAllHeaders?: string(name='PassThroughAllHeaders'),
            passThroughList?: [ string ](name='PassThroughList'),
          }
        ](name='MothedMapList'),
      }(name='HttpDubboTranscoder'),
      name?: string(name='Name'),
      namespace?: string(name='Namespace'),
      percent?: int32(name='Percent'),
      serviceId?: long(name='ServiceId'),
      servicePort?: int32(name='ServicePort'),
      sourceType?: string(name='SourceType'),
      version?: string(name='Version'),
    }
  ](name='Services'),
}

model AddGatewayRouteShrinkRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  destinationType?: string(name='DestinationType'),
  directResponseJSONShrink?: string(name='DirectResponseJSON'),
  domainId?: long(name='DomainId'),
  domainIdListJSON?: string(name='DomainIdListJSON'),
  enableWaf?: boolean(name='EnableWaf'),
  fallback?: boolean(name='Fallback'),
  fallbackServicesShrink?: string(name='FallbackServices'),
  gatewayId?: long(name='GatewayId'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  name?: string(name='Name'),
  predicatesShrink?: string(name='Predicates'),
  redirectJSONShrink?: string(name='RedirectJSON'),
  routeOrder?: int32(name='RouteOrder'),
  servicesShrink?: string(name='Services'),
}

model AddGatewayRouteResponseBody = {
  code?: int32(name='Code'),
  data?: long(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AddGatewayRouteResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddGatewayRouteResponseBody(name='body'),
}

async function addGatewayRouteWithOptions(tmpReq: AddGatewayRouteRequest, runtime: Util.RuntimeOptions): AddGatewayRouteResponse {
  Util.validateModel(tmpReq);
  var request = new AddGatewayRouteShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.directResponseJSON)) {
    request.directResponseJSONShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.directResponseJSON, 'DirectResponseJSON', 'json');
  }
  if (!Util.isUnset(tmpReq.fallbackServices)) {
    request.fallbackServicesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.fallbackServices, 'FallbackServices', 'json');
  }
  if (!Util.isUnset(tmpReq.predicates)) {
    request.predicatesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.predicates, 'Predicates', 'json');
  }
  if (!Util.isUnset(tmpReq.redirectJSON)) {
    request.redirectJSONShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.redirectJSON, 'RedirectJSON', 'json');
  }
  if (!Util.isUnset(tmpReq.services)) {
    request.servicesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.services, 'Services', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.destinationType)) {
    query['DestinationType'] = request.destinationType;
  }
  if (!Util.isUnset(request.directResponseJSONShrink)) {
    query['DirectResponseJSON'] = request.directResponseJSONShrink;
  }
  if (!Util.isUnset(request.domainId)) {
    query['DomainId'] = request.domainId;
  }
  if (!Util.isUnset(request.domainIdListJSON)) {
    query['DomainIdListJSON'] = request.domainIdListJSON;
  }
  if (!Util.isUnset(request.enableWaf)) {
    query['EnableWaf'] = request.enableWaf;
  }
  if (!Util.isUnset(request.fallback)) {
    query['Fallback'] = request.fallback;
  }
  if (!Util.isUnset(request.fallbackServicesShrink)) {
    query['FallbackServices'] = request.fallbackServicesShrink;
  }
  if (!Util.isUnset(request.gatewayId)) {
    query['GatewayId'] = request.gatewayId;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.predicatesShrink)) {
    query['Predicates'] = request.predicatesShrink;
  }
  if (!Util.isUnset(request.redirectJSONShrink)) {
    query['RedirectJSON'] = request.redirectJSONShrink;
  }
  if (!Util.isUnset(request.routeOrder)) {
    query['RouteOrder'] = request.routeOrder;
  }
  if (!Util.isUnset(request.servicesShrink)) {
    query['Services'] = request.servicesShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddGatewayRoute',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addGatewayRoute(request: AddGatewayRouteRequest): AddGatewayRouteResponse {
  var runtime = new Util.RuntimeOptions{};
  return addGatewayRouteWithOptions(request, runtime);
}

model AddGatewayServiceVersionRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  serviceId?: long(name='ServiceId'),
  serviceVersion?: string(name='ServiceVersion'),
}

model AddGatewayServiceVersionResponseBody = {
  code?: int32(name='Code'),
  data?: long(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AddGatewayServiceVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddGatewayServiceVersionResponseBody(name='body'),
}

async function addGatewayServiceVersionWithOptions(request: AddGatewayServiceVersionRequest, runtime: Util.RuntimeOptions): AddGatewayServiceVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.serviceId)) {
    query['ServiceId'] = request.serviceId;
  }
  if (!Util.isUnset(request.serviceVersion)) {
    query['ServiceVersion'] = request.serviceVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddGatewayServiceVersion',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addGatewayServiceVersion(request: AddGatewayServiceVersionRequest): AddGatewayServiceVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return addGatewayServiceVersionWithOptions(request, runtime);
}

model AddGatewaySlbRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  httpPort?: int32(name='HttpPort'),
  httpsPort?: int32(name='HttpsPort'),
  httpsVServerGroupId?: string(name='HttpsVServerGroupId'),
  serviceWeight?: int32(name='ServiceWeight'),
  slbId?: string(name='SlbId'),
  type?: string(name='Type'),
  VServerGroupId?: string(name='VServerGroupId'),
}

model AddGatewaySlbResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AddGatewaySlbResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddGatewaySlbResponseBody(name='body'),
}

async function addGatewaySlbWithOptions(request: AddGatewaySlbRequest, runtime: Util.RuntimeOptions): AddGatewaySlbResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.httpPort)) {
    query['HttpPort'] = request.httpPort;
  }
  if (!Util.isUnset(request.httpsPort)) {
    query['HttpsPort'] = request.httpsPort;
  }
  if (!Util.isUnset(request.httpsVServerGroupId)) {
    query['HttpsVServerGroupId'] = request.httpsVServerGroupId;
  }
  if (!Util.isUnset(request.serviceWeight)) {
    query['ServiceWeight'] = request.serviceWeight;
  }
  if (!Util.isUnset(request.slbId)) {
    query['SlbId'] = request.slbId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.VServerGroupId)) {
    query['VServerGroupId'] = request.VServerGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddGatewaySlb',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addGatewaySlb(request: AddGatewaySlbRequest): AddGatewaySlbResponse {
  var runtime = new Util.RuntimeOptions{};
  return addGatewaySlbWithOptions(request, runtime);
}

model AddMockRuleRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  consumerAppIds?: string(name='ConsumerAppIds'),
  dubboMockItems?: string(name='DubboMockItems'),
  enable?: boolean(name='Enable'),
  extraJson?: string(name='ExtraJson'),
  mockType?: long(name='MockType'),
  name?: string(name='Name'),
  providerAppId?: string(name='ProviderAppId'),
  providerAppName?: string(name='ProviderAppName'),
  region?: string(name='Region'),
  scMockItems?: string(name='ScMockItems'),
  source?: string(name='Source'),
}

model AddMockRuleResponseBody = {
  code?: int32(name='Code'),
  data?: {
    accountId?: string(name='AccountId'),
    consumerAppId?: string(name='ConsumerAppId'),
    consumerAppName?: string(name='ConsumerAppName'),
    enable?: boolean(name='Enable'),
    extraJson?: string(name='ExtraJson'),
    id?: long(name='Id'),
    mockType?: long(name='MockType'),
    name?: string(name='Name'),
    namespaceId?: string(name='NamespaceId'),
    providerAppId?: string(name='ProviderAppId'),
    providerAppName?: string(name='ProviderAppName'),
    region?: string(name='Region'),
    scMockItemJson?: string(name='ScMockItemJson'),
    source?: string(name='Source'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AddMockRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddMockRuleResponseBody(name='body'),
}

async function addMockRuleWithOptions(request: AddMockRuleRequest, runtime: Util.RuntimeOptions): AddMockRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.consumerAppIds)) {
    query['ConsumerAppIds'] = request.consumerAppIds;
  }
  if (!Util.isUnset(request.dubboMockItems)) {
    query['DubboMockItems'] = request.dubboMockItems;
  }
  if (!Util.isUnset(request.enable)) {
    query['Enable'] = request.enable;
  }
  if (!Util.isUnset(request.extraJson)) {
    query['ExtraJson'] = request.extraJson;
  }
  if (!Util.isUnset(request.mockType)) {
    query['MockType'] = request.mockType;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.providerAppId)) {
    query['ProviderAppId'] = request.providerAppId;
  }
  if (!Util.isUnset(request.providerAppName)) {
    query['ProviderAppName'] = request.providerAppName;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.scMockItems)) {
    query['ScMockItems'] = request.scMockItems;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddMockRule',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addMockRule(request: AddMockRuleRequest): AddMockRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return addMockRuleWithOptions(request, runtime);
}

model AddSSLCertRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  certIdentifier?: string(name='CertIdentifier'),
  domainId?: long(name='DomainId'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
}

model AddSSLCertResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AddSSLCertResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddSSLCertResponseBody(name='body'),
}

async function addSSLCertWithOptions(request: AddSSLCertRequest, runtime: Util.RuntimeOptions): AddSSLCertResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.certIdentifier)) {
    query['CertIdentifier'] = request.certIdentifier;
  }
  if (!Util.isUnset(request.domainId)) {
    query['DomainId'] = request.domainId;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddSSLCert',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addSSLCert(request: AddSSLCertRequest): AddSSLCertResponse {
  var runtime = new Util.RuntimeOptions{};
  return addSSLCertWithOptions(request, runtime);
}

model AddSecurityGroupRuleRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  description?: string(name='Description'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  portRange?: string(name='PortRange'),
  securityGroupId?: string(name='SecurityGroupId'),
}

model AddSecurityGroupRuleResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AddSecurityGroupRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddSecurityGroupRuleResponseBody(name='body'),
}

async function addSecurityGroupRuleWithOptions(request: AddSecurityGroupRuleRequest, runtime: Util.RuntimeOptions): AddSecurityGroupRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.portRange)) {
    query['PortRange'] = request.portRange;
  }
  if (!Util.isUnset(request.securityGroupId)) {
    query['SecurityGroupId'] = request.securityGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddSecurityGroupRule',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addSecurityGroupRule(request: AddSecurityGroupRuleRequest): AddSecurityGroupRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return addSecurityGroupRuleWithOptions(request, runtime);
}

model AddServiceSourceRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  address?: string(name='Address'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  groupList?: [ string ](name='GroupList'),
  ingressOptionsRequest?: {
    enableIngress?: boolean(name='EnableIngress'),
    enableStatus?: boolean(name='EnableStatus'),
    ingressClass?: string(name='IngressClass'),
    watchNamespace?: string(name='WatchNamespace'),
  }(name='IngressOptionsRequest'),
  name?: string(name='Name'),
  pathList?: [ string ](name='PathList'),
  source?: string(name='Source'),
  type?: string(name='Type'),
}

model AddServiceSourceShrinkRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  address?: string(name='Address'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  groupListShrink?: string(name='GroupList'),
  ingressOptionsRequestShrink?: string(name='IngressOptionsRequest'),
  name?: string(name='Name'),
  pathListShrink?: string(name='PathList'),
  source?: string(name='Source'),
  type?: string(name='Type'),
}

model AddServiceSourceResponseBody = {
  code?: int32(name='Code'),
  data?: long(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AddServiceSourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddServiceSourceResponseBody(name='body'),
}

async function addServiceSourceWithOptions(tmpReq: AddServiceSourceRequest, runtime: Util.RuntimeOptions): AddServiceSourceResponse {
  Util.validateModel(tmpReq);
  var request = new AddServiceSourceShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.groupList)) {
    request.groupListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.groupList, 'GroupList', 'json');
  }
  if (!Util.isUnset(tmpReq.ingressOptionsRequest)) {
    request.ingressOptionsRequestShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.ingressOptionsRequest, 'IngressOptionsRequest', 'json');
  }
  if (!Util.isUnset(tmpReq.pathList)) {
    request.pathListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.pathList, 'PathList', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.address)) {
    query['Address'] = request.address;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.groupListShrink)) {
    query['GroupList'] = request.groupListShrink;
  }
  if (!Util.isUnset(request.ingressOptionsRequestShrink)) {
    query['IngressOptionsRequest'] = request.ingressOptionsRequestShrink;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.pathListShrink)) {
    query['PathList'] = request.pathListShrink;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddServiceSource',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addServiceSource(request: AddServiceSourceRequest): AddServiceSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return addServiceSourceWithOptions(request, runtime);
}

model ApplyGatewayRouteRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  routeId?: string(name='RouteId'),
}

model ApplyGatewayRouteResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ApplyGatewayRouteResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ApplyGatewayRouteResponseBody(name='body'),
}

async function applyGatewayRouteWithOptions(request: ApplyGatewayRouteRequest, runtime: Util.RuntimeOptions): ApplyGatewayRouteResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.routeId)) {
    query['RouteId'] = request.routeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ApplyGatewayRoute',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function applyGatewayRoute(request: ApplyGatewayRouteRequest): ApplyGatewayRouteResponse {
  var runtime = new Util.RuntimeOptions{};
  return applyGatewayRouteWithOptions(request, runtime);
}

model ApplyTagPoliciesRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  appId?: string(name='AppId'),
  enable?: boolean(name='Enable'),
  namespaceId?: string(name='NamespaceId'),
  region?: string(name='Region'),
  rules?: string(name='Rules'),
  source?: string(name='Source'),
}

model ApplyTagPoliciesResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      carryData?: boolean(name='CarryData'),
      enable?: boolean(name='Enable'),
      id?: long(name='Id'),
      instanceNum?: int32(name='InstanceNum'),
      name?: string(name='Name'),
      rate?: int32(name='Rate'),
      remove?: boolean(name='Remove'),
      rules?: string(name='Rules'),
      status?: int32(name='Status'),
      tag?: string(name='Tag'),
    }
  ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ApplyTagPoliciesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ApplyTagPoliciesResponseBody(name='body'),
}

async function applyTagPoliciesWithOptions(request: ApplyTagPoliciesRequest, runtime: Util.RuntimeOptions): ApplyTagPoliciesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.enable)) {
    query['Enable'] = request.enable;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.rules)) {
    query['Rules'] = request.rules;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ApplyTagPolicies',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function applyTagPolicies(request: ApplyTagPoliciesRequest): ApplyTagPoliciesResponse {
  var runtime = new Util.RuntimeOptions{};
  return applyTagPoliciesWithOptions(request, runtime);
}

model CloneNacosConfigRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  ids?: string(name='Ids'),
  instanceId?: string(name='InstanceId'),
  originNamespaceId?: string(name='OriginNamespaceId'),
  policy?: string(name='Policy'),
  targetNamespaceId?: string(name='TargetNamespaceId'),
}

model CloneNacosConfigResponseBody = {
  code?: int32(name='Code'),
  data?: {
    failData?: [ 
      {
        dataId?: string(name='DataId'),
        group?: string(name='Group'),
      }
    ](name='FailData'),
    skipCount?: int32(name='SkipCount'),
    skipData?: [ 
      {
        dataId?: string(name='DataId'),
        group?: string(name='Group'),
      }
    ](name='SkipData'),
    succCount?: int32(name='SuccCount'),
  }(name='Data'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CloneNacosConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CloneNacosConfigResponseBody(name='body'),
}

async function cloneNacosConfigWithOptions(request: CloneNacosConfigRequest, runtime: Util.RuntimeOptions): CloneNacosConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.ids)) {
    query['Ids'] = request.ids;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.originNamespaceId)) {
    query['OriginNamespaceId'] = request.originNamespaceId;
  }
  if (!Util.isUnset(request.policy)) {
    query['Policy'] = request.policy;
  }
  if (!Util.isUnset(request.targetNamespaceId)) {
    query['TargetNamespaceId'] = request.targetNamespaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CloneNacosConfig',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cloneNacosConfig(request: CloneNacosConfigRequest): CloneNacosConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return cloneNacosConfigWithOptions(request, runtime);
}

model CreateApplicationRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  appName?: string(name='AppName'),
  extraInfo?: string(name='ExtraInfo'),
  language?: string(name='Language'),
  region?: string(name='Region'),
  sentinelEnable?: string(name='SentinelEnable'),
  source?: string(name='Source'),
  switchEnable?: string(name='SwitchEnable'),
}

model CreateApplicationResponseBody = {
  code?: int32(name='Code'),
  data?: {
    appId?: string(name='AppId'),
    appName?: string(name='AppName'),
    createTime?: long(name='CreateTime'),
    extraInfo?: string(name='ExtraInfo'),
    language?: string(name='Language'),
    licenseKey?: string(name='LicenseKey'),
    regionId?: string(name='RegionId'),
    source?: string(name='Source'),
    status?: int32(name='Status'),
    updateTime?: long(name='UpdateTime'),
    userId?: string(name='UserId'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model CreateApplicationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateApplicationResponseBody(name='body'),
}

async function createApplicationWithOptions(request: CreateApplicationRequest, runtime: Util.RuntimeOptions): CreateApplicationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.extraInfo)) {
    query['ExtraInfo'] = request.extraInfo;
  }
  if (!Util.isUnset(request.language)) {
    query['Language'] = request.language;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.sentinelEnable)) {
    query['SentinelEnable'] = request.sentinelEnable;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.switchEnable)) {
    query['SwitchEnable'] = request.switchEnable;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateApplication',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createApplication(request: CreateApplicationRequest): CreateApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return createApplicationWithOptions(request, runtime);
}

model CreateClusterRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterSpecification?: string(name='ClusterSpecification'),
  clusterType?: string(name='ClusterType'),
  clusterVersion?: string(name='ClusterVersion'),
  connectionType?: string(name='ConnectionType'),
  diskType?: string(name='DiskType'),
  instanceCount?: int32(name='InstanceCount'),
  instanceName?: string(name='InstanceName'),
  mseVersion?: string(name='MseVersion'),
  netType?: string(name='NetType'),
  privateSlbSpecification?: string(name='PrivateSlbSpecification'),
  pubNetworkFlow?: string(name='PubNetworkFlow'),
  pubSlbSpecification?: string(name='PubSlbSpecification'),
  region?: string(name='Region'),
  requestPars?: string(name='RequestPars'),
  resourceGroupId?: string(name='ResourceGroupId'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  vSwitchId?: string(name='VSwitchId'),
  vpcId?: string(name='VpcId'),
}

model CreateClusterResponseBody = {
  errorCode?: string(name='ErrorCode'),
  instanceId?: string(name='InstanceId'),
  message?: string(name='Message'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateClusterResponseBody(name='body'),
}

async function createClusterWithOptions(request: CreateClusterRequest, runtime: Util.RuntimeOptions): CreateClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clusterSpecification)) {
    query['ClusterSpecification'] = request.clusterSpecification;
  }
  if (!Util.isUnset(request.clusterType)) {
    query['ClusterType'] = request.clusterType;
  }
  if (!Util.isUnset(request.clusterVersion)) {
    query['ClusterVersion'] = request.clusterVersion;
  }
  if (!Util.isUnset(request.connectionType)) {
    query['ConnectionType'] = request.connectionType;
  }
  if (!Util.isUnset(request.diskType)) {
    query['DiskType'] = request.diskType;
  }
  if (!Util.isUnset(request.instanceCount)) {
    query['InstanceCount'] = request.instanceCount;
  }
  if (!Util.isUnset(request.instanceName)) {
    query['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.mseVersion)) {
    query['MseVersion'] = request.mseVersion;
  }
  if (!Util.isUnset(request.netType)) {
    query['NetType'] = request.netType;
  }
  if (!Util.isUnset(request.privateSlbSpecification)) {
    query['PrivateSlbSpecification'] = request.privateSlbSpecification;
  }
  if (!Util.isUnset(request.pubNetworkFlow)) {
    query['PubNetworkFlow'] = request.pubNetworkFlow;
  }
  if (!Util.isUnset(request.pubSlbSpecification)) {
    query['PubSlbSpecification'] = request.pubSlbSpecification;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.requestPars)) {
    query['RequestPars'] = request.requestPars;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateCluster',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createCluster(request: CreateClusterRequest): CreateClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return createClusterWithOptions(request, runtime);
}

model CreateEngineNamespaceRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterId?: string(name='ClusterId'),
  desc?: string(name='Desc'),
  id?: string(name='Id'),
  instanceId?: string(name='InstanceId'),
  name?: string(name='Name'),
  serviceCount?: int32(name='ServiceCount'),
}

model CreateEngineNamespaceResponseBody = {
  clusterId?: string(name='ClusterId'),
  data?: {
    configCount?: int32(name='ConfigCount'),
    namespace?: string(name='Namespace'),
    namespaceDesc?: string(name='NamespaceDesc'),
    namespaceShowName?: string(name='NamespaceShowName'),
    quota?: int32(name='Quota'),
    serviceCount?: int32(name='ServiceCount'),
    type?: int32(name='Type'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateEngineNamespaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateEngineNamespaceResponseBody(name='body'),
}

async function createEngineNamespaceWithOptions(request: CreateEngineNamespaceRequest, runtime: Util.RuntimeOptions): CreateEngineNamespaceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.desc)) {
    query['Desc'] = request.desc;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.serviceCount)) {
    query['ServiceCount'] = request.serviceCount;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateEngineNamespace',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createEngineNamespace(request: CreateEngineNamespaceRequest): CreateEngineNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createEngineNamespaceWithOptions(request, runtime);
}

model CreateMseServiceApplicationRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  appName?: string(name='AppName'),
  extraInfo?: string(name='ExtraInfo'),
  language?: string(name='Language'),
  mseVersion?: string(name='MseVersion'),
  region?: string(name='Region'),
  sentinelEnable?: string(name='SentinelEnable'),
  source?: string(name='Source'),
  switchEnable?: string(name='SwitchEnable'),
}

model CreateMseServiceApplicationResponseBody = {
  code?: int32(name='Code'),
  data?: {
    appId?: string(name='AppId'),
    appName?: string(name='AppName'),
    createTime?: long(name='CreateTime'),
    extraInfo?: string(name='ExtraInfo'),
    language?: string(name='Language'),
    licenseKey?: string(name='LicenseKey'),
    regionId?: string(name='RegionId'),
    source?: string(name='Source'),
    status?: int32(name='Status'),
    updateTime?: long(name='UpdateTime'),
    userId?: string(name='UserId'),
    version?: string(name='Version'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model CreateMseServiceApplicationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateMseServiceApplicationResponseBody(name='body'),
}

async function createMseServiceApplicationWithOptions(request: CreateMseServiceApplicationRequest, runtime: Util.RuntimeOptions): CreateMseServiceApplicationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.extraInfo)) {
    query['ExtraInfo'] = request.extraInfo;
  }
  if (!Util.isUnset(request.language)) {
    query['Language'] = request.language;
  }
  if (!Util.isUnset(request.mseVersion)) {
    query['MseVersion'] = request.mseVersion;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.sentinelEnable)) {
    query['SentinelEnable'] = request.sentinelEnable;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.switchEnable)) {
    query['SwitchEnable'] = request.switchEnable;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateMseServiceApplication',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMseServiceApplication(request: CreateMseServiceApplicationRequest): CreateMseServiceApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMseServiceApplicationWithOptions(request, runtime);
}

model CreateNacosConfigRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  appName?: string(name='AppName'),
  betaIps?: string(name='BetaIps'),
  content?: string(name='Content'),
  dataId?: string(name='DataId'),
  desc?: string(name='Desc'),
  group?: string(name='Group'),
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
  tags?: string(name='Tags'),
  type?: string(name='Type'),
}

model CreateNacosConfigResponseBody = {
  code?: string(name='Code'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateNacosConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateNacosConfigResponseBody(name='body'),
}

async function createNacosConfigWithOptions(request: CreateNacosConfigRequest, runtime: Util.RuntimeOptions): CreateNacosConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.betaIps)) {
    query['BetaIps'] = request.betaIps;
  }
  if (!Util.isUnset(request.content)) {
    query['Content'] = request.content;
  }
  if (!Util.isUnset(request.dataId)) {
    query['DataId'] = request.dataId;
  }
  if (!Util.isUnset(request.desc)) {
    query['Desc'] = request.desc;
  }
  if (!Util.isUnset(request.group)) {
    query['Group'] = request.group;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateNacosConfig',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createNacosConfig(request: CreateNacosConfigRequest): CreateNacosConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return createNacosConfigWithOptions(request, runtime);
}

model CreateNacosInstanceRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterName?: string(name='ClusterName'),
  enabled?: boolean(name='Enabled'),
  ephemeral?: boolean(name='Ephemeral'),
  groupName?: string(name='GroupName'),
  instanceId?: string(name='InstanceId'),
  ip?: string(name='Ip'),
  metadata?: string(name='Metadata'),
  namespaceId?: string(name='NamespaceId'),
  port?: int32(name='Port'),
  serviceName?: string(name='ServiceName'),
  weight?: string(name='Weight'),
}

model CreateNacosInstanceResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateNacosInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateNacosInstanceResponseBody(name='body'),
}

async function createNacosInstanceWithOptions(request: CreateNacosInstanceRequest, runtime: Util.RuntimeOptions): CreateNacosInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.enabled)) {
    query['Enabled'] = request.enabled;
  }
  if (!Util.isUnset(request.ephemeral)) {
    query['Ephemeral'] = request.ephemeral;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ip)) {
    query['Ip'] = request.ip;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  if (!Util.isUnset(request.port)) {
    query['Port'] = request.port;
  }
  if (!Util.isUnset(request.serviceName)) {
    query['ServiceName'] = request.serviceName;
  }
  if (!Util.isUnset(request.weight)) {
    query['Weight'] = request.weight;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.metadata)) {
    body['Metadata'] = request.metadata;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateNacosInstance',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createNacosInstance(request: CreateNacosInstanceRequest): CreateNacosInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createNacosInstanceWithOptions(request, runtime);
}

model CreateNacosServiceRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterId?: string(name='ClusterId'),
  ephemeral?: boolean(name='Ephemeral'),
  groupName?: string(name='GroupName'),
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
  protectThreshold?: string(name='ProtectThreshold'),
  serviceName?: string(name='ServiceName'),
}

model CreateNacosServiceResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateNacosServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateNacosServiceResponseBody(name='body'),
}

async function createNacosServiceWithOptions(request: CreateNacosServiceRequest, runtime: Util.RuntimeOptions): CreateNacosServiceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.ephemeral)) {
    query['Ephemeral'] = request.ephemeral;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  if (!Util.isUnset(request.protectThreshold)) {
    query['ProtectThreshold'] = request.protectThreshold;
  }
  if (!Util.isUnset(request.serviceName)) {
    query['ServiceName'] = request.serviceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateNacosService',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createNacosService(request: CreateNacosServiceRequest): CreateNacosServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createNacosServiceWithOptions(request, runtime);
}

model CreateOrUpdateSwimmingLaneRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  enable?: boolean(name='Enable'),
  enableRules?: boolean(name='EnableRules'),
  entryRule?: string(name='EntryRule'),
  entryRules?: [ 
    {
      condition?: string(name='Condition'),
      enable?: boolean(name='Enable'),
      path?: string(name='Path'),
      paths?: [ string ](name='Paths'),
      priority?: int32(name='Priority'),
      restItems?: [ 
        {
          cond?: string(name='Cond'),
          datum?: string(name='Datum'),
          divisor?: int32(name='Divisor'),
          name?: string(name='Name'),
          nameList?: [ string ](name='NameList'),
          operator?: string(name='Operator'),
          rate?: int32(name='Rate'),
          remainder?: int32(name='Remainder'),
          type?: string(name='Type'),
          value?: string(name='Value'),
        }
      ](name='RestItems'),
    }
  ](name='EntryRules'),
  gmtCreate?: string(name='GmtCreate'),
  gmtModified?: string(name='GmtModified'),
  groupId?: long(name='GroupId'),
  id?: long(name='Id'),
  licenseKey?: string(name='LicenseKey'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
  source?: string(name='Source'),
  status?: int32(name='Status'),
  tag?: string(name='Tag'),
  userId?: string(name='UserId'),
}

model CreateOrUpdateSwimmingLaneResponseBody = {
  code?: int32(name='Code'),
  data?: any(name='Data'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateOrUpdateSwimmingLaneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateOrUpdateSwimmingLaneResponseBody(name='body'),
}

async function createOrUpdateSwimmingLaneWithOptions(request: CreateOrUpdateSwimmingLaneRequest, runtime: Util.RuntimeOptions): CreateOrUpdateSwimmingLaneResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.enable)) {
    query['Enable'] = request.enable;
  }
  if (!Util.isUnset(request.enableRules)) {
    query['EnableRules'] = request.enableRules;
  }
  if (!Util.isUnset(request.entryRule)) {
    query['EntryRule'] = request.entryRule;
  }
  if (!Util.isUnset(request.entryRules)) {
    query['EntryRules'] = request.entryRules;
  }
  if (!Util.isUnset(request.gmtCreate)) {
    query['GmtCreate'] = request.gmtCreate;
  }
  if (!Util.isUnset(request.gmtModified)) {
    query['GmtModified'] = request.gmtModified;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.licenseKey)) {
    query['LicenseKey'] = request.licenseKey;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateOrUpdateSwimmingLane',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createOrUpdateSwimmingLane(request: CreateOrUpdateSwimmingLaneRequest): CreateOrUpdateSwimmingLaneResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOrUpdateSwimmingLaneWithOptions(request, runtime);
}

model CreateOrUpdateSwimmingLaneGroupRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  appIds?: string(name='AppIds'),
  dbGrayEnable?: boolean(name='DbGrayEnable'),
  enable?: boolean(name='Enable'),
  entryApp?: string(name='EntryApp'),
  gmtCreate?: string(name='GmtCreate'),
  gmtModified?: string(name='GmtModified'),
  id?: long(name='Id'),
  licenseKey?: string(name='LicenseKey'),
  messageQueueFilterSide?: string(name='MessageQueueFilterSide'),
  messageQueueGrayEnable?: boolean(name='MessageQueueGrayEnable'),
  name?: string(name='Name'),
  region?: string(name='Region'),
  source?: string(name='Source'),
  status?: int32(name='Status'),
  userId?: string(name='UserId'),
}

model CreateOrUpdateSwimmingLaneGroupResponseBody = {
  code?: int32(name='Code'),
  data?: any(name='Data'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateOrUpdateSwimmingLaneGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateOrUpdateSwimmingLaneGroupResponseBody(name='body'),
}

async function createOrUpdateSwimmingLaneGroupWithOptions(request: CreateOrUpdateSwimmingLaneGroupRequest, runtime: Util.RuntimeOptions): CreateOrUpdateSwimmingLaneGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.appIds)) {
    query['AppIds'] = request.appIds;
  }
  if (!Util.isUnset(request.dbGrayEnable)) {
    query['DbGrayEnable'] = request.dbGrayEnable;
  }
  if (!Util.isUnset(request.enable)) {
    query['Enable'] = request.enable;
  }
  if (!Util.isUnset(request.entryApp)) {
    query['EntryApp'] = request.entryApp;
  }
  if (!Util.isUnset(request.gmtCreate)) {
    query['GmtCreate'] = request.gmtCreate;
  }
  if (!Util.isUnset(request.gmtModified)) {
    query['GmtModified'] = request.gmtModified;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.licenseKey)) {
    query['LicenseKey'] = request.licenseKey;
  }
  if (!Util.isUnset(request.messageQueueFilterSide)) {
    query['MessageQueueFilterSide'] = request.messageQueueFilterSide;
  }
  if (!Util.isUnset(request.messageQueueGrayEnable)) {
    query['MessageQueueGrayEnable'] = request.messageQueueGrayEnable;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateOrUpdateSwimmingLaneGroup',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createOrUpdateSwimmingLaneGroup(request: CreateOrUpdateSwimmingLaneGroupRequest): CreateOrUpdateSwimmingLaneGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOrUpdateSwimmingLaneGroupWithOptions(request, runtime);
}

model CreateZnodeRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterId?: string(name='ClusterId'),
  data?: string(name='Data'),
  path?: string(name='Path'),
}

model CreateZnodeResponseBody = {
  data?: {
    data?: string(name='Data'),
    dir?: boolean(name='Dir'),
    name?: string(name='Name'),
    path?: string(name='Path'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateZnodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateZnodeResponseBody(name='body'),
}

async function createZnodeWithOptions(request: CreateZnodeRequest, runtime: Util.RuntimeOptions): CreateZnodeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.data)) {
    query['Data'] = request.data;
  }
  if (!Util.isUnset(request.path)) {
    query['Path'] = request.path;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateZnode',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createZnode(request: CreateZnodeRequest): CreateZnodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return createZnodeWithOptions(request, runtime);
}

model DeleteAuthResourceRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  id?: long(name='Id'),
}

model DeleteAuthResourceResponseBody = {
  code?: int32(name='Code'),
  data?: {
    authId?: long(name='AuthId'),
    domainId?: long(name='DomainId'),
    domainName?: string(name='DomainName'),
    gatewayId?: long(name='GatewayId'),
    gatewayUniqueId?: string(name='GatewayUniqueId'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    id?: long(name='Id'),
    isWhite?: boolean(name='IsWhite'),
    path?: string(name='Path'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteAuthResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAuthResourceResponseBody(name='body'),
}

async function deleteAuthResourceWithOptions(request: DeleteAuthResourceRequest, runtime: Util.RuntimeOptions): DeleteAuthResourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAuthResource',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteAuthResource(request: DeleteAuthResourceRequest): DeleteAuthResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAuthResourceWithOptions(request, runtime);
}

model DeleteClusterRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  instanceId?: string(name='InstanceId'),
}

model DeleteClusterResponseBody = {
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteClusterResponseBody(name='body'),
}

async function deleteClusterWithOptions(request: DeleteClusterRequest, runtime: Util.RuntimeOptions): DeleteClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCluster',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteCluster(request: DeleteClusterRequest): DeleteClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteClusterWithOptions(request, runtime);
}

model DeleteEngineNamespaceRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterId?: string(name='ClusterId'),
  id?: string(name='Id'),
  instanceId?: string(name='InstanceId'),
}

model DeleteEngineNamespaceResponseBody = {
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteEngineNamespaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteEngineNamespaceResponseBody(name='body'),
}

async function deleteEngineNamespaceWithOptions(request: DeleteEngineNamespaceRequest, runtime: Util.RuntimeOptions): DeleteEngineNamespaceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteEngineNamespace',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteEngineNamespace(request: DeleteEngineNamespaceRequest): DeleteEngineNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteEngineNamespaceWithOptions(request, runtime);
}

model DeleteGatewayRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  deleteSlb?: boolean(name='DeleteSlb'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
}

model DeleteGatewayResponseBody = {
  code?: int32(name='Code'),
  data?: {
    gatewayUniqueId?: string(name='GatewayUniqueId'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    id?: long(name='Id'),
    name?: string(name='Name'),
    primaryUser?: string(name='PrimaryUser'),
    region?: string(name='Region'),
    replica?: int32(name='Replica'),
    securityGroup?: string(name='SecurityGroup'),
    spec?: string(name='Spec'),
    status?: int32(name='Status'),
    vpc?: string(name='Vpc'),
    vswitch?: string(name='Vswitch'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteGatewayResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteGatewayResponseBody(name='body'),
}

async function deleteGatewayWithOptions(request: DeleteGatewayRequest, runtime: Util.RuntimeOptions): DeleteGatewayResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.deleteSlb)) {
    query['DeleteSlb'] = request.deleteSlb;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGateway',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteGateway(request: DeleteGatewayRequest): DeleteGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGatewayWithOptions(request, runtime);
}

model DeleteGatewayDomainRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  id?: string(name='Id'),
}

model DeleteGatewayDomainResponseBody = {
  code?: int32(name='Code'),
  data?: {
    certIdentifier?: string(name='CertIdentifier'),
    gatewayId?: long(name='GatewayId'),
    gatewayUniqueId?: string(name='GatewayUniqueId'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    id?: long(name='Id'),
    mustHttps?: boolean(name='MustHttps'),
    name?: string(name='Name'),
    protocol?: string(name='Protocol'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteGatewayDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteGatewayDomainResponseBody(name='body'),
}

async function deleteGatewayDomainWithOptions(request: DeleteGatewayDomainRequest, runtime: Util.RuntimeOptions): DeleteGatewayDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGatewayDomain',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteGatewayDomain(request: DeleteGatewayDomainRequest): DeleteGatewayDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGatewayDomainWithOptions(request, runtime);
}

model DeleteGatewayRouteRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  routeId?: string(name='RouteId'),
}

model DeleteGatewayRouteResponseBody = {
  code?: int32(name='Code'),
  data?: {
    defaultServiceId?: long(name='DefaultServiceId'),
    gatewayId?: long(name='GatewayId'),
    gatewayUniqueId?: string(name='GatewayUniqueId'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    id?: long(name='Id'),
    name?: string(name='Name'),
    predicates?: string(name='Predicates'),
    routeOrder?: int32(name='RouteOrder'),
    status?: int32(name='Status'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteGatewayRouteResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteGatewayRouteResponseBody(name='body'),
}

async function deleteGatewayRouteWithOptions(request: DeleteGatewayRouteRequest, runtime: Util.RuntimeOptions): DeleteGatewayRouteResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.routeId)) {
    query['RouteId'] = request.routeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGatewayRoute',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteGatewayRoute(request: DeleteGatewayRouteRequest): DeleteGatewayRouteResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGatewayRouteWithOptions(request, runtime);
}

model DeleteGatewayServiceRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayId?: long(name='GatewayId'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  serviceId?: string(name='ServiceId'),
}

model DeleteGatewayServiceResponseBody = {
  code?: int32(name='Code'),
  data?: {
    gatewayId?: long(name='GatewayId'),
    gatewayUniqueId?: string(name='GatewayUniqueId'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    groupName?: string(name='GroupName'),
    id?: long(name='Id'),
    ips?: [ string ](name='Ips'),
    metaInfo?: string(name='MetaInfo'),
    name?: string(name='Name'),
    namespace?: string(name='Namespace'),
    serviceNameInRegistry?: string(name='ServiceNameInRegistry'),
    sourceId?: long(name='SourceId'),
    sourceType?: string(name='SourceType'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteGatewayServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteGatewayServiceResponseBody(name='body'),
}

async function deleteGatewayServiceWithOptions(request: DeleteGatewayServiceRequest, runtime: Util.RuntimeOptions): DeleteGatewayServiceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.gatewayId)) {
    query['GatewayId'] = request.gatewayId;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.serviceId)) {
    query['ServiceId'] = request.serviceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGatewayService',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteGatewayService(request: DeleteGatewayServiceRequest): DeleteGatewayServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGatewayServiceWithOptions(request, runtime);
}

model DeleteGatewayServiceVersionRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  serviceId?: long(name='ServiceId'),
  serviceVersion?: string(name='ServiceVersion'),
}

model DeleteGatewayServiceVersionResponseBody = {
  code?: int32(name='Code'),
  data?: long(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteGatewayServiceVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteGatewayServiceVersionResponseBody(name='body'),
}

async function deleteGatewayServiceVersionWithOptions(request: DeleteGatewayServiceVersionRequest, runtime: Util.RuntimeOptions): DeleteGatewayServiceVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.serviceId)) {
    query['ServiceId'] = request.serviceId;
  }
  if (!Util.isUnset(request.serviceVersion)) {
    query['ServiceVersion'] = request.serviceVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGatewayServiceVersion',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteGatewayServiceVersion(request: DeleteGatewayServiceVersionRequest): DeleteGatewayServiceVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGatewayServiceVersionWithOptions(request, runtime);
}

model DeleteGatewaySlbRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  deleteSlb?: boolean(name='DeleteSlb'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  id?: string(name='Id'),
}

model DeleteGatewaySlbResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteGatewaySlbResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteGatewaySlbResponseBody(name='body'),
}

async function deleteGatewaySlbWithOptions(request: DeleteGatewaySlbRequest, runtime: Util.RuntimeOptions): DeleteGatewaySlbResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.deleteSlb)) {
    query['DeleteSlb'] = request.deleteSlb;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGatewaySlb',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteGatewaySlb(request: DeleteGatewaySlbRequest): DeleteGatewaySlbResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGatewaySlbWithOptions(request, runtime);
}

model DeleteNacosConfigRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  beta?: boolean(name='Beta'),
  dataId?: string(name='DataId'),
  group?: string(name='Group'),
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
}

model DeleteNacosConfigResponseBody = {
  code?: string(name='Code'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteNacosConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteNacosConfigResponseBody(name='body'),
}

async function deleteNacosConfigWithOptions(request: DeleteNacosConfigRequest, runtime: Util.RuntimeOptions): DeleteNacosConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.beta)) {
    query['Beta'] = request.beta;
  }
  if (!Util.isUnset(request.dataId)) {
    query['DataId'] = request.dataId;
  }
  if (!Util.isUnset(request.group)) {
    query['Group'] = request.group;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteNacosConfig',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteNacosConfig(request: DeleteNacosConfigRequest): DeleteNacosConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteNacosConfigWithOptions(request, runtime);
}

model DeleteNacosConfigsRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  ids?: string(name='Ids'),
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
}

model DeleteNacosConfigsResponseBody = {
  code?: int32(name='Code'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteNacosConfigsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteNacosConfigsResponseBody(name='body'),
}

async function deleteNacosConfigsWithOptions(request: DeleteNacosConfigsRequest, runtime: Util.RuntimeOptions): DeleteNacosConfigsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.ids)) {
    query['Ids'] = request.ids;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteNacosConfigs',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteNacosConfigs(request: DeleteNacosConfigsRequest): DeleteNacosConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteNacosConfigsWithOptions(request, runtime);
}

model DeleteNacosInstanceRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterName?: string(name='ClusterName'),
  ephemeral?: boolean(name='Ephemeral'),
  groupName?: string(name='GroupName'),
  instanceId?: string(name='InstanceId'),
  ip?: string(name='Ip'),
  namespaceId?: string(name='NamespaceId'),
  port?: int32(name='Port'),
  serviceName?: string(name='ServiceName'),
}

model DeleteNacosInstanceResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteNacosInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteNacosInstanceResponseBody(name='body'),
}

async function deleteNacosInstanceWithOptions(request: DeleteNacosInstanceRequest, runtime: Util.RuntimeOptions): DeleteNacosInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.ephemeral)) {
    query['Ephemeral'] = request.ephemeral;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ip)) {
    query['Ip'] = request.ip;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  if (!Util.isUnset(request.port)) {
    query['Port'] = request.port;
  }
  if (!Util.isUnset(request.serviceName)) {
    query['ServiceName'] = request.serviceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteNacosInstance',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteNacosInstance(request: DeleteNacosInstanceRequest): DeleteNacosInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteNacosInstanceWithOptions(request, runtime);
}

model DeleteNacosServiceRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  groupName?: string(name='GroupName'),
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
  serviceName?: string(name='ServiceName'),
}

model DeleteNacosServiceResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteNacosServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteNacosServiceResponseBody(name='body'),
}

async function deleteNacosServiceWithOptions(request: DeleteNacosServiceRequest, runtime: Util.RuntimeOptions): DeleteNacosServiceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  if (!Util.isUnset(request.serviceName)) {
    query['ServiceName'] = request.serviceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteNacosService',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteNacosService(request: DeleteNacosServiceRequest): DeleteNacosServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteNacosServiceWithOptions(request, runtime);
}

model DeleteSecurityGroupRuleRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  id?: long(name='Id'),
}

model DeleteSecurityGroupRuleResponseBody = {
  code?: int32(name='Code'),
  data?: {
    description?: string(name='Description'),
    gatewayId?: long(name='GatewayId'),
    gatewayUniqueId?: string(name='GatewayUniqueId'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    id?: long(name='Id'),
    ipProtocol?: string(name='IpProtocol'),
    portRange?: string(name='PortRange'),
    securityGroupId?: string(name='SecurityGroupId'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteSecurityGroupRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSecurityGroupRuleResponseBody(name='body'),
}

async function deleteSecurityGroupRuleWithOptions(request: DeleteSecurityGroupRuleRequest, runtime: Util.RuntimeOptions): DeleteSecurityGroupRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSecurityGroupRule',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSecurityGroupRule(request: DeleteSecurityGroupRuleRequest): DeleteSecurityGroupRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSecurityGroupRuleWithOptions(request, runtime);
}

model DeleteServiceSourceRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  sourceId?: long(name='SourceId'),
}

model DeleteServiceSourceResponseBody = {
  code?: int32(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteServiceSourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteServiceSourceResponseBody(name='body'),
}

async function deleteServiceSourceWithOptions(request: DeleteServiceSourceRequest, runtime: Util.RuntimeOptions): DeleteServiceSourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.sourceId)) {
    query['SourceId'] = request.sourceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteServiceSource',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteServiceSource(request: DeleteServiceSourceRequest): DeleteServiceSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteServiceSourceWithOptions(request, runtime);
}

model DeleteSwimmingLaneRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  laneId?: long(name='LaneId'),
}

model DeleteSwimmingLaneResponseBody = {
  code?: int32(name='Code'),
  data?: any(name='Data'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteSwimmingLaneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSwimmingLaneResponseBody(name='body'),
}

async function deleteSwimmingLaneWithOptions(request: DeleteSwimmingLaneRequest, runtime: Util.RuntimeOptions): DeleteSwimmingLaneResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.laneId)) {
    query['LaneId'] = request.laneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSwimmingLane',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSwimmingLane(request: DeleteSwimmingLaneRequest): DeleteSwimmingLaneResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSwimmingLaneWithOptions(request, runtime);
}

model DeleteSwimmingLaneGroupRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  groupId?: long(name='GroupId'),
}

model DeleteSwimmingLaneGroupResponseBody = {
  code?: int32(name='Code'),
  data?: any(name='Data'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteSwimmingLaneGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSwimmingLaneGroupResponseBody(name='body'),
}

async function deleteSwimmingLaneGroupWithOptions(request: DeleteSwimmingLaneGroupRequest, runtime: Util.RuntimeOptions): DeleteSwimmingLaneGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSwimmingLaneGroup',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSwimmingLaneGroup(request: DeleteSwimmingLaneGroupRequest): DeleteSwimmingLaneGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSwimmingLaneGroupWithOptions(request, runtime);
}

model DeleteZnodeRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterId?: string(name='ClusterId'),
  path?: string(name='Path'),
  requestPars?: string(name='RequestPars'),
}

model DeleteZnodeResponseBody = {
  data?: {
    data?: string(name='Data'),
    dir?: boolean(name='Dir'),
    name?: string(name='Name'),
    path?: string(name='Path'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteZnodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteZnodeResponseBody(name='body'),
}

async function deleteZnodeWithOptions(request: DeleteZnodeRequest, runtime: Util.RuntimeOptions): DeleteZnodeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.path)) {
    query['Path'] = request.path;
  }
  if (!Util.isUnset(request.requestPars)) {
    query['RequestPars'] = request.requestPars;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteZnode',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteZnode(request: DeleteZnodeRequest): DeleteZnodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteZnodeWithOptions(request, runtime);
}

model ExportNacosConfigRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  appName?: string(name='AppName'),
  dataId?: string(name='DataId'),
  group?: string(name='Group'),
  ids?: string(name='Ids'),
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
}

model ExportNacosConfigResponseBody = {
  code?: int32(name='Code'),
  data?: {
    url?: string(name='Url'),
  }(name='Data'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ExportNacosConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ExportNacosConfigResponseBody(name='body'),
}

async function exportNacosConfigWithOptions(request: ExportNacosConfigRequest, runtime: Util.RuntimeOptions): ExportNacosConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.dataId)) {
    query['DataId'] = request.dataId;
  }
  if (!Util.isUnset(request.group)) {
    query['Group'] = request.group;
  }
  if (!Util.isUnset(request.ids)) {
    query['Ids'] = request.ids;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ExportNacosConfig',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function exportNacosConfig(request: ExportNacosConfigRequest): ExportNacosConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return exportNacosConfigWithOptions(request, runtime);
}

model GetAppMessageQueueRouteRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  appId?: string(name='AppId'),
  region?: string(name='Region'),
}

model GetAppMessageQueueRouteResponseBody = {
  code?: int32(name='Code'),
  data?: {
    appId?: string(name='AppId'),
    enable?: boolean(name='Enable'),
    filterSide?: string(name='FilterSide'),
    region?: string(name='Region'),
    tags?: [ string ](name='Tags'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetAppMessageQueueRouteResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAppMessageQueueRouteResponseBody(name='body'),
}

async function getAppMessageQueueRouteWithOptions(request: GetAppMessageQueueRouteRequest, runtime: Util.RuntimeOptions): GetAppMessageQueueRouteResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAppMessageQueueRoute',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAppMessageQueueRoute(request: GetAppMessageQueueRouteRequest): GetAppMessageQueueRouteResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAppMessageQueueRouteWithOptions(request, runtime);
}

model GetApplicationListRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  appId?: string(name='AppId'),
  appName?: string(name='AppName'),
  language?: string(name='Language'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  region?: string(name='Region'),
  sentinelEnable?: boolean(name='SentinelEnable'),
  source?: string(name='Source'),
  switchEnable?: boolean(name='SwitchEnable'),
}

model GetApplicationListResponseBody = {
  code?: int32(name='Code'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    result?: [ 
      {
        appId?: string(name='AppId'),
        appName?: string(name='AppName'),
        extraInfo?: string(name='ExtraInfo'),
        instancesNumber?: int32(name='InstancesNumber'),
        language?: string(name='Language'),
        licenseKey?: string(name='LicenseKey'),
        regionId?: string(name='RegionId'),
        source?: string(name='Source'),
        status?: long(name='Status'),
        userId?: string(name='UserId'),
      }
    ](name='Result'),
    totalSize?: int32(name='TotalSize'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetApplicationListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetApplicationListResponseBody(name='body'),
}

async function getApplicationListWithOptions(request: GetApplicationListRequest, runtime: Util.RuntimeOptions): GetApplicationListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.language)) {
    query['Language'] = request.language;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.sentinelEnable)) {
    query['SentinelEnable'] = request.sentinelEnable;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.switchEnable)) {
    query['SwitchEnable'] = request.switchEnable;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetApplicationList',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getApplicationList(request: GetApplicationListRequest): GetApplicationListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getApplicationListWithOptions(request, runtime);
}

model GetApplicationListWithMetircsRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  appId?: string(name='AppId'),
  appName?: string(name='AppName'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  region?: string(name='Region'),
  source?: string(name='Source'),
}

model GetApplicationListWithMetircsResponseBody = {
  code?: int32(name='Code'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    result?: [ 
      {
        appId?: string(name='AppId'),
        appName?: string(name='AppName'),
        curMetrics?: [ 
          {
            blockQps?: double(name='BlockQps'),
            expQps?: double(name='ExpQps'),
            passQps?: double(name='PassQps'),
            qps?: double(name='Qps'),
            rt?: double(name='Rt'),
            thread?: double(name='Thread'),
            timestamp?: long(name='Timestamp'),
          }
        ](name='CurMetrics'),
        curMetricsFm?: {
          blockQps?: double(name='BlockQps'),
          expQps?: double(name='ExpQps'),
          passQps?: double(name='PassQps'),
          qps?: double(name='Qps'),
          rt?: double(name='Rt'),
          thread?: double(name='Thread'),
          timestamp?: long(name='Timestamp'),
        }(name='CurMetricsFm'),
        extraInfo?: string(name='ExtraInfo'),
        instancesNumber?: int32(name='InstancesNumber'),
        language?: string(name='Language'),
        licenseKey?: string(name='LicenseKey'),
        regionId?: string(name='RegionId'),
        source?: string(name='Source'),
        status?: long(name='Status'),
        tags?: [ string ](name='Tags'),
        userId?: string(name='UserId'),
      }
    ](name='Result'),
    totalSize?: int32(name='TotalSize'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetApplicationListWithMetircsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetApplicationListWithMetircsResponseBody(name='body'),
}

async function getApplicationListWithMetircsWithOptions(request: GetApplicationListWithMetircsRequest, runtime: Util.RuntimeOptions): GetApplicationListWithMetircsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetApplicationListWithMetircs',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getApplicationListWithMetircs(request: GetApplicationListWithMetircsRequest): GetApplicationListWithMetircsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getApplicationListWithMetircsWithOptions(request, runtime);
}

model GetBlackWhiteListRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  isWhite?: boolean(name='IsWhite'),
  resourceType?: string(name='ResourceType'),
  type?: string(name='Type'),
}

model GetBlackWhiteListResponseBody = {
  code?: int32(name='Code'),
  data?: {
    content?: string(name='Content'),
    gatewayId?: long(name='GatewayId'),
    gatewayUniqueId?: string(name='GatewayUniqueId'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    id?: long(name='Id'),
    isWhite?: boolean(name='IsWhite'),
    resourceId?: long(name='ResourceId'),
    resourceType?: string(name='ResourceType'),
    status?: string(name='Status'),
    type?: string(name='Type'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetBlackWhiteListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetBlackWhiteListResponseBody(name='body'),
}

async function getBlackWhiteListWithOptions(request: GetBlackWhiteListRequest, runtime: Util.RuntimeOptions): GetBlackWhiteListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.isWhite)) {
    query['IsWhite'] = request.isWhite;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetBlackWhiteList',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getBlackWhiteList(request: GetBlackWhiteListRequest): GetBlackWhiteListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getBlackWhiteListWithOptions(request, runtime);
}

model GetEngineNamepaceRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterId?: string(name='ClusterId'),
  id?: string(name='Id'),
  instanceId?: string(name='InstanceId'),
}

model GetEngineNamepaceResponseBody = {
  configCount?: string(name='ConfigCount'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  namespace?: string(name='Namespace'),
  namespaceDesc?: string(name='NamespaceDesc'),
  namespaceShowName?: string(name='NamespaceShowName'),
  quota?: string(name='Quota'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  type?: string(name='Type'),
}

model GetEngineNamepaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetEngineNamepaceResponseBody(name='body'),
}

async function getEngineNamepaceWithOptions(request: GetEngineNamepaceRequest, runtime: Util.RuntimeOptions): GetEngineNamepaceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetEngineNamepace',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getEngineNamepace(request: GetEngineNamepaceRequest): GetEngineNamepaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getEngineNamepaceWithOptions(request, runtime);
}

model GetGatewayRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
}

model GetGatewayResponseBody = {
  code?: int32(name='Code'),
  data?: {
    chargeType?: string(name='ChargeType'),
    endDate?: string(name='EndDate'),
    gatewayUniqueId?: string(name='GatewayUniqueId'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    id?: long(name='Id'),
    instanceId?: string(name='InstanceId'),
    logConfigDetails?: {
      logEnabled?: boolean(name='LogEnabled'),
      logStoreName?: string(name='LogStoreName'),
      projectName?: string(name='ProjectName'),
    }(name='LogConfigDetails'),
    mseTag?: string(name='MseTag'),
    name?: string(name='Name'),
    primaryUser?: string(name='PrimaryUser'),
    region?: string(name='Region'),
    replica?: int32(name='Replica'),
    resourceGroupId?: string(name='ResourceGroupId'),
    securityGroup?: string(name='SecurityGroup'),
    spec?: string(name='Spec'),
    status?: int32(name='Status'),
    statusDesc?: string(name='StatusDesc'),
    vpc?: string(name='Vpc'),
    vswitch?: string(name='Vswitch'),
    vswitch2?: string(name='Vswitch2'),
    xtraceDetails?: {
      sample?: int32(name='Sample'),
      traceOn?: boolean(name='TraceOn'),
    }(name='XtraceDetails'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetGatewayResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetGatewayResponseBody(name='body'),
}

async function getGatewayWithOptions(request: GetGatewayRequest, runtime: Util.RuntimeOptions): GetGatewayResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetGateway',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getGateway(request: GetGatewayRequest): GetGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return getGatewayWithOptions(request, runtime);
}

model GetGatewayDomainDetailRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  id?: string(name='Id'),
}

model GetGatewayDomainDetailResponseBody = {
  code?: int32(name='Code'),
  data?: {
    afterDate?: long(name='AfterDate'),
    algorithm?: string(name='Algorithm'),
    beforeDate?: long(name='BeforeDate'),
    certIdentifier?: string(name='CertIdentifier'),
    certName?: string(name='CertName'),
    commonName?: string(name='CommonName'),
    gatewayId?: long(name='GatewayId'),
    gatewayUniqueId?: string(name='GatewayUniqueId'),
    gmtAfter?: string(name='GmtAfter'),
    gmtBefore?: string(name='GmtBefore'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    http2?: string(name='Http2'),
    id?: long(name='Id'),
    issuer?: string(name='Issuer'),
    mustHttps?: boolean(name='MustHttps'),
    name?: string(name='Name'),
    protocol?: string(name='Protocol'),
    sans?: string(name='Sans'),
    tlsMax?: string(name='TlsMax'),
    tlsMin?: string(name='TlsMin'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetGatewayDomainDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetGatewayDomainDetailResponseBody(name='body'),
}

async function getGatewayDomainDetailWithOptions(request: GetGatewayDomainDetailRequest, runtime: Util.RuntimeOptions): GetGatewayDomainDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetGatewayDomainDetail',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getGatewayDomainDetail(request: GetGatewayDomainDetailRequest): GetGatewayDomainDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getGatewayDomainDetailWithOptions(request, runtime);
}

model GetGatewayOptionRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayId?: long(name='GatewayId'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
}

model GetGatewayOptionResponseBody = {
  code?: int32(name='Code'),
  data?: GatewayOption(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetGatewayOptionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetGatewayOptionResponseBody(name='body'),
}

async function getGatewayOptionWithOptions(request: GetGatewayOptionRequest, runtime: Util.RuntimeOptions): GetGatewayOptionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.gatewayId)) {
    query['GatewayId'] = request.gatewayId;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetGatewayOption',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getGatewayOption(request: GetGatewayOptionRequest): GetGatewayOptionResponse {
  var runtime = new Util.RuntimeOptions{};
  return getGatewayOptionWithOptions(request, runtime);
}

model GetGatewayRouteDetailRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  routeId?: long(name='RouteId'),
}

model GetGatewayRouteDetailResponseBody = {
  code?: int32(name='Code'),
  data?: {
    ahasStatus?: int32(name='AhasStatus'),
    cors?: {
      allowCredentials?: boolean(name='AllowCredentials'),
      allowHeaders?: string(name='AllowHeaders'),
      allowMethods?: string(name='AllowMethods'),
      allowOrigins?: string(name='AllowOrigins'),
      exposeHeaders?: string(name='ExposeHeaders'),
      status?: string(name='Status'),
      timeUnit?: string(name='TimeUnit'),
      unitNum?: long(name='UnitNum'),
    }(name='Cors'),
    defaultServiceId?: long(name='DefaultServiceId'),
    defaultServiceName?: string(name='DefaultServiceName'),
    destinationType?: string(name='DestinationType'),
    directResponse?: {
      body?: string(name='Body'),
      code?: int32(name='Code'),
    }(name='DirectResponse'),
    domainId?: long(name='DomainId'),
    domainIdList?: [ long ](name='DomainIdList'),
    domainName?: string(name='DomainName'),
    domainNameList?: [ string ](name='DomainNameList'),
    enableWaf?: boolean(name='EnableWaf'),
    fallback?: boolean(name='Fallback'),
    fallbackServices?: [ 
      {
        agreementType?: string(name='AgreementType'),
        groupName?: string(name='GroupName'),
        name?: string(name='Name'),
        namespace?: string(name='Namespace'),
        percent?: int32(name='Percent'),
        serviceId?: long(name='ServiceId'),
        serviceName?: string(name='ServiceName'),
        servicePort?: int32(name='ServicePort'),
        sourceType?: string(name='SourceType'),
        version?: string(name='Version'),
      }
    ](name='FallbackServices'),
    gatewayId?: long(name='GatewayId'),
    gatewayUniqueId?: string(name='GatewayUniqueId'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    HTTPRewrite?: {
      host?: string(name='Host'),
      path?: string(name='Path'),
      pathType?: string(name='PathType'),
      pattern?: string(name='Pattern'),
      status?: string(name='Status'),
      substitution?: string(name='Substitution'),
    }(name='HTTPRewrite'),
    headerOp?: {
      headerOpItems?: [ 
        {
          directionType?: string(name='DirectionType'),
          key?: string(name='Key'),
          opType?: string(name='OpType'),
          value?: string(name='Value'),
        }
      ](name='HeaderOpItems'),
      status?: string(name='Status'),
    }(name='HeaderOp'),
    id?: long(name='Id'),
    name?: string(name='Name'),
    predicates?: string(name='Predicates'),
    redirect?: {
      code?: int32(name='Code'),
      host?: string(name='Host'),
      path?: string(name='Path'),
    }(name='Redirect'),
    retry?: {
      attempts?: int32(name='Attempts'),
      httpCodes?: [ string ](name='HttpCodes'),
      retryOn?: [ string ](name='RetryOn'),
      status?: string(name='Status'),
    }(name='Retry'),
    routeOrder?: int32(name='RouteOrder'),
    routePredicates?: {
      headerPredicates?: [ 
        {
          key?: string(name='Key'),
          type?: string(name='Type'),
          value?: string(name='Value'),
        }
      ](name='HeaderPredicates'),
      methodPredicates?: [ string ](name='MethodPredicates'),
      pathPredicates?: {
        ignoreCase?: boolean(name='IgnoreCase'),
        path?: string(name='Path'),
        type?: string(name='Type'),
      }(name='PathPredicates'),
      queryPredicates?: [ 
        {
          key?: string(name='Key'),
          type?: string(name='Type'),
          value?: string(name='Value'),
        }
      ](name='QueryPredicates'),
    }(name='RoutePredicates'),
    routeServices?: [ 
      {
        agreementType?: string(name='AgreementType'),
        groupName?: string(name='GroupName'),
        name?: string(name='Name'),
        namespace?: string(name='Namespace'),
        percent?: int32(name='Percent'),
        serviceId?: long(name='ServiceId'),
        serviceName?: string(name='ServiceName'),
        servicePort?: int32(name='ServicePort'),
        sourceType?: string(name='SourceType'),
        version?: string(name='Version'),
      }
    ](name='RouteServices'),
    services?: string(name='Services'),
    status?: int32(name='Status'),
    timeout?: {
      status?: string(name='Status'),
      timeUnit?: string(name='TimeUnit'),
      unitNum?: int32(name='UnitNum'),
    }(name='Timeout'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetGatewayRouteDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetGatewayRouteDetailResponseBody(name='body'),
}

async function getGatewayRouteDetailWithOptions(request: GetGatewayRouteDetailRequest, runtime: Util.RuntimeOptions): GetGatewayRouteDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.routeId)) {
    query['RouteId'] = request.routeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetGatewayRouteDetail',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getGatewayRouteDetail(request: GetGatewayRouteDetailRequest): GetGatewayRouteDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getGatewayRouteDetailWithOptions(request, runtime);
}

model GetGatewayServiceDetailRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  serviceId?: long(name='ServiceId'),
}

model GetGatewayServiceDetailResponseBody = {
  code?: int32(name='Code'),
  data?: {
    gatewayId?: long(name='GatewayId'),
    gatewayTrafficPolicy?: TrafficPolicy(name='GatewayTrafficPolicy'),
    gatewayUniqueId?: string(name='GatewayUniqueId'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    groupName?: string(name='GroupName'),
    healthCheck?: string(name='HealthCheck'),
    healthStatus?: string(name='HealthStatus'),
    id?: long(name='Id'),
    ips?: [ string ](name='Ips'),
    labelDetails?: [ 
      {
        key?: string(name='Key'),
        values?: [ string ](name='Values'),
      }
    ](name='LabelDetails'),
    metaInfo?: string(name='MetaInfo'),
    name?: string(name='Name'),
    namespace?: string(name='Namespace'),
    portTrafficPolicyList?: [ 
      {
        gatewayUniqueId?: string(name='GatewayUniqueId'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        id?: long(name='Id'),
        serviceId?: long(name='ServiceId'),
        servicePort?: int32(name='ServicePort'),
        trafficPolicy?: TrafficPolicy(name='TrafficPolicy'),
      }
    ](name='PortTrafficPolicyList'),
    ports?: [ int32 ](name='Ports'),
    serviceNameInRegistry?: string(name='ServiceNameInRegistry'),
    serviceProtocol?: string(name='ServiceProtocol'),
    sourceId?: long(name='SourceId'),
    sourceType?: string(name='SourceType'),
    versionDetails?: [ 
      {
        endpointNum?: int32(name='EndpointNum'),
        endpointNumPercent?: string(name='EndpointNumPercent'),
        serviceVersion?: {
          labels?: [ 
            {
              key?: string(name='Key'),
              value?: string(name='Value'),
            }
          ](name='Labels'),
          name?: string(name='Name'),
        }(name='ServiceVersion'),
      }
    ](name='VersionDetails'),
    versions?: [ 
      {
        label?: string(name='Label'),
        type?: string(name='Type'),
        value?: string(name='Value'),
      }
    ](name='Versions'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetGatewayServiceDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetGatewayServiceDetailResponseBody(name='body'),
}

async function getGatewayServiceDetailWithOptions(request: GetGatewayServiceDetailRequest, runtime: Util.RuntimeOptions): GetGatewayServiceDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.serviceId)) {
    query['ServiceId'] = request.serviceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetGatewayServiceDetail',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getGatewayServiceDetail(request: GetGatewayServiceDetailRequest): GetGatewayServiceDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getGatewayServiceDetailWithOptions(request, runtime);
}

model GetGovernanceKubernetesClusterRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterId?: string(name='ClusterId'),
  regionId?: string(name='RegionId'),
}

model GetGovernanceKubernetesClusterResponseBody = {
  code?: int32(name='Code'),
  data?: {
    clusterId?: string(name='ClusterId'),
    clusterName?: string(name='ClusterName'),
    k8sVersion?: string(name='K8sVersion'),
    namespaceInfos?: string(name='NamespaceInfos'),
    namespaces?: [ 
      {
        name?: string(name='Name'),
        tags?: string(name='Tags'),
      }
    ](name='Namespaces'),
    pilotStartTime?: string(name='PilotStartTime'),
    region?: string(name='Region'),
    updateTime?: string(name='UpdateTime'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetGovernanceKubernetesClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetGovernanceKubernetesClusterResponseBody(name='body'),
}

async function getGovernanceKubernetesClusterWithOptions(request: GetGovernanceKubernetesClusterRequest, runtime: Util.RuntimeOptions): GetGovernanceKubernetesClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetGovernanceKubernetesCluster',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getGovernanceKubernetesCluster(request: GetGovernanceKubernetesClusterRequest): GetGovernanceKubernetesClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return getGovernanceKubernetesClusterWithOptions(request, runtime);
}

model GetImageRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  versionCode?: string(name='VersionCode'),
}

model GetImageResponseBody = {
  data?: {
    currentVersionFullShowName?: string(name='CurrentVersionFullShowName'),
    maxVersionChangelogUrl?: string(name='MaxVersionChangelogUrl'),
    maxVersionCode?: string(name='MaxVersionCode'),
    maxVersionFullShowName?: string(name='MaxVersionFullShowName'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetImageResponseBody(name='body'),
}

async function getImageWithOptions(request: GetImageRequest, runtime: Util.RuntimeOptions): GetImageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.versionCode)) {
    query['VersionCode'] = request.versionCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetImage',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getImage(request: GetImageRequest): GetImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return getImageWithOptions(request, runtime);
}

model GetImportFileUrlRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  contentType?: string(name='ContentType'),
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
}

model GetImportFileUrlResponseBody = {
  code?: int32(name='Code'),
  data?: {
    url?: string(name='Url'),
  }(name='Data'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetImportFileUrlResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetImportFileUrlResponseBody(name='body'),
}

async function getImportFileUrlWithOptions(request: GetImportFileUrlRequest, runtime: Util.RuntimeOptions): GetImportFileUrlResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.contentType)) {
    query['ContentType'] = request.contentType;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetImportFileUrl',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getImportFileUrl(request: GetImportFileUrlRequest): GetImportFileUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  return getImportFileUrlWithOptions(request, runtime);
}

model GetKubernetesSourceRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
}

model GetKubernetesSourceResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      cluster?: string(name='Cluster'),
      name?: string(name='Name'),
    }
  ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetKubernetesSourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetKubernetesSourceResponseBody(name='body'),
}

async function getKubernetesSourceWithOptions(request: GetKubernetesSourceRequest, runtime: Util.RuntimeOptions): GetKubernetesSourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetKubernetesSource',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getKubernetesSource(request: GetKubernetesSourceRequest): GetKubernetesSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getKubernetesSourceWithOptions(request, runtime);
}

model GetMseFeatureSwitchRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
}

model GetMseFeatureSwitchResponseBody = {
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: map[string]any(name='Result'),
  success?: boolean(name='Success'),
}

model GetMseFeatureSwitchResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMseFeatureSwitchResponseBody(name='body'),
}

async function getMseFeatureSwitchWithOptions(request: GetMseFeatureSwitchRequest, runtime: Util.RuntimeOptions): GetMseFeatureSwitchResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMseFeatureSwitch',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMseFeatureSwitch(request: GetMseFeatureSwitchRequest): GetMseFeatureSwitchResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMseFeatureSwitchWithOptions(request, runtime);
}

model GetMseSourceRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  type?: string(name='Type'),
}

model GetMseSourceResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      address?: string(name='Address'),
      clusterId?: string(name='ClusterId'),
      instanceId?: string(name='InstanceId'),
      name?: string(name='Name'),
      type?: string(name='Type'),
    }
  ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetMseSourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMseSourceResponseBody(name='body'),
}

async function getMseSourceWithOptions(request: GetMseSourceRequest, runtime: Util.RuntimeOptions): GetMseSourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMseSource',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMseSource(request: GetMseSourceRequest): GetMseSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMseSourceWithOptions(request, runtime);
}

model GetNacosConfigRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  beta?: boolean(name='Beta'),
  dataId?: string(name='DataId'),
  group?: string(name='Group'),
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
}

model GetNacosConfigResponseBody = {
  configuration?: {
    appName?: string(name='AppName'),
    betaIps?: string(name='BetaIps'),
    content?: string(name='Content'),
    dataId?: string(name='DataId'),
    desc?: string(name='Desc'),
    encryptedDataKey?: string(name='EncryptedDataKey'),
    group?: string(name='Group'),
    md5?: string(name='Md5'),
    tags?: string(name='Tags'),
    type?: string(name='Type'),
  }(name='Configuration'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetNacosConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetNacosConfigResponseBody(name='body'),
}

async function getNacosConfigWithOptions(request: GetNacosConfigRequest, runtime: Util.RuntimeOptions): GetNacosConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.beta)) {
    query['Beta'] = request.beta;
  }
  if (!Util.isUnset(request.dataId)) {
    query['DataId'] = request.dataId;
  }
  if (!Util.isUnset(request.group)) {
    query['Group'] = request.group;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetNacosConfig',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getNacosConfig(request: GetNacosConfigRequest): GetNacosConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return getNacosConfigWithOptions(request, runtime);
}

model GetNacosHistoryConfigRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  dataId?: string(name='DataId'),
  group?: string(name='Group'),
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
  nid?: string(name='Nid'),
}

model GetNacosHistoryConfigResponseBody = {
  configuration?: {
    appName?: string(name='AppName'),
    content?: string(name='Content'),
    dataId?: string(name='DataId'),
    encryptedDataKey?: string(name='EncryptedDataKey'),
    group?: string(name='Group'),
    md5?: string(name='Md5'),
    opType?: string(name='OpType'),
  }(name='Configuration'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetNacosHistoryConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetNacosHistoryConfigResponseBody(name='body'),
}

async function getNacosHistoryConfigWithOptions(request: GetNacosHistoryConfigRequest, runtime: Util.RuntimeOptions): GetNacosHistoryConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.dataId)) {
    query['DataId'] = request.dataId;
  }
  if (!Util.isUnset(request.group)) {
    query['Group'] = request.group;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  if (!Util.isUnset(request.nid)) {
    query['Nid'] = request.nid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetNacosHistoryConfig',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getNacosHistoryConfig(request: GetNacosHistoryConfigRequest): GetNacosHistoryConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return getNacosHistoryConfigWithOptions(request, runtime);
}

model GetOverviewRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  period?: int32(name='Period'),
  region?: string(name='Region'),
}

model GetOverviewResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model GetOverviewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetOverviewResponseBody(name='body'),
}

async function getOverviewWithOptions(request: GetOverviewRequest, runtime: Util.RuntimeOptions): GetOverviewResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetOverview',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getOverview(request: GetOverviewRequest): GetOverviewResponse {
  var runtime = new Util.RuntimeOptions{};
  return getOverviewWithOptions(request, runtime);
}

model GetPluginConfigRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  pluginId?: long(name='PluginId'),
}

model GetPluginConfigResponseBody = {
  code?: int32(name='Code'),
  data?: {
    category?: int32(name='Category'),
    configCheck?: string(name='ConfigCheck'),
    gatewayConfigList?: [ 
      {
        config?: string(name='Config'),
        configLevel?: int32(name='ConfigLevel'),
        enable?: boolean(name='Enable'),
        gatewayId?: long(name='GatewayId'),
        gatewayUniqueId?: string(name='GatewayUniqueId'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        id?: long(name='Id'),
        pluginId?: long(name='PluginId'),
      }
    ](name='GatewayConfigList'),
    id?: long(name='Id'),
    imageName?: string(name='ImageName'),
    mode?: int32(name='Mode'),
    name?: string(name='Name'),
    phase?: int32(name='Phase'),
    primaryUser?: string(name='PrimaryUser'),
    priority?: int32(name='Priority'),
    publishState?: int32(name='PublishState'),
    readme?: string(name='Readme'),
    readmeEn?: string(name='ReadmeEn'),
    status?: string(name='Status'),
    summary?: string(name='Summary'),
    type?: int32(name='Type'),
    version?: string(name='Version'),
    wasmLang?: int32(name='WasmLang'),
  }(name='Data'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetPluginConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPluginConfigResponseBody(name='body'),
}

async function getPluginConfigWithOptions(request: GetPluginConfigRequest, runtime: Util.RuntimeOptions): GetPluginConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.pluginId)) {
    query['PluginId'] = request.pluginId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetPluginConfig',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPluginConfig(request: GetPluginConfigRequest): GetPluginConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPluginConfigWithOptions(request, runtime);
}

model GetPluginsRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  category?: int32(name='Category'),
  enableOnly?: boolean(name='EnableOnly'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  name?: string(name='Name'),
}

model GetPluginsResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      category?: int32(name='Category'),
      configCheck?: string(name='ConfigCheck'),
      id?: long(name='Id'),
      name?: string(name='Name'),
      phase?: int32(name='Phase'),
      primaryUser?: string(name='PrimaryUser'),
      priority?: int32(name='Priority'),
      publishState?: int32(name='PublishState'),
      status?: string(name='Status'),
      summary?: string(name='Summary'),
      version?: string(name='Version'),
      wasmFile?: string(name='WasmFile'),
      wasmLang?: int32(name='WasmLang'),
    }
  ](name='Data'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetPluginsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPluginsResponseBody(name='body'),
}

async function getPluginsWithOptions(request: GetPluginsRequest, runtime: Util.RuntimeOptions): GetPluginsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.category)) {
    query['Category'] = request.category;
  }
  if (!Util.isUnset(request.enableOnly)) {
    query['EnableOnly'] = request.enableOnly;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetPlugins',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPlugins(request: GetPluginsRequest): GetPluginsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPluginsWithOptions(request, runtime);
}

model GetServiceListRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  appId?: string(name='AppId'),
  ip?: string(name='Ip'),
  region?: string(name='Region'),
  serviceName?: string(name='ServiceName'),
  serviceType?: string(name='ServiceType'),
}

model GetServiceListResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      dubboApplicationName?: string(name='DubboApplicationName'),
      edasAppName?: string(name='EdasAppName'),
      group?: string(name='Group'),
      metadata?: map[string]any(name='Metadata'),
      methods?: [ 
        {
          methodController?: string(name='MethodController'),
          name?: string(name='Name'),
          parameterTypes?: [ string ](name='ParameterTypes'),
          paths?: [ string ](name='Paths'),
          requestMethods?: [ string ](name='RequestMethods'),
          returnType?: string(name='ReturnType'),
        }
      ](name='Methods'),
      registryType?: string(name='RegistryType'),
      serviceName?: string(name='ServiceName'),
      serviceType?: string(name='ServiceType'),
      springApplicationName?: string(name='SpringApplicationName'),
      version?: string(name='Version'),
    }
  ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetServiceListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetServiceListResponseBody(name='body'),
}

async function getServiceListWithOptions(request: GetServiceListRequest, runtime: Util.RuntimeOptions): GetServiceListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.ip)) {
    query['Ip'] = request.ip;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.serviceName)) {
    query['ServiceName'] = request.serviceName;
  }
  if (!Util.isUnset(request.serviceType)) {
    query['ServiceType'] = request.serviceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetServiceList',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getServiceList(request: GetServiceListRequest): GetServiceListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getServiceListWithOptions(request, runtime);
}

model GetServiceListenersRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterId?: string(name='ClusterId'),
  clusterName?: string(name='ClusterName'),
  groupName?: string(name='GroupName'),
  hasIpCount?: string(name='HasIpCount'),
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  requestPars?: string(name='RequestPars'),
  serviceName?: string(name='ServiceName'),
}

model GetServiceListenersResponseBody = {
  data?: [ 
    {
      addr?: string(name='Addr'),
      agent?: string(name='Agent'),
      app?: string(name='App'),
      cluster?: string(name='Cluster'),
      IP?: string(name='IP'),
      namespaceId?: string(name='NamespaceId'),
      port?: string(name='Port'),
      serviceName?: string(name='ServiceName'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model GetServiceListenersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetServiceListenersResponseBody(name='body'),
}

async function getServiceListenersWithOptions(request: GetServiceListenersRequest, runtime: Util.RuntimeOptions): GetServiceListenersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.hasIpCount)) {
    query['HasIpCount'] = request.hasIpCount;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.requestPars)) {
    query['RequestPars'] = request.requestPars;
  }
  if (!Util.isUnset(request.serviceName)) {
    query['ServiceName'] = request.serviceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetServiceListeners',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getServiceListeners(request: GetServiceListenersRequest): GetServiceListenersResponse {
  var runtime = new Util.RuntimeOptions{};
  return getServiceListenersWithOptions(request, runtime);
}

model GetTagsBySwimmingLaneGroupIdRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  groupId?: long(name='GroupId'),
}

model GetTagsBySwimmingLaneGroupIdResponseBody = {
  code?: int32(name='Code'),
  data?: any(name='Data'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetTagsBySwimmingLaneGroupIdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTagsBySwimmingLaneGroupIdResponseBody(name='body'),
}

async function getTagsBySwimmingLaneGroupIdWithOptions(request: GetTagsBySwimmingLaneGroupIdRequest, runtime: Util.RuntimeOptions): GetTagsBySwimmingLaneGroupIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTagsBySwimmingLaneGroupId',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTagsBySwimmingLaneGroupId(request: GetTagsBySwimmingLaneGroupIdRequest): GetTagsBySwimmingLaneGroupIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTagsBySwimmingLaneGroupIdWithOptions(request, runtime);
}

model ImportNacosConfigRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  fileUrl?: string(name='FileUrl'),
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
  policy?: string(name='Policy'),
}

model ImportNacosConfigResponseBody = {
  code?: int32(name='Code'),
  data?: {
    failData?: [ 
      {
        dataId?: string(name='DataId'),
        group?: string(name='Group'),
      }
    ](name='FailData'),
    skipCount?: int32(name='SkipCount'),
    skipData?: [ 
      {
        dataId?: string(name='DataId'),
        group?: string(name='Group'),
      }
    ](name='SkipData'),
    succCount?: int32(name='SuccCount'),
  }(name='Data'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ImportNacosConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ImportNacosConfigResponseBody(name='body'),
}

async function importNacosConfigWithOptions(request: ImportNacosConfigRequest, runtime: Util.RuntimeOptions): ImportNacosConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.fileUrl)) {
    query['FileUrl'] = request.fileUrl;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  if (!Util.isUnset(request.policy)) {
    query['Policy'] = request.policy;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ImportNacosConfig',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function importNacosConfig(request: ImportNacosConfigRequest): ImportNacosConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return importNacosConfigWithOptions(request, runtime);
}

model ImportServicesRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  serviceList?: [ 
    {
      groupName?: string(name='GroupName'),
      ips?: [ string ](name='Ips'),
      name?: string(name='Name'),
      namespace?: string(name='Namespace'),
      servicePort?: long(name='ServicePort'),
      serviceProtocol?: string(name='ServiceProtocol'),
    }
  ](name='ServiceList'),
  sourceType?: string(name='SourceType'),
  tlsSetting?: string(name='TlsSetting'),
}

model ImportServicesShrinkRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  serviceListShrink?: string(name='ServiceList'),
  sourceType?: string(name='SourceType'),
  tlsSetting?: string(name='TlsSetting'),
}

model ImportServicesResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ImportServicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ImportServicesResponseBody(name='body'),
}

async function importServicesWithOptions(tmpReq: ImportServicesRequest, runtime: Util.RuntimeOptions): ImportServicesResponse {
  Util.validateModel(tmpReq);
  var request = new ImportServicesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.serviceList)) {
    request.serviceListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.serviceList, 'ServiceList', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.serviceListShrink)) {
    query['ServiceList'] = request.serviceListShrink;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  if (!Util.isUnset(request.tlsSetting)) {
    query['TlsSetting'] = request.tlsSetting;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ImportServices',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function importServices(request: ImportServicesRequest): ImportServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return importServicesWithOptions(request, runtime);
}

model ListAnsInstancesRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterId?: string(name='ClusterId'),
  clusterName?: string(name='ClusterName'),
  groupName?: string(name='GroupName'),
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  requestPars?: string(name='RequestPars'),
  serviceName?: string(name='ServiceName'),
}

model ListAnsInstancesResponseBody = {
  data?: [ 
    {
      app?: string(name='App'),
      clusterName?: string(name='ClusterName'),
      datumKey?: string(name='DatumKey'),
      defaultKey?: string(name='DefaultKey'),
      enabled?: boolean(name='Enabled'),
      ephemeral?: boolean(name='Ephemeral'),
      failCount?: int32(name='FailCount'),
      healthy?: boolean(name='Healthy'),
      instanceHeartBeatInterval?: int32(name='InstanceHeartBeatInterval'),
      instanceHeartBeatTimeOut?: int32(name='InstanceHeartBeatTimeOut'),
      instanceId?: string(name='InstanceId'),
      ip?: string(name='Ip'),
      ipDeleteTimeout?: int32(name='IpDeleteTimeout'),
      lastBeat?: long(name='LastBeat'),
      marked?: boolean(name='Marked'),
      metadata?: map[string]any(name='Metadata'),
      okCount?: int32(name='OkCount'),
      port?: int32(name='Port'),
      serviceName?: string(name='ServiceName'),
      weight?: int32(name='Weight'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListAnsInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAnsInstancesResponseBody(name='body'),
}

async function listAnsInstancesWithOptions(request: ListAnsInstancesRequest, runtime: Util.RuntimeOptions): ListAnsInstancesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAnsInstances',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAnsInstances(request: ListAnsInstancesRequest): ListAnsInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAnsInstancesWithOptions(request, runtime);
}

model ListAnsServiceClustersRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterId?: string(name='ClusterId'),
  clusterName?: string(name='ClusterName'),
  groupName?: string(name='GroupName'),
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  requestPars?: string(name='RequestPars'),
  serviceName?: string(name='ServiceName'),
}

model ListAnsServiceClustersResponseBody = {
  data?: {
    clusters?: [ 
      {
        defaultCheckPort?: int32(name='DefaultCheckPort'),
        defaultPort?: int32(name='DefaultPort'),
        healthCheckerType?: string(name='HealthCheckerType'),
        metadata?: map[string]any(name='Metadata'),
        name?: string(name='Name'),
        serviceName?: string(name='ServiceName'),
        useIPPort4Check?: boolean(name='UseIPPort4Check'),
      }
    ](name='Clusters'),
    ephemeral?: boolean(name='Ephemeral'),
    groupName?: string(name='GroupName'),
    metadata?: map[string]any(name='Metadata'),
    name?: string(name='Name'),
    protectThreshold?: float(name='ProtectThreshold'),
    selectorType?: string(name='SelectorType'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListAnsServiceClustersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAnsServiceClustersResponseBody(name='body'),
}

async function listAnsServiceClustersWithOptions(request: ListAnsServiceClustersRequest, runtime: Util.RuntimeOptions): ListAnsServiceClustersResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAnsServiceClusters',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAnsServiceClusters(request: ListAnsServiceClustersRequest): ListAnsServiceClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAnsServiceClustersWithOptions(request, runtime);
}

model ListAnsServicesRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterId?: string(name='ClusterId'),
  groupName?: string(name='GroupName'),
  hasIpCount?: string(name='HasIpCount'),
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  requestPars?: string(name='RequestPars'),
  serviceName?: string(name='ServiceName'),
}

model ListAnsServicesResponseBody = {
  data?: [ 
    {
      clusterCount?: int32(name='ClusterCount'),
      groupName?: string(name='GroupName'),
      healthyInstanceCount?: int32(name='HealthyInstanceCount'),
      ipCount?: int32(name='IpCount'),
      name?: string(name='Name'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListAnsServicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAnsServicesResponseBody(name='body'),
}

async function listAnsServicesWithOptions(request: ListAnsServicesRequest, runtime: Util.RuntimeOptions): ListAnsServicesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAnsServices',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAnsServices(request: ListAnsServicesRequest): ListAnsServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAnsServicesWithOptions(request, runtime);
}

model ListAppBySwimmingLaneGroupTagRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  groupId?: long(name='GroupId'),
  tag?: string(name='Tag'),
}

model ListAppBySwimmingLaneGroupTagResponseBody = {
  code?: int32(name='Code'),
  data?: any(name='Data'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListAppBySwimmingLaneGroupTagResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAppBySwimmingLaneGroupTagResponseBody(name='body'),
}

async function listAppBySwimmingLaneGroupTagWithOptions(request: ListAppBySwimmingLaneGroupTagRequest, runtime: Util.RuntimeOptions): ListAppBySwimmingLaneGroupTagResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAppBySwimmingLaneGroupTag',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAppBySwimmingLaneGroupTag(request: ListAppBySwimmingLaneGroupTagRequest): ListAppBySwimmingLaneGroupTagResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAppBySwimmingLaneGroupTagWithOptions(request, runtime);
}

model ListApplicationsWithTagRulesRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  appId?: string(name='AppId'),
  appName?: string(name='AppName'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  region?: string(name='Region'),
  source?: string(name='Source'),
}

model ListApplicationsWithTagRulesResponseBody = {
  code?: int32(name='Code'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    result?: [ 
      {
        appId?: string(name='AppId'),
        appName?: string(name='AppName'),
        routeRules?: [ 
          {
            carryData?: boolean(name='CarryData'),
            enable?: boolean(name='Enable'),
            gmtModified?: string(name='GmtModified'),
            id?: long(name='Id'),
            instanceNum?: int32(name='InstanceNum'),
            name?: string(name='Name'),
            rate?: int32(name='Rate'),
            remove?: boolean(name='Remove'),
            rules?: string(name='Rules'),
            status?: int32(name='Status'),
            tag?: string(name='Tag'),
          }
        ](name='RouteRules'),
        routeStatus?: long(name='RouteStatus'),
      }
    ](name='Result'),
    totalSize?: int32(name='TotalSize'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListApplicationsWithTagRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListApplicationsWithTagRulesResponseBody(name='body'),
}

async function listApplicationsWithTagRulesWithOptions(request: ListApplicationsWithTagRulesRequest, runtime: Util.RuntimeOptions): ListApplicationsWithTagRulesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListApplicationsWithTagRules',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listApplicationsWithTagRules(request: ListApplicationsWithTagRulesRequest): ListApplicationsWithTagRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listApplicationsWithTagRulesWithOptions(request, runtime);
}

model ListClusterConnectionTypesRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
}

model ListClusterConnectionTypesResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      showName?: string(name='ShowName'),
    }
  ](name='Data'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListClusterConnectionTypesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListClusterConnectionTypesResponseBody(name='body'),
}

async function listClusterConnectionTypesWithOptions(request: ListClusterConnectionTypesRequest, runtime: Util.RuntimeOptions): ListClusterConnectionTypesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListClusterConnectionTypes',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listClusterConnectionTypes(request: ListClusterConnectionTypesRequest): ListClusterConnectionTypesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClusterConnectionTypesWithOptions(request, runtime);
}

model ListClusterTypesRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  connectType?: string(name='ConnectType'),
  mseVersion?: string(name='MseVersion'),
  regionId?: string(name='RegionId'),
}

model ListClusterTypesResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      showName?: string(name='ShowName'),
    }
  ](name='Data'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListClusterTypesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListClusterTypesResponseBody(name='body'),
}

async function listClusterTypesWithOptions(request: ListClusterTypesRequest, runtime: Util.RuntimeOptions): ListClusterTypesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.connectType)) {
    query['ConnectType'] = request.connectType;
  }
  if (!Util.isUnset(request.mseVersion)) {
    query['MseVersion'] = request.mseVersion;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListClusterTypes',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listClusterTypes(request: ListClusterTypesRequest): ListClusterTypesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClusterTypesWithOptions(request, runtime);
}

model ListClusterVersionsRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterType?: string(name='ClusterType'),
  mseVersion?: string(name='MseVersion'),
}

model ListClusterVersionsResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      clusterType?: string(name='ClusterType'),
      code?: string(name='Code'),
      showName?: string(name='ShowName'),
    }
  ](name='Data'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListClusterVersionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListClusterVersionsResponseBody(name='body'),
}

async function listClusterVersionsWithOptions(request: ListClusterVersionsRequest, runtime: Util.RuntimeOptions): ListClusterVersionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clusterType)) {
    query['ClusterType'] = request.clusterType;
  }
  if (!Util.isUnset(request.mseVersion)) {
    query['MseVersion'] = request.mseVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListClusterVersions',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listClusterVersions(request: ListClusterVersionsRequest): ListClusterVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClusterVersionsWithOptions(request, runtime);
}

model ListClustersRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterAliasName?: string(name='ClusterAliasName'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  requestPars?: string(name='RequestPars'),
  resourceGroupId?: string(name='ResourceGroupId'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model ListClustersResponseBody = {
  data?: [ 
    {
      appVersion?: string(name='AppVersion'),
      canUpdate?: boolean(name='CanUpdate'),
      chargeType?: string(name='ChargeType'),
      clusterAliasName?: string(name='ClusterAliasName'),
      clusterName?: string(name='ClusterName'),
      clusterType?: string(name='ClusterType'),
      createTime?: string(name='CreateTime'),
      endDate?: string(name='EndDate'),
      initStatus?: string(name='InitStatus'),
      instanceCount?: long(name='InstanceCount'),
      instanceId?: string(name='InstanceId'),
      internetAddress?: string(name='InternetAddress'),
      internetDomain?: string(name='InternetDomain'),
      intranetAddress?: string(name='IntranetAddress'),
      intranetDomain?: string(name='IntranetDomain'),
      mseVersion?: string(name='MseVersion'),
      resourceGroupId?: string(name='ResourceGroupId'),
      tags?: map[string]any(name='Tags'),
      versionCode?: string(name='VersionCode'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListClustersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListClustersResponseBody(name='body'),
}

async function listClustersWithOptions(request: ListClustersRequest, runtime: Util.RuntimeOptions): ListClustersResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListClusters',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listClusters(request: ListClustersRequest): ListClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClustersWithOptions(request, runtime);
}

model ListEngineNamespacesRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  instanceId?: string(name='InstanceId'),
}

model ListEngineNamespacesResponseBody = {
  data?: [ 
    {
      configCount?: int32(name='ConfigCount'),
      namespace?: string(name='Namespace'),
      namespaceDesc?: string(name='NamespaceDesc'),
      namespaceShowName?: string(name='NamespaceShowName'),
      quota?: int32(name='Quota'),
      serviceCount?: string(name='ServiceCount'),
      type?: int32(name='Type'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListEngineNamespacesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListEngineNamespacesResponseBody(name='body'),
}

async function listEngineNamespacesWithOptions(request: ListEngineNamespacesRequest, runtime: Util.RuntimeOptions): ListEngineNamespacesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListEngineNamespaces',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listEngineNamespaces(request: ListEngineNamespacesRequest): ListEngineNamespacesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEngineNamespacesWithOptions(request, runtime);
}

model ListEurekaInstancesRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterId?: string(name='ClusterId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  requestPars?: string(name='RequestPars'),
  serviceName?: string(name='ServiceName'),
}

model ListEurekaInstancesResponseBody = {
  data?: [ 
    {
      app?: string(name='App'),
      durationInSecs?: int32(name='DurationInSecs'),
      homePageUrl?: string(name='HomePageUrl'),
      hostName?: string(name='HostName'),
      instanceId?: string(name='InstanceId'),
      ipAddr?: string(name='IpAddr'),
      lastDirtyTimestamp?: long(name='LastDirtyTimestamp'),
      lastUpdatedTimestamp?: long(name='LastUpdatedTimestamp'),
      metadata?: map[string]any(name='Metadata'),
      port?: int32(name='Port'),
      renewalIntervalInSecs?: int32(name='RenewalIntervalInSecs'),
      securePort?: int32(name='SecurePort'),
      status?: string(name='Status'),
      vipAddress?: string(name='VipAddress'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListEurekaInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListEurekaInstancesResponseBody(name='body'),
}

async function listEurekaInstancesWithOptions(request: ListEurekaInstancesRequest, runtime: Util.RuntimeOptions): ListEurekaInstancesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListEurekaInstances',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listEurekaInstances(request: ListEurekaInstancesRequest): ListEurekaInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEurekaInstancesWithOptions(request, runtime);
}

model ListEurekaServicesRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterId?: string(name='ClusterId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  requestPars?: string(name='RequestPars'),
}

model ListEurekaServicesResponseBody = {
  data?: [ 
    {
      instancesId?: [ string ](name='InstancesId'),
      name?: string(name='Name'),
      upStatus?: string(name='UpStatus'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListEurekaServicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListEurekaServicesResponseBody(name='body'),
}

async function listEurekaServicesWithOptions(request: ListEurekaServicesRequest, runtime: Util.RuntimeOptions): ListEurekaServicesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListEurekaServices',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listEurekaServices(request: ListEurekaServicesRequest): ListEurekaServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEurekaServicesWithOptions(request, runtime);
}

model ListGatewayRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  descSort?: boolean(name='DescSort'),
  filterParams?: {
    gatewayType?: string(name='GatewayType'),
    gatewayUniqueId?: string(name='GatewayUniqueId'),
    instanceId?: string(name='InstanceId'),
    mseTag?: string(name='MseTag'),
    name?: string(name='Name'),
    resourceGroupId?: string(name='ResourceGroupId'),
    vpc?: string(name='Vpc'),
  }(name='FilterParams'),
  orderItem?: string(name='OrderItem'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListGatewayShrinkRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  descSort?: boolean(name='DescSort'),
  filterParamsShrink?: string(name='FilterParams'),
  orderItem?: string(name='OrderItem'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListGatewayResponseBody = {
  code?: int32(name='Code'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    result?: [ 
      {
        ahasOn?: boolean(name='AhasOn'),
        appVersion?: string(name='AppVersion'),
        armsOn?: boolean(name='ArmsOn'),
        chargeType?: string(name='ChargeType'),
        currentVersion?: string(name='CurrentVersion'),
        endDate?: string(name='EndDate'),
        gatewayType?: string(name='GatewayType'),
        gatewayUniqueId?: string(name='GatewayUniqueId'),
        gatewayVersion?: string(name='GatewayVersion'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        id?: long(name='Id'),
        initConfig?: {
          enableWaf?: boolean(name='EnableWaf'),
          supportWaf?: boolean(name='SupportWaf'),
        }(name='InitConfig'),
        instanceId?: string(name='InstanceId'),
        internetSlb?: [ 
          {
            gatewaySlbMode?: string(name='GatewaySlbMode'),
            gatewaySlbStatus?: string(name='GatewaySlbStatus'),
            internetNetworkFlow?: string(name='InternetNetworkFlow'),
            slbId?: string(name='SlbId'),
            slbIp?: string(name='SlbIp'),
            slbPort?: string(name='SlbPort'),
            slbSpec?: string(name='SlbSpec'),
            statusDesc?: string(name='StatusDesc'),
            type?: string(name='Type'),
          }
        ](name='InternetSlb'),
        latestVersion?: string(name='LatestVersion'),
        mseTag?: string(name='MseTag'),
        mustUpgrade?: boolean(name='MustUpgrade'),
        name?: string(name='Name'),
        primaryUser?: string(name='PrimaryUser'),
        region?: string(name='Region'),
        replica?: int32(name='Replica'),
        resourceGroupId?: string(name='ResourceGroupId'),
        rollBack?: boolean(name='RollBack'),
        slb?: [ 
          {
            gatewaySlbMode?: string(name='GatewaySlbMode'),
            gatewaySlbStatus?: string(name='GatewaySlbStatus'),
            slbId?: string(name='SlbId'),
            slbIp?: string(name='SlbIp'),
            slbPort?: string(name='SlbPort'),
            slbSpec?: string(name='SlbSpec'),
            statusDesc?: string(name='StatusDesc'),
            type?: string(name='Type'),
          }
        ](name='Slb'),
        spec?: string(name='Spec'),
        status?: int32(name='Status'),
        statusDesc?: string(name='StatusDesc'),
        supportWasm?: boolean(name='SupportWasm'),
        tag?: string(name='Tag'),
        upgrade?: boolean(name='Upgrade'),
        vswitch2?: string(name='Vswitch2'),
      }
    ](name='Result'),
    totalSize?: long(name='TotalSize'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListGatewayResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListGatewayResponseBody(name='body'),
}

async function listGatewayWithOptions(tmpReq: ListGatewayRequest, runtime: Util.RuntimeOptions): ListGatewayResponse {
  Util.validateModel(tmpReq);
  var request = new ListGatewayShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.filterParams)) {
    request.filterParamsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.filterParams, 'FilterParams', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.descSort)) {
    query['DescSort'] = request.descSort;
  }
  if (!Util.isUnset(request.filterParamsShrink)) {
    query['FilterParams'] = request.filterParamsShrink;
  }
  if (!Util.isUnset(request.orderItem)) {
    query['OrderItem'] = request.orderItem;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListGateway',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listGateway(request: ListGatewayRequest): ListGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return listGatewayWithOptions(request, runtime);
}

model ListGatewayDomainRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  type?: string(name='Type'),
}

model ListGatewayDomainResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      certBeforeDate?: string(name='CertBeforeDate'),
      certIdentifier?: string(name='CertIdentifier'),
      comment?: {
        status?: string(name='Status'),
      }(name='Comment'),
      gatewayId?: long(name='GatewayId'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      http2?: string(name='Http2'),
      id?: long(name='Id'),
      mustHttps?: boolean(name='MustHttps'),
      name?: string(name='Name'),
      protocol?: string(name='Protocol'),
      status?: int32(name='Status'),
      tlsMax?: string(name='TlsMax'),
      tlsMin?: string(name='TlsMin'),
      type?: string(name='Type'),
    }
  ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListGatewayDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListGatewayDomainResponseBody(name='body'),
}

async function listGatewayDomainWithOptions(request: ListGatewayDomainRequest, runtime: Util.RuntimeOptions): ListGatewayDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListGatewayDomain',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listGatewayDomain(request: ListGatewayDomainRequest): ListGatewayDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return listGatewayDomainWithOptions(request, runtime);
}

model ListGatewayRouteRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  descSort?: boolean(name='DescSort'),
  filterParams?: {
    defaultServiceId?: long(name='DefaultServiceId'),
    domainId?: long(name='DomainId'),
    domainName?: string(name='DomainName'),
    gatewayId?: long(name='GatewayId'),
    gatewayUniqueId?: string(name='GatewayUniqueId'),
    name?: string(name='Name'),
    routeOrder?: int32(name='RouteOrder'),
    status?: int32(name='Status'),
  }(name='FilterParams'),
  orderItem?: string(name='OrderItem'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListGatewayRouteShrinkRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  descSort?: boolean(name='DescSort'),
  filterParamsShrink?: string(name='FilterParams'),
  orderItem?: string(name='OrderItem'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListGatewayRouteResponseBody = {
  code?: int32(name='Code'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    result?: [ 
      {
        comment?: {
          status?: string(name='Status'),
        }(name='Comment'),
        defaultServiceId?: long(name='DefaultServiceId'),
        defaultServiceName?: string(name='DefaultServiceName'),
        destinationType?: string(name='DestinationType'),
        directResponse?: {
          body?: string(name='Body'),
          code?: int32(name='Code'),
        }(name='DirectResponse'),
        domainId?: long(name='DomainId'),
        domainIdList?: [ long ](name='DomainIdList'),
        domainName?: string(name='DomainName'),
        domainNameList?: [ string ](name='DomainNameList'),
        enableWaf?: string(name='EnableWaf'),
        fallback?: boolean(name='Fallback'),
        fallbackServices?: [ 
          {
            agreementType?: string(name='AgreementType'),
            groupName?: string(name='GroupName'),
            name?: string(name='Name'),
            namespace?: string(name='Namespace'),
            percent?: int32(name='Percent'),
            serviceId?: long(name='ServiceId'),
            serviceName?: string(name='ServiceName'),
            servicePort?: int32(name='ServicePort'),
            sourceType?: string(name='SourceType'),
            version?: string(name='Version'),
          }
        ](name='FallbackServices'),
        gatewayId?: long(name='GatewayId'),
        gatewayUniqueId?: string(name='GatewayUniqueId'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        id?: long(name='Id'),
        name?: string(name='Name'),
        predicates?: string(name='Predicates'),
        redirect?: {
          code?: int32(name='Code'),
          host?: string(name='Host'),
          path?: string(name='Path'),
        }(name='Redirect'),
        routeOrder?: int32(name='RouteOrder'),
        routePredicates?: {
          headerPredicates?: [ 
            {
              key?: string(name='Key'),
              type?: string(name='Type'),
              value?: string(name='Value'),
            }
          ](name='HeaderPredicates'),
          methodPredicates?: [ string ](name='MethodPredicates'),
          pathPredicates?: {
            ignoreCase?: boolean(name='IgnoreCase'),
            path?: string(name='Path'),
            type?: string(name='Type'),
          }(name='PathPredicates'),
          queryPredicates?: [ 
            {
              key?: string(name='Key'),
              type?: string(name='Type'),
              value?: string(name='Value'),
            }
          ](name='QueryPredicates'),
        }(name='RoutePredicates'),
        routeServices?: [ 
          {
            agreementType?: string(name='AgreementType'),
            groupName?: string(name='GroupName'),
            httpDubboTranscoder?: {
              dubboServiceGroup?: string(name='DubboServiceGroup'),
              dubboServiceName?: string(name='DubboServiceName'),
              dubboServiceVersion?: string(name='DubboServiceVersion'),
              mothedMapList?: [ 
                {
                  dubboMothedName?: string(name='DubboMothedName'),
                  httpMothed?: string(name='HttpMothed'),
                  mothedpath?: string(name='Mothedpath'),
                  paramMapsList?: [ 
                    {
                      extractKey?: string(name='ExtractKey'),
                      extractKeySpec?: string(name='ExtractKeySpec'),
                      mappingType?: string(name='MappingType'),
                    }
                  ](name='ParamMapsList'),
                  passThroughAllHeaders?: string(name='PassThroughAllHeaders'),
                  passThroughList?: [ string ](name='PassThroughList'),
                }
              ](name='MothedMapList'),
            }(name='HttpDubboTranscoder'),
            name?: string(name='Name'),
            namespace?: string(name='Namespace'),
            percent?: int32(name='Percent'),
            serviceId?: long(name='ServiceId'),
            serviceName?: string(name='ServiceName'),
            servicePort?: int32(name='ServicePort'),
            sourceType?: string(name='SourceType'),
            version?: string(name='Version'),
          }
        ](name='RouteServices'),
        services?: string(name='Services'),
        status?: int32(name='Status'),
        type?: string(name='Type'),
      }
    ](name='Result'),
    totalSize?: long(name='TotalSize'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListGatewayRouteResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListGatewayRouteResponseBody(name='body'),
}

async function listGatewayRouteWithOptions(tmpReq: ListGatewayRouteRequest, runtime: Util.RuntimeOptions): ListGatewayRouteResponse {
  Util.validateModel(tmpReq);
  var request = new ListGatewayRouteShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.filterParams)) {
    request.filterParamsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.filterParams, 'FilterParams', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.descSort)) {
    query['DescSort'] = request.descSort;
  }
  if (!Util.isUnset(request.filterParamsShrink)) {
    query['FilterParams'] = request.filterParamsShrink;
  }
  if (!Util.isUnset(request.orderItem)) {
    query['OrderItem'] = request.orderItem;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListGatewayRoute',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listGatewayRoute(request: ListGatewayRouteRequest): ListGatewayRouteResponse {
  var runtime = new Util.RuntimeOptions{};
  return listGatewayRouteWithOptions(request, runtime);
}

model ListGatewayServiceRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  descSort?: boolean(name='DescSort'),
  filterParams?: {
    gatewayUniqueId?: string(name='GatewayUniqueId'),
    groupName?: string(name='GroupName'),
    name?: string(name='Name'),
    namespace?: string(name='Namespace'),
    serviceProtocol?: string(name='ServiceProtocol'),
    sourceType?: string(name='SourceType'),
  }(name='FilterParams'),
  orderItem?: string(name='OrderItem'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListGatewayServiceShrinkRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  descSort?: boolean(name='DescSort'),
  filterParamsShrink?: string(name='FilterParams'),
  orderItem?: string(name='OrderItem'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListGatewayServiceResponseBody = {
  code?: int32(name='Code'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    result?: [ 
      {
        gatewayId?: long(name='GatewayId'),
        gatewayTrafficPolicy?: {
          loadBalancerSettings?: {
            consistentHashLBConfig?: {
              consistentHashLBType?: string(name='ConsistentHashLBType'),
              httpCookie?: {
                name?: string(name='Name'),
                path?: string(name='Path'),
                ttl?: string(name='Ttl'),
              }(name='HttpCookie'),
              minimumRingSize?: long(name='MinimumRingSize'),
              parameterName?: string(name='ParameterName'),
            }(name='ConsistentHashLBConfig'),
            loadbalancerType?: string(name='LoadbalancerType'),
            warmupDuration?: int32(name='WarmupDuration'),
          }(name='LoadBalancerSettings'),
          tls?: {
            caCertContent?: string(name='CaCertContent'),
            caCertId?: string(name='CaCertId'),
            certId?: string(name='CertId'),
            mode?: string(name='Mode'),
            sni?: string(name='Sni'),
            subjectAltNames?: [ string ](name='SubjectAltNames'),
          }(name='Tls'),
        }(name='GatewayTrafficPolicy'),
        gatewayUniqueId?: string(name='GatewayUniqueId'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        groupName?: string(name='GroupName'),
        healehStatus?: string(name='HealehStatus'),
        healthCheck?: boolean(name='HealthCheck'),
        healthCheckInfo?: {
          check?: boolean(name='Check'),
          expectedStatuses?: [ int32 ](name='ExpectedStatuses'),
          healthyThreshold?: int32(name='HealthyThreshold'),
          httpHost?: string(name='HttpHost'),
          httpPath?: string(name='HttpPath'),
          interval?: int32(name='Interval'),
          protocol?: string(name='Protocol'),
          timeout?: int32(name='Timeout'),
          unhealthyThreshold?: int32(name='UnhealthyThreshold'),
        }(name='HealthCheckInfo'),
        healthStatus?: string(name='HealthStatus'),
        id?: long(name='Id'),
        ips?: [ string ](name='Ips'),
        metaInfo?: string(name='MetaInfo'),
        name?: string(name='Name'),
        namespace?: string(name='Namespace'),
        ports?: [ int32 ](name='Ports'),
        serviceNameInRegistry?: string(name='ServiceNameInRegistry'),
        servicePort?: long(name='ServicePort'),
        serviceProtocol?: string(name='ServiceProtocol'),
        sourceId?: long(name='SourceId'),
        sourceType?: string(name='SourceType'),
        unhealthyEndpoints?: [ string ](name='UnhealthyEndpoints'),
        versions?: [ 
          {
            name?: string(name='Name'),
          }
        ](name='Versions'),
      }
    ](name='Result'),
    totalSize?: long(name='TotalSize'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListGatewayServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListGatewayServiceResponseBody(name='body'),
}

async function listGatewayServiceWithOptions(tmpReq: ListGatewayServiceRequest, runtime: Util.RuntimeOptions): ListGatewayServiceResponse {
  Util.validateModel(tmpReq);
  var request = new ListGatewayServiceShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.filterParams)) {
    request.filterParamsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.filterParams, 'FilterParams', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.descSort)) {
    query['DescSort'] = request.descSort;
  }
  if (!Util.isUnset(request.filterParamsShrink)) {
    query['FilterParams'] = request.filterParamsShrink;
  }
  if (!Util.isUnset(request.orderItem)) {
    query['OrderItem'] = request.orderItem;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListGatewayService',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listGatewayService(request: ListGatewayServiceRequest): ListGatewayServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return listGatewayServiceWithOptions(request, runtime);
}

model ListGatewaySlbRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
}

model ListGatewaySlbResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      editEnable?: boolean(name='EditEnable'),
      gatewayId?: string(name='GatewayId'),
      gatewaySlbMode?: string(name='GatewaySlbMode'),
      gatewaySlbStatus?: string(name='GatewaySlbStatus'),
      gmtCreate?: string(name='GmtCreate'),
      httpPort?: int32(name='HttpPort'),
      httpsPort?: int32(name='HttpsPort'),
      httpsVServerGroupId?: string(name='HttpsVServerGroupId'),
      id?: string(name='Id'),
      serviceWeight?: int32(name='ServiceWeight'),
      slbId?: string(name='SlbId'),
      slbIp?: string(name='SlbIp'),
      slbPort?: string(name='SlbPort'),
      statusDesc?: string(name='StatusDesc'),
      type?: string(name='Type'),
      VServerGroupId?: string(name='VServerGroupId'),
    }
  ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListGatewaySlbResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListGatewaySlbResponseBody(name='body'),
}

async function listGatewaySlbWithOptions(request: ListGatewaySlbRequest, runtime: Util.RuntimeOptions): ListGatewaySlbResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListGatewaySlb',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listGatewaySlb(request: ListGatewaySlbRequest): ListGatewaySlbResponse {
  var runtime = new Util.RuntimeOptions{};
  return listGatewaySlbWithOptions(request, runtime);
}

model ListInstanceCountRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterType?: string(name='ClusterType'),
  mseVersion?: string(name='MseVersion'),
  regionId?: string(name='RegionId'),
  requestPars?: string(name='RequestPars'),
}

model ListInstanceCountResponseBody = {
  code?: int32(name='Code'),
  data?: [ int32 ](name='Data'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListInstanceCountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInstanceCountResponseBody(name='body'),
}

async function listInstanceCountWithOptions(request: ListInstanceCountRequest, runtime: Util.RuntimeOptions): ListInstanceCountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clusterType)) {
    query['ClusterType'] = request.clusterType;
  }
  if (!Util.isUnset(request.mseVersion)) {
    query['MseVersion'] = request.mseVersion;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.requestPars)) {
    query['RequestPars'] = request.requestPars;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInstanceCount',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listInstanceCount(request: ListInstanceCountRequest): ListInstanceCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInstanceCountWithOptions(request, runtime);
}

model ListListenersByConfigRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  dataId?: string(name='DataId'),
  group?: string(name='Group'),
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
  requestPars?: string(name='RequestPars'),
}

model ListListenersByConfigResponseBody = {
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  listeners?: [ 
    {
      ip?: string(name='Ip'),
      md5?: string(name='Md5'),
      status?: string(name='Status'),
    }
  ](name='Listeners'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListListenersByConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListListenersByConfigResponseBody(name='body'),
}

async function listListenersByConfigWithOptions(request: ListListenersByConfigRequest, runtime: Util.RuntimeOptions): ListListenersByConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.dataId)) {
    query['DataId'] = request.dataId;
  }
  if (!Util.isUnset(request.group)) {
    query['Group'] = request.group;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  if (!Util.isUnset(request.requestPars)) {
    query['RequestPars'] = request.requestPars;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListListenersByConfig',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listListenersByConfig(request: ListListenersByConfigRequest): ListListenersByConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return listListenersByConfigWithOptions(request, runtime);
}

model ListListenersByIpRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  instanceId?: string(name='InstanceId'),
  ip?: string(name='Ip'),
  namespaceId?: string(name='NamespaceId'),
  requestPars?: string(name='RequestPars'),
}

model ListListenersByIpResponseBody = {
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  listeners?: [ 
    {
      dataId?: string(name='DataId'),
      group?: string(name='Group'),
      md5?: string(name='Md5'),
    }
  ](name='Listeners'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListListenersByIpResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListListenersByIpResponseBody(name='body'),
}

async function listListenersByIpWithOptions(request: ListListenersByIpRequest, runtime: Util.RuntimeOptions): ListListenersByIpResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ip)) {
    query['Ip'] = request.ip;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  if (!Util.isUnset(request.requestPars)) {
    query['RequestPars'] = request.requestPars;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListListenersByIp',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listListenersByIp(request: ListListenersByIpRequest): ListListenersByIpResponse {
  var runtime = new Util.RuntimeOptions{};
  return listListenersByIpWithOptions(request, runtime);
}

model ListNacosConfigsRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  appName?: string(name='AppName'),
  dataId?: string(name='DataId'),
  group?: string(name='Group'),
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  requestPars?: string(name='RequestPars'),
  tags?: string(name='Tags'),
}

model ListNacosConfigsResponseBody = {
  code?: int32(name='Code'),
  configurations?: [ 
    {
      appName?: string(name='AppName'),
      dataId?: string(name='DataId'),
      group?: string(name='Group'),
      id?: string(name='Id'),
    }
  ](name='Configurations'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListNacosConfigsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListNacosConfigsResponseBody(name='body'),
}

async function listNacosConfigsWithOptions(request: ListNacosConfigsRequest, runtime: Util.RuntimeOptions): ListNacosConfigsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.dataId)) {
    query['DataId'] = request.dataId;
  }
  if (!Util.isUnset(request.group)) {
    query['Group'] = request.group;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.requestPars)) {
    query['RequestPars'] = request.requestPars;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListNacosConfigs',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listNacosConfigs(request: ListNacosConfigsRequest): ListNacosConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNacosConfigsWithOptions(request, runtime);
}

model ListNacosHistoryConfigsRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  dataId?: string(name='DataId'),
  group?: string(name='Group'),
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  requestPars?: string(name='RequestPars'),
}

model ListNacosHistoryConfigsResponseBody = {
  errorCode?: string(name='ErrorCode'),
  historyItems?: [ 
    {
      appName?: string(name='AppName'),
      dataId?: string(name='DataId'),
      group?: string(name='Group'),
      id?: long(name='Id'),
      lastModifiedTime?: long(name='LastModifiedTime'),
      opType?: string(name='OpType'),
    }
  ](name='HistoryItems'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListNacosHistoryConfigsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListNacosHistoryConfigsResponseBody(name='body'),
}

async function listNacosHistoryConfigsWithOptions(request: ListNacosHistoryConfigsRequest, runtime: Util.RuntimeOptions): ListNacosHistoryConfigsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.dataId)) {
    query['DataId'] = request.dataId;
  }
  if (!Util.isUnset(request.group)) {
    query['Group'] = request.group;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.requestPars)) {
    query['RequestPars'] = request.requestPars;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListNacosHistoryConfigs',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listNacosHistoryConfigs(request: ListNacosHistoryConfigsRequest): ListNacosHistoryConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNacosHistoryConfigsWithOptions(request, runtime);
}

model ListSSLCertRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
}

model ListSSLCertResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      afterDate?: string(name='AfterDate'),
      algorithm?: string(name='Algorithm'),
      beforeDate?: string(name='BeforeDate'),
      certIdentifier?: string(name='CertIdentifier'),
      certName?: string(name='CertName'),
      commonName?: string(name='CommonName'),
      gmtAfter?: string(name='GmtAfter'),
      gmtBefore?: string(name='GmtBefore'),
      issuer?: string(name='Issuer'),
      sans?: string(name='Sans'),
    }
  ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListSSLCertResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSSLCertResponseBody(name='body'),
}

async function listSSLCertWithOptions(request: ListSSLCertRequest, runtime: Util.RuntimeOptions): ListSSLCertResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSSLCert',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSSLCert(request: ListSSLCertRequest): ListSSLCertResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSSLCertWithOptions(request, runtime);
}

model ListSecurityGroupRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
}

model ListSecurityGroupResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      securityGroupId?: string(name='SecurityGroupId'),
      securityGroupName?: string(name='SecurityGroupName'),
      securityGroupType?: string(name='SecurityGroupType'),
      vpcId?: string(name='VpcId'),
    }
  ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListSecurityGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSecurityGroupResponseBody(name='body'),
}

async function listSecurityGroupWithOptions(request: ListSecurityGroupRequest, runtime: Util.RuntimeOptions): ListSecurityGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSecurityGroup',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSecurityGroup(request: ListSecurityGroupRequest): ListSecurityGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSecurityGroupWithOptions(request, runtime);
}

model ListSecurityGroupRuleRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
}

model ListSecurityGroupRuleResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      description?: string(name='Description'),
      gatewayId?: long(name='GatewayId'),
      gatewayUniqueId?: string(name='GatewayUniqueId'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      id?: string(name='Id'),
      ipProtocol?: string(name='IpProtocol'),
      portRange?: string(name='PortRange'),
      securityGroupId?: string(name='SecurityGroupId'),
    }
  ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListSecurityGroupRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSecurityGroupRuleResponseBody(name='body'),
}

async function listSecurityGroupRuleWithOptions(request: ListSecurityGroupRuleRequest, runtime: Util.RuntimeOptions): ListSecurityGroupRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSecurityGroupRule',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSecurityGroupRule(request: ListSecurityGroupRuleRequest): ListSecurityGroupRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSecurityGroupRuleWithOptions(request, runtime);
}

model ListServiceSourceRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
}

model ListServiceSourceResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      address?: string(name='Address'),
      bindingWithGateway?: int32(name='BindingWithGateway'),
      gatewayId?: long(name='GatewayId'),
      gatewayUniqueId?: string(name='GatewayUniqueId'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      groupList?: [ string ](name='GroupList'),
      id?: long(name='Id'),
      ingressOptions?: {
        enableIngress?: boolean(name='EnableIngress'),
        enableStatus?: boolean(name='EnableStatus'),
        ingressClass?: string(name='IngressClass'),
        watchNamespace?: string(name='WatchNamespace'),
      }(name='IngressOptions'),
      name?: string(name='Name'),
      pathList?: [ string ](name='PathList'),
      source?: string(name='Source'),
      sourceUniqueId?: string(name='SourceUniqueId'),
      type?: string(name='Type'),
    }
  ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListServiceSourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListServiceSourceResponseBody(name='body'),
}

async function listServiceSourceWithOptions(request: ListServiceSourceRequest, runtime: Util.RuntimeOptions): ListServiceSourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListServiceSource',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listServiceSource(request: ListServiceSourceRequest): ListServiceSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return listServiceSourceWithOptions(request, runtime);
}

model ListTagResourcesRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  resourceId?: [ string ](name='ResourceId'),
  resourceType?: string(name='ResourceType'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model ListTagResourcesResponseBody = {
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  tagResources?: {
    tagResource?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='TagResource')
  }(name='TagResources'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagResources',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagResourcesWithOptions(request, runtime);
}

model ListZnodeChildrenRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterId?: string(name='ClusterId'),
  path?: string(name='Path'),
}

model ListZnodeChildrenResponseBody = {
  data?: [ 
    {
      data?: string(name='Data'),
      dir?: boolean(name='Dir'),
      name?: string(name='Name'),
      path?: string(name='Path'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListZnodeChildrenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListZnodeChildrenResponseBody(name='body'),
}

async function listZnodeChildrenWithOptions(request: ListZnodeChildrenRequest, runtime: Util.RuntimeOptions): ListZnodeChildrenResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListZnodeChildren',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listZnodeChildren(request: ListZnodeChildrenRequest): ListZnodeChildrenResponse {
  var runtime = new Util.RuntimeOptions{};
  return listZnodeChildrenWithOptions(request, runtime);
}

model ModifyGovernanceKubernetesClusterRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterId?: string(name='ClusterId'),
  namespaceInfos?: string(name='NamespaceInfos'),
  regionId?: string(name='RegionId'),
}

model ModifyGovernanceKubernetesClusterResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ModifyGovernanceKubernetesClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyGovernanceKubernetesClusterResponseBody(name='body'),
}

async function modifyGovernanceKubernetesClusterWithOptions(request: ModifyGovernanceKubernetesClusterRequest, runtime: Util.RuntimeOptions): ModifyGovernanceKubernetesClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.namespaceInfos)) {
    query['NamespaceInfos'] = request.namespaceInfos;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyGovernanceKubernetesCluster',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyGovernanceKubernetesCluster(request: ModifyGovernanceKubernetesClusterRequest): ModifyGovernanceKubernetesClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyGovernanceKubernetesClusterWithOptions(request, runtime);
}

model ModifyLosslessRuleRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  aligned?: boolean(name='Aligned'),
  appId?: string(name='AppId'),
  appName?: string(name='AppName'),
  delayTime?: long(name='DelayTime'),
  enable?: boolean(name='Enable'),
  funcType?: long(name='FuncType'),
  regionId?: string(name='RegionId'),
  related?: boolean(name='Related'),
  shutdownWaitSeconds?: int32(name='ShutdownWaitSeconds'),
  source?: string(name='Source'),
  warmupTime?: long(name='WarmupTime'),
}

model ModifyLosslessRuleResponseBody = {
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ModifyLosslessRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyLosslessRuleResponseBody(name='body'),
}

async function modifyLosslessRuleWithOptions(request: ModifyLosslessRuleRequest, runtime: Util.RuntimeOptions): ModifyLosslessRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.aligned)) {
    query['Aligned'] = request.aligned;
  }
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.delayTime)) {
    query['DelayTime'] = request.delayTime;
  }
  if (!Util.isUnset(request.enable)) {
    query['Enable'] = request.enable;
  }
  if (!Util.isUnset(request.funcType)) {
    query['FuncType'] = request.funcType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.related)) {
    query['Related'] = request.related;
  }
  if (!Util.isUnset(request.shutdownWaitSeconds)) {
    query['ShutdownWaitSeconds'] = request.shutdownWaitSeconds;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.warmupTime)) {
    query['WarmupTime'] = request.warmupTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyLosslessRule',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyLosslessRule(request: ModifyLosslessRuleRequest): ModifyLosslessRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyLosslessRuleWithOptions(request, runtime);
}

model OfflineGatewayRouteRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  routeId?: string(name='RouteId'),
}

model OfflineGatewayRouteResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model OfflineGatewayRouteResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OfflineGatewayRouteResponseBody(name='body'),
}

async function offlineGatewayRouteWithOptions(request: OfflineGatewayRouteRequest, runtime: Util.RuntimeOptions): OfflineGatewayRouteResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.routeId)) {
    query['RouteId'] = request.routeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OfflineGatewayRoute',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function offlineGatewayRoute(request: OfflineGatewayRouteRequest): OfflineGatewayRouteResponse {
  var runtime = new Util.RuntimeOptions{};
  return offlineGatewayRouteWithOptions(request, runtime);
}

model PullServicesRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  namespace?: string(name='Namespace'),
  sourceType?: string(name='SourceType'),
}

model PullServicesResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      groupName?: string(name='GroupName'),
      namespace?: string(name='Namespace'),
      namespaceShowName?: string(name='NamespaceShowName'),
      services?: [ 
        {
          groupName?: string(name='GroupName'),
          name?: string(name='Name'),
          namespace?: string(name='Namespace'),
          sourceId?: string(name='SourceId'),
          sourceType?: string(name='SourceType'),
        }
      ](name='Services'),
    }
  ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PullServicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PullServicesResponseBody(name='body'),
}

async function pullServicesWithOptions(request: PullServicesRequest, runtime: Util.RuntimeOptions): PullServicesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PullServices',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function pullServices(request: PullServicesRequest): PullServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return pullServicesWithOptions(request, runtime);
}

model QueryAllSwimmingLaneRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  groupId?: long(name='GroupId'),
}

model QueryAllSwimmingLaneResponseBody = {
  code?: int32(name='Code'),
  data?: any(name='Data'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryAllSwimmingLaneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryAllSwimmingLaneResponseBody(name='body'),
}

async function queryAllSwimmingLaneWithOptions(request: QueryAllSwimmingLaneRequest, runtime: Util.RuntimeOptions): QueryAllSwimmingLaneResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryAllSwimmingLane',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryAllSwimmingLane(request: QueryAllSwimmingLaneRequest): QueryAllSwimmingLaneResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryAllSwimmingLaneWithOptions(request, runtime);
}

model QueryAllSwimmingLaneGroupRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
}

model QueryAllSwimmingLaneGroupResponseBody = {
  code?: int32(name='Code'),
  data?: any(name='Data'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryAllSwimmingLaneGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryAllSwimmingLaneGroupResponseBody(name='body'),
}

async function queryAllSwimmingLaneGroupWithOptions(request: QueryAllSwimmingLaneGroupRequest, runtime: Util.RuntimeOptions): QueryAllSwimmingLaneGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryAllSwimmingLaneGroup',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryAllSwimmingLaneGroup(request: QueryAllSwimmingLaneGroupRequest): QueryAllSwimmingLaneGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryAllSwimmingLaneGroupWithOptions(request, runtime);
}

model QueryBusinessLocationsRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
}

model QueryBusinessLocationsResponseBody = {
  data?: [ 
    {
      cnName?: string(name='CnName'),
      description?: string(name='Description'),
      districtCnName?: string(name='DistrictCnName'),
      districtEnName?: string(name='DistrictEnName'),
      districtId?: string(name='DistrictId'),
      districtOrdering?: int32(name='DistrictOrdering'),
      districtShowName?: string(name='DistrictShowName'),
      enDescription?: string(name='EnDescription'),
      enName?: string(name='EnName'),
      name?: string(name='Name'),
      ordering?: int32(name='Ordering'),
      showName?: string(name='ShowName'),
      type?: string(name='Type'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model QueryBusinessLocationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryBusinessLocationsResponseBody(name='body'),
}

async function queryBusinessLocationsWithOptions(request: QueryBusinessLocationsRequest, runtime: Util.RuntimeOptions): QueryBusinessLocationsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryBusinessLocations',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryBusinessLocations(request: QueryBusinessLocationsRequest): QueryBusinessLocationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryBusinessLocationsWithOptions(request, runtime);
}

model QueryClusterDetailRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  aclSwitch?: boolean(name='AclSwitch'),
  instanceId?: string(name='InstanceId'),
  orderId?: string(name='OrderId'),
}

model QueryClusterDetailResponseBody = {
  data?: {
    aclEntryList?: string(name='AclEntryList'),
    aclId?: string(name='AclId'),
    appVersion?: string(name='AppVersion'),
    chargeType?: string(name='ChargeType'),
    clusterAliasName?: string(name='ClusterAliasName'),
    clusterName?: string(name='ClusterName'),
    clusterSpecification?: string(name='ClusterSpecification'),
    clusterType?: string(name='ClusterType'),
    clusterVersion?: string(name='ClusterVersion'),
    connectionType?: string(name='ConnectionType'),
    cpu?: int32(name='Cpu'),
    createTime?: string(name='CreateTime'),
    diskCapacity?: long(name='DiskCapacity'),
    diskType?: string(name='DiskType'),
    healthStatus?: string(name='HealthStatus'),
    initCostTime?: long(name='InitCostTime'),
    initStatus?: string(name='InitStatus'),
    instanceCount?: int32(name='InstanceCount'),
    instanceId?: string(name='InstanceId'),
    instanceModels?: [ 
      {
        creationTimestamp?: string(name='CreationTimestamp'),
        healthStatus?: string(name='HealthStatus'),
        internetIp?: string(name='InternetIp'),
        ip?: string(name='Ip'),
        podName?: string(name='PodName'),
        role?: string(name='Role'),
        singleTunnelVip?: string(name='SingleTunnelVip'),
        zone?: string(name='Zone'),
      }
    ](name='InstanceModels'),
    internetAddress?: string(name='InternetAddress'),
    internetDomain?: string(name='InternetDomain'),
    internetPort?: string(name='InternetPort'),
    intranetAddress?: string(name='IntranetAddress'),
    intranetDomain?: string(name='IntranetDomain'),
    intranetPort?: string(name='IntranetPort'),
    memoryCapacity?: long(name='MemoryCapacity'),
    mseVersion?: string(name='MseVersion'),
    netType?: string(name='NetType'),
    orderClusterVersion?: string(name='OrderClusterVersion'),
    payInfo?: string(name='PayInfo'),
    pubNetworkFlow?: string(name='PubNetworkFlow'),
    regionId?: string(name='RegionId'),
    resourceGroupId?: string(name='ResourceGroupId'),
    tags?: map[string]any(name='Tags'),
    vSwitchId?: string(name='VSwitchId'),
    vpcId?: string(name='VpcId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryClusterDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryClusterDetailResponseBody(name='body'),
}

async function queryClusterDetailWithOptions(request: QueryClusterDetailRequest, runtime: Util.RuntimeOptions): QueryClusterDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.aclSwitch)) {
    query['AclSwitch'] = request.aclSwitch;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryClusterDetail',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryClusterDetail(request: QueryClusterDetailRequest): QueryClusterDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryClusterDetailWithOptions(request, runtime);
}

model QueryClusterDiskSpecificationRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterType?: string(name='ClusterType'),
}

model QueryClusterDiskSpecificationResponseBody = {
  code?: int32(name='Code'),
  data?: {
    max?: int32(name='Max'),
    min?: int32(name='Min'),
    step?: int32(name='Step'),
  }(name='Data'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryClusterDiskSpecificationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryClusterDiskSpecificationResponseBody(name='body'),
}

async function queryClusterDiskSpecificationWithOptions(request: QueryClusterDiskSpecificationRequest, runtime: Util.RuntimeOptions): QueryClusterDiskSpecificationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clusterType)) {
    query['ClusterType'] = request.clusterType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryClusterDiskSpecification',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryClusterDiskSpecification(request: QueryClusterDiskSpecificationRequest): QueryClusterDiskSpecificationResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryClusterDiskSpecificationWithOptions(request, runtime);
}

model QueryClusterSpecificationRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  connectType?: string(name='ConnectType'),
  mseVersion?: string(name='MseVersion'),
}

model QueryClusterSpecificationResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      clusterSpecificationName?: string(name='ClusterSpecificationName'),
      cpuCapacity?: string(name='CpuCapacity'),
      diskCapacity?: string(name='DiskCapacity'),
      instanceCount?: string(name='InstanceCount'),
      maxCon?: string(name='MaxCon'),
      maxTps?: string(name='MaxTps'),
      memoryCapacity?: string(name='MemoryCapacity'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryClusterSpecificationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryClusterSpecificationResponseBody(name='body'),
}

async function queryClusterSpecificationWithOptions(request: QueryClusterSpecificationRequest, runtime: Util.RuntimeOptions): QueryClusterSpecificationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.connectType)) {
    query['ConnectType'] = request.connectType;
  }
  if (!Util.isUnset(request.mseVersion)) {
    query['MseVersion'] = request.mseVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryClusterSpecification',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryClusterSpecification(request: QueryClusterSpecificationRequest): QueryClusterSpecificationResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryClusterSpecificationWithOptions(request, runtime);
}

model QueryConfigRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterId?: string(name='ClusterId'),
  configType?: string(name='ConfigType'),
  instanceId?: string(name='InstanceId'),
  requestPars?: string(name='RequestPars'),
}

model QueryConfigResponseBody = {
  code?: int32(name='Code'),
  data?: {
    autopurgePurgeInterval?: string(name='AutopurgePurgeInterval'),
    autopurgeSnapRetainCount?: string(name='AutopurgeSnapRetainCount'),
    clusterName?: string(name='ClusterName'),
    configAuthEnabled?: boolean(name='ConfigAuthEnabled'),
    configAuthSupported?: boolean(name='ConfigAuthSupported'),
    configSecretEnabled?: boolean(name='ConfigSecretEnabled'),
    configSecretSupported?: boolean(name='ConfigSecretSupported'),
    initLimit?: string(name='InitLimit'),
    juteMaxbuffer?: string(name='JuteMaxbuffer'),
    jvmFlagsCustom?: string(name='JvmFlagsCustom'),
    MCPEnabled?: boolean(name='MCPEnabled'),
    MCPSupported?: boolean(name='MCPSupported'),
    maxClientCnxns?: string(name='MaxClientCnxns'),
    maxSessionTimeout?: string(name='MaxSessionTimeout'),
    minSessionTimeout?: string(name='MinSessionTimeout'),
    namingAuthEnabled?: boolean(name='NamingAuthEnabled'),
    namingAuthSupported?: boolean(name='NamingAuthSupported'),
    namingCreateServiceSupported?: boolean(name='NamingCreateServiceSupported'),
    openSuperAcl?: boolean(name='OpenSuperAcl'),
    passWord?: string(name='PassWord'),
    restartFlag?: boolean(name='RestartFlag'),
    snapshotCount?: string(name='SnapshotCount'),
    syncLimit?: string(name='SyncLimit'),
    tickTime?: string(name='TickTime'),
    userName?: string(name='UserName'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryConfigResponseBody(name='body'),
}

async function queryConfigWithOptions(request: QueryConfigRequest, runtime: Util.RuntimeOptions): QueryConfigResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryConfig',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryConfig(request: QueryConfigRequest): QueryConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryConfigWithOptions(request, runtime);
}

model QueryGatewayRegionRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
}

model QueryGatewayRegionResponseBody = {
  code?: int32(name='Code'),
  data?: [ string ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryGatewayRegionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryGatewayRegionResponseBody(name='body'),
}

async function queryGatewayRegionWithOptions(request: QueryGatewayRegionRequest, runtime: Util.RuntimeOptions): QueryGatewayRegionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryGatewayRegion',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryGatewayRegion(request: QueryGatewayRegionRequest): QueryGatewayRegionResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryGatewayRegionWithOptions(request, runtime);
}

model QueryGatewayTypeRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
}

model QueryGatewayTypeResponseBody = {
  code?: int32(name='Code'),
  data?: [ string ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryGatewayTypeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryGatewayTypeResponseBody(name='body'),
}

async function queryGatewayTypeWithOptions(request: QueryGatewayTypeRequest, runtime: Util.RuntimeOptions): QueryGatewayTypeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryGatewayType',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryGatewayType(request: QueryGatewayTypeRequest): QueryGatewayTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryGatewayTypeWithOptions(request, runtime);
}

model QueryGovernanceKubernetesClusterRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterId?: string(name='ClusterId'),
  clusterName?: string(name='ClusterName'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model QueryGovernanceKubernetesClusterResponseBody = {
  code?: int32(name='Code'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    result?: [ 
      {
        clusterId?: string(name='ClusterId'),
        clusterName?: string(name='ClusterName'),
        k8sVersion?: string(name='K8sVersion'),
        namespaceInfos?: string(name='NamespaceInfos'),
        pilotStartTime?: string(name='PilotStartTime'),
        region?: string(name='Region'),
      }
    ](name='Result'),
    totalSize?: int32(name='TotalSize'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryGovernanceKubernetesClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryGovernanceKubernetesClusterResponseBody(name='body'),
}

async function queryGovernanceKubernetesClusterWithOptions(request: QueryGovernanceKubernetesClusterRequest, runtime: Util.RuntimeOptions): QueryGovernanceKubernetesClusterResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryGovernanceKubernetesCluster',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryGovernanceKubernetesCluster(request: QueryGovernanceKubernetesClusterRequest): QueryGovernanceKubernetesClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryGovernanceKubernetesClusterWithOptions(request, runtime);
}

model QueryMonitorRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  endTime?: long(name='EndTime'),
  instanceId?: string(name='InstanceId'),
  monitorType?: string(name='MonitorType'),
  requestPars?: string(name='RequestPars'),
  startTime?: long(name='StartTime'),
  step?: long(name='Step'),
}

model QueryMonitorResponseBody = {
  data?: [ 
    {
      clusterNamePrefix?: string(name='clusterNamePrefix'),
      podName?: string(name='podName'),
      values?: [  map[string]any ](name='values'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryMonitorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryMonitorResponseBody(name='body'),
}

async function queryMonitorWithOptions(request: QueryMonitorRequest, runtime: Util.RuntimeOptions): QueryMonitorResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryMonitor',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryMonitor(request: QueryMonitorRequest): QueryMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMonitorWithOptions(request, runtime);
}

model QuerySlbSpecRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
}

model QuerySlbSpecResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      id?: int32(name='Id'),
      maxConnection?: string(name='MaxConnection'),
      name?: string(name='Name'),
      newConnectionPerSecond?: string(name='NewConnectionPerSecond'),
      qps?: string(name='Qps'),
      spec?: string(name='Spec'),
    }
  ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QuerySlbSpecResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QuerySlbSpecResponseBody(name='body'),
}

async function querySlbSpecWithOptions(request: QuerySlbSpecRequest, runtime: Util.RuntimeOptions): QuerySlbSpecResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QuerySlbSpec',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function querySlbSpec(request: QuerySlbSpecRequest): QuerySlbSpecResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySlbSpecWithOptions(request, runtime);
}

model QuerySwimmingLaneByIdRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  laneId?: long(name='LaneId'),
}

model QuerySwimmingLaneByIdResponseBody = {
  code?: int32(name='Code'),
  data?: any(name='Data'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QuerySwimmingLaneByIdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QuerySwimmingLaneByIdResponseBody(name='body'),
}

async function querySwimmingLaneByIdWithOptions(request: QuerySwimmingLaneByIdRequest, runtime: Util.RuntimeOptions): QuerySwimmingLaneByIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.laneId)) {
    query['LaneId'] = request.laneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QuerySwimmingLaneById',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function querySwimmingLaneById(request: QuerySwimmingLaneByIdRequest): QuerySwimmingLaneByIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySwimmingLaneByIdWithOptions(request, runtime);
}

model QueryZnodeDetailRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterId?: string(name='ClusterId'),
  instanceId?: string(name='InstanceId'),
  path?: string(name='Path'),
  requestPars?: string(name='RequestPars'),
}

model QueryZnodeDetailResponseBody = {
  data?: {
    data?: string(name='Data'),
    dir?: boolean(name='Dir'),
    name?: string(name='Name'),
    path?: string(name='Path'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model QueryZnodeDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryZnodeDetailResponseBody(name='body'),
}

async function queryZnodeDetailWithOptions(request: QueryZnodeDetailRequest, runtime: Util.RuntimeOptions): QueryZnodeDetailResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryZnodeDetail',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryZnodeDetail(request: QueryZnodeDetailRequest): QueryZnodeDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryZnodeDetailWithOptions(request, runtime);
}

model RestartClusterRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterId?: string(name='ClusterId'),
  instanceId?: string(name='InstanceId'),
  podNameList?: string(name='PodNameList'),
  requestPars?: string(name='RequestPars'),
}

model RestartClusterResponseBody = {
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RestartClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RestartClusterResponseBody(name='body'),
}

async function restartClusterWithOptions(request: RestartClusterRequest, runtime: Util.RuntimeOptions): RestartClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.podNameList)) {
    query['PodNameList'] = request.podNameList;
  }
  if (!Util.isUnset(request.requestPars)) {
    query['RequestPars'] = request.requestPars;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RestartCluster',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function restartCluster(request: RestartClusterRequest): RestartClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return restartClusterWithOptions(request, runtime);
}

model RetryClusterRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  instanceId?: string(name='InstanceId'),
  requestPars?: string(name='RequestPars'),
}

model RetryClusterResponseBody = {
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RetryClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RetryClusterResponseBody(name='body'),
}

async function retryClusterWithOptions(request: RetryClusterRequest, runtime: Util.RuntimeOptions): RetryClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.requestPars)) {
    query['RequestPars'] = request.requestPars;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RetryCluster',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function retryCluster(request: RetryClusterRequest): RetryClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return retryClusterWithOptions(request, runtime);
}

model SelectGatewaySlbRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  name?: string(name='Name'),
  type?: string(name='Type'),
}

model SelectGatewaySlbResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      slbId?: string(name='SlbId'),
      slbName?: string(name='SlbName'),
    }
  ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SelectGatewaySlbResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SelectGatewaySlbResponseBody(name='body'),
}

async function selectGatewaySlbWithOptions(request: SelectGatewaySlbRequest, runtime: Util.RuntimeOptions): SelectGatewaySlbResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SelectGatewaySlb',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function selectGatewaySlb(request: SelectGatewaySlbRequest): SelectGatewaySlbResponse {
  var runtime = new Util.RuntimeOptions{};
  return selectGatewaySlbWithOptions(request, runtime);
}

model TagResourcesRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  regionId?: string(name='RegionId'),
  resourceId?: [ string ](name='ResourceId'),
  resourceType?: string(name='ResourceType'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model TagResourcesResponseBody = {
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResourcesWithOptions(request: TagResourcesRequest, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TagResources',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagResourcesWithOptions(request, runtime);
}

model UntagResourcesRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  all?: boolean(name='All'),
  regionId?: string(name='RegionId'),
  resourceId?: [ string ](name='ResourceId'),
  resourceType?: string(name='ResourceType'),
  tagKey?: [ string ](name='TagKey'),
}

model UntagResourcesResponseBody = {
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResourcesWithOptions(request: UntagResourcesRequest, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.all)) {
    query['All'] = request.all;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagKey)) {
    query['TagKey'] = request.tagKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UntagResources',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return untagResourcesWithOptions(request, runtime);
}

model UpdateAclRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  aclEntryList?: string(name='AclEntryList'),
  instanceId?: string(name='InstanceId'),
}

model UpdateAclResponseBody = {
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateAclResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAclResponseBody(name='body'),
}

async function updateAclWithOptions(request: UpdateAclRequest, runtime: Util.RuntimeOptions): UpdateAclResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.aclEntryList)) {
    query['AclEntryList'] = request.aclEntryList;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAcl',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAcl(request: UpdateAclRequest): UpdateAclResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAclWithOptions(request, runtime);
}

model UpdateBlackWhiteListRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  content?: string(name='Content'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  id?: long(name='Id'),
  isWhite?: boolean(name='IsWhite'),
  name?: string(name='Name'),
  note?: string(name='Note'),
  resourceIdJsonList?: string(name='ResourceIdJsonList'),
  resourceType?: string(name='ResourceType'),
  status?: string(name='Status'),
  type?: string(name='Type'),
}

model UpdateBlackWhiteListResponseBody = {
  code?: int32(name='Code'),
  data?: long(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateBlackWhiteListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateBlackWhiteListResponseBody(name='body'),
}

async function updateBlackWhiteListWithOptions(request: UpdateBlackWhiteListRequest, runtime: Util.RuntimeOptions): UpdateBlackWhiteListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.content)) {
    query['Content'] = request.content;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.isWhite)) {
    query['IsWhite'] = request.isWhite;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.note)) {
    query['Note'] = request.note;
  }
  if (!Util.isUnset(request.resourceIdJsonList)) {
    query['ResourceIdJsonList'] = request.resourceIdJsonList;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateBlackWhiteList',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateBlackWhiteList(request: UpdateBlackWhiteListRequest): UpdateBlackWhiteListResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateBlackWhiteListWithOptions(request, runtime);
}

model UpdateClusterRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterAliasName?: string(name='ClusterAliasName'),
  instanceId?: string(name='InstanceId'),
  requestPars?: string(name='RequestPars'),
}

model UpdateClusterResponseBody = {
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: string(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateClusterResponseBody(name='body'),
}

async function updateClusterWithOptions(request: UpdateClusterRequest, runtime: Util.RuntimeOptions): UpdateClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clusterAliasName)) {
    query['ClusterAliasName'] = request.clusterAliasName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.requestPars)) {
    query['RequestPars'] = request.requestPars;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateCluster',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateCluster(request: UpdateClusterRequest): UpdateClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateClusterWithOptions(request, runtime);
}

model UpdateClusterSpecRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterId?: string(name='ClusterId'),
  clusterSpecification?: string(name='ClusterSpecification'),
  instanceCount?: int32(name='InstanceCount'),
  instanceId?: string(name='InstanceId'),
}

model UpdateClusterSpecResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateClusterSpecResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateClusterSpecResponseBody(name='body'),
}

async function updateClusterSpecWithOptions(request: UpdateClusterSpecRequest, runtime: Util.RuntimeOptions): UpdateClusterSpecResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.clusterSpecification)) {
    query['ClusterSpecification'] = request.clusterSpecification;
  }
  if (!Util.isUnset(request.instanceCount)) {
    query['InstanceCount'] = request.instanceCount;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateClusterSpec',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateClusterSpec(request: UpdateClusterSpecRequest): UpdateClusterSpecResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateClusterSpecWithOptions(request, runtime);
}

model UpdateConfigRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  autopurgePurgeInterval?: string(name='AutopurgePurgeInterval'),
  autopurgeSnapRetainCount?: string(name='AutopurgeSnapRetainCount'),
  clusterId?: string(name='ClusterId'),
  configAuthEnabled?: boolean(name='ConfigAuthEnabled'),
  configSecretEnabled?: boolean(name='ConfigSecretEnabled'),
  configType?: string(name='ConfigType'),
  initLimit?: string(name='InitLimit'),
  instanceId?: string(name='InstanceId'),
  juteMaxbuffer?: string(name='JuteMaxbuffer'),
  MCPEnabled?: boolean(name='MCPEnabled'),
  maxClientCnxns?: string(name='MaxClientCnxns'),
  maxSessionTimeout?: string(name='MaxSessionTimeout'),
  minSessionTimeout?: string(name='MinSessionTimeout'),
  namingAuthEnabled?: boolean(name='NamingAuthEnabled'),
  openSuperAcl?: string(name='OpenSuperAcl'),
  passWord?: string(name='PassWord'),
  requestPars?: string(name='RequestPars'),
  snapshotCount?: string(name='SnapshotCount'),
  syncLimit?: string(name='SyncLimit'),
  tickTime?: string(name='TickTime'),
  userName?: string(name='UserName'),
}

model UpdateConfigResponseBody = {
  code?: int32(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateConfigResponseBody(name='body'),
}

async function updateConfigWithOptions(request: UpdateConfigRequest, runtime: Util.RuntimeOptions): UpdateConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.autopurgePurgeInterval)) {
    query['AutopurgePurgeInterval'] = request.autopurgePurgeInterval;
  }
  if (!Util.isUnset(request.autopurgeSnapRetainCount)) {
    query['AutopurgeSnapRetainCount'] = request.autopurgeSnapRetainCount;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.configAuthEnabled)) {
    query['ConfigAuthEnabled'] = request.configAuthEnabled;
  }
  if (!Util.isUnset(request.configSecretEnabled)) {
    query['ConfigSecretEnabled'] = request.configSecretEnabled;
  }
  if (!Util.isUnset(request.configType)) {
    query['ConfigType'] = request.configType;
  }
  if (!Util.isUnset(request.initLimit)) {
    query['InitLimit'] = request.initLimit;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.juteMaxbuffer)) {
    query['JuteMaxbuffer'] = request.juteMaxbuffer;
  }
  if (!Util.isUnset(request.MCPEnabled)) {
    query['MCPEnabled'] = request.MCPEnabled;
  }
  if (!Util.isUnset(request.maxClientCnxns)) {
    query['MaxClientCnxns'] = request.maxClientCnxns;
  }
  if (!Util.isUnset(request.maxSessionTimeout)) {
    query['MaxSessionTimeout'] = request.maxSessionTimeout;
  }
  if (!Util.isUnset(request.minSessionTimeout)) {
    query['MinSessionTimeout'] = request.minSessionTimeout;
  }
  if (!Util.isUnset(request.namingAuthEnabled)) {
    query['NamingAuthEnabled'] = request.namingAuthEnabled;
  }
  if (!Util.isUnset(request.passWord)) {
    query['PassWord'] = request.passWord;
  }
  if (!Util.isUnset(request.requestPars)) {
    query['RequestPars'] = request.requestPars;
  }
  if (!Util.isUnset(request.snapshotCount)) {
    query['SnapshotCount'] = request.snapshotCount;
  }
  if (!Util.isUnset(request.syncLimit)) {
    query['SyncLimit'] = request.syncLimit;
  }
  if (!Util.isUnset(request.tickTime)) {
    query['TickTime'] = request.tickTime;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.openSuperAcl)) {
    body['OpenSuperAcl'] = request.openSuperAcl;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateConfig',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateConfig(request: UpdateConfigRequest): UpdateConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateConfigWithOptions(request, runtime);
}

model UpdateEngineNamespaceRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterId?: string(name='ClusterId'),
  desc?: string(name='Desc'),
  id?: string(name='Id'),
  instanceId?: string(name='InstanceId'),
  name?: string(name='Name'),
  serviceCount?: int32(name='ServiceCount'),
}

model UpdateEngineNamespaceResponseBody = {
  data?: {
    configCount?: int32(name='ConfigCount'),
    namespace?: string(name='Namespace'),
    namespaceDesc?: string(name='NamespaceDesc'),
    namespaceShowName?: string(name='NamespaceShowName'),
    quota?: int32(name='Quota'),
    type?: int32(name='Type'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateEngineNamespaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateEngineNamespaceResponseBody(name='body'),
}

async function updateEngineNamespaceWithOptions(request: UpdateEngineNamespaceRequest, runtime: Util.RuntimeOptions): UpdateEngineNamespaceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.desc)) {
    query['Desc'] = request.desc;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.serviceCount)) {
    query['ServiceCount'] = request.serviceCount;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateEngineNamespace',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateEngineNamespace(request: UpdateEngineNamespaceRequest): UpdateEngineNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateEngineNamespaceWithOptions(request, runtime);
}

model UpdateGatewayDomainRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  certIdentifier?: string(name='CertIdentifier'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  http2?: string(name='Http2'),
  id?: long(name='Id'),
  mustHttps?: boolean(name='MustHttps'),
  protocol?: string(name='Protocol'),
  tlsMax?: string(name='TlsMax'),
  tlsMin?: string(name='TlsMin'),
}

model UpdateGatewayDomainResponseBody = {
  code?: int32(name='Code'),
  data?: long(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateGatewayDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateGatewayDomainResponseBody(name='body'),
}

async function updateGatewayDomainWithOptions(request: UpdateGatewayDomainRequest, runtime: Util.RuntimeOptions): UpdateGatewayDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.certIdentifier)) {
    query['CertIdentifier'] = request.certIdentifier;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.http2)) {
    query['Http2'] = request.http2;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.mustHttps)) {
    query['MustHttps'] = request.mustHttps;
  }
  if (!Util.isUnset(request.protocol)) {
    query['Protocol'] = request.protocol;
  }
  if (!Util.isUnset(request.tlsMax)) {
    query['TlsMax'] = request.tlsMax;
  }
  if (!Util.isUnset(request.tlsMin)) {
    query['TlsMin'] = request.tlsMin;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateGatewayDomain',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateGatewayDomain(request: UpdateGatewayDomainRequest): UpdateGatewayDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateGatewayDomainWithOptions(request, runtime);
}

model UpdateGatewayNameRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  name?: string(name='Name'),
}

model UpdateGatewayNameResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateGatewayNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateGatewayNameResponseBody(name='body'),
}

async function updateGatewayNameWithOptions(request: UpdateGatewayNameRequest, runtime: Util.RuntimeOptions): UpdateGatewayNameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateGatewayName',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateGatewayName(request: UpdateGatewayNameRequest): UpdateGatewayNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateGatewayNameWithOptions(request, runtime);
}

model UpdateGatewayOptionRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayId?: long(name='GatewayId'),
  gatewayOption?: GatewayOption(name='GatewayOption'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
}

model UpdateGatewayOptionShrinkRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayId?: long(name='GatewayId'),
  gatewayOptionShrink?: string(name='GatewayOption'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
}

model UpdateGatewayOptionResponseBody = {
  code?: int32(name='Code'),
  data?: GatewayOption(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateGatewayOptionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateGatewayOptionResponseBody(name='body'),
}

async function updateGatewayOptionWithOptions(tmpReq: UpdateGatewayOptionRequest, runtime: Util.RuntimeOptions): UpdateGatewayOptionResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateGatewayOptionShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.gatewayOption)) {
    request.gatewayOptionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.gatewayOption, 'GatewayOption', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.gatewayId)) {
    query['GatewayId'] = request.gatewayId;
  }
  if (!Util.isUnset(request.gatewayOptionShrink)) {
    query['GatewayOption'] = request.gatewayOptionShrink;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateGatewayOption',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateGatewayOption(request: UpdateGatewayOptionRequest): UpdateGatewayOptionResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateGatewayOptionWithOptions(request, runtime);
}

model UpdateGatewayRouteRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  destinationType?: string(name='DestinationType'),
  directResponseJSON?: {
    body?: string(name='Body'),
    code?: long(name='Code'),
  }(name='DirectResponseJSON'),
  domainIdListJSON?: string(name='DomainIdListJSON'),
  enableWaf?: boolean(name='EnableWaf'),
  fallback?: boolean(name='Fallback'),
  fallbackServices?: [ 
    {
      agreementType?: string(name='AgreementType'),
      groupName?: string(name='GroupName'),
      name?: string(name='Name'),
      namespace?: string(name='Namespace'),
      percent?: int32(name='Percent'),
      serviceId?: long(name='ServiceId'),
      servicePort?: int32(name='ServicePort'),
      sourceType?: string(name='SourceType'),
      version?: string(name='Version'),
    }
  ](name='FallbackServices'),
  gatewayId?: long(name='GatewayId'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  id?: long(name='Id'),
  name?: string(name='Name'),
  predicates?: {
    headerPredicates?: [ 
      {
        key?: string(name='Key'),
        type?: string(name='Type'),
        value?: string(name='Value'),
      }
    ](name='HeaderPredicates'),
    methodPredicates?: [ string ](name='MethodPredicates'),
    pathPredicates?: {
      ignoreCase?: boolean(name='IgnoreCase'),
      path?: string(name='Path'),
      type?: string(name='Type'),
    }(name='PathPredicates'),
    queryPredicates?: [ 
      {
        key?: string(name='Key'),
        type?: string(name='Type'),
        value?: string(name='Value'),
      }
    ](name='QueryPredicates'),
  }(name='Predicates'),
  redirectJSON?: {
    code?: int32(name='Code'),
    host?: string(name='Host'),
    path?: string(name='Path'),
  }(name='RedirectJSON'),
  routeOrder?: int32(name='RouteOrder'),
  services?: [ 
    {
      agreementType?: string(name='AgreementType'),
      groupName?: string(name='GroupName'),
      httpDubboTranscoder?: {
        dubboServiceGroup?: string(name='DubboServiceGroup'),
        dubboServiceName?: string(name='DubboServiceName'),
        dubboServiceVersion?: string(name='DubboServiceVersion'),
        mothedMapList?: [ 
          {
            dubboMothedName?: string(name='DubboMothedName'),
            httpMothed?: string(name='HttpMothed'),
            mothedpath?: string(name='Mothedpath'),
            paramMapsList?: [ 
              {
                extractKey?: string(name='ExtractKey'),
                extractKeySpec?: string(name='ExtractKeySpec'),
                mappingType?: string(name='MappingType'),
              }
            ](name='ParamMapsList'),
            passThroughAllHeaders?: string(name='PassThroughAllHeaders'),
            passThroughList?: [ string ](name='PassThroughList'),
          }
        ](name='MothedMapList'),
      }(name='HttpDubboTranscoder'),
      name?: string(name='Name'),
      namespace?: string(name='Namespace'),
      percent?: int32(name='Percent'),
      serviceId?: long(name='ServiceId'),
      servicePort?: int32(name='ServicePort'),
      sourceType?: string(name='SourceType'),
      version?: string(name='Version'),
    }
  ](name='Services'),
}

model UpdateGatewayRouteShrinkRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  destinationType?: string(name='DestinationType'),
  directResponseJSONShrink?: string(name='DirectResponseJSON'),
  domainIdListJSON?: string(name='DomainIdListJSON'),
  enableWaf?: boolean(name='EnableWaf'),
  fallback?: boolean(name='Fallback'),
  fallbackServicesShrink?: string(name='FallbackServices'),
  gatewayId?: long(name='GatewayId'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  id?: long(name='Id'),
  name?: string(name='Name'),
  predicatesShrink?: string(name='Predicates'),
  redirectJSONShrink?: string(name='RedirectJSON'),
  routeOrder?: int32(name='RouteOrder'),
  servicesShrink?: string(name='Services'),
}

model UpdateGatewayRouteResponseBody = {
  code?: int32(name='Code'),
  data?: long(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateGatewayRouteResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateGatewayRouteResponseBody(name='body'),
}

async function updateGatewayRouteWithOptions(tmpReq: UpdateGatewayRouteRequest, runtime: Util.RuntimeOptions): UpdateGatewayRouteResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateGatewayRouteShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.directResponseJSON)) {
    request.directResponseJSONShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.directResponseJSON, 'DirectResponseJSON', 'json');
  }
  if (!Util.isUnset(tmpReq.fallbackServices)) {
    request.fallbackServicesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.fallbackServices, 'FallbackServices', 'json');
  }
  if (!Util.isUnset(tmpReq.predicates)) {
    request.predicatesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.predicates, 'Predicates', 'json');
  }
  if (!Util.isUnset(tmpReq.redirectJSON)) {
    request.redirectJSONShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.redirectJSON, 'RedirectJSON', 'json');
  }
  if (!Util.isUnset(tmpReq.services)) {
    request.servicesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.services, 'Services', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.destinationType)) {
    query['DestinationType'] = request.destinationType;
  }
  if (!Util.isUnset(request.directResponseJSONShrink)) {
    query['DirectResponseJSON'] = request.directResponseJSONShrink;
  }
  if (!Util.isUnset(request.domainIdListJSON)) {
    query['DomainIdListJSON'] = request.domainIdListJSON;
  }
  if (!Util.isUnset(request.enableWaf)) {
    query['EnableWaf'] = request.enableWaf;
  }
  if (!Util.isUnset(request.fallback)) {
    query['Fallback'] = request.fallback;
  }
  if (!Util.isUnset(request.fallbackServicesShrink)) {
    query['FallbackServices'] = request.fallbackServicesShrink;
  }
  if (!Util.isUnset(request.gatewayId)) {
    query['GatewayId'] = request.gatewayId;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.predicatesShrink)) {
    query['Predicates'] = request.predicatesShrink;
  }
  if (!Util.isUnset(request.redirectJSONShrink)) {
    query['RedirectJSON'] = request.redirectJSONShrink;
  }
  if (!Util.isUnset(request.routeOrder)) {
    query['RouteOrder'] = request.routeOrder;
  }
  if (!Util.isUnset(request.servicesShrink)) {
    query['Services'] = request.servicesShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateGatewayRoute',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateGatewayRoute(request: UpdateGatewayRouteRequest): UpdateGatewayRouteResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateGatewayRouteWithOptions(request, runtime);
}

model UpdateGatewayRouteCORSRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  corsJSON?: {
    allowCredentials?: boolean(name='AllowCredentials'),
    allowHeaders?: string(name='AllowHeaders'),
    allowMethods?: string(name='AllowMethods'),
    allowOrigins?: string(name='AllowOrigins'),
    exposeHeaders?: string(name='ExposeHeaders'),
    status?: string(name='Status'),
    timeUnit?: string(name='TimeUnit'),
    unitNum?: long(name='UnitNum'),
  }(name='CorsJSON'),
  gatewayId?: long(name='GatewayId'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  id?: long(name='Id'),
}

model UpdateGatewayRouteCORSShrinkRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  corsJSONShrink?: string(name='CorsJSON'),
  gatewayId?: long(name='GatewayId'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  id?: long(name='Id'),
}

model UpdateGatewayRouteCORSResponseBody = {
  code?: int32(name='Code'),
  data?: long(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateGatewayRouteCORSResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateGatewayRouteCORSResponseBody(name='body'),
}

async function updateGatewayRouteCORSWithOptions(tmpReq: UpdateGatewayRouteCORSRequest, runtime: Util.RuntimeOptions): UpdateGatewayRouteCORSResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateGatewayRouteCORSShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.corsJSON)) {
    request.corsJSONShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.corsJSON, 'CorsJSON', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.corsJSONShrink)) {
    query['CorsJSON'] = request.corsJSONShrink;
  }
  if (!Util.isUnset(request.gatewayId)) {
    query['GatewayId'] = request.gatewayId;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateGatewayRouteCORS',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateGatewayRouteCORS(request: UpdateGatewayRouteCORSRequest): UpdateGatewayRouteCORSResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateGatewayRouteCORSWithOptions(request, runtime);
}

model UpdateGatewayRouteHTTPRewriteRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayId?: long(name='GatewayId'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  httpRewriteJSON?: string(name='HttpRewriteJSON'),
  id?: long(name='Id'),
}

model UpdateGatewayRouteHTTPRewriteResponseBody = {
  code?: int32(name='Code'),
  data?: long(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateGatewayRouteHTTPRewriteResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateGatewayRouteHTTPRewriteResponseBody(name='body'),
}

async function updateGatewayRouteHTTPRewriteWithOptions(request: UpdateGatewayRouteHTTPRewriteRequest, runtime: Util.RuntimeOptions): UpdateGatewayRouteHTTPRewriteResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.gatewayId)) {
    query['GatewayId'] = request.gatewayId;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.httpRewriteJSON)) {
    query['HttpRewriteJSON'] = request.httpRewriteJSON;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateGatewayRouteHTTPRewrite',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateGatewayRouteHTTPRewrite(request: UpdateGatewayRouteHTTPRewriteRequest): UpdateGatewayRouteHTTPRewriteResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateGatewayRouteHTTPRewriteWithOptions(request, runtime);
}

model UpdateGatewayRouteHeaderOpRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayId?: long(name='GatewayId'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  headerOpJSON?: string(name='HeaderOpJSON'),
  id?: long(name='Id'),
}

model UpdateGatewayRouteHeaderOpResponseBody = {
  code?: int32(name='Code'),
  data?: long(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateGatewayRouteHeaderOpResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateGatewayRouteHeaderOpResponseBody(name='body'),
}

async function updateGatewayRouteHeaderOpWithOptions(request: UpdateGatewayRouteHeaderOpRequest, runtime: Util.RuntimeOptions): UpdateGatewayRouteHeaderOpResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.gatewayId)) {
    query['GatewayId'] = request.gatewayId;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.headerOpJSON)) {
    query['HeaderOpJSON'] = request.headerOpJSON;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateGatewayRouteHeaderOp',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateGatewayRouteHeaderOp(request: UpdateGatewayRouteHeaderOpRequest): UpdateGatewayRouteHeaderOpResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateGatewayRouteHeaderOpWithOptions(request, runtime);
}

model UpdateGatewayRouteRetryRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayId?: long(name='GatewayId'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  id?: long(name='Id'),
  retryJSON?: {
    attempts?: int32(name='Attempts'),
    httpCodes?: [ string ](name='HttpCodes'),
    retryOn?: [ string ](name='RetryOn'),
    status?: string(name='Status'),
  }(name='RetryJSON'),
}

model UpdateGatewayRouteRetryShrinkRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayId?: long(name='GatewayId'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  id?: long(name='Id'),
  retryJSONShrink?: string(name='RetryJSON'),
}

model UpdateGatewayRouteRetryResponseBody = {
  code?: int32(name='Code'),
  data?: long(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateGatewayRouteRetryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateGatewayRouteRetryResponseBody(name='body'),
}

async function updateGatewayRouteRetryWithOptions(tmpReq: UpdateGatewayRouteRetryRequest, runtime: Util.RuntimeOptions): UpdateGatewayRouteRetryResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateGatewayRouteRetryShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.retryJSON)) {
    request.retryJSONShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.retryJSON, 'RetryJSON', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.gatewayId)) {
    query['GatewayId'] = request.gatewayId;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.retryJSONShrink)) {
    query['RetryJSON'] = request.retryJSONShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateGatewayRouteRetry',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateGatewayRouteRetry(request: UpdateGatewayRouteRetryRequest): UpdateGatewayRouteRetryResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateGatewayRouteRetryWithOptions(request, runtime);
}

model UpdateGatewayRouteTimeoutRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayId?: long(name='GatewayId'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  id?: long(name='Id'),
  timeoutJSON?: {
    status?: string(name='Status'),
    timeUnit?: string(name='TimeUnit'),
    unitNum?: int32(name='UnitNum'),
  }(name='TimeoutJSON'),
}

model UpdateGatewayRouteTimeoutShrinkRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayId?: long(name='GatewayId'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  id?: long(name='Id'),
  timeoutJSONShrink?: string(name='TimeoutJSON'),
}

model UpdateGatewayRouteTimeoutResponseBody = {
  code?: int32(name='Code'),
  data?: long(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateGatewayRouteTimeoutResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateGatewayRouteTimeoutResponseBody(name='body'),
}

async function updateGatewayRouteTimeoutWithOptions(tmpReq: UpdateGatewayRouteTimeoutRequest, runtime: Util.RuntimeOptions): UpdateGatewayRouteTimeoutResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateGatewayRouteTimeoutShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.timeoutJSON)) {
    request.timeoutJSONShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.timeoutJSON, 'TimeoutJSON', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.gatewayId)) {
    query['GatewayId'] = request.gatewayId;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.timeoutJSONShrink)) {
    query['TimeoutJSON'] = request.timeoutJSONShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateGatewayRouteTimeout',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateGatewayRouteTimeout(request: UpdateGatewayRouteTimeoutRequest): UpdateGatewayRouteTimeoutResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateGatewayRouteTimeoutWithOptions(request, runtime);
}

model UpdateGatewayRouteWafStatusRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  enableWaf?: boolean(name='EnableWaf'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  routeId?: long(name='RouteId'),
}

model UpdateGatewayRouteWafStatusResponseBody = {
  code?: int32(name='Code'),
  data?: {
    cors?: {
      allowCredentials?: boolean(name='AllowCredentials'),
      allowHeaders?: string(name='AllowHeaders'),
      allowMethods?: string(name='AllowMethods'),
      allowOrigins?: string(name='AllowOrigins'),
      exposeHeaders?: string(name='ExposeHeaders'),
      status?: string(name='Status'),
      timeUnit?: string(name='TimeUnit'),
      unitNum?: long(name='UnitNum'),
    }(name='Cors'),
    defaultServiceId?: long(name='DefaultServiceId'),
    defaultServiceName?: string(name='DefaultServiceName'),
    destinationType?: string(name='DestinationType'),
    directResponse?: {
      body?: string(name='Body'),
      code?: int32(name='Code'),
    }(name='DirectResponse'),
    domainId?: long(name='DomainId'),
    domainIdList?: [ long ](name='DomainIdList'),
    domainName?: string(name='DomainName'),
    domainNameList?: [ string ](name='DomainNameList'),
    enableWaf?: boolean(name='EnableWaf'),
    gatewayId?: long(name='GatewayId'),
    gatewayUniqueId?: string(name='GatewayUniqueId'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    HTTPRewrite?: {
      host?: string(name='Host'),
      path?: string(name='Path'),
      pathType?: string(name='PathType'),
      pattern?: string(name='Pattern'),
      status?: string(name='Status'),
      substitution?: string(name='Substitution'),
    }(name='HTTPRewrite'),
    headerOp?: {
      headerOpItems?: [ 
        {
          directionType?: string(name='DirectionType'),
          key?: string(name='Key'),
          opType?: string(name='OpType'),
          value?: string(name='Value'),
        }
      ](name='HeaderOpItems'),
      status?: string(name='Status'),
    }(name='HeaderOp'),
    id?: long(name='Id'),
    name?: string(name='Name'),
    predicates?: string(name='Predicates'),
    redirect?: {
      code?: int32(name='Code'),
      host?: string(name='Host'),
      path?: string(name='Path'),
    }(name='Redirect'),
    retry?: {
      attempts?: int32(name='Attempts'),
      httpCodes?: [ string ](name='HttpCodes'),
      retryOn?: [ string ](name='RetryOn'),
      status?: string(name='Status'),
    }(name='Retry'),
    routeOrder?: int32(name='RouteOrder'),
    routePredicates?: {
      headerPredicates?: [ 
        {
          key?: string(name='Key'),
          type?: string(name='Type'),
          value?: string(name='Value'),
        }
      ](name='HeaderPredicates'),
      methodPredicates?: [ string ](name='MethodPredicates'),
      pathPredicates?: {
        ignoreCase?: boolean(name='IgnoreCase'),
        path?: string(name='Path'),
        type?: string(name='Type'),
      }(name='PathPredicates'),
      queryPredicates?: [ 
        {
          key?: string(name='Key'),
          type?: string(name='Type'),
          value?: string(name='Value'),
        }
      ](name='QueryPredicates'),
    }(name='RoutePredicates'),
    routeServices?: [ 
      {
        groupName?: string(name='GroupName'),
        name?: string(name='Name'),
        namespace?: string(name='Namespace'),
        percent?: int32(name='Percent'),
        serviceId?: long(name='ServiceId'),
        serviceName?: string(name='ServiceName'),
        sourceType?: string(name='SourceType'),
        version?: string(name='Version'),
      }
    ](name='RouteServices'),
    services?: string(name='Services'),
    status?: int32(name='Status'),
    timeout?: {
      status?: string(name='Status'),
      timeUnit?: string(name='TimeUnit'),
      unitNum?: int32(name='UnitNum'),
    }(name='Timeout'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateGatewayRouteWafStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateGatewayRouteWafStatusResponseBody(name='body'),
}

async function updateGatewayRouteWafStatusWithOptions(request: UpdateGatewayRouteWafStatusRequest, runtime: Util.RuntimeOptions): UpdateGatewayRouteWafStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.enableWaf)) {
    query['EnableWaf'] = request.enableWaf;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.routeId)) {
    query['RouteId'] = request.routeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateGatewayRouteWafStatus',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateGatewayRouteWafStatus(request: UpdateGatewayRouteWafStatusRequest): UpdateGatewayRouteWafStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateGatewayRouteWafStatusWithOptions(request, runtime);
}

model UpdateGatewayServiceTrafficPolicyRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayId?: long(name='GatewayId'),
  gatewayTrafficPolicy?: TrafficPolicy(name='GatewayTrafficPolicy'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  serviceId?: long(name='ServiceId'),
}

model UpdateGatewayServiceTrafficPolicyShrinkRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayId?: long(name='GatewayId'),
  gatewayTrafficPolicyShrink?: string(name='GatewayTrafficPolicy'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  serviceId?: long(name='ServiceId'),
}

model UpdateGatewayServiceTrafficPolicyResponseBody = {
  code?: int32(name='Code'),
  data?: GatewayService(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateGatewayServiceTrafficPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateGatewayServiceTrafficPolicyResponseBody(name='body'),
}

async function updateGatewayServiceTrafficPolicyWithOptions(tmpReq: UpdateGatewayServiceTrafficPolicyRequest, runtime: Util.RuntimeOptions): UpdateGatewayServiceTrafficPolicyResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateGatewayServiceTrafficPolicyShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.gatewayTrafficPolicy)) {
    request.gatewayTrafficPolicyShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.gatewayTrafficPolicy, 'GatewayTrafficPolicy', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.gatewayId)) {
    query['GatewayId'] = request.gatewayId;
  }
  if (!Util.isUnset(request.gatewayTrafficPolicyShrink)) {
    query['GatewayTrafficPolicy'] = request.gatewayTrafficPolicyShrink;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.serviceId)) {
    query['ServiceId'] = request.serviceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateGatewayServiceTrafficPolicy',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateGatewayServiceTrafficPolicy(request: UpdateGatewayServiceTrafficPolicyRequest): UpdateGatewayServiceTrafficPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateGatewayServiceTrafficPolicyWithOptions(request, runtime);
}

model UpdateGatewayServiceVersionRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  serviceId?: long(name='ServiceId'),
  serviceVersion?: string(name='ServiceVersion'),
}

model UpdateGatewayServiceVersionResponseBody = {
  code?: int32(name='Code'),
  data?: long(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateGatewayServiceVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateGatewayServiceVersionResponseBody(name='body'),
}

async function updateGatewayServiceVersionWithOptions(request: UpdateGatewayServiceVersionRequest, runtime: Util.RuntimeOptions): UpdateGatewayServiceVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.serviceId)) {
    query['ServiceId'] = request.serviceId;
  }
  if (!Util.isUnset(request.serviceVersion)) {
    query['ServiceVersion'] = request.serviceVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateGatewayServiceVersion',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateGatewayServiceVersion(request: UpdateGatewayServiceVersionRequest): UpdateGatewayServiceVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateGatewayServiceVersionWithOptions(request, runtime);
}

model UpdateGatewaySpecRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  replica?: int32(name='Replica'),
  spec?: string(name='Spec'),
}

model UpdateGatewaySpecResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateGatewaySpecResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateGatewaySpecResponseBody(name='body'),
}

async function updateGatewaySpecWithOptions(request: UpdateGatewaySpecRequest, runtime: Util.RuntimeOptions): UpdateGatewaySpecResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.replica)) {
    query['Replica'] = request.replica;
  }
  if (!Util.isUnset(request.spec)) {
    query['Spec'] = request.spec;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateGatewaySpec',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateGatewaySpec(request: UpdateGatewaySpecRequest): UpdateGatewaySpecResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateGatewaySpecWithOptions(request, runtime);
}

model UpdateImageRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterId?: string(name='ClusterId'),
  versionCode?: string(name='VersionCode'),
}

model UpdateImageResponseBody = {
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateImageResponseBody(name='body'),
}

async function updateImageWithOptions(request: UpdateImageRequest, runtime: Util.RuntimeOptions): UpdateImageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.versionCode)) {
    query['VersionCode'] = request.versionCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateImage',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateImage(request: UpdateImageRequest): UpdateImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateImageWithOptions(request, runtime);
}

model UpdateMessageQueueRouteRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  appId?: string(name='AppId'),
  enable?: boolean(name='Enable'),
  filterSide?: string(name='FilterSide'),
  region?: string(name='Region'),
  tags?: [ string ](name='Tags'),
}

model UpdateMessageQueueRouteShrinkRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  appId?: string(name='AppId'),
  enable?: boolean(name='Enable'),
  filterSide?: string(name='FilterSide'),
  region?: string(name='Region'),
  tagsShrink?: string(name='Tags'),
}

model UpdateMessageQueueRouteResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateMessageQueueRouteResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateMessageQueueRouteResponseBody(name='body'),
}

async function updateMessageQueueRouteWithOptions(tmpReq: UpdateMessageQueueRouteRequest, runtime: Util.RuntimeOptions): UpdateMessageQueueRouteResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateMessageQueueRouteShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.enable)) {
    query['Enable'] = request.enable;
  }
  if (!Util.isUnset(request.filterSide)) {
    query['FilterSide'] = request.filterSide;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.tagsShrink)) {
    query['Tags'] = request.tagsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMessageQueueRoute',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateMessageQueueRoute(request: UpdateMessageQueueRouteRequest): UpdateMessageQueueRouteResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMessageQueueRouteWithOptions(request, runtime);
}

model UpdateNacosClusterRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  checkPort?: int32(name='CheckPort'),
  clusterName?: string(name='ClusterName'),
  groupName?: string(name='GroupName'),
  healthChecker?: string(name='HealthChecker'),
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
  serviceName?: string(name='ServiceName'),
  useInstancePortForCheck?: boolean(name='UseInstancePortForCheck'),
}

model UpdateNacosClusterResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateNacosClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateNacosClusterResponseBody(name='body'),
}

async function updateNacosClusterWithOptions(request: UpdateNacosClusterRequest, runtime: Util.RuntimeOptions): UpdateNacosClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.checkPort)) {
    query['CheckPort'] = request.checkPort;
  }
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.healthChecker)) {
    query['HealthChecker'] = request.healthChecker;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  if (!Util.isUnset(request.serviceName)) {
    query['ServiceName'] = request.serviceName;
  }
  if (!Util.isUnset(request.useInstancePortForCheck)) {
    query['UseInstancePortForCheck'] = request.useInstancePortForCheck;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateNacosCluster',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateNacosCluster(request: UpdateNacosClusterRequest): UpdateNacosClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateNacosClusterWithOptions(request, runtime);
}

model UpdateNacosConfigRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  appName?: string(name='AppName'),
  betaIps?: string(name='BetaIps'),
  content?: string(name='Content'),
  dataId?: string(name='DataId'),
  desc?: string(name='Desc'),
  encryptedDataKey?: string(name='EncryptedDataKey'),
  group?: string(name='Group'),
  instanceId?: string(name='InstanceId'),
  md5?: string(name='Md5'),
  namespaceId?: string(name='NamespaceId'),
  tags?: string(name='Tags'),
  type?: string(name='Type'),
}

model UpdateNacosConfigResponseBody = {
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateNacosConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateNacosConfigResponseBody(name='body'),
}

async function updateNacosConfigWithOptions(request: UpdateNacosConfigRequest, runtime: Util.RuntimeOptions): UpdateNacosConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.betaIps)) {
    query['BetaIps'] = request.betaIps;
  }
  if (!Util.isUnset(request.content)) {
    query['Content'] = request.content;
  }
  if (!Util.isUnset(request.dataId)) {
    query['DataId'] = request.dataId;
  }
  if (!Util.isUnset(request.desc)) {
    query['Desc'] = request.desc;
  }
  if (!Util.isUnset(request.encryptedDataKey)) {
    query['EncryptedDataKey'] = request.encryptedDataKey;
  }
  if (!Util.isUnset(request.group)) {
    query['Group'] = request.group;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.md5)) {
    query['Md5'] = request.md5;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateNacosConfig',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateNacosConfig(request: UpdateNacosConfigRequest): UpdateNacosConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateNacosConfigWithOptions(request, runtime);
}

model UpdateNacosInstanceRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterName?: string(name='ClusterName'),
  enabled?: boolean(name='Enabled'),
  ephemeral?: boolean(name='Ephemeral'),
  groupName?: string(name='GroupName'),
  instanceId?: string(name='InstanceId'),
  ip?: string(name='Ip'),
  metadata?: string(name='Metadata'),
  namespaceId?: string(name='NamespaceId'),
  port?: int32(name='Port'),
  serviceName?: string(name='ServiceName'),
  weight?: string(name='Weight'),
}

model UpdateNacosInstanceResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateNacosInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateNacosInstanceResponseBody(name='body'),
}

async function updateNacosInstanceWithOptions(request: UpdateNacosInstanceRequest, runtime: Util.RuntimeOptions): UpdateNacosInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.enabled)) {
    query['Enabled'] = request.enabled;
  }
  if (!Util.isUnset(request.ephemeral)) {
    query['Ephemeral'] = request.ephemeral;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ip)) {
    query['Ip'] = request.ip;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  if (!Util.isUnset(request.port)) {
    query['Port'] = request.port;
  }
  if (!Util.isUnset(request.serviceName)) {
    query['ServiceName'] = request.serviceName;
  }
  if (!Util.isUnset(request.weight)) {
    query['Weight'] = request.weight;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.metadata)) {
    body['Metadata'] = request.metadata;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateNacosInstance',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateNacosInstance(request: UpdateNacosInstanceRequest): UpdateNacosInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateNacosInstanceWithOptions(request, runtime);
}

model UpdateNacosServiceRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterId?: string(name='ClusterId'),
  groupName?: string(name='GroupName'),
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
  protectThreshold?: string(name='ProtectThreshold'),
  serviceName?: string(name='ServiceName'),
}

model UpdateNacosServiceResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateNacosServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateNacosServiceResponseBody(name='body'),
}

async function updateNacosServiceWithOptions(request: UpdateNacosServiceRequest, runtime: Util.RuntimeOptions): UpdateNacosServiceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  if (!Util.isUnset(request.protectThreshold)) {
    query['ProtectThreshold'] = request.protectThreshold;
  }
  if (!Util.isUnset(request.serviceName)) {
    query['ServiceName'] = request.serviceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateNacosService',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateNacosService(request: UpdateNacosServiceRequest): UpdateNacosServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateNacosServiceWithOptions(request, runtime);
}

model UpdatePluginConfigRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  config?: string(name='Config'),
  configLevel?: int32(name='ConfigLevel'),
  enable?: boolean(name='Enable'),
  gatewayId?: long(name='GatewayId'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  gmtCreate?: string(name='GmtCreate'),
  gmtModified?: string(name='GmtModified'),
  id?: long(name='Id'),
  pluginId?: long(name='PluginId'),
}

model UpdatePluginConfigResponseBody = {
  code?: int32(name='Code'),
  data?: long(name='Data'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdatePluginConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdatePluginConfigResponseBody(name='body'),
}

async function updatePluginConfigWithOptions(request: UpdatePluginConfigRequest, runtime: Util.RuntimeOptions): UpdatePluginConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.config)) {
    query['Config'] = request.config;
  }
  if (!Util.isUnset(request.configLevel)) {
    query['ConfigLevel'] = request.configLevel;
  }
  if (!Util.isUnset(request.enable)) {
    query['Enable'] = request.enable;
  }
  if (!Util.isUnset(request.gatewayId)) {
    query['GatewayId'] = request.gatewayId;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.gmtCreate)) {
    query['GmtCreate'] = request.gmtCreate;
  }
  if (!Util.isUnset(request.gmtModified)) {
    query['GmtModified'] = request.gmtModified;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.pluginId)) {
    query['PluginId'] = request.pluginId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdatePluginConfig',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updatePluginConfig(request: UpdatePluginConfigRequest): UpdatePluginConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updatePluginConfigWithOptions(request, runtime);
}

model UpdateSSLCertRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  certIdentifier?: string(name='CertIdentifier'),
  domainId?: long(name='DomainId'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
}

model UpdateSSLCertResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateSSLCertResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateSSLCertResponseBody(name='body'),
}

async function updateSSLCertWithOptions(request: UpdateSSLCertRequest, runtime: Util.RuntimeOptions): UpdateSSLCertResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.certIdentifier)) {
    query['CertIdentifier'] = request.certIdentifier;
  }
  if (!Util.isUnset(request.domainId)) {
    query['DomainId'] = request.domainId;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSSLCert',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateSSLCert(request: UpdateSSLCertRequest): UpdateSSLCertResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSSLCertWithOptions(request, runtime);
}

model UpdateServiceSourceRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  address?: string(name='Address'),
  gatewayId?: long(name='GatewayId'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  id?: long(name='Id'),
  ingressOptionsRequest?: {
    enableIngress?: boolean(name='EnableIngress'),
    enableStatus?: boolean(name='EnableStatus'),
    ingressClass?: string(name='IngressClass'),
    watchNamespace?: string(name='WatchNamespace'),
  }(name='IngressOptionsRequest'),
  name?: string(name='Name'),
  pathList?: [ string ](name='PathList'),
  source?: string(name='Source'),
  type?: string(name='Type'),
}

model UpdateServiceSourceShrinkRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  address?: string(name='Address'),
  gatewayId?: long(name='GatewayId'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  id?: long(name='Id'),
  ingressOptionsRequestShrink?: string(name='IngressOptionsRequest'),
  name?: string(name='Name'),
  pathListShrink?: string(name='PathList'),
  source?: string(name='Source'),
  type?: string(name='Type'),
}

model UpdateServiceSourceResponseBody = {
  code?: int32(name='Code'),
  data?: long(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateServiceSourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateServiceSourceResponseBody(name='body'),
}

async function updateServiceSourceWithOptions(tmpReq: UpdateServiceSourceRequest, runtime: Util.RuntimeOptions): UpdateServiceSourceResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateServiceSourceShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.ingressOptionsRequest)) {
    request.ingressOptionsRequestShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.ingressOptionsRequest, 'IngressOptionsRequest', 'json');
  }
  if (!Util.isUnset(tmpReq.pathList)) {
    request.pathListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.pathList, 'PathList', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.address)) {
    query['Address'] = request.address;
  }
  if (!Util.isUnset(request.gatewayId)) {
    query['GatewayId'] = request.gatewayId;
  }
  if (!Util.isUnset(request.gatewayUniqueId)) {
    query['GatewayUniqueId'] = request.gatewayUniqueId;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.ingressOptionsRequestShrink)) {
    query['IngressOptionsRequest'] = request.ingressOptionsRequestShrink;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.pathListShrink)) {
    query['PathList'] = request.pathListShrink;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateServiceSource',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateServiceSource(request: UpdateServiceSourceRequest): UpdateServiceSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateServiceSourceWithOptions(request, runtime);
}

model UpdateZnodeRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clusterId?: string(name='ClusterId'),
  data?: string(name='Data'),
  path?: string(name='Path'),
  requestPars?: string(name='RequestPars'),
}

model UpdateZnodeResponseBody = {
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateZnodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateZnodeResponseBody(name='body'),
}

async function updateZnodeWithOptions(request: UpdateZnodeRequest, runtime: Util.RuntimeOptions): UpdateZnodeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.data)) {
    query['Data'] = request.data;
  }
  if (!Util.isUnset(request.path)) {
    query['Path'] = request.path;
  }
  if (!Util.isUnset(request.requestPars)) {
    query['RequestPars'] = request.requestPars;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateZnode',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateZnode(request: UpdateZnodeRequest): UpdateZnodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateZnodeWithOptions(request, runtime);
}

model UpgradeClusterRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  instanceId?: string(name='InstanceId'),
  requestPars?: string(name='RequestPars'),
  upgradeVersion?: string(name='UpgradeVersion'),
}

model UpgradeClusterResponseBody = {
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpgradeClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpgradeClusterResponseBody(name='body'),
}

async function upgradeClusterWithOptions(request: UpgradeClusterRequest, runtime: Util.RuntimeOptions): UpgradeClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.requestPars)) {
    query['RequestPars'] = request.requestPars;
  }
  if (!Util.isUnset(request.upgradeVersion)) {
    query['UpgradeVersion'] = request.upgradeVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpgradeCluster',
    version = '2019-05-31',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function upgradeCluster(request: UpgradeClusterRequest): UpgradeClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeClusterWithOptions(request, runtime);
}

