/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('mse', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model GatewayOption {
  logConfigDetails?: {
    logEnabled?: boolean(name='LogEnabled', description='是否开启日志投递'),
    logStoreName?: string(name='LogStoreName', description='投递的目标logstore'),
    projectName?: string(name='ProjectName', description='投递的目标project'),
  }(name='LogConfigDetails', description='日志配置详情'),
  traceDetails?: {
    sample?: long(name='Sample', description='trace 采样率'),
    traceEnabled?: boolean(name='TraceEnabled', description='trace是否开启'),
  }(name='TraceDetails', description='xtrace config option'),
}

model TrafficPolicy {
  loadBalancerSettings?: {
    consistentHashLBConfig?: {
      consistentHashLBType?: string(name='ConsistentHashLBType', description='HEADER, COOKIE, SOURCE_IP, QUERY_PARAMETER'),
      httpCookie?: {
        name?: string(name='Name', description='cookie名'),
        path?: string(name='Path', description='cookie path'),
        TTL?: string(name='TTL', description='cookie生命周期'),
      }(name='HttpCookie', description='使用cookie时配置'),
      parameterName?: string(name='ParameterName', description='使用根据header和参数路由时生效'),
    }(name='ConsistentHashLBConfig', description='一致性hash相关配置'),
    loadbalancerType?: string(name='LoadbalancerType', description='负载均衡类型，枚举类可为ROUND_ROBIN, LEAST_CONN,RANDOM, CONSISTENT_HASH'),
  }(name='LoadBalancerSettings', description='负载均衡相关配置'),
  tlsSetting?: {
    caCertContent?: string(name='CaCertContent', description='ca证书内容'),
    certId?: string(name='CertId', description='使用的证书id，仅当为mutual时需要填写'),
    sni?: string(name='Sni', description='到后端服务些带'),
    tlsMode?: string(name='TlsMode', description='tls模式。为枚举类，可为NONE, SIMPLE, MUITUAL'),
  }(name='TlsSetting', description='tls相关配置'),
}

model AddGatewayRequest {
  enterpriseSecurityGroup?: boolean(name='EnterpriseSecurityGroup'),
  internetSlbSpec?: string(name='InternetSlbSpec'),
  name?: string(name='Name'),
  region?: string(name='Region'),
  replica?: int32(name='Replica'),
  slbSpec?: string(name='SlbSpec'),
  spec?: string(name='Spec'),
  vpc?: string(name='Vpc'),
  vswitch?: string(name='Vswitch'),
  vswitch2?: string(name='Vswitch2'),
}

model AddGatewayResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model AddGatewayResponse = {
  headers: map[string]string(name='headers'),
  body: AddGatewayResponseBody(name='body'),
}

async function addGatewayWithOptions(request: AddGatewayRequest, runtime: Util.RuntimeOptions): AddGatewayResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddGateway', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addGateway(request: AddGatewayRequest): AddGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return addGatewayWithOptions(request, runtime);
}

model AddMockRuleRequest {
  consumerAppIds?: string(name='ConsumerAppIds'),
  dubboMockItems?: string(name='DubboMockItems'),
  enable?: boolean(name='Enable'),
  extraJson?: string(name='ExtraJson'),
  mockType?: long(name='MockType'),
  name?: string(name='Name'),
  providerAppId?: string(name='ProviderAppId'),
  providerAppName?: string(name='ProviderAppName'),
  region?: string(name='Region'),
  scMockItems?: string(name='ScMockItems'),
  source?: string(name='Source'),
}

model AddMockRuleResponseBody = {
  code?: int32(name='Code'),
  data?: {
    accountId?: string(name='AccountId'),
    consumerAppId?: string(name='ConsumerAppId'),
    consumerAppName?: string(name='ConsumerAppName'),
    enable?: boolean(name='Enable'),
    extraJson?: string(name='ExtraJson'),
    id?: long(name='Id'),
    mockType?: long(name='MockType'),
    name?: string(name='Name'),
    namespaceId?: string(name='NamespaceId'),
    providerAppId?: string(name='ProviderAppId'),
    providerAppName?: string(name='ProviderAppName'),
    region?: string(name='Region'),
    scMockItemJson?: string(name='ScMockItemJson'),
    source?: string(name='Source'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AddMockRuleResponse = {
  headers: map[string]string(name='headers'),
  body: AddMockRuleResponseBody(name='body'),
}

async function addMockRuleWithOptions(request: AddMockRuleRequest, runtime: Util.RuntimeOptions): AddMockRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddMockRule', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addMockRule(request: AddMockRuleRequest): AddMockRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return addMockRuleWithOptions(request, runtime);
}

model AddServiceSourceRequest {
  address?: string(name='Address'),
  gatewayId?: long(name='GatewayId'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  info1?: string(name='Info1'),
  info2?: string(name='Info2'),
  name?: string(name='Name'),
  source?: string(name='Source'),
  type?: string(name='Type'),
}

model AddServiceSourceResponseBody = {
  code?: int32(name='Code'),
  data?: long(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model AddServiceSourceResponse = {
  headers: map[string]string(name='headers'),
  body: AddServiceSourceResponseBody(name='body'),
}

async function addServiceSourceWithOptions(request: AddServiceSourceRequest, runtime: Util.RuntimeOptions): AddServiceSourceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddServiceSource', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addServiceSource(request: AddServiceSourceRequest): AddServiceSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return addServiceSourceWithOptions(request, runtime);
}

model CloneNacosConfigRequest {
  ids?: string(name='Ids'),
  instanceId?: string(name='InstanceId'),
  originNamespaceId?: string(name='OriginNamespaceId'),
  policy?: string(name='Policy'),
  targetNamespaceId?: string(name='TargetNamespaceId'),
}

model CloneNacosConfigResponseBody = {
  code?: int32(name='Code'),
  data?: {
    failData?: [ 
      {
        dataId?: string(name='DataId'),
        group?: string(name='Group'),
      }
    ](name='FailData'),
    skipCount?: int32(name='SkipCount'),
    skipData?: [ 
      {
        dataId?: string(name='DataId'),
        group?: string(name='Group'),
      }
    ](name='SkipData'),
    succCount?: int32(name='SuccCount'),
  }(name='Data'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CloneNacosConfigResponse = {
  headers: map[string]string(name='headers'),
  body: CloneNacosConfigResponseBody(name='body'),
}

async function cloneNacosConfigWithOptions(request: CloneNacosConfigRequest, runtime: Util.RuntimeOptions): CloneNacosConfigResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CloneNacosConfig', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function cloneNacosConfig(request: CloneNacosConfigRequest): CloneNacosConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return cloneNacosConfigWithOptions(request, runtime);
}

model CreateAlarmRuleRequest {
  aggregates?: string(name='Aggregates'),
  alarmAliasName?: string(name='AlarmAliasName'),
  alarmItem?: string(name='AlarmItem'),
  alertWay?: map[string]any(name='AlertWay'),
  contactGroupIds?: map[string]any(name='ContactGroupIds'),
  instanceId?: string(name='InstanceId'),
  NValue?: int32(name='NValue'),
  operator?: string(name='Operator'),
  value?: float(name='Value'),
}

model CreateAlarmRuleShrinkRequest {
  aggregates?: string(name='Aggregates'),
  alarmAliasName?: string(name='AlarmAliasName'),
  alarmItem?: string(name='AlarmItem'),
  alertWayShrink?: string(name='AlertWay'),
  contactGroupIdsShrink?: string(name='ContactGroupIds'),
  instanceId?: string(name='InstanceId'),
  NValue?: int32(name='NValue'),
  operator?: string(name='Operator'),
  value?: float(name='Value'),
}

model CreateAlarmRuleResponseBody = {
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateAlarmRuleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateAlarmRuleResponseBody(name='body'),
}

async function createAlarmRuleWithOptions(tmpReq: CreateAlarmRuleRequest, runtime: Util.RuntimeOptions): CreateAlarmRuleResponse {
  Util.validateModel(tmpReq);
  var request = new CreateAlarmRuleShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.alertWay)) {
    request.alertWayShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.alertWay, 'AlertWay', 'json');
  }
  if (!Util.isUnset(tmpReq.contactGroupIds)) {
    request.contactGroupIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.contactGroupIds, 'ContactGroupIds', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateAlarmRule', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createAlarmRule(request: CreateAlarmRuleRequest): CreateAlarmRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAlarmRuleWithOptions(request, runtime);
}

model CreateApplicationRequest {
  appName?: string(name='AppName'),
  extraInfo?: string(name='ExtraInfo'),
  language?: string(name='Language'),
  region?: string(name='Region'),
  source?: string(name='Source'),
}

model CreateApplicationResponseBody = {
  code?: int32(name='Code'),
  data?: {
    appId?: string(name='AppId'),
    appName?: string(name='AppName'),
    createTime?: long(name='CreateTime'),
    extraInfo?: string(name='ExtraInfo'),
    language?: string(name='Language'),
    licenseKey?: string(name='LicenseKey'),
    regionId?: string(name='RegionId'),
    source?: string(name='Source'),
    status?: int32(name='Status'),
    updateTime?: long(name='UpdateTime'),
    userId?: string(name='UserId'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model CreateApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: CreateApplicationResponseBody(name='body'),
}

async function createApplicationWithOptions(request: CreateApplicationRequest, runtime: Util.RuntimeOptions): CreateApplicationResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateApplication', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createApplication(request: CreateApplicationRequest): CreateApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return createApplicationWithOptions(request, runtime);
}

model CreateClusterRequest {
  clusterSpecification?: string(name='ClusterSpecification'),
  clusterType?: string(name='ClusterType'),
  clusterVersion?: string(name='ClusterVersion'),
  connectionType?: string(name='ConnectionType'),
  diskCapacity?: int32(name='DiskCapacity'),
  diskType?: string(name='DiskType'),
  instanceCount?: int32(name='InstanceCount'),
  mseVersion?: string(name='MseVersion', description='用于区分基础/专业版本'),
  netType?: string(name='NetType'),
  privateSlbSpecification?: string(name='PrivateSlbSpecification'),
  pubNetworkFlow?: string(name='PubNetworkFlow'),
  pubSlbSpecification?: string(name='PubSlbSpecification'),
  region?: string(name='Region'),
  requestPars?: string(name='RequestPars'),
  vSwitchId?: string(name='VSwitchId'),
  vpcId?: string(name='VpcId'),
}

model CreateClusterResponseBody = {
  errorCode?: string(name='ErrorCode'),
  instanceId?: string(name='InstanceId'),
  message?: string(name='Message'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateClusterResponse = {
  headers: map[string]string(name='headers'),
  body: CreateClusterResponseBody(name='body'),
}

async function createClusterWithOptions(request: CreateClusterRequest, runtime: Util.RuntimeOptions): CreateClusterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateCluster', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createCluster(request: CreateClusterRequest): CreateClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return createClusterWithOptions(request, runtime);
}

model CreateEngineNamespaceRequest {
  clusterId?: string(name='ClusterId'),
  desc?: string(name='Desc'),
  instanceId?: string(name='InstanceId'),
  name?: string(name='Name'),
  serviceCount?: int32(name='ServiceCount'),
}

model CreateEngineNamespaceResponseBody = {
  clusterId?: string(name='ClusterId'),
  data?: {
    configCount?: int32(name='ConfigCount'),
    namespace?: string(name='Namespace'),
    namespaceDesc?: string(name='NamespaceDesc'),
    namespaceShowName?: string(name='NamespaceShowName'),
    quota?: int32(name='Quota'),
    serviceCount?: int32(name='ServiceCount'),
    type?: int32(name='Type'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateEngineNamespaceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateEngineNamespaceResponseBody(name='body'),
}

async function createEngineNamespaceWithOptions(request: CreateEngineNamespaceRequest, runtime: Util.RuntimeOptions): CreateEngineNamespaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateEngineNamespace', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createEngineNamespace(request: CreateEngineNamespaceRequest): CreateEngineNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createEngineNamespaceWithOptions(request, runtime);
}

model CreateNacosConfigRequest {
  appName?: string(name='AppName'),
  betaIps?: string(name='BetaIps'),
  content?: string(name='Content'),
  dataId?: string(name='DataId'),
  desc?: string(name='Desc'),
  group?: string(name='Group'),
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
  tags?: string(name='Tags'),
  type?: string(name='Type'),
}

model CreateNacosConfigResponseBody = {
  code?: string(name='Code'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateNacosConfigResponse = {
  headers: map[string]string(name='headers'),
  body: CreateNacosConfigResponseBody(name='body'),
}

async function createNacosConfigWithOptions(request: CreateNacosConfigRequest, runtime: Util.RuntimeOptions): CreateNacosConfigResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateNacosConfig', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createNacosConfig(request: CreateNacosConfigRequest): CreateNacosConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return createNacosConfigWithOptions(request, runtime);
}

model CreateZnodeRequest {
  clusterId?: string(name='ClusterId'),
  data?: string(name='Data'),
  path?: string(name='Path'),
}

model CreateZnodeResponseBody = {
  data?: {
    data?: string(name='Data'),
    dir?: boolean(name='Dir'),
    name?: string(name='Name'),
    path?: string(name='Path'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateZnodeResponse = {
  headers: map[string]string(name='headers'),
  body: CreateZnodeResponseBody(name='body'),
}

async function createZnodeWithOptions(request: CreateZnodeRequest, runtime: Util.RuntimeOptions): CreateZnodeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateZnode', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createZnode(request: CreateZnodeRequest): CreateZnodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return createZnodeWithOptions(request, runtime);
}

model DeleteAlarmRuleRequest {
  alarmRuleId?: string(name='AlarmRuleId'),
  requestPars?: string(name='RequestPars'),
}

model DeleteAlarmRuleResponseBody = {
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteAlarmRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAlarmRuleResponseBody(name='body'),
}

async function deleteAlarmRuleWithOptions(request: DeleteAlarmRuleRequest, runtime: Util.RuntimeOptions): DeleteAlarmRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteAlarmRule', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteAlarmRule(request: DeleteAlarmRuleRequest): DeleteAlarmRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAlarmRuleWithOptions(request, runtime);
}

model DeleteClusterRequest {
  instanceId?: string(name='InstanceId'),
}

model DeleteClusterResponseBody = {
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteClusterResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteClusterResponseBody(name='body'),
}

async function deleteClusterWithOptions(request: DeleteClusterRequest, runtime: Util.RuntimeOptions): DeleteClusterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteCluster', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteCluster(request: DeleteClusterRequest): DeleteClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteClusterWithOptions(request, runtime);
}

model DeleteEngineNamespaceRequest {
  clusterId?: string(name='ClusterId'),
  id?: string(name='Id'),
  instanceId?: string(name='InstanceId'),
}

model DeleteEngineNamespaceResponseBody = {
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteEngineNamespaceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteEngineNamespaceResponseBody(name='body'),
}

async function deleteEngineNamespaceWithOptions(request: DeleteEngineNamespaceRequest, runtime: Util.RuntimeOptions): DeleteEngineNamespaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteEngineNamespace', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteEngineNamespace(request: DeleteEngineNamespaceRequest): DeleteEngineNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteEngineNamespaceWithOptions(request, runtime);
}

model DeleteNacosConfigRequest {
  beta?: boolean(name='Beta'),
  dataId?: string(name='DataId'),
  group?: string(name='Group'),
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
}

model DeleteNacosConfigResponseBody = {
  code?: string(name='Code'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteNacosConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteNacosConfigResponseBody(name='body'),
}

async function deleteNacosConfigWithOptions(request: DeleteNacosConfigRequest, runtime: Util.RuntimeOptions): DeleteNacosConfigResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteNacosConfig', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteNacosConfig(request: DeleteNacosConfigRequest): DeleteNacosConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteNacosConfigWithOptions(request, runtime);
}

model DeleteNacosConfigsRequest {
  ids?: string(name='Ids'),
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
}

model DeleteNacosConfigsResponseBody = {
  code?: int32(name='Code'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteNacosConfigsResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteNacosConfigsResponseBody(name='body'),
}

async function deleteNacosConfigsWithOptions(request: DeleteNacosConfigsRequest, runtime: Util.RuntimeOptions): DeleteNacosConfigsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteNacosConfigs', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteNacosConfigs(request: DeleteNacosConfigsRequest): DeleteNacosConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteNacosConfigsWithOptions(request, runtime);
}

model DeleteNacosServiceRequest {
  groupName?: string(name='GroupName'),
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
  serviceName?: string(name='ServiceName'),
}

model DeleteNacosServiceResponseBody = {
  code?: int32(name='Code', description='响应码'),
  data?: string(name='Data', description='删除服务的结果'),
  httpStatusCode?: int32(name='HttpStatusCode', description='http状态码'),
  message?: string(name='Message', description='响应信息'),
  requestId?: string(name='RequestId', description='请求id'),
  success?: boolean(name='Success', description='成功标志'),
}

model DeleteNacosServiceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteNacosServiceResponseBody(name='body'),
}

async function deleteNacosServiceWithOptions(request: DeleteNacosServiceRequest, runtime: Util.RuntimeOptions): DeleteNacosServiceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteNacosService', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteNacosService(request: DeleteNacosServiceRequest): DeleteNacosServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteNacosServiceWithOptions(request, runtime);
}

model DeleteZnodeRequest {
  clusterId?: string(name='ClusterId'),
  path?: string(name='Path'),
  requestPars?: string(name='RequestPars'),
}

model DeleteZnodeResponseBody = {
  data?: {
    data?: string(name='Data'),
    dir?: boolean(name='Dir'),
    name?: string(name='Name'),
    path?: string(name='Path'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteZnodeResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteZnodeResponseBody(name='body'),
}

async function deleteZnodeWithOptions(request: DeleteZnodeRequest, runtime: Util.RuntimeOptions): DeleteZnodeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteZnode', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteZnode(request: DeleteZnodeRequest): DeleteZnodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteZnodeWithOptions(request, runtime);
}

model ExportNacosConfigRequest {
  appName?: string(name='AppName'),
  dataId?: string(name='DataId'),
  group?: string(name='Group'),
  ids?: string(name='Ids'),
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
}

model ExportNacosConfigResponseBody = {
  code?: int32(name='Code'),
  data?: {
    url?: string(name='Url'),
  }(name='Data'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ExportNacosConfigResponse = {
  headers: map[string]string(name='headers'),
  body: ExportNacosConfigResponseBody(name='body'),
}

async function exportNacosConfigWithOptions(request: ExportNacosConfigRequest, runtime: Util.RuntimeOptions): ExportNacosConfigResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ExportNacosConfig', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function exportNacosConfig(request: ExportNacosConfigRequest): ExportNacosConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return exportNacosConfigWithOptions(request, runtime);
}

model GetEngineNamepaceRequest {
  clusterId?: string(name='ClusterId'),
  id?: string(name='Id'),
  instanceId?: string(name='InstanceId'),
}

model GetEngineNamepaceResponseBody = {
  configCount?: string(name='ConfigCount'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  namespace?: string(name='Namespace'),
  namespaceDesc?: string(name='NamespaceDesc'),
  namespaceShowName?: string(name='NamespaceShowName'),
  quota?: string(name='Quota'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  type?: string(name='Type'),
}

model GetEngineNamepaceResponse = {
  headers: map[string]string(name='headers'),
  body: GetEngineNamepaceResponseBody(name='body'),
}

async function getEngineNamepaceWithOptions(request: GetEngineNamepaceRequest, runtime: Util.RuntimeOptions): GetEngineNamepaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetEngineNamepace', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getEngineNamepace(request: GetEngineNamepaceRequest): GetEngineNamepaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getEngineNamepaceWithOptions(request, runtime);
}

model GetGatewayRequest {
  gatewayUniqueId?: string(name='GatewayUniqueId'),
}

model GetGatewayResponseBody = {
  code?: int32(name='Code'),
  data?: {
    armsOn?: boolean(name='ArmsOn'),
    chargeType?: string(name='ChargeType'),
    endDate?: string(name='EndDate'),
    gatewayType?: string(name='GatewayType'),
    gatewayUniqueId?: string(name='GatewayUniqueId'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    id?: long(name='Id'),
    instanceId?: string(name='InstanceId'),
    logConfigDetails?: {
      logEnabled?: boolean(name='LogEnabled'),
      logStoreName?: string(name='LogStoreName'),
      projectName?: string(name='ProjectName'),
    }(name='LogConfigDetails'),
    name?: string(name='Name'),
    primaryUser?: string(name='PrimaryUser'),
    region?: string(name='Region'),
    replica?: int32(name='Replica'),
    securityGroup?: string(name='SecurityGroup'),
    spec?: string(name='Spec'),
    status?: int32(name='Status'),
    vpc?: string(name='Vpc'),
    vswitch?: string(name='Vswitch'),
    vswitch2?: string(name='Vswitch2'),
    xtraceDetails?: {
      sample?: int32(name='Sample'),
      traceOn?: boolean(name='TraceOn'),
    }(name='XtraceDetails'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model GetGatewayResponse = {
  headers: map[string]string(name='headers'),
  body: GetGatewayResponseBody(name='body'),
}

async function getGatewayWithOptions(request: GetGatewayRequest, runtime: Util.RuntimeOptions): GetGatewayResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('GetGateway', '2019-05-31', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function getGateway(request: GetGatewayRequest): GetGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return getGatewayWithOptions(request, runtime);
}

model GetGatewayOptionRequest {
  gatewayId?: long(name='GatewayId'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
}

model GetGatewayOptionResponseBody = {
  code?: int32(name='Code'),
  data?: GatewayOption(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model GetGatewayOptionResponse = {
  headers: map[string]string(name='headers'),
  body: GetGatewayOptionResponseBody(name='body'),
}

async function getGatewayOptionWithOptions(request: GetGatewayOptionRequest, runtime: Util.RuntimeOptions): GetGatewayOptionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetGatewayOption', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getGatewayOption(request: GetGatewayOptionRequest): GetGatewayOptionResponse {
  var runtime = new Util.RuntimeOptions{};
  return getGatewayOptionWithOptions(request, runtime);
}

model GetGovernanceKubernetesClusterRequest {
  clusterId?: string(name='ClusterId'),
  regionId?: string(name='RegionId'),
}

model GetGovernanceKubernetesClusterResponseBody = {
  code?: int32(name='Code'),
  data?: {
    clusterId?: string(name='ClusterId'),
    clusterName?: string(name='ClusterName'),
    k8sVersion?: string(name='K8sVersion'),
    namespaceInfos?: string(name='NamespaceInfos'),
    namespaces?: [ 
      {
        name?: string(name='Name'),
        tags?: string(name='Tags'),
      }
    ](name='Namespaces'),
    pilotStartTime?: string(name='PilotStartTime'),
    region?: string(name='Region'),
    updateTime?: string(name='UpdateTime'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetGovernanceKubernetesClusterResponse = {
  headers: map[string]string(name='headers'),
  body: GetGovernanceKubernetesClusterResponseBody(name='body'),
}

async function getGovernanceKubernetesClusterWithOptions(request: GetGovernanceKubernetesClusterRequest, runtime: Util.RuntimeOptions): GetGovernanceKubernetesClusterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetGovernanceKubernetesCluster', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getGovernanceKubernetesCluster(request: GetGovernanceKubernetesClusterRequest): GetGovernanceKubernetesClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return getGovernanceKubernetesClusterWithOptions(request, runtime);
}

model GetGovernanceKubernetesClusterListRequest {
  clusterId?: string(name='ClusterId'),
  clusterName?: string(name='ClusterName'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model GetGovernanceKubernetesClusterListResponseBody = {
  code?: int32(name='Code'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    result?: [ 
      {
        clusterId?: string(name='ClusterId'),
        clusterName?: string(name='ClusterName'),
        k8sVersion?: string(name='K8sVersion'),
        namespaceInfos?: string(name='NamespaceInfos'),
        pilotStartTime?: string(name='PilotStartTime'),
        region?: string(name='Region'),
      }
    ](name='Result'),
    totalSize?: int32(name='TotalSize'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetGovernanceKubernetesClusterListResponse = {
  headers: map[string]string(name='headers'),
  body: GetGovernanceKubernetesClusterListResponseBody(name='body'),
}

async function getGovernanceKubernetesClusterListWithOptions(request: GetGovernanceKubernetesClusterListRequest, runtime: Util.RuntimeOptions): GetGovernanceKubernetesClusterListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetGovernanceKubernetesClusterList', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getGovernanceKubernetesClusterList(request: GetGovernanceKubernetesClusterListRequest): GetGovernanceKubernetesClusterListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getGovernanceKubernetesClusterListWithOptions(request, runtime);
}

model GetImageRequest {
  versionCode?: string(name='VersionCode', description='集群版本'),
}

model GetImageResponseBody = {
  data?: {
    currentVersionFullShowName?: string(name='CurrentVersionFullShowName', description='当前集群镜像版本的4位全名'),
    maxVersionChangelogUrl?: string(name='MaxVersionChangelogUrl', description='可升级的最大版本变更日志url'),
    maxVersionCode?: string(name='MaxVersionCode', description='可升级的增量版本Code'),
    maxVersionFullShowName?: string(name='MaxVersionFullShowName', description='可升级的增量版本全名'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model GetImageResponse = {
  headers: map[string]string(name='headers'),
  body: GetImageResponseBody(name='body'),
}

async function getImageWithOptions(request: GetImageRequest, runtime: Util.RuntimeOptions): GetImageResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetImage', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getImage(request: GetImageRequest): GetImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return getImageWithOptions(request, runtime);
}

model GetImportFileUrlRequest {
  contentType?: string(name='ContentType'),
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
}

model GetImportFileUrlResponseBody = {
  code?: int32(name='Code'),
  data?: {
    url?: string(name='Url'),
  }(name='Data'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetImportFileUrlResponse = {
  headers: map[string]string(name='headers'),
  body: GetImportFileUrlResponseBody(name='body'),
}

async function getImportFileUrlWithOptions(request: GetImportFileUrlRequest, runtime: Util.RuntimeOptions): GetImportFileUrlResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetImportFileUrl', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getImportFileUrl(request: GetImportFileUrlRequest): GetImportFileUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  return getImportFileUrlWithOptions(request, runtime);
}

model GetMseFeatureSwitchResponseBody = {
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: map[string]any(name='Result'),
  success?: boolean(name='Success'),
}

model GetMseFeatureSwitchResponse = {
  headers: map[string]string(name='headers'),
  body: GetMseFeatureSwitchResponseBody(name='body'),
}

async function getMseFeatureSwitchWithOptions(runtime: Util.RuntimeOptions): GetMseFeatureSwitchResponse {
  var req = new OpenApi.OpenApiRequest{};
  return doRPCRequest('GetMseFeatureSwitch', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getMseFeatureSwitch(): GetMseFeatureSwitchResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMseFeatureSwitchWithOptions(runtime);
}

model GetNacosConfigRequest {
  beta?: boolean(name='Beta'),
  dataId?: string(name='DataId'),
  group?: string(name='Group'),
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
}

model GetNacosConfigResponseBody = {
  configuration?: {
    appName?: string(name='AppName'),
    betaIps?: string(name='BetaIps'),
    content?: string(name='Content'),
    dataId?: string(name='DataId'),
    desc?: string(name='Desc'),
    encryptedDataKey?: string(name='EncryptedDataKey'),
    group?: string(name='Group'),
    md5?: string(name='Md5'),
    tags?: string(name='Tags'),
    type?: string(name='Type'),
  }(name='Configuration'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetNacosConfigResponse = {
  headers: map[string]string(name='headers'),
  body: GetNacosConfigResponseBody(name='body'),
}

async function getNacosConfigWithOptions(request: GetNacosConfigRequest, runtime: Util.RuntimeOptions): GetNacosConfigResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetNacosConfig', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getNacosConfig(request: GetNacosConfigRequest): GetNacosConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return getNacosConfigWithOptions(request, runtime);
}

model GetNacosHistoryConfigRequest {
  dataId?: string(name='DataId'),
  group?: string(name='Group'),
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
  nid?: string(name='Nid'),
}

model GetNacosHistoryConfigResponseBody = {
  configuration?: {
    appName?: string(name='AppName'),
    content?: string(name='Content'),
    dataId?: string(name='DataId'),
    encryptedDataKey?: string(name='EncryptedDataKey'),
    group?: string(name='Group'),
    md5?: string(name='Md5'),
    opType?: string(name='OpType'),
  }(name='Configuration'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetNacosHistoryConfigResponse = {
  headers: map[string]string(name='headers'),
  body: GetNacosHistoryConfigResponseBody(name='body'),
}

async function getNacosHistoryConfigWithOptions(request: GetNacosHistoryConfigRequest, runtime: Util.RuntimeOptions): GetNacosHistoryConfigResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetNacosHistoryConfig', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getNacosHistoryConfig(request: GetNacosHistoryConfigRequest): GetNacosHistoryConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return getNacosHistoryConfigWithOptions(request, runtime);
}

model GetOverviewRequest {
  period?: int32(name='Period'),
  region?: string(name='Region'),
}

model GetOverviewResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model GetOverviewResponse = {
  headers: map[string]string(name='headers'),
  body: GetOverviewResponseBody(name='body'),
}

async function getOverviewWithOptions(request: GetOverviewRequest, runtime: Util.RuntimeOptions): GetOverviewResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetOverview', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getOverview(request: GetOverviewRequest): GetOverviewResponse {
  var runtime = new Util.RuntimeOptions{};
  return getOverviewWithOptions(request, runtime);
}

model ImportNacosConfigRequest {
  fileUrl?: string(name='FileUrl'),
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
  policy?: string(name='Policy'),
}

model ImportNacosConfigResponseBody = {
  code?: int32(name='Code'),
  data?: {
    failData?: [ 
      {
        dataId?: string(name='DataId'),
        group?: string(name='Group'),
      }
    ](name='FailData'),
    skipCount?: int32(name='SkipCount'),
    skipData?: [ 
      {
        dataId?: string(name='DataId'),
        group?: string(name='Group'),
      }
    ](name='SkipData'),
    succCount?: int32(name='SuccCount'),
  }(name='Data'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ImportNacosConfigResponse = {
  headers: map[string]string(name='headers'),
  body: ImportNacosConfigResponseBody(name='body'),
}

async function importNacosConfigWithOptions(request: ImportNacosConfigRequest, runtime: Util.RuntimeOptions): ImportNacosConfigResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ImportNacosConfig', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function importNacosConfig(request: ImportNacosConfigRequest): ImportNacosConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return importNacosConfigWithOptions(request, runtime);
}

model ListAlarmContactGroupsRequest {
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  requestPars?: string(name='RequestPars'),
}

model ListAlarmContactGroupsResponseBody = {
  data?: [ 
    {
      contactGroupId?: string(name='ContactGroupId'),
      contactGroupName?: string(name='ContactGroupName'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListAlarmContactGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: ListAlarmContactGroupsResponseBody(name='body'),
}

async function listAlarmContactGroupsWithOptions(request: ListAlarmContactGroupsRequest, runtime: Util.RuntimeOptions): ListAlarmContactGroupsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListAlarmContactGroups', '2019-05-31', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listAlarmContactGroups(request: ListAlarmContactGroupsRequest): ListAlarmContactGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAlarmContactGroupsWithOptions(request, runtime);
}

model ListAlarmHistoriesRequest {
  alarmMseType?: string(name='AlarmMseType'),
  alarmName?: string(name='AlarmName'),
  endTime?: long(name='EndTime'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  requestPars?: string(name='RequestPars'),
  startTime?: long(name='StartTime'),
}

model ListAlarmHistoriesResponseBody = {
  data?: [ 
    {
      alarmContent?: string(name='AlarmContent'),
      alarmDingDing?: string(name='AlarmDingDing'),
      alarmEmail?: string(name='AlarmEmail'),
      alarmName?: string(name='AlarmName'),
      alarmPhone?: string(name='AlarmPhone'),
      alarmTime?: string(name='AlarmTime'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListAlarmHistoriesResponse = {
  headers: map[string]string(name='headers'),
  body: ListAlarmHistoriesResponseBody(name='body'),
}

async function listAlarmHistoriesWithOptions(request: ListAlarmHistoriesRequest, runtime: Util.RuntimeOptions): ListAlarmHistoriesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListAlarmHistories', '2019-05-31', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listAlarmHistories(request: ListAlarmHistoriesRequest): ListAlarmHistoriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAlarmHistoriesWithOptions(request, runtime);
}

model ListAlarmItemsRequest {
  requestPars?: string(name='RequestPars'),
}

model ListAlarmItemsResponseBody = {
  data?: [ 
    {
      alarmCode?: string(name='AlarmCode'),
      alarmDesc?: string(name='AlarmDesc'),
      clusterType?: string(name='ClusterType'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListAlarmItemsResponse = {
  headers: map[string]string(name='headers'),
  body: ListAlarmItemsResponseBody(name='body'),
}

async function listAlarmItemsWithOptions(request: ListAlarmItemsRequest, runtime: Util.RuntimeOptions): ListAlarmItemsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListAlarmItems', '2019-05-31', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listAlarmItems(request: ListAlarmItemsRequest): ListAlarmItemsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAlarmItemsWithOptions(request, runtime);
}

model ListAlarmRulesRequest {
  alarmMseType?: string(name='AlarmMseType'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  requestPars?: string(name='RequestPars'),
}

model ListAlarmRulesResponseBody = {
  data?: [ 
    {
      alarmName?: string(name='AlarmName'),
      alarmRuleDetail?: string(name='AlarmRuleDetail'),
      alarmRuleId?: string(name='AlarmRuleId'),
      alarmStatus?: string(name='AlarmStatus'),
      createTime?: string(name='CreateTime'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListAlarmRulesResponse = {
  headers: map[string]string(name='headers'),
  body: ListAlarmRulesResponseBody(name='body'),
}

async function listAlarmRulesWithOptions(request: ListAlarmRulesRequest, runtime: Util.RuntimeOptions): ListAlarmRulesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListAlarmRules', '2019-05-31', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listAlarmRules(request: ListAlarmRulesRequest): ListAlarmRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAlarmRulesWithOptions(request, runtime);
}

model ListAnsInstancesRequest {
  clusterId?: string(name='ClusterId'),
  clusterName?: string(name='ClusterName'),
  groupName?: string(name='GroupName'),
  namespaceId?: string(name='NamespaceId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  requestPars?: string(name='RequestPars'),
  serviceName?: string(name='ServiceName'),
}

model ListAnsInstancesResponseBody = {
  data?: [ 
    {
      app?: string(name='App'),
      clusterName?: string(name='ClusterName'),
      datumKey?: string(name='DatumKey'),
      defaultKey?: string(name='DefaultKey'),
      enabled?: boolean(name='Enabled'),
      ephemeral?: boolean(name='Ephemeral'),
      failCount?: int32(name='FailCount'),
      healthy?: boolean(name='Healthy'),
      instanceHeartBeatInterval?: int32(name='InstanceHeartBeatInterval'),
      instanceHeartBeatTimeOut?: int32(name='InstanceHeartBeatTimeOut'),
      instanceId?: string(name='InstanceId'),
      ip?: string(name='Ip'),
      ipDeleteTimeout?: int32(name='IpDeleteTimeout'),
      lastBeat?: long(name='LastBeat'),
      marked?: boolean(name='Marked'),
      metadata?: map[string]any(name='Metadata'),
      okCount?: int32(name='OkCount'),
      port?: int32(name='Port'),
      serviceName?: string(name='ServiceName'),
      weight?: int32(name='Weight'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListAnsInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: ListAnsInstancesResponseBody(name='body'),
}

async function listAnsInstancesWithOptions(request: ListAnsInstancesRequest, runtime: Util.RuntimeOptions): ListAnsInstancesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListAnsInstances', '2019-05-31', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listAnsInstances(request: ListAnsInstancesRequest): ListAnsInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAnsInstancesWithOptions(request, runtime);
}

model ListAnsServiceClustersRequest {
  clusterId?: string(name='ClusterId'),
  clusterName?: string(name='ClusterName'),
  groupName?: string(name='GroupName'),
  namespaceId?: string(name='NamespaceId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  requestPars?: string(name='RequestPars'),
  serviceName?: string(name='ServiceName'),
}

model ListAnsServiceClustersResponseBody = {
  data?: {
    clusters?: [ 
      {
        defaultCheckPort?: int32(name='DefaultCheckPort'),
        defaultPort?: int32(name='DefaultPort'),
        healthCheckerType?: string(name='HealthCheckerType'),
        metadata?: map[string]any(name='Metadata'),
        name?: string(name='Name'),
        serviceName?: string(name='ServiceName'),
        useIPPort4Check?: boolean(name='UseIPPort4Check'),
      }
    ](name='Clusters'),
    groupName?: string(name='GroupName'),
    metadata?: map[string]any(name='Metadata'),
    name?: string(name='Name'),
    protectThreshold?: float(name='ProtectThreshold'),
    selectorType?: string(name='SelectorType'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListAnsServiceClustersResponse = {
  headers: map[string]string(name='headers'),
  body: ListAnsServiceClustersResponseBody(name='body'),
}

async function listAnsServiceClustersWithOptions(request: ListAnsServiceClustersRequest, runtime: Util.RuntimeOptions): ListAnsServiceClustersResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListAnsServiceClusters', '2019-05-31', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listAnsServiceClusters(request: ListAnsServiceClustersRequest): ListAnsServiceClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAnsServiceClustersWithOptions(request, runtime);
}

model ListAnsServicesRequest {
  clusterId?: string(name='ClusterId'),
  groupName?: string(name='GroupName'),
  hasIpCount?: string(name='HasIpCount'),
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  requestPars?: string(name='RequestPars'),
  serviceName?: string(name='ServiceName'),
}

model ListAnsServicesResponseBody = {
  data?: [ 
    {
      clusterCount?: int32(name='ClusterCount'),
      groupName?: string(name='GroupName'),
      healthyInstanceCount?: int32(name='HealthyInstanceCount'),
      ipCount?: int32(name='IpCount'),
      name?: string(name='Name'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListAnsServicesResponse = {
  headers: map[string]string(name='headers'),
  body: ListAnsServicesResponseBody(name='body'),
}

async function listAnsServicesWithOptions(request: ListAnsServicesRequest, runtime: Util.RuntimeOptions): ListAnsServicesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListAnsServices', '2019-05-31', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listAnsServices(request: ListAnsServicesRequest): ListAnsServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAnsServicesWithOptions(request, runtime);
}

model ListClusterConnectionTypesResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      showName?: string(name='ShowName'),
    }
  ](name='Data'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListClusterConnectionTypesResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterConnectionTypesResponseBody(name='body'),
}

async function listClusterConnectionTypesWithOptions(runtime: Util.RuntimeOptions): ListClusterConnectionTypesResponse {
  var req = new OpenApi.OpenApiRequest{};
  return doRPCRequest('ListClusterConnectionTypes', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listClusterConnectionTypes(): ListClusterConnectionTypesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClusterConnectionTypesWithOptions(runtime);
}

model ListClusterTypesRequest {
  regionId?: string(name='RegionId'),
}

model ListClusterTypesResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      showName?: string(name='ShowName'),
    }
  ](name='Data'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListClusterTypesResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterTypesResponseBody(name='body'),
}

async function listClusterTypesWithOptions(request: ListClusterTypesRequest, runtime: Util.RuntimeOptions): ListClusterTypesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListClusterTypes', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listClusterTypes(request: ListClusterTypesRequest): ListClusterTypesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClusterTypesWithOptions(request, runtime);
}

model ListClusterVersionsRequest {
  clusterType?: string(name='ClusterType'),
}

model ListClusterVersionsResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      clusterType?: string(name='ClusterType'),
      code?: string(name='Code'),
      showName?: string(name='ShowName'),
    }
  ](name='Data'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListClusterVersionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterVersionsResponseBody(name='body'),
}

async function listClusterVersionsWithOptions(request: ListClusterVersionsRequest, runtime: Util.RuntimeOptions): ListClusterVersionsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListClusterVersions', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listClusterVersions(request: ListClusterVersionsRequest): ListClusterVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClusterVersionsWithOptions(request, runtime);
}

model ListClustersRequest {
  clusterAliasName?: string(name='ClusterAliasName'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  requestPars?: string(name='RequestPars'),
}

model ListClustersResponseBody = {
  data?: [ 
    {
      appVersion?: string(name='AppVersion'),
      canUpdate?: boolean(name='CanUpdate'),
      chargeType?: string(name='ChargeType'),
      clusterAliasName?: string(name='ClusterAliasName'),
      clusterName?: string(name='ClusterName'),
      clusterType?: string(name='ClusterType'),
      createTime?: string(name='CreateTime'),
      endDate?: string(name='EndDate'),
      initStatus?: string(name='InitStatus'),
      instanceCount?: long(name='InstanceCount'),
      instanceId?: string(name='InstanceId'),
      internetAddress?: string(name='InternetAddress'),
      internetDomain?: string(name='InternetDomain'),
      intranetAddress?: string(name='IntranetAddress'),
      intranetDomain?: string(name='IntranetDomain'),
      versionCode?: string(name='VersionCode'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListClustersResponse = {
  headers: map[string]string(name='headers'),
  body: ListClustersResponseBody(name='body'),
}

async function listClustersWithOptions(request: ListClustersRequest, runtime: Util.RuntimeOptions): ListClustersResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListClusters', '2019-05-31', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listClusters(request: ListClustersRequest): ListClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClustersWithOptions(request, runtime);
}

model ListEngineNamespacesRequest {
  instanceId?: string(name='InstanceId'),
}

model ListEngineNamespacesResponseBody = {
  data?: [ 
    {
      configCount?: int32(name='ConfigCount'),
      namespace?: string(name='Namespace'),
      namespaceDesc?: string(name='NamespaceDesc'),
      namespaceShowName?: string(name='NamespaceShowName'),
      quota?: int32(name='Quota'),
      serviceCount?: string(name='ServiceCount'),
      type?: int32(name='Type'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListEngineNamespacesResponse = {
  headers: map[string]string(name='headers'),
  body: ListEngineNamespacesResponseBody(name='body'),
}

async function listEngineNamespacesWithOptions(request: ListEngineNamespacesRequest, runtime: Util.RuntimeOptions): ListEngineNamespacesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListEngineNamespaces', '2019-05-31', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listEngineNamespaces(request: ListEngineNamespacesRequest): ListEngineNamespacesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEngineNamespacesWithOptions(request, runtime);
}

model ListEurekaInstancesRequest {
  clusterId?: string(name='ClusterId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  requestPars?: string(name='RequestPars'),
  serviceName?: string(name='ServiceName'),
}

model ListEurekaInstancesResponseBody = {
  data?: [ 
    {
      app?: string(name='App'),
      durationInSecs?: int32(name='DurationInSecs'),
      homePageUrl?: string(name='HomePageUrl'),
      hostName?: string(name='HostName'),
      instanceId?: string(name='InstanceId'),
      ipAddr?: string(name='IpAddr'),
      lastDirtyTimestamp?: long(name='LastDirtyTimestamp'),
      lastUpdatedTimestamp?: long(name='LastUpdatedTimestamp'),
      metadata?: map[string]any(name='Metadata'),
      port?: int32(name='Port'),
      renewalIntervalInSecs?: int32(name='RenewalIntervalInSecs'),
      securePort?: int32(name='SecurePort'),
      status?: string(name='Status'),
      vipAddress?: string(name='VipAddress'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListEurekaInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: ListEurekaInstancesResponseBody(name='body'),
}

async function listEurekaInstancesWithOptions(request: ListEurekaInstancesRequest, runtime: Util.RuntimeOptions): ListEurekaInstancesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListEurekaInstances', '2019-05-31', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listEurekaInstances(request: ListEurekaInstancesRequest): ListEurekaInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEurekaInstancesWithOptions(request, runtime);
}

model ListEurekaServicesRequest {
  clusterId?: string(name='ClusterId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  requestPars?: string(name='RequestPars'),
}

model ListEurekaServicesResponseBody = {
  data?: [ 
    {
      instancesId?: [ string ](name='InstancesId'),
      name?: string(name='Name'),
      upStatus?: string(name='UpStatus'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListEurekaServicesResponse = {
  headers: map[string]string(name='headers'),
  body: ListEurekaServicesResponseBody(name='body'),
}

async function listEurekaServicesWithOptions(request: ListEurekaServicesRequest, runtime: Util.RuntimeOptions): ListEurekaServicesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListEurekaServices', '2019-05-31', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listEurekaServices(request: ListEurekaServicesRequest): ListEurekaServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEurekaServicesWithOptions(request, runtime);
}

model ListGatewayRequest {
  descSort?: boolean(name='DescSort'),
  filterParams?: {
    gatewayType?: string(name='GatewayType'),
    gatewayUniqueId?: string(name='GatewayUniqueId'),
    instanceId?: string(name='InstanceId'),
    name?: string(name='Name'),
    vpc?: string(name='Vpc'),
  }(name='FilterParams'),
  orderItem?: string(name='OrderItem'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListGatewayShrinkRequest {
  descSort?: boolean(name='DescSort'),
  filterParamsShrink?: string(name='FilterParams'),
  orderItem?: string(name='OrderItem'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListGatewayResponseBody = {
  code?: int32(name='Code'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    result?: [ 
      {
        ahasOn?: boolean(name='AhasOn'),
        armsOn?: boolean(name='ArmsOn'),
        chargeType?: string(name='ChargeType'),
        currentVersion?: string(name='CurrentVersion'),
        endDate?: string(name='EndDate'),
        gatewayType?: string(name='GatewayType'),
        gatewayUniqueId?: string(name='GatewayUniqueId'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        id?: long(name='Id'),
        instanceId?: string(name='InstanceId'),
        internetSlb?: [ 
          {
            gatewaySlbMode?: string(name='GatewaySlbMode'),
            gatewaySlbStatus?: string(name='GatewaySlbStatus'),
            internetNetworkFlow?: string(name='InternetNetworkFlow'),
            slbId?: string(name='SlbId'),
            slbIp?: string(name='SlbIp'),
            slbPort?: string(name='SlbPort'),
            slbSpec?: string(name='SlbSpec'),
            statusDesc?: string(name='StatusDesc'),
            type?: string(name='Type'),
          }
        ](name='InternetSlb'),
        latestVersion?: string(name='LatestVersion'),
        mustUpgrade?: boolean(name='MustUpgrade'),
        name?: string(name='Name'),
        primaryUser?: string(name='PrimaryUser'),
        region?: string(name='Region'),
        replica?: int32(name='Replica'),
        slb?: [ 
          {
            gatewaySlbMode?: string(name='GatewaySlbMode'),
            gatewaySlbStatus?: string(name='GatewaySlbStatus'),
            slbId?: string(name='SlbId'),
            slbIp?: string(name='SlbIp'),
            slbPort?: string(name='SlbPort'),
            slbSpec?: string(name='SlbSpec'),
            statusDesc?: string(name='StatusDesc'),
            type?: string(name='Type'),
          }
        ](name='Slb'),
        spec?: string(name='Spec'),
        status?: int32(name='Status'),
        statusDesc?: string(name='StatusDesc'),
        tag?: string(name='Tag'),
        upgrade?: boolean(name='Upgrade'),
        vswitch2?: string(name='Vswitch2'),
      }
    ](name='Result'),
    totalSize?: long(name='TotalSize'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model ListGatewayResponse = {
  headers: map[string]string(name='headers'),
  body: ListGatewayResponseBody(name='body'),
}

async function listGatewayWithOptions(tmpReq: ListGatewayRequest, runtime: Util.RuntimeOptions): ListGatewayResponse {
  Util.validateModel(tmpReq);
  var request = new ListGatewayShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.filterParams)) {
    request.filterParamsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.filterParams, 'FilterParams', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListGateway', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listGateway(request: ListGatewayRequest): ListGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return listGatewayWithOptions(request, runtime);
}

model ListListenersByConfigRequest {
  dataId?: string(name='DataId'),
  group?: string(name='Group'),
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
  requestPars?: string(name='RequestPars'),
}

model ListListenersByConfigResponseBody = {
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  listeners?: [ 
    {
      ip?: string(name='Ip'),
      md5?: string(name='Md5'),
    }
  ](name='Listeners'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListListenersByConfigResponse = {
  headers: map[string]string(name='headers'),
  body: ListListenersByConfigResponseBody(name='body'),
}

async function listListenersByConfigWithOptions(request: ListListenersByConfigRequest, runtime: Util.RuntimeOptions): ListListenersByConfigResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListListenersByConfig', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listListenersByConfig(request: ListListenersByConfigRequest): ListListenersByConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return listListenersByConfigWithOptions(request, runtime);
}

model ListListenersByIpRequest {
  instanceId?: string(name='InstanceId'),
  ip?: string(name='Ip'),
  namespaceId?: string(name='NamespaceId'),
  requestPars?: string(name='RequestPars'),
}

model ListListenersByIpResponseBody = {
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  listeners?: [ 
    {
      dataId?: string(name='DataId'),
      group?: string(name='Group'),
      md5?: string(name='Md5'),
    }
  ](name='Listeners'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListListenersByIpResponse = {
  headers: map[string]string(name='headers'),
  body: ListListenersByIpResponseBody(name='body'),
}

async function listListenersByIpWithOptions(request: ListListenersByIpRequest, runtime: Util.RuntimeOptions): ListListenersByIpResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListListenersByIp', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listListenersByIp(request: ListListenersByIpRequest): ListListenersByIpResponse {
  var runtime = new Util.RuntimeOptions{};
  return listListenersByIpWithOptions(request, runtime);
}

model ListNacosConfigsRequest {
  appName?: string(name='AppName'),
  dataId?: string(name='DataId'),
  group?: string(name='Group'),
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  requestPars?: string(name='RequestPars'),
  tags?: string(name='Tags'),
}

model ListNacosConfigsResponseBody = {
  code?: int32(name='Code'),
  configurations?: [ 
    {
      appName?: string(name='AppName'),
      dataId?: string(name='DataId'),
      group?: string(name='Group'),
      id?: string(name='Id'),
    }
  ](name='Configurations'),
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListNacosConfigsResponse = {
  headers: map[string]string(name='headers'),
  body: ListNacosConfigsResponseBody(name='body'),
}

async function listNacosConfigsWithOptions(request: ListNacosConfigsRequest, runtime: Util.RuntimeOptions): ListNacosConfigsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListNacosConfigs', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listNacosConfigs(request: ListNacosConfigsRequest): ListNacosConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNacosConfigsWithOptions(request, runtime);
}

model ListNacosHistoryConfigsRequest {
  dataId?: string(name='DataId'),
  group?: string(name='Group'),
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  requestPars?: string(name='RequestPars'),
}

model ListNacosHistoryConfigsResponseBody = {
  errorCode?: string(name='ErrorCode'),
  historyItems?: [ 
    {
      appName?: string(name='AppName'),
      dataId?: string(name='DataId'),
      group?: string(name='Group'),
      id?: long(name='Id'),
      lastModifiedTime?: long(name='LastModifiedTime'),
      opType?: string(name='OpType'),
    }
  ](name='HistoryItems'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListNacosHistoryConfigsResponse = {
  headers: map[string]string(name='headers'),
  body: ListNacosHistoryConfigsResponseBody(name='body'),
}

async function listNacosHistoryConfigsWithOptions(request: ListNacosHistoryConfigsRequest, runtime: Util.RuntimeOptions): ListNacosHistoryConfigsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListNacosHistoryConfigs', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listNacosHistoryConfigs(request: ListNacosHistoryConfigsRequest): ListNacosHistoryConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNacosHistoryConfigsWithOptions(request, runtime);
}

model ListZnodeChildrenRequest {
  clusterId?: string(name='ClusterId'),
  path?: string(name='Path'),
}

model ListZnodeChildrenResponseBody = {
  data?: [ 
    {
      data?: string(name='Data'),
      dir?: boolean(name='Dir'),
      name?: string(name='Name'),
      path?: string(name='Path'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListZnodeChildrenResponse = {
  headers: map[string]string(name='headers'),
  body: ListZnodeChildrenResponseBody(name='body'),
}

async function listZnodeChildrenWithOptions(request: ListZnodeChildrenRequest, runtime: Util.RuntimeOptions): ListZnodeChildrenResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListZnodeChildren', '2019-05-31', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listZnodeChildren(request: ListZnodeChildrenRequest): ListZnodeChildrenResponse {
  var runtime = new Util.RuntimeOptions{};
  return listZnodeChildrenWithOptions(request, runtime);
}

model ModifyGovernanceKubernetesClusterRequest {
  clusterId?: string(name='ClusterId'),
  namespaceInfos?: string(name='NamespaceInfos'),
  regionId?: string(name='RegionId'),
}

model ModifyGovernanceKubernetesClusterResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ModifyGovernanceKubernetesClusterResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyGovernanceKubernetesClusterResponseBody(name='body'),
}

async function modifyGovernanceKubernetesClusterWithOptions(request: ModifyGovernanceKubernetesClusterRequest, runtime: Util.RuntimeOptions): ModifyGovernanceKubernetesClusterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyGovernanceKubernetesCluster', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyGovernanceKubernetesCluster(request: ModifyGovernanceKubernetesClusterRequest): ModifyGovernanceKubernetesClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyGovernanceKubernetesClusterWithOptions(request, runtime);
}

model QueryBusinessLocationsResponseBody = {
  data?: [ 
    {
      cnName?: string(name='CnName'),
      description?: string(name='Description'),
      districtCnName?: string(name='DistrictCnName'),
      districtEnName?: string(name='DistrictEnName'),
      districtId?: string(name='DistrictId'),
      districtOrdering?: int32(name='DistrictOrdering'),
      districtShowName?: string(name='DistrictShowName'),
      enDescription?: string(name='EnDescription'),
      enName?: string(name='EnName'),
      name?: string(name='Name'),
      ordering?: int32(name='Ordering'),
      showName?: string(name='ShowName'),
      type?: string(name='Type'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model QueryBusinessLocationsResponse = {
  headers: map[string]string(name='headers'),
  body: QueryBusinessLocationsResponseBody(name='body'),
}

async function queryBusinessLocationsWithOptions(runtime: Util.RuntimeOptions): QueryBusinessLocationsResponse {
  var req = new OpenApi.OpenApiRequest{};
  return doRPCRequest('QueryBusinessLocations', '2019-05-31', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function queryBusinessLocations(): QueryBusinessLocationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryBusinessLocationsWithOptions(runtime);
}

model QueryClusterDetailRequest {
  instanceId?: string(name='InstanceId'),
  orderId?: string(name='OrderId'),
}

model QueryClusterDetailResponseBody = {
  data?: {
    aclEntryList?: string(name='AclEntryList'),
    aclId?: string(name='AclId'),
    appVersion?: string(name='AppVersion'),
    chargeType?: string(name='ChargeType'),
    clusterAliasName?: string(name='ClusterAliasName'),
    clusterName?: string(name='ClusterName'),
    clusterSpecification?: string(name='ClusterSpecification'),
    clusterType?: string(name='ClusterType'),
    clusterVersion?: string(name='ClusterVersion'),
    connectionType?: string(name='ConnectionType'),
    cpu?: int32(name='Cpu'),
    createTime?: string(name='CreateTime'),
    diskCapacity?: long(name='DiskCapacity'),
    diskType?: string(name='DiskType'),
    healthStatus?: string(name='HealthStatus'),
    initCostTime?: long(name='InitCostTime'),
    initStatus?: string(name='InitStatus'),
    instanceCount?: int32(name='InstanceCount'),
    instanceId?: string(name='InstanceId'),
    instanceModels?: [ 
      {
        creationTimestamp?: string(name='CreationTimestamp'),
        healthStatus?: string(name='HealthStatus'),
        internetIp?: string(name='InternetIp'),
        ip?: string(name='Ip'),
        podName?: string(name='PodName'),
        role?: string(name='Role'),
        singleTunnelVip?: string(name='SingleTunnelVip'),
      }
    ](name='InstanceModels'),
    internetAddress?: string(name='InternetAddress'),
    internetDomain?: string(name='InternetDomain'),
    internetPort?: string(name='InternetPort'),
    intranetAddress?: string(name='IntranetAddress'),
    intranetDomain?: string(name='IntranetDomain'),
    intranetPort?: string(name='IntranetPort'),
    memoryCapacity?: long(name='MemoryCapacity'),
    mseVersion?: string(name='MseVersion'),
    netType?: string(name='NetType'),
    payInfo?: string(name='PayInfo'),
    pubNetworkFlow?: string(name='PubNetworkFlow'),
    regionId?: string(name='RegionId'),
    vSwitchId?: string(name='VSwitchId'),
    vpcId?: string(name='VpcId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryClusterDetailResponse = {
  headers: map[string]string(name='headers'),
  body: QueryClusterDetailResponseBody(name='body'),
}

async function queryClusterDetailWithOptions(request: QueryClusterDetailRequest, runtime: Util.RuntimeOptions): QueryClusterDetailResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryClusterDetail', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryClusterDetail(request: QueryClusterDetailRequest): QueryClusterDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryClusterDetailWithOptions(request, runtime);
}

model QueryClusterDiskSpecificationRequest {
  clusterType?: string(name='ClusterType'),
}

model QueryClusterDiskSpecificationResponseBody = {
  code?: int32(name='Code'),
  data?: {
    max?: int32(name='Max'),
    min?: int32(name='Min'),
    step?: int32(name='Step'),
  }(name='Data'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryClusterDiskSpecificationResponse = {
  headers: map[string]string(name='headers'),
  body: QueryClusterDiskSpecificationResponseBody(name='body'),
}

async function queryClusterDiskSpecificationWithOptions(request: QueryClusterDiskSpecificationRequest, runtime: Util.RuntimeOptions): QueryClusterDiskSpecificationResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryClusterDiskSpecification', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryClusterDiskSpecification(request: QueryClusterDiskSpecificationRequest): QueryClusterDiskSpecificationResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryClusterDiskSpecificationWithOptions(request, runtime);
}

model QueryClusterSpecificationResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      clusterSpecificationName?: string(name='ClusterSpecificationName'),
      cpuCapacity?: string(name='CpuCapacity'),
      diskCapacity?: string(name='DiskCapacity'),
      instanceCount?: string(name='InstanceCount'),
      maxCon?: string(name='MaxCon'),
      maxTps?: string(name='MaxTps'),
      memoryCapacity?: string(name='MemoryCapacity'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryClusterSpecificationResponse = {
  headers: map[string]string(name='headers'),
  body: QueryClusterSpecificationResponseBody(name='body'),
}

async function queryClusterSpecificationWithOptions(runtime: Util.RuntimeOptions): QueryClusterSpecificationResponse {
  var req = new OpenApi.OpenApiRequest{};
  return doRPCRequest('QueryClusterSpecification', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryClusterSpecification(): QueryClusterSpecificationResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryClusterSpecificationWithOptions(runtime);
}

model QueryConfigRequest {
  clusterId?: string(name='ClusterId'),
  configType?: string(name='ConfigType'),
  instanceId?: string(name='InstanceId'),
  requestPars?: string(name='RequestPars'),
}

model QueryConfigResponseBody = {
  code?: int32(name='Code'),
  data?: {
    autopurgePurgeInterval?: string(name='AutopurgePurgeInterval'),
    autopurgeSnapRetainCount?: string(name='AutopurgeSnapRetainCount'),
    clusterName?: string(name='ClusterName'),
    configAuthEnabled?: boolean(name='ConfigAuthEnabled'),
    configAuthSupported?: boolean(name='ConfigAuthSupported'),
    configSecretEnabled?: boolean(name='ConfigSecretEnabled'),
    configSecretSupported?: boolean(name='ConfigSecretSupported'),
    initLimit?: string(name='InitLimit'),
    juteMaxbuffer?: string(name='JuteMaxbuffer'),
    jvmFlagsCustom?: string(name='JvmFlagsCustom'),
    MCPEnabled?: boolean(name='MCPEnabled'),
    MCPSupported?: boolean(name='MCPSupported'),
    maxClientCnxns?: string(name='MaxClientCnxns'),
    openSuperAcl?: boolean(name='OpenSuperAcl'),
    passWord?: string(name='PassWord'),
    restartFlag?: boolean(name='RestartFlag'),
    syncLimit?: string(name='SyncLimit'),
    tickTime?: string(name='TickTime'),
    userName?: string(name='UserName'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryConfigResponse = {
  headers: map[string]string(name='headers'),
  body: QueryConfigResponseBody(name='body'),
}

async function queryConfigWithOptions(request: QueryConfigRequest, runtime: Util.RuntimeOptions): QueryConfigResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('QueryConfig', '2019-05-31', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function queryConfig(request: QueryConfigRequest): QueryConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryConfigWithOptions(request, runtime);
}

model QueryGatewayRegionResponseBody = {
  code?: int32(name='Code'),
  data?: [ string ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model QueryGatewayRegionResponse = {
  headers: map[string]string(name='headers'),
  body: QueryGatewayRegionResponseBody(name='body'),
}

async function queryGatewayRegionWithOptions(runtime: Util.RuntimeOptions): QueryGatewayRegionResponse {
  var req = new OpenApi.OpenApiRequest{};
  return doRPCRequest('QueryGatewayRegion', '2019-05-31', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function queryGatewayRegion(): QueryGatewayRegionResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryGatewayRegionWithOptions(runtime);
}

model QueryGatewayTypeResponseBody = {
  code?: int32(name='Code'),
  data?: [ string ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model QueryGatewayTypeResponse = {
  headers: map[string]string(name='headers'),
  body: QueryGatewayTypeResponseBody(name='body'),
}

async function queryGatewayTypeWithOptions(runtime: Util.RuntimeOptions): QueryGatewayTypeResponse {
  var req = new OpenApi.OpenApiRequest{};
  return doRPCRequest('QueryGatewayType', '2019-05-31', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function queryGatewayType(): QueryGatewayTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryGatewayTypeWithOptions(runtime);
}

model QueryGovernanceKubernetesClusterRequest {
  clusterId?: string(name='ClusterId'),
  clusterName?: string(name='ClusterName'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model QueryGovernanceKubernetesClusterResponseBody = {
  code?: int32(name='Code'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    result?: [ 
      {
        clusterId?: string(name='ClusterId'),
        clusterName?: string(name='ClusterName'),
        k8sVersion?: string(name='K8sVersion'),
        namespaceInfos?: string(name='NamespaceInfos'),
        pilotStartTime?: string(name='PilotStartTime'),
        region?: string(name='Region'),
      }
    ](name='Result'),
    totalSize?: int32(name='TotalSize'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryGovernanceKubernetesClusterResponse = {
  headers: map[string]string(name='headers'),
  body: QueryGovernanceKubernetesClusterResponseBody(name='body'),
}

async function queryGovernanceKubernetesClusterWithOptions(request: QueryGovernanceKubernetesClusterRequest, runtime: Util.RuntimeOptions): QueryGovernanceKubernetesClusterResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('QueryGovernanceKubernetesCluster', '2019-05-31', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function queryGovernanceKubernetesCluster(request: QueryGovernanceKubernetesClusterRequest): QueryGovernanceKubernetesClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryGovernanceKubernetesClusterWithOptions(request, runtime);
}

model QueryMonitorRequest {
  endTime?: long(name='EndTime'),
  instanceId?: string(name='InstanceId'),
  monitorType?: string(name='MonitorType'),
  requestPars?: string(name='RequestPars'),
  startTime?: long(name='StartTime'),
  step?: long(name='Step'),
}

model QueryMonitorResponseBody = {
  data?: string(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryMonitorResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMonitorResponseBody(name='body'),
}

async function queryMonitorWithOptions(request: QueryMonitorRequest, runtime: Util.RuntimeOptions): QueryMonitorResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('QueryMonitor', '2019-05-31', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function queryMonitor(request: QueryMonitorRequest): QueryMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMonitorWithOptions(request, runtime);
}

model QuerySlbSpecResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      id?: int32(name='Id'),
      maxConnection?: string(name='MaxConnection'),
      name?: string(name='Name'),
      newConnectionPerSecond?: string(name='NewConnectionPerSecond'),
      qps?: string(name='Qps'),
      spec?: string(name='Spec'),
    }
  ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model QuerySlbSpecResponse = {
  headers: map[string]string(name='headers'),
  body: QuerySlbSpecResponseBody(name='body'),
}

async function querySlbSpecWithOptions(runtime: Util.RuntimeOptions): QuerySlbSpecResponse {
  var req = new OpenApi.OpenApiRequest{};
  return doRPCRequest('QuerySlbSpec', '2019-05-31', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function querySlbSpec(): QuerySlbSpecResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySlbSpecWithOptions(runtime);
}

model QueryZnodeDetailRequest {
  clusterId?: string(name='ClusterId'),
  path?: string(name='Path'),
  requestPars?: string(name='RequestPars'),
}

model QueryZnodeDetailResponseBody = {
  data?: {
    data?: string(name='Data'),
    dir?: boolean(name='Dir'),
    name?: string(name='Name'),
    path?: string(name='Path'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model QueryZnodeDetailResponse = {
  headers: map[string]string(name='headers'),
  body: QueryZnodeDetailResponseBody(name='body'),
}

async function queryZnodeDetailWithOptions(request: QueryZnodeDetailRequest, runtime: Util.RuntimeOptions): QueryZnodeDetailResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('QueryZnodeDetail', '2019-05-31', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function queryZnodeDetail(request: QueryZnodeDetailRequest): QueryZnodeDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryZnodeDetailWithOptions(request, runtime);
}

model RestartClusterRequest {
  clusterId?: string(name='ClusterId'),
  instanceId?: string(name='InstanceId'),
  podNameList?: string(name='PodNameList'),
  requestPars?: string(name='RequestPars'),
}

model RestartClusterResponseBody = {
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RestartClusterResponse = {
  headers: map[string]string(name='headers'),
  body: RestartClusterResponseBody(name='body'),
}

async function restartClusterWithOptions(request: RestartClusterRequest, runtime: Util.RuntimeOptions): RestartClusterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RestartCluster', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function restartCluster(request: RestartClusterRequest): RestartClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return restartClusterWithOptions(request, runtime);
}

model RetryClusterRequest {
  instanceId?: string(name='InstanceId'),
  requestPars?: string(name='RequestPars'),
}

model RetryClusterResponseBody = {
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RetryClusterResponse = {
  headers: map[string]string(name='headers'),
  body: RetryClusterResponseBody(name='body'),
}

async function retryClusterWithOptions(request: RetryClusterRequest, runtime: Util.RuntimeOptions): RetryClusterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RetryCluster', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function retryCluster(request: RetryClusterRequest): RetryClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return retryClusterWithOptions(request, runtime);
}

model ScalingClusterRequest {
  clusterSpecification?: string(name='ClusterSpecification'),
  cpu?: int32(name='Cpu'),
  instanceCount?: int32(name='InstanceCount'),
  instanceId?: string(name='InstanceId'),
  memoryCapacity?: long(name='MemoryCapacity'),
}

model ScalingClusterResponseBody = {
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ScalingClusterResponse = {
  headers: map[string]string(name='headers'),
  body: ScalingClusterResponseBody(name='body'),
}

async function scalingClusterWithOptions(request: ScalingClusterRequest, runtime: Util.RuntimeOptions): ScalingClusterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ScalingCluster', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function scalingCluster(request: ScalingClusterRequest): ScalingClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return scalingClusterWithOptions(request, runtime);
}

model UpdateAclRequest {
  aclEntryList?: string(name='AclEntryList'),
  instanceId?: string(name='InstanceId'),
}

model UpdateAclResponseBody = {
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateAclResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAclResponseBody(name='body'),
}

async function updateAclWithOptions(request: UpdateAclRequest, runtime: Util.RuntimeOptions): UpdateAclResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateAcl', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateAcl(request: UpdateAclRequest): UpdateAclResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAclWithOptions(request, runtime);
}

model UpdateClusterRequest {
  clusterAliasName?: string(name='ClusterAliasName'),
  instanceId?: string(name='InstanceId'),
  requestPars?: string(name='RequestPars'),
}

model UpdateClusterResponseBody = {
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateClusterResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateClusterResponseBody(name='body'),
}

async function updateClusterWithOptions(request: UpdateClusterRequest, runtime: Util.RuntimeOptions): UpdateClusterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateCluster', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateCluster(request: UpdateClusterRequest): UpdateClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateClusterWithOptions(request, runtime);
}

model UpdateConfigRequest {
  autopurgePurgeInterval?: string(name='AutopurgePurgeInterval'),
  autopurgeSnapRetainCount?: string(name='AutopurgeSnapRetainCount'),
  clusterId?: string(name='ClusterId'),
  configAuthEnabled?: boolean(name='ConfigAuthEnabled'),
  configSecretEnabled?: boolean(name='ConfigSecretEnabled'),
  configType?: string(name='ConfigType'),
  initLimit?: string(name='InitLimit'),
  instanceId?: string(name='InstanceId'),
  juteMaxbuffer?: string(name='JuteMaxbuffer'),
  MCPEnabled?: boolean(name='MCPEnabled'),
  maxClientCnxns?: string(name='MaxClientCnxns'),
  openSuperAcl?: string(name='OpenSuperAcl'),
  passWord?: string(name='PassWord'),
  requestPars?: string(name='RequestPars'),
  syncLimit?: string(name='SyncLimit'),
  tickTime?: string(name='TickTime'),
  userName?: string(name='UserName'),
}

model UpdateConfigResponseBody = {
  code?: int32(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateConfigResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateConfigResponseBody(name='body'),
}

async function updateConfigWithOptions(request: UpdateConfigRequest, runtime: Util.RuntimeOptions): UpdateConfigResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateConfig', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateConfig(request: UpdateConfigRequest): UpdateConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateConfigWithOptions(request, runtime);
}

model UpdateEngineNamespaceRequest {
  clusterId?: string(name='ClusterId'),
  desc?: string(name='Desc'),
  id?: string(name='Id'),
  instanceId?: string(name='InstanceId'),
  name?: string(name='Name'),
  serviceCount?: int32(name='ServiceCount'),
}

model UpdateEngineNamespaceResponseBody = {
  data?: {
    configCount?: int32(name='ConfigCount'),
    namespace?: string(name='Namespace'),
    namespaceDesc?: string(name='NamespaceDesc'),
    namespaceShowName?: string(name='NamespaceShowName'),
    quota?: int32(name='Quota'),
    type?: int32(name='Type'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateEngineNamespaceResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateEngineNamespaceResponseBody(name='body'),
}

async function updateEngineNamespaceWithOptions(request: UpdateEngineNamespaceRequest, runtime: Util.RuntimeOptions): UpdateEngineNamespaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateEngineNamespace', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateEngineNamespace(request: UpdateEngineNamespaceRequest): UpdateEngineNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateEngineNamespaceWithOptions(request, runtime);
}

model UpdateGatewayNameRequest {
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  name?: string(name='Name'),
}

model UpdateGatewayNameResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model UpdateGatewayNameResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateGatewayNameResponseBody(name='body'),
}

async function updateGatewayNameWithOptions(request: UpdateGatewayNameRequest, runtime: Util.RuntimeOptions): UpdateGatewayNameResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('UpdateGatewayName', '2019-05-31', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function updateGatewayName(request: UpdateGatewayNameRequest): UpdateGatewayNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateGatewayNameWithOptions(request, runtime);
}

model UpdateGatewayOptionRequest {
  gatewayId?: long(name='GatewayId'),
  gatewayOption?: GatewayOption(name='GatewayOption'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
}

model UpdateGatewayOptionShrinkRequest {
  gatewayId?: long(name='GatewayId'),
  gatewayOptionShrink?: string(name='GatewayOption'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
}

model UpdateGatewayOptionResponseBody = {
  code?: int32(name='Code'),
  data?: GatewayOption(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model UpdateGatewayOptionResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateGatewayOptionResponseBody(name='body'),
}

async function updateGatewayOptionWithOptions(tmpReq: UpdateGatewayOptionRequest, runtime: Util.RuntimeOptions): UpdateGatewayOptionResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateGatewayOptionShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.gatewayOption)) {
    request.gatewayOptionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.gatewayOption, 'GatewayOption', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateGatewayOption', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateGatewayOption(request: UpdateGatewayOptionRequest): UpdateGatewayOptionResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateGatewayOptionWithOptions(request, runtime);
}

model UpdateGatewayRouteHTTPRewriteRequest {
  gatewayId?: long(name='GatewayId'),
  gatewayUniqueId?: string(name='GatewayUniqueId'),
  httpRewriteJSON?: string(name='HttpRewriteJSON'),
  id?: long(name='Id'),
}

model UpdateGatewayRouteHTTPRewriteResponseBody = {
  code?: int32(name='Code'),
  data?: long(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model UpdateGatewayRouteHTTPRewriteResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateGatewayRouteHTTPRewriteResponseBody(name='body'),
}

async function updateGatewayRouteHTTPRewriteWithOptions(request: UpdateGatewayRouteHTTPRewriteRequest, runtime: Util.RuntimeOptions): UpdateGatewayRouteHTTPRewriteResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateGatewayRouteHTTPRewrite', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateGatewayRouteHTTPRewrite(request: UpdateGatewayRouteHTTPRewriteRequest): UpdateGatewayRouteHTTPRewriteResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateGatewayRouteHTTPRewriteWithOptions(request, runtime);
}

model UpdateImageRequest {
  clusterId?: string(name='ClusterId', description='目标集群的id'),
  versionCode?: string(name='VersionCode', description='想修改的镜像版本code'),
}

model UpdateImageResponseBody = {
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model UpdateImageResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateImageResponseBody(name='body'),
}

async function updateImageWithOptions(request: UpdateImageRequest, runtime: Util.RuntimeOptions): UpdateImageResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateImage', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateImage(request: UpdateImageRequest): UpdateImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateImageWithOptions(request, runtime);
}

model UpdateNacosConfigRequest {
  appName?: string(name='AppName'),
  betaIps?: string(name='BetaIps'),
  content?: string(name='Content'),
  dataId?: string(name='DataId'),
  desc?: string(name='Desc'),
  encryptedDataKey?: string(name='EncryptedDataKey'),
  group?: string(name='Group'),
  instanceId?: string(name='InstanceId'),
  md5?: string(name='Md5'),
  namespaceId?: string(name='NamespaceId'),
  tags?: string(name='Tags'),
  type?: string(name='Type'),
}

model UpdateNacosConfigResponseBody = {
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateNacosConfigResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateNacosConfigResponseBody(name='body'),
}

async function updateNacosConfigWithOptions(request: UpdateNacosConfigRequest, runtime: Util.RuntimeOptions): UpdateNacosConfigResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateNacosConfig', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateNacosConfig(request: UpdateNacosConfigRequest): UpdateNacosConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateNacosConfigWithOptions(request, runtime);
}

model UpdateNacosInstanceRequest {
  clusterName?: string(name='ClusterName', description='Nacos集群名'),
  enabled?: boolean(name='Enabled', description='服务禁用标志'),
  ephemeral?: boolean(name='Ephemeral', description='临时节点标志'),
  groupName?: string(name='GroupName', description='分组名'),
  instanceId?: string(name='InstanceId', description='实例id'),
  ip?: string(name='Ip', description='Nacos实例ip'),
  metadata?: string(name='Metadata', description='节点元数据'),
  namespaceId?: string(name='NamespaceId', description='命名空间id'),
  port?: int32(name='Port', description='Nacos实例端口'),
  serviceName?: string(name='ServiceName', description='服务名'),
  weight?: string(name='Weight', description='权重'),
}

model UpdateNacosInstanceResponseBody = {
  code?: int32(name='Code', description='响应码'),
  data?: string(name='Data', description='修改结果'),
  httpStatusCode?: int32(name='HttpStatusCode', description='http状态码'),
  message?: string(name='Message', description='响应信息'),
  requestId?: string(name='RequestId', description='请求id'),
  success?: boolean(name='Success', description='成功标志'),
}

model UpdateNacosInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateNacosInstanceResponseBody(name='body'),
}

async function updateNacosInstanceWithOptions(request: UpdateNacosInstanceRequest, runtime: Util.RuntimeOptions): UpdateNacosInstanceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateNacosInstance', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateNacosInstance(request: UpdateNacosInstanceRequest): UpdateNacosInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateNacosInstanceWithOptions(request, runtime);
}

model UpdateZnodeRequest {
  clusterId?: string(name='ClusterId'),
  data?: string(name='Data'),
  path?: string(name='Path'),
  requestPars?: string(name='RequestPars'),
}

model UpdateZnodeResponseBody = {
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateZnodeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateZnodeResponseBody(name='body'),
}

async function updateZnodeWithOptions(request: UpdateZnodeRequest, runtime: Util.RuntimeOptions): UpdateZnodeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateZnode', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateZnode(request: UpdateZnodeRequest): UpdateZnodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateZnodeWithOptions(request, runtime);
}

model UpgradeClusterRequest {
  instanceId?: string(name='InstanceId'),
  requestPars?: string(name='RequestPars'),
  upgradeVersion?: string(name='UpgradeVersion'),
}

model UpgradeClusterResponseBody = {
  errorCode?: string(name='ErrorCode'),
  httpCode?: string(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpgradeClusterResponse = {
  headers: map[string]string(name='headers'),
  body: UpgradeClusterResponseBody(name='body'),
}

async function upgradeClusterWithOptions(request: UpgradeClusterRequest, runtime: Util.RuntimeOptions): UpgradeClusterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpgradeCluster', '2019-05-31', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function upgradeCluster(request: UpgradeClusterRequest): UpgradeClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeClusterWithOptions(request, runtime);
}

