/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    cn-qingdao = 'ess.aliyuncs.com',
    cn-beijing = 'ess.aliyuncs.com',
    cn-hangzhou = 'ess.aliyuncs.com',
    cn-shanghai = 'ess.aliyuncs.com',
    cn-shenzhen = 'ess.aliyuncs.com',
    cn-hongkong = 'ess.aliyuncs.com',
    ap-southeast-1 = 'ess.aliyuncs.com',
    us-east-1 = 'ess.aliyuncs.com',
    us-west-1 = 'ess.aliyuncs.com',
    cn-shanghai-finance-1 = 'ess.aliyuncs.com',
    cn-shenzhen-finance-1 = 'ess.aliyuncs.com',
    cn-north-2-gov-1 = 'ess.aliyuncs.com',
    ap-northeast-2-pop = 'ess.aliyuncs.com',
    cn-beijing-finance-pop = 'ess.aliyuncs.com',
    cn-beijing-gov-1 = 'ess.aliyuncs.com',
    cn-beijing-nu16-b01 = 'ess.aliyuncs.com',
    cn-edge-1 = 'ess.aliyuncs.com',
    cn-fujian = 'ess.aliyuncs.com',
    cn-haidian-cm12-c01 = 'ess.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'ess.aliyuncs.com',
    cn-hangzhou-finance = 'ess.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'ess.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'ess.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'ess.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'ess.aliyuncs.com',
    cn-hangzhou-test-306 = 'ess.aliyuncs.com',
    cn-hongkong-finance-pop = 'ess.aliyuncs.com',
    cn-huhehaote-nebula-1 = 'ess.aliyuncs.com',
    cn-qingdao-nebula = 'ess.aliyuncs.com',
    cn-shanghai-et15-b01 = 'ess.aliyuncs.com',
    cn-shanghai-et2-b01 = 'ess.aliyuncs.com',
    cn-shanghai-inner = 'ess.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'ess.aliyuncs.com',
    cn-shenzhen-inner = 'ess.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'ess.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'ess.aliyuncs.com',
    cn-wuhan = 'ess.aliyuncs.com',
    cn-yushanfang = 'ess.aliyuncs.com',
    cn-zhangbei = 'ess.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'ess.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'ess.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'ess.aliyuncs.com',
    eu-west-1-oxs = 'ess.aliyuncs.com',
    rus-west-1-pop = 'ess.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('ess', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AttachAlbServerGroupsRequest {
  albServerGroups?: [ 
    {
      albServerGroupId?: string(name='AlbServerGroupId', description='The weight of the ECS instance as a backend server after the instance is added to the ALB server group.

If you increase the weight of an ECS instance in an ALB server group, the number of access requests that are forwarded to the ECS instance increases. If you set the Weight parameter for an ECS instance to 0, no access requests are forwarded to the ECS instance. Valid values: 0 to 100.', example='sgp-ddwb0y0g6y9bjm****'),
      port?: int32(name='Port', description='The ID of the scaling activity in which Auto Scaling associates the ALB server group with the scaling group and adds ECS instances in the scaling group to the ALB server group. This parameter is returned only if you set the `ForceAttach` parameter to `true`.', example='22'),
      weight?: int32(name='Weight', description='The port number used by the ECS instance after the ECS instance is added to the ALB server group. Valid values: 1 to 65535.', example='100'),
    }
  ](name='AlbServerGroups', description='Details of the ALB server group.'),
  clientToken?: string(name='ClientToken', description='Specifies whether to add the ECS instances in the scaling group to the ALB server group. Valid values:

*   true: adds the ECS instances to the ALB server group and returns the value of the `ScalingActivityId` parameter. You can check whether the ECS instances are added to the ALB server group by using the ID of the scaling activity.
*   false: does not add the ECS instances to the ALB server group.

Default value: false.', example='123e4567-e89b-12d3-a456-42665544****'),
  forceAttach?: boolean(name='ForceAttach', description='Details of the ALB server group.', example='false'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The ID of the scaling group.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  scalingGroupId?: string(name='ScalingGroupId', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that the value is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure the idempotence of a request](~~25965~~).', example='asg-bp18p2yfxow2dloq****'),
}

model AttachAlbServerGroupsResponseBody = {
  requestId?: string(name='RequestId', description='auditing', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3****'),
  scalingActivityId?: string(name='ScalingActivityId', description='The ID of the request.', example='asa-2ze6wxj8vsohn6j9****'),
}

model AttachAlbServerGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AttachAlbServerGroupsResponseBody(name='body'),
}

/**
  * Associates one or more Application Load Balancer (ALB) server groups with a scaling group.
  *
  * @param request AttachAlbServerGroupsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return AttachAlbServerGroupsResponse
 */
async function attachAlbServerGroupsWithOptions(request: AttachAlbServerGroupsRequest, runtime: Util.RuntimeOptions): AttachAlbServerGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.albServerGroups)) {
    query['AlbServerGroups'] = request.albServerGroups;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.forceAttach)) {
    query['ForceAttach'] = request.forceAttach;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.scalingGroupId)) {
    query['ScalingGroupId'] = request.scalingGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AttachAlbServerGroups',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Associates one or more Application Load Balancer (ALB) server groups with a scaling group.
  *
  * @param request AttachAlbServerGroupsRequest
  * @return AttachAlbServerGroupsResponse
 */
async function attachAlbServerGroups(request: AttachAlbServerGroupsRequest): AttachAlbServerGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachAlbServerGroupsWithOptions(request, runtime);
}

model AttachDBInstancesRequest {
  clientToken?: string(name='ClientToken', description='The ID of the ApsaraDB RDS instance.', example='123e4567-e89b-12d3-a456-42665544****'),
  DBInstances?: [ string ](name='DBInstances', description='The ID of the ApsaraDB RDS instance.'),
  forceAttach?: boolean(name='ForceAttach', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that the value is unique among different requests.

The token can only contain ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure the idempotence of a request](~~25965~~).', example='false'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The ID of the request.', example='cn-qingdao'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  scalingGroupId?: string(name='ScalingGroupId', description='Specifies whether to add the private IP addresses of all instances in the scaling group to the IP address whitelist of the ApsaraDB RDS instance. Valid values:

*   true
*   false

Default value: false.', example='asg-bp1avr6ensitts3w****'),
}

model AttachDBInstancesResponseBody = {
  requestId?: string(name='RequestId', description='auditing', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3****'),
}

model AttachDBInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AttachDBInstancesResponseBody(name='body'),
}

/**
  * Associates one or more ApsaraDB RDS instances with a scaling group.
  *
  * @param request AttachDBInstancesRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return AttachDBInstancesResponse
 */
async function attachDBInstancesWithOptions(request: AttachDBInstancesRequest, runtime: Util.RuntimeOptions): AttachDBInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBInstances)) {
    query['DBInstances'] = request.DBInstances;
  }
  if (!Util.isUnset(request.forceAttach)) {
    query['ForceAttach'] = request.forceAttach;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.scalingGroupId)) {
    query['ScalingGroupId'] = request.scalingGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AttachDBInstances',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Associates one or more ApsaraDB RDS instances with a scaling group.
  *
  * @param request AttachDBInstancesRequest
  * @return AttachDBInstancesResponse
 */
async function attachDBInstances(request: AttachDBInstancesRequest): AttachDBInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachDBInstancesWithOptions(request, runtime);
}

model AttachInstancesRequest {
  entrusted?: boolean(name='Entrusted', description='The IDs of the ECS instances or elastic container instances that you want to add.', example='false'),
  instanceIds?: [ string ](name='InstanceIds', description='The IDs of the ECS instances or elastic container instances that you want to add. You can specify 1 to 20 instance IDs.

Examples:

*   The ID of the ECS instance that you want to add is `i-28wt4****`.
*   The ID of the elastic container instance that you want to add is `eci-bp17gw49eu09yiwm****`.'),
  lifecycleHook?: boolean(name='LifecycleHook', description='The region ID of the scaling group.', example='false'),
  loadBalancerWeights?: [ int32 ](name='LoadBalancerWeights', description='The weights of the ECS instances or elastic container instances as the backend servers of the associated CLB instance. Valid values: 1 to 100. Default value: 50.'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The ID of the scaling activity.', example='cn-qingdao'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  scalingGroupId?: string(name='ScalingGroupId', description='Specifies whether the scaling group manages the lifecycles of instances that are manually added to the scaling group. Valid values:

*   true: The scaling group manages the lifecycles of instances that are manually added in a similar manner in which the scaling group manages the lifecycles of automatically created instances. After Auto Scaling removes instances from the scaling group, Auto Scaling releases the instances. After you call the DetachInstances operation to remove instances from the scaling group, Auto Scaling does not release the instances.
*   false: The scaling group does not manage the lifecycles of instances that are manually added. After Auto Scaling removes instances from the scaling group, Auto Scaling does not release the instances.

> You cannot specify this parameter for subscription instances.

Default value: false.', example='asg-bp18p2yfxow2dloq****'),
}

model AttachInstancesResponseBody = {
  requestId?: string(name='RequestId', description='auditing', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  scalingActivityId?: string(name='ScalingActivityId', description='The ID of the request.', example='asa-bp1crxor24s28xf1****'),
}

model AttachInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AttachInstancesResponseBody(name='body'),
}

/**
  * Manually adds Elastic Compute Service (ECS) instances or elastic container instances to a scaling group.
  *
  * @param request AttachInstancesRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return AttachInstancesResponse
 */
async function attachInstancesWithOptions(request: AttachInstancesRequest, runtime: Util.RuntimeOptions): AttachInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.entrusted)) {
    query['Entrusted'] = request.entrusted;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.lifecycleHook)) {
    query['LifecycleHook'] = request.lifecycleHook;
  }
  if (!Util.isUnset(request.loadBalancerWeights)) {
    query['LoadBalancerWeights'] = request.loadBalancerWeights;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.scalingGroupId)) {
    query['ScalingGroupId'] = request.scalingGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AttachInstances',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Manually adds Elastic Compute Service (ECS) instances or elastic container instances to a scaling group.
  *
  * @param request AttachInstancesRequest
  * @return AttachInstancesResponse
 */
async function attachInstances(request: AttachInstancesRequest): AttachInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachInstancesWithOptions(request, runtime);
}

model AttachLoadBalancersRequest {
  async?: boolean(name='Async', description='The IDs of the CLB instances.', example='false'),
  clientToken?: string(name='ClientToken', description='Specifies whether to attach the CLB instance to the scaling group in an asynchronous manner. If you attach the CLB instance from the scaling group in an asynchronous manner, the call is successful only after all operations are successful. If a specific operation fails, the call fails. We recommend that you set this parameter to true. Valid values:

*   true: attaches the CLB instance to the scaling group in an asynchronous manner. In this case, the ID of the scaling activity is returned.
*   false: does not attach the CLB instance to the scaling group in an asynchronous manner.

Default value: false.', example='123e4567-e89b-12d3-a456-42665544****'),
  forceAttach?: boolean(name='ForceAttach', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that the value is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25965~~).', example='false'),
  loadBalancers?: [ string ](name='LoadBalancers', description='The IDs of the CLB instances.'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  scalingGroupId?: string(name='ScalingGroupId', description='Specifies whether to add all instances in the scaling group to the vServer groups of the CLB instance. Valid values:

*   true
*   false

Default value: false.', example='asg-bp1avr6ensitts3w****'),
}

model AttachLoadBalancersResponseBody = {
  requestId?: string(name='RequestId', description='auditing', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  scalingActivityId?: string(name='ScalingActivityId', description='The ID of the request.', example='asa-bp140qd7mak8k63f****'),
}

model AttachLoadBalancersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AttachLoadBalancersResponseBody(name='body'),
}

/**
  * Attaches one or more Classic Load Balancer (CLB) instances to a scaling group.
  *
  * @param request AttachLoadBalancersRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return AttachLoadBalancersResponse
 */
async function attachLoadBalancersWithOptions(request: AttachLoadBalancersRequest, runtime: Util.RuntimeOptions): AttachLoadBalancersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.async)) {
    query['Async'] = request.async;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.forceAttach)) {
    query['ForceAttach'] = request.forceAttach;
  }
  if (!Util.isUnset(request.loadBalancers)) {
    query['LoadBalancers'] = request.loadBalancers;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.scalingGroupId)) {
    query['ScalingGroupId'] = request.scalingGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AttachLoadBalancers',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Attaches one or more Classic Load Balancer (CLB) instances to a scaling group.
  *
  * @param request AttachLoadBalancersRequest
  * @return AttachLoadBalancersResponse
 */
async function attachLoadBalancers(request: AttachLoadBalancersRequest): AttachLoadBalancersResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachLoadBalancersWithOptions(request, runtime);
}

model AttachServerGroupsRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that the value is unique among different requests.

The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [Ensure idempotence](~~25965~~).', example='123e4567-e89b-12d3-a456-42665544****'),
  forceAttach?: boolean(name='ForceAttach', description='Specifies whether to add the Elastic Compute Service (ECS) instances in the scaling group to the vServer groups of the newly attached SLB instance.

*   true
*   false

Default value: false.', example='false'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID of the scaling group.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  scalingGroupId?: string(name='ScalingGroupId', description='The ID of the scaling group.', example='asg-bp1fo0dbtsbmqa9h****'),
  serverGroups?: [ 
    {
      port?: int32(name='Port', description='The port number that is used by an ECS instance after Auto Scaling adds the ECS instance to the backend vServer group. Valid values: 1 to 65535.', example='22'),
      serverGroupId?: string(name='ServerGroupId', description='The ID of the server group.', example='sgp-5yc3bd9lfyh*****'),
      type?: string(name='Type', description='The type of the vServer group. Valid values:

*   ALB
*   NLB', example='ALB'),
      weight?: int32(name='Weight', description='The weight of an ECS instance in the scaling group as a backend server after Auto Scaling adds the ECS instance to the backend vServer group.

If you increase the weight of an ECS instance in the backend vServer group, the number of access requests that are forwarded to the ECS instance increases. If you set the Weight parameter for an ECS instance to 0, no access requests are forwarded to the ECS instance. Valid values: 0 to 100.', example='100'),
    }
  ](name='ServerGroups', description='Details of the vServer groups.'),
}

model AttachServerGroupsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3****'),
  scalingActivityId?: string(name='ScalingActivityId', description='The ID of the scaling activity in which an ALB instance is attached to the scaling group and the ECS instances in the scaling group are added to the backend vServer group of the ALB instance.

> This parameter is returned only after you set the ForceAttach parameter to true.', example='asa-bp1c9djwrgxjyk31****'),
}

model AttachServerGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AttachServerGroupsResponseBody(name='body'),
}

async function attachServerGroupsWithOptions(request: AttachServerGroupsRequest, runtime: Util.RuntimeOptions): AttachServerGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.forceAttach)) {
    query['ForceAttach'] = request.forceAttach;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.scalingGroupId)) {
    query['ScalingGroupId'] = request.scalingGroupId;
  }
  if (!Util.isUnset(request.serverGroups)) {
    query['ServerGroups'] = request.serverGroups;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AttachServerGroups',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function attachServerGroups(request: AttachServerGroupsRequest): AttachServerGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachServerGroupsWithOptions(request, runtime);
}

model AttachVServerGroupsRequest {
  clientToken?: string(name='ClientToken', description='Specifies whether to add Elastic Compute Service (ECS) instances in the scaling group to the vServer group. Valid values:

*   true
*   false

Default value: false.', example='123e4567-e89b-12d3-a456-42665544****'),
  forceAttach?: boolean(name='ForceAttach', description='Details of the vServer groups.', example='false'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The ID of the scaling group.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  scalingGroupId?: string(name='ScalingGroupId', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that the value is unique among different requests.

The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure the idempotence of a request](~~25965~~).', example='asg-bp18p2yfxow2dloq****'),
  VServerGroups?: [ 
    {
      loadBalancerId?: string(name='LoadBalancerId', description='The ID of the request.', example='rsp-bp1jp1rge****'),
      VServerGroupAttributes?: [ 
        {
          port?: int32(name='Port', description='The ID of the CLB instance to which the vServer group belongs.', example='22'),
          VServerGroupId?: string(name='VServerGroupId', description='The weight of an ECS instance as a backend server in the vServer group. Valid values: 0 to 100.

Default value: 50.', example='lb-bp1u7etiogg38yvwz****'),
          weight?: int32(name='Weight', description='The port number that is used when Auto Scaling adds ECS instances to the vServer group. Valid values: 1 to 65535.', example='100'),
        }
      ](name='VServerGroupAttributes', description='Details of the vServer group attributes.'),
    }
  ](name='VServerGroups', description='Details of the vServer groups.'),
}

model AttachVServerGroupsResponseBody = {
  requestId?: string(name='RequestId', description='auditing', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3****'),
}

model AttachVServerGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AttachVServerGroupsResponseBody(name='body'),
}

/**
  * Attaches one or more vServer groups of a Classic Load Balancer (CLB) instance to a scaling group.
  *
  * @param request AttachVServerGroupsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return AttachVServerGroupsResponse
 */
async function attachVServerGroupsWithOptions(request: AttachVServerGroupsRequest, runtime: Util.RuntimeOptions): AttachVServerGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.forceAttach)) {
    query['ForceAttach'] = request.forceAttach;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.scalingGroupId)) {
    query['ScalingGroupId'] = request.scalingGroupId;
  }
  if (!Util.isUnset(request.VServerGroups)) {
    query['VServerGroups'] = request.VServerGroups;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AttachVServerGroups',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Attaches one or more vServer groups of a Classic Load Balancer (CLB) instance to a scaling group.
  *
  * @param request AttachVServerGroupsRequest
  * @return AttachVServerGroupsResponse
 */
async function attachVServerGroups(request: AttachVServerGroupsRequest): AttachVServerGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachVServerGroupsWithOptions(request, runtime);
}

model ChangeResourceGroupRequest {
  newResourceGroupId?: string(name='NewResourceGroupId', description='The ID of the resource group that you want to use to replace the previous scaling group.

> You can use resource groups to manage resources owned by your Alibaba Cloud account. Resource groups simplify the resource and permission management of your Alibaba Cloud account. For more information, see [What is resource management?](~~94475~~)', example='rg-aek2ckjqe3*****'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID of the scaling group.', example='cn-hangzhou'),
  resourceId?: string(name='ResourceId', description='The ID of the scaling group whose resource group you want to change.', example='asg-bp17xb4x1vr29lgt****'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceType?: string(name='ResourceType', description='The type of the resource. Only scaling groups are supported. Set the value to scalinggroup.', example='scalinggroup'),
}

model ChangeResourceGroupResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6EF9BFEE-FE07-4627-B8FB-14326FB9****'),
}

model ChangeResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ChangeResourceGroupResponseBody(name='body'),
}

/**
  * A resource is an entity of cloud services that you create on Alibaba Cloud. For example, a scaling group is a resource. A resource group is a collection of infrastructure for projects, environments, or stacks. In a resource group, you can manage resources, monitor resources, and perform operations in a centralized manner. This way, you do not need to view and check your Alibaba Cloud resources in each Alibaba Cloud service.
  *
  * @param request ChangeResourceGroupRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ChangeResourceGroupResponse
 */
async function changeResourceGroupWithOptions(request: ChangeResourceGroupRequest, runtime: Util.RuntimeOptions): ChangeResourceGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.newResourceGroupId)) {
    query['NewResourceGroupId'] = request.newResourceGroupId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ChangeResourceGroup',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * A resource is an entity of cloud services that you create on Alibaba Cloud. For example, a scaling group is a resource. A resource group is a collection of infrastructure for projects, environments, or stacks. In a resource group, you can manage resources, monitor resources, and perform operations in a centralized manner. This way, you do not need to view and check your Alibaba Cloud resources in each Alibaba Cloud service.
  *
  * @param request ChangeResourceGroupRequest
  * @return ChangeResourceGroupResponse
 */
async function changeResourceGroup(request: ChangeResourceGroupRequest): ChangeResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return changeResourceGroupWithOptions(request, runtime);
}

model CompleteLifecycleActionRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that the value is unique among different requests.

The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25965~~).', example='123e4567-e89b-12d3-a456-42665544****'),
  lifecycleActionResult?: string(name='LifecycleActionResult', description='The action that you want Auto Scaling to perform after the lifecycle hook ends. Valid values:

*   CONTINUE: Auto Scaling continues to add Elastic Compute Service (ECS) instances to the scaling group, or continues to remove ECS instances from the scaling group.
*   ABANDON: Auto Scaling stops adding ECS instances to the scaling group and releases the ECS instances, or continues to respond to scale-in requests and remove ECS instances from the scaling group.

Default value: CONTINUE.

If multiple lifecycle hooks exist in a scaling group and are triggered at the same time, the following rules apply:

*   If you set the LifecycleActionResult parameter to ABANDON for the lifecycle hook that is applied to a scale-in activity, Auto Scaling immediately removes ECS instances from the scaling group after the lifecycle hook ends, without the need to wait for the last lifecycle hook to end.
*   If you set the LifecycleActionResult parameter to CONTINUE for the lifecycle hook that is applied to a scale-in or scale-out activity, Auto Scaling performs the next action until the last lifecycle hook in the scaling group ends. The action that Auto Scaling performs varies based on the value that you specify for the LifecycleActionResult parameter of the last lifecycle hook.', example='CONTINUE'),
  lifecycleActionToken?: string(name='LifecycleActionToken', description='The token of the lifecycle hook. You can obtain this token by using a Message Service (MNS) queue or an MNS topic that is specified for the lifecycle hook.', example='aaaa-bbbbb-cccc-ddddd'),
  lifecycleHookId?: string(name='LifecycleHookId', description='The ID of the lifecycle hook.', example='ash-bp14g3ee6bt3sc98****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID of the scaling group.', example='cn-qingdao'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
}

model CompleteLifecycleActionResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
}

model CompleteLifecycleActionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CompleteLifecycleActionResponseBody(name='body'),
}

/**
  * When you call this operation to end a lifecycle hook ahead of schedule, you can use the LifecycleActionResult parameter to specify the action that you want Auto Scaling to perform after the lifecycle hook ends. You can set the LifecycleActionResult parameter to CONTINUE or ABANDON.
  *
  * @param request CompleteLifecycleActionRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CompleteLifecycleActionResponse
 */
async function completeLifecycleActionWithOptions(request: CompleteLifecycleActionRequest, runtime: Util.RuntimeOptions): CompleteLifecycleActionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.lifecycleActionResult)) {
    query['LifecycleActionResult'] = request.lifecycleActionResult;
  }
  if (!Util.isUnset(request.lifecycleActionToken)) {
    query['LifecycleActionToken'] = request.lifecycleActionToken;
  }
  if (!Util.isUnset(request.lifecycleHookId)) {
    query['LifecycleHookId'] = request.lifecycleHookId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CompleteLifecycleAction',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * When you call this operation to end a lifecycle hook ahead of schedule, you can use the LifecycleActionResult parameter to specify the action that you want Auto Scaling to perform after the lifecycle hook ends. You can set the LifecycleActionResult parameter to CONTINUE or ABANDON.
  *
  * @param request CompleteLifecycleActionRequest
  * @return CompleteLifecycleActionResponse
 */
async function completeLifecycleAction(request: CompleteLifecycleActionRequest): CompleteLifecycleActionResponse {
  var runtime = new Util.RuntimeOptions{};
  return completeLifecycleActionWithOptions(request, runtime);
}

model CreateAlarmRequest {
  alarmActions?: [ string ](name='AlarmActions', description='The list of unique identifiers of the scaling rules that are associated with the event-triggered task.'),
  comparisonOperator?: string(name='ComparisonOperator', description='The operator that is used to compare the metric value and the threshold. Valid values:

*   If the metric value is greater than or equal to the threshold, set the value to: >=.
*   If the metric value is less than or equal to the threshold, set the value to: <=.
*   If the metric value is greater than the threshold, set the value to: >.
*   If the metric value is less than the threshold, set the value to: <.

Default value: >=.', example='>='),
  description?: string(name='Description', description='The description of the event-triggered task.', example='Test alarm task.'),
  dimensions?: [ 
    {
      dimensionKey?: string(name='DimensionKey', description='The key of the metric dimension. The valid values vary based on the metric type.

*   If you set the MetricType parameter to custom, you can specify this parameter based on your business requirements.

*   If you set the MetricType parameter to system, this parameter has the following valid values:

    *   user_id: the ID of your Alibaba Cloud account
    *   scaling_group: the scaling group that you want to monitor
    *   device: the type of the NIC
    *   state: the status of the TCP connection', example='device'),
      dimensionValue?: string(name='DimensionValue', description='The value of the metric dimension. The valid values vary based on the value of the DimensionKey parameter.

*   If you set the MetricType parameter to custom, you can specify this parameter based on your business requirements.

*   If you set the MetricType parameter to system, the following rules apply:

    *   If you set the DimensionKey parameter to user_id, the system specifies the value of the DimensionValue parameter.

    *   If you set the DimensionKey parameter to scaling_group, the system specifies the value of the DimensionValue parameter.

    *   If you set the DimensionKey parameter to device, you can set the DimensionValue parameter to eth0 or eth1.

        *   For instances that reside in the classic network, eth0 specifies the internal NIC. Only one eth0 NIC exists on each instance that resides in a VPC.
        *   For instances that reside in the classic network, eth1 specifies the public NIC.

    *   If you set the DimensionKey parameter to state, you can set the DimensionValue parameter to TCP_TOTAL or ESTABLISHED.

        *   TCP_TOTAL specifies the total number of TCP connections.
        *   ESTABLISHED specifies the number of established TCP connections.', example='eth0'),
    }
  ](name='Dimensions', description='The metric dimensions.'),
  effective?: string(name='Effective', description='The effective period of the event-triggered task. By default, the event-triggered task is in effect all the time.

This parameter follows the cron expression format. The default format is `X X X X X ?`. In the format:

*   X: a placeholder for a field, which represents seconds, minutes, hours, days, and months in sequence. X can be a definite value or a special character that has logical meaning. For information about the valid values of X, see [Cron expression](~~25907~~).
*   ?: No value is specified.

> By default, this parameter value is specified in **UTC+8**. You can specify the time zone in the `TZ=+yy` format before a cron expression. y indicates the time zone. For example, `TZ=+00 * * 1-2 * * ?` specifies that the event-triggered task is in effect between 01:00 and 02:59 (UTC+0) every day.

Sample values:

*   ` * * * * * ?  `: The event-triggered task is in effect all the time.
*   ` * * 17-18 * * ?  `: The event-triggered task is in effect between 17:00 and 18:59 (UTC+8) every day.
*   `TZ=+00 * * 1-2 * * ?`: The event-triggered task is in effect between 01:00 and 02:59 (UTC+0) every day.', example='TZ=+00 * * 1-2 * * ?'),
  evaluationCount?: int32(name='EvaluationCount', description='The number of times that the threshold must be reached before a scaling rule can be executed. For example, if you set this parameter to 3, the average CPU utilization must reach or exceed 80% three times in a row before a scaling rule is triggered.

Default value: 3.', example='3'),
  expressions?: [ 
    {
      comparisonOperator?: string(name='ComparisonOperator', description='The operator that is used to compare the metric value and the threshold. Valid values:

*   If the metric value is greater than or equal to the threshold, set the value to: >=.
*   If the metric value is less than or equal to the threshold, set the value to: <=.
*   If the metric value is greater than the threshold, set the value to: >.
*   If the metric value is less than the threshold, set the value to: <.

Default value: >=.', example='>='),
      metricName?: string(name='MetricName', description='The names of the metrics that are specified in the multi-metric alert rule. The valid values of this parameter vary based on the metric type.

*   If you set the MetricType parameter to custom, the valid values are your custom metrics.

*   If you set the MetricType parameter to system, the MetricName parameter has the following valid values:

    *   CpuUtilization: the CPU utilization of an ECS instance. Unit: %.
    *   IntranetTx: the outbound traffic over the internal network from an ECS instance. Unit: KB/min.
    *   IntranetRx: the inbound traffic over the Internet to an ECS instance that resides in a VPC. Unit: KB/min.
    *   VpcInternetTx: the outbound traffic over the Internet from an ECS instance that resides in a VPC. Unit: KB/min.
    *   VpcInternetRx: the inbound traffic over the Internet to an ECS instance that resides in a VPC. Unit: KB/min.
    *   SystemDiskReadBps: the number of bytes read from the system disk used by an ECS instance per second.
    *   SystemDiskWriteBps: the number of bytes written to the system disk used by an ECS instance per second.
    *   SystemDiskReadOps: the number of read operations on the system disk used by an ECS instance per second.
    *   SystemDiskWriteOps: the number of write operations on the system disk used by an ECS instance per second.
    *   CpuUtilizationAgent: the CPU utilization of an agent. Unit: %.
    *   GpuUtilizationAgent: the GPU utilization of an agent. Unit: %.
    *   GpuMemoryFreeUtilizationAgent: the percentage of idle GPU memory of an agent.
    *   GpuMemoryUtilizationAgent: the GPU memory usage of an agent. Unit: %.
    *   MemoryUtilization: the memory usage of an agent. Unit: %.
    *   LoadAverage: the average system load of an agent.
    *   TcpConnection: the total number of TCP connections of an agent.
    *   TcpConnection: the number of established TCP connections of an agent.
    *   PackagesNetOut: the number of packets that are sent by the internal NIC used by an agent.
    *   PackagesNetIn: the number of packets that are received by the internal NIC used by an agent.
    *   EciPodCpuUtilization: the CPU utilization of an elastic container instance. Unit: %.
    *   EciPodMemoryUtilization: the memory usage of an elastic container instance. Unit: %.

For more information, see [Event-triggered task for system monitoring](~~74854~~).', example='CpuUtilization'),
      period?: int32(name='Period', description='The period during which the statistical values of the metrics that are specified in the multi-metric alert rule are collected. Unit: seconds. Valid values:

*   15
*   60
*   120
*   300
*   900

> If your scaling group is of the ECS type and uses CloudMonitor metrics, you can set the Period parameter to 15. In other cases, you can set the Period parameter to 60, 120, 300, or 900. In most cases, the name of a CloudMonitor metric contains Agent.

Default value: 300.', example='900'),
      statistics?: string(name='Statistics', description='The method that is used to aggregate statistics about the metrics that are specified in the multi-metric alert rule. Valid values:

*   Average
*   Minimum
*   Maximum

Default value: Average.', example='Average'),
      threshold?: float(name='Threshold', description='The thresholds of the metric values. If the thresholds are reached the specified number of times within the specified period, a scaling rule is executed.', example='40.0'),
    }
  ](name='Expressions', description='The expressions that are specified in the multi-metric alert rule.'),
  expressionsLogicOperator?: string(name='ExpressionsLogicOperator', description='The relationship between the trigger conditions in the multi-metric alert rule. Valid values:

*   `&&`: An alert is triggered only if all metrics in the multi-metric alert rule meet the trigger conditions. In this case, an alert is triggered only if the results of all trigger conditions that are specified in the multi-metric alert rule are `true`.
*   `||`: An alert is triggered if one of the metrics in the multi-metric alert rule meets the trigger conditions.

Default value: `&&`.', example='&&'),
  groupId?: int32(name='GroupId', description='The ID of the application group to which the custom metric belongs. If you set the MetricType parameter to custom, you must specify this parameter.', example='4055401'),
  metricName?: string(name='MetricName', description='The name of the metric. The valid values vary based on the metric type.

*   If you set the MetricType parameter to custom, the valid values are your custom metrics.

*   If you set the MetricType parameter to system, the MetricName parameter has the following valid values:

    *   CpuUtilization: the CPU utilization of an ECS instance. Unit: %.
    *   IntranetTx: the outbound traffic over the internal network from an ECS instance. Unit: KB/min.
    *   IntranetRx: the inbound traffic over the Internet to an ECS instance that resides in a virtual private cloud (VPC). Unit: KB/min.
    *   VpcInternetTx: the outbound traffic over the Internet from an ECS instance that resides in a VPC. Unit: KB/min.
    *   VpcInternetRx: the inbound traffic over the Internet to an ECS instance that resides in a VPC. Unit: KB/min.
    *   SystemDiskReadBps: the number of bytes read from the system disk used by an ECS instance per second.
    *   SystemDiskWriteBps: the number of bytes written to the system disk used by an ECS instance per second.
    *   SystemDiskReadOps: the number of read operations on the system disk used by an ECS instance per second.
    *   SystemDiskWriteOps: the number of write operations on the system disk used by an ECS instance per second.
    *   CpuUtilizationAgent: the CPU utilization of an agent. Unit: %.
    *   GpuUtilizationAgent: the GPU utilization of an agent. Unit: %.
    *   GpuMemoryFreeUtilizationAgent: the percentage of idle GPU memory of an agent.
    *   GpuMemoryUtilizationAgent: the GPU memory usage of an agent. Unit: %.
    *   MemoryUtilization: the memory usage of an agent. Unit: %.
    *   LoadAverage: the average system load of an agent.
    *   TcpConnection: the total number of TCP connections of an agent.
    *   TcpConnection: the number of established TCP connections of an agent.
    *   PackagesNetOut: the number of packets that are sent by the internal network interface controller (NIC) used by an agent.
    *   PackagesNetIn: the number of packets that are received by the internal NIC used by an agent.
    *   EciPodCpuUtilization: the CPU utilization of an elastic container instance. Unit: %.
    *   EciPodMemoryUtilization: the memory usage of an elastic container instance. Unit: %.

For more information, see [Event-triggered task for system monitoring](~~74854~~).', example='CpuUtilization'),
  metricType?: string(name='MetricType', description='The type of the metric. Valid values:

*   system: system metrics of CloudMonitor
*   custom: custom metrics that are reported to CloudMonitor', example='system'),
  name?: string(name='Name', description='The name of the event-triggered task.', example='TestAlarmTask'),
  ownerId?: long(name='OwnerId'),
  period?: int32(name='Period', description='The period during which the statistical value of the metric is collected. Unit: seconds. Valid values:

*   15
*   60
*   120
*   300
*   900

> If your scaling group is of the ECS type and uses CloudMonitor metrics, you can set the Period parameter to 15. In other cases, you can set the Period parameter to 60, 120, 300, or 900. In most cases, the name of a CloudMonitor metric contains Agent.

Default value: 300.', example='300'),
  regionId?: string(name='RegionId', description='The region ID of the scaling group.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  scalingGroupId?: string(name='ScalingGroupId', description='The scaling group ID of the event-triggered task.', example='asg-bp18p2yfxow2dloq****'),
  statistics?: string(name='Statistics', description='The method that is used to aggregate statistics for the metric. Valid values:

*   Average
*   Minimum
*   Maximum

Default value: Average.', example='Average'),
  threshold?: float(name='Threshold', description='The threshold of the metric value. If the threshold is reached the specified number of times within the specified period, a scaling rule is executed.', example='80.0'),
}

model CreateAlarmResponseBody = {
  alarmTaskId?: string(name='AlarmTaskId', description='The ID of the event-triggered task.', example='asg-bp1hvbnmkl10vll5****_f95ce797-dc2e-4bad-9618-14fee7d1****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3****'),
}

model CreateAlarmResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAlarmResponseBody(name='body'),
}

/**
  * *   If you set the MetricType parameter to custom, you must report your custom metrics to CloudMonitor before you can create event-triggered tasks by using custom metrics. For more information, see [Custom monitoring event-triggered tasks](~~74861~~).
  * *   When you create an event-triggered task, you must specify the MetricName, DimensionKey, and DimensionValue parameters to determine the range of statistics that you want to aggregate for the metrics of the scaling group. For example, you can specify the user_id and scaling_group dimensions for an event-triggered task to aggregate monitoring data of all Elastic Compute Service (ECS) instances or elastic container instances in a scaling group within an Alibaba Cloud account.
  *     *   If you set the MetricType parameter to custom, the valid values are your custom metrics.
  *     *   For information about the supported metrics when you set the MetricType parameter to system, see [Event-triggered task for system monitoring](~~74854~~).
  * > The user_id and scaling_group dimensions are automatically populated. You need to only specify the device and state dimensions. For more information, see the `DimensionKey` and `DimensionValue` parameters in the "Request parameters" section of this topic.
  *
  * @param request CreateAlarmRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateAlarmResponse
 */
async function createAlarmWithOptions(request: CreateAlarmRequest, runtime: Util.RuntimeOptions): CreateAlarmResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alarmActions)) {
    query['AlarmActions'] = request.alarmActions;
  }
  if (!Util.isUnset(request.comparisonOperator)) {
    query['ComparisonOperator'] = request.comparisonOperator;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.dimensions)) {
    query['Dimensions'] = request.dimensions;
  }
  if (!Util.isUnset(request.effective)) {
    query['Effective'] = request.effective;
  }
  if (!Util.isUnset(request.evaluationCount)) {
    query['EvaluationCount'] = request.evaluationCount;
  }
  if (!Util.isUnset(request.expressions)) {
    query['Expressions'] = request.expressions;
  }
  if (!Util.isUnset(request.expressionsLogicOperator)) {
    query['ExpressionsLogicOperator'] = request.expressionsLogicOperator;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.metricName)) {
    query['MetricName'] = request.metricName;
  }
  if (!Util.isUnset(request.metricType)) {
    query['MetricType'] = request.metricType;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.scalingGroupId)) {
    query['ScalingGroupId'] = request.scalingGroupId;
  }
  if (!Util.isUnset(request.statistics)) {
    query['Statistics'] = request.statistics;
  }
  if (!Util.isUnset(request.threshold)) {
    query['Threshold'] = request.threshold;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateAlarm',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   If you set the MetricType parameter to custom, you must report your custom metrics to CloudMonitor before you can create event-triggered tasks by using custom metrics. For more information, see [Custom monitoring event-triggered tasks](~~74861~~).
  * *   When you create an event-triggered task, you must specify the MetricName, DimensionKey, and DimensionValue parameters to determine the range of statistics that you want to aggregate for the metrics of the scaling group. For example, you can specify the user_id and scaling_group dimensions for an event-triggered task to aggregate monitoring data of all Elastic Compute Service (ECS) instances or elastic container instances in a scaling group within an Alibaba Cloud account.
  *     *   If you set the MetricType parameter to custom, the valid values are your custom metrics.
  *     *   For information about the supported metrics when you set the MetricType parameter to system, see [Event-triggered task for system monitoring](~~74854~~).
  * > The user_id and scaling_group dimensions are automatically populated. You need to only specify the device and state dimensions. For more information, see the `DimensionKey` and `DimensionValue` parameters in the "Request parameters" section of this topic.
  *
  * @param request CreateAlarmRequest
  * @return CreateAlarmResponse
 */
async function createAlarm(request: CreateAlarmRequest): CreateAlarmResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAlarmWithOptions(request, runtime);
}

model CreateEciScalingConfigurationRequest {
  acrRegistryInfos?: [ 
    {
      domains?: [ string ](name='Domains', description='The domain names of the Container Registry Enterprise Edition instances. By default, all domain names of the Container Registry Enterprise Edition instances are displayed. You can specify one or more domain names. Separate multiple domain names with commas (,).'),
      instanceId?: string(name='InstanceId', description='The ID of the Container Registry Enterprise Edition instance.', example='cri-nwj395hgf6f3****'),
      instanceName?: string(name='InstanceName', description='The name of the Container Registry Enterprise Edition instance.', example='acr-test'),
      regionId?: string(name='RegionId', description='The region ID of the Container Registry Enterprise Edition instance.', example='cn-beijing'),
    }
  ](name='AcrRegistryInfos', description='Information about the Container Registry Enterprise Edition instance.'),
  activeDeadlineSeconds?: long(name='ActiveDeadlineSeconds', description='The validity period. Unit: seconds.', example='1000'),
  autoCreateEip?: boolean(name='AutoCreateEip', description='Specifies whether to automatically create an elastic IP address (EIP) and bind the EIP to the elastic container instance.', example='true'),
  autoMatchImageCache?: boolean(name='AutoMatchImageCache', description='Specifies whether to automatically match the image cache. Valid values:

*   true
*   false

Default value: false.', example='false'),
  containerGroupName?: string(name='ContainerGroupName', description='The name of the elastic container instance.', example='nginx-test'),
  containers?: [ 
    {
      livenessProbe?: {
        exec?: {
            commands?: [ string ](name='Commands'),
        }(name='Exec'),
        failureThreshold?: int32(name='FailureThreshold'),
        httpGet?: {
            path?: string(name='Path'),
            port?: int32(name='Port'),
            scheme?: string(name='Scheme'),
        }(name='HttpGet'),
        initialDelaySeconds?: int32(name='InitialDelaySeconds'),
        periodSeconds?: int32(name='PeriodSeconds'),
        successThreshold?: int32(name='SuccessThreshold'),
        tcpSocket?: {
            port?: int32(name='Port'),
        }(name='TcpSocket'),
        timeoutSeconds?: int32(name='TimeoutSeconds'),
      }(name='LivenessProbe'),
      readinessProbe?: {
        exec?: {
            commands?: [ string ](name='Commands'),
        }(name='Exec'),
        failureThreshold?: int32(name='FailureThreshold'),
        httpGet?: {
            path?: string(name='Path'),
            port?: int32(name='Port'),
            scheme?: string(name='Scheme'),
        }(name='HttpGet'),
        initialDelaySeconds?: int32(name='InitialDelaySeconds'),
        periodSeconds?: int32(name='PeriodSeconds'),
        successThreshold?: int32(name='SuccessThreshold'),
        tcpSocket?: {
            port?: int32(name='Port'),
        }(name='TcpSocket'),
        timeoutSeconds?: int32(name='TimeoutSeconds'),
      }(name='ReadinessProbe'),
      securityContext?: {
        capability?: {
            add?: [ string ](name='Add'),
        }(name='Capability'),
        readOnlyRootFilesystem?: boolean(name='ReadOnlyRootFilesystem'),
        runAsUser?: long(name='RunAsUser'),
      }(name='SecurityContext'),
      args?: [ string ](name='Args', description='The arguments that correspond to the startup commands of the container. You can specify up to 10 arguments.'),
      commands?: [ string ](name='Commands', description='The commands that you want to run in the container when you use the CLI to perform probes.'),
      cpu?: float(name='Cpu', description='The number of CPU cores in the container.', example='0.25'),
      environmentVars?: [ 
        {
          fieldRefFieldPath?: string(name='FieldRefFieldPath', description='> This parameter is unavailable.', example='fieldPath'),
          key?: string(name='Key', description='The name of the environment variable. The name must be 1 to 128 characters in length and can contain letters, digits, and underscores (\\_). The name cannot start with a digit. Specify the name in the \\[0-9a-zA-Z] format.', example='PATH'),
          value?: string(name='Value', description='The value of the environment variable. The value must be 0 to 256 characters in length.', example='/usr/local/bin'),
        }
      ](name='EnvironmentVars', description='Information about environment variables.'),
      gpu?: int32(name='Gpu', description='The number of GPUs that you want to allocate to the container.', example='1'),
      image?: string(name='Image', description='The image of the container.', example='registry-vpc.cn-hangzhou.aliyuncs.com/eci_open/nginx:latest'),
      imagePullPolicy?: string(name='ImagePullPolicy', description='The image pulling policy. Valid values:

*   Always: pulls images each time.
*   IfNotPresent: pulls images only if no on-premises images are available. On-premises images are preferentially used. If no on-premises images are available, image pulling is performed.
*   Never: never pulls images. On-premises images are always used.', example='Always'),
      memory?: float(name='Memory', description='The memory size of the container. Unit: GiB.', example='0.5'),
      name?: string(name='Name', description='The name of the container image.', example='nginx'),
      ports?: [ 
        {
          port?: int32(name='Port', description='The port number. Valid values: 1 to 65535.', example='80'),
          protocol?: string(name='Protocol', description='The type of the protocol. Valid values:

*   TCP
*   UDP', example='TCP'),
        }
      ](name='Ports', description='The ports.'),
      stdin?: boolean(name='Stdin', description='Specifies whether the container allocates buffer resources to standard input streams when the container is running. If you do not specify this parameter, an end-of-file (EOF) error may occur.

Default value: false.', example='false'),
      stdinOnce?: boolean(name='StdinOnce', description='Specifies whether to disconnect standard input streams after a client is disconnected.

If you set the StdinOnce parameter to true, standard input streams are connected after the container is started, and remain idle until a client is connected to receive data. After the client is disconnected, streams are also disconnected, and remain disconnected until the container is started again.', example='false'),
      tty?: boolean(name='Tty', description='Specifies whether to enable interaction. Valid values:

*   true
*   false

If the value of the Command parameter is /bin/bash, you must set this parameter to true.

Default value: false.', example='false'),
      volumeMounts?: [ 
        {
          mountPath?: string(name='MountPath', description='The directory on which the container mounts the volume.

> Data in this directory is overwritten by the data on the volume.', example='/pod/data'),
          mountPropagation?: string(name='MountPropagation', description='The mount propagation settings of the volume. Mount propagation allows volumes that are mounted on one container to be shared with other containers in the same pod, or even with other pods on the same node. Valid values:

*   None: The volume mount does not receive subsequent mounts that are mounted to this volume or its subdirectories.
*   HostToCotainer: The volume mount receives all subsequent mounts that are mounted to this volume or its subdirectories.
*   Bidirectional: This value is similar to HostToCotainer. The volume mount receives all subsequent mounts that are mounted to this volume or its subdirectories. In addition, all volume mounts that are created by the container are propagated back to the instance and to all containers of all pods that use the same volume.

Default value: None.', example='None'),
          name?: string(name='Name', description='The name of the volume. The value of this parameter is the same as the value of the VolumeName parameter.', example='default-volume1'),
          readOnly?: boolean(name='ReadOnly', description='Specifies whether the volume is read-only. Valid values:

*   true
*   false

Default value: false.', example='false'),
          subPath?: string(name='SubPath', description='The subdirectory of the volume.', example='data2/'),
        }
      ](name='VolumeMounts', description='Information about the volume mount of the container.'),
      workingDir?: string(name='WorkingDir', description='The working directory of the container.', example='/usr/local/'),
    }
  ](name='Containers', description='The containers in the elastic container instance.'),
  costOptimization?: boolean(name='CostOptimization', description='Specifies whether to enable the cost optimization feature. Valid values:

*   true
*   false', example='false'),
  cpu?: float(name='Cpu', description='The number of vCPUs of the elastic container instance.', example='1.0'),
  cpuOptionsCore?: int32(name='CpuOptionsCore', description='Number of physical CPU cores This parameter is not available for all instance types. For more information, see [Specify custom CPU options](~~197781~~).', example='2'),
  cpuOptionsThreadsPerCore?: int32(name='CpuOptionsThreadsPerCore', description='The number of threads per core. This parameter is not available for all instance types. A value of 1 indicates that Hyper-Threading is disabled. For more information, see [Specify custom CPU options](~~197781~~).', example='2'),
  description?: string(name='Description', description='> This parameter is unavailable.', example='desc'),
  dnsConfigNameServers?: [ string ](name='DnsConfigNameServers', description='The IP addresses of the DNS servers.'),
  dnsConfigOptions?: [ 
    {
      name?: string(name='Name', description='The variable name of the option.', example='name'),
      value?: string(name='Value', description='The variable value of the option.', example='value'),
    }
  ](name='DnsConfigOptions', description='The options. Each option is in the name-value pair format. The value in the name-value pair is optional.'),
  dnsConfigSearchs?: [ string ](name='DnsConfigSearchs', description='The DNS lookup domains.'),
  dnsPolicy?: string(name='DnsPolicy', description='The Domain Name System (DNS) policy. Valid values:

*   None: uses the DNS that is set for the DnsConfig field.
*   Default: use the DNS that is set for the runtime environment.', example='Default'),
  egressBandwidth?: long(name='EgressBandwidth', description='The maximum outbound bandwidth. Unit: bytes.', example='1024000'),
  eipBandwidth?: int32(name='EipBandwidth', description='The bandwidth of the EIP. Default value: 5 Mbit/s.', example='5'),
  enableSls?: boolean(name='EnableSls', description='> This parameter is unavailable.', example='false'),
  ephemeralStorage?: int32(name='EphemeralStorage', description='The size of the temporary storage space. By default, an ESSD of the PL1 type is used. Unit: GiB.', example='20'),
  hostAliases?: [ 
    {
      hostnames?: [ string ](name='Hostnames', description='The hostname that you want to add.'),
      ip?: string(name='Ip', description='The IP address that you want to add.', example='1.1.1.1'),
    }
  ](name='HostAliases', description='The hostnames and IP addresses of a container that you want to add to the hosts file of the elastic container instance.'),
  hostName?: string(name='HostName', description='The name of the elastic container instance.', example='test'),
  imageRegistryCredentials?: [ 
    {
      password?: string(name='Password', description='The password that is used to access the image repository.', example='yourpaasword'),
      server?: string(name='Server', description='The domain name of the image repository.', example='registry-vpc.cn-shanghai.aliyuncs.com'),
      userName?: string(name='UserName', description='The username that is used to access the image repository.', example='yourusername'),
    }
  ](name='ImageRegistryCredentials', description='Information about the image repository.'),
  imageSnapshotId?: string(name='ImageSnapshotId', description='The ID of the image cache.', example='imc-2zebxkiifuyzzlhl****'),
  ingressBandwidth?: long(name='IngressBandwidth', description='The maximum inbound bandwidth. Unit: bit/s.', example='1024000'),
  initContainers?: [ 
    {
      securityContext?: {
        capability?: {
            adds?: [ string ](name='Adds'),
        }(name='Capability'),
        readOnlyRootFilesystem?: boolean(name='ReadOnlyRootFilesystem'),
        runAsUser?: long(name='RunAsUser'),
      }(name='SecurityContext'),
      args?: [ string ](name='Args', description='The arguments that correspond to the startup commands of the container. You can specify up to 10 arguments.'),
      commands?: [ string ](name='Commands', description='The list of commands that you want to run to start the container.'),
      cpu?: float(name='Cpu', description='The number of vCPUs that you want to allocate to the container.', example='0.5'),
      gpu?: int32(name='Gpu', description='The number of GPUs that you want to allocate to the container.', example='1'),
      image?: string(name='Image', description='The container image.', example='nginx'),
      imagePullPolicy?: string(name='ImagePullPolicy', description='The image pulling policy.', example='Always'),
      initContainerEnvironmentVars?: [ 
        {
          fieldRefFieldPath?: string(name='FieldRefFieldPath', description='> This parameter is unavailable.', example='path'),
          key?: string(name='Key', description='The key of the environment variable. Specify the key in the `[0-9a-zA-Z]` format. The key must be 1 to 128 characters in length. The key can contain underscores (\\_) and cannot start with a digit.', example='Path'),
          value?: string(name='Value', description='The value of the environment variable. The value must be 0 to 256 characters in length.', example='/usr/bin/'),
        }
      ](name='InitContainerEnvironmentVars', description='The environment variables of the init container.'),
      initContainerPorts?: [ 
        {
          port?: int32(name='Port', description='The port number. Valid values: 1 to 65535.', example='1'),
          protocol?: string(name='Protocol', description='The type of the protocol. Valid values:

*   TCP
*   UDP', example='TCP'),
        }
      ](name='InitContainerPorts', description='The ports of the init container.'),
      initContainerVolumeMounts?: [ 
        {
          mountPath?: string(name='MountPath', description='The path to which the volume is mounted. Data under this path is overwritten by the data on the volume.', example='/usr/share/'),
          mountPropagation?: string(name='MountPropagation', description='The mount propagation settings of the volume . Mount propagation allows volumes that are mounted on one container to be shared with other containers in the same pod, or even with other pods on the same node. Valid values:

*   None: The volume mount does not receive subsequent mounts that are mounted to this volume or its subdirectories.
*   HostToCotainer: The volume mount receives all subsequent mounts that are mounted to this volume or its subdirectories.
*   Bidirectional: This value is similar to HostToCotainer. The volume mount receives all subsequent mounts that are mounted to this volume or its subdirectories. In addition, all volume mounts that are created by the container are propagated back to the instance and to all containers of all pods that use the same volume.', example='None'),
          name?: string(name='Name', description='The name of the volume.', example='test-empty'),
          readOnly?: boolean(name='ReadOnly', description='Specifies whether the mount path is read-only.

Default value: false.', example='false'),
          subPath?: string(name='SubPath', description='The subdirectory of the volume. The elastic container instance can mount different directories of the same volume to different subdirectories of containers.', example='/usr/sub/'),
        }
      ](name='InitContainerVolumeMounts', description='Information about the volume mounts of the init container.'),
      memory?: float(name='Memory', description='The size of the memory. Unit: GiB.', example='1.0'),
      name?: string(name='Name', description='The name of the container.', example='test-init'),
      workingDir?: string(name='WorkingDir', description='The working directory.', example='/usr/local'),
    }
  ](name='InitContainers', description='The init containers.'),
  instanceFamilyLevel?: string(name='InstanceFamilyLevel', description='The level of the instance type, which is used to filter the instance types that meet the specified criteria. This parameter takes effect only if you set the `CostOptimization` parameter to true. Valid values:

*   EntryLevel: shared instance type. Instances of this level are the most cost-effective but may not provide stable computing performance in a consistent manner. Instances of this level are suitable for business scenarios in which the CPU utilization is low. For more information, see [Shared instance families](~~108489~~).
*   EnterpriseLevel: Instances of this level provide stable performance and dedicated resources, and are suitable for business scenarios that require high stability. For more information, see [Instance family](~~25378~~).
*   CreditEntryLevel: This value is valid only for burstable instances. CPU credits are used to ensure computing performance. Instances of this level are suitable for scenarios in which the CPU utilization is low but may fluctuate in specific cases. For more information, see the [Overview](~~59977~~) topic of burstable instances.', example='EnterpriseLevel'),
  ipv6AddressCount?: int32(name='Ipv6AddressCount', description='The number of IPv6 addresses.', example='1'),
  loadBalancerWeight?: int32(name='LoadBalancerWeight', description='The weight of the elastic container instance as a backend server. Valid values: 1 to 100.

Default value: 50.', example='50'),
  memory?: float(name='Memory', description='The memory size of the elastic container instance. Unit: GiB.', example='2.0'),
  ntpServers?: [ string ](name='NtpServers', description='The domain name of the Network Time Protocol (NTP) server.'),
  ownerId?: long(name='OwnerId'),
  ramRoleName?: string(name='RamRoleName', description='The name of the RAM role for the elastic container instance. You can use an instance RAM role to access both elastic container instances and Elastic Compute Service (ECS) instances. For more information, see [Use an instance RAM role by calling API operations](~~61178~~).', example='RamTestRole'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-uf66jeqopgqa9hdn****'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  restartPolicy?: string(name='RestartPolicy', description='The restart policy of the elastic container instance. Valid values:

*   Always: always restarts the elastic container instance.
*   Never: never restarts the elastic container instance.
*   OnFailure: restarts the elastic container instance upon failures.

Default value: Always.', example='Always'),
  scalingConfigurationName?: string(name='ScalingConfigurationName', description='The name of the scaling configuration. The name must be 2 to 64 characters in length, and can contain letters, digits, underscores (\\_), hyphens (-), and periods (.). The name must start with a letter or a digit.

The name of the scaling configuration must be unique within a scaling group in a region. If you do not specify this parameter, the value of the ScalingConfigurationId parameter is used.', example='scalingconfig****'),
  scalingGroupId?: string(name='ScalingGroupId', description='The ID of the scaling group in which you want to create the scaling configuration.', example='asg-bp14wlu85wrpchm0****'),
  securityContextSysctls?: [ 
    {
      name?: string(name='Name', description='The variable name of the security context in which the elastic container instance runs.', example='kernel.msgmax'),
      value?: string(name='Value', description='The variable value of the security context in which the elastic container instance runs.', example='65536'),
    }
  ](name='SecurityContextSysctls', description='The system information of the security context in which the elastic container instance runs.'),
  securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group with which you want to associate the elastic container instance. Elastic container instances that are associated with the same security group can access each other.

If you do not specify a security group, the system uses the default security group in the region that you selected. Make sure that the inbound rules of the security group contain the protocols and the port numbers of the containers that you want to expose. If you do not have a default security group in the region, the system creates a default security group, and then adds the declared container protocols and port numbers to the inbound rules of the security group.', example='sg-uf66jeqopgqa9hdn****'),
  spotPriceLimit?: float(name='SpotPriceLimit', description='The maximum hourly price of the preemptible elastic container instance. The value can be accurate to three decimal places.

If you set the SpotStrategy parameter to SpotWithPriceLimit, you must also specify the SpotPriceLimit parameter.', example='0.025'),
  spotStrategy?: string(name='SpotStrategy', description='The bidding policy for the elastic container instance. Valid values:

*   NoSpot: The instance is a pay-as-you-go instance.
*   SpotWithPriceLimit: The instance is a preemptible instance with a user-defined maximum hourly price.
*   SpotAsPriceGo: The instance is a preemptible instance for which the market price at the time of purchase is used as the bid price.

Default value: NoSpot.', example='SpotPriceLimit'),
  tags?: [ 
    {
      key?: string(name='Key', description='The tag key of the elastic container instance. You can specify 1 to 20 tags.

You cannot specify an empty string as a tag key. The tag key can be up to 128 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.', example='version'),
      value?: string(name='Value', description='The tag value of the elastic container instance. You can specify 1 to 20 tags.

You can specify an empty string as a tag value. The tag value can be up to 128 characters in length and cannot start with `acs:`. It cannot contain `http://` or `https://`.', example='3'),
    }
  ](name='Tags', description='The tags of the elastic container instance. The tags must be specified in the key-value pair format. You can specify up to 20 tags. When you specify tag keys and tag values, take note of the following items:

*   A tag key can be up to 64 characters in length. The key cannot start with acs: or aliyun and cannot contain `http://` or `https://`. You cannot specify an empty string as a tag key.
*   A tag value can be up to 128 characters in length. The value cannot start with acs: or aliyun and cannot contain `http://` or `https://`. You can specify an empty string as a tag value.'),
  terminationGracePeriodSeconds?: long(name='TerminationGracePeriodSeconds', description='The buffer time in which the program handles operations before the program is stopped. Unit: seconds.', example='60'),
  volumes?: [ 
    {
      diskVolume?: {
        diskId?: string(name='DiskId'),
        diskSize?: int32(name='DiskSize'),
        fsType?: string(name='FsType'),
      }(name='DiskVolume'),
      emptyDirVolume?: {
        medium?: string(name='Medium'),
      }(name='EmptyDirVolume'),
      flexVolume?: {
        driver?: string(name='Driver'),
        fsType?: string(name='FsType'),
        options?: string(name='Options'),
      }(name='FlexVolume'),
      hostPathVolume?: {
        path?: string(name='Path'),
        type?: string(name='Type'),
      }(name='HostPathVolume'),
      NFSVolume?: {
        path?: string(name='Path'),
        readOnly?: boolean(name='ReadOnly'),
        server?: string(name='Server'),
      }(name='NFSVolume'),
      configFileVolumeConfigFileToPaths?: [ 
        {
          content?: string(name='Content', description='The content of the configuration file, which can be up to 32 KB in size.', example='bGl1bWk='),
          mode?: int32(name='Mode', description='The permissions on ConfigFileVolume.', example='0644'),
          path?: string(name='Path', description='The name of the environment variable. The name must be 1 to 128 characters in length. Specify the name in the `[0-9a-zA-Z]` format. The name can contain underscores and cannot start with a digit.', example='PATH'),
        }
      ](name='ConfigFileVolumeConfigFileToPaths', description='The paths to the configuration files.'),
      configFileVolumeDefaultMode?: int32(name='ConfigFileVolumeDefaultMode', description='The default permissions on the ConfigFile volume.', example='0644'),
      name?: string(name='Name', description='The name of the volume.', example='default-volume1'),
      type?: string(name='Type', description='The type of the Host file or path. Examples: File, Directory, and Socket.', example='ConfigFileVolume'),
    }
  ](name='Volumes', description='Information about the volumes.'),
}

model CreateEciScalingConfigurationResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='89945DD3-9072-47D0-A318-353284CF****'),
  scalingConfigurationId?: string(name='ScalingConfigurationId', description='The ID of the elastic container instance.', example='eci-uf6fonnghi50u374****'),
}

model CreateEciScalingConfigurationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateEciScalingConfigurationResponseBody(name='body'),
}

/**
  * A scaling configuration is a template that is used to create elastic container instances during scale-out activities.
  * You can specify the Cpu and Memory parameters to determine the range of instance types. If you specify the parameters, Auto Scaling determines the available instance types based on factors such as I/O optimization requirements and zones. Auto Scaling preferentially creates elastic container instances of the instance type that is provided at the lowest price. This scaling mode is available only if Scaling Policy is set to Cost Optimization Policy and no instance type is specified in the scaling configuration.
  *
  * @param request CreateEciScalingConfigurationRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateEciScalingConfigurationResponse
 */
async function createEciScalingConfigurationWithOptions(request: CreateEciScalingConfigurationRequest, runtime: Util.RuntimeOptions): CreateEciScalingConfigurationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acrRegistryInfos)) {
    query['AcrRegistryInfos'] = request.acrRegistryInfos;
  }
  if (!Util.isUnset(request.activeDeadlineSeconds)) {
    query['ActiveDeadlineSeconds'] = request.activeDeadlineSeconds;
  }
  if (!Util.isUnset(request.autoCreateEip)) {
    query['AutoCreateEip'] = request.autoCreateEip;
  }
  if (!Util.isUnset(request.autoMatchImageCache)) {
    query['AutoMatchImageCache'] = request.autoMatchImageCache;
  }
  if (!Util.isUnset(request.containerGroupName)) {
    query['ContainerGroupName'] = request.containerGroupName;
  }
  if (!Util.isUnset(request.containers)) {
    query['Containers'] = request.containers;
  }
  if (!Util.isUnset(request.costOptimization)) {
    query['CostOptimization'] = request.costOptimization;
  }
  if (!Util.isUnset(request.cpu)) {
    query['Cpu'] = request.cpu;
  }
  if (!Util.isUnset(request.cpuOptionsCore)) {
    query['CpuOptionsCore'] = request.cpuOptionsCore;
  }
  if (!Util.isUnset(request.cpuOptionsThreadsPerCore)) {
    query['CpuOptionsThreadsPerCore'] = request.cpuOptionsThreadsPerCore;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.dnsConfigNameServers)) {
    query['DnsConfigNameServers'] = request.dnsConfigNameServers;
  }
  if (!Util.isUnset(request.dnsConfigOptions)) {
    query['DnsConfigOptions'] = request.dnsConfigOptions;
  }
  if (!Util.isUnset(request.dnsConfigSearchs)) {
    query['DnsConfigSearchs'] = request.dnsConfigSearchs;
  }
  if (!Util.isUnset(request.dnsPolicy)) {
    query['DnsPolicy'] = request.dnsPolicy;
  }
  if (!Util.isUnset(request.egressBandwidth)) {
    query['EgressBandwidth'] = request.egressBandwidth;
  }
  if (!Util.isUnset(request.eipBandwidth)) {
    query['EipBandwidth'] = request.eipBandwidth;
  }
  if (!Util.isUnset(request.enableSls)) {
    query['EnableSls'] = request.enableSls;
  }
  if (!Util.isUnset(request.ephemeralStorage)) {
    query['EphemeralStorage'] = request.ephemeralStorage;
  }
  if (!Util.isUnset(request.hostAliases)) {
    query['HostAliases'] = request.hostAliases;
  }
  if (!Util.isUnset(request.hostName)) {
    query['HostName'] = request.hostName;
  }
  if (!Util.isUnset(request.imageRegistryCredentials)) {
    query['ImageRegistryCredentials'] = request.imageRegistryCredentials;
  }
  if (!Util.isUnset(request.imageSnapshotId)) {
    query['ImageSnapshotId'] = request.imageSnapshotId;
  }
  if (!Util.isUnset(request.ingressBandwidth)) {
    query['IngressBandwidth'] = request.ingressBandwidth;
  }
  if (!Util.isUnset(request.initContainers)) {
    query['InitContainers'] = request.initContainers;
  }
  if (!Util.isUnset(request.instanceFamilyLevel)) {
    query['InstanceFamilyLevel'] = request.instanceFamilyLevel;
  }
  if (!Util.isUnset(request.ipv6AddressCount)) {
    query['Ipv6AddressCount'] = request.ipv6AddressCount;
  }
  if (!Util.isUnset(request.loadBalancerWeight)) {
    query['LoadBalancerWeight'] = request.loadBalancerWeight;
  }
  if (!Util.isUnset(request.memory)) {
    query['Memory'] = request.memory;
  }
  if (!Util.isUnset(request.ntpServers)) {
    query['NtpServers'] = request.ntpServers;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.ramRoleName)) {
    query['RamRoleName'] = request.ramRoleName;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.restartPolicy)) {
    query['RestartPolicy'] = request.restartPolicy;
  }
  if (!Util.isUnset(request.scalingConfigurationName)) {
    query['ScalingConfigurationName'] = request.scalingConfigurationName;
  }
  if (!Util.isUnset(request.scalingGroupId)) {
    query['ScalingGroupId'] = request.scalingGroupId;
  }
  if (!Util.isUnset(request.securityContextSysctls)) {
    query['SecurityContextSysctls'] = request.securityContextSysctls;
  }
  if (!Util.isUnset(request.securityGroupId)) {
    query['SecurityGroupId'] = request.securityGroupId;
  }
  if (!Util.isUnset(request.spotPriceLimit)) {
    query['SpotPriceLimit'] = request.spotPriceLimit;
  }
  if (!Util.isUnset(request.spotStrategy)) {
    query['SpotStrategy'] = request.spotStrategy;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  if (!Util.isUnset(request.terminationGracePeriodSeconds)) {
    query['TerminationGracePeriodSeconds'] = request.terminationGracePeriodSeconds;
  }
  if (!Util.isUnset(request.volumes)) {
    query['Volumes'] = request.volumes;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateEciScalingConfiguration',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * A scaling configuration is a template that is used to create elastic container instances during scale-out activities.
  * You can specify the Cpu and Memory parameters to determine the range of instance types. If you specify the parameters, Auto Scaling determines the available instance types based on factors such as I/O optimization requirements and zones. Auto Scaling preferentially creates elastic container instances of the instance type that is provided at the lowest price. This scaling mode is available only if Scaling Policy is set to Cost Optimization Policy and no instance type is specified in the scaling configuration.
  *
  * @param request CreateEciScalingConfigurationRequest
  * @return CreateEciScalingConfigurationResponse
 */
async function createEciScalingConfiguration(request: CreateEciScalingConfigurationRequest): CreateEciScalingConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  return createEciScalingConfigurationWithOptions(request, runtime);
}

model CreateLifecycleHookRequest {
  defaultResult?: string(name='DefaultResult', description='The action that you want Auto Scaling to perform after the lifecycle hook times out. Valid values:

*   CONTINUE: Auto Scaling continues to respond to scale-in or scale-out requests.
*   ABANDON: Auto Scaling releases Elastic Compute Service (ECS) instances that are created during scale-out activities, or removes ECS instances from the scaling group during scale-in activities.

If multiple lifecycle hooks in a scaling group are triggered during scale-in activities and you set the DefaultResult parameter to ABANDON for one of the lifecycle hooks, Auto Scaling immediately performs the action after the lifecycle hook whose DefaultResult is set to ABANDON times out. As a result, other lifecycle hooks time out ahead of schedule. In other cases, Auto Scaling performs the action only after all lifecycle hooks time out.

Default value: CONTINUE.', example='CONTINUE'),
  heartbeatTimeout?: int32(name='HeartbeatTimeout', description='The period of time before the lifecycle hook times out. After the lifecycle hook times out, Auto Scaling performs the default action. Valid values: 30 to 21600. Unit: seconds.

After you create a lifecycle hook, you can call the RecordLifecycleActionHeartbeat operation to prolong the timeout period of the lifecycle hook. You can also call the CompleteLifecycleAction operation to end the timeout period of the lifecycle hook ahead of schedule.

Default value: 600.', example='600'),
  lifecycleHookName?: string(name='LifecycleHookName', description='The name of the lifecycle hook. Each lifecycle hook name must be unique within a scaling group. The name must be 2 to 64 characters in length, and can contain letters, digits, underscores (\\_), hyphens (-), and periods (.). It must start with a letter or a digit.

If you do not specify this parameter, the value of the LifecycleHookId parameter is used.', example='lifecyclehook****'),
  lifecycleTransition?: string(name='LifecycleTransition', description='The type of the scaling activity to which the lifecycle hook applies. Valid values:

*   SCALE_OUT
*   SCALE_IN', example='SCALE_OUT'),
  notificationArn?: string(name='NotificationArn', description='The Alibaba Cloud Resource Name (ARN) of the notification method that is used by Auto Scaling to send notifications when the lifecycle hook takes effect. If you do not specify this parameter, no notification is sent when the lifecycle hook takes effect. If you specify this parameter, the following rules apply:

*   If you use a Message Service (MNS) queue as the notification method, specify the value in the acs:mns:{region-id}:{account-id}:queue/{queuename} format.
*   If you use an MNS topic as the notification method, specify the value in the acs:mns:{region-id}:{account-id}:topic/{topicname} format.
*   If you use an OOS template as the notification method, specify the value in the acs:oos:{region-id}:{account-id}:template/{templatename} format.

The variables in the preceding parameter formats have the following meanings:

*   region-id: the region ID of the scaling group.
*   account-id: the ID of the Alibaba Cloud account. The ID of the RAM user is not supported.
*   queuename: the name of the MNS queue.
*   topicname: the name of the MNS topic.
*   templatename: the name of the OOS template.', example='acs:mns:cn-beijing:161456884340****:queue/modifyLifecycleHo****'),
  notificationMetadata?: string(name='NotificationMetadata', description='The notification metadata that is sent when the lifecycle hook takes effect. This helps you manage and categorize notifications in an efficient manner. If you specify this parameter, you must specify the NotificationArn parameter. The parameter value cannot exceed 4,096 characters in length.

If you use the NotificationArn parameter to specify a public or customOOS template, the value of the NotificationMetadata parameter must be a JSON string that contains the OOS template parameters. For example, your OOS template includes the following parameters: `{"dbInstanceId": "dds-bp17661e0135****", "modifyMode": "Append"}`, `dbInstanceId`, and `modifyMode`. Some parameters defined in your OOS template have default values. When you specify the NotificationMetadata parameter, specify parameters that do not have default values. If you specify parameters that have default values, the default values are overwritten. However, the default values of the following parameters must be retained to obtain information about scaling activities that are in progress:

*   `regionId`: the region ID of the scaling activity that is in progress. Default value: ${regionId}.
*   `instanceIds`: the IDs of ECS instances that are scaled in in the scaling activity. Default value: ${instanceIds}.
*   `lifecycleHookId`: the ID of the lifecycle hook. Default value: ${lifecycleHookId}.
*   `lifecycleActionToken`: the token of the lifecycle action. You can use the token to end the timeout period of the lifecycle hook ahead of schedule. Default value: ${lifecycleActionToken}
*   `scalingGroupId`: the ID of the scaling group in which the scaling activity is executed. Default value: ${scalingGroupId}.

> You can obtain template parameter information in the [OOS console](https://oos.console.aliyun.com/).', example='Test lifecycle hook.'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  scalingGroupId?: string(name='ScalingGroupId', description='The ID of the scaling group.', example='asg-bp1eyv4qn8ssgv43****'),
}

model CreateLifecycleHookResponseBody = {
  lifecycleHookId?: string(name='LifecycleHookId', description='The ID of the lifecycle hook.', example='ash-bp1at9ufhmcf9cmy****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
}

model CreateLifecycleHookResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateLifecycleHookResponseBody(name='body'),
}

/**
  * You can create up to six lifecycle hooks for each scaling group. After a lifecycle hook is created for a scaling group, Elastic Compute Service (ECS) instances in the scaling group waits to be added to or removed from the scaling group during scaling activities. You can use the HeartbeatTimeout parameter to specify the timeout period of the lifecycle hook. During the timeout period of a lifecycle hook, you can perform custom operations such as initialize ECS instance configurations and download ECS instance data on the ECS instances for which the lifecycle hook is applied.
  * During a scale-out activity and the timeout period of a lifecycle hook, the private IP addresses of ECS instances wait to be added to the associated whitelist that manages access to the ApsaraDB RDS instance. The ECS instances also wait to be added to the backend server group of the associated Classic Load Balancer (CLB) instance. After the lifecycle hook times out, the private IP addresses of the ECS instances are added to the whitelist that manages access to the associated ApsaraDB RDS instance. The ECS instances are also added to the backend server group of the associated CLB instance. During a scale-in activity and the timeout period of a lifecycle hook, the private IP addresses of ECS instances wait to be removed from the whitelist that manages access to the associated ApsaraDB RDS instance. The ECS instances also wait to be removed from the backend server group of the associated CLB instance. After the lifecycle hook times out, the private IP addresses of the ECS instances are removed from the whitelist that manages access to the associated ApsaraDB RDS instance. The ECS instances are also removed from the backend server group of the associated CLB instance.
  * You can configure a notification method for a lifecycle hook. When the lifecycle hook is triggered, a notification can be sent to the specified Message Service (MNS) topic or queue, or an operation can be performed based on the specified Operation Orchestration Service (OOS) template. If you want to configure an OOS template, you must create a Resource Access Management (RAM) role for OOS. For more information, see [Grant RAM permissions to OOS](~~120810~~).
  * > If your scaling group has existing ECS instances and you configured an OOS template that is used to add the private IP addresses of ECS instances to or remove the private IP addresses of ECS instances from the whitelists that manage access to cloud databases that are not ApsaraDB RDS databases, you must manually add the private IP addresses of the ECS instances to or remove the private IP addresses of the ECS instances from the whitelists that manage access to the cloud databases.
  *
  * @param request CreateLifecycleHookRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateLifecycleHookResponse
 */
async function createLifecycleHookWithOptions(request: CreateLifecycleHookRequest, runtime: Util.RuntimeOptions): CreateLifecycleHookResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.defaultResult)) {
    query['DefaultResult'] = request.defaultResult;
  }
  if (!Util.isUnset(request.heartbeatTimeout)) {
    query['HeartbeatTimeout'] = request.heartbeatTimeout;
  }
  if (!Util.isUnset(request.lifecycleHookName)) {
    query['LifecycleHookName'] = request.lifecycleHookName;
  }
  if (!Util.isUnset(request.lifecycleTransition)) {
    query['LifecycleTransition'] = request.lifecycleTransition;
  }
  if (!Util.isUnset(request.notificationArn)) {
    query['NotificationArn'] = request.notificationArn;
  }
  if (!Util.isUnset(request.notificationMetadata)) {
    query['NotificationMetadata'] = request.notificationMetadata;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.scalingGroupId)) {
    query['ScalingGroupId'] = request.scalingGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateLifecycleHook',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can create up to six lifecycle hooks for each scaling group. After a lifecycle hook is created for a scaling group, Elastic Compute Service (ECS) instances in the scaling group waits to be added to or removed from the scaling group during scaling activities. You can use the HeartbeatTimeout parameter to specify the timeout period of the lifecycle hook. During the timeout period of a lifecycle hook, you can perform custom operations such as initialize ECS instance configurations and download ECS instance data on the ECS instances for which the lifecycle hook is applied.
  * During a scale-out activity and the timeout period of a lifecycle hook, the private IP addresses of ECS instances wait to be added to the associated whitelist that manages access to the ApsaraDB RDS instance. The ECS instances also wait to be added to the backend server group of the associated Classic Load Balancer (CLB) instance. After the lifecycle hook times out, the private IP addresses of the ECS instances are added to the whitelist that manages access to the associated ApsaraDB RDS instance. The ECS instances are also added to the backend server group of the associated CLB instance. During a scale-in activity and the timeout period of a lifecycle hook, the private IP addresses of ECS instances wait to be removed from the whitelist that manages access to the associated ApsaraDB RDS instance. The ECS instances also wait to be removed from the backend server group of the associated CLB instance. After the lifecycle hook times out, the private IP addresses of the ECS instances are removed from the whitelist that manages access to the associated ApsaraDB RDS instance. The ECS instances are also removed from the backend server group of the associated CLB instance.
  * You can configure a notification method for a lifecycle hook. When the lifecycle hook is triggered, a notification can be sent to the specified Message Service (MNS) topic or queue, or an operation can be performed based on the specified Operation Orchestration Service (OOS) template. If you want to configure an OOS template, you must create a Resource Access Management (RAM) role for OOS. For more information, see [Grant RAM permissions to OOS](~~120810~~).
  * > If your scaling group has existing ECS instances and you configured an OOS template that is used to add the private IP addresses of ECS instances to or remove the private IP addresses of ECS instances from the whitelists that manage access to cloud databases that are not ApsaraDB RDS databases, you must manually add the private IP addresses of the ECS instances to or remove the private IP addresses of the ECS instances from the whitelists that manage access to the cloud databases.
  *
  * @param request CreateLifecycleHookRequest
  * @return CreateLifecycleHookResponse
 */
async function createLifecycleHook(request: CreateLifecycleHookRequest): CreateLifecycleHookResponse {
  var runtime = new Util.RuntimeOptions{};
  return createLifecycleHookWithOptions(request, runtime);
}

model CreateNotificationConfigurationRequest {
  notificationArn?: string(name='NotificationArn', description='The types of the notifications that you want to create. You can create one to eight notifications. Specify multiple values in the repeated list form.

You can call the DescribeNotificationTypes operation to query the values of this parameter.', example='acs:mns:cn-beijing:161456884340****:queue/modifyLifecycleHo****'),
  notificationTypes?: [ string ](name='NotificationTypes', description='The types of the notifications that you want to create. You can create one to eight notifications. Specify multiple values in the repeated list form.

You can call the DescribeNotificationTypes operation to query the values of this parameter.'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The ID of the request.', example='cn-beijing'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  scalingGroupId?: string(name='ScalingGroupId', description='The Alibaba Cloud Resource Name (ARN) of the notification method. The following list describes the value formats of this parameter:

*   If you use CloudMonitor as the notification method, the value format of this parameter is acs:ess:{region-id}:{account-id}:cloudmonitor.
*   If you use an MNS queue as the notification method, the value format of this parameter is acs:mns:{region-id}:{account-id}:queue/{queuename}.
*   If you use an MNS topic as the notification method, the value format of this parameter is acs:mns:{region-id}:{account-id}:topic/{topicname}.

The variables in the preceding formats have the following meanings:

*   region-id: the region ID of the scaling group.
*   account-id: the ID of the Alibaba Cloud account.
*   queuename: the name of the MNS queue.
*   topicname: the name of the MNS topic.', example='asg-bp1igpak5ft1flyp****'),
}

model CreateNotificationConfigurationResponseBody = {
  requestId?: string(name='RequestId', description='auditing', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3****'),
}

model CreateNotificationConfigurationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateNotificationConfigurationResponseBody(name='body'),
}

/**
  * Creates a notification.
  *
  * @param request CreateNotificationConfigurationRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateNotificationConfigurationResponse
 */
async function createNotificationConfigurationWithOptions(request: CreateNotificationConfigurationRequest, runtime: Util.RuntimeOptions): CreateNotificationConfigurationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.notificationArn)) {
    query['NotificationArn'] = request.notificationArn;
  }
  if (!Util.isUnset(request.notificationTypes)) {
    query['NotificationTypes'] = request.notificationTypes;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.scalingGroupId)) {
    query['ScalingGroupId'] = request.scalingGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateNotificationConfiguration',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Creates a notification.
  *
  * @param request CreateNotificationConfigurationRequest
  * @return CreateNotificationConfigurationResponse
 */
async function createNotificationConfiguration(request: CreateNotificationConfigurationRequest): CreateNotificationConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  return createNotificationConfigurationWithOptions(request, runtime);
}

model CreateScalingConfigurationRequest {
  privatePoolOptions?: {
    id?: string(name='Id', description='The ID of the private pool. The ID of a private pool is the same as the ID of the elasticity assurance or capacity reservation for which the private pool is generated.', example='eap-bp67acfmxazb4****'),
    matchCriteria?: string(name='MatchCriteria', description='The type of the private pool that you want to use to start instances. A private pool is generated when an elasticity assurance or a capacity reservation takes effect. You can select a private pool when you start instances. Valid values:

*   Open: open private pool. The system selects an open private pool for instance startup. If no open private pool meets your business requirements, the resources in the public pool are used for instance startup. In this case, you do not need to specify the PrivatePoolOptions.Id parameter.
*   Target: specified private pool. The resources in the specified private pool are used for instance startup. If the specified private pool is unavailable, the instance startup fails. If you set this parameter to Target, you must specify the PrivatePoolOptions.Id parameter.
*   None: no private pool. The resources of private pools are not used for instance startup.', example='Open'),
  }(name='PrivatePoolOptions'),
  systemDisk?: {
    autoSnapshotPolicyId?: string(name='AutoSnapshotPolicyId', description='The ID of the automatic snapshot policy that you want to apply to the system disk.', example='sp-bp12m37ccmxvbmi5****'),
    burstingEnabled?: boolean(name='BurstingEnabled', description='Specifies whether to enable the burst feature for the system disk. Valid values:

*   true
*   false

> This parameter is available only if you set the `SystemDisk.Category` parameter to `cloud_auto`.

For more information, see [ESSD AutoPL disks](~~368372~~).', example='false'),
    category?: string(name='Category', description='The category of the system disk. Valid values:

*   cloud: basic disk.
*   cloud_efficiency: ultra disk.
*   cloud_ssd: standard SSD.
*   ephemeral_ssd: local standard SSD.
*   cloud_essd: enhanced SSD (ESSD).
*   cloud_auto: ESSD AutoPL disk.

You cannot specify the SystemDisk.Category and `SystemDiskCategories` parameters at the same time. If you do not specify the SystemDisk.Category and `SystemDiskCategories` parameters, the default value of the SystemDisk.Category parameter is used. For non-I/O optimized instances of Generation I instance types, the default value is cloud. For instances of other instance types, the default value is cloud_efficiency.', example='cloud_ssd'),
    description?: string(name='Description', description='The description of the system disk. The description must be 2 to 256 characters in length. The description can contain letters but cannot start with `http://` or `https://`.', example='Test system disk.'),
    diskName?: string(name='DiskName', description='The name of the system disk. The name must be 2 to 128 characters in length. The name must start with a letter but cannot start with `http://` or `https://`. The name can contain letters, digits, colons (:), underscores (\\_), and hyphens (-).', example='cloud_ssdSystem'),
    encryptAlgorithm?: string(name='EncryptAlgorithm', description='The algorithm that is used to encrypt the system disk. Valid values:

*   AES-256
*   SM4-128

Default value: AES-256.', example='AES-256'),
    encrypted?: boolean(name='Encrypted', description='Specifies whether to encrypt the system disk. Valid values:

*   true: encrypts the system disk.
*   false: does not encrypt the system disk.

Default value: false.', example='false'),
    KMSKeyId?: string(name='KMSKeyId', description='The ID of the KMS key that is used to encrypt the system disk.', example='0e478b7a-4262-4802-b8cb-00d3fb40****'),
    performanceLevel?: string(name='PerformanceLevel', description='The PL of the system disk of the ESSD category. Valid values:

*   PL0: An ESSD can deliver up to 10,000 random read/write IOPS.
*   PL1: An ESSD can deliver up to 50,000 random read/write IOPS.
*   PL2: An ESSD can deliver up to 100,000 random read/write IOPS.
*   PL3: An ESSD can deliver up to 1,000,000 random read/write IOPS.

Default value: PL0.', example='PL0'),
    provisionedIops?: long(name='ProvisionedIops', description='The IOPS metric that is preconfigured for the system disk.

> IOPS measures the number of read and write operations that an EBS device can process per second.', example='100'),
    size?: int32(name='Size', description='The size of the system disk. Unit: GiB. Valid values: 20 to 500.

The value of the SystemDisk.Size parameter must be greater than or equal to max{20, ImageSize}.

Default value: max{40, ImageSize}.', example='100'),
  }(name='SystemDisk'),
  affinity?: string(name='Affinity', description='Specifies whether to associate the instance on a dedicated host with the dedicated host. Valid values:

*   default: does not associate the instance with the dedicated host. If you start an instance that was stopped in economical mode and the original dedicated host of the instance has insufficient resources, the instance is automatically deployed to another dedicated host in the automatic deployment resource pool.
*   host: associates the instance with the dedicated host. If you start an instance that was stopped in economical mode, the instance remains on the original dedicated host. If the original dedicated host of the instance has insufficient resources, you cannot start the instance.

Default value: default.', example='default'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure the idempotence of a request](~~25693~~).', example='123e4567-e89b-12d3-a456-42665544****'),
  cpu?: int32(name='Cpu', description='The number of vCPUs.

You can specify the number of vCPUs and the memory size to determine the range of instance types. For example, you can set the Cpu parameter to 2 and the Memory parameter to 16 to specify the instance types that have 2 vCPUs and 16 GiB of memory. If you specify the Cpu and Memory parameters, Auto Scaling determines the available instance types based on factors such as I/O optimization requirements and zones. Then, Auto Scaling preferentially creates instances of the instance type that is provided at the lowest price.

> You can specify the Cpu and Memory parameters to determine the range of instance types only if the Scaling Policy parameter is set to Cost Optimization Policy and no instance type is specified in the scaling configuration.', example='2'),
  creditSpecification?: string(name='CreditSpecification', description='The performance mode of the burstable instance. Valid values:

*   Standard: standard mode
*   Unlimited: unlimited mode

For more information, see the "Performance modes" section in the [Overview](~~59977~~) topic.', example='Standard'),
  dataDisks?: [ 
    {
      autoSnapshotPolicyId?: string(name='AutoSnapshotPolicyId', description='The ID of the automatic snapshot policy that you want to apply to the data disk.', example='sp-bp19nq9enxqkomib****'),
      burstingEnabled?: boolean(name='BurstingEnabled', description='Specifies whether to enable the burst feature for the system disk. Valid values:

*   true
*   false

> This parameter is available only if you set the `SystemDisk.Category` parameter to `cloud_auto`.

For more information, see [ESSD AutoPL disks](~~368372~~).', example='false'),
      categories?: [ string ](name='Categories', description='The categories of the data disks. You can specify 1 to 16 data disks. You can specify 1 to 4 disk categories in a scaling configuration. The first data disk that is specified in a scaling configuration has the highest priority. The priority deceases based on the specified order of the data disks. If Auto Scaling cannot create instances by using the data disk that has the highest priority, Auto Scaling creates instances by using the data disk that has the next highest priority. Valid values:

*   cloud: basic disk. The DeleteWithInstance attribute of a basic disk that is created together with the instance is set to true.
*   cloud_efficiency: ultra disk.
*   cloud_ssd: standard SSD.
*   cloud_essd: ESSD.

> You cannot specify the Categories and `Category` parameters at the same time.'),
      category?: string(name='Category', description='The category of the system disk. Valid values:

*   cloud: basic disk
*   cloud_efficiency: ultra disk
*   cloud_ssd: standard SSD
*   cloud_essd: ESSD
*   ephemeral_ssd: local SSD
*   cloud_auto: ESSD AutoPL disk

You cannot specify the Category and `SystemDiskCategories` parameters at the same time. If you do not specify the Category and `SystemDiskCategories` parameters, the default value of the Category parameter is used. For non-I/O optimized instances of Generation I instance types, the default value is cloud. For instances of other instance types, the default value is cloud_efficiency.', example='cloud_ssd'),
      deleteWithInstance?: boolean(name='DeleteWithInstance', description='Specifies whether to release the data disk when the instance to which the data disk is attached is released. Valid values:

*   true: releases the data disk when the instance is released.
*   false: retains the data disk when the instance is released.

This parameter is available only for independent disks whose Category parameter is set to cloud, cloud_efficiency, cloud_ssd, or cloud_essd. If you specify this parameter for disks of other categories, an error will be reported.

Default value: true.', example='true'),
      description?: string(name='Description', description='The description of the data disk. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.', example='Test data disk.'),
      device?: string(name='Device', description='The mount target of the data disk. If you do not specify the Device parameter, the system automatically assigns a mount target when you create the ECS instance. The name of the mount target ranges from /dev/xvdb to /dev/xvdz.', example='/dev/xvdb'),
      diskName?: string(name='DiskName', description='The name of the system disk. The name must be 2 to 128 characters in length and can contain letters, digits, colons (:), underscores (\\_), and hyphens (-). The name must start with a letter and cannot start with `http://` or `https://`.', example='cloud_ssdData'),
      encrypted?: string(name='Encrypted', description='Specifies whether to encrypt the data disk. Valid values:

*   true
*   false.

Default value: false.', example='false'),
      KMSKeyId?: string(name='KMSKeyId', description='The ID of the Key Management Service (KMS) key that is used to encrypt the data disk.', example='0e478b7a-4262-4802-b8cb-00d3fb40****'),
      performanceLevel?: string(name='PerformanceLevel', description='The PL of the data disk of the ESSD category. If you set the Categories parameter to cloud_essd, you must also specify the PerformanceLevel parameter. Valid values:

*   PL0: An ESSD can deliver up to 10,000 random read/write IOPS.
*   PL1: An ESSD can deliver up to 50,000 random read/write IOPS.
*   PL2: An ESSD can deliver up to 100,000 random read/write IOPS.
*   PL3: An ESSD can deliver up to 1,000,000 random read/write IOPS.

> For more information about how to choose ESSD PLs, see [ESSD](~~122389~~).', example='PL0'),
      provisionedIops?: long(name='ProvisionedIops', description='The input/output operations per second (IOPS) metric that is preconfigured for the data disk.

> IOPS measures the number of read and write operations that an Elastic Block Storage (EBS) device can process per second.', example='100'),
      size?: int32(name='Size', description='The size of the data disk. Unit: GiB.

*   Valid values if you set the Category parameter to cloud: 5 to 2000.
*   Valid values if you set the Category parameter to cloud_efficiency: 20 to 32768.
*   Valid values if you set the Category parameter to cloud_essd: 20 to 32768.
*   Valid values if you set the Category parameter to ephemeral_ssd: 5 to 800.

The value of the Size parameter must be greater than or equal to the size of the snapshot that is specified by the SnapshotId parameter.', example='100'),
      snapshotId?: string(name='SnapshotId', description='The ID of the snapshot that is used to create the data disk. If you specify this parameter, the Size parameter is ignored. The size of the disk is the same as the size of the specified snapshot.

If you specify a snapshot created on or before July 15, 2013, the operation fails and the system returns InvalidSnapshot.TooOld.', example='s-280s7****'),
    }
  ](name='DataDisks', description='Details of the data disks.'),
  dedicatedHostId?: string(name='DedicatedHostId', description='The ID of the dedicated host on which you want to create the ECS instance. You cannot create preemptible instances on dedicated hosts. Therefore, if you configure the DedicatedHostId parameter, the SpotStrategy and SpotPriceLimit parameters are ignored.

You can call the DescribeDedicatedHosts operation to query dedicated host IDs.', example='dh-bp67acfmxazb4p****'),
  deploymentSetId?: string(name='DeploymentSetId', description='The ID of the deployment set to which the ECS instance belongs.', example='ds-bp1frxuzdg87zh4pz****'),
  hostName?: string(name='HostName', description='The hostname of the ECS instance. The hostname cannot start or end with a period (.) or a hyphen (-). The hostname cannot contain consecutive periods (.) or hyphens (-). Naming conventions for different types of instances:

*   Windows instances: The hostname must be 2 to 15 characters in length, and can contain letters, digits, and hyphens (-). The hostname cannot contain periods (.) or contain only digits.
*   Other instances such as Linux instances: The hostname must be 2 to 64 characters in length. You can use periods (.) to separate a hostname into multiple segments. Each segment can contain letters, digits, and hyphens (-).', example='host****'),
  hpcClusterId?: string(name='HpcClusterId', description='The ID of the Elastic High Performance Computing (E-HPC) cluster to which the ECS instance belongs.', example='hpc-clusterid'),
  imageFamily?: string(name='ImageFamily', description='The name of the image family. You can specify this parameter to obtain the latest custom images that are available in the specified image family. The images are used to create ECS instances. If you specify the ImageId parameter, you cannot specify the ImageFamily parameter.', example='hangzhou-daily-update'),
  imageId?: string(name='ImageId', description='The ID of the image that is used by Auto Scaling to automatically create instances.', example='centos6u5_64_20G_aliaegis****.vhd'),
  imageName?: string(name='ImageName', description='The name of the image. Each image name must be unique within a region. If you specify the ImageId parameter, the ImageName parameter is ignored.

You cannot use the ImageName parameter to specify images that are purchased from Alibaba Cloud Marketplace.', example='image****'),
  instanceDescription?: string(name='InstanceDescription', description='The description of the ECS instance. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.', example='Test instance.'),
  instanceName?: string(name='InstanceName', description='The name of the ECS instance that is automatically created based on the scaling configuration.', example='instance****'),
  instancePatternInfos?: [ 
    {
      architectures?: [ string ](name='Architectures', description='The architectures of the instance types. Valid values:

*   X86: x86 architecture.
*   Heterogeneous: heterogeneous architecture, such as GPUs and FPGAs.
*   BareMetal: ECS Bare Metal Instance architecture.
*   Arm: ARM architecture.
*   SuperComputeCluster: Super Computing Cluster architecture.

By default, all values are selected.'),
      burstablePerformance?: string(name='BurstablePerformance', description='Specifies whether to include burstable instance types. Valid values:

*   Exclude: excludes burstable instance types.
*   Include: includes burstable instance types.
*   Required: includes only burstable instance types.

Default value: Include.', example='Include'),
      cores?: int32(name='Cores', description='The number of vCPUs that is specified for an instance type in the intelligent configuration mode. This parameter is used to filter the available instance types that meet the specified criteria. For more information, see [Instance family](~~25378~~).

When you specify the Cores parameter, take note of the following items:

*   The InstancePatternInfos parameter is available only for scaling groups that reside in VPCs.
*   You must specify the InstancePatternInfos, Cores, and Memory parameters at the same time.
*   If you specify an instance type by using the InstanceType or InstanceTypes parameter, Auto Scaling preferentially uses the instance type that is specified by the InstanceType or InstanceTypes parameter for scale-out activities. If the specified instance type does not have sufficient inventory, Auto Scaling creates instances of the instance type that is specified by the InstancePatternInfos parameter based on the price in ascending order.', example='2'),
      excludedInstanceTypes?: [ string ](name='ExcludedInstanceTypes', description='The instance types that you want to filter out. You can use wildcard characters such as an asterisk (\\*) to filter out a single instance type or an instance family. Example:

*   ecs.c6.large: The ecs.c6.large instance type is filtered out.
*   ecs.c6.\\*: The c6 instance family is filtered out.'),
      instanceFamilyLevel?: string(name='InstanceFamilyLevel', description='The level of the instance type, which is used to filter the instance types that meet the specified criteria. This parameter takes effect only if you set the `CostOptimization` parameter to true. Valid values:

*   EntryLevel: shared instance type. Instances of this level are the most cost-effective but may not provide stable computing performance in a consistent manner. Instances of this level are suitable for business scenarios in which the CPU utilization is low. For more information, see [Shared instance families](~~108489~~).
*   EnterpriseLevel: Instances of this level provide stable performance and dedicated resources, and are suitable for business scenarios that require high stability. For more information, see [Instance family](~~25378~~).
*   CreditEntryLevel: This value is valid only for burstable instances. CPU credits are used to ensure computing performance. Instances of this level are suitable for scenarios in which the CPU utilization is low but may fluctuate in specific cases. For more information, see the [Overview](~~59977~~) topic of burstable instances.', example='EnterpriseLevel'),
      maxPrice?: float(name='MaxPrice', description='The maximum hourly price for a pay-as-you-go instance or a preemptible instance in the intelligent configuration mode. This parameter is used to filter the available instance types that meet the specified criteria.

> If you set the SpotStrategy parameter to SpotWithPriceLimit, you must specify the MaxPrice parameter. In other cases, you do not need to specify the MaxPrice parameter.', example='2'),
      memory?: float(name='Memory', description='The memory size that is specified for an instance type in the intelligent configuration mode. Unit: GiB. This parameter is used to filter the available instance types that meet the specified criteria.', example='4'),
    }
  ](name='InstancePatternInfos', description='Information about the intelligent configuration settings, which determines the available instance types.'),
  instanceType?: string(name='InstanceType', description='The instance type of the ECS instance. For more information, see the "Instance family" topic in ECS documentation.', example='ecs.g6.large'),
  instanceTypeOverrides?: [ 
    {
      instanceType?: string(name='InstanceType', description='The instance type that you want to use to overwrite the instance type specified in the launch template.

If you want Auto Scaling to scale instances based on the instance type capacity, you must specify the InstanceType parameter and the WeightedCapacity parameter. You can specify 1 to 10 instance types in the extended configurations of the launch template.

> This parameter takes effect only if you specify the LaunchTemplateId parameter.

You can specify an instance type that is available for purchase as the value of the InstanceType parameter.', example='ecs.c5.xlarge'),
      weightedCapacity?: int32(name='WeightedCapacity', description='The weight of the instance type. The weight of an instance type indicates the capacity of a single instance of the specified instance type in the scaling group. If you want to specify the capacity of a single instance of the specified instance type in the scaling group, you must specify the InstanceType parameter before you specify the WeightedCapacity parameter.

A higher weight specifies that a smaller number of instances of the specified instance type are required to meet the expected capacity.

Performance metrics, such as the number of vCPUs and the memory size of each instance type, may vary. You can specify different weights for different instance types based on your business requirements.

Example:

*   Current capacity: 0
*   Expected capacity: 6
*   Capacity of ecs.c5.xlarge: 4

To meet the expected capacity requirement, Auto Scaling must create and add two ecs.c5.xlarge instances.

> The capacity of the scaling group cannot exceed the sum of the maximum number of instances that is specified by the MaxSize parameter and the maximum weight of the instance types.

Valid values of the WeightedCapacity parameter: 1 to 500.', example='4'),
    }
  ](name='InstanceTypeOverrides', description='Information about the instance type.'),
  instanceTypes?: [ string ](name='InstanceTypes', description='The instance types. If you specify this parameter, the InstanceType parameter is ignored. You can specify up to 10 instance types in a scaling configuration.

The first instance type has the highest priority. The priority decreases based on the specified order of instance types. Auto Scaling creates instances based on the priorities of the instance types. If Auto Scaling cannot create instances of the instance type that has the highest priority, Auto Scaling creates instances of the instance type that has the next highest priority.'),
  internetChargeType?: string(name='InternetChargeType', description='The billing method for network usage. Valid values:

*   PayByBandwidth: You are charged for the maximum available bandwidth that is specified by the InternetMaxBandwidthOut parameter.
*   PayByTraffic: You are charged for the actual traffic that is used. The InternetMaxBandwidthOut parameter specifies only the maximum available bandwidth.

Default value for the classic network: PayByBandwidth. Default value for VPCs: PayByTraffic.', example='PayByTraffic'),
  internetMaxBandwidthIn?: int32(name='InternetMaxBandwidthIn', description='The maximum inbound public bandwidth. Unit: Mbit/s. Valid values: 1 to 200.

Default value: 200. This parameter is not used for billing because inbound traffic to instances is free of charge.', example='100'),
  internetMaxBandwidthOut?: int32(name='InternetMaxBandwidthOut', description='The maximum outbound public bandwidth. Unit: Mbit/s.

*   Valid values if you set the InternetChargeType parameter to PayByBandwidth: 0 to 100. If you do not specify this parameter, 0 is used as the value of this parameter.
*   Valid values if you set the InternetChargeType parameter to PayByTraffic: 0 to 100. If you do not specify this parameter, an error will be reported.', example='50'),
  ioOptimized?: string(name='IoOptimized', description='Specifies whether to create an I/O optimized instance. Valid values:

none: does not create an I/O optimized instance. optimized: creates an I/O optimized instance.

For instances of retired instance types, the default value is none. For instances of other instance types, the default value is optimized.', example='optimized'),
  ipv6AddressCount?: int32(name='Ipv6AddressCount', description='The number of randomly generated IPv6 addresses that you want to allocate to the ENI.', example='1'),
  keyPairName?: string(name='KeyPairName', description='The name of the key pair that is used to log on to the ECS instance.

*   Windows instances do not use this parameter.
*   By default, the username and password authentication method is disabled for Linux instances.', example='KeyPairTest'),
  loadBalancerWeight?: int32(name='LoadBalancerWeight', description='The weight of the ECS instance as a backend server. Valid values: 1 to 100.

Default value: 50.', example='50'),
  memory?: int32(name='Memory', description='The size of the memory. Unit: GiB.

You can specify the number of vCPUs and the memory size to determine the range of instance types. For example, you can set the Cpu parameter to 2 and the Memory parameter to 16 to specify the instance types that have 2 vCPUs and 16 GiB of memory. If you specify the Cpu and Memory parameters, Auto Scaling determines available instance types based on factors such as I/O optimization requirements and zones. Then, Auto Scaling preferentially creates instances of the instance type that is provided at the lowest price.

> You can specify the Cpu and Memory parameters to determine the range of instance types only if the Scaling Policy parameter is set to Cost Optimization Policy and no instance type is specified in the scaling configuration.', example='16'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  password?: string(name='Password', description='The password that is used to log on to the ECS instance. The password must be 8 to 30 characters in length, and contain at least three of the following character types: uppercase letters, lowercase letters, digits, and special characters. Special characters include:

\\`()`  ~!@#$%^&*-_+=\\|{}[]:;\\"<>,.?/ `

The password of a Windows instance cannot start with a forward slash (/).

> For security reasons, we recommend that you use HTTPS to send requests if the Password parameter is specified.', example='123abc****'),
  passwordInherit?: boolean(name='PasswordInherit', description='Specifies whether to use the password that is preconfigured in the image. Before you use this parameter, make sure that a password is configured for the image. Valid values:

*   true
*   false', example='false'),
  ramRoleName?: string(name='RamRoleName', description='The name of the RAM role that is associated with the ECS instance. The name is provided and maintained by Resource Access Management (RAM). You can call the ListRoles operation to query the available RAM roles.', example='ramrole****'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the ECS instance belongs.', example='rg-resource****'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  scalingConfigurationName?: string(name='ScalingConfigurationName', description='The name of the scaling configuration. The name must be 2 to 64 characters in length and can contain letters, digits, underscores (\\_), hyphens (-), and periods (.). The name must start with a letter or a digit.

The name of the scaling configuration must be unique in a region. If you do not specify this parameter, the scaling configuration ID is used.', example='scalingconfig****'),
  scalingGroupId?: string(name='ScalingGroupId', description='The ID of the scaling group in which you want to create the scaling configuration.', example='asg-bp14wlu85wrpchm0****'),
  schedulerOptions?: map[string]any(name='SchedulerOptions', description='The options of the scheduler.'),
  securityEnhancementStrategy?: string(name='SecurityEnhancementStrategy', description='Specifies whether to enable security hardening. Valid values:

*   Active: enables security hardening. This value is applicable only to public images.
*   Deactive: does not enable security hardening. This value is applicable to all images.', example='Active'),
  securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group with which the ECS instance is associated. The ECS instances that are associated with the same security group can access each other.', example='sg-280ih****'),
  securityGroupIds?: [ string ](name='SecurityGroupIds', description='The IDs of the security groups with which you want to associate the ECS instance. You can associate only a limited number of security groups with an ECS instance. For more information, see the "Security group limits" section in [Limits](~~25412~~).

> You cannot specify the SecurityGroupId and SecurityGroupIds parameters at the same time.'),
  spotDuration?: int32(name='SpotDuration', description='The retention period of the preemptible instance. Unit: hours. Valid values: 0, 1, 2, 3, 4, 5, and 6.

*   The following retention periods are available in invitational preview: 2, 3, 4, 5, and 6 hours. If you want to set this parameter to one of these values, submit a ticket.
*   If you set this parameter to 0, no retention period is specified for the preemptible instance.

Default value: 1.', example='1'),
  spotInterruptionBehavior?: string(name='SpotInterruptionBehavior', description='The interruption event of the preemptible instance. Default value: Terminate. Set the value to Terminate, which specifies that the preemptible instance is to be released.', example='Terminate'),
  spotPriceLimits?: [ 
    {
      instanceType?: string(name='InstanceType', description='The instance type of the preemptible instance. This parameter is available only if you set the SpotStrategy parameter to SpotWithPriceLimit.', example='ecs.g6.large'),
      priceLimit?: float(name='PriceLimit', description='The price limit of the preemptible instance. This parameter is available only if you set the SpotStrategy parameter to SpotWithPriceLimit.', example='0.5'),
    }
  ](name='SpotPriceLimits', description='The billing information about the preemptible instance.'),
  spotStrategy?: string(name='SpotStrategy', description='The preemption policy that you want to apply to pay-as-you-go instances and preemptible instances. Valid values:

*   NoSpot: The instance is created as a pay-as-you-go instance.
*   SpotWithPriceLimit: The instance is a preemptible instance that has a user-defined maximum hourly price.
*   SpotAsPriceGo: The instance is created as a preemptible instance for which the market price at the time of purchase is automatically used as the bid price.

Default value: NoSpot.', example='NoSpot'),
  systemDiskCategories?: [ string ](name='SystemDiskCategories', description='The categories of the system disks. You can specify one to four disk categories in a scaling configuration. The first disk category that is specified in a scaling configuration has the highest priority. The priority deceases based on the specified order of disk categories. If Auto Scaling cannot create instances by using the system disk that has the highest priority, Auto Scaling creates instances by using the system disk that has the next highest priority. Valid values:

*   cloud: basic disk
*   cloud_efficiency: ultra disk
*   cloud_ssd: standard SSD
*   cloud_essd: ESSD

> You cannot specify the SystemDiskCategories and `SystemDiskCategory` parameters at the same time.'),
  tags?: string(name='Tags', description='The tags of the ECS instance. The tags must be specified in the key-value pair format. You can specify up to 20 tags. When you specify tag keys and tag values, take note of the following items:

*   A tag key can be up to 64 characters in length. The key cannot start with acs: or aliyun and cannot contain `http://` or `https://`. You cannot specify an empty string as a tag key.
*   A tag value can be up to 128 characters in length. The value cannot start with acs: or aliyun and cannot contain `http://` or `https://`. You can specify an empty string as a tag value.', example='{"key1":"value1","key2":"value2", ... "key5":"value5"}'),
  tenancy?: string(name='Tenancy', description='Specifies whether to create an instance on a dedicated host. Valid values:

*   default: does not create an instance on a dedicated host.
*   host: creates an instance on a dedicated host. If you do not specify the DedicatedHostId parameter, Alibaba Cloud selects a dedicated host for the instance that you want to create.

Default value: default.', example='default'),
  userData?: string(name='UserData', description='The user data of the ECS instance. The data must be encoded in Base64. The maximum size of the data before encoding is 16 KB.', example='echo hello ecs!'),
  zoneId?: string(name='ZoneId', description='The ID of the zone where the ECS instance resides.', example='cn-hangzhou-g'),
}

model CreateScalingConfigurationShrinkRequest {
  privatePoolOptions?: {
    id?: string(name='Id', description='The ID of the private pool. The ID of a private pool is the same as the ID of the elasticity assurance or capacity reservation for which the private pool is generated.', example='eap-bp67acfmxazb4****'),
    matchCriteria?: string(name='MatchCriteria', description='The type of the private pool that you want to use to start instances. A private pool is generated when an elasticity assurance or a capacity reservation takes effect. You can select a private pool when you start instances. Valid values:

*   Open: open private pool. The system selects an open private pool for instance startup. If no open private pool meets your business requirements, the resources in the public pool are used for instance startup. In this case, you do not need to specify the PrivatePoolOptions.Id parameter.
*   Target: specified private pool. The resources in the specified private pool are used for instance startup. If the specified private pool is unavailable, the instance startup fails. If you set this parameter to Target, you must specify the PrivatePoolOptions.Id parameter.
*   None: no private pool. The resources of private pools are not used for instance startup.', example='Open'),
  }(name='PrivatePoolOptions'),
  systemDisk?: {
    autoSnapshotPolicyId?: string(name='AutoSnapshotPolicyId', description='The ID of the automatic snapshot policy that you want to apply to the system disk.', example='sp-bp12m37ccmxvbmi5****'),
    burstingEnabled?: boolean(name='BurstingEnabled', description='Specifies whether to enable the burst feature for the system disk. Valid values:

*   true
*   false

> This parameter is available only if you set the `SystemDisk.Category` parameter to `cloud_auto`.

For more information, see [ESSD AutoPL disks](~~368372~~).', example='false'),
    category?: string(name='Category', description='The category of the system disk. Valid values:

*   cloud: basic disk.
*   cloud_efficiency: ultra disk.
*   cloud_ssd: standard SSD.
*   ephemeral_ssd: local standard SSD.
*   cloud_essd: enhanced SSD (ESSD).
*   cloud_auto: ESSD AutoPL disk.

You cannot specify the SystemDisk.Category and `SystemDiskCategories` parameters at the same time. If you do not specify the SystemDisk.Category and `SystemDiskCategories` parameters, the default value of the SystemDisk.Category parameter is used. For non-I/O optimized instances of Generation I instance types, the default value is cloud. For instances of other instance types, the default value is cloud_efficiency.', example='cloud_ssd'),
    description?: string(name='Description', description='The description of the system disk. The description must be 2 to 256 characters in length. The description can contain letters but cannot start with `http://` or `https://`.', example='Test system disk.'),
    diskName?: string(name='DiskName', description='The name of the system disk. The name must be 2 to 128 characters in length. The name must start with a letter but cannot start with `http://` or `https://`. The name can contain letters, digits, colons (:), underscores (\\_), and hyphens (-).', example='cloud_ssdSystem'),
    encryptAlgorithm?: string(name='EncryptAlgorithm', description='The algorithm that is used to encrypt the system disk. Valid values:

*   AES-256
*   SM4-128

Default value: AES-256.', example='AES-256'),
    encrypted?: boolean(name='Encrypted', description='Specifies whether to encrypt the system disk. Valid values:

*   true: encrypts the system disk.
*   false: does not encrypt the system disk.

Default value: false.', example='false'),
    KMSKeyId?: string(name='KMSKeyId', description='The ID of the KMS key that is used to encrypt the system disk.', example='0e478b7a-4262-4802-b8cb-00d3fb40****'),
    performanceLevel?: string(name='PerformanceLevel', description='The PL of the system disk of the ESSD category. Valid values:

*   PL0: An ESSD can deliver up to 10,000 random read/write IOPS.
*   PL1: An ESSD can deliver up to 50,000 random read/write IOPS.
*   PL2: An ESSD can deliver up to 100,000 random read/write IOPS.
*   PL3: An ESSD can deliver up to 1,000,000 random read/write IOPS.

Default value: PL0.', example='PL0'),
    provisionedIops?: long(name='ProvisionedIops', description='The IOPS metric that is preconfigured for the system disk.

> IOPS measures the number of read and write operations that an EBS device can process per second.', example='100'),
    size?: int32(name='Size', description='The size of the system disk. Unit: GiB. Valid values: 20 to 500.

The value of the SystemDisk.Size parameter must be greater than or equal to max{20, ImageSize}.

Default value: max{40, ImageSize}.', example='100'),
  }(name='SystemDisk'),
  affinity?: string(name='Affinity', description='Specifies whether to associate the instance on a dedicated host with the dedicated host. Valid values:

*   default: does not associate the instance with the dedicated host. If you start an instance that was stopped in economical mode and the original dedicated host of the instance has insufficient resources, the instance is automatically deployed to another dedicated host in the automatic deployment resource pool.
*   host: associates the instance with the dedicated host. If you start an instance that was stopped in economical mode, the instance remains on the original dedicated host. If the original dedicated host of the instance has insufficient resources, you cannot start the instance.

Default value: default.', example='default'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure the idempotence of a request](~~25693~~).', example='123e4567-e89b-12d3-a456-42665544****'),
  cpu?: int32(name='Cpu', description='The number of vCPUs.

You can specify the number of vCPUs and the memory size to determine the range of instance types. For example, you can set the Cpu parameter to 2 and the Memory parameter to 16 to specify the instance types that have 2 vCPUs and 16 GiB of memory. If you specify the Cpu and Memory parameters, Auto Scaling determines the available instance types based on factors such as I/O optimization requirements and zones. Then, Auto Scaling preferentially creates instances of the instance type that is provided at the lowest price.

> You can specify the Cpu and Memory parameters to determine the range of instance types only if the Scaling Policy parameter is set to Cost Optimization Policy and no instance type is specified in the scaling configuration.', example='2'),
  creditSpecification?: string(name='CreditSpecification', description='The performance mode of the burstable instance. Valid values:

*   Standard: standard mode
*   Unlimited: unlimited mode

For more information, see the "Performance modes" section in the [Overview](~~59977~~) topic.', example='Standard'),
  dataDisks?: [ 
    {
      autoSnapshotPolicyId?: string(name='AutoSnapshotPolicyId', description='The ID of the automatic snapshot policy that you want to apply to the data disk.', example='sp-bp19nq9enxqkomib****'),
      burstingEnabled?: boolean(name='BurstingEnabled', description='Specifies whether to enable the burst feature for the system disk. Valid values:

*   true
*   false

> This parameter is available only if you set the `SystemDisk.Category` parameter to `cloud_auto`.

For more information, see [ESSD AutoPL disks](~~368372~~).', example='false'),
      categories?: [ string ](name='Categories', description='The categories of the data disks. You can specify 1 to 16 data disks. You can specify 1 to 4 disk categories in a scaling configuration. The first data disk that is specified in a scaling configuration has the highest priority. The priority deceases based on the specified order of the data disks. If Auto Scaling cannot create instances by using the data disk that has the highest priority, Auto Scaling creates instances by using the data disk that has the next highest priority. Valid values:

*   cloud: basic disk. The DeleteWithInstance attribute of a basic disk that is created together with the instance is set to true.
*   cloud_efficiency: ultra disk.
*   cloud_ssd: standard SSD.
*   cloud_essd: ESSD.

> You cannot specify the Categories and `Category` parameters at the same time.'),
      category?: string(name='Category', description='The category of the system disk. Valid values:

*   cloud: basic disk
*   cloud_efficiency: ultra disk
*   cloud_ssd: standard SSD
*   cloud_essd: ESSD
*   ephemeral_ssd: local SSD
*   cloud_auto: ESSD AutoPL disk

You cannot specify the Category and `SystemDiskCategories` parameters at the same time. If you do not specify the Category and `SystemDiskCategories` parameters, the default value of the Category parameter is used. For non-I/O optimized instances of Generation I instance types, the default value is cloud. For instances of other instance types, the default value is cloud_efficiency.', example='cloud_ssd'),
      deleteWithInstance?: boolean(name='DeleteWithInstance', description='Specifies whether to release the data disk when the instance to which the data disk is attached is released. Valid values:

*   true: releases the data disk when the instance is released.
*   false: retains the data disk when the instance is released.

This parameter is available only for independent disks whose Category parameter is set to cloud, cloud_efficiency, cloud_ssd, or cloud_essd. If you specify this parameter for disks of other categories, an error will be reported.

Default value: true.', example='true'),
      description?: string(name='Description', description='The description of the data disk. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.', example='Test data disk.'),
      device?: string(name='Device', description='The mount target of the data disk. If you do not specify the Device parameter, the system automatically assigns a mount target when you create the ECS instance. The name of the mount target ranges from /dev/xvdb to /dev/xvdz.', example='/dev/xvdb'),
      diskName?: string(name='DiskName', description='The name of the system disk. The name must be 2 to 128 characters in length and can contain letters, digits, colons (:), underscores (\\_), and hyphens (-). The name must start with a letter and cannot start with `http://` or `https://`.', example='cloud_ssdData'),
      encrypted?: string(name='Encrypted', description='Specifies whether to encrypt the data disk. Valid values:

*   true
*   false.

Default value: false.', example='false'),
      KMSKeyId?: string(name='KMSKeyId', description='The ID of the Key Management Service (KMS) key that is used to encrypt the data disk.', example='0e478b7a-4262-4802-b8cb-00d3fb40****'),
      performanceLevel?: string(name='PerformanceLevel', description='The PL of the data disk of the ESSD category. If you set the Categories parameter to cloud_essd, you must also specify the PerformanceLevel parameter. Valid values:

*   PL0: An ESSD can deliver up to 10,000 random read/write IOPS.
*   PL1: An ESSD can deliver up to 50,000 random read/write IOPS.
*   PL2: An ESSD can deliver up to 100,000 random read/write IOPS.
*   PL3: An ESSD can deliver up to 1,000,000 random read/write IOPS.

> For more information about how to choose ESSD PLs, see [ESSD](~~122389~~).', example='PL0'),
      provisionedIops?: long(name='ProvisionedIops', description='The input/output operations per second (IOPS) metric that is preconfigured for the data disk.

> IOPS measures the number of read and write operations that an Elastic Block Storage (EBS) device can process per second.', example='100'),
      size?: int32(name='Size', description='The size of the data disk. Unit: GiB.

*   Valid values if you set the Category parameter to cloud: 5 to 2000.
*   Valid values if you set the Category parameter to cloud_efficiency: 20 to 32768.
*   Valid values if you set the Category parameter to cloud_essd: 20 to 32768.
*   Valid values if you set the Category parameter to ephemeral_ssd: 5 to 800.

The value of the Size parameter must be greater than or equal to the size of the snapshot that is specified by the SnapshotId parameter.', example='100'),
      snapshotId?: string(name='SnapshotId', description='The ID of the snapshot that is used to create the data disk. If you specify this parameter, the Size parameter is ignored. The size of the disk is the same as the size of the specified snapshot.

If you specify a snapshot created on or before July 15, 2013, the operation fails and the system returns InvalidSnapshot.TooOld.', example='s-280s7****'),
    }
  ](name='DataDisks', description='Details of the data disks.'),
  dedicatedHostId?: string(name='DedicatedHostId', description='The ID of the dedicated host on which you want to create the ECS instance. You cannot create preemptible instances on dedicated hosts. Therefore, if you configure the DedicatedHostId parameter, the SpotStrategy and SpotPriceLimit parameters are ignored.

You can call the DescribeDedicatedHosts operation to query dedicated host IDs.', example='dh-bp67acfmxazb4p****'),
  deploymentSetId?: string(name='DeploymentSetId', description='The ID of the deployment set to which the ECS instance belongs.', example='ds-bp1frxuzdg87zh4pz****'),
  hostName?: string(name='HostName', description='The hostname of the ECS instance. The hostname cannot start or end with a period (.) or a hyphen (-). The hostname cannot contain consecutive periods (.) or hyphens (-). Naming conventions for different types of instances:

*   Windows instances: The hostname must be 2 to 15 characters in length, and can contain letters, digits, and hyphens (-). The hostname cannot contain periods (.) or contain only digits.
*   Other instances such as Linux instances: The hostname must be 2 to 64 characters in length. You can use periods (.) to separate a hostname into multiple segments. Each segment can contain letters, digits, and hyphens (-).', example='host****'),
  hpcClusterId?: string(name='HpcClusterId', description='The ID of the Elastic High Performance Computing (E-HPC) cluster to which the ECS instance belongs.', example='hpc-clusterid'),
  imageFamily?: string(name='ImageFamily', description='The name of the image family. You can specify this parameter to obtain the latest custom images that are available in the specified image family. The images are used to create ECS instances. If you specify the ImageId parameter, you cannot specify the ImageFamily parameter.', example='hangzhou-daily-update'),
  imageId?: string(name='ImageId', description='The ID of the image that is used by Auto Scaling to automatically create instances.', example='centos6u5_64_20G_aliaegis****.vhd'),
  imageName?: string(name='ImageName', description='The name of the image. Each image name must be unique within a region. If you specify the ImageId parameter, the ImageName parameter is ignored.

You cannot use the ImageName parameter to specify images that are purchased from Alibaba Cloud Marketplace.', example='image****'),
  instanceDescription?: string(name='InstanceDescription', description='The description of the ECS instance. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.', example='Test instance.'),
  instanceName?: string(name='InstanceName', description='The name of the ECS instance that is automatically created based on the scaling configuration.', example='instance****'),
  instancePatternInfos?: [ 
    {
      architectures?: [ string ](name='Architectures', description='The architectures of the instance types. Valid values:

*   X86: x86 architecture.
*   Heterogeneous: heterogeneous architecture, such as GPUs and FPGAs.
*   BareMetal: ECS Bare Metal Instance architecture.
*   Arm: ARM architecture.
*   SuperComputeCluster: Super Computing Cluster architecture.

By default, all values are selected.'),
      burstablePerformance?: string(name='BurstablePerformance', description='Specifies whether to include burstable instance types. Valid values:

*   Exclude: excludes burstable instance types.
*   Include: includes burstable instance types.
*   Required: includes only burstable instance types.

Default value: Include.', example='Include'),
      cores?: int32(name='Cores', description='The number of vCPUs that is specified for an instance type in the intelligent configuration mode. This parameter is used to filter the available instance types that meet the specified criteria. For more information, see [Instance family](~~25378~~).

When you specify the Cores parameter, take note of the following items:

*   The InstancePatternInfos parameter is available only for scaling groups that reside in VPCs.
*   You must specify the InstancePatternInfos, Cores, and Memory parameters at the same time.
*   If you specify an instance type by using the InstanceType or InstanceTypes parameter, Auto Scaling preferentially uses the instance type that is specified by the InstanceType or InstanceTypes parameter for scale-out activities. If the specified instance type does not have sufficient inventory, Auto Scaling creates instances of the instance type that is specified by the InstancePatternInfos parameter based on the price in ascending order.', example='2'),
      excludedInstanceTypes?: [ string ](name='ExcludedInstanceTypes', description='The instance types that you want to filter out. You can use wildcard characters such as an asterisk (\\*) to filter out a single instance type or an instance family. Example:

*   ecs.c6.large: The ecs.c6.large instance type is filtered out.
*   ecs.c6.\\*: The c6 instance family is filtered out.'),
      instanceFamilyLevel?: string(name='InstanceFamilyLevel', description='The level of the instance type, which is used to filter the instance types that meet the specified criteria. This parameter takes effect only if you set the `CostOptimization` parameter to true. Valid values:

*   EntryLevel: shared instance type. Instances of this level are the most cost-effective but may not provide stable computing performance in a consistent manner. Instances of this level are suitable for business scenarios in which the CPU utilization is low. For more information, see [Shared instance families](~~108489~~).
*   EnterpriseLevel: Instances of this level provide stable performance and dedicated resources, and are suitable for business scenarios that require high stability. For more information, see [Instance family](~~25378~~).
*   CreditEntryLevel: This value is valid only for burstable instances. CPU credits are used to ensure computing performance. Instances of this level are suitable for scenarios in which the CPU utilization is low but may fluctuate in specific cases. For more information, see the [Overview](~~59977~~) topic of burstable instances.', example='EnterpriseLevel'),
      maxPrice?: float(name='MaxPrice', description='The maximum hourly price for a pay-as-you-go instance or a preemptible instance in the intelligent configuration mode. This parameter is used to filter the available instance types that meet the specified criteria.

> If you set the SpotStrategy parameter to SpotWithPriceLimit, you must specify the MaxPrice parameter. In other cases, you do not need to specify the MaxPrice parameter.', example='2'),
      memory?: float(name='Memory', description='The memory size that is specified for an instance type in the intelligent configuration mode. Unit: GiB. This parameter is used to filter the available instance types that meet the specified criteria.', example='4'),
    }
  ](name='InstancePatternInfos', description='Information about the intelligent configuration settings, which determines the available instance types.'),
  instanceType?: string(name='InstanceType', description='The instance type of the ECS instance. For more information, see the "Instance family" topic in ECS documentation.', example='ecs.g6.large'),
  instanceTypeOverrides?: [ 
    {
      instanceType?: string(name='InstanceType', description='The instance type that you want to use to overwrite the instance type specified in the launch template.

If you want Auto Scaling to scale instances based on the instance type capacity, you must specify the InstanceType parameter and the WeightedCapacity parameter. You can specify 1 to 10 instance types in the extended configurations of the launch template.

> This parameter takes effect only if you specify the LaunchTemplateId parameter.

You can specify an instance type that is available for purchase as the value of the InstanceType parameter.', example='ecs.c5.xlarge'),
      weightedCapacity?: int32(name='WeightedCapacity', description='The weight of the instance type. The weight of an instance type indicates the capacity of a single instance of the specified instance type in the scaling group. If you want to specify the capacity of a single instance of the specified instance type in the scaling group, you must specify the InstanceType parameter before you specify the WeightedCapacity parameter.

A higher weight specifies that a smaller number of instances of the specified instance type are required to meet the expected capacity.

Performance metrics, such as the number of vCPUs and the memory size of each instance type, may vary. You can specify different weights for different instance types based on your business requirements.

Example:

*   Current capacity: 0
*   Expected capacity: 6
*   Capacity of ecs.c5.xlarge: 4

To meet the expected capacity requirement, Auto Scaling must create and add two ecs.c5.xlarge instances.

> The capacity of the scaling group cannot exceed the sum of the maximum number of instances that is specified by the MaxSize parameter and the maximum weight of the instance types.

Valid values of the WeightedCapacity parameter: 1 to 500.', example='4'),
    }
  ](name='InstanceTypeOverrides', description='Information about the instance type.'),
  instanceTypes?: [ string ](name='InstanceTypes', description='The instance types. If you specify this parameter, the InstanceType parameter is ignored. You can specify up to 10 instance types in a scaling configuration.

The first instance type has the highest priority. The priority decreases based on the specified order of instance types. Auto Scaling creates instances based on the priorities of the instance types. If Auto Scaling cannot create instances of the instance type that has the highest priority, Auto Scaling creates instances of the instance type that has the next highest priority.'),
  internetChargeType?: string(name='InternetChargeType', description='The billing method for network usage. Valid values:

*   PayByBandwidth: You are charged for the maximum available bandwidth that is specified by the InternetMaxBandwidthOut parameter.
*   PayByTraffic: You are charged for the actual traffic that is used. The InternetMaxBandwidthOut parameter specifies only the maximum available bandwidth.

Default value for the classic network: PayByBandwidth. Default value for VPCs: PayByTraffic.', example='PayByTraffic'),
  internetMaxBandwidthIn?: int32(name='InternetMaxBandwidthIn', description='The maximum inbound public bandwidth. Unit: Mbit/s. Valid values: 1 to 200.

Default value: 200. This parameter is not used for billing because inbound traffic to instances is free of charge.', example='100'),
  internetMaxBandwidthOut?: int32(name='InternetMaxBandwidthOut', description='The maximum outbound public bandwidth. Unit: Mbit/s.

*   Valid values if you set the InternetChargeType parameter to PayByBandwidth: 0 to 100. If you do not specify this parameter, 0 is used as the value of this parameter.
*   Valid values if you set the InternetChargeType parameter to PayByTraffic: 0 to 100. If you do not specify this parameter, an error will be reported.', example='50'),
  ioOptimized?: string(name='IoOptimized', description='Specifies whether to create an I/O optimized instance. Valid values:

none: does not create an I/O optimized instance. optimized: creates an I/O optimized instance.

For instances of retired instance types, the default value is none. For instances of other instance types, the default value is optimized.', example='optimized'),
  ipv6AddressCount?: int32(name='Ipv6AddressCount', description='The number of randomly generated IPv6 addresses that you want to allocate to the ENI.', example='1'),
  keyPairName?: string(name='KeyPairName', description='The name of the key pair that is used to log on to the ECS instance.

*   Windows instances do not use this parameter.
*   By default, the username and password authentication method is disabled for Linux instances.', example='KeyPairTest'),
  loadBalancerWeight?: int32(name='LoadBalancerWeight', description='The weight of the ECS instance as a backend server. Valid values: 1 to 100.

Default value: 50.', example='50'),
  memory?: int32(name='Memory', description='The size of the memory. Unit: GiB.

You can specify the number of vCPUs and the memory size to determine the range of instance types. For example, you can set the Cpu parameter to 2 and the Memory parameter to 16 to specify the instance types that have 2 vCPUs and 16 GiB of memory. If you specify the Cpu and Memory parameters, Auto Scaling determines available instance types based on factors such as I/O optimization requirements and zones. Then, Auto Scaling preferentially creates instances of the instance type that is provided at the lowest price.

> You can specify the Cpu and Memory parameters to determine the range of instance types only if the Scaling Policy parameter is set to Cost Optimization Policy and no instance type is specified in the scaling configuration.', example='16'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  password?: string(name='Password', description='The password that is used to log on to the ECS instance. The password must be 8 to 30 characters in length, and contain at least three of the following character types: uppercase letters, lowercase letters, digits, and special characters. Special characters include:

\\`()`  ~!@#$%^&*-_+=\\|{}[]:;\\"<>,.?/ `

The password of a Windows instance cannot start with a forward slash (/).

> For security reasons, we recommend that you use HTTPS to send requests if the Password parameter is specified.', example='123abc****'),
  passwordInherit?: boolean(name='PasswordInherit', description='Specifies whether to use the password that is preconfigured in the image. Before you use this parameter, make sure that a password is configured for the image. Valid values:

*   true
*   false', example='false'),
  ramRoleName?: string(name='RamRoleName', description='The name of the RAM role that is associated with the ECS instance. The name is provided and maintained by Resource Access Management (RAM). You can call the ListRoles operation to query the available RAM roles.', example='ramrole****'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the ECS instance belongs.', example='rg-resource****'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  scalingConfigurationName?: string(name='ScalingConfigurationName', description='The name of the scaling configuration. The name must be 2 to 64 characters in length and can contain letters, digits, underscores (\\_), hyphens (-), and periods (.). The name must start with a letter or a digit.

The name of the scaling configuration must be unique in a region. If you do not specify this parameter, the scaling configuration ID is used.', example='scalingconfig****'),
  scalingGroupId?: string(name='ScalingGroupId', description='The ID of the scaling group in which you want to create the scaling configuration.', example='asg-bp14wlu85wrpchm0****'),
  schedulerOptionsShrink?: string(name='SchedulerOptions', description='The options of the scheduler.'),
  securityEnhancementStrategy?: string(name='SecurityEnhancementStrategy', description='Specifies whether to enable security hardening. Valid values:

*   Active: enables security hardening. This value is applicable only to public images.
*   Deactive: does not enable security hardening. This value is applicable to all images.', example='Active'),
  securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group with which the ECS instance is associated. The ECS instances that are associated with the same security group can access each other.', example='sg-280ih****'),
  securityGroupIds?: [ string ](name='SecurityGroupIds', description='The IDs of the security groups with which you want to associate the ECS instance. You can associate only a limited number of security groups with an ECS instance. For more information, see the "Security group limits" section in [Limits](~~25412~~).

> You cannot specify the SecurityGroupId and SecurityGroupIds parameters at the same time.'),
  spotDuration?: int32(name='SpotDuration', description='The retention period of the preemptible instance. Unit: hours. Valid values: 0, 1, 2, 3, 4, 5, and 6.

*   The following retention periods are available in invitational preview: 2, 3, 4, 5, and 6 hours. If you want to set this parameter to one of these values, submit a ticket.
*   If you set this parameter to 0, no retention period is specified for the preemptible instance.

Default value: 1.', example='1'),
  spotInterruptionBehavior?: string(name='SpotInterruptionBehavior', description='The interruption event of the preemptible instance. Default value: Terminate. Set the value to Terminate, which specifies that the preemptible instance is to be released.', example='Terminate'),
  spotPriceLimits?: [ 
    {
      instanceType?: string(name='InstanceType', description='The instance type of the preemptible instance. This parameter is available only if you set the SpotStrategy parameter to SpotWithPriceLimit.', example='ecs.g6.large'),
      priceLimit?: float(name='PriceLimit', description='The price limit of the preemptible instance. This parameter is available only if you set the SpotStrategy parameter to SpotWithPriceLimit.', example='0.5'),
    }
  ](name='SpotPriceLimits', description='The billing information about the preemptible instance.'),
  spotStrategy?: string(name='SpotStrategy', description='The preemption policy that you want to apply to pay-as-you-go instances and preemptible instances. Valid values:

*   NoSpot: The instance is created as a pay-as-you-go instance.
*   SpotWithPriceLimit: The instance is a preemptible instance that has a user-defined maximum hourly price.
*   SpotAsPriceGo: The instance is created as a preemptible instance for which the market price at the time of purchase is automatically used as the bid price.

Default value: NoSpot.', example='NoSpot'),
  systemDiskCategories?: [ string ](name='SystemDiskCategories', description='The categories of the system disks. You can specify one to four disk categories in a scaling configuration. The first disk category that is specified in a scaling configuration has the highest priority. The priority deceases based on the specified order of disk categories. If Auto Scaling cannot create instances by using the system disk that has the highest priority, Auto Scaling creates instances by using the system disk that has the next highest priority. Valid values:

*   cloud: basic disk
*   cloud_efficiency: ultra disk
*   cloud_ssd: standard SSD
*   cloud_essd: ESSD

> You cannot specify the SystemDiskCategories and `SystemDiskCategory` parameters at the same time.'),
  tags?: string(name='Tags', description='The tags of the ECS instance. The tags must be specified in the key-value pair format. You can specify up to 20 tags. When you specify tag keys and tag values, take note of the following items:

*   A tag key can be up to 64 characters in length. The key cannot start with acs: or aliyun and cannot contain `http://` or `https://`. You cannot specify an empty string as a tag key.
*   A tag value can be up to 128 characters in length. The value cannot start with acs: or aliyun and cannot contain `http://` or `https://`. You can specify an empty string as a tag value.', example='{"key1":"value1","key2":"value2", ... "key5":"value5"}'),
  tenancy?: string(name='Tenancy', description='Specifies whether to create an instance on a dedicated host. Valid values:

*   default: does not create an instance on a dedicated host.
*   host: creates an instance on a dedicated host. If you do not specify the DedicatedHostId parameter, Alibaba Cloud selects a dedicated host for the instance that you want to create.

Default value: default.', example='default'),
  userData?: string(name='UserData', description='The user data of the ECS instance. The data must be encoded in Base64. The maximum size of the data before encoding is 16 KB.', example='echo hello ecs!'),
  zoneId?: string(name='ZoneId', description='The ID of the zone where the ECS instance resides.', example='cn-hangzhou-g'),
}

model CreateScalingConfigurationResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3****'),
  scalingConfigurationId?: string(name='ScalingConfigurationId', description='The ID of the scaling configuration.', example='asc-bp1ffogfdauy0nu5****'),
}

model CreateScalingConfigurationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateScalingConfigurationResponseBody(name='body'),
}

/**
  * Auto Scaling automatically scales out Elastic Compute Service (ECS) instances based on the specified scaling configuration. ECS instances can be configured in the following modes:
  * *   InstancePatternInfo.N: intelligent configuration mode. In this mode, you need to only specify the number of vCPUs, memory size, instance family, and maximum price. The system selects an instance type that is provided at the lowest price based on your configurations to create ECS instances. This mode is available only for scaling groups that reside in virtual private clouds (VPCs). This mode helps reduce the failures of scale-out activities caused by insufficient inventory of instance types.
  * *   InstanceType: In this mode, you must specify one instance type.
  * *   InstanceTypes.N: In this mode, you must specify multiple instance types.
  * *   InstanceTypeOverride.N: In this mode, you must specify multiple instance types and specify weights for the instance types.
  * *   Cpu and Memory: In this mode, you must specify the number of vCPUs and the memory size. Auto Scaling determines a set of available instance types based on factors such as I/O optimization requirements and zones. Then, Auto Scaling preferentially creates ECS instances of the instance type that is provided at the lowest price. This mode is available only if the Scaling Policy parameter is set to Cost Optimization Policy and no instance type is specified in the scaling configuration.
  * > You cannot use InstanceType, InstanceTypes, InstanceTypeOverride, and Cpu and Memory at the same time. You can use InstanceType and InstancePatternInfos or use InstanceTypes and InstancePatternInfos at the same time. If you use InstanceType and InstancePatternInfos or use InstanceTypes and InstancePatternInfos at the same time, Auto Scaling preferentially uses the instance types that are specified by InstanceType or InstanceTypes for scale-out activities. If the instance types that are specified by InstanceType or InstanceTypes do not have sufficient inventory, Auto Scaling uses the instance types that are specified by InstancePatternInfos for scale-out activities.
  *
  * @param tmpReq CreateScalingConfigurationRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateScalingConfigurationResponse
 */
async function createScalingConfigurationWithOptions(tmpReq: CreateScalingConfigurationRequest, runtime: Util.RuntimeOptions): CreateScalingConfigurationResponse {
  Util.validateModel(tmpReq);
  var request = new CreateScalingConfigurationShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.schedulerOptions)) {
    request.schedulerOptionsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.schedulerOptions, 'SchedulerOptions', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.affinity)) {
    query['Affinity'] = request.affinity;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.cpu)) {
    query['Cpu'] = request.cpu;
  }
  if (!Util.isUnset(request.creditSpecification)) {
    query['CreditSpecification'] = request.creditSpecification;
  }
  if (!Util.isUnset(request.dataDisks)) {
    query['DataDisks'] = request.dataDisks;
  }
  if (!Util.isUnset(request.dedicatedHostId)) {
    query['DedicatedHostId'] = request.dedicatedHostId;
  }
  if (!Util.isUnset(request.deploymentSetId)) {
    query['DeploymentSetId'] = request.deploymentSetId;
  }
  if (!Util.isUnset(request.hostName)) {
    query['HostName'] = request.hostName;
  }
  if (!Util.isUnset(request.hpcClusterId)) {
    query['HpcClusterId'] = request.hpcClusterId;
  }
  if (!Util.isUnset(request.imageFamily)) {
    query['ImageFamily'] = request.imageFamily;
  }
  if (!Util.isUnset(request.imageId)) {
    query['ImageId'] = request.imageId;
  }
  if (!Util.isUnset(request.imageName)) {
    query['ImageName'] = request.imageName;
  }
  if (!Util.isUnset(request.instanceDescription)) {
    query['InstanceDescription'] = request.instanceDescription;
  }
  if (!Util.isUnset(request.instanceName)) {
    query['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.instancePatternInfos)) {
    query['InstancePatternInfos'] = request.instancePatternInfos;
  }
  if (!Util.isUnset(request.instanceType)) {
    query['InstanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.instanceTypeOverrides)) {
    query['InstanceTypeOverrides'] = request.instanceTypeOverrides;
  }
  if (!Util.isUnset(request.instanceTypes)) {
    query['InstanceTypes'] = request.instanceTypes;
  }
  if (!Util.isUnset(request.internetChargeType)) {
    query['InternetChargeType'] = request.internetChargeType;
  }
  if (!Util.isUnset(request.internetMaxBandwidthIn)) {
    query['InternetMaxBandwidthIn'] = request.internetMaxBandwidthIn;
  }
  if (!Util.isUnset(request.internetMaxBandwidthOut)) {
    query['InternetMaxBandwidthOut'] = request.internetMaxBandwidthOut;
  }
  if (!Util.isUnset(request.ioOptimized)) {
    query['IoOptimized'] = request.ioOptimized;
  }
  if (!Util.isUnset(request.ipv6AddressCount)) {
    query['Ipv6AddressCount'] = request.ipv6AddressCount;
  }
  if (!Util.isUnset(request.keyPairName)) {
    query['KeyPairName'] = request.keyPairName;
  }
  if (!Util.isUnset(request.loadBalancerWeight)) {
    query['LoadBalancerWeight'] = request.loadBalancerWeight;
  }
  if (!Util.isUnset(request.memory)) {
    query['Memory'] = request.memory;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.passwordInherit)) {
    query['PasswordInherit'] = request.passwordInherit;
  }
  if (!Util.isUnset(request.ramRoleName)) {
    query['RamRoleName'] = request.ramRoleName;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.scalingConfigurationName)) {
    query['ScalingConfigurationName'] = request.scalingConfigurationName;
  }
  if (!Util.isUnset(request.scalingGroupId)) {
    query['ScalingGroupId'] = request.scalingGroupId;
  }
  if (!Util.isUnset(request.schedulerOptionsShrink)) {
    query['SchedulerOptions'] = request.schedulerOptionsShrink;
  }
  if (!Util.isUnset(request.securityEnhancementStrategy)) {
    query['SecurityEnhancementStrategy'] = request.securityEnhancementStrategy;
  }
  if (!Util.isUnset(request.securityGroupId)) {
    query['SecurityGroupId'] = request.securityGroupId;
  }
  if (!Util.isUnset(request.securityGroupIds)) {
    query['SecurityGroupIds'] = request.securityGroupIds;
  }
  if (!Util.isUnset(request.spotDuration)) {
    query['SpotDuration'] = request.spotDuration;
  }
  if (!Util.isUnset(request.spotInterruptionBehavior)) {
    query['SpotInterruptionBehavior'] = request.spotInterruptionBehavior;
  }
  if (!Util.isUnset(request.spotPriceLimits)) {
    query['SpotPriceLimits'] = request.spotPriceLimits;
  }
  if (!Util.isUnset(request.spotStrategy)) {
    query['SpotStrategy'] = request.spotStrategy;
  }
  if (!Util.isUnset(request.systemDiskCategories)) {
    query['SystemDiskCategories'] = request.systemDiskCategories;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  if (!Util.isUnset(request.tenancy)) {
    query['Tenancy'] = request.tenancy;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  if (!Util.isUnset(request.privatePoolOptions)) {
    query['PrivatePoolOptions'] = request.privatePoolOptions;
  }
  if (!Util.isUnset(request.systemDisk)) {
    query['SystemDisk'] = request.systemDisk;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateScalingConfiguration',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Auto Scaling automatically scales out Elastic Compute Service (ECS) instances based on the specified scaling configuration. ECS instances can be configured in the following modes:
  * *   InstancePatternInfo.N: intelligent configuration mode. In this mode, you need to only specify the number of vCPUs, memory size, instance family, and maximum price. The system selects an instance type that is provided at the lowest price based on your configurations to create ECS instances. This mode is available only for scaling groups that reside in virtual private clouds (VPCs). This mode helps reduce the failures of scale-out activities caused by insufficient inventory of instance types.
  * *   InstanceType: In this mode, you must specify one instance type.
  * *   InstanceTypes.N: In this mode, you must specify multiple instance types.
  * *   InstanceTypeOverride.N: In this mode, you must specify multiple instance types and specify weights for the instance types.
  * *   Cpu and Memory: In this mode, you must specify the number of vCPUs and the memory size. Auto Scaling determines a set of available instance types based on factors such as I/O optimization requirements and zones. Then, Auto Scaling preferentially creates ECS instances of the instance type that is provided at the lowest price. This mode is available only if the Scaling Policy parameter is set to Cost Optimization Policy and no instance type is specified in the scaling configuration.
  * > You cannot use InstanceType, InstanceTypes, InstanceTypeOverride, and Cpu and Memory at the same time. You can use InstanceType and InstancePatternInfos or use InstanceTypes and InstancePatternInfos at the same time. If you use InstanceType and InstancePatternInfos or use InstanceTypes and InstancePatternInfos at the same time, Auto Scaling preferentially uses the instance types that are specified by InstanceType or InstanceTypes for scale-out activities. If the instance types that are specified by InstanceType or InstanceTypes do not have sufficient inventory, Auto Scaling uses the instance types that are specified by InstancePatternInfos for scale-out activities.
  *
  * @param request CreateScalingConfigurationRequest
  * @return CreateScalingConfigurationResponse
 */
async function createScalingConfiguration(request: CreateScalingConfigurationRequest): CreateScalingConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  return createScalingConfigurationWithOptions(request, runtime);
}

model CreateScalingGroupRequest {
  albServerGroups?: [ 
    {
      albServerGroupId?: string(name='AlbServerGroupId', description='The ID of the ALB server group that you want to associate with the scaling group.

You can associate only a limited number of ALB server groups with a scaling group. Go to [Quota Center](https://quotas.console.aliyun.com/products/ess/quotas) to check the maximum number of ALB server groups that you can associate with a scaling group.', example='sgp-ddwb0y0g6y9bjm****'),
      port?: int32(name='Port', description='The port number used by the ECS instance after Auto Scaling adds the ECS instance to the ALB server group. Valid values: 1 to 65535.', example='22'),
      weight?: int32(name='Weight', description='The weight of the ECS instance as a backend server after Auto Scaling adds the ECS instance to the ALB server group. If you increase the weight of an ECS instance in the ALB server group, the number of access requests that are forwarded to the ECS instance increases. If you set the Weight parameter for an ECS instance to 0, no access requests are forwarded to the ECS instance. Valid values: 0 to 100.', example='100'),
    }
  ](name='AlbServerGroups', description='Details of the Application Load Balancer (ALB) server groups that you want to associate with the scaling group.'),
  allocationStrategy?: string(name='AllocationStrategy', description='The allocation policy of instances. Auto Scaling selects instance types based on the allocation policy to create the required number of instances. The policy can be applied to pay-as-you-go instances and preemptible instances. This parameter is available only if you set the `MultiAZPolicy` parameter to `COMPOSABLE`. Valid values:

*   priority: Auto Scaling selects instance types based on the specified orders of the instance types to create the required number of instances.
*   lowestPrice: Auto Scaling selects instance types that have the lowest unit price of vCPUs to create the required number of instances.

Default value: priority.', example='priority'),
  azBalance?: boolean(name='AzBalance', description='Specifies whether to evenly distribute instances in the scaling group across zones. This parameter is available only if you set the `MultiAZPolicy` parameter to `COMPOSABLE`. Valid values:

*   true
*   false

Default value: false.', example='false'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [Ensure idempotence](~~25965~~).', example='123e4567-e89b-12d3-a456-42665544****'),
  compensateWithOnDemand?: boolean(name='CompensateWithOnDemand', description='Specifies whether to automatically create pay-as-you-go instances to meet the requirement on the number of ECS instances when the expected capacity of preemptible instances cannot be provided due to reasons such as costs and insufficient resources. This parameter is available only if you set the MultiAZPolicy parameter to COST_OPTIMIZED. Valid values:

*   true
*   false

Default value: true.', example='true'),
  containerGroupId?: string(name='ContainerGroupId', description='The ID of the elastic container instance.', example='eci-uf6fonnghi50u374****'),
  customPolicyARN?: string(name='CustomPolicyARN', description='The ARN of the custom scale-in policy (Function). This parameter is available only if you specify CustomPolicy as the first step to remove instances.', example='acs:fc:cn-zhangjiakou:16145688****:services/ess_custom_terminate_policy.LATEST/functions/ess_custom_terminate_policy_name'),
  DBInstanceIds?: string(name='DBInstanceIds', description='The IDs of ApsaraDB RDS instances. The value can be a JSON array that contains multiple ApsaraDB RDS instance IDs. Separate multiple IDs with commas (,).

You can associate only a limited number of ApsaraDB RDS instances with a scaling group. Go to [Quota Center](https://quotas.console.aliyun.com/products/ess/quotas) to check the maximum number of ApsaraDB RDS instances that you can associate with a scaling group.', example='["rm-bp142f86de0t7****", "rm-bp18l1z42ar4o****", "rm-bp1lqr97h4aqk****"]'),
  defaultCooldown?: int32(name='DefaultCooldown', description='The cooldown time of the scaling group after a scaling activity is executed. Valid values: 0 to 86400. Unit: seconds.

During the cooldown time, Auto Scaling executes only scaling activities that are triggered by CloudMonitor event-triggered tasks.

Default value: 300.', example='300'),
  desiredCapacity?: int32(name='DesiredCapacity', description='The expected number of ECS instances in the scaling group. Auto Scaling automatically maintains the expected number of ECS instances. The value of the DesiredCapacity parameter cannot be greater than the value of the MaxSize parameter and less than the value of the MinSize parameter.', example='5'),
  groupDeletionProtection?: boolean(name='GroupDeletionProtection', description='Specifies whether to enable deletion protection for the scaling group. Valid values:

*   true: enables deletion protection for the scaling group. This way, the scaling group cannot be deleted.
*   false: disables deletion protection for the scaling group.

Default value: false.', example='true'),
  groupType?: string(name='GroupType', description='The type of instances that are managed by the scaling group. Valid values:

*   ECS: ECS instances
*   ECI: elastic container instances

Default value: ECS.', example='ECS'),
  healthCheckType?: string(name='HealthCheckType', description='The health check mode of the scaling group. Valid values:

*   NONE: does not perform health checks on instances in the scaling group.
*   ECS: performs health checks on ECS instances in the scaling group.

Default value: ECS.', example='ECS'),
  instanceId?: string(name='InstanceId', description='The ID of the existing ECS instance that provides instance configurations for Auto Scaling to create a scaling configuration.', example='i-28wt4****'),
  launchTemplateId?: string(name='LaunchTemplateId', description='The ID of the launch template that provides instance configurations for Auto Scaling to create instances.', example='lt-m5e3ofjr1zn1aw7****'),
  launchTemplateOverrides?: [ 
    {
      instanceType?: string(name='InstanceType', description='The instance type that you want to use to override the instance type that is specified in the launch template.

If you want to scale instances based on the weighted capacities of the instances, you must specify both the InstanceType and WeightedCapacity parameters.

> This parameter is available only if you specify the LaunchTemplateId parameter.

You can use the InstanceType parameter to specify only instance types that are available for purchase.', example='ecs.c5.xlarge'),
      spotPriceLimit?: float(name='SpotPriceLimit', description='The maximum bid price of the instance type that is specified by the `LaunchTemplateOverride.N.InstanceType` parameter. You can specify N instance types by using the Extended Configurations feature of the launch template. Valid values of N: 1 to 10

> This parameter is available only if you specify the LaunchTemplateId parameter.``', example='0.025'),
      weightedCapacity?: int32(name='WeightedCapacity', description='The weight of the instance type. The weight specifies the capacity of a single instance of the specified instance type in the scaling group. If you want to scale instances based on the weighted capacities of the instances, you must specify the WeightedCapacity parameter after you specify the InstanceType parameter.

A higher weight specifies that a smaller number of instances of the specified instance type are required to meet the expected capacity requirement.

Performance metrics, such as the number of vCPUs and the memory size of each instance type, may vary. You can specify different weights for different instance types based on your business requirements.

Example:

*   Current capacity: 0
*   Expected capacity: 6
*   Capacity of ecs.c5.xlarge: 4

To meet the expected capacity requirement, Auto Scaling must create and add two ecs.c5.xlarge instances.

> The capacity of the scaling group cannot exceed the sum of the maximum number of instances that is specified by the MaxSize parameter and the maximum weight of the instance types.

Valid values of the WeightedCapacity parameter: 1 to 500.', example='4'),
    }
  ](name='LaunchTemplateOverrides', description='Details of the instance types that you specify by using the Extended Configurations feature of the launch template.'),
  launchTemplateVersion?: string(name='LaunchTemplateVersion', description='The version number of the launch template. Valid values:

*   A fixed template version number.
*   Default: the default template version.
*   Latest: the latest template version.', example='Default'),
  lifecycleHooks?: [ 
    {
      defaultResult?: string(name='DefaultResult', description='The action that Auto Scaling performs after the lifecycle hook of the scaling group expires. Valid values:

*   CONTINUE: continues to respond to a scaling request.
*   ABANDON: releases ECS instances that are created during scale-out activities, or removes ECS instances from the scaling group during scale-in activities.

If multiple lifecycle hooks in a scaling group are triggered during a scale-in activity and you set the DefaultResult parameter to ABANDON for one of the lifecycle hooks, Auto Scaling immediately performs the action after the lifecycle hook whose DefaultResult is set to ABANDON times out. In this case, other lifecycle hooks time out ahead of schedule. In other cases, Auto Scaling performs the action only after all lifecycle hooks time out. The action that Auto Scaling performs is determined by the value of the DefaultResult parameter that you set for the lifecycle hook that last times out.

Default value: CONTINUE.', example='CONTINUE'),
      heartbeatTimeout?: int32(name='HeartbeatTimeout', description='The period of time before the lifecycle hook times out. When the lifecycle hook times out, Auto Scaling performs the action specified by the DefaultResult parameter. Valid values: 30 to 21600. Unit: seconds.

After you create a lifecycle hook, you can call the RecordLifecycleActionHeartbeat operation to extend the timeout period of the lifecycle hook. You can also call the CompleteLifecycleAction operation to end the timeout period ahead of schedule.

Default value: 600.', example='600'),
      lifecycleHookName?: string(name='LifecycleHookName', description='The name of the lifecycle hook. After you specify this parameter, you cannot change the value of this parameter. If you do not specify this parameter, the ID of the lifecycle hook is used.', example='lifecyclehook****'),
      lifecycleTransition?: string(name='LifecycleTransition', description='The type of scaling activities for which you create the lifecycle hook. Valid values:

*   SCALE_OUT: scale-out activities
*   SCALE_IN: scale-in activities

> If you create lifecycle hooks for your scaling group, you must specify the LifecycleTransition parameter.', example='SCALE_OUT'),
      notificationArn?: string(name='NotificationArn', description='The Alibaba Cloud Resource Name (ARN) of the notification method that Auto Scaling uses to send a notification when a lifecycle hook takes effect. This method can be a Message Service (MNS) queue or an MNS topic. The value of this parameter is in the following format: acs:ess:{region}:{account-id}:{resource-relative-id}.

*   region: the region where the scaling group resides
*   account-id: the ID of the Alibaba Cloud account

Example:

*   MNS queue: acs:ess:{region}:{account-id}:queue/{queuename}
*   MNS topic: acs:ess:{region}:{account-id}:topic/{topicname}', example='acs:ess:cn-hangzhou:1111111111:queue/queue2'),
      notificationMetadata?: string(name='NotificationMetadata', description='The fixed string that is included in a notification. Auto Scaling sends the notification when the lifecycle hook takes effect. The value of this parameter cannot exceed 4,096 characters in length. Auto Scaling sends the value of the notificationmetadata parameter together with the notification. This way, you can categorize and manage your notifications in an efficient manner. You can specify the notificationmetadata parameter only after you specify the notificationarn parameter.', example='Test'),
    }
  ](name='LifecycleHooks', description='The lifecycle hooks.'),
  loadBalancerIds?: string(name='LoadBalancerIds', description='The IDs of CLB instances. The value can be a JSON array that contains multiple CLB instance IDs. Separate multiple IDs with commas (,).

You can associate only a limited number of CLB instances with a scaling group. Go to [Quota Center](https://quotas.console.aliyun.com/products/ess/quotas) to check the maximum number of CLB instances that you can associate with a scaling group.', example='["lb-bp1u7etiogg38yvwz****", "lb-bp168cqrux9ai9l7f****", "lb-bp1jv3m9zvj22ufxp****"]'),
  maxInstanceLifetime?: int32(name='MaxInstanceLifetime', description='The maximum life span of the ECS instance in the scaling group. Unit: seconds.

Valid values: 86400 to Integer.maxValue.

Default value: null.', example='null'),
  maxSize?: int32(name='MaxSize', description='The maximum number of ECS instances that is allowed in the scaling group. If the number of ECS instances in the scaling group is greater than the value of the MaxSize parameter, Auto Scaling removes ECS instances from the scaling group to ensure that the number of ECS instances is equal to the value of the MaxSize parameter.

The value range of the MaxSize parameter varies based on the instance quota. You can go to [Quota Center](https://quotas.console.aliyun.com/products/ess/quotas) to check the maximum number of instances that a scaling group can contain.****

For example, if the instance quota is 2,000, the value range of the **MaxSize** parameter is 0 to 2000.', example='20'),
  minSize?: int32(name='MinSize', description='The minimum number of ECS instances that must be contained in the scaling group. If the number of ECS instances in the scaling group is less than the value of the MinSize parameter, Auto Scaling adds ECS instances to the scaling group to ensure that the number of ECS instances in the scaling group is equal to the value of the MinSize parameter.

> The value of the MinSize parameter must be less than or equal to the value of the MaxSize parameter.', example='2'),
  multiAZPolicy?: string(name='MultiAZPolicy', description='The scaling policy for the multi-zone scaling group that contains ECS instances. Valid values:

*   PRIORITY: scales ECS instances based on the priority of the vSwitch that is specified by the VSwitchIds parameter. Auto Scaling preferentially scales instances in the zone where the vSwitch that has the highest priority resides. If the scaling fails, Auto Scaling scales instances in the zone where the vSwitch that has the next highest priority resides.

*   COST_OPTIMIZED: scales ECS instances based on the price of vCPU. Auto Scaling preferentially creates ECS instances whose vCPUs are provided at the lowest price during scale-out activities and removes ECS instances whose vCPUs are provided at the highest price during scale-in activities. If preemptible instance types are specified in the scaling configuration, Auto Scaling preferentially creates preemptible instances. You can use the CompensateWithOnDemand parameter to specify whether to automatically create pay-as-you-go instances when preemptible instances cannot be created due to insufficient resources.

    **

    **Note**The COST_OPTIMIZED setting takes effect only when multiple instance types are specified or at least one preemptible instance type is specified.

*   BALANCE: evenly distributes ECS instances across zones that are specified for the scaling group. If ECS instances are unevenly distributed across zones due to insufficient resources, you can call the [RebalanceInstance](~~71516~~) operation to balance the instances across zones.

Default value: PRIORITY.', example='PRIORITY'),
  onDemandBaseCapacity?: int32(name='OnDemandBaseCapacity', description='The minimum number of pay-as-you-go instances that must be included in the scaling group. Valid values: 0 to 1000. If the number of pay-as-you-go instances is less than the value of this parameter, Auto Scaling preferentially creates pay-as-you-go instances.', example='30'),
  onDemandPercentageAboveBaseCapacity?: int32(name='OnDemandPercentageAboveBaseCapacity', description='The percentage of pay-as-you-go instances among the excess instances when the minimum number of pay-as-you-go instances reaches the requirement. Valid values: 0 to 100.', example='20'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID of the scaling group.', example='cn-qingdao'),
  removalPolicies?: [ string ](name='RemovalPolicies', description='The instance removal policies. Valid values:

*   OldestInstance: removes ECS instances that are added at the earliest point in time to the scaling group.
*   NewestInstance: removes ECS instances that are most recently added to the scaling group.
*   OldestScalingConfiguration: removes ECS instances that are created based on the earliest scaling configuration.
*   CustomPolicy: removes ECS instances based on the custom scale-in policy (Function).

The scaling configuration source specified by OldestScalingConfiguration can be a scaling configuration or a launch template. The CustomPolicy setting takes effect only if you use it as the first step to remove instances. If you use CustomPolicy, you must also specify the CustomPolicyARN parameter.

> The removal of ECS instances from a scaling group is also affected by the value of the MultiAZPolicy parameter. For more information, see [Configure a combination policy for removing instances](~~254822~~) in Auto Scaling Best Practices.'),
  resourceGroupId?: string(name='ResourceGroupId', example='rg-123******'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  scalingGroupName?: string(name='ScalingGroupName', description='The name of the scaling group. The name of each scaling group must be unique in a region.

The name must be 2 to 64 characters in length, and can contain letters, digits, underscores (\\_), hyphens (-), and periods (.). The name must start with a letter or a digit.

If you do not specify this parameter, the value of the ScalingGroupId parameter is used.', example='scalinggroup****'),
  scalingPolicy?: string(name='ScalingPolicy', description='The reclaim mode of the scaling group. Valid values:

*   recycle: economical mode.
*   release: release mode.

The ScalingPolicy parameter specifies the reclaim mode of the scaling group. The RemovePolicy parameter of the RemoveInstances operation specifies how to remove instances in a specific manner.', example='recycle'),
  serverGroups?: [ 
    {
      port?: int32(name='Port'),
      serverGroupId?: string(name='ServerGroupId'),
      type?: string(name='Type'),
      weight?: int32(name='Weight'),
    }
  ](name='ServerGroups'),
  spotAllocationStrategy?: string(name='SpotAllocationStrategy', description='The allocation policy of preemptible instances. You can use this parameter to individually specify the allocation policy of preemptible instances. This parameter is available only if you set the `MultiAZPolicy` parameter to `COMPOSABLE`. Valid values:

*   priority: Auto Scaling selects instance types based on the specified orders of the instance types to create the required number of preemptible instances.
*   lowestPrice: Auto Scaling selects instance types that have the lowest unit price of vCPUs to create the required number of preemptible instances.

Default value: priority.', example='lowestPrice'),
  spotInstancePools?: int32(name='SpotInstancePools', description='The number of available instance types. Auto Scaling evenly creates preemptible instances of multiple instance types that are provided at the lowest price in the scaling group. Valid values: 1 to 10.', example='5'),
  spotInstanceRemedy?: boolean(name='SpotInstanceRemedy', description='Specifies whether to supplement preemptible instances. If you set this parameter to true, Auto Scaling creates an instance to replace a preemptible instance when Auto Scaling receives a system message that indicates the preemptible instance is to be reclaimed.', example='true'),
  syncAlarmRuleToCms?: boolean(name='SyncAlarmRuleToCms', description='> This parameter is unavailable.', example='false'),
  tags?: [ 
    {
      key?: string(name='Key', description='The tag key of the scaling group.', example='Department'),
      value?: string(name='Value', description='The tag value of the scaling group.', example='Finance'),
    }
  ](name='Tags', description='Details of the tags that you want to add to the scaling group.'),
  VServerGroups?: [ 
    {
      loadBalancerId?: string(name='LoadBalancerId', description='The ID of the CLB instance to which the vServer group belongs.', example='lb-bp1u7etiogg38yvwz****'),
      VServerGroupAttributes?: [ 
        {
          port?: int32(name='Port', description='The port number used by the ECS instance after Auto Scaling adds the ECS instance to the vServer group. Valid values: 1 to 65535.', example='22'),
          VServerGroupId?: string(name='VServerGroupId', description='The ID of the vServer group.', example='rsp-bp1443g77****'),
          weight?: int32(name='Weight', description='The weight of the ECS instance as a backend server after Auto Scaling adds the ECS instance to the vServer group. If you increase the weight of an ECS instance, the number of access requests that are forwarded to the ECS instance increases. If you set the Weight parameter for an ECS instance to 0, no access requests are forwarded to the ECS instance. Valid values: 0 to 100. Default value: 50.', example='100'),
        }
      ](name='VServerGroupAttributes', description='Details of the vServer group attributes.'),
    }
  ](name='VServerGroups', description='Details of the vServer groups that you want to associate with the scaling group.'),
  vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch. If you specify the VSwitchId parameter, the network type of the scaling group is VPC.

> If you do not specify the VSwitchId or VSwitchIds parameter, the network type of the scaling group is classic network.', example='vsw-bp14zolna43z266bq****'),
  vSwitchIds?: [ string ](name='VSwitchIds', description='The IDs of vSwitches. If you specify the VSwitchIds parameter, the VSwitchId parameter is ignored. If you specify the VSwitchIds parameter, the network type of the scaling group is VPC.

If you specify multiple vSwitches, take note of the following items:

*   The vSwitches must belong to the same VPC.
*   The vSwitches can belong to different zones.
*   The vSwitches are sorted in ascending order. The first vSwitch specified by the VSwitchIds parameter has the highest priority. If Auto Scaling fails to create ECS instances in the zone where the vSwitch that has the highest priority resides, Auto Scaling creates ECS instances in the zone where the vSwitch that has the next highest priority resides.

> If you do not specify the VSwitchId or VSwitchIds parameter, the network type of the scaling group is classic network.'),
}

model CreateScalingGroupResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3****'),
  scalingGroupId?: string(name='ScalingGroupId', description='The ID of the scaling group.', example='asg-bp14wlu85wrpchm0****'),
}

model CreateScalingGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateScalingGroupResponseBody(name='body'),
}

/**
  * A scaling group is a group of Elastic Compute Service (ECS) instances that can be used in similar business scenarios.
  * You can create only a limited number of scaling groups in a region. Go to Quota Center to check the quota of the scaling groups.
  * A scaling group does not immediately take effect after you create it. You must call the EnableScalingGroup operation to enable a scaling group. After you enable a scaling group, Auto Scaling can execute scaling rules to trigger scaling activities in the scaling group.
  * The Classic Load Balancer (CLB) instances and ApsaraDB RDS instances that you want to associate with a scaling group must reside in the same region as the scaling group. CLB instances are formerly known as Server Load Balancer (SLB) instances. For more information, see the "Regions and zones" topic in ECS Product Introduction.
  * If you associate a CLB instance with a scaling group, Auto Scaling automatically adds ECS instances in the scaling group to the backend server group of the CLB instance. You can specify a server group to which ECS instances can be added. You can add ECS instances to the following types of server groups:
  * *   Default server group: a group of ECS instances that are used to receive requests. If you do not specify a vServer group or a primary/secondary server group for a listener, requests are forwarded to the ECS instances in the default server group.
  * *   vServer group: If you want to forward requests to backend servers that are not in the default server group or configure domain name-based or URL-based forwarding rules, you can use vServer groups.
  * > If you specify the default server group and multiple vServer groups at the same time, ECS instances are added to all specified server groups.
  * The default weight of an ECS instance that is added as a backend server of a CLB instance is 50. The CLB instance that you want to associate with your scaling group must meet the following requirements:
  * *   The CLB instance must be in the Active state. You can call the DescribeLoadBalancers operation to query the state of the CLB instance.
  * *   The health check feature must be enabled on all listener ports that are configured for the CLB instance. Otherwise, the scaling group fails to be created.
  * If you associate an Application Load Balancer (ALB) server group with a scaling group, Auto Scaling automatically adds ECS instances in the scaling group to the ALB server group to process requests distributed by the ALB instance to which the ALB server group belongs. You can specify multiple ALB server groups. The server groups must reside in the same virtual private cloud (VPC) as the scaling group. For more information, see the "AttachAlbServerGroups" topic.
  * If you associate an ApsaraDB RDS instance with a scaling group, Auto Scaling automatically adds the private IP addresses of the ECS instances in the scaling group to the IP address whitelist of the ApsaraDB RDS instance. The ApsaraDB RDS instance that you want to associate with your scaling group must meet the following requirements:
  * *   The ApsaraDB RDS instance must be in the Running state. You can call the DescribeDBInstances operation to query the state of the ApsaraDB RDS instance.
  * *   The number of IP addresses in the IP address whitelist of the ApsaraDB RDS instance cannot exceed the upper limit. For more information, see the "Configure whitelists" topic in ApsaraDB RDS User Guide.
  * If you set the MultiAZPolicy parameter of the scaling group to COST_OPTIMIZED, take note of the following items:
  * *   You can use the OnDemandBaseCapacity, OnDemandPercentageAboveBaseCapacity, and SpotInstancePools parameters to specify the instance allocation method based on the cost optimization policy. This instance allocation method is prioritized during scaling.
  * *   If you do not specify the OnDemandBaseCapacity, OnDemandPercentageAboveBaseCapacity, or SpotInstancePools parameter, the instance types that are provided at the lowest price are used to create instances based on the cost optimization policy.
  * If you set the `Tags.Propagate` parameter for the scaling group to true, the following rules apply:
  * *   Tags that you add to the scaling group cannot be propagated to existing instances in the scaling group. Tags that you add to the scaling group are propagated to only new instances.
  * *   If you specify instance tags in the scaling configuration that is used to create instances, and propagate the tags that you add to the scaling group to the instances, all tags exist at the same time.
  * *   If the tag key that you specify in a scaling configuration and the tag key that you add to the scaling group that uses the scaling configuration are the same, the tag value that you specify in the scaling configuration is preferentially used.
  *
  * @param request CreateScalingGroupRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateScalingGroupResponse
 */
async function createScalingGroupWithOptions(request: CreateScalingGroupRequest, runtime: Util.RuntimeOptions): CreateScalingGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.albServerGroups)) {
    query['AlbServerGroups'] = request.albServerGroups;
  }
  if (!Util.isUnset(request.allocationStrategy)) {
    query['AllocationStrategy'] = request.allocationStrategy;
  }
  if (!Util.isUnset(request.azBalance)) {
    query['AzBalance'] = request.azBalance;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.compensateWithOnDemand)) {
    query['CompensateWithOnDemand'] = request.compensateWithOnDemand;
  }
  if (!Util.isUnset(request.containerGroupId)) {
    query['ContainerGroupId'] = request.containerGroupId;
  }
  if (!Util.isUnset(request.customPolicyARN)) {
    query['CustomPolicyARN'] = request.customPolicyARN;
  }
  if (!Util.isUnset(request.DBInstanceIds)) {
    query['DBInstanceIds'] = request.DBInstanceIds;
  }
  if (!Util.isUnset(request.defaultCooldown)) {
    query['DefaultCooldown'] = request.defaultCooldown;
  }
  if (!Util.isUnset(request.desiredCapacity)) {
    query['DesiredCapacity'] = request.desiredCapacity;
  }
  if (!Util.isUnset(request.groupDeletionProtection)) {
    query['GroupDeletionProtection'] = request.groupDeletionProtection;
  }
  if (!Util.isUnset(request.groupType)) {
    query['GroupType'] = request.groupType;
  }
  if (!Util.isUnset(request.healthCheckType)) {
    query['HealthCheckType'] = request.healthCheckType;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.launchTemplateId)) {
    query['LaunchTemplateId'] = request.launchTemplateId;
  }
  if (!Util.isUnset(request.launchTemplateOverrides)) {
    query['LaunchTemplateOverrides'] = request.launchTemplateOverrides;
  }
  if (!Util.isUnset(request.launchTemplateVersion)) {
    query['LaunchTemplateVersion'] = request.launchTemplateVersion;
  }
  if (!Util.isUnset(request.lifecycleHooks)) {
    query['LifecycleHooks'] = request.lifecycleHooks;
  }
  if (!Util.isUnset(request.loadBalancerIds)) {
    query['LoadBalancerIds'] = request.loadBalancerIds;
  }
  if (!Util.isUnset(request.maxInstanceLifetime)) {
    query['MaxInstanceLifetime'] = request.maxInstanceLifetime;
  }
  if (!Util.isUnset(request.maxSize)) {
    query['MaxSize'] = request.maxSize;
  }
  if (!Util.isUnset(request.minSize)) {
    query['MinSize'] = request.minSize;
  }
  if (!Util.isUnset(request.multiAZPolicy)) {
    query['MultiAZPolicy'] = request.multiAZPolicy;
  }
  if (!Util.isUnset(request.onDemandBaseCapacity)) {
    query['OnDemandBaseCapacity'] = request.onDemandBaseCapacity;
  }
  if (!Util.isUnset(request.onDemandPercentageAboveBaseCapacity)) {
    query['OnDemandPercentageAboveBaseCapacity'] = request.onDemandPercentageAboveBaseCapacity;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.removalPolicies)) {
    query['RemovalPolicies'] = request.removalPolicies;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.scalingGroupName)) {
    query['ScalingGroupName'] = request.scalingGroupName;
  }
  if (!Util.isUnset(request.scalingPolicy)) {
    query['ScalingPolicy'] = request.scalingPolicy;
  }
  if (!Util.isUnset(request.serverGroups)) {
    query['ServerGroups'] = request.serverGroups;
  }
  if (!Util.isUnset(request.spotAllocationStrategy)) {
    query['SpotAllocationStrategy'] = request.spotAllocationStrategy;
  }
  if (!Util.isUnset(request.spotInstancePools)) {
    query['SpotInstancePools'] = request.spotInstancePools;
  }
  if (!Util.isUnset(request.spotInstanceRemedy)) {
    query['SpotInstanceRemedy'] = request.spotInstanceRemedy;
  }
  if (!Util.isUnset(request.syncAlarmRuleToCms)) {
    query['SyncAlarmRuleToCms'] = request.syncAlarmRuleToCms;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  if (!Util.isUnset(request.VServerGroups)) {
    query['VServerGroups'] = request.VServerGroups;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.vSwitchIds)) {
    query['VSwitchIds'] = request.vSwitchIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateScalingGroup',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * A scaling group is a group of Elastic Compute Service (ECS) instances that can be used in similar business scenarios.
  * You can create only a limited number of scaling groups in a region. Go to Quota Center to check the quota of the scaling groups.
  * A scaling group does not immediately take effect after you create it. You must call the EnableScalingGroup operation to enable a scaling group. After you enable a scaling group, Auto Scaling can execute scaling rules to trigger scaling activities in the scaling group.
  * The Classic Load Balancer (CLB) instances and ApsaraDB RDS instances that you want to associate with a scaling group must reside in the same region as the scaling group. CLB instances are formerly known as Server Load Balancer (SLB) instances. For more information, see the "Regions and zones" topic in ECS Product Introduction.
  * If you associate a CLB instance with a scaling group, Auto Scaling automatically adds ECS instances in the scaling group to the backend server group of the CLB instance. You can specify a server group to which ECS instances can be added. You can add ECS instances to the following types of server groups:
  * *   Default server group: a group of ECS instances that are used to receive requests. If you do not specify a vServer group or a primary/secondary server group for a listener, requests are forwarded to the ECS instances in the default server group.
  * *   vServer group: If you want to forward requests to backend servers that are not in the default server group or configure domain name-based or URL-based forwarding rules, you can use vServer groups.
  * > If you specify the default server group and multiple vServer groups at the same time, ECS instances are added to all specified server groups.
  * The default weight of an ECS instance that is added as a backend server of a CLB instance is 50. The CLB instance that you want to associate with your scaling group must meet the following requirements:
  * *   The CLB instance must be in the Active state. You can call the DescribeLoadBalancers operation to query the state of the CLB instance.
  * *   The health check feature must be enabled on all listener ports that are configured for the CLB instance. Otherwise, the scaling group fails to be created.
  * If you associate an Application Load Balancer (ALB) server group with a scaling group, Auto Scaling automatically adds ECS instances in the scaling group to the ALB server group to process requests distributed by the ALB instance to which the ALB server group belongs. You can specify multiple ALB server groups. The server groups must reside in the same virtual private cloud (VPC) as the scaling group. For more information, see the "AttachAlbServerGroups" topic.
  * If you associate an ApsaraDB RDS instance with a scaling group, Auto Scaling automatically adds the private IP addresses of the ECS instances in the scaling group to the IP address whitelist of the ApsaraDB RDS instance. The ApsaraDB RDS instance that you want to associate with your scaling group must meet the following requirements:
  * *   The ApsaraDB RDS instance must be in the Running state. You can call the DescribeDBInstances operation to query the state of the ApsaraDB RDS instance.
  * *   The number of IP addresses in the IP address whitelist of the ApsaraDB RDS instance cannot exceed the upper limit. For more information, see the "Configure whitelists" topic in ApsaraDB RDS User Guide.
  * If you set the MultiAZPolicy parameter of the scaling group to COST_OPTIMIZED, take note of the following items:
  * *   You can use the OnDemandBaseCapacity, OnDemandPercentageAboveBaseCapacity, and SpotInstancePools parameters to specify the instance allocation method based on the cost optimization policy. This instance allocation method is prioritized during scaling.
  * *   If you do not specify the OnDemandBaseCapacity, OnDemandPercentageAboveBaseCapacity, or SpotInstancePools parameter, the instance types that are provided at the lowest price are used to create instances based on the cost optimization policy.
  * If you set the `Tags.Propagate` parameter for the scaling group to true, the following rules apply:
  * *   Tags that you add to the scaling group cannot be propagated to existing instances in the scaling group. Tags that you add to the scaling group are propagated to only new instances.
  * *   If you specify instance tags in the scaling configuration that is used to create instances, and propagate the tags that you add to the scaling group to the instances, all tags exist at the same time.
  * *   If the tag key that you specify in a scaling configuration and the tag key that you add to the scaling group that uses the scaling configuration are the same, the tag value that you specify in the scaling configuration is preferentially used.
  *
  * @param request CreateScalingGroupRequest
  * @return CreateScalingGroupResponse
 */
async function createScalingGroup(request: CreateScalingGroupRequest): CreateScalingGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createScalingGroupWithOptions(request, runtime);
}

model CreateScalingRuleRequest {
  adjustmentType?: string(name='AdjustmentType', description='The number of instances that must be scaled based on the scaling rule. This parameter is required only if you set the ScalingRuleType parameter to SimpleScalingRule or StepScalingRule. The number of ECS instances that are scaled in a single scaling activity cannot exceed 1,000.

*   Valid values if you set the AdjustmentType parameter to QuantityChangeInCapacity: -1000 to 1000.
*   Valid values if you set the AdjustmentType parameter to PercentChangeInCapacity: -100 to 10000.
*   Valid values if you set the AdjustmentType parameter to TotalCapacity: 0 to 2000.', example='QuantityChangeInCapacity'),
  adjustmentValue?: int32(name='AdjustmentValue', description='The type of the scaling rule. Valid values:

*   SimpleScalingRule: scales the number of ECS instances based on the values that are specified for the AdjustmentType and AdjustmentValue parameters.
*   TargetTrackingScalingRule: calculates the number of ECS instances that must be scaled and maintains the value of a predefined metric close to the value that is specified for the TargetValue parameter.
*   StepScalingRule: scales ECS instances in steps based on the specified thresholds and metric values.
*   PredictiveScalingRule: uses machine learning to analyze historical monitoring data of the scaling group and predicts the future values of metrics. In addition, Auto Scaling automatically creates scheduled tasks to specify the boundary values for the scaling group.

Default value: SimpleScalingRule.', example='100'),
  cooldown?: int32(name='Cooldown', description='The minimum number of instances that must be scaled when the AdjustmentType parameter is set to PercentChangeInCapacity. This parameter takes effect only if you set the ScalingRuleType parameter to SimpleScalingRule or StepScalingRule.', example='60'),
  disableScaleIn?: boolean(name='DisableScaleIn', description='The number of consecutive times that the event-triggered task created for scale-in activities must meet the threshold conditions before an alert is triggered. After a target tracking scaling rule is created, an event-triggered task is automatically created and then associated with the target tracking scaling rule.

Default value: 15.', example='false'),
  estimatedInstanceWarmup?: int32(name='EstimatedInstanceWarmup', description='The predefined metric that you want to monitor. This parameter is required only if you set the ScalingRuleType parameter to TargetTrackingScalingRule or PredictiveScalingRule.

Valid values if you set the ScalingRuleType parameter to TargetTrackingScalingRule:

*   CpuUtilization: the average CPU utilization
*   ClassicInternetRx: the average inbound Internet traffic over the classic network
*   ClassicInternetTx: the average outbound Internet traffic over the classic network
*   VpcInternetRx: the average inbound Internet traffic over the virtual private cloud (VPC)
*   VpcInternetTx: the average outbound Internet traffic over the VPC
*   IntranetRx: the average inbound traffic over the internal network
*   IntranetTx: the average outbound traffic over the internal network

Valid values if you set the ScalingRuleType parameter to PredictiveScalingRule:

*   CpuUtilization: the average CPU utilization
*   IntranetRx: the average inbound traffic over the internal network
*   IntranetTx: the average outbound traffic over the internal network', example='300'),
  initialMaxSize?: int32(name='InitialMaxSize', description='Details of the step adjustments.', example='100'),
  metricName?: string(name='MetricName', description='The target value. This parameter is required only if you set the ScalingRuleType parameter to TargetTrackingScalingRule or PredictiveScalingRule. The value must be greater than 0 and can have up to three decimal places.', example='CpuUtilization'),
  minAdjustmentMagnitude?: int32(name='MinAdjustmentMagnitude', description='The scaling method of the scaling rule. This parameter is required only if you set the ScalingRuleType parameter to SimpleScalingRule or StepScalingRule. Valid values:

*   QuantityChangeInCapacity: adds the specified number of ECS instances to or removes the specified number of ECS instances from the scaling group.
*   PercentChangeInCapacity: adds the specified percentage of ECS instances to or removes the specified percentage of ECS instances from the scaling group.
*   TotalCapacity: adjusts the number of ECS instances in the scaling group to a specified number.', example='1'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  predictiveScalingMode?: string(name='PredictiveScalingMode', description='The maximum value for predication tasks. Valid values:

*   MaxOverridePredictiveValue: uses the initial maximum capacity as the maximum value for prediction tasks if the predicted value is greater than the initial maximum capacity.
*   PredictiveValueOverrideMax: uses the predicted value as the maximum value for prediction tasks if the predicted value is greater than the initial maximum capacity.
*   PredictiveValueOverrideMaxWithBuffer: increases the predicted value by a percentage that is specified by the PredictiveValueBuffer parameter. If the predicted value that is increased by the percentage is greater than the initial maximum capacity, the increased value is used as the maximum value for prediction tasks.

Default value: MaxOverridePredictiveValue.', example='PredictAndScale'),
  predictiveTaskBufferTime?: int32(name='PredictiveTaskBufferTime', description='The maximum number of ECS instances in the scaling group. If you specify this parameter, you must also specify the PredictiveValueBehavior parameter.

The default value of this parameter is the value of the MaxSize parameter.', example='30'),
  predictiveValueBehavior?: string(name='PredictiveValueBehavior', description='The percentage of the increment to the predicted value when the PredictiveValueBehavior parameter is set to PredictiveValueOverrideMaxWithBuffer. If the predicted value increased by this percentage is greater than the initial maximum capacity, the increased value is used as the maximum value for prediction tasks. Valid values: 0 to 100.

Default value: 0.', example='MaxOverridePredictiveValue'),
  predictiveValueBuffer?: int32(name='PredictiveValueBuffer', description='The amount of buffer time before the prediction task is executed. By default, all prediction tasks that are automatically created for a predictive scaling rule are executed on the hour. You can specify an amount of buffer time for resource preparation before the prediction tasks are executed. Valid values: 0 to 60. Unit: minutes.

Default value: 0.', example='50'),
  regionId?: string(name='RegionId', description='The unique identifier of the scaling rule.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  scaleInEvaluationCount?: int32(name='ScaleInEvaluationCount', description='The number of consecutive times that the event-triggered task created for scale-out activities must meet the threshold conditions before an alert is triggered. After a target tracking scaling rule is created, an event-triggered task is automatically created and then associated with the target tracking scaling rule.

Default value: 3.', example='15'),
  scaleOutEvaluationCount?: int32(name='ScaleOutEvaluationCount', description='The mode of the predictive scaling rule. Valid values:

*   PredictAndScale: produces predictions and creates prediction tasks.
*   PredictOnly: produces predictions but does not create prediction tasks.

Default value: PredictAndScale.', example='3'),
  scalingGroupId?: string(name='ScalingGroupId', description='The name of the scaling rule. It must be 2 to 64 characters in length, and can contain letters, digits, underscores (\\_), hyphens (-), and periods (.). It must start with a letter or a digit. The name of a scaling rule must be unique in the scaling group to which the scaling rule belongs and within an Alibaba Cloud account.

If you do not specify this parameter, the value of the ScalingRuleId parameter is used.', example='asg-bp1ffogfdauy0jw0****'),
  scalingRuleName?: string(name='ScalingRuleName', description='The cooldown time of the scaling rule. This parameter is available only if you set the ScalingRuleType parameter to SimpleScalingRule. Valid values: 0 to 86400. Unit: seconds.

By default, this parameter is left empty.', example='scalingrule****'),
  scalingRuleType?: string(name='ScalingRuleType', description='The warmup period of an instance. This parameter is available only if you set the ScalingRuleType parameter to TargetTrackingScalingRule or PredictiveScalingRule. Auto Scaling adds ECS instances that are in the warmup state to a scaling group but does not report monitoring data to CloudMonitor during the warmup period.

> Auto Scaling calculates the number of ECS instances that must be scaled. ECS instances in the warmup state are not counted towards the current capacity of the scaling group.

Valid values: 0 to 86400. Unit: seconds.

Default value: 300.', example='SimpleScalingRule'),
  stepAdjustments?: [ 
    {
      metricIntervalLowerBound?: float(name='MetricIntervalLowerBound', description='The region ID of the scaling group.', example='1.0'),
      metricIntervalUpperBound?: float(name='MetricIntervalUpperBound', description='The number of ECS instances that you want to scale in a step adjustment. This parameter is available only if you set the ScalingRuleType parameter to StepScalingRule.', example='5.0'),
      scalingAdjustment?: int32(name='ScalingAdjustment', description='The lower limit specified in a step adjustment. This parameter is available only if you set the ScalingRuleType parameter to StepScalingRule. Valid values: -9.999999E18 to 9.999999E18.', example='1'),
    }
  ](name='StepAdjustments', description='Details of the step adjustments.'),
  targetValue?: float(name='TargetValue', description='Specifies whether to disable scale-in. This parameter is available only if you set the ScalingRuleType parameter to TargetTrackingScalingRule.

Default value: false.', example='0.125'),
}

model CreateScalingRuleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the scaling rule, which is generated by the system and is globally unique.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3****'),
  scalingRuleAri?: string(name='ScalingRuleAri', description='The ID of the request.', example='ari:acs:ess:cn-hangzhou:140692647406****:scalingrule/asr-bp1dvirgwkoowxk7****'),
  scalingRuleId?: string(name='ScalingRuleId', description='auditing', example='asr-bp1dvirgwkoowxk7****'),
}

model CreateScalingRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateScalingRuleResponseBody(name='body'),
}

/**
  * Creates a scaling rule.
  *
  * @param request CreateScalingRuleRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateScalingRuleResponse
 */
async function createScalingRuleWithOptions(request: CreateScalingRuleRequest, runtime: Util.RuntimeOptions): CreateScalingRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.adjustmentType)) {
    query['AdjustmentType'] = request.adjustmentType;
  }
  if (!Util.isUnset(request.adjustmentValue)) {
    query['AdjustmentValue'] = request.adjustmentValue;
  }
  if (!Util.isUnset(request.cooldown)) {
    query['Cooldown'] = request.cooldown;
  }
  if (!Util.isUnset(request.disableScaleIn)) {
    query['DisableScaleIn'] = request.disableScaleIn;
  }
  if (!Util.isUnset(request.estimatedInstanceWarmup)) {
    query['EstimatedInstanceWarmup'] = request.estimatedInstanceWarmup;
  }
  if (!Util.isUnset(request.initialMaxSize)) {
    query['InitialMaxSize'] = request.initialMaxSize;
  }
  if (!Util.isUnset(request.metricName)) {
    query['MetricName'] = request.metricName;
  }
  if (!Util.isUnset(request.minAdjustmentMagnitude)) {
    query['MinAdjustmentMagnitude'] = request.minAdjustmentMagnitude;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.predictiveScalingMode)) {
    query['PredictiveScalingMode'] = request.predictiveScalingMode;
  }
  if (!Util.isUnset(request.predictiveTaskBufferTime)) {
    query['PredictiveTaskBufferTime'] = request.predictiveTaskBufferTime;
  }
  if (!Util.isUnset(request.predictiveValueBehavior)) {
    query['PredictiveValueBehavior'] = request.predictiveValueBehavior;
  }
  if (!Util.isUnset(request.predictiveValueBuffer)) {
    query['PredictiveValueBuffer'] = request.predictiveValueBuffer;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.scaleInEvaluationCount)) {
    query['ScaleInEvaluationCount'] = request.scaleInEvaluationCount;
  }
  if (!Util.isUnset(request.scaleOutEvaluationCount)) {
    query['ScaleOutEvaluationCount'] = request.scaleOutEvaluationCount;
  }
  if (!Util.isUnset(request.scalingGroupId)) {
    query['ScalingGroupId'] = request.scalingGroupId;
  }
  if (!Util.isUnset(request.scalingRuleName)) {
    query['ScalingRuleName'] = request.scalingRuleName;
  }
  if (!Util.isUnset(request.scalingRuleType)) {
    query['ScalingRuleType'] = request.scalingRuleType;
  }
  if (!Util.isUnset(request.stepAdjustments)) {
    query['StepAdjustments'] = request.stepAdjustments;
  }
  if (!Util.isUnset(request.targetValue)) {
    query['TargetValue'] = request.targetValue;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateScalingRule',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Creates a scaling rule.
  *
  * @param request CreateScalingRuleRequest
  * @return CreateScalingRuleResponse
 */
async function createScalingRule(request: CreateScalingRuleRequest): CreateScalingRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createScalingRuleWithOptions(request, runtime);
}

model CreateScheduledTaskRequest {
  description?: string(name='Description', description='The scaling rule that you want to execute when the scheduled task is triggered. Specify the unique identifier of the scaling rule. If you specify the `ScheduledAction` parameter, you must select an existing scaling rule for the scheduled task.

> You cannot specify the `ScheduledAction` and `ScalingGroupId` parameters at the same time.', example='Test scheduled task.'),
  desiredCapacity?: int32(name='DesiredCapacity', description='The ID of the scaling group whose number of instances must be modified when the scheduled task is triggered. If you specify the `ScalingGroupId` parameter for a scheduled task, you must specify the minimum, maximum, or expected numbers of instances for a scaling group in the scheduled task. That is, you must specify at least one of the `MinValue`, `MaxValue`, and `DesiredCapacity` parameters.

> You cannot specify the `ScheduledAction` and `ScalingGroupId` parameters at the same time.', example='10'),
  launchExpirationTime?: int32(name='LaunchExpirationTime', description='The minimum number of instances in the scaling group if you specify the ScalingGroupId parameter.', example='600'),
  launchTime?: string(name='LaunchTime', description='The interval at which the scheduled task is repeated. Valid values:

*   Daily: The scheduled task is executed once every specified number of days.
*   Weekly: The scheduled task is executed on each specified day of the week.
*   Monthly: The scheduled task is executed on each specified day of the month.
*   Cron: The scheduled task is executed based on the specified cron expression.

You must specify the `RecurrenceType` and `RecurrenceValue` parameters at the same time.', example='2014-08-17T16:52Z'),
  maxValue?: int32(name='MaxValue', description='The expected number of instances in the scaling group if you specify the ScalingGroupId parameter.

> You must specify the `DesiredCapacity` parameter when you create a scaling group.', example='10'),
  minValue?: int32(name='MinValue', description='The maximum number of instances in the scaling group if you specify the ScalingGroupId parameter.', example='0'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  recurrenceEndTime?: string(name='RecurrenceEndTime', description='The point in time at which the scheduled task is triggered. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mmZ format. The time must be in UTC. You cannot enter a point in time that is later than 90 days from the point in time at which the scheduled task is created.

*   If you specify the `RecurrenceType` parameter, the scheduled task is repeatedly executed at the point in time that is specified by the LaunchTime parameter.
*   If you do not specify the `RecurrenceType` parameter, the task is executed only once at the point in time that is specified by the LaunchTime parameter.', example='2014-08-17T16:55Z'),
  recurrenceType?: string(name='RecurrenceType', description='The number of recurrences of the scheduled task.

*   If you set the `RecurrenceType` parameter to `Daily`, you can specify only one value for this parameter. Valid values: 1 to 31.
*   If you set the `RecurrenceType` parameter to `Weekly`, you can specify multiple values for this parameter. Separate the values with commas (,). The values that correspond to Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, and Saturday are 0, 1, 2, 3, 4, 5, and 6.``
*   If you set the `RecurrenceType` parameter to `Monthly`, you can specify two values in the `A-B` format for this parameter. Valid values of A and B: 1 to 31. B must be greater than or equal to A.
*   If you set the `RecurrenceType` parameter to `Cron`, you can specify a cron expression. A cron expression is written in UTC time and consists of the following fields: minute, hour, day, month, and week. The expression can contain the letters L and W and the following wildcard characters: commas (,), question marks (?), hyphens (-), asterisks (\\*), number signs (#), and forward slashes (/).

You must specify both the `RecurrenceType` parameter and the `RecurrenceValue` parameter.', example='Daily'),
  recurrenceValue?: string(name='RecurrenceValue', description='Specifies whether to enable the scheduled task.

*   true
*   false

Default value: true.', example='1'),
  regionId?: string(name='RegionId', description='The name of the scheduled task. The name must be 2 to 64 characters in length, and can contain letters, digits, underscores (\\_), hyphens (-), and periods (.). The name must start with a letter or a digit. The name of the scheduled task must be unique in the region and within the Alibaba Cloud account.

If you do not specify this parameter, the value of the `ScheduledTaskId` parameter is used.', example='cn-qingdao'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  scalingGroupId?: string(name='ScalingGroupId', description='The globally unique ID of the scheduled task. The globally unique ID is generated by the system.', example='asg-bp18p2yfxow2dloq****'),
  scheduledAction?: string(name='ScheduledAction', description='The end time of the scheduled task. Specify the time in the ISO 8601 standard in the YYYY-MM-DDThh:mmZ format.

The time must be in UTC. You cannot enter a point in time that is later than 365 days from the point in time at which the scheduled task is created.', example='ari:acs:ess:cn-hangzhou:140692647****:scalingrule/asr-bp12tcnol686y1ik****'),
  scheduledTaskName?: string(name='ScheduledTaskName', description='The description of the scheduled task. The description must be 2 to 200 characters in length.', example='scheduled****'),
  taskEnabled?: boolean(name='TaskEnabled', description='The time period during which the failed scheduled task can be retried. Unit: seconds. Valid values: 0 to 1800.

Default value: 600.', example='true'),
}

model CreateScheduledTaskResponseBody = {
  requestId?: string(name='RequestId', description='auditing', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3****'),
  scheduledTaskId?: string(name='ScheduledTaskId', description='The ID of the request.', example='edRtShc57WGXdt8TlPbr****'),
}

model CreateScheduledTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateScheduledTaskResponseBody(name='body'),
}

/**
  * Creates a scheduled task.
  *
  * @param request CreateScheduledTaskRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateScheduledTaskResponse
 */
async function createScheduledTaskWithOptions(request: CreateScheduledTaskRequest, runtime: Util.RuntimeOptions): CreateScheduledTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.desiredCapacity)) {
    query['DesiredCapacity'] = request.desiredCapacity;
  }
  if (!Util.isUnset(request.launchExpirationTime)) {
    query['LaunchExpirationTime'] = request.launchExpirationTime;
  }
  if (!Util.isUnset(request.launchTime)) {
    query['LaunchTime'] = request.launchTime;
  }
  if (!Util.isUnset(request.maxValue)) {
    query['MaxValue'] = request.maxValue;
  }
  if (!Util.isUnset(request.minValue)) {
    query['MinValue'] = request.minValue;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.recurrenceEndTime)) {
    query['RecurrenceEndTime'] = request.recurrenceEndTime;
  }
  if (!Util.isUnset(request.recurrenceType)) {
    query['RecurrenceType'] = request.recurrenceType;
  }
  if (!Util.isUnset(request.recurrenceValue)) {
    query['RecurrenceValue'] = request.recurrenceValue;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.scalingGroupId)) {
    query['ScalingGroupId'] = request.scalingGroupId;
  }
  if (!Util.isUnset(request.scheduledAction)) {
    query['ScheduledAction'] = request.scheduledAction;
  }
  if (!Util.isUnset(request.scheduledTaskName)) {
    query['ScheduledTaskName'] = request.scheduledTaskName;
  }
  if (!Util.isUnset(request.taskEnabled)) {
    query['TaskEnabled'] = request.taskEnabled;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateScheduledTask',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Creates a scheduled task.
  *
  * @param request CreateScheduledTaskRequest
  * @return CreateScheduledTaskResponse
 */
async function createScheduledTask(request: CreateScheduledTaskRequest): CreateScheduledTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createScheduledTaskWithOptions(request, runtime);
}

model DeactivateScalingConfigurationRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  scalingConfigurationId?: string(name='ScalingConfigurationId'),
}

model DeactivateScalingConfigurationResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeactivateScalingConfigurationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeactivateScalingConfigurationResponseBody(name='body'),
}

async function deactivateScalingConfigurationWithOptions(request: DeactivateScalingConfigurationRequest, runtime: Util.RuntimeOptions): DeactivateScalingConfigurationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.scalingConfigurationId)) {
    query['ScalingConfigurationId'] = request.scalingConfigurationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeactivateScalingConfiguration',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deactivateScalingConfiguration(request: DeactivateScalingConfigurationRequest): DeactivateScalingConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  return deactivateScalingConfigurationWithOptions(request, runtime);
}

model DeleteAlarmRequest {
  alarmTaskId?: string(name='AlarmTaskId', description='The ID of the event-triggered task.', example='asg-bp1hvbnmkl10vll5****_f95ce797-dc2e-4bad-9618-14fee7d1****'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The ID of the event-triggered task.', example='cn-qingdao'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
}

model DeleteAlarmResponseBody = {
  alarmTaskId?: string(name='AlarmTaskId', description='The ID of the request.', example='asg-bp1hvbnmkl10vll5****_f95ce797-dc2e-4bad-9618-14fee7d1****'),
  requestId?: string(name='RequestId', description='auditing', example='6EF9BFEE-FE07-4627-B8FB-14326FB9****'),
}

model DeleteAlarmResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAlarmResponseBody(name='body'),
}

async function deleteAlarmWithOptions(request: DeleteAlarmRequest, runtime: Util.RuntimeOptions): DeleteAlarmResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alarmTaskId)) {
    query['AlarmTaskId'] = request.alarmTaskId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAlarm',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteAlarm(request: DeleteAlarmRequest): DeleteAlarmResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAlarmWithOptions(request, runtime);
}

model DeleteEciScalingConfigurationRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The ID of the request. This request ID is returned regardless of whether the request is successful.', example='cn-qingdao'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  scalingConfigurationId?: string(name='ScalingConfigurationId', description='The region ID of the scaling group.', example='asc-bp1bx8mzur534edp****'),
}

model DeleteEciScalingConfigurationResponseBody = {
  requestId?: string(name='RequestId', description='auditing', example='45D5B0AD-3B00-4A9B-9911-6D5303B06712'),
}

model DeleteEciScalingConfigurationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteEciScalingConfigurationResponseBody(name='body'),
}

/**
  * Deletes a scaling configuration that is used to create elastic container instances.
  *
  * @param request DeleteEciScalingConfigurationRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteEciScalingConfigurationResponse
 */
async function deleteEciScalingConfigurationWithOptions(request: DeleteEciScalingConfigurationRequest, runtime: Util.RuntimeOptions): DeleteEciScalingConfigurationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.scalingConfigurationId)) {
    query['ScalingConfigurationId'] = request.scalingConfigurationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteEciScalingConfiguration',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Deletes a scaling configuration that is used to create elastic container instances.
  *
  * @param request DeleteEciScalingConfigurationRequest
  * @return DeleteEciScalingConfigurationResponse
 */
async function deleteEciScalingConfiguration(request: DeleteEciScalingConfigurationRequest): DeleteEciScalingConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteEciScalingConfigurationWithOptions(request, runtime);
}

model DeleteLifecycleHookRequest {
  lifecycleHookId?: string(name='LifecycleHookId', description='The ID of the lifecycle hook.', example='ash-bp14g3ee6bt3sc98****'),
  lifecycleHookName?: string(name='LifecycleHookName', description='The name of the lifecycle hook.', example='lifecyclehook****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID of the scaling group.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  scalingGroupId?: string(name='ScalingGroupId', description='The ID of the scaling group.', example='asg-bp18p2yfxow2dloq****'),
}

model DeleteLifecycleHookResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
}

model DeleteLifecycleHookResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteLifecycleHookResponseBody(name='body'),
}

/**
  * If you delete a lifecycle hook that is in effect in a scaling group, instances exit the Pending state in advance. You can use one of the following methods to specify the lifecycle hooks that you want to delete:
  * *   Specify the scaling group ID of the lifecycle hook that you want to delete by using the ScalingGroupId parameter and the lifecycle hook name by using the LifecycleHookName parameter.
  * *   Specify the lifecycle hook ID by using the LifecycleHookId parameter. In this case, the ScalingGroupId parameter and the LifecycleHookName parameter are ignored.
  *
  * @param request DeleteLifecycleHookRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteLifecycleHookResponse
 */
async function deleteLifecycleHookWithOptions(request: DeleteLifecycleHookRequest, runtime: Util.RuntimeOptions): DeleteLifecycleHookResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lifecycleHookId)) {
    query['LifecycleHookId'] = request.lifecycleHookId;
  }
  if (!Util.isUnset(request.lifecycleHookName)) {
    query['LifecycleHookName'] = request.lifecycleHookName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.scalingGroupId)) {
    query['ScalingGroupId'] = request.scalingGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteLifecycleHook',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * If you delete a lifecycle hook that is in effect in a scaling group, instances exit the Pending state in advance. You can use one of the following methods to specify the lifecycle hooks that you want to delete:
  * *   Specify the scaling group ID of the lifecycle hook that you want to delete by using the ScalingGroupId parameter and the lifecycle hook name by using the LifecycleHookName parameter.
  * *   Specify the lifecycle hook ID by using the LifecycleHookId parameter. In this case, the ScalingGroupId parameter and the LifecycleHookName parameter are ignored.
  *
  * @param request DeleteLifecycleHookRequest
  * @return DeleteLifecycleHookResponse
 */
async function deleteLifecycleHook(request: DeleteLifecycleHookRequest): DeleteLifecycleHookResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteLifecycleHookWithOptions(request, runtime);
}

model DeleteNotificationConfigurationRequest {
  notificationArn?: string(name='NotificationArn', description='The region ID of the scaling group.', example='acs:ess:cn-beijing:161456884340****:cloudmonitor'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The ID of the request.', example='cn-beijing'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  scalingGroupId?: string(name='ScalingGroupId', description='The Alibaba Cloud Resource Name (ARN) of the notification method. The following list describes the value formats of this parameter:

*   If you use CloudMonitor as the notification party, the value format of this parameter is acs:ess:{region-id}:{account-id}:cloudmonitor.
*   If you use an MNS queue as the notification party, the value format of this parameter is acs:mns:{region-id}:{account-id}:queue/{queuename}.
*   If you use an MNS topic as the notification party, the value format of this parameter is acs:mns:{region-id}:{account-id}:topic/{topicname}.

The variables in the preceding formats have the following meanings:

*   region-id: the region ID of the scaling group.
*   account-id: the ID of the Alibaba Cloud account.
*   queuename: the name of the MNS queue.
*   topicname: the name of the MNS topic.', example='asg-bp18p2yfxow2dloq****'),
}

model DeleteNotificationConfigurationResponseBody = {
  requestId?: string(name='RequestId', description='auditing', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3****'),
}

model DeleteNotificationConfigurationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteNotificationConfigurationResponseBody(name='body'),
}

async function deleteNotificationConfigurationWithOptions(request: DeleteNotificationConfigurationRequest, runtime: Util.RuntimeOptions): DeleteNotificationConfigurationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.notificationArn)) {
    query['NotificationArn'] = request.notificationArn;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.scalingGroupId)) {
    query['ScalingGroupId'] = request.scalingGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteNotificationConfiguration',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteNotificationConfiguration(request: DeleteNotificationConfigurationRequest): DeleteNotificationConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteNotificationConfigurationWithOptions(request, runtime);
}

model DeleteScalingConfigurationRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  scalingConfigurationId?: string(name='ScalingConfigurationId', description='The ID of the request.', example='asc-bp1bx8mzur534edp****'),
}

model DeleteScalingConfigurationResponseBody = {
  requestId?: string(name='RequestId', description='auditing', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3****'),
}

model DeleteScalingConfigurationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteScalingConfigurationResponseBody(name='body'),
}

/**
  * Deletes a scaling configuration that is used to create Elastic Compute Service (ECS) instances.
  *
  * @param request DeleteScalingConfigurationRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteScalingConfigurationResponse
 */
async function deleteScalingConfigurationWithOptions(request: DeleteScalingConfigurationRequest, runtime: Util.RuntimeOptions): DeleteScalingConfigurationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.scalingConfigurationId)) {
    query['ScalingConfigurationId'] = request.scalingConfigurationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteScalingConfiguration',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Deletes a scaling configuration that is used to create Elastic Compute Service (ECS) instances.
  *
  * @param request DeleteScalingConfigurationRequest
  * @return DeleteScalingConfigurationResponse
 */
async function deleteScalingConfiguration(request: DeleteScalingConfigurationRequest): DeleteScalingConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteScalingConfigurationWithOptions(request, runtime);
}

model DeleteScalingGroupRequest {
  forceDelete?: boolean(name='ForceDelete', description='The region ID of the scaling group.', example='false'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The ID of the request.', example='cn-qingdao'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  scalingGroupId?: string(name='ScalingGroupId', description='Specifies whether to forcibly delete the scaling group and release Elastic Compute Service (ECS) instances in the scaling group when ECS instances or ongoing scaling activities exist in the scaling group. Valid values:

*   true: forcibly deletes the scaling group. The scaling group is disabled and new scaling requests are rejected. After all existing scaling requests are processed, the ECS instances are removed from the scaling group. Then, the scaling group is deleted. If the ECS instances are manually added to the scaling group, the ECS instances are only removed from the scaling group. If the ECS instances are automatically created and added to the scaling group, the ECS instances are removed from the scaling group and then released.

*   false: does not forcibly delete the scaling group. The scaling group is disabled and then deleted if the following conditions are met:

    *   No scaling activities are in process in the scaling group.
    *   The Total Capacity parameter is set to 0. A value of 0 specifies that no ECS instances exist in the scaling group.

Default value: false.', example='asg-bp18p2yfxow2dloq****'),
}

model DeleteScalingGroupResponseBody = {
  requestId?: string(name='RequestId', description='auditing', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
}

model DeleteScalingGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteScalingGroupResponseBody(name='body'),
}

/**
  * Deletes a scaling group.
  *
  * @param request DeleteScalingGroupRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteScalingGroupResponse
 */
async function deleteScalingGroupWithOptions(request: DeleteScalingGroupRequest, runtime: Util.RuntimeOptions): DeleteScalingGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.forceDelete)) {
    query['ForceDelete'] = request.forceDelete;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.scalingGroupId)) {
    query['ScalingGroupId'] = request.scalingGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteScalingGroup',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Deletes a scaling group.
  *
  * @param request DeleteScalingGroupRequest
  * @return DeleteScalingGroupResponse
 */
async function deleteScalingGroup(request: DeleteScalingGroupRequest): DeleteScalingGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteScalingGroupWithOptions(request, runtime);
}

model DeleteScalingRuleRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The ID of the request.', example='cn-qingdao'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  scalingRuleId?: string(name='ScalingRuleId', description='The region ID of the scaling group.', example='asr-bp163l21e07uhnyt****'),
}

model DeleteScalingRuleResponseBody = {
  requestId?: string(name='RequestId', description='auditing', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3****'),
}

model DeleteScalingRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteScalingRuleResponseBody(name='body'),
}

async function deleteScalingRuleWithOptions(request: DeleteScalingRuleRequest, runtime: Util.RuntimeOptions): DeleteScalingRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.scalingRuleId)) {
    query['ScalingRuleId'] = request.scalingRuleId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteScalingRule',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteScalingRule(request: DeleteScalingRuleRequest): DeleteScalingRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteScalingRuleWithOptions(request, runtime);
}

model DeleteScheduledTaskRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The ID of the request.', example='cn-qingdao'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  scheduledTaskId?: string(name='ScheduledTaskId', description='The region ID of the scheduled task.', example='edRtShc57WGXdt8TlPbr****'),
}

model DeleteScheduledTaskResponseBody = {
  requestId?: string(name='RequestId', description='auditing', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
}

model DeleteScheduledTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteScheduledTaskResponseBody(name='body'),
}

async function deleteScheduledTaskWithOptions(request: DeleteScheduledTaskRequest, runtime: Util.RuntimeOptions): DeleteScheduledTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.scheduledTaskId)) {
    query['ScheduledTaskId'] = request.scheduledTaskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteScheduledTask',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteScheduledTask(request: DeleteScheduledTaskRequest): DeleteScheduledTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteScheduledTaskWithOptions(request, runtime);
}

model DescribeAlarmsRequest {
  alarmTaskId?: string(name='AlarmTaskId', description='The ID of the event-triggered task.', example='asg-bp1hvbnmkl10vll5****_f95ce797-dc2e-4bad-9618-14fee7d1****'),
  isEnable?: boolean(name='IsEnable', description='Specifies whether to enable the event-triggered task. Valid values:

*   true: enables the event-triggered task.
*   false: disables the event-triggered task.', example='true'),
  metricName?: string(name='MetricName', description='The name of the event-triggered task.', example='CpuUtilization'),
  metricType?: string(name='MetricType', description='The type of the metric. Valid values:

*   system: system metrics of CloudMonitor
*   custom: custom metrics that are reported to CloudMonitor', example='true'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page 1.

Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Maximum value: 50.

Default value: 10.', example='10'),
  regionId?: string(name='RegionId', description='The region ID of the event-triggered task.', example='cn-qingdao'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  scalingGroupId?: string(name='ScalingGroupId', description='The ID of the scaling group with which the event-triggered task is associated.', example='asg-bp18p2yfxow2dloq****'),
  state?: string(name='State', description='The status of the event-triggered task. Valid values:

*   ALARM: The alert condition is met and an alert is triggered.
*   OK: The alert condition is not met.
*   INSUFFICIENT_DATA: Auto Scaling cannot determine whether the alert condition is met due to insufficient data.', example='OK'),
}

model DescribeAlarmsResponseBody = {
  alarmList?: [ 
    {
      alarmActions?: [ string ](name='AlarmActions', description='The list of unique identifiers of the scaling rules that are associated with the event-triggered task.'),
      alarmTaskId?: string(name='AlarmTaskId', description='The ID of the event-triggered task.', example='asg-bp1hvbnmkl10vll5****_f95ce797-dc2e-4bad-9618-14fee7d1****'),
      comparisonOperator?: string(name='ComparisonOperator', description='The operator that is used to compare the metric value and the threshold.

*   Valid value if the metric value is greater than or equal to the threshold: >=
*   Valid value if the metric value is less than or equal to the threshold: <=
*   Valid value if the metric value is greater than the threshold: >
*   Valid value if the metric value is less than the threshold: <', example='>='),
      description?: string(name='Description', description='The description of the event-triggered task.', example='Test alarm task.'),
      dimensions?: [ 
        {
          dimensionKey?: string(name='DimensionKey', description='The key of the dimension. Valid values:

*   user_id: the ID of your Alibaba Cloud account
*   scaling_group: the scaling group that you want to monitor
*   device: the type of the NIC
*   state: the state of the TCP connection', example='device'),
          dimensionValue?: string(name='DimensionValue', description='The value of the dimension. The value of the DimensionValue parameter varies based on the value of the DimensionKey parameter.

*   If you set the DimensionKey parameter to `user_id`, the system specifies the value of the DimensionValue parameter.

*   If you set the DimensionKey parameter to `scaling_group`, the system specifies the value of the DimensionValue parameter.

*   If you set the DimensionKey parameter to `device`, you can set the DimensionValue parameter to eth0 or eth1.

    *   For instances that reside in the classic network type, eth0 specifies the internal NIC. Only one eth0 NIC exists on each instance that resides in a VPC.
    *   For instances that reside in the classic network, eth1 specifies the public NIC.

*   If you set the DimensionKey parameter to `state`, you can set the DimensionValue parameter to TCP_TOTAL or ESTABLISHED.

    *   TCP_TOTAL specifies the total number of TCP connections.
    *   ESTABLISHED specifies the number of established TCP connections.', example='eth0'),
        }
      ](name='Dimensions', description='Details of the dimensions.'),
      effective?: string(name='Effective', description='> This parameter is in invitational preview and is unavailable.', example='Test'),
      enable?: boolean(name='Enable', description='Indicates whether the event-triggered task is enabled. Valid values:

*   true: The event-triggered task is enabled.
*   false: The event-triggered task is disabled.', example='true'),
      evaluationCount?: int32(name='EvaluationCount', description='The number of times that the threshold must be reached before a scaling rule can be executed. For example, if you set this parameter to 3, the average CPU utilization must reach or exceed 80% three times in a row before a scaling rule is triggered.', example='3'),
      expressions?: [ 
        {
          comparisonOperator?: string(name='ComparisonOperator', description='The operator that is used to compare the metric value and the threshold.

*   Valid value if the metric value is greater than or equal to the threshold: >=
*   Valid value if the metric value is less than or equal to the threshold: <=
*   Valid value if the metric value is greater than the threshold: >
*   Valid value if the metric value is less than the threshold: <

Default value: >=.', example='>='),
          metricName?: string(name='MetricName', description='The name of the metric that is specified in the multi-metric alert rule. Valid values:

*   CpuUtilization: the CPU utilization of an ECS instance. Unit: %.
*   IntranetTx: the outbound traffic over the internal network from an ECS instance. Unit: KB/min.
*   IntranetRx: the inbound traffic over the Internet to an ECS instance that resides in a VPC. Unit: KB/min.
*   VpcInternetTx: the outbound traffic over the Internet from an ECS instance that resides in a VPC. Unit: KB/min.
*   VpcInternetRx: the inbound traffic over the Internet to an ECS instance that resides in a VPC. Unit: KB/min.
*   SystemDiskReadBps: the number of bytes read from the system disk used by an ECS instance per second.
*   SystemDiskWriteBps: the number of bytes written to the system disk used by an ECS instance per second.
*   SystemDiskReadOps: the number of read operations on the system disk used by an ECS instance per second.
*   SystemDiskWriteOps: the number of write operations on the system disk used by an ECS instance per second.
*   CpuUtilizationAgent: the CPU utilization of an agent. Unit: %.
*   GpuUtilizationAgent: the GPU utilization of an agent. Unit: %.
*   GpuMemoryFreeUtilizationAgent: the percentage of idle GPU memory of an agent.
*   GpuMemoryUtilizationAgent: the GPU memory usage of an agent. Unit: %.
*   MemoryUtilization: the memory usage of an agent. Unit: %.
*   LoadAverage: the average system load of an agent.
*   TcpConnection: the total number of TCP connections of an agent.
*   TcpConnection: the number of established TCP connections of an agent.
*   PackagesNetOut: the number of packets that are sent by the internal NIC used by an agent.
*   PackagesNetIn: the number of packets that are received by the internal NIC used by an agent.
*   EciPodCpuUtilization: the CPU utilization of an elastic container instance. Unit: %.
*   EciPodMemoryUtilization: the memory usage of an elastic container instance. Unit: %.

For more information, see [Event-triggered task for system monitoring](~~74854~~).', example='CpuUtilization'),
          period?: int32(name='Period', description='The period of time during which statistics about the metrics in the multi-metric alert rule is collected. Unit: seconds. Valid values:

*   15
*   60
*   120
*   300
*   900

> If your scaling group is of the ECS type and the event-triggered task associated with your scaling group monitors CloudMonitor metrics, you can set the Period parameter to 15. In most cases, the name of a CloudMonitor metric contains Agent.', example='900'),
          statistics?: string(name='Statistics', description='The method that is used to aggregate statistics about the metrics in the multi-metric alert rule. Valid values:

*   Average
*   Minimum
*   Maximum', example='Average'),
          threshold?: float(name='Threshold', description='The thresholds of the metric values in the multi-metric alert rule. If the thresholds are reached the specified number of times within the specified period, a scaling rule is executed.', example='40.0'),
        }
      ](name='Expressions', description='The expressions that are specified in the multi-metric alert rule.'),
      expressionsLogicOperator?: string(name='ExpressionsLogicOperator', description='The relationship between the trigger conditions that are specified in the multi-metric alert rule. Valid values:

*   `&&`: An alert is triggered only if all metrics in the multi-metric alert rule meet the trigger conditions. In this case, an alert is triggered only if the results of all trigger conditions that are specified in the multi-metric alert rule are `true`.
*   `||`: An alert is triggered if one of the metrics in the multi-metric alert rule meets the trigger conditions.', example='&&'),
      metricName?: string(name='MetricName', description='The name of the metric. Valid values:

*   CpuUtilization: the CPU utilization of an ECS instance. Unit: %.
*   IntranetTx: the outbound traffic over the internal network from an ECS instance. Unit: KB/min.
*   IntranetRx: the inbound traffic over the Internet to an ECS instance that resides in a VPC. Unit: KB/min.
*   VpcInternetTx: the outbound traffic over the Internet from an ECS instance that resides in a VPC. Unit: KB/min.
*   VpcInternetRx: the inbound traffic over the Internet to an ECS instance that resides in a VPC. Unit: KB/min.
*   SystemDiskReadBps: the number of bytes read from the system disk used by an ECS instance per second.
*   SystemDiskWriteBps: the number of bytes written to the system disk used by an ECS instance per second.
*   SystemDiskReadOps: the number of read operations on the system disk used by an ECS instance per second.
*   SystemDiskWriteOps: the number of write operations on the system disk used by an ECS instance per second.
*   CpuUtilizationAgent: the CPU utilization of an agent. Unit: %.
*   GpuMemoryFreeUtilizationAgent: the percentage of idle GPU memory of an agent.
*   GpuMemoryUtilizationAgent: the GPU memory usage of an agent. Unit: %.
*   MemoryUtilization: the memory usage of an agent. Unit: %.
*   LoadAverage: the average system load of an agent.
*   TcpConnection: the total number of TCP connections of an agent.
*   TcpConnection: the number of established TCP connections of an agent.
*   PackagesNetOut: the number of packets that are sent by the internal NIC used by an agent.
*   PackagesNetIn: the number of packets that are received by the internal NIC used by an agent.
*   EciPodCpuUtilization: the CPU utilization of an elastic container instance. Unit: %.
*   EciPodMemoryUtilization: the memory usage of an elastic container instance. Unit: %.

For more information, see [Event-triggered task for system monitoring](~~74854~~).', example='CpuUtilization'),
      metricType?: string(name='MetricType', description='The type of the metric. Valid values:

*   system: system metrics of CloudMonitor
*   custom: custom metrics that are reported to CloudMonitor', example='system'),
      name?: string(name='Name', description='The name of the event-triggered task.', example='TestAlarmTask'),
      period?: int32(name='Period', description='The period of time during which statistics about the metric is collected. Unit: seconds. Valid values:

*   15
*   60
*   120
*   300
*   900

> If your scaling group is of the ECS type and the event-triggered task associated with your scaling group monitors CloudMonitor metrics, you can set the Period parameter to 15. In most cases, the name of a CloudMonitor metric contains Agent.', example='300'),
      scalingGroupId?: string(name='ScalingGroupId', description='The scaling group ID of the event-triggered task.', example='asg-bp18p2yfxow2dloq****'),
      state?: string(name='State', description='The status of the event-triggered task. Valid values:

*   ALARM: The alert condition is met and an alert is triggered.
*   OK: The alert condition is not met.
*   INSUFFICIENT_DATA: Auto Scaling cannot determine whether the alert condition is met due to insufficient data.', example='ALARM'),
      statistics?: string(name='Statistics', description='The method that is used to aggregate statistics for the metric. Valid values:

*   Average
*   Minimum
*   Maximum', example='Average'),
      threshold?: float(name='Threshold', description='The threshold of the metric value. If the threshold is reached the specified times within the specified period, a scaling rule is executed.', example='80.0'),
    }
  ](name='AlarmList', description='The list of event-triggered tasks.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='871C7C53-34A4-45AA-8C14-4B72FA6A****'),
  totalCount?: int32(name='TotalCount', description='The total number of event-triggered tasks.', example='2'),
}

model DescribeAlarmsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAlarmsResponseBody(name='body'),
}

async function describeAlarmsWithOptions(request: DescribeAlarmsRequest, runtime: Util.RuntimeOptions): DescribeAlarmsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alarmTaskId)) {
    query['AlarmTaskId'] = request.alarmTaskId;
  }
  if (!Util.isUnset(request.isEnable)) {
    query['IsEnable'] = request.isEnable;
  }
  if (!Util.isUnset(request.metricName)) {
    query['MetricName'] = request.metricName;
  }
  if (!Util.isUnset(request.metricType)) {
    query['MetricType'] = request.metricType;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.scalingGroupId)) {
    query['ScalingGroupId'] = request.scalingGroupId;
  }
  if (!Util.isUnset(request.state)) {
    query['State'] = request.state;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAlarms',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAlarms(request: DescribeAlarmsRequest): DescribeAlarmsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAlarmsWithOptions(request, runtime);
}

model DescribeEciScalingConfigurationsRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The number of entries to return on each page. Maximum value: 50.

Default value: 10.', example='1'),
  pageSize?: int32(name='PageSize', description='The ID of the scaling group. You can use the ID to query all scaling configurations in the scaling group.', example='50'),
  regionId?: string(name='RegionId', description='The number of the page to return. Pages start from page 1.

Default value: 1.', example='cn-qingdao'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  scalingConfigurationIds?: [ string ](name='ScalingConfigurationIds', description='The IDs of the scaling configurations that you want to query.

The IDs of active and inactive scaling configurations are displayed in the query results. You can differentiate between active and inactive scaling configurations based on the value of the LifecycleState parameter.'),
  scalingConfigurationNames?: [ string ](name='ScalingConfigurationNames', description='The names of the scaling configurations that you want to query.

The names of inactive scaling configurations are not displayed in the query results, and no error is reported.'),
  scalingGroupId?: string(name='ScalingGroupId', description='The IDs of the scaling configurations that you want to query.

The IDs of active and inactive scaling configurations are displayed in the query results. You can differentiate between active and inactive scaling configurations based on the value of the `LifecycleState` parameter.', example='asg-bp17pelvl720x3v7****'),
}

model DescribeEciScalingConfigurationsResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The ID of the request.', example='1'),
  pageSize?: int32(name='PageSize', description='The total number of scaling configurations.', example='50'),
  requestId?: string(name='RequestId', description='Details of the scaling configurations.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  scalingConfigurations?: [ 
    {
      acrRegistryInfos?: [ 
        {
          domains?: [ string ](name='Domains', description='The IP addresses of the DNS servers.'),
          instanceId?: string(name='InstanceId', description='The region ID of the Container Registry Enterprise Edition instance.', example='cri-nwj395hgf6f3****'),
          instanceName?: string(name='InstanceName', description='The domain name of the Container Registry Enterprise Edition instance. By default, all domain names of the Container Registry Enterprise Edition instance are displayed. You can specify one or more domain names. Separate multiple domain names with commas (,).', example='acr-test'),
          regionId?: string(name='RegionId', description='The domain name of the Container Registry Enterprise Edition instance. By default, all domain names of the Container Registry Enterprise Edition instance are displayed. You can specify one or more domain names. Separate multiple domain names with commas (,).', example='cn-hangzhou'),
        }
      ](name='AcrRegistryInfos', description='The ID of the Container Registry Enterprise Edition instance.'),
      activeDeadlineSeconds?: int32(name='ActiveDeadlineSeconds', description='Indicates whether an elastic IP address (EIP) is automatically created, and then bound to the elastic container instance.', example='1000'),
      autoCreateEip?: boolean(name='AutoCreateEip', description='The size of the temporary storage space. Unit: GiB.', example='true'),
      autoMatchImageCache?: boolean(name='AutoMatchImageCache', description='The name of the elastic container instance.', example='false'),
      containerGroupName?: string(name='ContainerGroupName', description='The number of physical CPU cores. This parameter can be specified for only some instance types. For more information, see [Specify custom CPU options](~~197781~~).', example='test'),
      containers?: [ 
        {
          args?: [ string ](name='Args', description='The commands that are run in the container when you use the CLI to perform probes.'),
          commands?: [ string ](name='Commands', description='The commands that are run in the container when you use the CLI to perform probes.'),
          cpu?: float(name='Cpu', description='The minimum number of consecutive failures for a probe to be considered failed after having been successful.

Default value: 3.', example='2.0'),
          environmentVars?: [ 
            {
              fieldRefFieldPath?: string(name='FieldRefFieldPath', description='The container startup commands. You can specify up to 20 commands. Each command can contain up to 256 characters.', example='path'),
              key?: string(name='Key', description='> This parameter is unavailable.', example='PATH'),
              value?: string(name='Value', description='The container startup commands. You can specify up to 20 commands. Each command can contain up to 256 characters.', example='/usr/bin/'),
            }
          ](name='EnvironmentVars', description='The name of the environment variable.'),
          gpu?: int32(name='Gpu', description='Indicates whether the container allocates buffer resources to standard input streams when the container runs. If you do not specify this parameter, an end-of-file (EOF) error may occur. Default value: false.', example='1'),
          image?: string(name='Image', description='The protocol type of HTTP GET requests when you use HTTP requests to perform probes. Valid values:

*   HTTP
*   HTTPS', example='mysql'),
          imagePullPolicy?: string(name='ImagePullPolicy', description='The number of vCPUs that are allocated to the container.', example='Always'),
          livenessProbeExecCommands?: [ string ](name='LivenessProbeExecCommands', description='The arguments that are passed to the container startup commands. You can specify up to 10 arguments.'),
          livenessProbeFailureThreshold?: int32(name='LivenessProbeFailureThreshold', description='The exposed ports and protocols of the container.', example='3'),
          livenessProbeHttpGetPath?: string(name='LivenessProbeHttpGetPath', description='The port number of TcpSocket.', example='/usr/nginx/'),
          livenessProbeHttpGetPort?: int32(name='LivenessProbeHttpGetPort', description='The number of seconds between the time when the startup of the container ends and the time when the probe starts.', example='80'),
          livenessProbeHttpGetScheme?: string(name='LivenessProbeHttpGetScheme', description='Indicates whether interaction is enabled. Valid values:

*   true
*   false

If the value of the Command parameter is /bin/bash, the value of this parameter is true.

Default value: false.', example='HTTP'),
          livenessProbeInitialDelaySeconds?: int32(name='LivenessProbeInitialDelaySeconds', description='The image pulling policy. Valid values:

*   Always: Image pulling is performed each time.
*   IfNotPresent: Image pulling is performed only if on-premises images are unavailable. On-premises images are preferentially used. If no on-premises images are available, image pulling is performed.
*   Never: On-premises images are always used. Image pulling is not performed.', example='10'),
          livenessProbePeriodSeconds?: int32(name='LivenessProbePeriodSeconds', description='The protocol type of HTTP GET requests when you use HTTP requests to perform probes. Valid values:

*   HTTP
*   HTTPS', example='5'),
          livenessProbeSuccessThreshold?: int32(name='LivenessProbeSuccessThreshold', description='The user ID (UID) that is used to run the entry point of the container process.', example='1'),
          livenessProbeTcpSocketPort?: int32(name='LivenessProbeTcpSocketPort', description='The working directory of the container.', example='80'),
          livenessProbeTimeoutSeconds?: int32(name='LivenessProbeTimeoutSeconds', description='The minimum number of consecutive failures for a probe to be considered failed after having been successful.

Default value: 3.', example='10'),
          memory?: float(name='Memory', description='Indicates whether the root file system is set to the read-only mode. The only valid value is true.', example='2.0'),
          name?: string(name='Name', description='The path to which the system sends an HTTP GET request for a probe.', example='nginx'),
          ports?: [ 
            {
              port?: int32(name='Port', description='The volumes that are mounted on the container.', example='8888'),
              protocol?: string(name='Protocol', description='The volumes that are mounted on the container.', example='TCP'),
            }
          ](name='Ports', description='The port number. Valid values: 1 to 65535.'),
          readinessProbeExecCommands?: [ string ](name='ReadinessProbeExecCommands', description='The permissions granted to processes in the container. Valid values: NET_ADMIN and NET_RAW.

> To use NET_RAW, you need to submit a ticket.'),
          readinessProbeFailureThreshold?: int32(name='ReadinessProbeFailureThreshold', description='The exposed ports and protocols of the container.', example='3'),
          readinessProbeHttpGetPath?: string(name='ReadinessProbeHttpGetPath', description='The interval at which probes are performed. Default value: 10. Minimum value: 1. Unit: seconds.', example='/usr/local'),
          readinessProbeHttpGetPort?: int32(name='ReadinessProbeHttpGetPort', description='The timeout period of a probe. Default value: 1. Minimum value: 1. Unit: seconds.', example='/usr/nginx/'),
          readinessProbeHttpGetScheme?: string(name='ReadinessProbeHttpGetScheme', description='The minimum number of consecutive successes for a probe to be considered successful after having failed. Default value: 1. Valid value: 1.', example='HTTP'),
          readinessProbeInitialDelaySeconds?: int32(name='ReadinessProbeInitialDelaySeconds', description='The memory size of the container.', example='5'),
          readinessProbePeriodSeconds?: int32(name='ReadinessProbePeriodSeconds', description='Indicates whether standard input streams are disconnected after a client is disconnected. If Stdin is set to true, standard input streams remain connected during multiple sessions.

If StdinOnce is set to true, standard input streams are connected after the container is started and remain idle until a client is connected to receive data. After the client is disconnected, streams are also disconnected and remain in the disconnected state until the container is started again.', example='1'),
          readinessProbeSuccessThreshold?: int32(name='ReadinessProbeSuccessThreshold', description='The port number of TcpSocket.', example='1'),
          readinessProbeTcpSocketPort?: int32(name='ReadinessProbeTcpSocketPort', description='The path to which the system sends an HTTP GET request for a probe.', example='8888'),
          readinessProbeTimeoutSeconds?: int32(name='ReadinessProbeTimeoutSeconds', description='The number of seconds between the time when the startup of the container ends and the time when the probe starts.', example='5'),
          securityContextCapabilityAdds?: [ string ](name='SecurityContextCapabilityAdds', description='The init containers.'),
          securityContextReadOnlyRootFilesystem?: boolean(name='SecurityContextReadOnlyRootFilesystem', description='The image of the container.', example='true'),
          securityContextRunAsUser?: long(name='SecurityContextRunAsUser', description='The interval at which probes are performed. Default value: 10. Minimum value: 1. Unit: seconds.', example='1000'),
          stdin?: boolean(name='Stdin', description='The name of the container.', example='true'),
          stdinOnce?: boolean(name='StdinOnce', description='The timeout period of a probe. Default value: 1. Minimum value: 1. Unit: seconds.', example='true'),
          tty?: boolean(name='Tty', description='The number of GPUs.', example='false'),
          volumeMounts?: [ 
            {
              mountPath?: string(name='MountPath', description='Details of the environment variables.', example='/pod/data'),
              mountPropagation?: string(name='MountPropagation', description='Details of the environment variables.', example='None'),
              name?: string(name='Name', description='The directory in which the container mounts the volume.

> Data in this directory is overwritten by the data on the volume.', example='default-volume1'),
              readOnly?: boolean(name='ReadOnly', description='The name of the volume. The value of this parameter is the same as the value of the Volumes.Name parameter.', example='false'),
              subPath?: string(name='SubPath', description='The mount propagation setting of the volume. Mount propagation allows the sharing of volumes that are mounted on one container with other containers in the same pod, or even with other pods on the same node. Valid values:

*   None: The volume mount does not receive subsequent mounts that are mounted to this volume or its subdirectories.
*   HostToCotainer: The volume mount receives all subsequent mounts that are mounted to this volume or its subdirectories.
*   Bidirectional: This value is similar to HostToCotainer. The volume mount receives all subsequent mounts that are mounted to this volume or its subdirectories. In addition, all volume mounts that are created by the container are propagated back to the instance and to all containers of all pods that use the same volume.

Default value: None.', example='data2/'),
            }
          ](name='VolumeMounts', description='Indicates whether the volume is read-only.

Default value: false.'),
          workingDir?: string(name='WorkingDir', description='The port to which HTTP GET requests were sent.', example='/usr/local/nginx'),
        }
      ](name='Containers', description='The path to which the system sends an HTTP GET request for a probe.'),
      costOptimization?: boolean(name='CostOptimization', description='auditing', example='false'),
      cpu?: float(name='Cpu', description='The ID of the resource group.', example='2.0'),
      cpuOptionsCore?: int32(name='CpuOptionsCore', description='The containers in the elastic container instance.', example='2'),
      cpuOptionsThreadsPerCore?: int32(name='CpuOptionsThreadsPerCore', description='The weight of the elastic container instance as a backend server. Valid values: 1 to 100.', example='2'),
      creationTime?: string(name='CreationTime', description='The ID of the security group with which the elastic container instance is associated. Elastic container instances that are associated with the same security group can access each other.', example='2014-08-14T10:58Z'),
      description?: string(name='Description', description='The ID of the image cache snapshot.', example='This is an example.'),
      dnsConfigNameServers?: [ string ](name='DnsConfigNameServers', description='The DNS lookup domains.'),
      dnsConfigOptions?: [ 
        {
          name?: string(name='Name', description='The hostname aliases of a container.', example='name'),
          value?: string(name='Value', description='The hostname aliases of a container.', example='value'),
        }
      ](name='DnsConfigOptions', description='The variable name of the option.'),
      dnsConfigSearches?: [ string ](name='DnsConfigSearches', description='The domain names of the Network Time Protocol (NTP) servers.'),
      dnsPolicy?: string(name='DnsPolicy', description='The maximum outbound bandwidth. Unit: bytes.', example='Default'),
      egressBandwidth?: long(name='EgressBandwidth', description='The name of the instance RAM role. You can use an instance RAM role to access both elastic container instances and Elastic Compute Service (ECS) instances. For more information, see [Use the instance RAM role by calling APIs](~~61178~~).', example='1024000'),
      eipBandwidth?: int32(name='EipBandwidth', description='The size of the memory.

You can specify the number of vCPUs and the memory size to determine the range of instance types. For example, you can set the Cpu parameter to 2 and the Memory parameter to 16 to specify the instance types that have 2 vCPUs and 16 GiB of memory. If you specify the Cpu and Memory parameters, Auto Scaling determines available instance types based on factors such as I/O optimization requirements and zones. Then, Auto Scaling preferentially creates instances of the instance type that is provided at the lowest price.

> You can specify CPU and memory specifications to determine the range of instance types only if the Scaling Policy parameter is set to Cost Optimization Policy and no instance type is specified in the scaling configuration.', example='5'),
      ephemeralStorage?: int32(name='EphemeralStorage', description='> This parameter is unavailable.', example='20'),
      hostAliases?: [ 
        {
          hostnames?: [ string ](name='Hostnames', description='The system information of the security context in which the elastic container instance runs.'),
          ip?: string(name='Ip', description='The hostnames that are added.', example='192.0.XX.XX'),
        }
      ](name='HostAliases', description='The IP address that is added.'),
      hostName?: string(name='HostName', description='The region ID of the elastic container instance.', example='[\\"hehe.com\\", \\"haha.com\\"]'),
      imageRegistryCredentials?: [ 
        {
          password?: string(name='Password', description='The username that is used to access the image repository.', example='yourpaasword'),
          server?: string(name='Server', description='The options. Each option is a name-value pair. The value in the name-value pair is optional.', example='registry-vpc.cn-shanghai.aliyuncs.com'),
          userName?: string(name='UserName', description='The options. Each option is a name-value pair. The value in the name-value pair is optional.', example='yourusername'),
        }
      ](name='ImageRegistryCredentials', description='The password that is used to access the image repository.'),
      imageSnapshotId?: string(name='ImageSnapshotId', description='The restart policy of the elastic container instance. Valid values:

*   Never: never restarts the elastic container instance.
*   Always: always restarts the elastic container instance.
*   OnFailure: restarts the elastic container instance upon failures.', example='imc-2zebxkiifuyzzlhl****'),
      ingressBandwidth?: long(name='IngressBandwidth', description='The buffer time in which the program handles operations before the program stops.', example='1024000'),
      initContainers?: [ 
        {
          cpu?: float(name='Cpu', description='The number of GPUs that are allocated to the container.', example='0.5'),
          gpu?: int32(name='Gpu', description='The size of the memory.', example='1'),
          image?: string(name='Image', description='The ID of the user that runs the container.', example='nginx'),
          imagePullPolicy?: string(name='ImagePullPolicy', description='The number of vCPUs.', example='Always'),
          initContainerArgs?: [ string ](name='InitContainerArgs', description='The tags of the elastic container instance. The tags are specified in the key-value pair format.'),
          initContainerCommands?: [ string ](name='InitContainerCommands', description='The container startup arguments.'),
          initContainerEnvironmentVars?: [ 
            {
              fieldRefFieldPath?: string(name='FieldRefFieldPath', description='Details of the init container ports.', example='path'),
              key?: string(name='Key', description='> This parameter is unavailable.', example='PATH'),
              value?: string(name='Value', description='Details of the init container ports.', example='/usr/local/bin'),
            }
          ](name='InitContainerEnvironmentVars', description='The name of the environment variable.'),
          initContainerPorts?: [ 
            {
              port?: int32(name='Port', description='The volumes that are mounted on the container.', example='1'),
              protocol?: string(name='Protocol', description='The volumes that are mounted on the container.', example='TCP'),
            }
          ](name='InitContainerPorts', description='The port number. Valid values: 1 to 65535.'),
          initContainerVolumeMounts?: [ 
            {
              mountPath?: string(name='MountPath', description='The permissions that are granted to the processes in the container. Valid values: NET_ADMIN and NET_RAW.

> To use NET_RAW, you need to submit a ticket.', example='/usr/share/'),
              mountPropagation?: string(name='MountPropagation', description='The permissions that are granted to the processes in the container. Valid values: NET_ADMIN and NET_RAW.

> To use NET_RAW, you need to submit a ticket.', example='None'),
              name?: string(name='Name', description='The directory to which the volume is mounted. Data under this directory is overwritten by the data on the volume.', example='test-empty'),
              readOnly?: boolean(name='ReadOnly', description='The name of the volume.', example='false'),
              subPath?: string(name='SubPath', description='The mount propagation setting of the volume. Mount propagation allows the sharing of volumes that are mounted on one container with other containers in the same pod, or even with other pods on the same node. Valid values:

*   None: The volume mount does not receive subsequent mounts that are mounted to this volume or its subdirectories.
*   HostToCotainer: The volume mount receives all subsequent mounts that are mounted to this volume or its subdirectories.
*   Bidirectional: This value is similar to HostToCotainer. The volume mount receives all subsequent mounts that are mounted to this volume or its subdirectories. In addition, all volume mounts that are created by the container are propagated back to the instance and to all containers of all pods that use the same volume.

Default value: None.', example='/usr/sub/'),
            }
          ](name='InitContainerVolumeMounts', description='Indicates whether the mount path is read-only.

Default value: false.'),
          memory?: float(name='Memory', description='Details of the environment variables.', example='1.0'),
          name?: string(name='Name', description='Details of the environment variables.', example='test-init'),
          securityContextCapabilityAdds?: [ string ](name='SecurityContextCapabilityAdds', description='The container startup commands.'),
          securityContextReadOnlyRootFilesystem?: boolean(name='SecurityContextReadOnlyRootFilesystem', description='The working directory.', example='true'),
          securityContextRunAsUser?: string(name='SecurityContextRunAsUser', description='The name of the container.', example='587'),
          workingDir?: string(name='WorkingDir', description='The container image.', example='/usr/local'),
        }
      ](name='InitContainers', description='Indicates whether the root file system is read-only. The only valid value is true.'),
      instanceFamilyLevel?: string(name='InstanceFamilyLevel', description='5292', example='EnterpriseLevel'),
      ipv6AddressCount?: int32(name='Ipv6AddressCount', description='The bandwidth of the EIP. Default value: 5 Mbit/s.', example='1'),
      lifecycleState?: string(name='LifecycleState', description='The instance family level, which is used to filter the range of instance types that meet the requirements. This parameter takes effect when the `CostOptimization` parameter is set to true. Valid values:

*   EntryLevel: shared instance type. Instances of this level are the most cost-effective but may not provide stable computing performance in a consistent manner. Instances of this level are suitable for business scenarios in which the CPU utilization is low. For more information, see [Shared instance families](~~108489~~).
*   EnterpriseLevel: Instances of this level provide stable performance and dedicated resources, and are suitable for business scenarios that require high stability. For more information, see [Instance family](~~25378~~).
*   CreditEntryLevel: This value is valid only for burstable instances. CPU credits are used to ensure computing performance. Instances of this level are suitable for scenarios in which the CPU utilization is low but may fluctuate in specific cases. For more information, see [Overview](~~59977~~) of burstable instances.', example='Active'),
      loadBalancerWeight?: int32(name='LoadBalancerWeight', description='The hostname.', example='1'),
      memory?: float(name='Memory', description='The maximum hourly price for the preemptible instance.

This parameter is returned only if you set the SpotStrategy parameter to SpotWithPriceLimit.', example='16'),
      ntpServers?: [ string ](name='NtpServers', description='The state of the scaling configuration in the scaling group. Valid values:

*   Active: The scaling configuration is active in the scaling group. Auto Scaling uses active scaling configurations to automatically create ECS instances.
*   Inactive: The scaling configuration is inactive in the scaling group. Auto Scaling does not use inactive scaling configurations to automatically create ECS instances. Inactive scaling configurations are retained in the scaling group.'),
      ramRoleName?: string(name='RamRoleName', description='Indicates whether the image cache is automatically matched. Default value: false.', example='ram:PassRole'),
      regionId?: string(name='RegionId', description='The number of vCPUs of the elastic container instance.', example='cn-hangzhou'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the scaling configuration.', example='rg-8db03793gfrz****'),
      restartPolicy?: string(name='RestartPolicy', description='The maximum inbound bandwidth. Unit: bit/s.', example='Never'),
      scalingConfigurationId?: string(name='ScalingConfigurationId', description='> This parameter is unavailable.', example='asc-bp1ezrfgoyn5kijl****'),
      scalingConfigurationName?: string(name='ScalingConfigurationName', description='The validity period. Unit: seconds.', example='scalingconfi****'),
      scalingGroupId?: string(name='ScalingGroupId', description='The number of IPv6 addresses.', example='asg-bp17pelvl720x3v7****'),
      securityContextSysCtls?: [ 
        {
          name?: string(name='Name', description='Details of the Container Registry Enterprise Edition instances.', example='kernel.msgmax'),
          value?: string(name='Value', description='Details of the Container Registry Enterprise Edition instances.', example='65536'),
        }
      ](name='SecurityContextSysCtls', description='The name of the security context in which the elastic container instance runs.'),
      securityGroupId?: string(name='SecurityGroupId', description='The preemption policy of the instance. Valid values:

*   NoSpot: The instance is created as a regular pay-as-you-go instance.
*   SpotWithPriceLimit: The instance is created as a preemptible instance with a user-defined maximum hourly price.
*   SpotAsPriceGo: The instance is created as a preemptible instance for which the market price at the time of purchase is automatically used as the bid price.', example='sg-bp18kz60mefs****'),
      slsEnable?: boolean(name='SlsEnable', description='The containers in the elastic container instance.', example='False'),
      spotPriceLimit?: float(name='SpotPriceLimit', description='The number of threads per core. This parameter can be specified for only some instance types. If you set this parameter to 1, Hyper-Threading is disabled. For more information, see [Specify custom CPU options](~~197781~~).', example='0.025'),
      spotStrategy?: string(name='SpotStrategy', description='The scaling group ID of the scaling configuration.', example='NoSpot'),
      tags?: [ 
        {
          key?: string(name='Key', description='Details of the volumes.', example='version'),
          value?: string(name='Value', description='Details of the volumes.', example='3'),
        }
      ](name='Tags', description='The key of the tag.'),
      terminationGracePeriodSeconds?: int32(name='TerminationGracePeriodSeconds', description='The Domain Name System (DNS) policy.', example='60'),
      volumes?: [ 
        {
          configFileVolumeConfigFileToPaths?: [ 
            {
              content?: string(name='Content', description='The information about the image repository.', example='bGl1bWk='),
              mode?: int32(name='Mode', description='The information about the image repository.', example='0644'),
              path?: string(name='Path', description='The content of the configuration file (32 KB).', example='/usr/bin/'),
            }
          ](name='ConfigFileVolumeConfigFileToPaths', description='The relative path to the configuration file.'),
          configFileVolumeDefaultMode?: int32(name='ConfigFileVolumeDefaultMode', description='The FlexVolume options. Each option is a key-value pair in a JSON string.

For example, when you use FlexVolume to mount a disk, the format of options is `{"volumeId":"d-2zehdahrwoa7srg****","performanceLevel": "PL2"}`.', example='0644'),
          diskVolumeDiskId?: string(name='DiskVolumeDiskId', description='The storage medium of EmptyDirVolume. If this parameter is left empty, the file system that backs the node is used as the storage medium. If this parameter is set to memory, the memory is used as the storage medium.', example='15'),
          diskVolumeDiskSize?: int32(name='DiskVolumeDiskSize', description='The file system type of the volume. The default value is determined by the script of FlexVolume.', example='15'),
          diskVolumeFsType?: string(name='DiskVolumeFsType', description='The path to the Network File System (NFS) volume.', example='xfs'),
          emptyDirVolumeMedium?: string(name='EmptyDirVolumeMedium', description='The storage size of a disk volume. Unit: GiB.', example='memory'),
          flexVolumeDriver?: string(name='FlexVolumeDriver', description='The endpoint of the NFS server.', example='flexvolume'),
          flexVolumeFsType?: string(name='FlexVolumeFsType', description='The FlexVolume driver name of the volume.', example='ext4'),
          flexVolumeOptions?: string(name='FlexVolumeOptions', description='The name of the volume.', example='{"volumeId":"d-2zehdahrwoa7srg****","performanceLevel": "PL2"}'),
          NFSVolumePath?: string(name='NFSVolumePath', description='Indicates whether the NFS volume is read-only.

Default value: false.', example='/share'),
          NFSVolumeReadOnly?: boolean(name='NFSVolumeReadOnly', description='The default permissions on the ConfigFile volume.', example='false'),
          NFSVolumeServer?: string(name='NFSVolumeServer', description='The paths to configuration files.', example='3f9cd4a596-naw76.cn-shanghai.nas.aliyuncs.com'),
          name?: string(name='Name', description='The paths to configuration files.', example='default-volume1'),
          type?: string(name='Type', description='The file system type of a disk volume.', example='EmptyDirVolume'),
        }
      ](name='Volumes', description='The type of the volume. Valid values:

*   EmptyDirVolume
*   NFSVolume
*   ConfigFileVolume
*   FlexVolume'),
    }
  ](name='ScalingConfigurations', description='The time when the scaling configuration was created.'),
  totalCount?: int32(name='TotalCount', description='Details of the scaling configurations.', example='1'),
}

model DescribeEciScalingConfigurationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeEciScalingConfigurationsResponseBody(name='body'),
}

async function describeEciScalingConfigurationsWithOptions(request: DescribeEciScalingConfigurationsRequest, runtime: Util.RuntimeOptions): DescribeEciScalingConfigurationsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.scalingConfigurationIds)) {
    query['ScalingConfigurationIds'] = request.scalingConfigurationIds;
  }
  if (!Util.isUnset(request.scalingConfigurationNames)) {
    query['ScalingConfigurationNames'] = request.scalingConfigurationNames;
  }
  if (!Util.isUnset(request.scalingGroupId)) {
    query['ScalingGroupId'] = request.scalingGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeEciScalingConfigurations',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeEciScalingConfigurations(request: DescribeEciScalingConfigurationsRequest): DescribeEciScalingConfigurationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEciScalingConfigurationsWithOptions(request, runtime);
}

model DescribeLifecycleActionsRequest {
  lifecycleActionStatus?: string(name='LifecycleActionStatus', description='The token that is used to specify the lifecycle action from which the query starts.

For example, after the first 10 lifecycle actions are queried, the query starts from the 11th lifecycle action. Set this parameter to the NextToken value that is returned in the previous API call. If you do not specify this parameter, the query starts from the beginning.', example='Pending'),
  maxResults?: int32(name='MaxResults', description='The region ID of the scaling group.', example='10'),
  nextToken?: string(name='NextToken', description='The maximum number of entries to return on each page. Valid values: 1 to 50.

Default value: 10.', example='AAAAAcSz4VTb1Nq****'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The query token returned in this call.', example='cn-qingdao'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  scalingActivityId?: string(name='ScalingActivityId', description='The status of the lifecycle action. Valid values:

*   If a lifecycle action is in the Pending state, Elastic Compute Service (ECS) instances are waiting to be added to a scaling group or waiting to be removed from a scaling group.
*   If a lifecycle action is in the Timeout state, the lifecycle hook that triggers the lifecycle action ends, and ECS instances are added to or removed from the scaling group.
*   If a lifecycle action is in the Completed state, you manually end the lifecycle hook that triggers the lifecycle action ahead of schedule.', example='asa-bp17mug9t0pegagw****'),
}

model DescribeLifecycleActionsResponseBody = {
  lifecycleActions?: [ 
    {
      instanceIds?: [ string ](name='InstanceIds', description='The IDs of the ECS instances to which the lifecycle hook applies.'),
      lifecycleActionResult?: string(name='LifecycleActionResult', description='The IDs of the ECS instances to which the lifecycle hook applies.', example='CONTINUE'),
      lifecycleActionStatus?: string(name='LifecycleActionStatus', description='The action that is performed after the lifecycle action triggered by the lifecycle hook is complete. Valid values:

*   CONTINUE: Auto Scaling continues to add ECS instances to the scaling group, or continues to remove ECS instances from the scaling group.
*   ABANDON: Auto Scaling stops adding ECS instances to the scaling group and releases the ECS instances, or continues to respond to scale-in requests and remove ECS instances from the scaling group.', example='Pending'),
      lifecycleActionToken?: string(name='LifecycleActionToken', description='The status of the lifecycle action.', example='9C2E9DA7-F794-449A-ACF6-CEE24444F7BB'),
      lifecycleHookId?: string(name='LifecycleHookId', description='The token of the lifecycle action.', example='ash-bp18uoft0deax0f7****'),
    }
  ](name='LifecycleActions', description='The lifecycle actions.'),
  maxResults?: int32(name='MaxResults', description='The lifecycle actions.', example='3'),
  nextToken?: string(name='NextToken', description='The ID of the request.', example='AAAAAcSz4VTb1Nq****'),
  requestId?: string(name='RequestId', description='The total number of the queried lifecycle actions.', example='42A742EB-FCF3-459E-9C62-E107048C17E3'),
  totalCount?: int32(name='TotalCount', description='The maximum number of entries returned per page.', example='3'),
}

model DescribeLifecycleActionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeLifecycleActionsResponseBody(name='body'),
}

/**
  * Queries lifecycle actions.
  *
  * @param request DescribeLifecycleActionsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeLifecycleActionsResponse
 */
async function describeLifecycleActionsWithOptions(request: DescribeLifecycleActionsRequest, runtime: Util.RuntimeOptions): DescribeLifecycleActionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lifecycleActionStatus)) {
    query['LifecycleActionStatus'] = request.lifecycleActionStatus;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.scalingActivityId)) {
    query['ScalingActivityId'] = request.scalingActivityId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLifecycleActions',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Queries lifecycle actions.
  *
  * @param request DescribeLifecycleActionsRequest
  * @return DescribeLifecycleActionsResponse
 */
async function describeLifecycleActions(request: DescribeLifecycleActionsRequest): DescribeLifecycleActionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLifecycleActionsWithOptions(request, runtime);
}

model DescribeLifecycleHooksRequest {
  lifecycleHookIds?: [ string ](name='LifecycleHookIds', description='The ID of the lifecycle hook.'),
  lifecycleHookName?: string(name='LifecycleHookName', description='The name of the lifecycle hook.', example='lifecyclehook****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page 1.

Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Maximum value: 50.

Default value: 50.', example='50'),
  regionId?: string(name='RegionId', description='The region ID of the scaling group.', example='cn-beijing'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  scalingGroupId?: string(name='ScalingGroupId', description='The ID of the scaling group.', example='asg-bp1igpak5ft1flyp****'),
}

model DescribeLifecycleHooksResponseBody = {
  lifecycleHooks?: [ 
    {
      defaultResult?: string(name='DefaultResult', description='The action that Auto Scaling performs after the lifecycle hook ends.', example='CONTINUE'),
      heartbeatTimeout?: int32(name='HeartbeatTimeout', description='The period of time before the lifecycle hook ends. Auto Scaling performs the specified action after the lifecycle hook ends.', example='60'),
      lifecycleHookId?: string(name='LifecycleHookId', description='The ID of the lifecycle hook.', example='ash-bp19d1032y9kij96****'),
      lifecycleHookName?: string(name='LifecycleHookName', description='The name of the lifecycle hook.', example='lifecyclehook****'),
      lifecycleHookStatus?: string(name='LifecycleHookStatus', description='The status of the lifecycle hook. Valid values:

*   Active
*   InActive', example='Active'),
      lifecycleTransition?: string(name='LifecycleTransition', description='The type of the scaling activity to which the lifecycle hook applies.', example='SCALE_OUT'),
      notificationArn?: string(name='NotificationArn', description='The Alibaba Cloud Resource Name (ARN) of the method that is used by Auto Scaling to send notifications when the lifecycle hook takes effect. Specify the value in one of the following formats:

*   If you do not create a notification rule, specify the value in the `acs:ess:{region-id}:{account-id}:null/null` format.
*   If you specify a Message Service (MNS) queue as the notification method, specify the value in the `acs:mns:{region-id}:{account-id}:queue/{queuename}` format.
*   If you specify an MNS topic as the notification method, specify the value in the `acs:mns:{region-id}:{account-id}:topic/{topicname}` format.
*   If you specify an Operation Orchestration Service (OOS) template as the notification method, specify the value in the `acs:oos:{region-id}:{account-id}:template/{templatename}` format.

The variables in the preceding parameter formats have the following meanings:

*   region-id: the region ID of the scaling group.
*   account-id: the ID of the Alibaba Cloud account.
*   queuename: the name of the MNS queue.
*   topicname: the name of the MNS topic.
*   templatename: the name of the OOS template.', example='acs:ess:cn-beijing:161456884340****:null/null'),
      notificationMetadata?: string(name='NotificationMetadata', description='The fixed string that is included in a notification. Auto Scaling sends the notification when the lifecycle hook takes effect.', example='Test Lifecycle Hook.'),
      scalingGroupId?: string(name='ScalingGroupId', description='The ID of the scaling group.', example='asg-bp1igpak5ft1flyp****'),
    }
  ](name='LifecycleHooks', description='Details of the lifecycle hooks.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='50'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  totalCount?: int32(name='TotalCount', description='The total number of lifecycle hooks.', example='1'),
}

model DescribeLifecycleHooksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeLifecycleHooksResponseBody(name='body'),
}

/**
  * You can use one of the following methods to query lifecycle hooks:
  * *   Specify a list of lifecycle hook IDs by using the LifecycleHookIds parameter. In this case, you do not need to specify the ScalingGroupId and LifecycleHookName parameters.
  * *   Specify the scaling group ID by using the ScalingGroupId parameter.
  * *   Specify the scaling group ID by using the ScalingGroupId parameter and the lifecycle hook name by using the LifecycleHookName parameter at the same time.
  *
  * @param request DescribeLifecycleHooksRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeLifecycleHooksResponse
 */
async function describeLifecycleHooksWithOptions(request: DescribeLifecycleHooksRequest, runtime: Util.RuntimeOptions): DescribeLifecycleHooksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lifecycleHookIds)) {
    query['LifecycleHookIds'] = request.lifecycleHookIds;
  }
  if (!Util.isUnset(request.lifecycleHookName)) {
    query['LifecycleHookName'] = request.lifecycleHookName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.scalingGroupId)) {
    query['ScalingGroupId'] = request.scalingGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLifecycleHooks',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can use one of the following methods to query lifecycle hooks:
  * *   Specify a list of lifecycle hook IDs by using the LifecycleHookIds parameter. In this case, you do not need to specify the ScalingGroupId and LifecycleHookName parameters.
  * *   Specify the scaling group ID by using the ScalingGroupId parameter.
  * *   Specify the scaling group ID by using the ScalingGroupId parameter and the lifecycle hook name by using the LifecycleHookName parameter at the same time.
  *
  * @param request DescribeLifecycleHooksRequest
  * @return DescribeLifecycleHooksResponse
 */
async function describeLifecycleHooks(request: DescribeLifecycleHooksRequest): DescribeLifecycleHooksResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLifecycleHooksWithOptions(request, runtime);
}

model DescribeLimitationRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
}

model DescribeLimitationResponseBody = {
  maxNumberOfAlbServerGroup?: int32(name='MaxNumberOfAlbServerGroup'),
  maxNumberOfDBInstances?: int32(name='MaxNumberOfDBInstances'),
  maxNumberOfLifecycleHooks?: int32(name='MaxNumberOfLifecycleHooks'),
  maxNumberOfLoadBalancers?: int32(name='MaxNumberOfLoadBalancers'),
  maxNumberOfMaxSize?: int32(name='MaxNumberOfMaxSize'),
  maxNumberOfMinSize?: int32(name='MaxNumberOfMinSize'),
  maxNumberOfNotificationConfigurations?: int32(name='MaxNumberOfNotificationConfigurations'),
  maxNumberOfScalingConfigurations?: int32(name='MaxNumberOfScalingConfigurations'),
  maxNumberOfScalingGroups?: int32(name='MaxNumberOfScalingGroups'),
  maxNumberOfScalingInstances?: int32(name='MaxNumberOfScalingInstances'),
  maxNumberOfScalingRules?: int32(name='MaxNumberOfScalingRules'),
  maxNumberOfScheduledTasks?: int32(name='MaxNumberOfScheduledTasks'),
  maxNumberOfVServerGroups?: int32(name='MaxNumberOfVServerGroups'),
  requestId?: string(name='RequestId'),
}

model DescribeLimitationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeLimitationResponseBody(name='body'),
}

async function describeLimitationWithOptions(request: DescribeLimitationRequest, runtime: Util.RuntimeOptions): DescribeLimitationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLimitation',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeLimitation(request: DescribeLimitationRequest): DescribeLimitationResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLimitationWithOptions(request, runtime);
}

model DescribeNotificationConfigurationsRequest {
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The ID of the request.', example='cn-beijing'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  scalingGroupId?: string(name='ScalingGroupId', description='The region ID of the scaling group.', example='asg-bp1igpak5ft1flyp****'),
}

model DescribeNotificationConfigurationsResponseBody = {
  notificationConfigurationModels?: [ 
    {
      notificationArn?: string(name='NotificationArn', description='The ID of the scaling group.', example='acs:mns:cn-beijing:161456884340****:topic/modifyLifecycleHo****'),
      notificationTypes?: [ string ](name='NotificationTypes', description='The types of the notifications.'),
      scalingGroupId?: string(name='ScalingGroupId', description='The types of the notifications.', example='asg-bp1igpak5ft1flyp****'),
    }
  ](name='NotificationConfigurationModels', description='Details of the notifications.'),
  requestId?: string(name='RequestId', description='Details of the notifications.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3****'),
}

model DescribeNotificationConfigurationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeNotificationConfigurationsResponseBody(name='body'),
}

async function describeNotificationConfigurationsWithOptions(request: DescribeNotificationConfigurationsRequest, runtime: Util.RuntimeOptions): DescribeNotificationConfigurationsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.scalingGroupId)) {
    query['ScalingGroupId'] = request.scalingGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeNotificationConfigurations',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeNotificationConfigurations(request: DescribeNotificationConfigurationsRequest): DescribeNotificationConfigurationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeNotificationConfigurationsWithOptions(request, runtime);
}

model DescribeNotificationTypesRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
}

model DescribeNotificationTypesResponseBody = {
  notificationTypes?: [ string ](name='NotificationTypes', description='The types of the notifications.

*   AUTOSCALING:SCALE_OUT_SUCCESS: The scale-out activity succeeds.
*   AUTOSCALING:SCALE_IN_SUCCESS: The scale-in activity succeeds.
*   AUTOSCALING:SCALE_OUT_ERROR: The scale-out activity fails.
*   AUTOSCALING:SCALE_IN_ERROR: The scale-in activity fails.
*   AUTOSCALING:SCALE_REJECT: The request for scaling activities is rejected.
*   AUTOSCALING:SCALE_OUT_START: The scale-out activity starts.
*   AUTOSCALING:SCALE_IN_START: The scale-in activity starts.
*   AUTOSCALING:SCHEDULE_TASK_EXPIRING: Auto Scaling sends a notification when a scheduled task is about to expire.'),
  requestId?: string(name='RequestId', description='The types of the notifications.

*   AUTOSCALING:SCALE_OUT_SUCCESS: The scale-out activity succeeds.
*   AUTOSCALING:SCALE_IN_SUCCESS: The scale-in activity succeeds.
*   AUTOSCALING:SCALE_OUT_ERROR: The scale-out activity fails.
*   AUTOSCALING:SCALE_IN_ERROR: The scale-in activity fails.
*   AUTOSCALING:SCALE_REJECT: The request for scaling activities is rejected.
*   AUTOSCALING:SCALE_OUT_START: The scale-out activity starts.
*   AUTOSCALING:SCALE_IN_START: The scale-in activity starts.
*   AUTOSCALING:SCHEDULE_TASK_EXPIRING: Auto Scaling sends a notification when a scheduled task is about to expire.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3****'),
}

model DescribeNotificationTypesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeNotificationTypesResponseBody(name='body'),
}

async function describeNotificationTypesWithOptions(request: DescribeNotificationTypesRequest, runtime: Util.RuntimeOptions): DescribeNotificationTypesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeNotificationTypes',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeNotificationTypes(request: DescribeNotificationTypesRequest): DescribeNotificationTypesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeNotificationTypesWithOptions(request, runtime);
}

model DescribeRegionsRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The ID of the request.', example='zh-CN'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeRegionsResponseBody = {
  regions?: [ 
    {
      classicUnavailable?: boolean(name='ClassicUnavailable', description='The endpoint of the region.', example='false'),
      localName?: string(name='LocalName', description='China (Beijing)', example='Indicates whether the region supports scaling groups of the virtual private cloud (VPC) type. Valid values:

*   true: The region does not support scaling groups of the VPC type.
*   false: The region supports scaling groups of the VPC type.'),
      regionEndpoint?: string(name='RegionEndpoint', description='The name of the region.', example='ess.aliyuncs.com'),
      regionId?: string(name='RegionId', description='auditing', example='cn-beijing'),
      vpcUnavailable?: boolean(name='VpcUnavailable', description='The ID of the region.', example='false'),
    }
  ](name='Regions', description='Details of the regions.'),
  requestId?: string(name='RequestId', description='Details of the regions.', example='73469C7-AA6F-4DC5-B3DB-A3DC0DE3****'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRegions',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(request, runtime);
}

model DescribeScalingActivitiesRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page 1.

Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Maximum value: 50.

Default value: 10.', example='10'),
  regionId?: string(name='RegionId', description='The region ID of the scaling group to which the scaling activity that you want to query belongs.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  scalingActivityIds?: [ string ](name='ScalingActivityIds', description='The IDs of the scaling activities that you want to query.

> When you call this operation, you must specify one of the `ScalingGroupId` and `ScalingActivityId.N` parameters. Otherwise, an error is reported.'),
  scalingGroupId?: string(name='ScalingGroupId', description='The ID of the scaling group.

> When you call this operation, you must specify one of the `ScalingGroupId` and `ScalingActivityId.N` parameters. Otherwise, an error is reported.', example='asg-bp18p2yfxow2dloq****'),
  statusCode?: string(name='StatusCode', description='The status of the scaling activity. Valid values:

*   Successful: The scaling activity is successful.
*   Warning: The scaling activity is partially successful.
*   Failed: The scaling activity failed.
*   InProgress: The scaling activity is in progress.
*   Rejected: The request to trigger the scaling activity is rejected.', example='Successful'),
}

model DescribeScalingActivitiesResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='CC107349-57B7-4405-B1BF-9BF5AF7F2A46'),
  scalingActivities?: [ 
    {
      attachedCapacity?: string(name='AttachedCapacity', description='The total number of instances that were manually added to the scaling group after the scaling activity was complete.', example='0'),
      autoCreatedCapacity?: string(name='AutoCreatedCapacity', description='The total number of instances that were created by Auto Scaling after the scaling activity was complete.', example='2'),
      cause?: string(name='Cause', description='The reason why the scaling activity was triggered.', example='A user requests to execute scaling rule \\"asr-bp12tcnol686y1ik****\\", changing the Total Capacity from \\"1\\" to \\"2\\".'),
      createdCapacity?: int32(name='CreatedCapacity', description='The number of instances that were created during the scaling activity.', example='1'),
      createdInstances?: [ string ](name='CreatedInstances', description='The instances that were created during the scaling activity.'),
      description?: string(name='Description', description='The description of the scaling activity.', example='Add \\"1\\" ECS instance'),
      destroyedCapacity?: int32(name='DestroyedCapacity', description='The number of instances that were released during the scaling activity.', example='1'),
      destroyedInstances?: [ string ](name='DestroyedInstances', description='The instances that were released during the scaling activity.'),
      detail?: string(name='Detail', description='Details of the scaling activity.', example='"new ECS instances "i-j6c8ilerw, i-j6c8iler4mx" are created."'),
      endTime?: string(name='EndTime', description='The time when the scaling activity was complete.', example='2020-09-10T09:54Z'),
      errorCode?: string(name='ErrorCode', description='The error code that is returned when the scaling activity failed.', example='OperationDenied.NoStock'),
      errorMessage?: string(name='ErrorMessage', description='The error message that is returned when the scaling activity failed.', example='The specified ECS resource is out of stock in this region. Please try again later.'),
      progress?: int32(name='Progress', description='The execution progress of the scaling activity.', example='100'),
      scalingActivityId?: string(name='ScalingActivityId', description='The ID of the scaling activity.', example='asa-bp161xudmuxdzofe****'),
      scalingGroupId?: string(name='ScalingGroupId', description='The ID of the scaling group.', example='asg-bp18p2yfxow2dloq****'),
      scalingInstanceNumber?: int32(name='ScalingInstanceNumber', description='If the scaling activity is a scale-out activity, the value of this parameter indicates the number of instances that were created during the scaling activity or the number of instances that were started from Economical Mode.

If the scaling activity is a scale-in activity, the value of this parameter indicates the number of instances that were deleted during the scaling activity or the number of instances that were stopped in Economical Mode.', example='1'),
      startTime?: string(name='StartTime', description='The time when the scaling activity started.', example='2020-09-10T09:54Z'),
      startedCapacity?: int32(name='StartedCapacity', description='The number of instances that were started from Economical Mode during the scaling activity.', example='1'),
      startedInstances?: [ string ](name='StartedInstances', description='The instances that were started from Economical Mode during the scaling activity.'),
      statusCode?: string(name='StatusCode', description='The status of the scaling activity. Valid values:

*   Successful: The scaling activity is successful.
*   Warning: The scaling activity is partially successful.
*   Failed: The scaling activity failed.
*   InProgress: The scaling activity is in progress.
*   Rejected: The request to trigger the scaling activity is rejected.', example='Successful'),
      statusMessage?: string(name='StatusMessage', description='The status message of the scaling activity.', example='\\"1\\" ECS instances are added'),
      stoppedCapacity?: int32(name='StoppedCapacity', description='The number of instances that were stopped in Economical Mode during the scaling activity.', example='1'),
      stoppedInstances?: [ string ](name='StoppedInstances', description='The instances that were stopped in Economical Mode during the scaling activity.'),
      totalCapacity?: string(name='TotalCapacity', description='The total number of instances in the scaling group after the scaling activity was complete.', example='2'),
    }
  ](name='ScalingActivities', description='Details of the scaling activities.'),
  totalCount?: int32(name='TotalCount', description='The total number of scaling activities.', example='1'),
}

model DescribeScalingActivitiesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeScalingActivitiesResponseBody(name='body'),
}

/**
  * You can specify a scaling group ID to query all scaling activities in the scaling group.
  * You can filter query results based on the status of scaling activities.
  * You can query scaling activities that are executed in the previous 30 days.
  *
  * @param request DescribeScalingActivitiesRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeScalingActivitiesResponse
 */
async function describeScalingActivitiesWithOptions(request: DescribeScalingActivitiesRequest, runtime: Util.RuntimeOptions): DescribeScalingActivitiesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.scalingActivityIds)) {
    query['ScalingActivityIds'] = request.scalingActivityIds;
  }
  if (!Util.isUnset(request.scalingGroupId)) {
    query['ScalingGroupId'] = request.scalingGroupId;
  }
  if (!Util.isUnset(request.statusCode)) {
    query['StatusCode'] = request.statusCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeScalingActivities',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can specify a scaling group ID to query all scaling activities in the scaling group.
  * You can filter query results based on the status of scaling activities.
  * You can query scaling activities that are executed in the previous 30 days.
  *
  * @param request DescribeScalingActivitiesRequest
  * @return DescribeScalingActivitiesResponse
 */
async function describeScalingActivities(request: DescribeScalingActivitiesRequest): DescribeScalingActivitiesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeScalingActivitiesWithOptions(request, runtime);
}

model DescribeScalingActivityDetailRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  scalingActivityId?: string(name='ScalingActivityId', description='The ID of the request.', example='asa-bp1c9djwrgxjyk31****'),
}

model DescribeScalingActivityDetailResponseBody = {
  detail?: string(name='Detail', description='auditing', example='new ECS instances \\"i-bp16t2cgmiiymeqv****\\" are created.'),
  requestId?: string(name='RequestId', description='The ID of the scaling activity.', example='B13527BF-1FBD-4334-A512-20F5E9D3FB4D'),
  scalingActivityId?: string(name='ScalingActivityId', description='Details of the scaling activity.', example='asa-bp1c9djwrgxjyk31****'),
}

model DescribeScalingActivityDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeScalingActivityDetailResponseBody(name='body'),
}

async function describeScalingActivityDetailWithOptions(request: DescribeScalingActivityDetailRequest, runtime: Util.RuntimeOptions): DescribeScalingActivityDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.scalingActivityId)) {
    query['ScalingActivityId'] = request.scalingActivityId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeScalingActivityDetail',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeScalingActivityDetail(request: DescribeScalingActivityDetailRequest): DescribeScalingActivityDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeScalingActivityDetailWithOptions(request, runtime);
}

model DescribeScalingConfigurationsRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page 1.

Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 50.

Default value: 10.', example='50'),
  regionId?: string(name='RegionId', description='The region ID of the scaling group to which the scaling configuration that you want to query belongs.', example='cn-qingdao'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  scalingConfigurationIds?: [ string ](name='ScalingConfigurationIds', description='The IDs of the scaling configurations that you want to query.

The IDs of active and inactive scaling configurations are displayed in the query results. You can differentiate between active and inactive scaling configurations based on the value of the `LifecycleState` parameter.'),
  scalingConfigurationNames?: [ string ](name='ScalingConfigurationNames', description='The names of the scaling configurations that you want to query.

The names of inactive scaling configurations are not displayed in the query results, and no error is reported.'),
  scalingGroupId?: string(name='ScalingGroupId', description='The ID of the scaling group. You can use the ID to query all scaling configurations in the scaling group.', example='asg-bp17pelvl720x3v7****'),
}

model DescribeScalingConfigurationsResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='50'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3****'),
  scalingConfigurations?: [ 
    {
      privatePoolOptions?: {
        id?: string(name='Id'),
        matchCriteria?: string(name='MatchCriteria'),
      }(name='PrivatePoolOptions'),
      affinity?: string(name='Affinity', description='Indicates whether the instance on the dedicated host is associated with the dedicated host. Valid values:

*   default: The instance is not associated with the dedicated host. If you start an instance that was stopped in Economical Mode and the original dedicated host has insufficient resources, the instance is automatically deployed to another dedicated host in the automatic deployment resource pool.
*   host: The instance is associated with the dedicated host. If you start an instance that was stopped in Economical Mode, the instance remains on the original dedicated host. If the original dedicated host has insufficient resources, the instance cannot be started.', example='default'),
      cpu?: int32(name='Cpu', description='The number of vCPUs.

You can specify the number of vCPUs and the memory size to determine the range of instance types. For example, you can set the Cpu parameter to 2 and the Memory parameter to 16 to specify the instance types that have 2 vCPUs and 16 GiB of memory. If you specify the Cpu and Memory parameters, Auto Scaling determines the available instance types based on factors such as I/O optimization requirements and zones. Then, Auto Scaling preferentially creates instances of the instance type that is provided at the lowest price.

> You can specify CPU and memory specifications to determine the range of instance types only if the Scaling Policy parameter is set to Cost Optimization Policy and no instance type is specified in the scaling configuration.', example='2'),
      creationTime?: string(name='CreationTime', description='The time when the scaling configuration was created.', example='2014-08-14T10:58Z'),
      creditSpecification?: string(name='CreditSpecification', description='The performance mode of the burstable instance. Valid values:

*   Standard: standard mode. For more information, see the "Standard mode" section in the [Burstable instances](~~59977~~) topic.
*   Unlimited: unlimited mode. For more information, see the "Unlimited mode" section in the [Burstable instances](~~59977~~) topic.', example='Standard'),
      dataDisks?: [ 
        {
          autoSnapshotPolicyId?: string(name='AutoSnapshotPolicyId', description='The ID of the automatic snapshot policy that is applied to the data disk.', example='sp-bp19nq9enxqkomib****'),
          burstingEnabled?: boolean(name='BurstingEnabled', description='Indicates whether the burst feature is enabled for the data disk. Valid values:

*   true
*   false

> This parameter is available only if you set the `DataDisk.Category` parameter to `cloud_auto`.

For more information, see the [ESSD AutoPL disks](~~368372~~) topic.', example='false'),
          categories?: [ string ](name='Categories', description='The categories of the data disks. The values are sorted based on their priorities. The first value has the highest priority. If Auto Scaling cannot create instances by using the disk that has the highest priority, Auto Scaling creates instances by using the disk that has the next highest priority. Valid values:

*   cloud: basic disk. The DeleteWithInstance parameter of a basic disk that is created together with the instance is set to true.
*   cloud_efficiency: ultra disk.
*   cloud_ssd: standard SSD.
*   cloud_essd: ESSD.'),
          category?: string(name='Category', description='The category of the data disk. Valid values:

*   cloud: basic disk. The DeleteWithInstance parameter of a basic disk that is created together with the instance is set to true.
*   cloud_efficiency: ultra disk.
*   cloud_ssd: standard SSD.
*   ephemeral_ssd: local standard SSD.
*   cloud_essd: ESSD.
*   cloud_auto: ESSD AutoPL disk.', example='cloud'),
          deleteWithInstance?: boolean(name='DeleteWithInstance', description='Indicates whether the data disk is released if the instance to which the data disk is attached is released. Valid values:

*   true
*   false', example='true'),
          description?: string(name='Description', description='The description of the data disk.', example='FinanceDept'),
          device?: string(name='Device', description='The mount target of the data disk.', example='/dev/xvdb'),
          diskName?: string(name='DiskName', description='The name of the data disk.', example='cloud_ssdData'),
          encrypted?: string(name='Encrypted', description='Indicates whether the data disk is encrypted. Valid values:

*   true
*   false

Default value: false.', example='false'),
          KMSKeyId?: string(name='KMSKeyId', description='The ID of the Key Management Service (KMS) key that is used to encrypt the data disk.', example='0e478b7a-4262-4802-b8cb-00d3fb40****'),
          performanceLevel?: string(name='PerformanceLevel', description='The PL of the data disk of the ESSD category.', example='PL1'),
          provisionedIops?: long(name='ProvisionedIops', description='The provisioned input/output operations per second (IOPS) for the data disk.

> IOPS measures the number of read and write operations that an Elastic Block Storage (EBS) device can process per second.', example='100'),
          size?: int32(name='Size', description='The size of the data disk. Unit: GiB.

*   Valid values if you set the Category parameter to cloud: 5 to 2000.
*   Valid values if you set the Category parameter to cloud_efficiency: 20 to 32768.
*   Valid values if you set the Category parameter to cloud_ssd: 20 to 32768.
*   Valid values if you set the Category parameter to cloud_essd: 20 to 32768.
*   Valid values if you set the Category parameter to ephemeral_ssd: 5 to 800.', example='200'),
          snapshotId?: string(name='SnapshotId', description='The ID of the snapshot that is used to create the data disk.', example='s-23f2i****'),
        }
      ](name='DataDisks', description='Details of the data disks.'),
      dedicatedHostId?: string(name='DedicatedHostId', description='The ID of the dedicated host on which the ECS instance is created. Preemptible instances cannot be created on dedicated hosts. If you specify the DedicatedHostId parameter, the SpotStrategy and SpotPriceLimit parameters are ignored.

You can call the DescribeDedicatedHosts operation to query dedicated host IDs.', example='dh-bp67acfmxazb4p****'),
      deploymentSetId?: string(name='DeploymentSetId', description='The ID of the deployment set to which the Elastic Compute Service (ECS) instance belongs.', example='ds-bp1frxuzdg87zh4p****'),
      hostName?: string(name='HostName', description='The hostname of the ECS instance.', example='LocalHost'),
      hpcClusterId?: string(name='HpcClusterId', description='The ID of the Elastic High Performance Computing (E-HPC) cluster to which the ECS instance belongs.', example='hpc-clus****'),
      imageFamily?: string(name='ImageFamily', description='The name of the image family. If you specify this parameter, the latest custom images that are available in the specified image family are returned. You can use the images to create instances. If the ImageId parameter is specified, you cannot specify the ImageFamily parameter.', example='hangzhou-daily-update'),
      imageId?: string(name='ImageId', description='The ID of the image that is used by Auto Scaling to create instances.', example='centos6u5_64_20G_aliaegis_2014****.vhd'),
      imageName?: string(name='ImageName', description='The name of the image file.', example='centos6u5_64_20G_aliaegis_2014****.vhd'),
      imageOwnerAlias?: string(name='ImageOwnerAlias', description='The source of the image. Valid values:

*   system: public images provided by Alibaba Cloud
*   self: custom images that you create
*   others: shared images from other Alibaba Cloud accounts or community images published by other Alibaba Cloud accounts
*   marketplace: images that are available in Alibaba Cloud Marketplace', example='system'),
      instanceDescription?: string(name='InstanceDescription', description='The description of the ECS instance.', example='FinanceDept'),
      instanceGeneration?: string(name='InstanceGeneration', description='The generation of the ECS instance.', example='ecs-3'),
      instanceName?: string(name='InstanceName', description='The name of the ECS instance.', example='instance****'),
      instancePatternInfos?: [ 
        {
          architectures?: [ string ](name='Architectures', description='The architectures of the instance types. Valid values:

*   X86: x86 architecture.
*   Heterogeneous: heterogeneous architecture, such as GPUs and FPGAs.
*   BareMetal: ECS Bare Metal Instance architecture.
*   Arm: ARM architecture.
*   SuperComputeCluster: Super Computing Cluster architecture.'),
          burstablePerformance?: string(name='BurstablePerformance', description='Indicates whether burstable instance types are included. Valid values:

*   Exclude: Burstable instance types are not included.
*   Include: Burstable instance types are included.
*   Required: Only burstable instance types are included.', example='Include'),
          cores?: int32(name='Cores', description='The number of vCPUs of the instance type.', example='2'),
          excludedInstanceTypes?: [ string ](name='ExcludedInstanceTypes', description='The instance types that are excluded. You can use wildcard characters such as an asterisk (\\*) to exclude an instance type or an instance family. Examples:

*   ecs.c6.large: The ecs.c6.large instance type is excluded.
*   ecs.c6.\\*: The c6 instance family is excluded.'),
          instanceFamilyLevel?: string(name='InstanceFamilyLevel', description='The level of the instance family.

*   EntryLevel: shared instance type. Instances of this level are cost-effective, but do not provide stable computing performance. Instances of this level are suitable for scenarios in which the CPU utilization is low. For more information, see [Shared instance families](~~108489~~).
*   EnterpriseLevel: Instances of this level provide stable performance and dedicated resources, and are suitable for scenarios in which high stability is required. For more information, see [Overview of instance families](~~25378~~).
*   CreditEntryLevel: This value is available only for burstable instances. CPU credits are used to ensure computing performance. Instances of this level are suitable for scenarios in which the CPU utilization is low but may fluctuate in specific cases. For more information, see [Overview](~~59977~~) of burstable instances', example='EnterpriseLevel'),
          maxPrice?: float(name='MaxPrice', description='The maximum hourly price for pay-as-you-go instances or preemptible instances.', example='2'),
          memory?: float(name='Memory', description='The memory size of the instance type. Unit: GiB.', example='4'),
        }
      ](name='InstancePatternInfos', description='Details of the intelligent configuration settings, which determines the range of instance types that meet the specified criteria.'),
      instanceType?: string(name='InstanceType', description='The instance type of the ECS instance.', example='ecs.g6.large'),
      instanceTypes?: [ string ](name='InstanceTypes', description='Details of the ECS instance types.'),
      internetChargeType?: string(name='InternetChargeType', description='The billing method for network usage. Valid values:

*   PayByBandwidth: You are charged for the maximum available bandwidth that is specified by the InternetMaxBandwidthOut parameter.
*   PayByTraffic: You are charged for the actual data transfer. The InternetMaxBandwidthOut parameter specifies only the maximum available bandwidth.', example='PayByTraffic'),
      internetMaxBandwidthIn?: int32(name='InternetMaxBandwidthIn', description='The maximum inbound public bandwidth. Unit: Mbit/s. Valid values: 1 to 200.', example='200'),
      internetMaxBandwidthOut?: int32(name='InternetMaxBandwidthOut', description='The maximum outbound public bandwidth. Unit: Mbit/s. Valid values:

*   0 to 100 if you set the InternetChargeType parameter to PayByBandwidth. If you leave this parameter empty, this parameter is automatically set to 0.
*   0 to 100 if you set the InternetChargeType parameter to PayByTraffic. If you leave this parameter empty, an error is reported.', example='0'),
      ioOptimized?: string(name='IoOptimized', description='Indicates whether the instance is I/O optimized. Valid values:

*   none: The instance is not I/O optimized.
*   optimized: The instance is I/O optimized.', example='none'),
      ipv6AddressCount?: int32(name='Ipv6AddressCount', description='The number of randomly generated IPv6 addresses that are allocated to the elastic network interface (ENI).', example='1'),
      keyPairName?: string(name='KeyPairName', description='The name of the key pair that is used to log on to the ECS instance.', example='keypair****'),
      lifecycleState?: string(name='LifecycleState', description='The status of the scaling configuration in the scaling group. Valid values:

*   Active: The scaling configuration is active in the scaling group. Auto Scaling uses the active scaling configuration to automatically create ECS instances.
*   Inactive: The scaling configuration is inactive in the scaling group. Auto Scaling does not use inactive scaling configurations to automatically create ECS instances. Inactive scaling configurations are retained in the scaling group.', example='Active'),
      loadBalancerWeight?: int32(name='LoadBalancerWeight', description='The weight of the ECS instance as a backend server. Valid values: 1 to 100.', example='1'),
      memory?: int32(name='Memory', description='The memory size. Unit: GiB.

You can specify the number of vCPUs and the memory size to determine the range of instance types. For example, you can set the Cpu parameter to 2 and the Memory parameter to 16 to specify the instance types that have 2 vCPUs and 16 GiB of memory. If you specify the Cpu and Memory parameters, Auto Scaling determines the available instance types based on factors such as I/O optimization requirements and zones. Then, Auto Scaling preferentially creates instances of the instance type that is provided at the lowest price.

> You can specify CPU and memory specifications to determine the range of instance types only if the Scaling Policy parameter is set to Cost Optimization Policy and no instance type is specified in the scaling configuration.', example='16'),
      passwordInherit?: boolean(name='PasswordInherit', description='Indicates whether the password preconfigured in the image is used.', example='true'),
      ramRoleName?: string(name='RamRoleName', description='The name of the RAM role that is associated with the ECS instance. The name is provided and maintained by Resource Access Management (RAM). You can call the ListRoles operation to query the available RAM roles.', example='ramrole****'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the ECS instance belongs.', example='rg-aekzn2ou7xo****'),
      scalingConfigurationId?: string(name='ScalingConfigurationId', description='The ID of the scaling configuration.', example='asc-bp1ezrfgoyn5kijl****'),
      scalingConfigurationName?: string(name='ScalingConfigurationName', description='The name of the scaling configuration.', example='scalingconfigura****'),
      scalingGroupId?: string(name='ScalingGroupId', description='The ID of the scaling group to which the scaling configuration belongs.', example='asg-bp17pelvl720x3v7****'),
      schedulerOptions?: {
        managedPrivateSpaceId?: string(name='ManagedPrivateSpaceId', description='> This parameter is in invitational preview and is unavailable.', example='testManagedPrivateSpaceId'),
      }(name='SchedulerOptions', description='> This parameter is in invitational preview and is unavailable.'),
      securityEnhancementStrategy?: string(name='SecurityEnhancementStrategy', description='Indicates whether security hardening is enabled. Valid values:

*   Active: Security hardening is enabled. This value is available only to public images.
*   Deactive: Security hardening is disabled. This value is available to all types of images.', example='Active'),
      securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group with which the ECS instance is associated. ECS instances that are associated with the same security group can access each other.', example='sg-bp18kz60mefs****'),
      securityGroupIds?: [ string ](name='SecurityGroupIds', description='The IDs of the security groups with which the ECS instance is associated. ECS instances that are associated with the same security group can access each other.'),
      spotDuration?: int32(name='SpotDuration', description='The protection period of the preemptible instance. Unit: hours.', example='1'),
      spotInterruptionBehavior?: string(name='SpotInterruptionBehavior', description='The interruption mode of the preemptible instance.', example='Terminate'),
      spotPriceLimits?: [ 
        {
          instanceType?: string(name='InstanceType', description='The instance type of the preemptible instance.', example='ecs.g6.large'),
          priceLimit?: float(name='PriceLimit', description='The price limit of the preemptible instance.', example='0.125'),
        }
      ](name='SpotPriceLimits', description='Details of the preemptible instances.'),
      spotStrategy?: string(name='SpotStrategy', description='The preemption policy that is applied to pay-as-you-go instances and preemptible instances. Valid values:

*   NoSpot: The instance is created as a pay-as-you-go instance.
*   SpotWithPriceLimit: The instance is a preemptible instance that has a user-defined maximum hourly price.
*   SpotAsPriceGo: The instance is created as a preemptible instance for which the market price at the time of purchase is automatically used as the bid price.', example='NoSpot'),
      systemDiskAutoSnapshotPolicyId?: string(name='SystemDiskAutoSnapshotPolicyId', description='The ID of the automatic snapshot policy that is applied to the system disk.', example='sp-bp12m37ccmxvbmi5****'),
      systemDiskBurstingEnabled?: boolean(name='SystemDiskBurstingEnabled', description='Indicates whether the burst feature is enabled for the system disk. Valid values:

*   true
*   false

> This parameter is available only if you set the SystemDisk.Category parameter to cloud_auto.', example='false'),
      systemDiskCategories?: [ string ](name='SystemDiskCategories', description='The categories of the system disks. The values are sorted based on their priorities. The first value has the highest priority. If Auto Scaling cannot create instances by using the disk that has the highest priority, Auto Scaling creates instances by using the disk that has the next highest priority. Valid values:

*   cloud: basic disk
*   cloud_efficiency: ultra disk
*   cloud_ssd: standard SSD
*   cloud_essd: ESSD'),
      systemDiskCategory?: string(name='SystemDiskCategory', description='The category of the system disk. Valid values:

*   cloud: basic disk
*   cloud_efficiency: ultra disk
*   cloud_ssd: standard SSD
*   ephemeral_ssd: local standard SSD
*   cloud_essd: enhanced SSD (ESSD)
*   cloud_auto: ESSD AutoPL disk', example='cloud'),
      systemDiskDescription?: string(name='SystemDiskDescription', description='The description of the system disk.', example='Test system disk.'),
      systemDiskEncryptAlgorithm?: string(name='SystemDiskEncryptAlgorithm', description='The algorithm that is used to encrypt the system disk. Valid values:

*   AES-256
*   SM4-128', example='AES-256'),
      systemDiskEncrypted?: boolean(name='SystemDiskEncrypted', description='Indicates whether the system disk is encrypted. Valid values:

*   true
*   false', example='false'),
      systemDiskKMSKeyId?: string(name='SystemDiskKMSKeyId', description='The ID of the KMS key that is used to encrypt the system disk.', example='0e478b7a-4262-4802-b8cb-00d3fb40****'),
      systemDiskName?: string(name='SystemDiskName', description='The name of the system disk.', example='cloud_ssd_Test'),
      systemDiskPerformanceLevel?: string(name='SystemDiskPerformanceLevel', description='The performance level (PL) of the system disk of the ESSD category.', example='PL1'),
      systemDiskProvisionedIops?: long(name='SystemDiskProvisionedIops', description='The provisioned IOPS for the system disk.

> IOPS measures the number of read and write operations that an EBS device can process per second.', example='100'),
      systemDiskSize?: int32(name='SystemDiskSize', description='The size of the system disk. Unit: GiB.', example='100'),
      tags?: [ 
        {
          key?: string(name='Key', description='The key of tag N. Valid values of N: 1 to 20.

The tag key cannot be an empty string. The tag key can be up to 128 characters in length, and cannot start with `acs:` or `aliyun`. The tag key cannot contain `http://` or `https://`.', example='binary'),
          value?: string(name='Value', description='The value of tag N. Valid values of N: 1 to 20.

The tag value can be an empty string. The tag value can be up to 128 characters in length, and cannot start with `acs:`. The tag value cannot contain `http://` or `https://`.', example='alterTable'),
        }
      ](name='Tags', description='Details of the tags.'),
      tenancy?: string(name='Tenancy', description='Indicates whether the instance is created on a dedicated host. Valid values:

*   default: The instance is created on a non-dedicated host.
*   host: The instance is created on a dedicated host. If you do not specify the DedicatedHostId parameter, Alibaba Cloud selects a dedicated host for the instance.

Default value: default.', example='default'),
      userData?: string(name='UserData', description='The user data of the ECS instance.', example='echo hello ecs!'),
      weightedCapacities?: [ int32 ](name='WeightedCapacities', description='The weight of the instance type. The weight of an instance type indicates the capacity of an instance of the specified instance type in the scaling group. A higher weight indicates that a smaller number of instances of the specified instance type are required to meet the expected capacity requirement.'),
      zoneId?: string(name='ZoneId', description='The zone ID of the ECS instance. You can call the DescribeZones operation to query the most recent zone list.', example='cn-hangzhou-g'),
    }
  ](name='ScalingConfigurations', description='Details of the scaling configurations.'),
  totalCount?: int32(name='TotalCount', description='The total number of scaling configurations.', example='1'),
}

model DescribeScalingConfigurationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeScalingConfigurationsResponseBody(name='body'),
}

async function describeScalingConfigurationsWithOptions(request: DescribeScalingConfigurationsRequest, runtime: Util.RuntimeOptions): DescribeScalingConfigurationsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.scalingConfigurationIds)) {
    query['ScalingConfigurationIds'] = request.scalingConfigurationIds;
  }
  if (!Util.isUnset(request.scalingConfigurationNames)) {
    query['ScalingConfigurationNames'] = request.scalingConfigurationNames;
  }
  if (!Util.isUnset(request.scalingGroupId)) {
    query['ScalingGroupId'] = request.scalingGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeScalingConfigurations',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeScalingConfigurations(request: DescribeScalingConfigurationsRequest): DescribeScalingConfigurationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeScalingConfigurationsWithOptions(request, runtime);
}

model DescribeScalingGroupsRequest {
  groupType?: string(name='GroupType', description='The type of instances that are managed by the scaling group. Valid values:

*   ECS: Elastic Compute Service (ECS) instances
*   ECI: elastic container instances

Default value: ECS.', example='ECS'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page 1.

Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Maximum value: 50.

Default value: 10.', example='10'),
  regionId?: string(name='RegionId', description='The region ID of the scaling group.', example='cn-qingdao'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the scaling group you want to query belongs.

> If the specified resource group contains no scaling groups, null is returned, and no error is reported.', example='rg-123******'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  scalingGroupIds?: [ string ](name='ScalingGroupIds', description='The IDs of the scaling groups that you want to query.

The IDs of inactive scaling groups are not displayed in the query results, and no error is reported.'),
  scalingGroupName?: string(name='ScalingGroupName', description='The name of the scaling group.', example='scalinggroup****'),
  scalingGroupNames?: [ string ](name='ScalingGroupNames', description='The names of the scaling groups that you want to query.

The names of inactive scaling groups are not displayed in the query results, and no error is reported.'),
}

model DescribeScalingGroupsResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3****'),
  scalingGroups?: [ 
    {
      activeCapacity?: int32(name='ActiveCapacity', description='The number of ECS instances that are added to the scaling group and in the In Service state.', example='1'),
      activeScalingConfigurationId?: string(name='ActiveScalingConfigurationId', description='The ID of the active scaling configuration in the scaling group.', example='asc-bp1et2qekq3ojr33****'),
      albServerGroups?: [ 
        {
          albServerGroupId?: string(name='AlbServerGroupId', description='The ID of the ALB server group.', example='sgp-ddwb0y0g6y9bjm****'),
          port?: int32(name='Port', description='The port number used by the ECS instance after Auto Scaling adds the ECS instance to the ALB server group.', example='80'),
          weight?: int32(name='Weight', description='The weight of the ECS instance as a backend server after Auto Scaling adds the ECS instance to the ALB server group.', example='100'),
        }
      ](name='AlbServerGroups', description='Details of the Application Load Balancer (ALB) server groups.'),
      allocationStrategy?: string(name='AllocationStrategy', description='The allocation policy of instances. Auto Scaling selects instance types based on the allocation policy to create the required number of instances. The policy can be applied to pay-as-you-go instances and preemptible instances. This parameter is available only if you set the `MultiAZPolicy` parameter to `COMPOSABLE`. Valid values:

*   priority: Auto Scaling selects instance types based on the specified orders of the instance types to create the required number of instances.
*   lowestPrice: Auto Scaling selects instance types that have the lowest unit price of vCPUs to create the required number of instances.', example='priority'),
      azBalance?: boolean(name='AzBalance', description='Indicates whether instances in the scaling group are evenly distributed across zones. This parameter is available only if you set the `MultiAZPolicy` parameter to `COMPOSABLE`. Valid values:

*   true
*   false', example='false'),
      compensateWithOnDemand?: boolean(name='CompensateWithOnDemand', description='Indicates whether pay-as-you-go instances can be automatically created to meet the requirement on the number of ECS instances when the expected capacity of preemptible instances cannot be provided due to reasons such as cost-related issues and insufficient resources. This parameter is available only if you set the MultiAZPolicy parameter to COST_OPTIMIZED. Valid values:

*   true
*   false', example='true'),
      creationTime?: string(name='CreationTime', description='The time at which the scaling group was created.', example='2014-08-14T10:58Z'),
      currentHostName?: string(name='CurrentHostName', description='> This parameter is unavailable.', example='hostname'),
      customPolicyARN?: string(name='CustomPolicyARN', description='The Alibaba Cloud Resource Name (ARN) of the custom scale-in policy (Function). This parameter is available only if you specify CustomPolicy as the first step to remove instances.', example='acs:fc:cn-zhangjiakou:16145688****:services/ess_custom_terminate_policy.LATEST/functions/ess_custom_terminate_policy_name'),
      DBInstanceIds?: [ string ](name='DBInstanceIds', description='The IDs of the ApsaraDB RDS instances that are associated with the scaling group.'),
      defaultCooldown?: int32(name='DefaultCooldown', description='The cooldown time of the scaling group. During the cooldown time, Auto Scaling executes only the scaling activities that are triggered by [CloudMonitor](~~35170~~) event-triggered tasks.', example='60'),
      desiredCapacity?: int32(name='DesiredCapacity', description='The expected number of ECS instances in the scaling group. Auto Scaling automatically maintains the expected number of ECS instances in the scaling group.', example='5'),
      groupDeletionProtection?: boolean(name='GroupDeletionProtection', description='Indicates whether deletion protection is enabled for the scaling group. Valid values:

*   true: Deletion protection is enabled for the scaling group. This way, the scaling group cannot be deleted.
*   false: Deletion protection is disabled for the scaling group.', example='true'),
      groupType?: string(name='GroupType', description='The type of instances that are managed by the scaling group.', example='ECS'),
      healthCheckType?: string(name='HealthCheckType', description='The health check mode of the scaling group. Valid values:

*   NONE: Auto Scaling does not perform health checks.
*   ECS: Auto Scaling performs health checks on ECS instances in the scaling group.', example='ECS'),
      initCapacity?: int32(name='InitCapacity', description='The number of instances that are in the Initialized state before the instances are scaled out in the scaling group.', example='0'),
      isElasticStrengthInAlarm?: boolean(name='IsElasticStrengthInAlarm', description='> This parameter is unavailable.', example='false'),
      launchTemplateId?: string(name='LaunchTemplateId', description='The ID of the launch template that is used by the scaling group.', example='lt-m5e3ofjr1zn1aw7****'),
      launchTemplateOverrides?: [ 
        {
          instanceType?: string(name='InstanceType', description='The instance type. The instance type that is specified by this parameter overrides the instance type that is specified in the launch template.', example='ecs.c5.xlarge'),
          spotPriceLimit?: float(name='SpotPriceLimit', description='The maximum bid price of instance type N that is specified by the `LaunchTemplateOverride.N.InstanceType` parameter. You can specify N instance types by using the Extended Configurations feature of the launch template. Valid values of N: 1 to 10

> This parameter is available only if you specify the `LaunchTemplateId` parameter.', example='0.025'),
          weightedCapacity?: int32(name='WeightedCapacity', description='The weight of the instance type. The value of this parameter indicates the capacity of a single instance of the specified instance type in the scaling group. A greater weight indicates that a smaller number of instances of the specified instance type are required to meet the expected capacity requirement.', example='4'),
        }
      ](name='LaunchTemplateOverrides', description='The information about the instance types that are specified by using the Extended Configurations feature of the launch template.'),
      launchTemplateVersion?: string(name='LaunchTemplateVersion', description='The version of the launch template that is used by the scaling group.', example='Default'),
      lifecycleState?: string(name='LifecycleState', description='The status of the scaling group. Valid values:

*   Active: The scaling group is active. Active scaling groups can receive requests to execute scaling rules and trigger scaling activities.
*   Inactive: The scaling group is inactive. Inactive scaling groups cannot receive requests to execute scaling rules.
*   Deleting: The scaling group is being deleted. Scaling groups that are being deleted cannot receive requests to execute scaling rules. In addition, the parameter settings of the scaling groups cannot be modified.', example='Active'),
      loadBalancerIds?: [ string ](name='LoadBalancerIds', description='The IDs of the CLB instances that are associated with the scaling group.'),
      maxInstanceLifetime?: int32(name='MaxInstanceLifetime', description='The maximum life span of the instance in the scaling group. Unit: seconds.

Valid values: 0 or 86400 to the value of the `Integer.maxValue` parameter. The value 0 indicates that the instance has an unlimited life span in the scaling group.

Default value: null.

> This parameter is unavailable for scaling groups that manage elastic container instances or scaling groups whose ScalingPolicy parameter is set to recycle.', example='null'),
      maxSize?: int32(name='MaxSize', description='The maximum number of ECS instances that is allowed in the scaling group.', example='2'),
      minSize?: int32(name='MinSize', description='The minimum number of ECS instances that must be contained in the scaling group.', example='1'),
      modificationTime?: string(name='ModificationTime', description='The time when the scaling group was modified.', example='2014-08-14T10:58Z'),
      monitorGroupId?: string(name='MonitorGroupId', description='The ID of the CloudMonitor application group that is associated with the scaling group.', example='1497****'),
      multiAZPolicy?: string(name='MultiAZPolicy', description='The scaling policy for the multi-zone scaling group that contains ECS instances. Valid values:

*   PRIORITY: ECS instances are scaled based on the value of the VSwitchIds.N parameter. If Auto Scaling fails to create ECS instances in the zone where the vSwitch that has the highest priority resides, Auto Scaling creates ECS instances in the zone where the vSwitch that has the next highest priority resides.

*   COST_OPTIMIZED: ECS instances are scaled based on the unit price of vCPUs. Auto Scaling preferentially creates ECS instances whose vCPUs have the lowest price. If preemptible instance types are specified in the scaling configuration, Auto Scaling preferentially creates preemptible instances. You can use the CompensateWithOnDemand parameter to specify whether to automatically create pay-as-you-go instances when preemptible instances cannot be created due to insufficient resources.

    **

    **Note**The COST_OPTIMIZED setting takes effect only when multiple instance types are specified or at least one preemptible instance type is specified.

*   BALANCE: ECS instances are evenly distributed across multiple zones that are specified for the scaling group. If ECS instances are unevenly distributed across the specified zones due to insufficient resources, you can call the RebalanceInstance operation to evenly distribute the instances across the zones.', example='PRIORITY'),
      onDemandBaseCapacity?: int32(name='OnDemandBaseCapacity', description='The minimum number of pay-as-you-go instances that must be contained in the scaling group. Valid values: 0 to 1000. If the number of pay-as-you-go instances is less than the value of this parameter, Auto Scaling preferentially creates pay-as-you-go instances.', example='30'),
      onDemandPercentageAboveBaseCapacity?: int32(name='OnDemandPercentageAboveBaseCapacity', description='The percentage of pay-as-you-go instances among the excess instances when the minimum number of pay-as-you-go instances reaches the requirement. Valid values: 0 to 100.', example='20'),
      pendingCapacity?: int32(name='PendingCapacity', description='The number of ECS instances that are being added to the scaling group and still being configured.', example='0'),
      pendingWaitCapacity?: int32(name='PendingWaitCapacity', description='The number of ECS instances that are in the Pending Add state in the scaling group.', example='1'),
      protectedCapacity?: int32(name='ProtectedCapacity', description='The number of ECS instances that are in the Protected state in the scaling group.', example='1'),
      regionId?: string(name='RegionId', description='The region ID of the scaling group.', example='cn-qingdao'),
      removalPolicies?: [ string ](name='RemovalPolicies', description='Details of the policies that are used to remove ECS instances from the scaling group. Valid values:

*   OldestInstance: ECS instances that are created at the earliest point in time are removed.
*   NewestInstance: ECS instances that are created at the most recent point in time are removed.
*   OldestScalingConfiguration: ECS instances that are created based on the earliest scaling configuration are removed.'),
      removingCapacity?: int32(name='RemovingCapacity', description='The number of ECS instances that are being removed from the scaling group.', example='0'),
      removingWaitCapacity?: int32(name='RemovingWaitCapacity', description='The number of ECS instances that are in the Pending Remove state in the scaling group.', example='1'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the scaling group belongs.', example='rg-123****'),
      scalingGroupId?: string(name='ScalingGroupId', description='The ID of the scaling group.', example='asg-bp14wlu85wrpchm0****'),
      scalingGroupName?: string(name='ScalingGroupName', description='The name of the scaling group.', example='dyrSuvBOtO1dEdIlIbp****'),
      scalingPolicy?: string(name='ScalingPolicy', description='The reclaim mode of the scaling group. Valid values:

*   recycle: economical mode
*   release: release mode', example='recycle'),
      serverGroups?: [ 
        {
          port?: int32(name='Port', description='弹性伸缩将ECS实例添加到ALB服务器组后，ECS实例使用的端口号。', example='80'),
          serverGroupId?: string(name='ServerGroupId', description='服务器组ID。', example='sgp-i9ouakeaerr*****'),
          type?: string(name='Type', description='服务器组类型，可能值：

- ALB。
- NLB。
> 支持的服务器组类型包括：
- 应用型负载均衡ALB（Application Load Balancer）
- 网络型负载均衡NLB（Network Load Balancer）', example='ALB'),
          weight?: int32(name='Weight', description='弹性伸缩将ECS实例添加到服务器组后，ECS实例作为后端服务器的权重。', example='100'),
        }
      ](name='ServerGroups', description='负载均衡服务器组的相关信息集合。

> 您可以通过此参数获取伸缩组关联的ALB类型服务组和NLB类型服务器组的相关信息集合。
>'),
      spotAllocationStrategy?: string(name='SpotAllocationStrategy', description='The allocation policy of preemptible instances. You can use this parameter to individually specify the allocation policy of preemptible instances. This parameter is available only if you set the `MultiAZPolicy` parameter to `COMPOSABLE`. Valid values:

*   priority: Auto Scaling selects instance types based on the specified orders of the instance types to create the required number of preemptible instances.
*   lowestPrice: Auto Scaling selects instance types that have the lowest unit price of vCPUs to create the required number of preemptible instances.

Default value: priority.', example='lowestPrice'),
      spotInstancePools?: int32(name='SpotInstancePools', description='The number of instance types that are specified. Auto Scaling evenly creates preemptible instances of multiple instance types that are provided at the lowest price across zones. Valid values: 0 to 10.', example='5'),
      spotInstanceRemedy?: boolean(name='SpotInstanceRemedy', description='Indicates whether preemptible instances can be supplemented. If this parameter is set to true, Auto Scaling creates an instance to replace a preemptible instance when Auto Scaling receives the system message that indicates that the preemptible instance is to be reclaimed.', example='true'),
      standbyCapacity?: int32(name='StandbyCapacity', description='The number of instances that are in the Standby state in the scaling group.', example='1'),
      stoppedCapacity?: int32(name='StoppedCapacity', description='The number of instances that are stopped in Economical Mode in the scaling group.', example='1'),
      suspendedProcesses?: [ string ](name='SuspendedProcesses', description='The processes that are suspended. If no process is suspended, null is returned. Valid values:

*   ScaleIn: scale-in processes
*   ScaleOut: scale-out processes
*   HealthCheck: health check processes
*   AlarmNotification: event-triggered task processes
*   ScheduledAction: scheduled task processes'),
      systemSuspended?: boolean(name='SystemSuspended', description='Indicates whether scaling activities are stopped by Auto Scaling in the scaling group. Valid values:

*   true: If scaling activities fail for more than seven consecutive days, the scaling activities are stopped by Auto Scaling in the scaling group. You must modify the scaling group or scaling configuration to resume the execution of the scaling activities.
*   false: Scaling activities are not stopped by Auto Scaling in the scaling group.', example='true'),
      totalCapacity?: int32(name='TotalCapacity', description='If the WeightedCapacity parameter is specified, the value of this parameter indicates the total weighted capacity of all ECS instances in the scaling group. In other cases, the value of this parameter indicates the total number of ECS instances in the scaling group.', example='1'),
      totalInstanceCount?: int32(name='TotalInstanceCount', description='The total number of ECS instances in the scaling group.', example='1'),
      VServerGroups?: [ 
        {
          loadBalancerId?: string(name='LoadBalancerId', description='The ID of the Classic Load Balancer (CLB) instance to which the backend vServer group belongs.', example='147b46d767c-cn-qingdao-cm5****'),
          VServerGroupAttributes?: [ 
            {
              port?: int32(name='Port', description='The port number that is used by the CLB instance to provide external services.', example='22'),
              VServerGroupId?: string(name='VServerGroupId', description='The ID of the backend vServer group.', example='rsp-bp12bjrny****'),
              weight?: int32(name='Weight', description='The weight of the backend vServer group.', example='1'),
            }
          ](name='VServerGroupAttributes', description='Details of the backend vServer group attributes.'),
        }
      ](name='VServerGroups', description='The backend vServer groups.'),
      vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch that is associated with the scaling group.', example='vsw-bp1whw2u46cn8zubm****'),
      vSwitchIds?: [ string ](name='VSwitchIds', description='The IDs of the vSwitches that are associated with the scaling group. If you specify the VSwitchIds parameter, the VSwitchId parameter is ignored.'),
      vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC) in which the scaling group resides.', example='vpc-bp1vwnn14rqpyiczj****'),
    }
  ](name='ScalingGroups', description='Details of the scaling groups.'),
  totalCount?: int32(name='TotalCount', description='The total number of scaling groups.', example='1'),
}

model DescribeScalingGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeScalingGroupsResponseBody(name='body'),
}

async function describeScalingGroupsWithOptions(request: DescribeScalingGroupsRequest, runtime: Util.RuntimeOptions): DescribeScalingGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupType)) {
    query['GroupType'] = request.groupType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.scalingGroupIds)) {
    query['ScalingGroupIds'] = request.scalingGroupIds;
  }
  if (!Util.isUnset(request.scalingGroupName)) {
    query['ScalingGroupName'] = request.scalingGroupName;
  }
  if (!Util.isUnset(request.scalingGroupNames)) {
    query['ScalingGroupNames'] = request.scalingGroupNames;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeScalingGroups',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeScalingGroups(request: DescribeScalingGroupsRequest): DescribeScalingGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeScalingGroupsWithOptions(request, runtime);
}

model DescribeScalingInstancesRequest {
  creationType?: string(name='CreationType', description='The method that is used to create the ECS instance. Valid values:

*   AutoCreated: The ECS instance is automatically created by Auto Scaling based on the instance configuration source of the scaling group.
*   Attached: The ECS instance is manually added to the scaling group.', example='AutoCreated'),
  healthStatus?: string(name='HealthStatus', description='The health status of the ECS instance in the scaling group. If ECS instances do not run as expected, Auto Scaling considers the ECS instances unhealthy. Valid values:

*   Healthy
*   Unhealthy

Auto Scaling automatically removes unhealthy ECS instances from the scaling group and then releases the automatically created instances among the unhealthy instances.

Unhealthy ECS instances that are manually added to the scaling group are released based on the management mode of the instance lifecycles. If the lifecycles of the ECS instances are not managed by the scaling group, Auto Scaling removes the instances from the scaling group but does not release the instances. If the lifecycles of the ECS instances are managed by the scaling group, Auto Scaling removes the instances from the scaling group and releases the instances.

>  Make sure that you have sufficient balance within your Alibaba Cloud account. If you have overdue payments within your Alibaba Cloud account, pay-as-you-go and preemptible instances are stopped or released. For information about how the states of ECS instances change when you have overdue payments within your Alibaba Cloud account, see [Overdue payments](~~170589~~).', example='Healthy'),
  instanceIds?: [ string ](name='InstanceIds', description='The IDs of the ECS instances.

Invalid instance IDs are not displayed in the query result, and no error is reported.'),
  lifecycleState?: string(name='LifecycleState', description='The lifecycle state of the ECS instance in the scaling group. Valid values:

*   InService: The ECS instance is added to the scaling group and provides services as expected.
*   Pending: The ECS instance is being added to the scaling group. During this process, Auto Scaling adds the ECS instance to the backend server groups of the associated CLB instance and adds the private IP address of the ECS instance to the IP address whitelist of the associated ApsaraDB RDS instance.
*   Pending:Wait: The ECS instance is pending to be added to the scaling group. If a lifecycle hook that applies to scale-out activities is created for the scaling group, the ECS instance enters the Pending:Wait state. The ECS instance is added to the scaling group only after the lifecycle hook times out.
*   Protected: The ECS instance is being protected. The ECS instance can provide services as expected. However, Auto Scaling does not manage the lifecycle of the ECS instance. You must manually manage the lifecycle of the ECS instance.
*   Standby: The ECS instance is on standby. The ECS instance is out of service and the weight of the ECS instance as a backend server is set to zero. Auto Scaling does not manage the lifecycle of the ECS instance. You must manually manage the lifecycle of the ECS instance.
*   Stopped: The ECS instance is stopped. The ECS instance is stopped and cannot provide services.
*   Removing: The ECS instance is being removed from the scaling group. During this process, Auto Scaling removes the ECS instance from the backend server groups of the associated CLB instance and removes the IP address of the ECS instance from the IP address whitelist of the associated ApsaraDB RDS instance.
*   Removing:Wait: The ECS instance is being removed from the scaling group and enters the Removing:Wait state. If a lifecycle hook that applies to scale-in activities is created for the scaling group, the ECS instance enters the Removing:Wait state. The ECS instance is removed from the scaling group only after the lifecycle hook times out.', example='InService'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page 1.

Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Maximum value: 100.

Default value: 10.', example='10'),
  regionId?: string(name='RegionId', description='The region ID of the scaling group.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  scalingActivityId?: string(name='ScalingActivityId', description='The ID of the scaling activity.', example='asa-bp1c9djwrgxjyk31****'),
  scalingConfigurationId?: string(name='ScalingConfigurationId', description='The ID of the associated scaling configuration.', example='asc-bp1i65jd06v04vdh****'),
  scalingGroupId?: string(name='ScalingGroupId', description='The ID of the scaling group.', example='asg-bp1igpak5ft1flyp****'),
}

model DescribeScalingInstancesResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='B13527BF-1FBD-4334-A512-20F5E9D3FB4D'),
  scalingInstances?: [ 
    {
      createdTime?: string(name='CreatedTime', description='The time when the ECS instance was added to the scaling group. The value is accurate to seconds.', example='2020-05-18T03:11:39Z'),
      creationTime?: string(name='CreationTime', description='The time when the ECS instance was added to the scaling group. The value is accurate to minutes.', example='2020-05-18T03:11Z'),
      creationType?: string(name='CreationType', description='The method that is used to create the ECS instance. Valid values:

*   AutoCreated: The ECS instance is automatically created by Auto Scaling based on the instance configuration source of the scaling group.
*   Attached: The ECS instance is manually added to the scaling group.', example='AutoCreated'),
      entrusted?: boolean(name='Entrusted', description='Indicates whether the lifecycles of the ECS instances that are manually added to the scaling group are managed by the scaling group. If the scaling group manages the lifecycles of the ECS instances that are manually added, Auto Scaling releases the ECS instances after Auto Scaling removes the ECS instances from the scaling group. The release rule does not apply to ECS instances that are manually removed from the scaling group. Valid values:

*   true
*   false', example='true'),
      healthStatus?: string(name='HealthStatus', description='The health status of the ECS instance in the scaling group. If the ECS instance does not run as expected, Auto Scaling considers the ECS instance unhealthy. Valid values:

*   Healthy
*   Unhealthy

Auto Scaling automatically removes unhealthy ECS instances from the scaling group and then releases the automatically created instances among the unhealthy instances.

Unhealthy ECS instances that are manually added to the scaling group are released based on the management mode of the instance lifecycles. If the lifecycles of the ECS instances are not managed by the scaling group, Auto Scaling removes the instances from the scaling group but does not release the instances. If the lifecycles of the ECS instances are managed by the scaling group, Auto Scaling removes the instances from the scaling group and releases the instances.

>  Make sure that you have sufficient balance within your Alibaba Cloud account. If you have overdue payments within your Alibaba Cloud account, pay-as-you-go and preemptible instances are stopped or released. For information about how the states of ECS instances change when you have overdue payments within your Alibaba Cloud account, see [Overdue payments](~~170589~~).', example='Healthy'),
      instanceId?: string(name='InstanceId', description='The ID of the ECS instance.', example='i-bp109k5j3dum1ce6****'),
      launchTemplateId?: string(name='LaunchTemplateId', description='The ID of the launch template.', example='lt-m5e3ofjr1zn1aw7****'),
      launchTemplateVersion?: string(name='LaunchTemplateVersion', description='The version number of the launch template.', example='1'),
      lifecycleState?: string(name='LifecycleState', description='The lifecycle state of the ECS instance in the scaling group. Valid values:

*   InService: The ECS instance is added to the scaling group and provides services as expected.
*   Pending: The ECS instance is being added to the scaling group. During this process, Auto Scaling adds the ECS instance to the backend server groups of the associated CLB instance and adds the private IP address of the ECS instance to the IP address whitelist of the associated ApsaraDB RDS instance.
*   Pending:Wait: The ECS instance is pending to be added to the scaling group. If a lifecycle hook that applies to scale-out activities is created for the scaling group, the ECS instance enters the Pending:Wait state. The ECS instance is added to the scaling group only after the lifecycle hook times out.
*   Protected: The ECS instance is being protected. The ECS instance can provide services as expected. However, Auto Scaling does not manage the lifecycle of the ECS instance. You must manually manage the lifecycle of the ECS instance.
*   Standby: The ECS instance is on standby. The ECS instance is out of service and the weight of the ECS instance as a backend server is set to zero. Auto Scaling does not manage the lifecycle of the ECS instance. You must manually manage the lifecycle of the ECS instance.
*   Stopped: The ECS instance is stopped. The ECS instance is stopped and cannot provide services.
*   Removing: The ECS instance is being removed from the scaling group. During this process, Auto Scaling removes the ECS instance from the backend server groups of the associated CLB instance and removes the IP address of the ECS instance from the IP address whitelist of the associated ApsaraDB RDS instance.
*   Removing:Wait: The ECS instance is being removed from the scaling group and enters the Removing:Wait state. If a lifecycle hook that applies to scale-in activities is created for the scaling group, the ECS instance enters the Removing:Wait state. The ECS instance is removed from the scaling group only after the lifecycle hook times out.', example='InService'),
      loadBalancerWeight?: int32(name='LoadBalancerWeight', description='The weight of the ECS instance as a backend server.', example='50'),
      scalingActivityId?: string(name='ScalingActivityId', description='The ID of the scaling activity during which the ECS instance is added to the scaling group.', example='asa-bp1c9djwrgxjyk31****'),
      scalingConfigurationId?: string(name='ScalingConfigurationId', description='The ID of the associated scaling configuration.', example='asc-bp1i65jd06v04vdh****'),
      scalingGroupId?: string(name='ScalingGroupId', description='The ID of the scaling group to which the ECS instance belongs.', example='asg-bp1igpak5ft1flyp****'),
      spotStrategy?: string(name='SpotStrategy', description='The bidding policy for the preemptible instance. Valid values:

*   SpotWithPriceLimit: The instance is created as a preemptible instance with a user-defined maximum hourly price.
*   SpotAsPriceGo: The instance is created as a preemptible instance for which the market price at the time of purchase is automatically used as the bid price.', example='SpotWithPriceLimit'),
      warmupState?: string(name='WarmupState', description='The warmup state of the ECS instance. Valid values:

*   NoNeedWarmup: The instance does not need to be warmed up.
*   WaitingForInstanceWarmup: The instance is being warmed up.
*   InstanceWarmupFinish: The instance is warmed up.', example='NoNeedWarmup'),
      weightedCapacity?: int32(name='WeightedCapacity', description='The weight of the instance type. The weight indicates the capacity of a single instance of the specified instance type in the scaling group. A higher weight indicates that a smaller number of instances of the specified instance type are required to meet the expected capacity requirement.', example='4'),
      zoneId?: string(name='ZoneId', description='The zone ID of the ECS instance.', example='cn-hangzhou-g'),
    }
  ](name='ScalingInstances', description='Details of the ECS instances.'),
  totalCount?: int32(name='TotalCount', description='The total number of the ECS instances in the scaling group.', example='1'),
  totalSpotCount?: int32(name='TotalSpotCount', description='The total number of preemptible instances that run as expected in the scaling group.', example='4'),
}

model DescribeScalingInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeScalingInstancesResponseBody(name='body'),
}

/**
  * You can query ECS instances by scaling group ID, scaling configuration ID, health status, lifecycle status, and instance creation method.
  *
  * @param request DescribeScalingInstancesRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeScalingInstancesResponse
 */
async function describeScalingInstancesWithOptions(request: DescribeScalingInstancesRequest, runtime: Util.RuntimeOptions): DescribeScalingInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.creationType)) {
    query['CreationType'] = request.creationType;
  }
  if (!Util.isUnset(request.healthStatus)) {
    query['HealthStatus'] = request.healthStatus;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.lifecycleState)) {
    query['LifecycleState'] = request.lifecycleState;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.scalingActivityId)) {
    query['ScalingActivityId'] = request.scalingActivityId;
  }
  if (!Util.isUnset(request.scalingConfigurationId)) {
    query['ScalingConfigurationId'] = request.scalingConfigurationId;
  }
  if (!Util.isUnset(request.scalingGroupId)) {
    query['ScalingGroupId'] = request.scalingGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeScalingInstances',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can query ECS instances by scaling group ID, scaling configuration ID, health status, lifecycle status, and instance creation method.
  *
  * @param request DescribeScalingInstancesRequest
  * @return DescribeScalingInstancesResponse
 */
async function describeScalingInstances(request: DescribeScalingInstancesRequest): DescribeScalingInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeScalingInstancesWithOptions(request, runtime);
}

model DescribeScalingRulesRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The number of entries to return on each page. Maximum value: 50.

Default value: 10.', example='1'),
  pageSize?: int32(name='PageSize', description='The ID of the scaling group.', example='50'),
  regionId?: string(name='RegionId', description='The number of the page to return. Pages start from page 1.

Default value: 1.', example='cn-qingdao'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  scalingGroupId?: string(name='ScalingGroupId', description='The type of the scaling rule. Valid values:

*   SimpleScalingRule: adjusts the number of ECS instances based on the values of the AdjustmentType and AdjustmentValue parameters.
*   TargetTrackingScalingRule: calculates the number of ECS instances that need to be scaled in a dynamic manner and maintains the value of a predefined metric close to the value of the TargetValue parameter.
*   StepScalingRule: scales ECS instances in steps based on the specified thresholds and metric values.
*   PredictiveScalingRule: uses machine learning to analyze historical monitoring data of the scaling group and predicts the future values of metrics. In addition, Auto Scaling automatically creates scheduled tasks to adjust the boundary values for the scaling group.', example='asg-bp1ffogfdauy0jw0****'),
  scalingRuleAris?: [ string ](name='ScalingRuleAris', description='The unique identifiers of the scaling rules that you want to query.'),
  scalingRuleIds?: [ string ](name='ScalingRuleIds', description='The IDs of the scaling rules that you want to query.'),
  scalingRuleNames?: [ string ](name='ScalingRuleNames', description='The names of the scaling rules that you want to query.'),
  scalingRuleType?: string(name='ScalingRuleType', description='Specifies whether to return CloudMonitor event-triggered tasks associated with scaling rules. Valid values:

*   true
*   false

Default value: false.', example='SimpleScalingRule'),
  showAlarmRules?: boolean(name='ShowAlarmRules', description='The IDs of the scaling rules that you want to query.', example='false'),
}

model DescribeScalingRulesResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The number of entries returned per page.', example='1'),
  pageSize?: int32(name='PageSize', description='The total number of scaling rules.', example='50'),
  requestId?: string(name='RequestId', description='The page number of the returned page.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3****'),
  scalingRules?: [ 
    {
      adjustmentType?: string(name='AdjustmentType', description='The maximum number of ECS instances in the scaling group. You must specify the InitialMaxSize and PredictiveValueBehavior parameters.', example='QuantityChangeInCapacity'),
      adjustmentValue?: int32(name='AdjustmentValue', description='The number of consecutive times that the event-triggered task created for scale-out activities must meet the threshold conditions before an alert is triggered. After a target tracking scaling rule is created, an event-triggered task is automatically created and then associated with the target tracking scaling rule.', example='1'),
      alarms?: [ 
        {
          alarmTaskId?: string(name='AlarmTaskId', description='The comparison operator between the metric value and the threshold for the event-triggered task that is associated with the scaling rule. The comparison operator indicates the relationship between the metric value and the threshold that is required to meet the condition.

*   Valid value if the metric value is greater than or equal to the threshold: >=.
*   Valid value if the metric value is less than or equal to the threshold: <=.
*   Valid value if the metric value is greater than the threshold: >.
*   Valid value if the metric value is less than the threshold: <.', example='asg-bp18p2yfxow2dloq****_1f9458d1-70e1-4bee-8c7f-7a47695b****'),
          alarmTaskName?: string(name='AlarmTaskName', description='The type of the event-triggered task that is associated with the scaling rule. Valid values:

*   system: system monitoring event-triggered tasks
*   custom: custom monitoring event-triggered tasks', example='alarmtask****'),
          comparisonOperator?: string(name='ComparisonOperator', description='The name of the metric of the event-triggered task that is associated with the scaling rule.', example='>='),
          dimensions?: [ 
            {
              dimensionKey?: string(name='DimensionKey', description='The value of the dimension that is associated with the metric.', example='scaling_group'),
              dimensionValue?: string(name='DimensionValue', description='The step adjustments of the step scaling rule.', example='asg-bp18p2yfxow2dloq****'),
            }
          ](name='Dimensions', description='The dimensions of the event-triggered task that is associated with the scaling rule.'),
          evaluationCount?: int32(name='EvaluationCount', description='The name of the event-triggered task that is associated with the scaling rule.', example='3'),
          metricName?: string(name='MetricName', description='The number of consecutive times for which the event-triggered task that is associated with the scaling rule meets the threshold expressions before an alert is triggered.', example='CpuUtilization'),
          metricType?: string(name='MetricType', description='The alert threshold of the event-triggered task that is associated with the scaling rule.', example='system'),
          statistics?: string(name='Statistics', description='The dimensions of the event-triggered task that is associated with the scaling rule.', example='Average'),
          threshold?: float(name='Threshold', description='The statistical method of the event-triggered task that is associated with the scaling rule. Valid values:

*   Average
*   Maximum
*   Minimum', example='50'),
        }
      ](name='Alarms', description='The event-triggered tasks that are associated with the scaling rule. Event-triggered tasks that are associated with the scaling rule are returned only if you set the ShowAlarmRules parameter to true. Otherwise, an empty list is returned.'),
      cooldown?: int32(name='Cooldown', description='The maximum number of ECS instances in the scaling group.', example='20'),
      disableScaleIn?: boolean(name='DisableScaleIn', description='The name of the scaling rule.', example='true'),
      estimatedInstanceWarmup?: int32(name='EstimatedInstanceWarmup', description='The number of consecutive times that the event-triggered task created for scale-in activities must meet the threshold conditions before an alert is triggered. After a target tracking scaling rule is created, an event-triggered task is automatically created and then associated with the target tracking scaling rule.', example='300'),
      initialMaxSize?: int32(name='InitialMaxSize', description='The warmup period of the ECS instance.', example='100'),
      maxSize?: int32(name='MaxSize', description='The percentage of the increment to the predicted value when the PredictiveValueBehavior parameter is set to PredictiveValueOverrideMaxWithBuffer. If the predicted value increased by this percentage is greater than the initial maximum capacity, the increased value is used as the maximum value for prediction tasks. Valid values: 0 to 100.', example='2'),
      metricName?: string(name='MetricName', description='The scaling mode of the scaling rule. Valid values:

*   QuantityChangeInCapacity: adds the specified number of ECS instances to or removes the specified number of ECS instances from the scaling group.
*   PercentChangeInCapacity: adds the specified percentage of ECS instances to or removes the specified percentage of ECS instances from the scaling group.
*   TotalCapacity: adjusts the number of ECS instances in the scaling group to the specified number.', example='CpuUtilization'),
      minAdjustmentMagnitude?: int32(name='MinAdjustmentMagnitude', description='The unique identifier of the scaling rule.', example='1'),
      minSize?: int32(name='MinSize', description='The ID of the scaling group.', example='1'),
      predictiveScalingMode?: string(name='PredictiveScalingMode', description='The minimum number of instances that must be scaled when the AdjustmentType parameter is set to PercentChangeInCapacity. This parameter takes effect only if you set the ScalingRuleType parameter to SimpleScalingRule or StepScalingRule.', example='PredictAndScale'),
      predictiveTaskBufferTime?: int32(name='PredictiveTaskBufferTime', description='The minimum number of ECS instances in the scaling group.', example='30'),
      predictiveValueBehavior?: string(name='PredictiveValueBehavior', description='The target value of the metric.', example='MaxOverridePredictiveValue'),
      predictiveValueBuffer?: int32(name='PredictiveValueBuffer', description='The type of the scaling rule. Valid values:

*   SimpleScalingRule: adjusts the number of ECS instances based on the values of the AdjustmentType and AdjustmentValue parameters.
*   TargetTrackingScalingRule: calculates the number of ECS instances that need to be scaled in a dynamic manner and maintains the value of a predefined metric close to the value of the TargetValue parameter.
*   StepScalingRule: scales ECS instances in steps based on specified thresholds and metric values.
*   PredictiveScalingRule: uses machine learning to analyze historical monitoring data of the scaling group and predicts the future values of metrics. In addition, Auto Scaling automatically creates scheduled tasks to adjust the boundary values for the scaling group.', example='50'),
      scaleInEvaluationCount?: int32(name='ScaleInEvaluationCount', description='Specifies whether to disable scale-in. This parameter is available only if you set the ScalingRuleType parameter to TargetTrackingScalingRule. Valid values:

*   true
*   false', example='15'),
      scaleOutEvaluationCount?: int32(name='ScaleOutEvaluationCount', description='The mode of the predictive scaling rule. Valid values:

*   PredictAndScale: produces predictions and creates prediction tasks.
*   PredictOnly: produces predictions but does not create prediction tasks.', example='3'),
      scalingGroupId?: string(name='ScalingGroupId', description='Specifies which one of the initial maximum capacity and the predicted value can be used as the maximum value for prediction tasks. Valid values:

*   MaxOverridePredictiveValue: uses the initial maximum capacity as the maximum value for prediction tasks if the predicted value is greater than the initial maximum capacity.
*   PredictiveValueOverrideMax: uses the predicted value as the maximum value for prediction tasks when the predicted value is greater than the initial maximum capacity.
*   PredictiveValueOverrideMaxWithBuffer: increases the predicted value by a percentage that is specified by the PredictiveValueBuffer parameter. If the predicted value that is increased by the percentage is greater than the initial maximum capacity, the increased value is used as the maximum value for prediction tasks.', example='asg-bp1ffogfdauy0jw0****'),
      scalingRuleAri?: string(name='ScalingRuleAri', description='The amount of buffer time before the prediction task is executed. By default, all scheduled tasks that are automatically created for a predictive scaling rule are executed on the hour. You can specify a buffer time for resource preparation before prediction tasks are executed. Valid values: 0 to 60. Unit: minutes.', example='ari:acs:ess:cn-hangzhou:140692647406****:scalingrule/asr-bp1dvirgwkoowxk7****'),
      scalingRuleId?: string(name='ScalingRuleId', description='The event-triggered tasks that are associated with the scaling rule. Event-triggered tasks that are associated with the scaling rule are returned only if you set the ShowAlarmRules parameter to true. Otherwise, an empty list is returned.', example='asr-bp1dvirgwkoowxk7****'),
      scalingRuleName?: string(name='ScalingRuleName', description='The ID of the scaling rule.', example='scalingrule****'),
      scalingRuleType?: string(name='ScalingRuleType', description='The adjustment value that is specified in the scaling rule.', example='SimpleScalingRule'),
      stepAdjustments?: [ 
        {
          metricIntervalLowerBound?: float(name='MetricIntervalLowerBound', description='auditing', example='1.0'),
          metricIntervalUpperBound?: float(name='MetricIntervalUpperBound', description='The number of ECS instances that are scaled in a step adjustment.', example='5.0'),
          scalingAdjustment?: int32(name='ScalingAdjustment', description='The lower limit that is specified in a step adjustment. Valid values: -9.999999E18 to 9.999999E18.', example='1'),
        }
      ](name='StepAdjustments', description='The step adjustments of the step scaling rule.'),
      targetValue?: float(name='TargetValue', description='The cooldown time of the scaling rule. This parameter is available only if you set the ScalingRuleType parameter to SimpleScalingRule. Valid values: 0 to 86400. Unit: seconds.', example='0.125'),
    }
  ](name='ScalingRules', description='Details of the scaling rules.'),
  totalCount?: int32(name='TotalCount', description='Details of the scaling rules.', example='1'),
}

model DescribeScalingRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeScalingRulesResponseBody(name='body'),
}

/**
  * Queries all scaling rules in a scaling group.
  *
  * @param request DescribeScalingRulesRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeScalingRulesResponse
 */
async function describeScalingRulesWithOptions(request: DescribeScalingRulesRequest, runtime: Util.RuntimeOptions): DescribeScalingRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.scalingGroupId)) {
    query['ScalingGroupId'] = request.scalingGroupId;
  }
  if (!Util.isUnset(request.scalingRuleAris)) {
    query['ScalingRuleAris'] = request.scalingRuleAris;
  }
  if (!Util.isUnset(request.scalingRuleIds)) {
    query['ScalingRuleIds'] = request.scalingRuleIds;
  }
  if (!Util.isUnset(request.scalingRuleNames)) {
    query['ScalingRuleNames'] = request.scalingRuleNames;
  }
  if (!Util.isUnset(request.scalingRuleType)) {
    query['ScalingRuleType'] = request.scalingRuleType;
  }
  if (!Util.isUnset(request.showAlarmRules)) {
    query['ShowAlarmRules'] = request.showAlarmRules;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeScalingRules',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Queries all scaling rules in a scaling group.
  *
  * @param request DescribeScalingRulesRequest
  * @return DescribeScalingRulesResponse
 */
async function describeScalingRules(request: DescribeScalingRulesRequest): DescribeScalingRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeScalingRulesWithOptions(request, runtime);
}

model DescribeScheduledTasksRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page 1.

Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 50.

Default value: 10.', example='50'),
  regionId?: string(name='RegionId', description='The region ID of the scaling group to which the scheduled task belongs.', example='cn-qingdao'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  scalingGroupId?: string(name='ScalingGroupId', description='The ID of the scaling group to which the scheduled task belongs.', example='asg-bp1bo5tca4m56nap****'),
  scheduledActions?: [ string ](name='ScheduledActions', description='The actions that you want Auto Scaling to perform when the scheduled task is triggered.'),
  scheduledTaskIds?: [ string ](name='ScheduledTaskIds', description='The ID of the scheduled task that you want to query.'),
  scheduledTaskNames?: [ string ](name='ScheduledTaskNames', description='The names of the scheduled tasks that you want to query.'),
}

model DescribeScheduledTasksResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='50'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  scheduledTasks?: [ 
    {
      description?: string(name='Description', description='The description of the scheduled task.', example='Test scheduled task.'),
      desiredCapacity?: int32(name='DesiredCapacity', description='The expected number of instances in the scaling group if you specify the ScalingGroupId parameter.', example='10'),
      launchExpirationTime?: int32(name='LaunchExpirationTime', description='The time period during which the failed scheduled task is retried. Unit: seconds. Valid values: 0 to 21600.', example='600'),
      launchTime?: string(name='LaunchTime', description='The point in time at which the scheduled task is triggered.', example='2014-08-18T10:52Z'),
      maxValue?: int32(name='MaxValue', description='The maximum number of instances in the scaling group if you specify the ScalingGroupId parameter.', example='10'),
      minValue?: int32(name='MinValue', description='The minimum number of instances in the scaling group if you specify the ScalingGroupId parameter.', example='0'),
      recurrenceEndTime?: string(name='RecurrenceEndTime', description='The end time of the recurrence of the scheduled task.', example='2014-08-20T16:55Z'),
      recurrenceType?: string(name='RecurrenceType', description='The interval at which the scheduled task is repeated.', example='Daily'),
      recurrenceValue?: string(name='RecurrenceValue', description='The number of recurrences of the scheduled task.', example='1'),
      scalingGroupId?: string(name='ScalingGroupId', description='The ID of the scaling group to which the scheduled task belongs.', example='asg-bp1bo5tca4m56nap****'),
      scheduledAction?: string(name='ScheduledAction', description='The scaling rule that is executed when the scheduled task is triggered. This parameter is returned only after a scaling rule is specified for the scheduled task.', example='ari:acs:ess:cn-hangzhou:1406926474****:scalingrule/asr-bp1id5rhu8edp7kd****'),
      scheduledTaskId?: string(name='ScheduledTaskId', description='The ID of the scheduled task.', example='edRtShc57WGXdt8TlPbr****'),
      scheduledTaskName?: string(name='ScheduledTaskName', description='The name of the scheduled task.', example='scheduled****'),
      taskEnabled?: boolean(name='TaskEnabled', description='Indicates whether the scheduled task is enabled.

*   true
*   false

Default value: true.', example='true'),
    }
  ](name='ScheduledTasks', description='Details of the scheduled tasks.'),
  totalCount?: int32(name='TotalCount', description='The total number of scheduled tasks.', example='1'),
}

model DescribeScheduledTasksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeScheduledTasksResponseBody(name='body'),
}

/**
  * You can query scheduled tasks by scaling rule, task ID, or task name.
  *
  * @param request DescribeScheduledTasksRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeScheduledTasksResponse
 */
async function describeScheduledTasksWithOptions(request: DescribeScheduledTasksRequest, runtime: Util.RuntimeOptions): DescribeScheduledTasksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.scalingGroupId)) {
    query['ScalingGroupId'] = request.scalingGroupId;
  }
  if (!Util.isUnset(request.scheduledActions)) {
    query['ScheduledActions'] = request.scheduledActions;
  }
  if (!Util.isUnset(request.scheduledTaskIds)) {
    query['ScheduledTaskIds'] = request.scheduledTaskIds;
  }
  if (!Util.isUnset(request.scheduledTaskNames)) {
    query['ScheduledTaskNames'] = request.scheduledTaskNames;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeScheduledTasks',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can query scheduled tasks by scaling rule, task ID, or task name.
  *
  * @param request DescribeScheduledTasksRequest
  * @return DescribeScheduledTasksResponse
 */
async function describeScheduledTasks(request: DescribeScheduledTasksRequest): DescribeScheduledTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeScheduledTasksWithOptions(request, runtime);
}

model DetachAlbServerGroupsRequest {
  albServerGroups?: [ 
    {
      albServerGroupId?: string(name='AlbServerGroupId', description='The port number used by the ECS instances in the ALB server group.', example='sgp-ddwb0y0g6y9bjm****'),
      port?: int32(name='Port', description='The ID of the scaling activity in which the ALB server group is disassociated from the scaling group and the ECS instances in the ALB server group are removed from the ALB server group. This parameter is returned only after you set the `ForceDetach` parameter to `true`.', example='22'),
    }
  ](name='AlbServerGroups', description='Details of the ALB server groups.'),
  clientToken?: string(name='ClientToken', description='Specifies whether to remove existing Elastic Compute Service (ECS) instances from the ALB server group that you want to disassociate from the scaling group. Valid values:

*   true: removes existing ECS instances and returns the value of the `ScalingActivityId` parameter. You can use the scaling activity ID to check whether the ECS instances are removed.
*   false: does not remove existing ECS instances.

Default value: false.', example='123e4567-e89b-12d3-a456-42665544****'),
  forceDetach?: boolean(name='ForceDetach', description='Details of the ALB server groups.', example='false'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The ID of the scaling group.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  scalingGroupId?: string(name='ScalingGroupId', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that the value is unique among different requests.

The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure the idempotence of a request](~~25965~~).', example='asg-bp18p2yfxow2dloq****'),
}

model DetachAlbServerGroupsResponseBody = {
  requestId?: string(name='RequestId', description='auditing', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  scalingActivityId?: string(name='ScalingActivityId', description='The ID of the request.', example='asa-2ze6wxj8vsohn6j9****'),
}

model DetachAlbServerGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetachAlbServerGroupsResponseBody(name='body'),
}

async function detachAlbServerGroupsWithOptions(request: DetachAlbServerGroupsRequest, runtime: Util.RuntimeOptions): DetachAlbServerGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.albServerGroups)) {
    query['AlbServerGroups'] = request.albServerGroups;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.forceDetach)) {
    query['ForceDetach'] = request.forceDetach;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.scalingGroupId)) {
    query['ScalingGroupId'] = request.scalingGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DetachAlbServerGroups',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detachAlbServerGroups(request: DetachAlbServerGroupsRequest): DetachAlbServerGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachAlbServerGroupsWithOptions(request, runtime);
}

model DetachDBInstancesRequest {
  clientToken?: string(name='ClientToken', description='The IDs of the ApsaraDB RDS instances. You can specify up to five ApsaraDB RDS instances.', example='123e4567-e89b-12d3-a456-42665544****'),
  DBInstances?: [ string ](name='DBInstances', description='The IDs of the ApsaraDB RDS instances. You can specify up to five ApsaraDB RDS instances.'),
  forceDetach?: boolean(name='ForceDetach', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that the value is unique among different requests.

The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25965~~).', example='false'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The ID of the request.', example='cn-qingdao'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  scalingGroupId?: string(name='ScalingGroupId', description='Specifies whether to remove the private IP addresses of instances in the scaling group from the whitelist that manages access to the ApsaraDB RDS instance with which the scaling group is associated. Valid values:

*   true
*   false

Default value: false.', example='asg-bp1igpak5ft1flyp****'),
}

model DetachDBInstancesResponseBody = {
  requestId?: string(name='RequestId', description='auditing', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3****'),
}

model DetachDBInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetachDBInstancesResponseBody(name='body'),
}

async function detachDBInstancesWithOptions(request: DetachDBInstancesRequest, runtime: Util.RuntimeOptions): DetachDBInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBInstances)) {
    query['DBInstances'] = request.DBInstances;
  }
  if (!Util.isUnset(request.forceDetach)) {
    query['ForceDetach'] = request.forceDetach;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.scalingGroupId)) {
    query['ScalingGroupId'] = request.scalingGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DetachDBInstances',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detachDBInstances(request: DetachDBInstancesRequest): DetachDBInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachDBInstancesWithOptions(request, runtime);
}

model DetachInstancesRequest {
  decreaseDesiredCapacity?: boolean(name='DecreaseDesiredCapacity', description='Specifies whether to remove the instances from the default server group and vServer groups of the Classic Load Balancer (CLB) instance that is associated with the scaling group, and whether to remove the IP addresses of the instances from the whitelist that manages access to the ApsaraDB RDS instance that is associated with the scaling group.

If you set this parameter to both, the instances are removed from the default sever group and vServer groups of the associated CLB instance, and the IP addresses of the instances are removed from the whitelist that manages access to the associated ApsaraDB RDS instance.', example='true'),
  detachOption?: string(name='DetachOption', description='The IDs of the ECS instances or elastic container instances that you want to remove from the scaling group.', example='both'),
  instanceIds?: [ string ](name='InstanceIds', description='The IDs of the ECS instances or elastic container instances that you want to remove from the scaling group. You can specify 1 to 20 instance IDs.

Examples:

*   The ID of the ECS instance that you want to remove is `i-bp109k5j3dum1ce6****`.
*   The ID of the elastic container instance that you want to remove is `eci-bp17gw49eu09yiwm****`.'),
  lifecycleHook?: boolean(name='LifecycleHook', description='The ID of the scaling activity.', example='false'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  scalingGroupId?: string(name='ScalingGroupId', description='Specifies whether to adjust the expected number of instances in the scaling group. Valid values:

*   true: After a specific number of instances are removed from the scaling group, the expected number of instances in the scaling group decreases.
*   false: After a specific number of instances are removed from the scaling group, the expected number of instances in the scaling group remains unchanged.

Default value: true.', example='asg-bp1igpak5ft1flyp****'),
}

model DetachInstancesResponseBody = {
  requestId?: string(name='RequestId', description='auditing', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3****'),
  scalingActivityId?: string(name='ScalingActivityId', description='The ID of the request.', example='asa-bp1gbswjhjrw8tko****'),
}

model DetachInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetachInstancesResponseBody(name='body'),
}

/**
  * Removes one or more Elastic Compute Service (ECS) instances or elastic container instances from a scaling group.
  *
  * @param request DetachInstancesRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DetachInstancesResponse
 */
async function detachInstancesWithOptions(request: DetachInstancesRequest, runtime: Util.RuntimeOptions): DetachInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.decreaseDesiredCapacity)) {
    query['DecreaseDesiredCapacity'] = request.decreaseDesiredCapacity;
  }
  if (!Util.isUnset(request.detachOption)) {
    query['DetachOption'] = request.detachOption;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.lifecycleHook)) {
    query['LifecycleHook'] = request.lifecycleHook;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.scalingGroupId)) {
    query['ScalingGroupId'] = request.scalingGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DetachInstances',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Removes one or more Elastic Compute Service (ECS) instances or elastic container instances from a scaling group.
  *
  * @param request DetachInstancesRequest
  * @return DetachInstancesResponse
 */
async function detachInstances(request: DetachInstancesRequest): DetachInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachInstancesWithOptions(request, runtime);
}

model DetachLoadBalancersRequest {
  async?: boolean(name='Async', description='Specifies whether to detach the CLB instance from the scaling group in an asynchronous manner. If you detach the CLB instance from the scaling group in an asynchronous manner, the call is successful only after all operations are successful. If a specific operation fails, the call fails. We recommend that you set this parameter to true.

Valid values:

*   true: detaches the CLB instance from the scaling group in an asynchronous manner. In this case, the ID of the scaling activity is returned.
*   false: does not detach the CLB instance from the scaling group in an asynchronous manner.

Default value: false.', example='false'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that the value is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25965~~).', example='123e4567-e89b-12d3-a456-42665544****'),
  forceDetach?: boolean(name='ForceDetach', description='Specifies whether to remove Elastic Compute Service (ECS) instances in the scaling group from the backend server groups of the CLB instance. Valid values:

*   true
*   false

Default value: false.', example='false'),
  loadBalancers?: [ string ](name='LoadBalancers', description='The IDs of the CLB instances. You can specify up to five instance IDs.'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID of the scaling group.', example='cn-qingdao'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  scalingGroupId?: string(name='ScalingGroupId', description='The ID of the scaling group.', example='asg-bp1ffogfdauy0jw0****'),
}

model DetachLoadBalancersResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3****'),
  scalingActivityId?: string(name='ScalingActivityId', description='The ID of the scaling activity. The value of this parameter is returned only if you set the Async parameter to true. You can call the describescalingactivities operation to query all scaling activity IDs and use the scaling activity IDs to check the status of the scaling activities.', example='asa-bp140qd7mak8k63f****'),
}

model DetachLoadBalancersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetachLoadBalancersResponseBody(name='body'),
}

async function detachLoadBalancersWithOptions(request: DetachLoadBalancersRequest, runtime: Util.RuntimeOptions): DetachLoadBalancersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.async)) {
    query['Async'] = request.async;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.forceDetach)) {
    query['ForceDetach'] = request.forceDetach;
  }
  if (!Util.isUnset(request.loadBalancers)) {
    query['LoadBalancers'] = request.loadBalancers;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.scalingGroupId)) {
    query['ScalingGroupId'] = request.scalingGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DetachLoadBalancers',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detachLoadBalancers(request: DetachLoadBalancersRequest): DetachLoadBalancersResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachLoadBalancersWithOptions(request, runtime);
}

model DetachServerGroupsRequest {
  clientToken?: string(name='ClientToken', example='123e4567-e89b-12d3-a456-42665544****'),
  forceDetach?: boolean(name='ForceDetach', example='false'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  scalingGroupId?: string(name='ScalingGroupId', example='asg-bp18p2yfxow2dloq****'),
  serverGroups?: [ 
    {
      port?: int32(name='Port', example='22'),
      serverGroupId?: string(name='ServerGroupId', example='sgp-1gv2uidn2msy****'),
      type?: string(name='Type', example='ALB'),
    }
  ](name='ServerGroups'),
}

model DetachServerGroupsResponseBody = {
  requestId?: string(name='RequestId', example='6EF9BFEE-FE07-4627-B8FB-14326FB9****'),
  scalingActivityId?: string(name='ScalingActivityId', example='asa-bp1gbswjhjrw8tko****'),
}

model DetachServerGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetachServerGroupsResponseBody(name='body'),
}

async function detachServerGroupsWithOptions(request: DetachServerGroupsRequest, runtime: Util.RuntimeOptions): DetachServerGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.forceDetach)) {
    query['ForceDetach'] = request.forceDetach;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.scalingGroupId)) {
    query['ScalingGroupId'] = request.scalingGroupId;
  }
  if (!Util.isUnset(request.serverGroups)) {
    query['ServerGroups'] = request.serverGroups;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DetachServerGroups',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detachServerGroups(request: DetachServerGroupsRequest): DetachServerGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachServerGroupsWithOptions(request, runtime);
}

model DetachVServerGroupsRequest {
  clientToken?: string(name='ClientToken', description='Specifies whether to remove ECS instances in your scaling group from the vServer group.

*   true
*   false

Default value: false.', example='123e4567-e89b-12d3-a456-42665544****'),
  forceDetach?: boolean(name='ForceDetach', description='Details of the vServer groups.', example='false'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The ID of the scaling group.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  scalingGroupId?: string(name='ScalingGroupId', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that the value is unique among different requests.

The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25965~~).', example='asg-bp1fo0dbtsbmqa9h****'),
  VServerGroups?: [ 
    {
      loadBalancerId?: string(name='LoadBalancerId', description='The ID of the request.', example='lb-bp1p90y3ya9h8s62d****'),
      VServerGroupAttributes?: [ 
        {
          port?: int32(name='Port', description='The ID of the Classic Load Balancer (CLB) instance to which the vServer group belongs.', example='22'),
          VServerGroupId?: string(name='VServerGroupId', description='The port number that is used when Auto Scaling adds ECS instances to the vServer group. Valid values: 1 to 65535.', example='rsp-bp1jp1rge****'),
        }
      ](name='VServerGroupAttributes', description='Details of the vServer group attributes.'),
    }
  ](name='VServerGroups', description='Details of the vServer groups.'),
}

model DetachVServerGroupsResponseBody = {
  requestId?: string(name='RequestId', description='auditing', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3****'),
}

model DetachVServerGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetachVServerGroupsResponseBody(name='body'),
}

/**
  * Detaches one or more vServer groups of a Classic Load Balancer (CLB) instance from a scaling group.
  *
  * @param request DetachVServerGroupsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DetachVServerGroupsResponse
 */
async function detachVServerGroupsWithOptions(request: DetachVServerGroupsRequest, runtime: Util.RuntimeOptions): DetachVServerGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.forceDetach)) {
    query['ForceDetach'] = request.forceDetach;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.scalingGroupId)) {
    query['ScalingGroupId'] = request.scalingGroupId;
  }
  if (!Util.isUnset(request.VServerGroups)) {
    query['VServerGroups'] = request.VServerGroups;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DetachVServerGroups',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Detaches one or more vServer groups of a Classic Load Balancer (CLB) instance from a scaling group.
  *
  * @param request DetachVServerGroupsRequest
  * @return DetachVServerGroupsResponse
 */
async function detachVServerGroups(request: DetachVServerGroupsRequest): DetachVServerGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachVServerGroupsWithOptions(request, runtime);
}

model DisableAlarmRequest {
  alarmTaskId?: string(name='AlarmTaskId', description='The ID of the request.', example='asg-bp1hvbnmkl10vll5****_f95ce797-dc2e-4bad-9618-14fee7d1****'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The ID of the event-triggered task.', example='cn-qingdao'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
}

model DisableAlarmResponseBody = {
  requestId?: string(name='RequestId', description='auditing', example='086EFCD4-C76F-4DC6-9EE9-0D9B711E****'),
}

model DisableAlarmResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DisableAlarmResponseBody(name='body'),
}

async function disableAlarmWithOptions(request: DisableAlarmRequest, runtime: Util.RuntimeOptions): DisableAlarmResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alarmTaskId)) {
    query['AlarmTaskId'] = request.alarmTaskId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableAlarm',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function disableAlarm(request: DisableAlarmRequest): DisableAlarmResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableAlarmWithOptions(request, runtime);
}

model DisableScalingGroupRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  scalingGroupId?: string(name='ScalingGroupId', description='The ID of the request.', example='asg-bp18p2yfxow2dloq****'),
}

model DisableScalingGroupResponseBody = {
  requestId?: string(name='RequestId', description='auditing', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
}

model DisableScalingGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DisableScalingGroupResponseBody(name='body'),
}

/**
  * Disables a scaling group.
  *
  * @param request DisableScalingGroupRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DisableScalingGroupResponse
 */
async function disableScalingGroupWithOptions(request: DisableScalingGroupRequest, runtime: Util.RuntimeOptions): DisableScalingGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.scalingGroupId)) {
    query['ScalingGroupId'] = request.scalingGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableScalingGroup',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Disables a scaling group.
  *
  * @param request DisableScalingGroupRequest
  * @return DisableScalingGroupResponse
 */
async function disableScalingGroup(request: DisableScalingGroupRequest): DisableScalingGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableScalingGroupWithOptions(request, runtime);
}

model EnableAlarmRequest {
  alarmTaskId?: string(name='AlarmTaskId', description='The ID of the request.', example='asg-bp1hvbnmkl10vll5****_f95ce797-dc2e-4bad-9618-14fee7d1****'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The ID of the event-triggered task.', example='cn-qingdao'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
}

model EnableAlarmResponseBody = {
  requestId?: string(name='RequestId', description='auditing', example='688B18B8-FB1E-42EB-A1ED-7F55B090****'),
}

model EnableAlarmResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableAlarmResponseBody(name='body'),
}

async function enableAlarmWithOptions(request: EnableAlarmRequest, runtime: Util.RuntimeOptions): EnableAlarmResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alarmTaskId)) {
    query['AlarmTaskId'] = request.alarmTaskId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableAlarm',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function enableAlarm(request: EnableAlarmRequest): EnableAlarmResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableAlarmWithOptions(request, runtime);
}

model EnableScalingGroupRequest {
  activeScalingConfigurationId?: string(name='ActiveScalingConfigurationId', description='The ID of the scaling configuration that you want to put into the Active state.', example='asc-bp1ffogfdauy0nu5****'),
  instanceIds?: [ string ](name='InstanceIds', description='The IDs of ECS instances that you want to add to the scaling group after you enable the scaling group.

The ECS instances must meet the following requirements:

*   The instances and the scaling group must reside in the same region.
*   The instances must be in the Running state.
*   The instances are not added to other scaling groups.
*   The instances must use the subscription or pay-as-you-go billing method or be preemptible instances.
*   If you specify the VswitchID parameter for the scaling group, the instances must reside in the same virtual private cloud (VPC) as the specified vSwitch. You cannot add instances that reside in the classic network or other VPCs to the scaling group.
*   If you do not specify the VswitchID parameter for the scaling group, you cannot add instances that reside in VPCs to the scaling group.'),
  launchTemplateId?: string(name='LaunchTemplateId', description='The ID of the launch template that is used by Auto Scaling to create ECS instances.', example='lt-m5e3ofjr1zn1aw7****'),
  launchTemplateOverrides?: [ 
    {
      instanceType?: string(name='InstanceType', description='The instance type. The instance type that you specify by using the InstanceType parameter overwrites the instance type that is specified in the launch template.

If you want Auto Scaling to scale instances in the scaling group based on the instance type weight, you must specify both the InstanceType parameter and the WeightedCapacity parameter.

> This parameter takes effect only after you specify the LaunchTemplateId parameter.

You can use the InstanceType parameter to specify only instance types that are available for purchase.', example='ecs.c5.xlarge'),
      weightedCapacity?: int32(name='WeightedCapacity', description='The weight of the instance type. The weight specifies the capacity of a single instance of the specified instance type in the scaling group. If you want Auto Scaling to scale instances in the scaling group based on the weighted capacity of instances, you must specify the WeightedCapacity parameter after you specify the InstanceType parameter.

A higher weight specifies that a smaller number of instances of the specified instance type are required to meet the expected capacity requirement.

Performance metrics, such as the number of vCPUs and the memory size of each instance type, may vary. You can specify different weights for different instance types based on your business requirements.

Example:

*   Current capacity: 0
*   Expected capacity: 6
*   Capacity of ecs.c5.xlarge: 4

To meet the expected capacity requirement, Auto Scaling must create and add two ecs.c5.xlarge instances.

> The capacity of the scaling group cannot exceed the sum of the maximum number of instances that is specified by the MaxSize parameter and the maximum weight of the instance types.

Valid values of the WeightedCapacity parameter: 1 to 500.', example='4'),
    }
  ](name='LaunchTemplateOverrides', description='Details of the instance types that are specified in the extended configurations of the launch template.'),
  launchTemplateVersion?: string(name='LaunchTemplateVersion', description='The version number of the launch template. Valid values:

*   A fixed template version number.
*   Default: The default template version is always used.
*   Latest: The latest template version is always used.', example='Default'),
  loadBalancerWeights?: [ int32 ](name='LoadBalancerWeights', description='The weight of an ECS instance as a backend server in the associated vServer group.

Default value: 50.'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID of the scaling group.', example='cn-qingdao'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  scalingGroupId?: string(name='ScalingGroupId', description='The ID of the scaling group.', example='asg-bp14wlu85wrpchm0****'),
}

model EnableScalingGroupResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3****'),
}

model EnableScalingGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableScalingGroupResponseBody(name='body'),
}

/**
  * You can call this operation to enable a scaling group that is in the Inactive state and has an instance configuration source. The instance configuration source can be a scaling configuration, a launch template, or an Elastic Compute Service (ECS) instance that you specified when you created the scaling group. If a scaling group is not in the Inactive state or does not have an active instance configuration source, you cannot call this operation to enable the scaling group.
  * > A scaling group can have only one active instance configuration source. When you call this operation to enable a scaling group, you can specify a scaling configuration or a launch template for the scaling group. If an instance configuration source has been configured for the scaling group before you call this operation, the scaling configuration or launch template that you specify in the request overwrites the original scaling configuration or launch template.
  * If you specify a value for the InstanceId parameter when you call the operation, Auto Scaling checks whether the total number of ECS instances is within the range allowed in the scaling group after you call the operation.
  * *   If the total number of ECS instances is less than the minimum number of instances allowed in the scaling group after you call the operation, Auto Scaling automatically creates the required number of pay-as-you-go ECS instances and adds the instances to the scaling group to reach the minimum number. For example, if the minimum number of instances allowed in your scaling group is five, and you specify the InstanceId parameter to add two created ECS instances to the scaling group, Auto Scaling automatically creates three instances in the scaling group after the two instances are added.
  * *   If the value of the TotalCapactiy parameter is greater than the value of the MaxSize parameter, the call fails.
  *
  * @param request EnableScalingGroupRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return EnableScalingGroupResponse
 */
async function enableScalingGroupWithOptions(request: EnableScalingGroupRequest, runtime: Util.RuntimeOptions): EnableScalingGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.activeScalingConfigurationId)) {
    query['ActiveScalingConfigurationId'] = request.activeScalingConfigurationId;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.launchTemplateId)) {
    query['LaunchTemplateId'] = request.launchTemplateId;
  }
  if (!Util.isUnset(request.launchTemplateOverrides)) {
    query['LaunchTemplateOverrides'] = request.launchTemplateOverrides;
  }
  if (!Util.isUnset(request.launchTemplateVersion)) {
    query['LaunchTemplateVersion'] = request.launchTemplateVersion;
  }
  if (!Util.isUnset(request.loadBalancerWeights)) {
    query['LoadBalancerWeights'] = request.loadBalancerWeights;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.scalingGroupId)) {
    query['ScalingGroupId'] = request.scalingGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableScalingGroup',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this operation to enable a scaling group that is in the Inactive state and has an instance configuration source. The instance configuration source can be a scaling configuration, a launch template, or an Elastic Compute Service (ECS) instance that you specified when you created the scaling group. If a scaling group is not in the Inactive state or does not have an active instance configuration source, you cannot call this operation to enable the scaling group.
  * > A scaling group can have only one active instance configuration source. When you call this operation to enable a scaling group, you can specify a scaling configuration or a launch template for the scaling group. If an instance configuration source has been configured for the scaling group before you call this operation, the scaling configuration or launch template that you specify in the request overwrites the original scaling configuration or launch template.
  * If you specify a value for the InstanceId parameter when you call the operation, Auto Scaling checks whether the total number of ECS instances is within the range allowed in the scaling group after you call the operation.
  * *   If the total number of ECS instances is less than the minimum number of instances allowed in the scaling group after you call the operation, Auto Scaling automatically creates the required number of pay-as-you-go ECS instances and adds the instances to the scaling group to reach the minimum number. For example, if the minimum number of instances allowed in your scaling group is five, and you specify the InstanceId parameter to add two created ECS instances to the scaling group, Auto Scaling automatically creates three instances in the scaling group after the two instances are added.
  * *   If the value of the TotalCapactiy parameter is greater than the value of the MaxSize parameter, the call fails.
  *
  * @param request EnableScalingGroupRequest
  * @return EnableScalingGroupResponse
 */
async function enableScalingGroup(request: EnableScalingGroupRequest): EnableScalingGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableScalingGroupWithOptions(request, runtime);
}

model EnterStandbyRequest {
  async?: boolean(name='Async', description='Specifies whether to asynchronously set the ECS instances to the Standby state. Valid values:

*   true
*   false

Default value: false.', example='false'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that the value is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25965~~).', example='123e4567-e89b-12d3-a456-42665544****'),
  instanceIds?: [ string ](name='InstanceIds', description='The IDs of the ECS instances.'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  scalingGroupId?: string(name='ScalingGroupId', description='The ID of the scaling group.', example='asg-bp1fo0dbtsbmqa9h****'),
}

model EnterStandbyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3****'),
  scalingActivityId?: string(name='ScalingActivityId', description='The ID of the scaling activity.', example='asa-2zeb04oym05qaceq****'),
}

model EnterStandbyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnterStandbyResponseBody(name='body'),
}

/**
  * *   If you call the operation to set an Elastic Compute Service (ECS) instance in a scaling group that is associated with a Server Load Balancer (SLB) instance to the Standby state, the weight of the ECS instance as a backend server of the SLB instance is set to 0.
  * *   You can remove an ECS instance that is in the Standby state from a scaling group and release the instance.
  * *   When scale-in activities are triggered by changes in the number of scaling groups or by event-triggered tasks, the ECS instances that are in the Standby state are not removed from the scaling groups.
  * *   If Auto Scaling considers an ECS instance that is in the Standby state unhealthy, such as in the Stopping or Restarting state, Auto Scaling does not update the health check status of the ECS instance or trigger scale-in activities to remove the ECS instance from the scaling group. Auto Scaling updates the health check status of the ECS instance only when the ECS instance is no longer in the Standby state.
  *
  * @param request EnterStandbyRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return EnterStandbyResponse
 */
async function enterStandbyWithOptions(request: EnterStandbyRequest, runtime: Util.RuntimeOptions): EnterStandbyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.async)) {
    query['Async'] = request.async;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.scalingGroupId)) {
    query['ScalingGroupId'] = request.scalingGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnterStandby',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   If you call the operation to set an Elastic Compute Service (ECS) instance in a scaling group that is associated with a Server Load Balancer (SLB) instance to the Standby state, the weight of the ECS instance as a backend server of the SLB instance is set to 0.
  * *   You can remove an ECS instance that is in the Standby state from a scaling group and release the instance.
  * *   When scale-in activities are triggered by changes in the number of scaling groups or by event-triggered tasks, the ECS instances that are in the Standby state are not removed from the scaling groups.
  * *   If Auto Scaling considers an ECS instance that is in the Standby state unhealthy, such as in the Stopping or Restarting state, Auto Scaling does not update the health check status of the ECS instance or trigger scale-in activities to remove the ECS instance from the scaling group. Auto Scaling updates the health check status of the ECS instance only when the ECS instance is no longer in the Standby state.
  *
  * @param request EnterStandbyRequest
  * @return EnterStandbyResponse
 */
async function enterStandby(request: EnterStandbyRequest): EnterStandbyResponse {
  var runtime = new Util.RuntimeOptions{};
  return enterStandbyWithOptions(request, runtime);
}

model ExecuteScalingRuleRequest {
  breachThreshold?: float(name='BreachThreshold', description='The metric value specified when the step scaling rule is executed. Valid values: -9.999999E18 to 9.999999E18.', example='1.0'),
  clientToken?: string(name='ClientToken', description='The threshold specified when the step scaling rule is executed. Valid values: -9.999999E18 to 9.999999E18.', example='123e4567-e89b-12d3-a456-426655440000'),
  metricValue?: float(name='MetricValue', description='The region ID of the scaling group.', example='1.0'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The ID of the scaling activity.', example='cn-qingdao'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  scalingRuleAri?: string(name='ScalingRuleAri', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that the value is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25965~~).', example='ari:acs:ess:cn-hangzhou:140692647406****:scalingrule/asr-bp1dvirgwkoowxk7****'),
}

model ExecuteScalingRuleResponseBody = {
  requestId?: string(name='RequestId', description='auditing', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  scalingActivityId?: string(name='ScalingActivityId', description='The ID of the request.', example='asa-bp13o672yeautiil****'),
}

model ExecuteScalingRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ExecuteScalingRuleResponseBody(name='body'),
}

/**
  * Executes a scaling rule.
  *
  * @param request ExecuteScalingRuleRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ExecuteScalingRuleResponse
 */
async function executeScalingRuleWithOptions(request: ExecuteScalingRuleRequest, runtime: Util.RuntimeOptions): ExecuteScalingRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.breachThreshold)) {
    query['BreachThreshold'] = request.breachThreshold;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.metricValue)) {
    query['MetricValue'] = request.metricValue;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.scalingRuleAri)) {
    query['ScalingRuleAri'] = request.scalingRuleAri;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ExecuteScalingRule',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Executes a scaling rule.
  *
  * @param request ExecuteScalingRuleRequest
  * @return ExecuteScalingRuleResponse
 */
async function executeScalingRule(request: ExecuteScalingRuleRequest): ExecuteScalingRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return executeScalingRuleWithOptions(request, runtime);
}

model ExitStandbyRequest {
  async?: boolean(name='Async', description='The region ID of the scaling group.', example='false'),
  clientToken?: string(name='ClientToken', description='The IDs of the ECS instances. The value of this parameter can be a JSON array that consists of up to 20 instance IDs. Separate multiple instance IDs with commas (,).', example='123e4567-e89b-12d3-a456-42665544****'),
  instanceIds?: [ string ](name='InstanceIds', description='The IDs of the ECS instances. The value of this parameter can be a JSON array that consists of up to 20 instance IDs. Separate multiple instance IDs with commas (,).'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The ID of the request.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  scalingGroupId?: string(name='ScalingGroupId', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that the value is unique among different requests.

The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25965~~).', example='asg-bp1fo0dbtsbmqa9h****'),
}

model ExitStandbyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the scaling activity.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3****'),
  scalingActivityId?: string(name='ScalingActivityId', description='auditing', example='asa-2zeb04oym05qaceq****'),
}

model ExitStandbyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ExitStandbyResponseBody(name='body'),
}

/**
  * If the scaling group is associated with a load balancing instance, the ECS instance weight will be set to the weight value defined in the scaling configuration.
  *
  * @param request ExitStandbyRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ExitStandbyResponse
 */
async function exitStandbyWithOptions(request: ExitStandbyRequest, runtime: Util.RuntimeOptions): ExitStandbyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.async)) {
    query['Async'] = request.async;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.scalingGroupId)) {
    query['ScalingGroupId'] = request.scalingGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ExitStandby',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * If the scaling group is associated with a load balancing instance, the ECS instance weight will be set to the weight value defined in the scaling configuration.
  *
  * @param request ExitStandbyRequest
  * @return ExitStandbyResponse
 */
async function exitStandby(request: ExitStandbyRequest): ExitStandbyResponse {
  var runtime = new Util.RuntimeOptions{};
  return exitStandbyWithOptions(request, runtime);
}

model ListTagKeysRequest {
  nextToken?: string(name='NextToken', description='The number of entries to return on each page. Maximum value: 50.

Default value: 10.', example='caeba0bbb2be03f84eb48b699f0a****'),
  ownerId?: long(name='OwnerId'),
  pageSize?: int32(name='PageSize', description='The token that determines the start point of the next query. If this parameter is empty, all results are returned.', example='10'),
  regionId?: string(name='RegionId', description='The type of the Auto Scaling resource. Set the value to scalinggroup. This indicates that the tags are added to scaling groups.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceType?: string(name='ResourceType', description='The token that determines the start point of the next query. If this parameter is empty, all results are returned.', example='scalinggroup'),
}

model ListTagKeysResponseBody = {
  keys?: [ string ](name='Keys', description='Details of the tag keys.'),
  nextToken?: string(name='NextToken', description='The ID of the request.', example='caeba0bbb2be03f84eb48b699f0a****'),
  pageSize?: int32(name='PageSize', description='Details of the tag keys.', example='10'),
  requestId?: string(name='RequestId', description='The number of entries returned per page.', example='DC09A6AA-2713-4E10-A2E9-E6C5C43A****'),
}

model ListTagKeysResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagKeysResponseBody(name='body'),
}

async function listTagKeysWithOptions(request: ListTagKeysRequest, runtime: Util.RuntimeOptions): ListTagKeysResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagKeys',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTagKeys(request: ListTagKeysRequest): ListTagKeysResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagKeysWithOptions(request, runtime);
}

model ListTagResourcesRequest {
  nextToken?: string(name='NextToken', description='The token that determines the start point of the next query.', example='caeba0bbb2be03f84eb48b699f0a4883'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID of the Auto Scaling resource. You can call the DescribeRegions operation to query the most recent region list.', example='cn-hangzhou'),
  resourceIds?: [ string ](name='ResourceIds', description='The IDs of the Auto Scaling resources. You can specify 1 to 50 resource IDs.'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceType?: string(name='ResourceType', description='The type of the Auto Scaling resource. Only scaling groups are supported. Set the value to scalinggroup.', example='scalinggroup'),
  tags?: [ 
    {
      key?: string(name='Key', description='The key of the tag. The key is used to perform an exact match of Auto Scaling resources. The key must be 1 to 128 characters in length.

`Tags` is used to perform an exact match of Auto Scaling resources to which the specified tags are added. Specify a tag in the key-value pair format.

*   If you specify only `Tags.Key`, all resources whose tags contain the specified tag key are returned.
*   If you specify only `Tags.Value`, the `MissingParameter.TagKey` error is reported.
*   If you specify multiple key-value pairs at the same time, only Auto Scaling resources that match all the tag keys and tag values are returned.', example='TestKey'),
      value?: string(name='Value', description='The value of the tag. The value is used to perform an exact match of Auto Scaling resources. The value can be up to 128 characters in length.', example='TestValue'),
    }
  ](name='Tags', description='Details of the tags.'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken', description='The token that determines the start point of the next query.', example='caeba0bbb2be03f84eb48b699f0a4883'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='DE65F6B7-7566-4802-9007-96F2494A****'),
  tagResources?: [ 
    {
      propagate?: boolean(name='Propagate', description='Indicates whether the tag can be propagated.

*   true: The tag can be propagated only to instances that are to be added to the scaling group. The tag cannot be propagated to instances that are already running in the scaling group.
*   false: The tag cannot be propagated to an instance.', example='false'),
      resourceId?: string(name='ResourceId', description='The ID of the resource.', example='asg-bp17xb4x1vr29lgt****'),
      resourceType?: string(name='ResourceType', description='The type of the resource.', example='ALIYUN::ESS::SCALINGGROUP'),
      tagKey?: string(name='TagKey', description='The key of the tag.', example='TestKey'),
      tagValue?: string(name='TagValue', description='The value of the tag.', example='TestValue'),
    }
  ](name='TagResources', description='Details of the resource and tags, such as the resource ID, the resource type, tag keys, and tag values.'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceIds)) {
    query['ResourceIds'] = request.resourceIds;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagResources',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagResourcesWithOptions(request, runtime);
}

model ListTagValuesRequest {
  key?: string(name='Key', description='The token that determines the start point of the next query. If this parameter is empty, all results are returned.', example='ESS'),
  nextToken?: string(name='NextToken', description='The number of entries to return on each page. Maximum value: 50.

Default value: 10.', example='caeba0bbb2be03f84eb48b699f0a****'),
  ownerId?: long(name='OwnerId'),
  pageSize?: int32(name='PageSize', description='The key of the tag.', example='10'),
  regionId?: string(name='RegionId', description='The type of the Auto Scaling resource. Set the value to scalinggroup. This indicates that the tag is added to a scaling group.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceType?: string(name='ResourceType', description='The token that determines the start point of the next query. If this parameter is empty, all results are returned.', example='scalinggroup'),
}

model ListTagValuesResponseBody = {
  nextToken?: string(name='NextToken', description='The ID of the request.', example='caeba0bbb2be03f84eb48b699f0a****'),
  pageSize?: int32(name='PageSize', description='Details of the tag values.', example='10'),
  requestId?: string(name='RequestId', description='The number of entries returned per page.', example='AB444F46-1CFF-4B06-B8F0-B45D3158****'),
  values?: [ string ](name='Values', description='Details of the tag values.'),
}

model ListTagValuesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagValuesResponseBody(name='body'),
}

async function listTagValuesWithOptions(request: ListTagValuesRequest, runtime: Util.RuntimeOptions): ListTagValuesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.key)) {
    query['Key'] = request.key;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagValues',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTagValues(request: ListTagValuesRequest): ListTagValuesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagValuesWithOptions(request, runtime);
}

model ModifyAlarmRequest {
  alarmActions?: [ string ](name='AlarmActions', description='The list of unique identifiers of the scaling rules that are associated with the event-triggered task.'),
  alarmTaskId?: string(name='AlarmTaskId', description='The name of the event-triggered task.', example='asg-bp1hvbnmkl10vll5****_f95ce797-dc2e-4bad-9618-14fee7d1****'),
  comparisonOperator?: string(name='ComparisonOperator', description='The number of times that the threshold must be reached before a scaling rule can be executed. For example, if you set this parameter to 3, the average CPU utilization must reach or exceed 80% three times in a row before a scaling rule is triggered.', example='>='),
  description?: string(name='Description', description='The name of the metric. The valid values vary based on the metric type.

*   If you set the MetricType parameter to custom, the valid values are your custom metrics.

*   If you set the MetricType parameter to system, the MetricName parameter has the following valid values:

    *   CpuUtilization: the CPU utilization of an ECS instance. Unit: %.
    *   IntranetTx: the outbound traffic over the internal network from an ECS instance. Unit: KB/min.
    *   IntranetRx: the inbound traffic over the Internet to an ECS instance that resides in a virtual private cloud (VPC). Unit: KB/min.
    *   VpcInternetTx: the outbound traffic over the Internet from an ECS instance that resides in a VPC. Unit: KB/min.
    *   VpcInternetRx: the inbound traffic over the Internet to an ECS instance that resides in a VPC. Unit: KB/min.
    *   SystemDiskReadBps: the number of bytes read from the system disk used by an ECS instance per second.
    *   SystemDiskWriteBps: the number of bytes written to the system disk used by an ECS instance per second.
    *   SystemDiskReadOps: the number of read operations on the system disk used by an ECS instance per second.
    *   SystemDiskWriteOps: the number of write operations on the system disk used by an ECS instance per second.
    *   CpuUtilizationAgent: the CPU utilization of an agent. Unit: %.
    *   GpuMemoryFreeUtilizationAgent: the percentage of idle GPU memory of an agent.
    *   GpuMemoryUtilizationAgent: the GPU memory usage of an agent. Unit: %.
    *   MemoryUtilization: the memory usage of an agent. Unit: %.
    *   LoadAverage: the average system load of an agent.
    *   TcpConnection: the total number of TCP connections of an agent.
    *   TcpConnection: the number of established TCP connections of an agent.
    *   PackagesNetOut: the number of packets that are sent by the internal network interface controller (NIC) used by an agent.
    *   PackagesNetIn: the number of packets that are received by the internal NIC used by an agent.
    *   EciPodCpuUtilization: the CPU utilization of an elastic container instance. Unit: %.
    *   EciPodMemoryUtilization: the memory usage of an elastic container instance. Unit: %.

For more information, see [Event-triggered task for system monitoring](~~74854~~).', example='Test alarm task.'),
  dimensions?: [ 
    {
      dimensionKey?: string(name='DimensionKey', description='The value of the dimension. The valid values vary based on the value of the DimensionKey parameter.

*   If you set the MetricType parameter to custom, you can specify this parameter based on your business requirements.

*   If you set the MetricType parameter to system, this parameter has the following valid values:

    *   If you set the DimensionKey parameter to user_id, the system specifies the value

    *   scaling_group: The system specifies the value of the DimensionValue parameter.

    *   If you set the DimensionKey parameter to device, you can set the DimensionValue parameter to eth0 or eth1.

        *   For instances that reside in the classic network type, eth0 specifies the internal NIC. Only one eth0 NIC exists on each instance that resides in a VPC.
        *   For instances that reside in the classic network, eth1 specifies the public NIC.

    *   If you set the DimensionKey parameter to state, you can set the DimensionValue parameter to TCP_TOTAL or ESTABLISHED.

        *   TCP_TOTAL specifies the total number of TCP connections.
        *   ESTABLISHED specifies the number of established TCP connections.', example='device'),
      dimensionValue?: string(name='DimensionValue', description='The expressions that are specified in the multi-metric alert rule.', example='eth0'),
    }
  ](name='Dimensions', description='Details of the dimensions.'),
  effective?: string(name='Effective', description='The list of unique identifiers of the scaling rules that are associated with the event-triggered task.', example='TZ=+00 * * 1-2 * * ?'),
  evaluationCount?: int32(name='EvaluationCount', description='The ID of the application group to which the custom metric belongs. If you set the MetricType parameter to custom, you must specify this parameter.', example='3'),
  expressions?: [ 
    {
      comparisonOperator?: string(name='ComparisonOperator', description='The period of time during which statistics about the metrics in the multi-metric alert rule is collected. Unit: seconds. Valid values:

*   15
*   60
*   120
*   300
*   900

> If your scaling group is of the ECS type and the event-triggered task associated with your scaling group monitors CloudMonitor metrics, you can set the Period parameter to 15. In other cases, you can set the Period parameter to 60, 120, 300, or 900. In most cases, the name of a CloudMonitor metric contains Agent.

Default value: 300.', example='>='),
      metricName?: string(name='MetricName', description='The operator that is used to compare the metric value and the threshold. Valid values:

*   If the metric value is greater than or equal to the threshold, set the value to `>=`.
*   If the metric value is less than or equal to the threshold, set the value to `<=`.
*   If the metric value is greater than the threshold, set the value to `>`.
*   If the metric value is less than the threshold, set the value to `<`.

Default value: >=.', example='CpuUtilization'),
      period?: int32(name='Period', description='The method that is used to aggregate statistics about the metrics that are specified in the multi-metric alert rule. Valid values:

*   Average
*   Minimum
*   Maximum', example='300'),
      statistics?: string(name='Statistics', description='The thresholds of the metric values in the multi-metric alert rule. If the thresholds are reached the specified number of times within the specified period, a scaling rule is executed.', example='Average'),
      threshold?: float(name='Threshold', description='The relationship between the trigger conditions in the multi-metric alert rule. Valid values:

*   `&&`: An alert is triggered only if all metrics in the multi-metric alert rule meet the trigger conditions. In this case, an alert is triggered only if the results of all trigger conditions that are specified in the multi-metric alert rule are `true`.
*   \\`\\`: An alert is triggered if one of the metrics in the multi-metric alert rule meets the trigger condition.

Default value: `&&`.', example='40.0'),
    }
  ](name='Expressions', description='The expressions that are specified in the multi-metric alert rule.'),
  expressionsLogicOperator?: string(name='ExpressionsLogicOperator', description='The ID of the event-triggered task.', example='&&'),
  groupId?: int32(name='GroupId', description='The effective period of the event-triggered task.

This parameter follows the cron expression format. The default format is `X X X X X ?`, in which:

*   X: a placeholder for a field, which represents seconds, minutes, hours, days, and months in sequence. X can be a definite value or a special character that has logical meaning. For information about the valid values of X, see [Cron expression](~~25907~~).
*   ?: No value is specified.

> By default, the value of this parameter is specified in **UTC+8**. You can specify the time zone in the `TZ=+yy` format before a cron expression. y indicates the time zone. For example, `TZ=+00 * * 1-2 * * ?` specifies that the event-triggered task is in effect between 01:00 and 02:59 (UTC+0) every day.

Examples:

*   ` * * * * * ?  `: The event-triggered task is in effect all the time.
*   ` * * 17-18 * * ?  `: The event-triggered task is in effect between 17:00 and 18:59 (UTC+8) every day.
*   `TZ=+00 * * 1-2 * * ?`: The event-triggered task is in effect between 01:00 and 02:59 (UTC+0) every day.', example='4055401'),
  metricName?: string(name='MetricName', description='The type of the metric. Valid values:

*   system: system metrics of CloudMonitor
*   custom: custom metrics that are reported to CloudMonitor', example='MemoryUtilization'),
  metricType?: string(name='MetricType', description='The period of time during which statistics about the metric is collected. Unit: seconds. Valid values:

*   15
*   60
*   120
*   300
*   900

> If your scaling group is of the ECS type and uses CloudMonitor metrics, you can set the Period parameter to 15. In other cases, you can set the Period parameter to 60, 120, 300, or 900. In most cases, the name of a CloudMonitor metric contains Agent.', example='system'),
  name?: string(name='Name', description='The description of the event-triggered task.', example='alarmtask****'),
  ownerId?: long(name='OwnerId'),
  period?: int32(name='Period', description='The method that is used to aggregate statistics for the metric. Valid values:

*   Average
*   Minimum
*   Maximum', example='300'),
  regionId?: string(name='RegionId', description='The ID of the event-triggered task.', example='cn-qingdao'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  statistics?: string(name='Statistics', description='The thresholds of the metric values in the multi-metric alert rule. If the thresholds are reached the specified number of times within the specified period, a scaling rule is executed.', example='Average'),
  threshold?: float(name='Threshold', description='The operator that is used to compare the metric value and the threshold. Valid values:

*   If the metric value is greater than or equal to the threshold, set the value to `>=`.
*   If the metric value is less than or equal to the threshold, set the value to `<=`.
*   If the metric value is greater than the threshold, set the value to `>`.
*   If the metric value is less than the threshold, set the value to `<`.', example='80'),
}

model ModifyAlarmResponseBody = {
  alarmTaskId?: string(name='AlarmTaskId', description='The ID of the request.', example='asg-bp1hvbnmkl10vll5****_83948190-acdd-483f-98f7-b77f4778****'),
  requestId?: string(name='RequestId', description='auditing', example='BACACF83-7070-4953-A8FD-D81F89F1****'),
}

model ModifyAlarmResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyAlarmResponseBody(name='body'),
}

/**
  * Modifies an event-triggered task.
  *
  * @param request ModifyAlarmRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ModifyAlarmResponse
 */
async function modifyAlarmWithOptions(request: ModifyAlarmRequest, runtime: Util.RuntimeOptions): ModifyAlarmResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alarmActions)) {
    query['AlarmActions'] = request.alarmActions;
  }
  if (!Util.isUnset(request.alarmTaskId)) {
    query['AlarmTaskId'] = request.alarmTaskId;
  }
  if (!Util.isUnset(request.comparisonOperator)) {
    query['ComparisonOperator'] = request.comparisonOperator;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.dimensions)) {
    query['Dimensions'] = request.dimensions;
  }
  if (!Util.isUnset(request.effective)) {
    query['Effective'] = request.effective;
  }
  if (!Util.isUnset(request.evaluationCount)) {
    query['EvaluationCount'] = request.evaluationCount;
  }
  if (!Util.isUnset(request.expressions)) {
    query['Expressions'] = request.expressions;
  }
  if (!Util.isUnset(request.expressionsLogicOperator)) {
    query['ExpressionsLogicOperator'] = request.expressionsLogicOperator;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.metricName)) {
    query['MetricName'] = request.metricName;
  }
  if (!Util.isUnset(request.metricType)) {
    query['MetricType'] = request.metricType;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.statistics)) {
    query['Statistics'] = request.statistics;
  }
  if (!Util.isUnset(request.threshold)) {
    query['Threshold'] = request.threshold;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyAlarm',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Modifies an event-triggered task.
  *
  * @param request ModifyAlarmRequest
  * @return ModifyAlarmResponse
 */
async function modifyAlarm(request: ModifyAlarmRequest): ModifyAlarmResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyAlarmWithOptions(request, runtime);
}

model ModifyEciScalingConfigurationRequest {
  acrRegistryInfos?: [ 
    {
      domains?: [ string ](name='Domains', description='The domain names of the Container Registry Enterprise Edition instances. By default, all domain names of the Container Registry Enterprise Edition instances are displayed. You can specify one or more domain names. Separate multiple domain names with commas (,).'),
      instanceId?: string(name='InstanceId', description='The ID of the Container Registry Enterprise Edition instance.', example='cri-nwj395hgf6f3****'),
      instanceName?: string(name='InstanceName', description='The name of the Container Registry Enterprise Edition instance.', example='acr-test'),
      regionId?: string(name='RegionId', description='The region ID of the Container Registry Enterprise Edition instance.', example='cn-hangzhou'),
    }
  ](name='AcrRegistryInfos', description='Information about the Container Registry Enterprise Edition instance.'),
  activeDeadlineSeconds?: long(name='ActiveDeadlineSeconds', description='The validity period. Unit: seconds.', example='1000'),
  autoCreateEip?: boolean(name='AutoCreateEip', description='Specifies whether to automatically create an elastic IP address (EIP) and bind the EIP to the elastic container instance.', example='true'),
  autoMatchImageCache?: boolean(name='AutoMatchImageCache', description='Specifies whether to automatically match the image cache.

Default value: false.', example='false'),
  containerGroupName?: string(name='ContainerGroupName', description='The name of the elastic container instance. The name must meet the following requirements:

*   The name must be 2 to 128 characters in length
*   The name can contain only lowercase letters, digits, and hyphens (-). It cannot start or end with a hyphen (-).', example='nginx-test'),
  containers?: [ 
    {
      livenessProbe?: {
        exec?: {
            commands?: [ string ](name='Commands'),
        }(name='Exec'),
        failureThreshold?: int32(name='FailureThreshold'),
        httpGet?: {
            path?: string(name='Path'),
            port?: int32(name='Port'),
            scheme?: string(name='Scheme'),
        }(name='HttpGet'),
        initialDelaySeconds?: int32(name='InitialDelaySeconds'),
        periodSeconds?: int32(name='PeriodSeconds'),
        successThreshold?: int32(name='SuccessThreshold'),
        tcpSocket?: {
            port?: int32(name='Port'),
        }(name='TcpSocket'),
        timeoutSeconds?: int32(name='TimeoutSeconds'),
      }(name='LivenessProbe'),
      readinessProbe?: {
        exec?: {
            commands?: [ string ](name='Commands'),
        }(name='Exec'),
        failureThreshold?: int32(name='FailureThreshold'),
        httpGet?: {
            path?: string(name='Path'),
            port?: int32(name='Port'),
            scheme?: string(name='Scheme'),
        }(name='HttpGet'),
        initialDelaySeconds?: int32(name='InitialDelaySeconds'),
        periodSeconds?: int32(name='PeriodSeconds'),
        successThreshold?: int32(name='SuccessThreshold'),
        tcpSocket?: {
            port?: int32(name='Port'),
        }(name='TcpSocket'),
        timeoutSeconds?: int32(name='TimeoutSeconds'),
      }(name='ReadinessProbe'),
      securityContext?: {
        capability?: {
            adds?: [ string ](name='Adds'),
        }(name='Capability'),
        readOnlyRootFilesystem?: boolean(name='ReadOnlyRootFilesystem'),
        runAsUser?: long(name='RunAsUser'),
      }(name='SecurityContext'),
      args?: [ string ](name='Args', description='The arguments that correspond to the startup commands of the container. You can specify up to 10 arguments.'),
      commands?: [ string ](name='Commands', description='The commands that you want to execute in the container when you use the command line interface (CLI) to perform probes.'),
      cpu?: float(name='Cpu', description='The number of vCPUs that you want to allocate to the container.', example='0.25'),
      environmentVars?: [ 
        {
          fieldRef?: {
            fieldPath?: string(name='FieldPath'),
          }(name='FieldRef'),
          key?: string(name='Key', description='The key of the environment variable. Specify the name in the `[0-9a-zA-Z]` format. The name must be 1 to 128 characters in length, and can contain underscores (\\_). It cannot start with a digit.', example='PATH'),
          value?: string(name='Value', description='The value of the environment variable. The value must be 0 to 256 characters in length.', example='/usr/local/bin'),
        }
      ](name='EnvironmentVars', description='Information about the environment variables.'),
      gpu?: int32(name='Gpu', description='The number of GPUs that you want to allocate to the container.', example='1'),
      image?: string(name='Image', description='The image of the container.', example='registry-vpc.cn-hangzhou.aliyuncs.com/eci_open/nginx:latest'),
      imagePullPolicy?: string(name='ImagePullPolicy', description='The image pulling policy. Valid values:

*   Always: pulls images each time.
*   IfNotPresent: pulls images only if no on-premises images are available. On-premises images are preferentially used. If no on-premises images are available, image pulling is performed.
*   Never: never pulls images. On-premises images are always used.', example='Always'),
      memory?: float(name='Memory', description='The memory size of the container. Unit: GiB.', example='0.5'),
      name?: string(name='Name', description='The name of the container image.', example='nginx'),
      ports?: [ 
        {
          port?: int32(name='Port', description='The port number. Valid values: 1 to 65535.', example='80'),
          protocol?: string(name='Protocol', description='The type of the protocol. Valid values:

*   TCP
*   UDP', example='TCP'),
        }
      ](name='Ports', description='Information about the ports.'),
      stdin?: boolean(name='Stdin', description='Specifies whether the container allocates buffer resources to standard input streams when the container is running. If you do not specify this parameter, an end-of-file (EOF) error may occur.

Default value: false.', example='false'),
      stdinOnce?: boolean(name='StdinOnce', description='Specifies whether standard input streams are disconnected after a client is disconnected.

If you set the StdinOnce parameter to true, standard input streams are connected after the container is started, and remain idle until a client is connected to receive data. After the client is disconnected, streams are also disconnected, and remain disconnected until the container is started again.', example='false'),
      tty?: boolean(name='Tty', description='Specifies whether to enable interaction. Default value: false.

If the command is a /bin/bash command, set the value to true.', example='false'),
      volumeMounts?: [ 
        {
          mountPath?: string(name='MountPath', description='The path where the container mounts the volume.

>  Data stored in the path of the container is directly overwritten by the content of the volume.', example='/pod/data'),
          mountPropagation?: string(name='MountPropagation', description='The mount propagation setting of the volume. Mount propagation allows the sharing of volumes that are mounted on one container with other containers in the same pod, or even with other pods on the same node. Valid values:

*   None: The volume mount does not receive subsequent mounts that are mounted to this volume or its subdirectories.
*   HostToCotainer: The volume mount receives all subsequent mounts that are mounted to this volume or its subdirectories.
*   Bidirectional: This value is similar to HostToCotainer. The volume mount receives all subsequent mounts that are mounted to this volume or its subdirectories. In addition, all volume mounts that are created by the container are propagated back to the instance and to all containers of all pods that use the same volume.', example='None'),
          name?: string(name='Name', description='The name of the volume. The value of this parameter is the same as the value of the Volumes.Name parameter.', example='default-volume1'),
          readOnly?: boolean(name='ReadOnly', description='Specifies whether the volume is read-only.

Default value: false.', example='false'),
          subPath?: string(name='SubPath', description='The subdirectory of the volume.', example='data2/'),
        }
      ](name='VolumeMounts', description='Information about the volume mount of the container.'),
      workingDir?: string(name='WorkingDir', description='The working directory of the container.', example='/usr/local/'),
    }
  ](name='Containers', description='The containers.'),
  containersUpdateType?: string(name='ContainersUpdateType'),
  costOptimization?: boolean(name='CostOptimization', description='Specifies whether to enable the cost optimization feature. Valid values:

*   true
*   false

Default value: false.', example='false'),
  cpu?: float(name='Cpu', description='The number of vCPUs of the elastic container instance.', example='1.0'),
  cpuOptionsCore?: int32(name='CpuOptionsCore', description='The number of physical CPU cores. This parameter is not available for all instance types. For more information, see [Specify custom CPU options](~~197781~~).', example='2'),
  cpuOptionsThreadsPerCore?: int32(name='CpuOptionsThreadsPerCore', description='The number of threads per core. This parameter is not available for all instance types. A value of 1 indicates that Hyper-Threading is disabled. For more information, see [Specify custom CPU options](~~197781~~).', example='2'),
  description?: string(name='Description', description='> This parameter is unavailable.', example='desc'),
  dnsConfigNameServers?: [ string ](name='DnsConfigNameServers', description='The IP addresses of the DNS servers.'),
  dnsConfigOptions?: [ 
    {
      name?: string(name='Name', description='The variable name of the option.', example='name'),
      value?: string(name='Value', description='The variable value of the option.', example='value'),
    }
  ](name='DnsConfigOptions', description='The options. Each option is a name-value pair. The value in the name-value pair is optional.'),
  dnsConfigSearchs?: [ string ](name='DnsConfigSearchs', description='The DNS lookup domains.'),
  dnsPolicy?: string(name='DnsPolicy', description='The Domain Name System (DNS) policy. Valid values:

*   None: uses the DNS that is set for the DnsConfig field.
*   Default: use the DNS that is set for the runtime environment.', example='Default'),
  egressBandwidth?: long(name='EgressBandwidth', description='The maximum outbound bandwidth. Unit: bit/s.', example='1024000'),
  eipBandwidth?: int32(name='EipBandwidth', description='The bandwidth of the EIP.

Default value: 5. Unit: Mbit/s.', example='5'),
  enableSls?: boolean(name='EnableSls', description='> This parameter is unavailable.', example='false'),
  ephemeralStorage?: int32(name='EphemeralStorage', description='The size of the temporary storage space. By default, an enhanced SSD (ESSD) of the PL1 level is used. Unit: GiB.', example='20'),
  hostAliases?: [ 
    {
      hostnames?: [ string ](name='Hostnames', description='The hostnames that you want to add.'),
      ip?: string(name='Ip', description='The IP address that you want to add.', example='192.0.XX.XX'),
    }
  ](name='HostAliases', description='Information about the hosts.'),
  hostName?: string(name='HostName', description='The name of the elastic container instance.', example='test'),
  imageRegistryCredentials?: [ 
    {
      password?: string(name='Password', description='The password that is used to access the image repository.', example='yourpaasword'),
      server?: string(name='Server', description='The domain name of the image repository.', example='registry-vpc.cn-shanghai.aliyuncs.com'),
      userName?: string(name='UserName', description='The username that is used to access the image repository.', example='yourusername'),
    }
  ](name='ImageRegistryCredentials', description='Information about the image repository.'),
  imageSnapshotId?: string(name='ImageSnapshotId', description='The ID of the image cache.', example='imc-2zebxkiifuyzzlhl****'),
  ingressBandwidth?: long(name='IngressBandwidth', description='The maximum inbound bandwidth. Unit: bit/s.', example='1024000'),
  initContainers?: [ 
    {
      securityContext?: {
        capability?: {
            adds?: [ string ](name='Adds'),
        }(name='Capability'),
        readOnlyRootFilesystem?: boolean(name='ReadOnlyRootFilesystem'),
        runAsUser?: long(name='RunAsUser'),
      }(name='SecurityContext'),
      args?: [ string ](name='Args', description='The startup parameter of the container.'),
      commands?: [ string ](name='Commands', description='The commands that you want to run to start the container.'),
      cpu?: float(name='Cpu', description='The number of vCPUs that you want to allocate to the container.', example='0.5'),
      gpu?: int32(name='Gpu', description='The number of GPUs that you want to allocate to the container.', example='1'),
      image?: string(name='Image', description='The container image.', example='nginx'),
      imagePullPolicy?: string(name='ImagePullPolicy', description='The image pulling policy. Valid values:

*   Always: pulls images each time.
*   IfNotPresent: pulls images only if no on-premises images are available. On-premises images are preferentially used. If no on-premises images are available, image pulling is performed.
*   Never: never pulls images. On-premises images are always used. Image pulling is not performed.', example='Always'),
      initContainerEnvironmentVars?: [ 
        {
          fieldRef?: {
            fieldPath?: string(name='FieldPath'),
          }(name='FieldRef'),
          key?: string(name='Key', description='The key of the environment variable. The key must be 1 to 128 characters in length. Specify the name in the `[0-9a-zA-Z]` format. The name can contain underscores and cannot start with a digit.', example='Path'),
          value?: string(name='Value', description='The value of the environment variable. The value must be 0 to 256 characters in length.', example='/usr/bin/'),
        }
      ](name='InitContainerEnvironmentVars', description='The environment variables of the init container.'),
      initContainerPorts?: [ 
        {
          port?: int32(name='Port', description='The port number. Valid values: 1 to 65535.', example='1'),
          protocol?: string(name='Protocol', description='The type of the protocol. Valid values:

*   TCP
*   UDP', example='TCP'),
        }
      ](name='InitContainerPorts', description='The ports of the init container.'),
      initContainerVolumeMounts?: [ 
        {
          mountPath?: string(name='MountPath', description='The path where the container mounts the volume.

>  Data stored in the path of the container is overwritten by the content of the volume.', example='/usr/share/'),
          mountPropagation?: string(name='MountPropagation', description='The mount propagation setting of the volume. Mount propagation allows the sharing of volumes that are mounted on one container with other containers in the same pod, or even with other pods on the same node. Valid values:

*   None: The volume mount does not receive subsequent mounts that are mounted to this volume or its subdirectories.
*   HostToCotainer: The volume mount receives all subsequent mounts that are mounted to this volume or its subdirectories.
*   Bidirectional: This value is similar to HostToCotainer. The volume mount receives all subsequent mounts that are mounted to this volume or its subdirectories. In addition, all volume mounts that are created by the container are propagated back to the instance and to all containers of all pods that use the same volume.

Default value: None.', example='None'),
          name?: string(name='Name', description='The name of the volume.', example='test-empty'),
          readOnly?: boolean(name='ReadOnly', description='Specifies whether the mount path is read-only.

Default value: false.', example='false'),
          subPath?: string(name='SubPath', description='The subdirectory of the volume. The elastic container instance can mount different directories of the same volume to different subdirectories of containers.', example='Always'),
        }
      ](name='InitContainerVolumeMounts', description='Information about the volume mounts of the init container.'),
      memory?: float(name='Memory', description='The size of the memory. Unit: GiB.', example='1.0'),
      name?: string(name='Name', description='The name of the container.', example='test-init'),
      workingDir?: string(name='WorkingDir', description='The working directory.', example='/usr/local'),
    }
  ](name='InitContainers', description='The init containers.'),
  instanceFamilyLevel?: string(name='InstanceFamilyLevel', description='The level of the instance type, which is used to filter the instance types that meet the specified criteria. This parameter takes effect only if you set the `CostOptimization` parameter to true. Valid values:

*   EntryLevel: shared instance type. Instances of this level are the most cost-effective but may not provide stable computing performance in a consistent manner. Instances of this level are suitable for business scenarios in which the CPU utilization is low. For more information, see [Shared instance families](~~108489~~).
*   EnterpriseLevel: Instances of this level provide stable performance and dedicated resources, and are suitable for business scenarios that require high stability. For more information, see [Instance family](~~25378~~).
*   CreditEntryLevel: This value is valid only for burstable instances. CPU credits are used to ensure computing performance. Instances of this level are suitable for scenarios in which the CPU utilization is low but may fluctuate in specific cases. For more information, see the [Overview](~~59977~~) topic of burstable instances.', example='EnterpriseLevel'),
  ipv6AddressCount?: int32(name='Ipv6AddressCount', description='The number of IPv6 addresses.', example='1'),
  loadBalancerWeight?: int32(name='LoadBalancerWeight', description='The weight of the elastic container instance as a backend server. Valid values: 1 to 100.', example='50'),
  memory?: float(name='Memory', description='The memory size of the elastic container instance. Unit: GiB.', example='2.0'),
  ntpServers?: [ string ](name='NtpServers', description='The domain names of the NTP server.'),
  ownerId?: long(name='OwnerId'),
  ramRoleName?: string(name='RamRoleName', description='The name of the RAM role for the instance. You can use an instance RAM role to access both elastic container instances and Elastic Compute Service (ECS) instances. For more information, see [Use an instance RAM role by calling API operations](~~61178~~).', example='RamTestRole'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-uf66jeqopgqa9hdn****'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  restartPolicy?: string(name='RestartPolicy', description='The instance restart policy. Valid values:

*   Always: always restarts the elastic container instance.
*   Never: never restarts the elastic container instance.
*   OnFailure: restarts the elastic container instance upon failures.

Default value: Always.', example='Always'),
  scalingConfigurationId?: string(name='ScalingConfigurationId', description='The ID of the scaling configuration that you want to modify.', example='asc-bp16har3jpj6fjbx****'),
  scalingConfigurationName?: string(name='ScalingConfigurationName', description='The name of the scaling configuration. The name must be 2 to 64 characters in length and can contain letters, digits, underscores (\\_), hyphens (-), and periods (.). The name must start with a letter or a digit.

The name of the scaling configuration must be unique within a scaling group in a region. If you do not specify this parameter, the value of the ScalingConfigurationId parameter is used.', example='test-modify'),
  securityContextSysCtls?: [ 
    {
      name?: string(name='Name', description='The name of the security context in which the elastic container instance runs.', example='kernel.msgmax'),
      value?: string(name='Value', description='The variable value of the security context in which the elastic container instance runs.', example='65536'),
    }
  ](name='SecurityContextSysCtls', description='The system information of the security context in which the elastic container instance runs.'),
  securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group with which you want to associate the elastic container instance. Elastic container instances that are associated with the same security group can access each other.

If you do not specify a security group, the system uses the default security group in the region that you selected. Make sure that the inbound rules of the security group contain the protocols and the port numbers of the containers that you want to expose. If you do not have a default security group in the region, the system creates a default security group, and then adds the declared container protocols and port numbers to the inbound rules of the security group.', example='sg-uf66jeqopgqa9hdn****'),
  spotPriceLimit?: float(name='SpotPriceLimit', description='The maximum hourly price of the preemptible elastic container instance. The value can be accurate to three decimal places.

If you set the SpotStrategy parameter to SpotWithPriceLimit, you must also specify the SpotPriceLimit parameter.', example='0.025'),
  spotStrategy?: string(name='SpotStrategy', description='The bidding policy for the elastic container instance. Valid values:

*   NoSpot: The instance is a pay-as-you-go instance.
*   SpotWithPriceLimit: The instance is a preemptible instance with a user-defined maximum hourly price.
*   SpotAsPriceGo: The instance is a preemptible instance for which the market price at the time of purchase is used as the bid price.

Default value: NoSpot.', example='SpotPriceLimit'),
  tags?: [ 
    {
      key?: string(name='Key', description='The key of the tag.', example='version'),
      value?: string(name='Value', description='The value of the tag.', example='3'),
    }
  ](name='Tags', description='Information about the tags.'),
  terminationGracePeriodSeconds?: long(name='TerminationGracePeriodSeconds', description='The buffer time in which the program handles operations before the program is stopped. Unit: seconds.', example='60'),
  volumes?: [ 
    {
      diskVolume?: {
        diskId?: string(name='DiskId'),
        diskSize?: int32(name='DiskSize'),
        fsType?: string(name='FsType'),
      }(name='DiskVolume'),
      emptyDirVolume?: {
        medium?: string(name='Medium'),
      }(name='EmptyDirVolume'),
      flexVolume?: {
        driver?: string(name='Driver'),
        fsType?: string(name='FsType'),
        options?: string(name='Options'),
      }(name='FlexVolume'),
      hostPathVolume?: {
        path?: string(name='Path'),
        type?: string(name='Type'),
      }(name='HostPathVolume'),
      NFSVolume?: {
        path?: string(name='Path'),
        readOnly?: boolean(name='ReadOnly'),
        server?: string(name='Server'),
      }(name='NFSVolume'),
      configFileVolumeConfigFileToPath?: [ 
        {
          content?: string(name='Content', description='The content of the configuration file, which can be up to 32 KB in size.', example='bGl1bWk='),
          mode?: int32(name='Mode', description='The permissions on ConfigFileVolume.', example='0644'),
          path?: string(name='Path', description='The relative path to the configuration file.', example='/usr/bin/'),
        }
      ](name='ConfigFileVolumeConfigFileToPath', description='The paths to the configuration files.'),
      configFileVolumeDefaultMode?: int32(name='ConfigFileVolumeDefaultMode', description='The default permissions on ConfigFileVolume.', example='0644'),
      name?: string(name='Name', description='The name of the volume.', example='default-volume1'),
      type?: string(name='Type', description='The type of HostPathVolume. Examples: File, Directory, and Socket.', example='EmptyDirVolume'),
    }
  ](name='Volumes', description='Information about the volumes.'),
}

model ModifyEciScalingConfigurationResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='89945DD3-9072-47D0-A318-353284CF****'),
}

model ModifyEciScalingConfigurationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyEciScalingConfigurationResponseBody(name='body'),
}

/**
  * If you want to change the name of a scaling configuration in a scaling group, make sure that the new name is unique within the scaling group.
  *
  * @param request ModifyEciScalingConfigurationRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ModifyEciScalingConfigurationResponse
 */
async function modifyEciScalingConfigurationWithOptions(request: ModifyEciScalingConfigurationRequest, runtime: Util.RuntimeOptions): ModifyEciScalingConfigurationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acrRegistryInfos)) {
    query['AcrRegistryInfos'] = request.acrRegistryInfos;
  }
  if (!Util.isUnset(request.activeDeadlineSeconds)) {
    query['ActiveDeadlineSeconds'] = request.activeDeadlineSeconds;
  }
  if (!Util.isUnset(request.autoCreateEip)) {
    query['AutoCreateEip'] = request.autoCreateEip;
  }
  if (!Util.isUnset(request.autoMatchImageCache)) {
    query['AutoMatchImageCache'] = request.autoMatchImageCache;
  }
  if (!Util.isUnset(request.containerGroupName)) {
    query['ContainerGroupName'] = request.containerGroupName;
  }
  if (!Util.isUnset(request.containers)) {
    query['Containers'] = request.containers;
  }
  if (!Util.isUnset(request.containersUpdateType)) {
    query['ContainersUpdateType'] = request.containersUpdateType;
  }
  if (!Util.isUnset(request.costOptimization)) {
    query['CostOptimization'] = request.costOptimization;
  }
  if (!Util.isUnset(request.cpu)) {
    query['Cpu'] = request.cpu;
  }
  if (!Util.isUnset(request.cpuOptionsCore)) {
    query['CpuOptionsCore'] = request.cpuOptionsCore;
  }
  if (!Util.isUnset(request.cpuOptionsThreadsPerCore)) {
    query['CpuOptionsThreadsPerCore'] = request.cpuOptionsThreadsPerCore;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.dnsConfigNameServers)) {
    query['DnsConfigNameServers'] = request.dnsConfigNameServers;
  }
  if (!Util.isUnset(request.dnsConfigOptions)) {
    query['DnsConfigOptions'] = request.dnsConfigOptions;
  }
  if (!Util.isUnset(request.dnsConfigSearchs)) {
    query['DnsConfigSearchs'] = request.dnsConfigSearchs;
  }
  if (!Util.isUnset(request.dnsPolicy)) {
    query['DnsPolicy'] = request.dnsPolicy;
  }
  if (!Util.isUnset(request.egressBandwidth)) {
    query['EgressBandwidth'] = request.egressBandwidth;
  }
  if (!Util.isUnset(request.eipBandwidth)) {
    query['EipBandwidth'] = request.eipBandwidth;
  }
  if (!Util.isUnset(request.enableSls)) {
    query['EnableSls'] = request.enableSls;
  }
  if (!Util.isUnset(request.ephemeralStorage)) {
    query['EphemeralStorage'] = request.ephemeralStorage;
  }
  if (!Util.isUnset(request.hostAliases)) {
    query['HostAliases'] = request.hostAliases;
  }
  if (!Util.isUnset(request.hostName)) {
    query['HostName'] = request.hostName;
  }
  if (!Util.isUnset(request.imageRegistryCredentials)) {
    query['ImageRegistryCredentials'] = request.imageRegistryCredentials;
  }
  if (!Util.isUnset(request.imageSnapshotId)) {
    query['ImageSnapshotId'] = request.imageSnapshotId;
  }
  if (!Util.isUnset(request.ingressBandwidth)) {
    query['IngressBandwidth'] = request.ingressBandwidth;
  }
  if (!Util.isUnset(request.initContainers)) {
    query['InitContainers'] = request.initContainers;
  }
  if (!Util.isUnset(request.instanceFamilyLevel)) {
    query['InstanceFamilyLevel'] = request.instanceFamilyLevel;
  }
  if (!Util.isUnset(request.ipv6AddressCount)) {
    query['Ipv6AddressCount'] = request.ipv6AddressCount;
  }
  if (!Util.isUnset(request.loadBalancerWeight)) {
    query['LoadBalancerWeight'] = request.loadBalancerWeight;
  }
  if (!Util.isUnset(request.memory)) {
    query['Memory'] = request.memory;
  }
  if (!Util.isUnset(request.ntpServers)) {
    query['NtpServers'] = request.ntpServers;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.ramRoleName)) {
    query['RamRoleName'] = request.ramRoleName;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.restartPolicy)) {
    query['RestartPolicy'] = request.restartPolicy;
  }
  if (!Util.isUnset(request.scalingConfigurationId)) {
    query['ScalingConfigurationId'] = request.scalingConfigurationId;
  }
  if (!Util.isUnset(request.scalingConfigurationName)) {
    query['ScalingConfigurationName'] = request.scalingConfigurationName;
  }
  if (!Util.isUnset(request.securityContextSysCtls)) {
    query['SecurityContextSysCtls'] = request.securityContextSysCtls;
  }
  if (!Util.isUnset(request.securityGroupId)) {
    query['SecurityGroupId'] = request.securityGroupId;
  }
  if (!Util.isUnset(request.spotPriceLimit)) {
    query['SpotPriceLimit'] = request.spotPriceLimit;
  }
  if (!Util.isUnset(request.spotStrategy)) {
    query['SpotStrategy'] = request.spotStrategy;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  if (!Util.isUnset(request.terminationGracePeriodSeconds)) {
    query['TerminationGracePeriodSeconds'] = request.terminationGracePeriodSeconds;
  }
  if (!Util.isUnset(request.volumes)) {
    query['Volumes'] = request.volumes;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyEciScalingConfiguration',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * If you want to change the name of a scaling configuration in a scaling group, make sure that the new name is unique within the scaling group.
  *
  * @param request ModifyEciScalingConfigurationRequest
  * @return ModifyEciScalingConfigurationResponse
 */
async function modifyEciScalingConfiguration(request: ModifyEciScalingConfigurationRequest): ModifyEciScalingConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyEciScalingConfigurationWithOptions(request, runtime);
}

model ModifyLifecycleHookRequest {
  defaultResult?: string(name='DefaultResult', description='The period of time before the lifecycle hook ends. Auto Scaling performs the specified action after the lifecycle hook ends. Valid values: 30 to 21600. Unit: seconds.

You can call the RecordLifecycleActionHeartbeat operation to prolong the length of a lifecycle hook. You can also call the CompleteLifecycleAction operation to end a lifecycle hook ahead of schedule.', example='CONTINUE'),
  heartbeatTimeout?: int32(name='HeartbeatTimeout', description='The type of scaling activity to which the lifecycle hook applies. Valid values:

*   SCALE_OUT
*   SCALE_IN', example='600'),
  lifecycleHookId?: string(name='LifecycleHookId', description='The ID of the scaling group to which the lifecycle hook belongs.', example='ash-bp1fxuqyi98w0aib****'),
  lifecycleHookName?: string(name='LifecycleHookName', description='The action that you want Auto Scaling to perform after the lifecycle hook ends. Valid values:

*   CONTINUE: Auto Scaling continues to respond to scaling requests.
*   ABANDON: Auto Scaling releases Elastic Compute Service (ECS) instances that are created during scale-out activities, or removes ECS instances from the scaling group during scale-in activities.

If multiple lifecycle hooks in a scaling group are triggered during scale-in activities and you set the DefaultResult parameter to ABANDON for the lifecycle hook that you want to modify, Auto Scaling immediately performs the action after the lifecycle hook that you want to modify ends. As a result, other lifecycle hooks end ahead of schedule. In other cases, Auto Scaling performs the action only after all lifecycle hooks end.', example='test_SCALE_IN'),
  lifecycleHookStatus?: string(name='LifecycleHookStatus', description='The ID of the request.', example='Active'),
  lifecycleTransition?: string(name='LifecycleTransition', description='The fixed string that is included in a notification. Auto Scaling sends the notification when the lifecycle hook takes effect. The value of this parameter cannot exceed 4,096 characters in length.

Auto Scaling sends the value specified for the NotificationMetadata parameter together with the notification. This helps you categorize your notifications. The NotificationMetadata parameter takes effect only after you specify the NotificationArn parameter.', example='SCALE_IN'),
  notificationArn?: string(name='NotificationArn', description='The region ID of the scaling group.', example='acs:mns:cn-beijing:161456884340****:queue/modifyLifecycleHo****'),
  notificationMetadata?: string(name='NotificationMetadata', description='The Alibaba Cloud Resource Name (ARN) of the notification method. Specify the value in one of the following formats:

*   If the notification method is a Message Service (MNS) queue, specify the value in the acs:mns:{region-id}:{account-id}:queue/{queuename} format.
*   If the notification method is an MNS topic, specify the value in the acs:mns:{region-id}:{account-id}:topic/{topicname} format.
*   If the notification method is an Operation Orchestration Service (OOS) template, specify the value in the acs:oos:{region-id}:{account-id}:template/{templatename} format.

The variables in the preceding parameter formats have the following meanings:

*   region-id: the region ID of the scaling group.
*   account-id: the ID of the Alibaba Cloud account.
*   queuename: the name of the MNS queue.
*   topicname: the name of the MNS topic.
*   templatename: the name of the OOS template.', example='Test'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The status into which you want to put the lifecycle hook. Valid values:

*   Active
*   InActive

If you do not specify this parameter, the status of the lifecycle hook remains unchanged after you call this operation.

> By default, a lifecycle hook is in the Active state after you create it.', example='cn-beijing'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  scalingGroupId?: string(name='ScalingGroupId', description='The name of the lifecycle hook that you want to modify.', example='asg-bp18p2yfxow2dloq****'),
}

model ModifyLifecycleHookResponseBody = {
  requestId?: string(name='RequestId', description='auditing', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3****'),
}

model ModifyLifecycleHookResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyLifecycleHookResponseBody(name='body'),
}

/**
  * Modifies a lifecycle hook.
  *
  * @param request ModifyLifecycleHookRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ModifyLifecycleHookResponse
 */
async function modifyLifecycleHookWithOptions(request: ModifyLifecycleHookRequest, runtime: Util.RuntimeOptions): ModifyLifecycleHookResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.defaultResult)) {
    query['DefaultResult'] = request.defaultResult;
  }
  if (!Util.isUnset(request.heartbeatTimeout)) {
    query['HeartbeatTimeout'] = request.heartbeatTimeout;
  }
  if (!Util.isUnset(request.lifecycleHookId)) {
    query['LifecycleHookId'] = request.lifecycleHookId;
  }
  if (!Util.isUnset(request.lifecycleHookName)) {
    query['LifecycleHookName'] = request.lifecycleHookName;
  }
  if (!Util.isUnset(request.lifecycleHookStatus)) {
    query['LifecycleHookStatus'] = request.lifecycleHookStatus;
  }
  if (!Util.isUnset(request.lifecycleTransition)) {
    query['LifecycleTransition'] = request.lifecycleTransition;
  }
  if (!Util.isUnset(request.notificationArn)) {
    query['NotificationArn'] = request.notificationArn;
  }
  if (!Util.isUnset(request.notificationMetadata)) {
    query['NotificationMetadata'] = request.notificationMetadata;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.scalingGroupId)) {
    query['ScalingGroupId'] = request.scalingGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyLifecycleHook',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Modifies a lifecycle hook.
  *
  * @param request ModifyLifecycleHookRequest
  * @return ModifyLifecycleHookResponse
 */
async function modifyLifecycleHook(request: ModifyLifecycleHookRequest): ModifyLifecycleHookResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyLifecycleHookWithOptions(request, runtime);
}

model ModifyNotificationConfigurationRequest {
  notificationArn?: string(name='NotificationArn', description='The types of the notifications that you want to modify. You can modify one to eight notifications. Specify multiple values in the repeated list form.

You can call the DescribeNotificationTypes operation to query the values of this parameter.', example='acs:ess:cn-beijing:161456884340****:cloudmonitor'),
  notificationTypes?: [ string ](name='NotificationTypes', description='The types of the notifications that you want to modify. You can modify one to eight notifications. Specify multiple values in the repeated list form.

You can call the DescribeNotificationTypes operation to query the values of this parameter.'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The ID of the request.', example='cn-beijing'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  scalingGroupId?: string(name='ScalingGroupId', description='The Alibaba Cloud Resource Name (ARN) of the notification method. The following list describes the value formats of this parameter:

*   If you use CloudMonitor as the notification method, the value format of this parameter is acs:ess:{region-id}:{account-id}:cloudmonitor.
*   If you use an MNS queue as the notification method, the value format of this parameter is acs:mns:{region-id}:{account-id}:queue/{queuename}.
*   If you use an MNS topic as the notification method, the value format of this parameter is acs:mns:{region-id}:{account-id}:topic/{topicname}.

The variables in the preceding formats have the following meanings:

*   region-id: the region ID of the scaling group.
*   account-id: the ID of the Alibaba Cloud account.
*   queuename: the name of the MNS queue.
*   topicname: the name of the MNS topic.', example='asg-bp1igpak5ft1flyp****'),
}

model ModifyNotificationConfigurationResponseBody = {
  requestId?: string(name='RequestId', description='auditing', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3****'),
}

model ModifyNotificationConfigurationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyNotificationConfigurationResponseBody(name='body'),
}

async function modifyNotificationConfigurationWithOptions(request: ModifyNotificationConfigurationRequest, runtime: Util.RuntimeOptions): ModifyNotificationConfigurationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.notificationArn)) {
    query['NotificationArn'] = request.notificationArn;
  }
  if (!Util.isUnset(request.notificationTypes)) {
    query['NotificationTypes'] = request.notificationTypes;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.scalingGroupId)) {
    query['ScalingGroupId'] = request.scalingGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyNotificationConfiguration',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyNotificationConfiguration(request: ModifyNotificationConfigurationRequest): ModifyNotificationConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyNotificationConfigurationWithOptions(request, runtime);
}

model ModifyScalingConfigurationRequest {
  privatePoolOptions?: {
    id?: string(name='Id', description='The ID of the private pool. The ID of a private pool is the same as the ID of the elasticity assurance or capacity reservation for which the private pool is generated.', example='eap-bp67acfmxazb4****'),
    matchCriteria?: string(name='MatchCriteria', description='The type of the private pool that you want to use to create instances. A private pool is generated when an elasticity assurance or a capacity reservation takes effect. You can select a private pool when you create instances. Valid values:

*   Open: open private pool. The system selects an open private pool for instance startup. If no open private pool meets your business requirements, the resources in the public pool are used for instance startup. In this case, you do not need to specify the PrivatePoolOptions.Id parameter.
*   Target: specified private pool. The resources in the specified private pool are used for instance startup. If the specified private pool is unavailable, the instance startup fails. If you set this parameter to Target, you must specify the PrivatePoolOptions.Id parameter.
*   None: no private pool. The resources of private pools are not used for instance startup.', example='Open'),
  }(name='PrivatePoolOptions'),
  systemDisk?: {
    autoSnapshotPolicyId?: string(name='AutoSnapshotPolicyId', description='The ID of the automatic snapshot policy that you want to apply to the system disk.', example='sp-bp12m37ccmxvbmi5****'),
    burstingEnabled?: boolean(name='BurstingEnabled', description='Specifies whether to enable the burst feature for the system disk. Valid values:

*   true
*   false

> This parameter is available only if you set the `SystemDisk.Category` parameter to `cloud_auto`.

For more information, see [ESSD AutoPL disks](~~368372~~).', example='false'),
    category?: string(name='Category', description='The category of the system disk. Valid values:

*   cloud: basic disk.
*   cloud_efficiency: ultra disk.
*   cloud_ssd: standard SSD.
*   cloud_essd: ESSD.
*   ephemeral_ssd: local SSD.

You cannot specify the SystemDisk.Category and `SystemDiskCategories` parameters at the same time. If you do not specify the Category and `SystemDiskCategories` parameters, the default value of the Category parameter is used. For non-I/O optimized instances of Generation I instance types, the default value is cloud. For instances of other instance types, the default value is cloud_efficiency.', example='cloud_efficiency'),
    description?: string(name='Description', description='The description of the system disk. The description must be 2 to 256 characters in length. The description can contain letters but cannot start with `http://` or `https://`.', example='Test system disk.'),
    diskName?: string(name='DiskName', description='The name of the system disk. The name must be 2 to 128 characters in length. The name must start with a letter but cannot start with `http://` or `https://`. The name can contain letters, digits, colons (:), underscores (\\_), and hyphens (-).', example='cloud_ssdSystem'),
    encryptAlgorithm?: string(name='EncryptAlgorithm', description='The algorithm that is used to encrypt the system disk. Valid values:

*   AES-256
*   SM4-128

Default value: AES-256.', example='AES-256'),
    encrypted?: boolean(name='Encrypted', description='Specifies whether to encrypt the system disk. Valid values:

*   true: encrypts the system disk.
*   false: does not encrypt the system disk.

Default value: false.', example='false'),
    KMSKeyId?: string(name='KMSKeyId', description='The ID of the KMS key that is used to encrypt the system disk.', example='0e478b7a-4262-4802-b8cb-00d3fb40****'),
    performanceLevel?: string(name='PerformanceLevel', description='The PL of the system disk of the ESSD category. Valid values:

*   PL0: An ESSD can deliver up to 10,000 random read/write IOPS.
*   PL1: An ESSD can deliver up to 50,000 random read/write IOPS.
*   PL2: An ESSD can deliver up to 100,000 random read/write IOPS.
*   PL3: An ESSD can deliver up to 1,000,000 random read/write IOPS.

> For more information about how to choose ESSD PLs, see [ESSD](~~122389~~).', example='PL0'),
    provisionedIops?: long(name='ProvisionedIops', description='The IOPS metric that is preconfigured for the system disk.

> IOPS measures the number of read and write operations that an EBS device can process per second.', example='100'),
    size?: int32(name='Size', description='The size of the system disk. Unit: GiB.

*   Valid values if you set the SystemDisk.Category parameter to cloud: 20 to 500.
*   Valid values if you set the SystemDisk.Category parameter to cloud_efficiency: 20 to 500
*   Valid values if you set the SystemDisk.Category parameter to cloud_ssd: 20 to 500
*   Valid values if you set the SystemDisk.Category parameter to cloud_essd: 20 to 500
*   Valid values if you set the SystemDisk.Category parameter to ephemeral_ssd: 20 to 500

The value of SystemDisk.Size must be greater than or equal to max{20, ImageSize}.', example='50'),
  }(name='SystemDisk'),
  affinity?: string(name='Affinity', description='Specifies whether to associate the instance on a dedicated host with the dedicated host. Valid values:

*   default: does not associate the instance with the dedicated host. If you start an instance that was stopped in economical mode and the original dedicated host of the instance has insufficient resources, the instance is automatically deployed to another dedicated host in the automatic deployment resource pool.
*   host: associates the instance with the dedicated host. If you start an instance that was stopped in economical mode, the instance remains on the original dedicated host. If the original dedicated host of the instance has insufficient resources, you cannot start the instance.', example='default'),
  cpu?: int32(name='Cpu', description='The number of vCPUs.

You can specify the number of vCPUs and the memory size to determine the range of instance types. For example, you can set the Cpu parameter to 2 and the Memory parameter to 16 to specify the instance types that have 2 vCPUs and 16 GiB of memory. Auto Scaling determines the available instance types based on factors such as I/O optimization requirements and zones. Then, Auto Scaling preferentially creates instances of the instance type that is provided at the lowest price.

> You can specify the Cpu and Memory parameters to determine the range of instance types only if the Scaling Policy parameter is set to Cost Optimization Policy and no instance type is specified in the scaling configuration.', example='2'),
  creditSpecification?: string(name='CreditSpecification', description='The performance mode of the burstable instance. Valid values:

*   Standard: standard mode. For more information, see the "Standard mode" section in [Burstable instances](~~59977~~).
*   Unlimited: unlimited mode. For more information, see the "Unlimited mode" section in [Burstable instances](~~59977~~).', example='Standard'),
  dataDisks?: [ 
    {
      autoSnapshotPolicyId?: string(name='AutoSnapshotPolicyId', description='The ID of the automatic snapshot policy that you want to apply to the data disk.', example='sp-bp19nq9enxqkomib****'),
      burstingEnabled?: boolean(name='BurstingEnabled', description='Specifies whether to enable the burst feature for the system disk. Valid values:

*   true
*   false

> This parameter is available only if you set the `SystemDisk.Category` parameter to `cloud_auto`.

For more information, see [ESSD AutoPL disks](~~368372~~).', example='false'),
      categories?: [ string ](name='Categories', description='The categories of the data disks. You can specify 1 to 16 data disks. You can specify 1 to 4 disk categories in a scaling configuration. The first disk category that is specified in a scaling configuration has the highest priority. The priority deceases based on the specified order of disk categories. If Auto Scaling cannot create instances by using the data disk that has the highest priority, Auto Scaling creates instances by using the data disk that has the next highest priority. Valid values:

*   cloud: basic disk. The DeleteWithInstance attribute of a basic disk that is created together with the instance is set to true.
*   cloud_efficiency: ultra disk.
*   cloud_ssd: standard SSD.
*   cloud_essd: ESSD.

> You cannot specify the Categories and `Category` parameters at the same time.'),
      category?: string(name='Category', description='The category of the data disk. You can specify 1 to 16 data disks. Valid values:

*   cloud: basic disk. The DeleteWithInstance attribute of a basic disk that is created together with the instance is set to true.
*   cloud_efficiency: ultra disk.
*   cloud_ssd: standard SSD.
*   ephemeral_ssd: local standard SSD.
*   cloud_essd: ESSD.

You cannot specify the Category and `Categories` parameters at the same time. If you do not specify the Category and `Categories` parameters, the default value of the Category parameter is:

*   cloud_efficiency for I/O optimized instances.
*   cloud for non-I/O optimized instances.', example='cloud_ssd'),
      deleteWithInstance?: boolean(name='DeleteWithInstance', description='Specifies whether to release the data disk when the instance to which the data disk is attached is released. Valid values:

*   true
*   false

This parameter is available only for independent disks whose Category parameter is set to cloud, cloud_efficiency, cloud_ssd, cloud_essd, or cloud_auto. If you specify this parameter for disks of other categories, an error will be reported.', example='true'),
      description?: string(name='Description', description='The description of the system disk. The description must be 2 to 256 characters in length. The description can contain letters but cannot start with `http://` or `https://`.', example='Test data disk.'),
      device?: string(name='Device', description='The mount target of the data disk. If you do not specify the Device parameter, a mount target is automatically created when Auto Scaling creates ECS instance. The name of the mount target ranges from /dev/xvdb to /dev/xvdz.', example='/dev/xvdd'),
      diskName?: string(name='DiskName', description='The name of the system disk. The name must be 2 to 128 characters in length and can contain letters, digits, colons (:), underscores (\\_), and hyphens (-). The name must start with a letter but cannot start with `http://` or `https://`.', example='cloud_ssdData'),
      encrypted?: string(name='Encrypted', description='Specifies whether to encrypt the system disk. Valid values:

*   true: encrypts the system disk.
*   false: does not encrypt the system disk.', example='false'),
      KMSKeyId?: string(name='KMSKeyId', description='The ID of the KMS key of the data disk.', example='0e478b7a-4262-4802-b8cb-00d3fb40****'),
      performanceLevel?: string(name='PerformanceLevel', description='The PL of the data disk of the ESSD category. If you set the Category parameter to cloud_essd, you must also specify the PerformanceLevel parameter. Valid values:

*   PL0: An ESSD can deliver up to 10,000 random read/write IOPS.
*   PL1: An ESSD can deliver up to 50,000 random read/write IOPS.
*   PL2: An ESSD can deliver up to 100,000 random read/write IOPS.
*   PL3: An ESSD can deliver up to 1,000,000 random read/write IOPS.

> For more information about how to choose ESSD PLs, see [ESSD](~~122389~~).', example='PL1'),
      provisionedIops?: long(name='ProvisionedIops', description='The input/output operations per second (IOPS) metric that is preconfigured for the data disk.

> IOPS measures the number of read and write operations that an EBS device can process per second.', example='100'),
      size?: int32(name='Size', description='The size of the data disk. Unit: GiB.

*   Valid values if you set the Category parameter to cloud: 5 to 2000.
*   Valid values if you set the Category parameter to cloud_efficiency: 20 to 32768.
*   Valid values if you set the Category parameter to cloud_ssd: 20 to 32768.
*   Valid values if you set the Category parameter to cloud_essd: 20 to 32768.
*   Valid values if you set the Category parameter to ephemeral_ssd: 5 to 800.

The value of the Size parameter must be greater than or equal to the size of the snapshot that is specified by the SnapshotId parameter.', example='100'),
      snapshotId?: string(name='SnapshotId', description='The ID of the snapshot that you want to use to create data disks. If you specify this parameter, the Size parameter is ignored. The size of the disk is the same as the size of the specified snapshot.

If you specify a snapshot created on or before July 15, 2013, the operation fails and the system returns InvalidSnapshot.TooOld.', example='s-snapshot****'),
    }
  ](name='DataDisks', description='Details of the data disks.'),
  dedicatedHostId?: string(name='DedicatedHostId', description='The ID of the dedicated host on which you want to create the ECS instance. You cannot create preemptible instances on dedicated hosts. If you specify the DedicatedHostId parameter, the SpotStrategy and SpotPriceLimit parameters are ignored.

You can call the DescribeDedicatedHosts operation to query dedicated host IDs.', example='dh-bp67acfmxazb4p****'),
  deploymentSetId?: string(name='DeploymentSetId', description='The ID of the deployment set to which the ECS instance belongs.', example='ds-bp13v7bjnj9gis****'),
  hostName?: string(name='HostName', description='The hostname of the ECS instance. The hostname cannot start or end with a period (.) or a hyphen (-). The hostname cannot contain consecutive periods (.) or hyphens (-). Naming conventions for different types of instances:

*   Windows instances: The hostname must be 2 to 15 characters in length, and can contain letters, digits, and hyphens (-). The hostname cannot contain periods (.) or contain only digits.
*   Other instances such as Linux instances: The hostname must be 2 to 64 characters in length. You can use periods (.) to separate a hostname into multiple segments. Each segment can contain letters, digits, and hyphens (-).', example='hos****'),
  hpcClusterId?: string(name='HpcClusterId', description='The ID of the Elastic High Performance Computing (E-HPC) cluster to which the ECS instance belongs.', example='hpc-clusterid'),
  imageFamily?: string(name='ImageFamily', description='The name of the image family. You can specify this parameter to obtain the latest custom images that are available in the specified image family. The images are used to create instances. If the ImageId parameter is specified, you cannot specify the ImageFamily parameter.', example='hangzhou-daily-update'),
  imageId?: string(name='ImageId', description='The ID of the image that is used by Auto Scaling to automatically create instances.

> If the image that is specified in the scaling configuration contains system disks and data disks, the data that is stored in the data disks is cleared after you modify the image.', example='centos6u5_64_20G_aliaegis_2014****.vhd'),
  imageName?: string(name='ImageName', description='The name of the image. Each image name must be unique in a region. If you specify the ImageId parameter, the ImageName parameter is ignored.

You cannot use the ImageName parameter to specify Alibaba Cloud Marketplace images.', example='suse11sp3_64_20G_aliaegis_2015****.vhd'),
  instanceDescription?: string(name='InstanceDescription', description='The description of the ECS instance. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.', example='Test instance.'),
  instanceName?: string(name='InstanceName', description='The name of the ECS instance that is automatically created based on the scaling configuration.', example='inst****'),
  instancePatternInfos?: [ 
    {
      architectures?: [ string ](name='Architectures', description='The architectures of the instance types. Valid values:

*   X86: x86 architecture.
*   Heterogeneous: heterogeneous architecture, such as GPUs and FPGAs.
*   BareMetal: ECS Bare Metal Instance architecture.
*   Arm: ARM architecture.
*   SuperComputeCluster: Super Computing Cluster architecture.

By default, all values are selected.'),
      burstablePerformance?: string(name='BurstablePerformance', description='Specifies whether to include burstable instance types. Valid values:

*   Exclude: excludes burstable instance types.
*   Include: includes burstable instance types.
*   Required: includes only burstable instance types.

Default value: Include.', example='Include'),
      cores?: int32(name='Cores', description='The number of vCPUs that is specified for an instance type in the intelligent configuration mode. This parameter is used to filter the available instance types that meet the specified criteria. For more information, see [Instance family](~~25378~~).

Take note of the following items:

*   The InstancePatternInfos parameter is available only for scaling groups that reside in VPCs.
*   You must specify the InstancePatternInfos, Cores, and Memory parameters at the same time.
*   If you specify an instance type by using the InstanceType or InstanceTypes parameter, Auto Scaling preferentially uses the instance type that is specified by the InstanceType or InstanceTypes parameter for scale-out activities. If the specified instance type does not have sufficient inventory, Auto Scaling creates instances of the instance type that is specified by the InstancePatternInfos parameter based on the price in ascending order.', example='2'),
      excludedInstanceTypes?: [ string ](name='ExcludedInstanceTypes', description='The instance types that you want to filter out. You can use wildcard characters such as an asterisk (\\*) to filter out a single instance type or an instance family. Example:

*   ecs.c6.large: The ecs.c6.large instance type is filtered out.
*   ecs.c6.\\*: The c6 instance family is filtered out.'),
      instanceFamilyLevel?: string(name='InstanceFamilyLevel', description='The level of the instance type, which is used to filter the instance types that meet the specified criteria. This parameter takes effect only if you set the `CostOptimization` parameter to true. Valid values:

*   EntryLevel: shared instance type. Instances of this level are the most cost-effective but may not provide stable computing performance in a consistent manner. Instances of this level are suitable for business scenarios in which the CPU utilization is low. For more information, see [Shared instance families](~~108489~~).
*   EnterpriseLevel: Instances of this level provide stable performance and dedicated resources, and are suitable for business scenarios that require high stability. For more information, see [Instance family](~~25378~~).
*   CreditEntryLevel: This value is valid only for burstable instances. CPU credits are used to ensure computing performance. Instances of this level are suitable for scenarios in which the CPU utilization is low but may fluctuate in specific cases. For more information, see the [Overview](~~59977~~) topic of burstable instances.', example='EnterpriseLevel'),
      maxPrice?: float(name='MaxPrice', description='The maximum hourly price for a pay-as-you-go instance or a preemptible instance in the intelligent configuration mode. This parameter is used to filter the available instance types that meet the specified criteria.

> If you set the SpotStrategy parameter to SpotWithPriceLimit, you must specify the MaxPrice parameter. In other cases, you do not need to specify the MaxPrice parameter.', example='2'),
      memory?: float(name='Memory', description='The memory size that is specified for an instance type in the intelligent configuration mode. Unit: GiB. This parameter is used to filter the available instance types that meet the specified criteria.', example='4'),
    }
  ](name='InstancePatternInfos', description='Information about the intelligent configuration settings, which determines the available instance types.'),
  instanceTypeOverrides?: [ 
    {
      instanceType?: string(name='InstanceType', description='The instance type. If you want to specify the weight of the instance type in the scaling configuration, you must specify the InstanceType and WeightedCapacity parameters at the same time.

You can use the InstanceType parameter to specify 1 to 10 instance types. You can use the WeightedCapacity parameter to specify weights of instance types.

> You cannot specify the InstanceType and InstanceTypes parameters at the same time.

You can specify instance types that are available for purchase as the values of the InstanceType parameter.', example='ecs.c5.xlarge'),
      weightedCapacity?: int32(name='WeightedCapacity', description='The weight of the instance type. The weight of the instance type indicates the capacity of the instance of the specified instance type in the scaling group. If you want Auto Scaling to scale instances based on the instance type weight, you must specify the WeightedCapacity parameter after you specify the InstanceType parameter.

A higher weight specifies that a smaller number of instances of the specified instance type are required to meet the expected capacity.

Performance metrics, such as the number of vCPUs and the memory size of each instance type, may vary. You can specify different weights for different instance types based on your business requirements.

Example:

*   Current capacity: 0
*   Expected capacity: 6
*   Capacity of ecs.c5.xlarge: 4

To meet the expected capacity requirement, Auto Scaling must create and add two ecs.c5.xlarge instances.

> The capacity of the scaling group cannot exceed the sum of the maximum number of instances that is specified by the MaxSize parameter and the maximum weight of the instance types.

Valid values of the WeightedCapacity parameter: 1 to 500.', example='4'),
    }
  ](name='InstanceTypeOverrides', description='Information about the instance type.'),
  instanceTypes?: [ string ](name='InstanceTypes', description='The instance types. If you specify this parameter, the InstanceType parameter is ignored. You can specify up to 10 instance types in a scaling configuration.

The first instance type has the highest priority. The priority decreases based on the specified order of instance types. Auto Scaling creates instances based on the priorities of the instance types. If Auto Scaling cannot create instances of the instance type that has the highest priority, Auto Scaling creates instances of the instance type that has the next highest priority.'),
  internetChargeType?: string(name='InternetChargeType', description='The billing method for network usage. Valid values:

*   PayByBandwidth: You are charged for the maximum available bandwidth that is specified by the InternetMaxBandwidthOut parameter.
*   PayByTraffic: You are charged for the actual traffic that is used. The InternetMaxBandwidthOut parameter specifies only the maximum available bandwidth.', example='PayByBandwidth'),
  internetMaxBandwidthOut?: int32(name='InternetMaxBandwidthOut', description='The maximum outbound public bandwidth. Unit: Mbit/s. Valid values:

*   0 to 100 if you set the InternetChargeType parameter to PayByBandwidth. If you leave this parameter empty, this parameter is automatically set to 0.
*   0 to 100 if you set the InternetChargeType parameter to PayByTraffic. If you leave this parameter empty, an error will be reported.', example='50'),
  ioOptimized?: string(name='IoOptimized', description='Specifies whether to create an I/O optimized instance. Valid values:

*   none: does not create an I/O optimized instance.
*   optimized: creates an I/O optimized instance.', example='none'),
  ipv6AddressCount?: int32(name='Ipv6AddressCount', description='The number of randomly generated IPv6 addresses that you want to allocate to the elastic network interface (ENI).', example='1'),
  keyPairName?: string(name='KeyPairName', description='The name of the key pair that is used to log on to the ECS instance.

*   Windows instances do not use this parameter.
*   By default, the username and password authentication method is disabled for Linux instances.', example='KeyPair_Name'),
  loadBalancerWeight?: int32(name='LoadBalancerWeight', description='The weight of the ECS instance as a backend server. Valid values: 1 to 100.', example='50'),
  memory?: int32(name='Memory', description='The size of the memory. Unit: GiB.

You can specify the number of vCPUs and the memory size to determine the range of instance types. For example, you can set the Cpu parameter to 2 and the Memory parameter to 16 to specify the instance types that have 2 vCPUs and 16 GiB of memory. Auto Scaling determines the available instance types based on factors such as I/O optimization requirements and zones. Then, Auto Scaling preferentially creates instances of the instance type that is provided at the lowest price.

> You can specify the Cpu and Memory parameters to determine the range of instance types only if the Scaling Policy parameter is set to Cost Optimization Policy and no instance type is specified in the scaling configuration.', example='16'),
  override?: boolean(name='Override', description='Specifies whether to overwrite existing data. Valid values:

*   true: overwrites existing data.
*   false: does not overwrite existing data.', example='true'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  passwordInherit?: boolean(name='PasswordInherit', description='Specifies whether to use the password that is preconfigured in the image. Before you use this parameter, make sure that a password is configured for the image.', example='false'),
  ramRoleName?: string(name='RamRoleName', description='The name of the RAM role that is associated with the ECS instance. The name is provided and maintained by Resource Access Management (RAM). You can call the ListRoles operation to query the available RAM roles. You can call the CreateRole operation to create RAM roles.', example='RamRoleTest'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the ECS instance belongs.', example='abcd1234abcd****'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  scalingConfigurationId?: string(name='ScalingConfigurationId', description='The ID of the scaling configuration that you want to modify.', example='asc-bp16har3jpj6fjbx****'),
  scalingConfigurationName?: string(name='ScalingConfigurationName', description='The name of the scaling configuration. The name must be 2 to 64 characters in length and can contain letters, digits, underscores (\\_), hyphens (-), and periods (.). It must start with a letter or a digit.

The name of the scaling configuration must be unique within a scaling group in a region. If you do not specify the ScalingConfigurationName parameter, the scaling configuration ID is used.', example='test-modify'),
  schedulerOptions?: map[string]any(name='SchedulerOptions', description='The options of the scheduler.'),
  securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group with which the ECS instance is associated. The ECS instances that are associated with the same security group can access each other.', example='sg-F876F****'),
  securityGroupIds?: [ string ](name='SecurityGroupIds', description='The IDs of the security groups.'),
  spotDuration?: int32(name='SpotDuration', description='The retention period of the preemptible instance. Unit: hours. Valid values: 0, 1, 2, 3, 4, 5, and 6.

*   The following retention periods are available in invitational preview: 2, 3, 4, 5, and 6 hours. If you want to set this parameter to one of these values, submit a ticket.
*   If you set this parameter to 0, no retention period is specified for the preemptible instance.', example='1'),
  spotInterruptionBehavior?: string(name='SpotInterruptionBehavior', description='The interruption event of the preemptible instance. Default value: Terminate. Set the value to Terminate, which specifies that the preemptible instance is to be released.', example='Terminate'),
  spotPriceLimits?: [ 
    {
      instanceType?: string(name='InstanceType', description='The instance type of the preemptible instance. This parameter takes effect only if you set the SpotStrategy parameter to SpotWithPriceLimit.', example='ecs.g6.large'),
      priceLimit?: float(name='PriceLimit', description='The price limit of the preemptible instance. This parameter takes effect only if you set the SpotStrategy parameter to SpotWithPriceLimit.', example='0.125'),
    }
  ](name='SpotPriceLimits', description='Information about the instance types of preemptible instances.'),
  spotStrategy?: string(name='SpotStrategy', description='The preemption policy that you want to apply to pay-as-you-go instances and preemptible instances. Valid values:

*   NoSpot: The instance is created as a pay-as-you-go instance.
*   SpotWithPriceLimit: The instance is a preemptible instance that has a user-defined maximum hourly price.
*   SpotAsPriceGo: The instance is created as a preemptible instance for which the market price at the time of purchase is automatically used as the bid price.', example='NoSpot'),
  systemDiskCategories?: [ string ](name='SystemDiskCategories', description='The categories of the system disks. You can specify one to four disk categories in a scaling configuration. The first disk category that is specified in a scaling configuration has the highest priority. The priority deceases based on the specified order of disk categories. If Auto Scaling cannot create instances by using the disk category that has the highest priority, Auto Scaling creates instances by using the disk category that has the next highest priority. Valid values:

*   cloud: basic disk.
*   cloud_efficiency: ultra disk.
*   cloud_ssd: standard SSD.
*   cloud_essd: ESSD.

> You cannot specify the SystemDiskCategories and `SystemDisk.Category` parameters at the same time.'),
  tags?: string(name='Tags', description='The tags of the ECS instance. The tags must be specified in the key-value pair format. You can specify up to 20 tags. When you specify tag keys and tag values, take note of the following items:

*   A tag key can be up to 64 characters in length. The key cannot start with `acs:` or `aliyun`, and cannot contain `http://` or `https://`. You cannot specify an empty string as a tag key.
*   A tag value can be up to 128 characters in length. The value cannot start with `acs:` or `aliyun`, and cannot contain `http://` or `https://`. You can specify an empty string as a tag value.', example='{"key1":"value1","key2":"value2", ... "key5":"value5"}'),
  tenancy?: string(name='Tenancy', description='Specifies whether to create the instance on a dedicated host. Valid values:

*   default: does not create the instance on a dedicated host.
*   host: creates the instance on a dedicated host. If you do not specify the DedicatedHostId parameter, Alibaba Cloud selects a dedicated host for the instance that you want to create.', example='default'),
  userData?: string(name='UserData', description='The user data of the ECS instance. The data must be encoded in Base64. The maximum size of the data before encoding is 16 KB.', example='echo hello ecs!'),
  zoneId?: string(name='ZoneId', description='The zone ID of the ECS instance.', example='cn-hangzhou-g'),
}

model ModifyScalingConfigurationShrinkRequest {
  privatePoolOptions?: {
    id?: string(name='Id', description='The ID of the private pool. The ID of a private pool is the same as the ID of the elasticity assurance or capacity reservation for which the private pool is generated.', example='eap-bp67acfmxazb4****'),
    matchCriteria?: string(name='MatchCriteria', description='The type of the private pool that you want to use to create instances. A private pool is generated when an elasticity assurance or a capacity reservation takes effect. You can select a private pool when you create instances. Valid values:

*   Open: open private pool. The system selects an open private pool for instance startup. If no open private pool meets your business requirements, the resources in the public pool are used for instance startup. In this case, you do not need to specify the PrivatePoolOptions.Id parameter.
*   Target: specified private pool. The resources in the specified private pool are used for instance startup. If the specified private pool is unavailable, the instance startup fails. If you set this parameter to Target, you must specify the PrivatePoolOptions.Id parameter.
*   None: no private pool. The resources of private pools are not used for instance startup.', example='Open'),
  }(name='PrivatePoolOptions'),
  systemDisk?: {
    autoSnapshotPolicyId?: string(name='AutoSnapshotPolicyId', description='The ID of the automatic snapshot policy that you want to apply to the system disk.', example='sp-bp12m37ccmxvbmi5****'),
    burstingEnabled?: boolean(name='BurstingEnabled', description='Specifies whether to enable the burst feature for the system disk. Valid values:

*   true
*   false

> This parameter is available only if you set the `SystemDisk.Category` parameter to `cloud_auto`.

For more information, see [ESSD AutoPL disks](~~368372~~).', example='false'),
    category?: string(name='Category', description='The category of the system disk. Valid values:

*   cloud: basic disk.
*   cloud_efficiency: ultra disk.
*   cloud_ssd: standard SSD.
*   cloud_essd: ESSD.
*   ephemeral_ssd: local SSD.

You cannot specify the SystemDisk.Category and `SystemDiskCategories` parameters at the same time. If you do not specify the Category and `SystemDiskCategories` parameters, the default value of the Category parameter is used. For non-I/O optimized instances of Generation I instance types, the default value is cloud. For instances of other instance types, the default value is cloud_efficiency.', example='cloud_efficiency'),
    description?: string(name='Description', description='The description of the system disk. The description must be 2 to 256 characters in length. The description can contain letters but cannot start with `http://` or `https://`.', example='Test system disk.'),
    diskName?: string(name='DiskName', description='The name of the system disk. The name must be 2 to 128 characters in length. The name must start with a letter but cannot start with `http://` or `https://`. The name can contain letters, digits, colons (:), underscores (\\_), and hyphens (-).', example='cloud_ssdSystem'),
    encryptAlgorithm?: string(name='EncryptAlgorithm', description='The algorithm that is used to encrypt the system disk. Valid values:

*   AES-256
*   SM4-128

Default value: AES-256.', example='AES-256'),
    encrypted?: boolean(name='Encrypted', description='Specifies whether to encrypt the system disk. Valid values:

*   true: encrypts the system disk.
*   false: does not encrypt the system disk.

Default value: false.', example='false'),
    KMSKeyId?: string(name='KMSKeyId', description='The ID of the KMS key that is used to encrypt the system disk.', example='0e478b7a-4262-4802-b8cb-00d3fb40****'),
    performanceLevel?: string(name='PerformanceLevel', description='The PL of the system disk of the ESSD category. Valid values:

*   PL0: An ESSD can deliver up to 10,000 random read/write IOPS.
*   PL1: An ESSD can deliver up to 50,000 random read/write IOPS.
*   PL2: An ESSD can deliver up to 100,000 random read/write IOPS.
*   PL3: An ESSD can deliver up to 1,000,000 random read/write IOPS.

> For more information about how to choose ESSD PLs, see [ESSD](~~122389~~).', example='PL0'),
    provisionedIops?: long(name='ProvisionedIops', description='The IOPS metric that is preconfigured for the system disk.

> IOPS measures the number of read and write operations that an EBS device can process per second.', example='100'),
    size?: int32(name='Size', description='The size of the system disk. Unit: GiB.

*   Valid values if you set the SystemDisk.Category parameter to cloud: 20 to 500.
*   Valid values if you set the SystemDisk.Category parameter to cloud_efficiency: 20 to 500
*   Valid values if you set the SystemDisk.Category parameter to cloud_ssd: 20 to 500
*   Valid values if you set the SystemDisk.Category parameter to cloud_essd: 20 to 500
*   Valid values if you set the SystemDisk.Category parameter to ephemeral_ssd: 20 to 500

The value of SystemDisk.Size must be greater than or equal to max{20, ImageSize}.', example='50'),
  }(name='SystemDisk'),
  affinity?: string(name='Affinity', description='Specifies whether to associate the instance on a dedicated host with the dedicated host. Valid values:

*   default: does not associate the instance with the dedicated host. If you start an instance that was stopped in economical mode and the original dedicated host of the instance has insufficient resources, the instance is automatically deployed to another dedicated host in the automatic deployment resource pool.
*   host: associates the instance with the dedicated host. If you start an instance that was stopped in economical mode, the instance remains on the original dedicated host. If the original dedicated host of the instance has insufficient resources, you cannot start the instance.', example='default'),
  cpu?: int32(name='Cpu', description='The number of vCPUs.

You can specify the number of vCPUs and the memory size to determine the range of instance types. For example, you can set the Cpu parameter to 2 and the Memory parameter to 16 to specify the instance types that have 2 vCPUs and 16 GiB of memory. Auto Scaling determines the available instance types based on factors such as I/O optimization requirements and zones. Then, Auto Scaling preferentially creates instances of the instance type that is provided at the lowest price.

> You can specify the Cpu and Memory parameters to determine the range of instance types only if the Scaling Policy parameter is set to Cost Optimization Policy and no instance type is specified in the scaling configuration.', example='2'),
  creditSpecification?: string(name='CreditSpecification', description='The performance mode of the burstable instance. Valid values:

*   Standard: standard mode. For more information, see the "Standard mode" section in [Burstable instances](~~59977~~).
*   Unlimited: unlimited mode. For more information, see the "Unlimited mode" section in [Burstable instances](~~59977~~).', example='Standard'),
  dataDisks?: [ 
    {
      autoSnapshotPolicyId?: string(name='AutoSnapshotPolicyId', description='The ID of the automatic snapshot policy that you want to apply to the data disk.', example='sp-bp19nq9enxqkomib****'),
      burstingEnabled?: boolean(name='BurstingEnabled', description='Specifies whether to enable the burst feature for the system disk. Valid values:

*   true
*   false

> This parameter is available only if you set the `SystemDisk.Category` parameter to `cloud_auto`.

For more information, see [ESSD AutoPL disks](~~368372~~).', example='false'),
      categories?: [ string ](name='Categories', description='The categories of the data disks. You can specify 1 to 16 data disks. You can specify 1 to 4 disk categories in a scaling configuration. The first disk category that is specified in a scaling configuration has the highest priority. The priority deceases based on the specified order of disk categories. If Auto Scaling cannot create instances by using the data disk that has the highest priority, Auto Scaling creates instances by using the data disk that has the next highest priority. Valid values:

*   cloud: basic disk. The DeleteWithInstance attribute of a basic disk that is created together with the instance is set to true.
*   cloud_efficiency: ultra disk.
*   cloud_ssd: standard SSD.
*   cloud_essd: ESSD.

> You cannot specify the Categories and `Category` parameters at the same time.'),
      category?: string(name='Category', description='The category of the data disk. You can specify 1 to 16 data disks. Valid values:

*   cloud: basic disk. The DeleteWithInstance attribute of a basic disk that is created together with the instance is set to true.
*   cloud_efficiency: ultra disk.
*   cloud_ssd: standard SSD.
*   ephemeral_ssd: local standard SSD.
*   cloud_essd: ESSD.

You cannot specify the Category and `Categories` parameters at the same time. If you do not specify the Category and `Categories` parameters, the default value of the Category parameter is:

*   cloud_efficiency for I/O optimized instances.
*   cloud for non-I/O optimized instances.', example='cloud_ssd'),
      deleteWithInstance?: boolean(name='DeleteWithInstance', description='Specifies whether to release the data disk when the instance to which the data disk is attached is released. Valid values:

*   true
*   false

This parameter is available only for independent disks whose Category parameter is set to cloud, cloud_efficiency, cloud_ssd, cloud_essd, or cloud_auto. If you specify this parameter for disks of other categories, an error will be reported.', example='true'),
      description?: string(name='Description', description='The description of the system disk. The description must be 2 to 256 characters in length. The description can contain letters but cannot start with `http://` or `https://`.', example='Test data disk.'),
      device?: string(name='Device', description='The mount target of the data disk. If you do not specify the Device parameter, a mount target is automatically created when Auto Scaling creates ECS instance. The name of the mount target ranges from /dev/xvdb to /dev/xvdz.', example='/dev/xvdd'),
      diskName?: string(name='DiskName', description='The name of the system disk. The name must be 2 to 128 characters in length and can contain letters, digits, colons (:), underscores (\\_), and hyphens (-). The name must start with a letter but cannot start with `http://` or `https://`.', example='cloud_ssdData'),
      encrypted?: string(name='Encrypted', description='Specifies whether to encrypt the system disk. Valid values:

*   true: encrypts the system disk.
*   false: does not encrypt the system disk.', example='false'),
      KMSKeyId?: string(name='KMSKeyId', description='The ID of the KMS key of the data disk.', example='0e478b7a-4262-4802-b8cb-00d3fb40****'),
      performanceLevel?: string(name='PerformanceLevel', description='The PL of the data disk of the ESSD category. If you set the Category parameter to cloud_essd, you must also specify the PerformanceLevel parameter. Valid values:

*   PL0: An ESSD can deliver up to 10,000 random read/write IOPS.
*   PL1: An ESSD can deliver up to 50,000 random read/write IOPS.
*   PL2: An ESSD can deliver up to 100,000 random read/write IOPS.
*   PL3: An ESSD can deliver up to 1,000,000 random read/write IOPS.

> For more information about how to choose ESSD PLs, see [ESSD](~~122389~~).', example='PL1'),
      provisionedIops?: long(name='ProvisionedIops', description='The input/output operations per second (IOPS) metric that is preconfigured for the data disk.

> IOPS measures the number of read and write operations that an EBS device can process per second.', example='100'),
      size?: int32(name='Size', description='The size of the data disk. Unit: GiB.

*   Valid values if you set the Category parameter to cloud: 5 to 2000.
*   Valid values if you set the Category parameter to cloud_efficiency: 20 to 32768.
*   Valid values if you set the Category parameter to cloud_ssd: 20 to 32768.
*   Valid values if you set the Category parameter to cloud_essd: 20 to 32768.
*   Valid values if you set the Category parameter to ephemeral_ssd: 5 to 800.

The value of the Size parameter must be greater than or equal to the size of the snapshot that is specified by the SnapshotId parameter.', example='100'),
      snapshotId?: string(name='SnapshotId', description='The ID of the snapshot that you want to use to create data disks. If you specify this parameter, the Size parameter is ignored. The size of the disk is the same as the size of the specified snapshot.

If you specify a snapshot created on or before July 15, 2013, the operation fails and the system returns InvalidSnapshot.TooOld.', example='s-snapshot****'),
    }
  ](name='DataDisks', description='Details of the data disks.'),
  dedicatedHostId?: string(name='DedicatedHostId', description='The ID of the dedicated host on which you want to create the ECS instance. You cannot create preemptible instances on dedicated hosts. If you specify the DedicatedHostId parameter, the SpotStrategy and SpotPriceLimit parameters are ignored.

You can call the DescribeDedicatedHosts operation to query dedicated host IDs.', example='dh-bp67acfmxazb4p****'),
  deploymentSetId?: string(name='DeploymentSetId', description='The ID of the deployment set to which the ECS instance belongs.', example='ds-bp13v7bjnj9gis****'),
  hostName?: string(name='HostName', description='The hostname of the ECS instance. The hostname cannot start or end with a period (.) or a hyphen (-). The hostname cannot contain consecutive periods (.) or hyphens (-). Naming conventions for different types of instances:

*   Windows instances: The hostname must be 2 to 15 characters in length, and can contain letters, digits, and hyphens (-). The hostname cannot contain periods (.) or contain only digits.
*   Other instances such as Linux instances: The hostname must be 2 to 64 characters in length. You can use periods (.) to separate a hostname into multiple segments. Each segment can contain letters, digits, and hyphens (-).', example='hos****'),
  hpcClusterId?: string(name='HpcClusterId', description='The ID of the Elastic High Performance Computing (E-HPC) cluster to which the ECS instance belongs.', example='hpc-clusterid'),
  imageFamily?: string(name='ImageFamily', description='The name of the image family. You can specify this parameter to obtain the latest custom images that are available in the specified image family. The images are used to create instances. If the ImageId parameter is specified, you cannot specify the ImageFamily parameter.', example='hangzhou-daily-update'),
  imageId?: string(name='ImageId', description='The ID of the image that is used by Auto Scaling to automatically create instances.

> If the image that is specified in the scaling configuration contains system disks and data disks, the data that is stored in the data disks is cleared after you modify the image.', example='centos6u5_64_20G_aliaegis_2014****.vhd'),
  imageName?: string(name='ImageName', description='The name of the image. Each image name must be unique in a region. If you specify the ImageId parameter, the ImageName parameter is ignored.

You cannot use the ImageName parameter to specify Alibaba Cloud Marketplace images.', example='suse11sp3_64_20G_aliaegis_2015****.vhd'),
  instanceDescription?: string(name='InstanceDescription', description='The description of the ECS instance. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.', example='Test instance.'),
  instanceName?: string(name='InstanceName', description='The name of the ECS instance that is automatically created based on the scaling configuration.', example='inst****'),
  instancePatternInfos?: [ 
    {
      architectures?: [ string ](name='Architectures', description='The architectures of the instance types. Valid values:

*   X86: x86 architecture.
*   Heterogeneous: heterogeneous architecture, such as GPUs and FPGAs.
*   BareMetal: ECS Bare Metal Instance architecture.
*   Arm: ARM architecture.
*   SuperComputeCluster: Super Computing Cluster architecture.

By default, all values are selected.'),
      burstablePerformance?: string(name='BurstablePerformance', description='Specifies whether to include burstable instance types. Valid values:

*   Exclude: excludes burstable instance types.
*   Include: includes burstable instance types.
*   Required: includes only burstable instance types.

Default value: Include.', example='Include'),
      cores?: int32(name='Cores', description='The number of vCPUs that is specified for an instance type in the intelligent configuration mode. This parameter is used to filter the available instance types that meet the specified criteria. For more information, see [Instance family](~~25378~~).

Take note of the following items:

*   The InstancePatternInfos parameter is available only for scaling groups that reside in VPCs.
*   You must specify the InstancePatternInfos, Cores, and Memory parameters at the same time.
*   If you specify an instance type by using the InstanceType or InstanceTypes parameter, Auto Scaling preferentially uses the instance type that is specified by the InstanceType or InstanceTypes parameter for scale-out activities. If the specified instance type does not have sufficient inventory, Auto Scaling creates instances of the instance type that is specified by the InstancePatternInfos parameter based on the price in ascending order.', example='2'),
      excludedInstanceTypes?: [ string ](name='ExcludedInstanceTypes', description='The instance types that you want to filter out. You can use wildcard characters such as an asterisk (\\*) to filter out a single instance type or an instance family. Example:

*   ecs.c6.large: The ecs.c6.large instance type is filtered out.
*   ecs.c6.\\*: The c6 instance family is filtered out.'),
      instanceFamilyLevel?: string(name='InstanceFamilyLevel', description='The level of the instance type, which is used to filter the instance types that meet the specified criteria. This parameter takes effect only if you set the `CostOptimization` parameter to true. Valid values:

*   EntryLevel: shared instance type. Instances of this level are the most cost-effective but may not provide stable computing performance in a consistent manner. Instances of this level are suitable for business scenarios in which the CPU utilization is low. For more information, see [Shared instance families](~~108489~~).
*   EnterpriseLevel: Instances of this level provide stable performance and dedicated resources, and are suitable for business scenarios that require high stability. For more information, see [Instance family](~~25378~~).
*   CreditEntryLevel: This value is valid only for burstable instances. CPU credits are used to ensure computing performance. Instances of this level are suitable for scenarios in which the CPU utilization is low but may fluctuate in specific cases. For more information, see the [Overview](~~59977~~) topic of burstable instances.', example='EnterpriseLevel'),
      maxPrice?: float(name='MaxPrice', description='The maximum hourly price for a pay-as-you-go instance or a preemptible instance in the intelligent configuration mode. This parameter is used to filter the available instance types that meet the specified criteria.

> If you set the SpotStrategy parameter to SpotWithPriceLimit, you must specify the MaxPrice parameter. In other cases, you do not need to specify the MaxPrice parameter.', example='2'),
      memory?: float(name='Memory', description='The memory size that is specified for an instance type in the intelligent configuration mode. Unit: GiB. This parameter is used to filter the available instance types that meet the specified criteria.', example='4'),
    }
  ](name='InstancePatternInfos', description='Information about the intelligent configuration settings, which determines the available instance types.'),
  instanceTypeOverrides?: [ 
    {
      instanceType?: string(name='InstanceType', description='The instance type. If you want to specify the weight of the instance type in the scaling configuration, you must specify the InstanceType and WeightedCapacity parameters at the same time.

You can use the InstanceType parameter to specify 1 to 10 instance types. You can use the WeightedCapacity parameter to specify weights of instance types.

> You cannot specify the InstanceType and InstanceTypes parameters at the same time.

You can specify instance types that are available for purchase as the values of the InstanceType parameter.', example='ecs.c5.xlarge'),
      weightedCapacity?: int32(name='WeightedCapacity', description='The weight of the instance type. The weight of the instance type indicates the capacity of the instance of the specified instance type in the scaling group. If you want Auto Scaling to scale instances based on the instance type weight, you must specify the WeightedCapacity parameter after you specify the InstanceType parameter.

A higher weight specifies that a smaller number of instances of the specified instance type are required to meet the expected capacity.

Performance metrics, such as the number of vCPUs and the memory size of each instance type, may vary. You can specify different weights for different instance types based on your business requirements.

Example:

*   Current capacity: 0
*   Expected capacity: 6
*   Capacity of ecs.c5.xlarge: 4

To meet the expected capacity requirement, Auto Scaling must create and add two ecs.c5.xlarge instances.

> The capacity of the scaling group cannot exceed the sum of the maximum number of instances that is specified by the MaxSize parameter and the maximum weight of the instance types.

Valid values of the WeightedCapacity parameter: 1 to 500.', example='4'),
    }
  ](name='InstanceTypeOverrides', description='Information about the instance type.'),
  instanceTypes?: [ string ](name='InstanceTypes', description='The instance types. If you specify this parameter, the InstanceType parameter is ignored. You can specify up to 10 instance types in a scaling configuration.

The first instance type has the highest priority. The priority decreases based on the specified order of instance types. Auto Scaling creates instances based on the priorities of the instance types. If Auto Scaling cannot create instances of the instance type that has the highest priority, Auto Scaling creates instances of the instance type that has the next highest priority.'),
  internetChargeType?: string(name='InternetChargeType', description='The billing method for network usage. Valid values:

*   PayByBandwidth: You are charged for the maximum available bandwidth that is specified by the InternetMaxBandwidthOut parameter.
*   PayByTraffic: You are charged for the actual traffic that is used. The InternetMaxBandwidthOut parameter specifies only the maximum available bandwidth.', example='PayByBandwidth'),
  internetMaxBandwidthOut?: int32(name='InternetMaxBandwidthOut', description='The maximum outbound public bandwidth. Unit: Mbit/s. Valid values:

*   0 to 100 if you set the InternetChargeType parameter to PayByBandwidth. If you leave this parameter empty, this parameter is automatically set to 0.
*   0 to 100 if you set the InternetChargeType parameter to PayByTraffic. If you leave this parameter empty, an error will be reported.', example='50'),
  ioOptimized?: string(name='IoOptimized', description='Specifies whether to create an I/O optimized instance. Valid values:

*   none: does not create an I/O optimized instance.
*   optimized: creates an I/O optimized instance.', example='none'),
  ipv6AddressCount?: int32(name='Ipv6AddressCount', description='The number of randomly generated IPv6 addresses that you want to allocate to the elastic network interface (ENI).', example='1'),
  keyPairName?: string(name='KeyPairName', description='The name of the key pair that is used to log on to the ECS instance.

*   Windows instances do not use this parameter.
*   By default, the username and password authentication method is disabled for Linux instances.', example='KeyPair_Name'),
  loadBalancerWeight?: int32(name='LoadBalancerWeight', description='The weight of the ECS instance as a backend server. Valid values: 1 to 100.', example='50'),
  memory?: int32(name='Memory', description='The size of the memory. Unit: GiB.

You can specify the number of vCPUs and the memory size to determine the range of instance types. For example, you can set the Cpu parameter to 2 and the Memory parameter to 16 to specify the instance types that have 2 vCPUs and 16 GiB of memory. Auto Scaling determines the available instance types based on factors such as I/O optimization requirements and zones. Then, Auto Scaling preferentially creates instances of the instance type that is provided at the lowest price.

> You can specify the Cpu and Memory parameters to determine the range of instance types only if the Scaling Policy parameter is set to Cost Optimization Policy and no instance type is specified in the scaling configuration.', example='16'),
  override?: boolean(name='Override', description='Specifies whether to overwrite existing data. Valid values:

*   true: overwrites existing data.
*   false: does not overwrite existing data.', example='true'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  passwordInherit?: boolean(name='PasswordInherit', description='Specifies whether to use the password that is preconfigured in the image. Before you use this parameter, make sure that a password is configured for the image.', example='false'),
  ramRoleName?: string(name='RamRoleName', description='The name of the RAM role that is associated with the ECS instance. The name is provided and maintained by Resource Access Management (RAM). You can call the ListRoles operation to query the available RAM roles. You can call the CreateRole operation to create RAM roles.', example='RamRoleTest'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the ECS instance belongs.', example='abcd1234abcd****'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  scalingConfigurationId?: string(name='ScalingConfigurationId', description='The ID of the scaling configuration that you want to modify.', example='asc-bp16har3jpj6fjbx****'),
  scalingConfigurationName?: string(name='ScalingConfigurationName', description='The name of the scaling configuration. The name must be 2 to 64 characters in length and can contain letters, digits, underscores (\\_), hyphens (-), and periods (.). It must start with a letter or a digit.

The name of the scaling configuration must be unique within a scaling group in a region. If you do not specify the ScalingConfigurationName parameter, the scaling configuration ID is used.', example='test-modify'),
  schedulerOptionsShrink?: string(name='SchedulerOptions', description='The options of the scheduler.'),
  securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group with which the ECS instance is associated. The ECS instances that are associated with the same security group can access each other.', example='sg-F876F****'),
  securityGroupIds?: [ string ](name='SecurityGroupIds', description='The IDs of the security groups.'),
  spotDuration?: int32(name='SpotDuration', description='The retention period of the preemptible instance. Unit: hours. Valid values: 0, 1, 2, 3, 4, 5, and 6.

*   The following retention periods are available in invitational preview: 2, 3, 4, 5, and 6 hours. If you want to set this parameter to one of these values, submit a ticket.
*   If you set this parameter to 0, no retention period is specified for the preemptible instance.', example='1'),
  spotInterruptionBehavior?: string(name='SpotInterruptionBehavior', description='The interruption event of the preemptible instance. Default value: Terminate. Set the value to Terminate, which specifies that the preemptible instance is to be released.', example='Terminate'),
  spotPriceLimits?: [ 
    {
      instanceType?: string(name='InstanceType', description='The instance type of the preemptible instance. This parameter takes effect only if you set the SpotStrategy parameter to SpotWithPriceLimit.', example='ecs.g6.large'),
      priceLimit?: float(name='PriceLimit', description='The price limit of the preemptible instance. This parameter takes effect only if you set the SpotStrategy parameter to SpotWithPriceLimit.', example='0.125'),
    }
  ](name='SpotPriceLimits', description='Information about the instance types of preemptible instances.'),
  spotStrategy?: string(name='SpotStrategy', description='The preemption policy that you want to apply to pay-as-you-go instances and preemptible instances. Valid values:

*   NoSpot: The instance is created as a pay-as-you-go instance.
*   SpotWithPriceLimit: The instance is a preemptible instance that has a user-defined maximum hourly price.
*   SpotAsPriceGo: The instance is created as a preemptible instance for which the market price at the time of purchase is automatically used as the bid price.', example='NoSpot'),
  systemDiskCategories?: [ string ](name='SystemDiskCategories', description='The categories of the system disks. You can specify one to four disk categories in a scaling configuration. The first disk category that is specified in a scaling configuration has the highest priority. The priority deceases based on the specified order of disk categories. If Auto Scaling cannot create instances by using the disk category that has the highest priority, Auto Scaling creates instances by using the disk category that has the next highest priority. Valid values:

*   cloud: basic disk.
*   cloud_efficiency: ultra disk.
*   cloud_ssd: standard SSD.
*   cloud_essd: ESSD.

> You cannot specify the SystemDiskCategories and `SystemDisk.Category` parameters at the same time.'),
  tags?: string(name='Tags', description='The tags of the ECS instance. The tags must be specified in the key-value pair format. You can specify up to 20 tags. When you specify tag keys and tag values, take note of the following items:

*   A tag key can be up to 64 characters in length. The key cannot start with `acs:` or `aliyun`, and cannot contain `http://` or `https://`. You cannot specify an empty string as a tag key.
*   A tag value can be up to 128 characters in length. The value cannot start with `acs:` or `aliyun`, and cannot contain `http://` or `https://`. You can specify an empty string as a tag value.', example='{"key1":"value1","key2":"value2", ... "key5":"value5"}'),
  tenancy?: string(name='Tenancy', description='Specifies whether to create the instance on a dedicated host. Valid values:

*   default: does not create the instance on a dedicated host.
*   host: creates the instance on a dedicated host. If you do not specify the DedicatedHostId parameter, Alibaba Cloud selects a dedicated host for the instance that you want to create.', example='default'),
  userData?: string(name='UserData', description='The user data of the ECS instance. The data must be encoded in Base64. The maximum size of the data before encoding is 16 KB.', example='echo hello ecs!'),
  zoneId?: string(name='ZoneId', description='The zone ID of the ECS instance.', example='cn-hangzhou-g'),
}

model ModifyScalingConfigurationResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3****'),
}

model ModifyScalingConfigurationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyScalingConfigurationResponseBody(name='body'),
}

/**
  * If you want to change the name of a scaling configuration in a scaling group, make sure that the new name is unique within the scaling group.
  *
  * @param tmpReq ModifyScalingConfigurationRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ModifyScalingConfigurationResponse
 */
async function modifyScalingConfigurationWithOptions(tmpReq: ModifyScalingConfigurationRequest, runtime: Util.RuntimeOptions): ModifyScalingConfigurationResponse {
  Util.validateModel(tmpReq);
  var request = new ModifyScalingConfigurationShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.schedulerOptions)) {
    request.schedulerOptionsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.schedulerOptions, 'SchedulerOptions', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.affinity)) {
    query['Affinity'] = request.affinity;
  }
  if (!Util.isUnset(request.cpu)) {
    query['Cpu'] = request.cpu;
  }
  if (!Util.isUnset(request.creditSpecification)) {
    query['CreditSpecification'] = request.creditSpecification;
  }
  if (!Util.isUnset(request.dataDisks)) {
    query['DataDisks'] = request.dataDisks;
  }
  if (!Util.isUnset(request.dedicatedHostId)) {
    query['DedicatedHostId'] = request.dedicatedHostId;
  }
  if (!Util.isUnset(request.deploymentSetId)) {
    query['DeploymentSetId'] = request.deploymentSetId;
  }
  if (!Util.isUnset(request.hostName)) {
    query['HostName'] = request.hostName;
  }
  if (!Util.isUnset(request.hpcClusterId)) {
    query['HpcClusterId'] = request.hpcClusterId;
  }
  if (!Util.isUnset(request.imageFamily)) {
    query['ImageFamily'] = request.imageFamily;
  }
  if (!Util.isUnset(request.imageId)) {
    query['ImageId'] = request.imageId;
  }
  if (!Util.isUnset(request.imageName)) {
    query['ImageName'] = request.imageName;
  }
  if (!Util.isUnset(request.instanceDescription)) {
    query['InstanceDescription'] = request.instanceDescription;
  }
  if (!Util.isUnset(request.instanceName)) {
    query['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.instancePatternInfos)) {
    query['InstancePatternInfos'] = request.instancePatternInfos;
  }
  if (!Util.isUnset(request.instanceTypeOverrides)) {
    query['InstanceTypeOverrides'] = request.instanceTypeOverrides;
  }
  if (!Util.isUnset(request.instanceTypes)) {
    query['InstanceTypes'] = request.instanceTypes;
  }
  if (!Util.isUnset(request.internetChargeType)) {
    query['InternetChargeType'] = request.internetChargeType;
  }
  if (!Util.isUnset(request.internetMaxBandwidthOut)) {
    query['InternetMaxBandwidthOut'] = request.internetMaxBandwidthOut;
  }
  if (!Util.isUnset(request.ioOptimized)) {
    query['IoOptimized'] = request.ioOptimized;
  }
  if (!Util.isUnset(request.ipv6AddressCount)) {
    query['Ipv6AddressCount'] = request.ipv6AddressCount;
  }
  if (!Util.isUnset(request.keyPairName)) {
    query['KeyPairName'] = request.keyPairName;
  }
  if (!Util.isUnset(request.loadBalancerWeight)) {
    query['LoadBalancerWeight'] = request.loadBalancerWeight;
  }
  if (!Util.isUnset(request.memory)) {
    query['Memory'] = request.memory;
  }
  if (!Util.isUnset(request.override)) {
    query['Override'] = request.override;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.passwordInherit)) {
    query['PasswordInherit'] = request.passwordInherit;
  }
  if (!Util.isUnset(request.ramRoleName)) {
    query['RamRoleName'] = request.ramRoleName;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.scalingConfigurationId)) {
    query['ScalingConfigurationId'] = request.scalingConfigurationId;
  }
  if (!Util.isUnset(request.scalingConfigurationName)) {
    query['ScalingConfigurationName'] = request.scalingConfigurationName;
  }
  if (!Util.isUnset(request.schedulerOptionsShrink)) {
    query['SchedulerOptions'] = request.schedulerOptionsShrink;
  }
  if (!Util.isUnset(request.securityGroupId)) {
    query['SecurityGroupId'] = request.securityGroupId;
  }
  if (!Util.isUnset(request.securityGroupIds)) {
    query['SecurityGroupIds'] = request.securityGroupIds;
  }
  if (!Util.isUnset(request.spotDuration)) {
    query['SpotDuration'] = request.spotDuration;
  }
  if (!Util.isUnset(request.spotInterruptionBehavior)) {
    query['SpotInterruptionBehavior'] = request.spotInterruptionBehavior;
  }
  if (!Util.isUnset(request.spotPriceLimits)) {
    query['SpotPriceLimits'] = request.spotPriceLimits;
  }
  if (!Util.isUnset(request.spotStrategy)) {
    query['SpotStrategy'] = request.spotStrategy;
  }
  if (!Util.isUnset(request.systemDiskCategories)) {
    query['SystemDiskCategories'] = request.systemDiskCategories;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  if (!Util.isUnset(request.tenancy)) {
    query['Tenancy'] = request.tenancy;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  if (!Util.isUnset(request.privatePoolOptions)) {
    query['PrivatePoolOptions'] = request.privatePoolOptions;
  }
  if (!Util.isUnset(request.systemDisk)) {
    query['SystemDisk'] = request.systemDisk;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyScalingConfiguration',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * If you want to change the name of a scaling configuration in a scaling group, make sure that the new name is unique within the scaling group.
  *
  * @param request ModifyScalingConfigurationRequest
  * @return ModifyScalingConfigurationResponse
 */
async function modifyScalingConfiguration(request: ModifyScalingConfigurationRequest): ModifyScalingConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyScalingConfigurationWithOptions(request, runtime);
}

model ModifyScalingGroupRequest {
  activeScalingConfigurationId?: string(name='ActiveScalingConfigurationId', description='The health check mode of the scaling group. Valid values:

*   NONE: Auto Scaling does not perform health checks on instances in the scaling group.
*   ECS: Auto Scaling performs health checks on ECS instances in the scaling group.', example='asc-bp17pelvl720x5ub****'),
  allocationStrategy?: string(name='AllocationStrategy', description='The allocation policy of preemptible instances. You can use this parameter to individually specify the allocation policy of preemptible instances. This parameter takes effect only when you set the `MultiAZPolicy` parameter to `COMPOSABLE`. Valid values:

*   priority: Auto Scaling selects instance types based on the specified order to create the required number of preemptible instances.
*   lowestPrice: Auto Scaling selects instance types that have the lowest unit price of vCPUs to create the required number of preemptible instances.

Default value: priority.', example='priority'),
  azBalance?: boolean(name='AzBalance', description='The allocation policy. Auto Scaling selects instance types based on the allocation policy to create the required number of instances. The policy can be applied to pay-as-you-go instances and preemptible instances at the same time. This parameter takes effect only when you set the MultiAZPolicy parameter to COMPOSABLE. Valid values:

*   priority: Auto Scaling selects instance types based on the specified order to create the required number of instances.
*   lowestPrice: Auto Scaling selects instance types that have the lowest unit price of vCPUs to create the required number of instances.

Default value: priority.', example='false'),
  compensateWithOnDemand?: boolean(name='CompensateWithOnDemand', description='The number of instance types that you specify. Auto Scaling creates preemptible instances of multiple instance types that are provided at the lowest price. Valid values: 0 to 10.

If you set the `MultiAZPolicy` parameter to `COMPOSABLE` Policy, the default value is 2.', example='true'),
  customPolicyARN?: string(name='CustomPolicyARN', description='The ID of the request.', example='acs:fc:cn-zhangjiakou:16145688****:services/ess_custom_terminate_policy.LATEST/functions/ess_custom_terminate_policy_name'),
  defaultCooldown?: int32(name='DefaultCooldown', description='The policy that is used to remove ECS instances from the scaling group. Valid values:

*   OldestInstance: removes ECS instances that are added at the earliest point in time to the scaling group.
*   NewestInstance: removes ECS instances that are most recently added to the scaling group.
*   OldestScalingConfiguration: removes ECS instances that are created based on the earliest scaling configuration.', example='600'),
  desiredCapacity?: int32(name='DesiredCapacity', description='Specifies whether to enable deletion protection for the scaling group. Valid values:

*   true: enables deletion protection for the scaling group. This way, the scaling group cannot be deleted.
*   false: disables deletion protection for the scaling group.', example='5'),
  groupDeletionProtection?: boolean(name='GroupDeletionProtection', description='The scaling policy for the multi-zone scaling group that contains ECS instances. Valid values:

*   PRIORITY: ECS instances are scaled based on the vSwitch priority. The first vSwitch specified by using the VSwitchIds parameter has the highest priority. Auto Scaling preferentially scales instances in the zone where the vSwitch that has the highest priority resides. If the scaling fails, Auto Scaling scales instances in the zone where the vSwitch that has the next highest priority resides.
*   COST_OPTIMIZED: During a scale-out activity, Auto Scaling preferentially creates ECS instances of the instance type that has the lowest unit price of vCPU. During a scale-in activity, Auto Scaling preferentially removes ECS instances of the instance types that have the highest unit price of vCPU. Auto Scaling preferentially creates preemptible instances when preemptible instance types are specified in the scaling configuration. You can use the `CompensateWithOnDemand` parameter to specify whether to automatically create pay-as-you-go instances when Auto Scaling fails to create preemptible instances.

> The `COST_OPTIMIZED` setting takes effect only when multiple instance types are specified or at least one instance type is specified for preemptible instances.

*   BALANCE: ECS instances are evenly distributed across zones that are specified in the scaling group. If ECS instances are unevenly distributed among zones due to insufficient resources, you can call the RebalanceInstance operation to evenly distribute the instances among the zones.
*   COMPOSABLE: You can flexibly combine the preceding policies based on your business requirements.', example='true'),
  healthCheckType?: string(name='HealthCheckType', description='The ID of the launch template that is used by Auto Scaling to create instances.', example='ECS'),
  launchTemplateId?: string(name='LaunchTemplateId', description='The version number of the launch template. Valid values:

*   A fixed template version number.
*   Default: The default template version is always used.
*   Latest: The latest template version is always used.', example='lt-m5e3ofjr1zn1aw7****'),
  launchTemplateOverrides?: [ 
    {
      instanceType?: string(name='InstanceType', description='The weight of the instance type. The weight specifies the capacity of a single instance of the specified instance type in the scaling group. If you want Auto Scaling to scale instances in the scaling group based on the weighted capacity of instances, you must specify the WeightedCapacity parameter after you specify the InstanceType parameter.

A higher weight specifies that a smaller number of instances of the specified instance type are required to meet the expected capacity.

Performance metrics, such as the number of vCPUs and the memory size of each instance type, may vary. You can specify different weights for different instance types based on your business requirements.

Example:

*   Current capacity: 0
*   Expected capacity: 6
*   Capacity of ecs.c5.xlarge: 4

To meet the expected capacity requirement, Auto Scaling must create and add two ecs.c5.xlarge instances.

> The capacity of the scaling group cannot exceed the sum of the maximum number of instances that is specified by the MaxSize parameter and the maximum weight of the instance type.

Valid values of the WeightedCapacity parameter: 1 to 500.', example='ecs.c5.xlarge'),
      spotPriceLimit?: float(name='SpotPriceLimit'),
      weightedCapacity?: int32(name='WeightedCapacity', description='The maximum life span of the instance in the scaling group. Unit: seconds.

Valid values: 86400 to Integer.maxValue. ``You can also set this parameter to 0. A value of 0 indicates that the instance has an unlimited life span in the scaling group.

Default value: null.

> You cannot specify this parameter for scaling groups that manage elastic container instances or scaling groups whose ScalingPolicy is set to recycle.', example='4'),
    }
  ](name='LaunchTemplateOverrides', description='Details of the instance types that are specified in the extended configurations of the launch template.'),
  launchTemplateVersion?: string(name='LaunchTemplateVersion', description='The minimum number of pay-as-you-go instances that must be included in the scaling group. Valid values: 0 to 1000. If the number of pay-as-you-go instances is less than the value of this parameter, Auto Scaling preferentially creates pay-as-you-go instances.

If you set the `MultiAZPolicy` parameter to `COMPOSABLE` Policy, the default value is 0.', example='Default'),
  maxInstanceLifetime?: int32(name='MaxInstanceLifetime', description='Specifies whether to evenly distribute instances in the scaling group across zones. This parameter takes effect only when you set the `MultiAZPolicy` parameter to `COMPOSABLE`. Valid values:

*   true
*   false

Default value: false.', example='null'),
  maxSize?: int32(name='MaxSize', description='The default cooldown time of the scaling group. This parameter takes effect only for scaling groups that have simple scaling rules. Valid values: 0 to 86400. Unit: seconds. During the cooldown time, Auto Scaling executes only scaling activities that are triggered by event-triggered tasks associated with CloudMonitor.', example='99'),
  minSize?: int32(name='MinSize', description='The maximum number of ECS instances in the scaling group. When the number of ECS instances in the scaling group is greater than the value of the MaxSize parameter, Auto Scaling automatically removes ECS instances from the scaling group until the number of instances is equal to the value of the MaxSize parameter.

The value range of the MaxSize parameter varies based on the instance quota. You can go to [Quota Center](https://quotas.console.aliyun.com/products/ess/quotas) to check the quota of **instances that can be included in a scaling group**.

For example, if the quota of instances that can be included in a scaling group is 2000, the valid values of the MaxSize parameter range from 0 to 2000.', example='1'),
  multiAZPolicy?: string(name='MultiAZPolicy', description='The IDs of vSwitches.

This parameter takes effect only when the network type of the scaling group is virtual private cloud (VPC). The specified vSwitches and the scaling group must reside in the same VPC.

The vSwitches can reside in different zones. The vSwitches are sorted in ascending order. The first vSwitch specified by using the VSwitchIds parameter has the highest priority. If Auto Scaling fails to create ECS instances in the zone where the vSwitch that has the highest priority resides, Auto Scaling creates ECS instances in the zone where the vSwitch that has the next highest priority resides.', example='PRIORITY'),
  onDemandBaseCapacity?: int32(name='OnDemandBaseCapacity', description='The expected percentage of pay-as-you-go instances in the excess instances when the minimum number of pay-as-you-go instances reaches the requirement. Valid values: 0 to 100.

If you set the `MultiAZPolicy` parameter to `COMPOSABLE` Policy, the default value is 100.', example='30'),
  onDemandPercentageAboveBaseCapacity?: int32(name='OnDemandPercentageAboveBaseCapacity', description='Specifies whether to supplement preemptible instances. If this parameter is set to true, Auto Scaling creates an instance to replace a preemptible instance when Auto Scaling receives the system message that the preemptible instance is to be reclaimed.', example='20'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  removalPolicies?: [ string ](name='RemovalPolicies', description='The policy that is used to remove ECS instances from the scaling group. Valid values:

*   OldestInstance: removes ECS instances that are added at the earliest point in time to the scaling group.
*   NewestInstance: removes ECS instances that are most recently added to the scaling group.
*   OldestScalingConfiguration: removes ECS instances that are created based on the earliest scaling configuration.'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  scalingGroupId?: string(name='ScalingGroupId', description='The name of the scaling group. The name of each scaling group must be unique in a region. The name must be 2 to 64 characters in length and can contain letters, digits, underscores (\\_), hyphens (-), and periods (.). The name must start with a letter or a digit.', example='asg-bp1ffogfdauy0jw0****'),
  scalingGroupName?: string(name='ScalingGroupName', description='The minimum number of ECS instances in the scaling group. When the number of ECS instances in the scaling group is less than the value of the MinSize parameter, Auto Scaling automatically creates ECS instances and adds the instances to the scaling group until the number of instances is equal to the value of the MinSize parameter.

> The value of the MinSize parameter must be less than or equal to the value of the MaxSize parameter.', example='scalinggroup****'),
  spotAllocationStrategy?: string(name='SpotAllocationStrategy', description='The ARN of the custom scaling policy (Function). This parameter takes effect only when you specify CustomPolicy as the first step of the instance removal policy.', example='lowestPrice'),
  spotInstancePools?: int32(name='SpotInstancePools', description='The expected number of ECS instances in the scaling group. Auto Scaling automatically maintains the specified expected number of ECS instances. The expected number cannot be greater than the value of the MaxSize parameter and cannot be less than the value of the MinSize parameter.', example='5'),
  spotInstanceRemedy?: boolean(name='SpotInstanceRemedy', description='Specifies whether to automatically create pay-as-you-go instances to meet the requirements on the number of ECS instances in the scaling group when the number of preemptible instances cannot be reached due to reasons such as costs and insufficient resources. This parameter takes effect only if you set the MultiAZPolicy parameter in the CreateScalingGroup operation to COST_OPTIMIZED. Valid values:

*   true
*   false', example='true'),
  vSwitchIds?: [ string ](name='VSwitchIds', description='The IDs of vSwitches.

This parameter takes effect only when the network type of the scaling group is VPC. The specified vSwitches and the scaling group must reside in the same VPC.

The vSwitches can reside in different zones. The vSwitches are sorted in ascending order. The first vSwitch specified by using the VSwitchIds parameter has the highest priority. If Auto Scaling fails to create ECS instances in the zone where the vSwitch that has the highest priority resides, Auto Scaling creates ECS instances in the zone where the vSwitch that has the next highest priority resides.'),
}

model ModifyScalingGroupResponseBody = {
  requestId?: string(name='RequestId', description='auditing', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3****'),
}

model ModifyScalingGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyScalingGroupResponseBody(name='body'),
}

/**
  * Modifies a scaling group.
  *
  * @param request ModifyScalingGroupRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ModifyScalingGroupResponse
 */
async function modifyScalingGroupWithOptions(request: ModifyScalingGroupRequest, runtime: Util.RuntimeOptions): ModifyScalingGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.activeScalingConfigurationId)) {
    query['ActiveScalingConfigurationId'] = request.activeScalingConfigurationId;
  }
  if (!Util.isUnset(request.allocationStrategy)) {
    query['AllocationStrategy'] = request.allocationStrategy;
  }
  if (!Util.isUnset(request.azBalance)) {
    query['AzBalance'] = request.azBalance;
  }
  if (!Util.isUnset(request.compensateWithOnDemand)) {
    query['CompensateWithOnDemand'] = request.compensateWithOnDemand;
  }
  if (!Util.isUnset(request.customPolicyARN)) {
    query['CustomPolicyARN'] = request.customPolicyARN;
  }
  if (!Util.isUnset(request.defaultCooldown)) {
    query['DefaultCooldown'] = request.defaultCooldown;
  }
  if (!Util.isUnset(request.desiredCapacity)) {
    query['DesiredCapacity'] = request.desiredCapacity;
  }
  if (!Util.isUnset(request.groupDeletionProtection)) {
    query['GroupDeletionProtection'] = request.groupDeletionProtection;
  }
  if (!Util.isUnset(request.healthCheckType)) {
    query['HealthCheckType'] = request.healthCheckType;
  }
  if (!Util.isUnset(request.launchTemplateId)) {
    query['LaunchTemplateId'] = request.launchTemplateId;
  }
  if (!Util.isUnset(request.launchTemplateOverrides)) {
    query['LaunchTemplateOverrides'] = request.launchTemplateOverrides;
  }
  if (!Util.isUnset(request.launchTemplateVersion)) {
    query['LaunchTemplateVersion'] = request.launchTemplateVersion;
  }
  if (!Util.isUnset(request.maxInstanceLifetime)) {
    query['MaxInstanceLifetime'] = request.maxInstanceLifetime;
  }
  if (!Util.isUnset(request.maxSize)) {
    query['MaxSize'] = request.maxSize;
  }
  if (!Util.isUnset(request.minSize)) {
    query['MinSize'] = request.minSize;
  }
  if (!Util.isUnset(request.multiAZPolicy)) {
    query['MultiAZPolicy'] = request.multiAZPolicy;
  }
  if (!Util.isUnset(request.onDemandBaseCapacity)) {
    query['OnDemandBaseCapacity'] = request.onDemandBaseCapacity;
  }
  if (!Util.isUnset(request.onDemandPercentageAboveBaseCapacity)) {
    query['OnDemandPercentageAboveBaseCapacity'] = request.onDemandPercentageAboveBaseCapacity;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.removalPolicies)) {
    query['RemovalPolicies'] = request.removalPolicies;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.scalingGroupId)) {
    query['ScalingGroupId'] = request.scalingGroupId;
  }
  if (!Util.isUnset(request.scalingGroupName)) {
    query['ScalingGroupName'] = request.scalingGroupName;
  }
  if (!Util.isUnset(request.spotAllocationStrategy)) {
    query['SpotAllocationStrategy'] = request.spotAllocationStrategy;
  }
  if (!Util.isUnset(request.spotInstancePools)) {
    query['SpotInstancePools'] = request.spotInstancePools;
  }
  if (!Util.isUnset(request.spotInstanceRemedy)) {
    query['SpotInstanceRemedy'] = request.spotInstanceRemedy;
  }
  if (!Util.isUnset(request.vSwitchIds)) {
    query['VSwitchIds'] = request.vSwitchIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyScalingGroup',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Modifies a scaling group.
  *
  * @param request ModifyScalingGroupRequest
  * @return ModifyScalingGroupResponse
 */
async function modifyScalingGroup(request: ModifyScalingGroupRequest): ModifyScalingGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyScalingGroupWithOptions(request, runtime);
}

model ModifyScalingRuleRequest {
  adjustmentType?: string(name='AdjustmentType', description='The target value specified in the scaling rule. This parameter is required when the ScalingRuleType parameter is set to SimpleScalingRule or StepScalingRule. The number of ECS instances that are scaled in a single scaling activity cannot exceed 1,000.

*   Valid values if you set the AdjustmentType parameter to QuantityChangeInCapacity: -1000 to 1000.
*   Valid values if you set the AdjustmentType parameter to PercentChangeInCapacity: -100 to 10000.
*   Valid values if you set the AdjustmentType parameter to TotalCapacity: 0 to 2000.', example='QuantityChangeInCapacity'),
  adjustmentValue?: int32(name='AdjustmentValue', description='The warmup period of an instance. This parameter is available only if you set the ScalingRuleType parameter to TargetTrackingScalingRule or PredictiveScalingRule. Auto Scaling adds ECS instances that are in the warmup state to a scaling group but does not report monitoring data to CloudMonitor during the warmup period.

> Auto Scaling calculates the number of ECS instances that need to be scaled. ECS instances in the warmup state are not counted towards the current capacity of the scaling group.

Valid values: 0 to 86400. Unit: seconds.', example='100'),
  cooldown?: int32(name='Cooldown', description='The minimum number of instances that must be scaled when the AdjustmentType parameter is set to PercentChangeInCapacity. This parameter takes effect only if you set the ScalingRuleType parameter to SimpleScalingRule or StepScalingRule.', example='60'),
  disableScaleIn?: boolean(name='DisableScaleIn', description='The number of consecutive times that the event-triggered task created for scale-in activities must meet the threshold conditions before an alert is triggered. After a target tracking scaling rule is created, an event-triggered task is automatically created and then associated with the target tracking scaling rule.', example='true'),
  estimatedInstanceWarmup?: int32(name='EstimatedInstanceWarmup', description='The predefined metric that you want to monitor. This parameter is required only if you set the ScalingRuleType parameter to TargetTrackingScalingRule or PredictiveScalingRule.

Valid values if you set the ScalingRuleType parameter to TargetTrackingScalingRule:

*   CpuUtilization: the average CPU utilization
*   ClassicInternetRx: the average inbound Internet traffic over the classic network
*   ClassicInternetTx: the average outbound Internet traffic over the classic network
*   VpcInternetRx: the average inbound Internet traffic over the virtual private cloud (VPC)
*   VpcInternetTx: the average outbound Internet traffic over the VPC
*   IntranetRx: the average inbound traffic over the internal network
*   IntranetTx: the average outbound traffic over the internal network

Valid values if you set the ScalingRuleType parameter to PredictiveScalingRule:

*   CpuUtilization: the average CPU utilization
*   IntranetRx: the average inbound traffic over the internal network
*   IntranetTx: the average outbound traffic over the internal network', example='60'),
  initialMaxSize?: int32(name='InitialMaxSize', description='Details of the step adjustments.', example='100'),
  metricName?: string(name='MetricName', description='The target value. This parameter is available only if you set the ScalingRuleType parameter to TargetTrackingScalingRule or PredictiveScalingRule. The value must be greater than 0 and can have up to three decimal places.', example='CpuUtilization'),
  minAdjustmentMagnitude?: int32(name='MinAdjustmentMagnitude', description='The adjustment method of the scaling rule. This is required when the ScalingRuleType parameter is set to SimpleScalingRule or StepScalingRule. Valid values:

*   QuantityChangeInCapacity: adds the specified number of ECS instances to or removes the specified number of ECS instances from the scaling group.
*   PercentChangeInCapacity: adds the specified percentage of ECS instances to or removes the specified percentage of ECS instances from the scaling group.
*   TotalCapacity: adjusts the number of ECS instances in the scaling group to the specified number.', example='1'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  predictiveScalingMode?: string(name='PredictiveScalingMode', description='Specifies which one of the initial maximum capacity and the predicted value can be used as the maximum value for prediction tasks. Valid values:

*   MaxOverridePredictiveValue: uses the initial maximum capacity as the maximum value for prediction tasks if the predicted value is greater than the initial maximum capacity.
*   PredictiveValueOverrideMax: uses the predicted value as the maximum value for prediction tasks when the predicted value is greater than the initial maximum capacity.
*   PredictiveValueOverrideMaxWithBuffer: increases the predicted value by a percentage that is specified by the PredictiveValueBuffer parameter. If the predicted value that is increased by the percentage is greater than the initial maximum capacity, the increased value is used as the maximum value for prediction tasks.', example='PredictAndScale'),
  predictiveTaskBufferTime?: int32(name='PredictiveTaskBufferTime', description='The maximum number of ECS instances in the scaling group. If you specify this parameter, you must also specify the PredictiveValueBehavior parameter.', example='30'),
  predictiveValueBehavior?: string(name='PredictiveValueBehavior', description='The percentage of the increment to the predicted value when the PredictiveValueBehavior parameter is set to PredictiveValueOverrideMaxWithBuffer. If the predicted value increased by this percentage is greater than the initial maximum capacity, the increased value is used as the maximum value for prediction tasks. Valid values: 0 to 100.', example='MaxOverridePredictiveValue'),
  predictiveValueBuffer?: int32(name='PredictiveValueBuffer', description='The amount of buffer time before the prediction task is executed. By default, all prediction tasks that are automatically created for a predictive scaling rule are executed on the hour. You can specify an amount of buffer time for resource preparation before the prediction tasks are executed. Valid values: 0 to 60.', example='50'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  scaleInEvaluationCount?: int32(name='ScaleInEvaluationCount', description='The number of consecutive times that the event-triggered task created for scale-out activities must meet the threshold conditions before an alert is triggered. After a target tracking scaling rule is created, an event-triggered task is automatically created and then associated with the target tracking scaling rule.', example='15'),
  scaleOutEvaluationCount?: int32(name='ScaleOutEvaluationCount', description='The mode of the predictive scaling rule. Valid values:

*   PredictAndScale: produces predictions and creates prediction tasks.
*   PredictOnly: produces predictions but does not create prediction tasks.', example='3'),
  scalingRuleId?: string(name='ScalingRuleId', description='The name of the scaling rule. The name must be 2 to 64 characters in length, and can contain letters, digits, underscores (\\_), hyphens (-), and periods (.). The name must start with a letter or a digit. The name of a scaling rule must be unique in the scaling group to which the scaling rule belongs and within an Alibaba Cloud account.', example='asr-bp1dvirgwkoowxk7****'),
  scalingRuleName?: string(name='ScalingRuleName', description='The cooldown time of the scaling rule. This parameter is available only if you set the ScalingRuleType parameter to SimpleScalingRule.

Valid values: 0 to 86400. Unit: seconds.', example='scalingrule****'),
  stepAdjustments?: [ 
    {
      metricIntervalLowerBound?: float(name='MetricIntervalLowerBound', description='The ID of the request.', example='1.0'),
      metricIntervalUpperBound?: float(name='MetricIntervalUpperBound', description='The number of ECS instances that you want to scale in a step adjustment. This parameter is available only if you set the ScalingRuleType parameter to StepScalingRule.', example='5.0'),
      scalingAdjustment?: int32(name='ScalingAdjustment', description='The lower limit that is specified in a step adjustment. This parameter is available only if you set the ScalingRuleType parameter to StepScalingRule. Valid values: -9.999999E18 to 9.999999E18.', example='1'),
    }
  ](name='StepAdjustments', description='Details of the step adjustments.'),
  targetValue?: float(name='TargetValue', description='Specifies whether to disable scale-in. This parameter is available only if you set the ScalingRuleType parameter to TargetTrackingScalingRule.', example='0.125'),
}

model ModifyScalingRuleResponseBody = {
  requestId?: string(name='RequestId', description='4454', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3****'),
}

model ModifyScalingRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyScalingRuleResponseBody(name='body'),
}

async function modifyScalingRuleWithOptions(request: ModifyScalingRuleRequest, runtime: Util.RuntimeOptions): ModifyScalingRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.adjustmentType)) {
    query['AdjustmentType'] = request.adjustmentType;
  }
  if (!Util.isUnset(request.adjustmentValue)) {
    query['AdjustmentValue'] = request.adjustmentValue;
  }
  if (!Util.isUnset(request.cooldown)) {
    query['Cooldown'] = request.cooldown;
  }
  if (!Util.isUnset(request.disableScaleIn)) {
    query['DisableScaleIn'] = request.disableScaleIn;
  }
  if (!Util.isUnset(request.estimatedInstanceWarmup)) {
    query['EstimatedInstanceWarmup'] = request.estimatedInstanceWarmup;
  }
  if (!Util.isUnset(request.initialMaxSize)) {
    query['InitialMaxSize'] = request.initialMaxSize;
  }
  if (!Util.isUnset(request.metricName)) {
    query['MetricName'] = request.metricName;
  }
  if (!Util.isUnset(request.minAdjustmentMagnitude)) {
    query['MinAdjustmentMagnitude'] = request.minAdjustmentMagnitude;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.predictiveScalingMode)) {
    query['PredictiveScalingMode'] = request.predictiveScalingMode;
  }
  if (!Util.isUnset(request.predictiveTaskBufferTime)) {
    query['PredictiveTaskBufferTime'] = request.predictiveTaskBufferTime;
  }
  if (!Util.isUnset(request.predictiveValueBehavior)) {
    query['PredictiveValueBehavior'] = request.predictiveValueBehavior;
  }
  if (!Util.isUnset(request.predictiveValueBuffer)) {
    query['PredictiveValueBuffer'] = request.predictiveValueBuffer;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.scaleInEvaluationCount)) {
    query['ScaleInEvaluationCount'] = request.scaleInEvaluationCount;
  }
  if (!Util.isUnset(request.scaleOutEvaluationCount)) {
    query['ScaleOutEvaluationCount'] = request.scaleOutEvaluationCount;
  }
  if (!Util.isUnset(request.scalingRuleId)) {
    query['ScalingRuleId'] = request.scalingRuleId;
  }
  if (!Util.isUnset(request.scalingRuleName)) {
    query['ScalingRuleName'] = request.scalingRuleName;
  }
  if (!Util.isUnset(request.stepAdjustments)) {
    query['StepAdjustments'] = request.stepAdjustments;
  }
  if (!Util.isUnset(request.targetValue)) {
    query['TargetValue'] = request.targetValue;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyScalingRule',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyScalingRule(request: ModifyScalingRuleRequest): ModifyScalingRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyScalingRuleWithOptions(request, runtime);
}

model ModifyScheduledTaskRequest {
  description?: string(name='Description', description='The scaling rule that you want to execute when the scheduled task is triggered. Specify the unique identifier of the scaling rule. If you specify the `ScheduledAction` parameter, you must select an existing scaling rule for the scheduled task.

> You cannot specify the `ScheduledAction` and `ScalingGroupId` parameters at the same time.', example='Test scheduled task.'),
  desiredCapacity?: int32(name='DesiredCapacity', description='The ID of the scaling group whose number of instances must be modified when the scheduled task is triggered. If you specify the `ScalingGroupId` parameter for a scheduled task, you must specify the minimum, maximum, or expected numbers of instances for a scaling group in the scheduled task. That is, you must specify at least one of the `MinValue`, `MaxValue`, and `DesiredCapacity` parameters.

> You cannot specify the `ScheduledAction` and `ScalingGroupId` parameters at the same time.', example='10'),
  launchExpirationTime?: int32(name='LaunchExpirationTime', description='The minimum number of instances in the scaling group if you specify the ScalingGroupId parameter.', example='600'),
  launchTime?: string(name='LaunchTime', description='The interval at which the scheduled task is repeated. Valid values:

*   Daily: The scheduled task is executed once every specified number of days.
*   Weekly: The scheduled task is executed on each specified day of the week.
*   Monthly: The scheduled task is executed on each specified day of the month.
*   Cron: The scheduled task is executed based on the specified cron expression.

After you modify the scheduled task, the values that you specify for the `RecurrenceType` and `RecurrenceValue` parameters must be valid at the same time.', example='2014-08-18T10:52Z'),
  maxValue?: int32(name='MaxValue', description='The expected number of instances in the scaling group if you specify the ScalingGroupId parameter.

> You must specify the `DesiredCapacity` parameter when you create a scaling group.', example='10'),
  minValue?: int32(name='MinValue', description='The maximum number of instances in the scaling group if you specify the ScalingGroupId parameter.', example='0'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  recurrenceEndTime?: string(name='RecurrenceEndTime', description='The point in time at which the scheduled task is triggered. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mmZ format. The time must be in UTC. You cannot enter a time point later than 90 days from the point in time at which the scheduled task is modified.

*   If you specify the `RecurrenceType` parameter, the task is repeatedly executed at the time point that is specified by the LaunchTime parameter.
*   If you do not specify the `RecurrenceType` parameter, the task is executed only once at the point in time that is specified by the LaunchTime parameter.', example='2014-08-20T16:55Z'),
  recurrenceType?: string(name='RecurrenceType', description='The number of recurrences of the scheduled task.

*   If you set the `RecurrenceType` parameter to `Daily`, you can specify only one value for this parameter. Valid values: 1 to 31.
*   If you set the `RecurrenceType` parameter to `Weekly`, you can specify multiple values for this parameter. Separate the values with commas (,). The values that correspond to Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, and Saturday are 0, 1, 2, 3, 4, 5, and 6.``
*   If you set the `RecurrenceType` parameter to `Monthly`, you can specify two values in the `A-B` format for this parameter. Valid values of A and B: 1 to 31. B must be greater than or equal to A.
*   If you set the `RecurrenceType` parameter to `Cron`, you can specify a cron expression. A cron expression is written in UTC time and consists of the following fields: minute, hour, day, month, and week. The expression can contain the letters L and W and the following wildcard characters: commas (,), question marks (?), hyphens (-), asterisks (\\*), number signs (#), and forward slashes (/).

After you modify the scheduled task, the values that you specify for the `RecurrenceType` and `RecurrenceValue` parameters must be valid at the same time.', example='Daily'),
  recurrenceValue?: string(name='RecurrenceValue', description='Specifies whether to enable the scheduled task. Valid values:

*   true
*   false

Default value: true.', example='2'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  scalingGroupId?: string(name='ScalingGroupId', description='The ID of the request.', example='asg-bp18p2yfxow2dloq****'),
  scheduledAction?: string(name='ScheduledAction', description='The end time of the scheduled task. Specify the time in the ISO 8601 standard in the YYYY-MM-DDThh:mmZ format. The time must be in UTC. You cannot enter a point in time that is later than 365 days from the point in time at which the scheduled task is modified.', example='ari:acs:ess:cn-hangzhou:14069264****:scalingrule/asr-bp12tcnol686y1ik****'),
  scheduledTaskId?: string(name='ScheduledTaskId', description='The name of the scheduled task. The name must be 2 to 64 characters in length, and can contain letters, digits, underscores (\\_), hyphens (-), and periods (.). It must start with a letter or a digit. The name of the scheduled task must be unique in the region and within the Alibaba Cloud account.', example='edRtShc57WGXdt8TlPbr****'),
  scheduledTaskName?: string(name='ScheduledTaskName', description='The description of the scheduled task. The description must be 2 to 200 characters in length.', example='scheduled****'),
  taskEnabled?: boolean(name='TaskEnabled', description='The time period during which the failed scheduled task is retried. Unit: seconds. Valid values: 0 to 1800.

Default value: 600.', example='true'),
}

model ModifyScheduledTaskResponseBody = {
  requestId?: string(name='RequestId', description='auditing', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3****'),
}

model ModifyScheduledTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyScheduledTaskResponseBody(name='body'),
}

/**
  * Modifies a scheduled task.
  *
  * @param request ModifyScheduledTaskRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ModifyScheduledTaskResponse
 */
async function modifyScheduledTaskWithOptions(request: ModifyScheduledTaskRequest, runtime: Util.RuntimeOptions): ModifyScheduledTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.desiredCapacity)) {
    query['DesiredCapacity'] = request.desiredCapacity;
  }
  if (!Util.isUnset(request.launchExpirationTime)) {
    query['LaunchExpirationTime'] = request.launchExpirationTime;
  }
  if (!Util.isUnset(request.launchTime)) {
    query['LaunchTime'] = request.launchTime;
  }
  if (!Util.isUnset(request.maxValue)) {
    query['MaxValue'] = request.maxValue;
  }
  if (!Util.isUnset(request.minValue)) {
    query['MinValue'] = request.minValue;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.recurrenceEndTime)) {
    query['RecurrenceEndTime'] = request.recurrenceEndTime;
  }
  if (!Util.isUnset(request.recurrenceType)) {
    query['RecurrenceType'] = request.recurrenceType;
  }
  if (!Util.isUnset(request.recurrenceValue)) {
    query['RecurrenceValue'] = request.recurrenceValue;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.scalingGroupId)) {
    query['ScalingGroupId'] = request.scalingGroupId;
  }
  if (!Util.isUnset(request.scheduledAction)) {
    query['ScheduledAction'] = request.scheduledAction;
  }
  if (!Util.isUnset(request.scheduledTaskId)) {
    query['ScheduledTaskId'] = request.scheduledTaskId;
  }
  if (!Util.isUnset(request.scheduledTaskName)) {
    query['ScheduledTaskName'] = request.scheduledTaskName;
  }
  if (!Util.isUnset(request.taskEnabled)) {
    query['TaskEnabled'] = request.taskEnabled;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyScheduledTask',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Modifies a scheduled task.
  *
  * @param request ModifyScheduledTaskRequest
  * @return ModifyScheduledTaskResponse
 */
async function modifyScheduledTask(request: ModifyScheduledTaskRequest): ModifyScheduledTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyScheduledTaskWithOptions(request, runtime);
}

model RebalanceInstancesRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The ID of the scaling activity.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  scalingGroupId?: string(name='ScalingGroupId', description='The region ID of the scaling group.', example='asg-bp18p2yfxow2dloq****'),
}

model RebalanceInstancesResponseBody = {
  requestId?: string(name='RequestId', description='auditing', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3****'),
  scalingActivityId?: string(name='ScalingActivityId', description='The ID of the request.', example='asa-kjgffgdfadah****'),
}

model RebalanceInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RebalanceInstancesResponseBody(name='body'),
}

/**
  * Rebalances Elastic Compute Service (ECS) instances in a multi-zone scaling group across zones.
  *
  * @param request RebalanceInstancesRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return RebalanceInstancesResponse
 */
async function rebalanceInstancesWithOptions(request: RebalanceInstancesRequest, runtime: Util.RuntimeOptions): RebalanceInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.scalingGroupId)) {
    query['ScalingGroupId'] = request.scalingGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RebalanceInstances',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Rebalances Elastic Compute Service (ECS) instances in a multi-zone scaling group across zones.
  *
  * @param request RebalanceInstancesRequest
  * @return RebalanceInstancesResponse
 */
async function rebalanceInstances(request: RebalanceInstancesRequest): RebalanceInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return rebalanceInstancesWithOptions(request, runtime);
}

model RecordLifecycleActionHeartbeatRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The ID of the request.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  heartbeatTimeout?: int32(name='heartbeatTimeout', description='The region ID of the scaling group.', example='600'),
  lifecycleActionToken?: string(name='lifecycleActionToken', description='The period of time before the lifecycle hook ends. Auto Scaling performs the specified action after the lifecycle hook ends. Valid values: 30 to 21600. Unit: seconds.

You can call this operation to prolong the length of a lifecycle hook. You can also call the CompleteLifecycleAction operation to end a lifecycle hook ahead of schedule.

Default value: 600.', example='F324B880-900E-4968-85DD-81691113****'),
  lifecycleHookId?: string(name='lifecycleHookId', description='The token of the lifecycle hook. You can obtain this token by using a Message Service (MNS) queue or an MNS topic that is specified for the lifecycle hook.', example='ash-bp1fxuqyi98w0aib****'),
}

model RecordLifecycleActionHeartbeatResponseBody = {
  requestId?: string(name='RequestId', description='auditing', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
}

model RecordLifecycleActionHeartbeatResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RecordLifecycleActionHeartbeatResponseBody(name='body'),
}

/**
  * Prolongs a lifecycle hook for Elastic Compute Service (ECS) instances.
  *
  * @param request RecordLifecycleActionHeartbeatRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return RecordLifecycleActionHeartbeatResponse
 */
async function recordLifecycleActionHeartbeatWithOptions(request: RecordLifecycleActionHeartbeatRequest, runtime: Util.RuntimeOptions): RecordLifecycleActionHeartbeatResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.heartbeatTimeout)) {
    query['heartbeatTimeout'] = request.heartbeatTimeout;
  }
  if (!Util.isUnset(request.lifecycleActionToken)) {
    query['lifecycleActionToken'] = request.lifecycleActionToken;
  }
  if (!Util.isUnset(request.lifecycleHookId)) {
    query['lifecycleHookId'] = request.lifecycleHookId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RecordLifecycleActionHeartbeat',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Prolongs a lifecycle hook for Elastic Compute Service (ECS) instances.
  *
  * @param request RecordLifecycleActionHeartbeatRequest
  * @return RecordLifecycleActionHeartbeatResponse
 */
async function recordLifecycleActionHeartbeat(request: RecordLifecycleActionHeartbeatRequest): RecordLifecycleActionHeartbeatResponse {
  var runtime = new Util.RuntimeOptions{};
  return recordLifecycleActionHeartbeatWithOptions(request, runtime);
}

model RemoveInstancesRequest {
  decreaseDesiredCapacity?: boolean(name='DecreaseDesiredCapacity', description='Specifies whether to adjust the expected number of ECS instances in the scaling group. Valid values:

*   true: After ECS instances are removed from the scaling group, the expected number of ECS instances in the scaling group decreases.
*   false: After ECS instances are removed from the scaling group, the expected number of ECS instances in the scaling group remains unchanged.

Default value: true.', example='true'),
  instanceIds?: [ string ](name='InstanceIds', description='The IDs of the ECS instances that you want to remove from the scaling group.'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID of the scaling group.', example='cn-qingdao'),
  removePolicy?: string(name='RemovePolicy', description='The action that you want Auto Scaling to perform after the ECS instance is removed from the scaling group. Valid values:

*   recycle: puts the ECS instance into economical mode.

    **

    **Note**This setting takes effect only if you set the ScalingPolicy parameter to recycle.

*   release: releases the ECS instance.

The ScalingPolicy parameter that you specify when you call the CreateScalingGroup operation specifies the reclaim mode of the scaling group. The RemovePolicy parameter that you specify when you call the RemoveInstances operation specifies the action to be performed on ECS instances after the ECS instances are removed. Example:

*   If you set both the ScalingPolicy parameter and the RemovePolicy parameter to recycle, the ECS instances are put into economical mode after the ECS instances are removed from the scaling group.
*   If you set the ScalingPolicy parameter to recycle and the RemovePolicy parameter to release, the ECS instances are released after the ECS instances are removed from the scaling group.
*   If you set the ScalingPolicy parameter to release and the RemovePolicy parameter to recycle, the ECS instances are released after the ECS instances are removed from the scaling group.
*   If you set both the ScalingPolicy parameter and the RemovePolicy parameter to release, the ECS instances are released after the ECS instances are removed from the scaling group.

Default value: release.', example='release'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  scalingGroupId?: string(name='ScalingGroupId', description='The ID of the scaling group.', example='asg-bp18p2yfxow2dloq****'),
}

model RemoveInstancesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  scalingActivityId?: string(name='ScalingActivityId', description='The ID of the scaling activity.', example='asa-bp175o6f6ego3r2j****'),
}

model RemoveInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveInstancesResponseBody(name='body'),
}

/**
  * *   Before you call this operation, make sure that the following requirements are met:
  *     *   The scaling group is in the Active state.
  *     *   No scaling activity is in progress within the scaling group.
  * > If no scaling activity is in progress within the scaling group, you can call the operation even within the cooldown period.
  * *   If an ECS instance is automatically created by Auto Scaling, or if an ECS instance is manually added to a scaling group and managed by the scaling group, the ECS instance is stopped in economical mode or is released after the instance is removed from the scaling group.
  * *   If an ECS instance is manually added to a scaling group and is not managed by the scaling group, the ECS instance is not stopped or released after the instance is removed from the scaling group.
  * *   If the difference between the number of existing ECS instances specified by the TotalCapacity parameter and the number of ECS instances that you call this operation to remove is less than the value of the MinSize parameter, the call fails.
  * A successful call only means that Auto Scaling accepts the request. The scaling activity may still fail. You can obtain the status of a scaling activity based on the value of the ScalingActivityId parameter in the response.
  *
  * @param request RemoveInstancesRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return RemoveInstancesResponse
 */
async function removeInstancesWithOptions(request: RemoveInstancesRequest, runtime: Util.RuntimeOptions): RemoveInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.decreaseDesiredCapacity)) {
    query['DecreaseDesiredCapacity'] = request.decreaseDesiredCapacity;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.removePolicy)) {
    query['RemovePolicy'] = request.removePolicy;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.scalingGroupId)) {
    query['ScalingGroupId'] = request.scalingGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemoveInstances',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   Before you call this operation, make sure that the following requirements are met:
  *     *   The scaling group is in the Active state.
  *     *   No scaling activity is in progress within the scaling group.
  * > If no scaling activity is in progress within the scaling group, you can call the operation even within the cooldown period.
  * *   If an ECS instance is automatically created by Auto Scaling, or if an ECS instance is manually added to a scaling group and managed by the scaling group, the ECS instance is stopped in economical mode or is released after the instance is removed from the scaling group.
  * *   If an ECS instance is manually added to a scaling group and is not managed by the scaling group, the ECS instance is not stopped or released after the instance is removed from the scaling group.
  * *   If the difference between the number of existing ECS instances specified by the TotalCapacity parameter and the number of ECS instances that you call this operation to remove is less than the value of the MinSize parameter, the call fails.
  * A successful call only means that Auto Scaling accepts the request. The scaling activity may still fail. You can obtain the status of a scaling activity based on the value of the ScalingActivityId parameter in the response.
  *
  * @param request RemoveInstancesRequest
  * @return RemoveInstancesResponse
 */
async function removeInstances(request: RemoveInstancesRequest): RemoveInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeInstancesWithOptions(request, runtime);
}

model ResumeProcessesRequest {
  clientToken?: string(name='ClientToken', description='Details of the processes that you want to resume.', example='123e4567-e89b-12d3-a456-42665544****'),
  ownerId?: long(name='OwnerId'),
  processes?: [ string ](name='Processes', description='The type of the process that you want to resume. Valid values:

*   ScaleIn
*   ScaleOut
*   HealthCheck
*   AlarmNotification
*   ScheduledAction

You can resume five processes of the preceding types at the same time. If you try to resume more than five processes at the same time, Auto Scaling automatically removes the duplicate processes.'),
  regionId?: string(name='RegionId', description='The ID of the request', example='cn-qingdao'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  scalingGroupId?: string(name='ScalingGroupId', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that the value is unique among different requests.

The token can only contain ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25965~~).', example='asg-bp15oubotmrq11xe****'),
}

model ResumeProcessesResponseBody = {
  requestId?: string(name='RequestId', description='auditing', example='E38EB733-D714-4658-8A5F-0688AB68****'),
}

model ResumeProcessesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ResumeProcessesResponseBody(name='body'),
}

async function resumeProcessesWithOptions(request: ResumeProcessesRequest, runtime: Util.RuntimeOptions): ResumeProcessesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.processes)) {
    query['Processes'] = request.processes;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.scalingGroupId)) {
    query['ScalingGroupId'] = request.scalingGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResumeProcesses',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function resumeProcesses(request: ResumeProcessesRequest): ResumeProcessesResponse {
  var runtime = new Util.RuntimeOptions{};
  return resumeProcessesWithOptions(request, runtime);
}

model ScaleWithAdjustmentRequest {
  adjustmentType?: string(name='AdjustmentType', description='The type of the scaling policy. Valid values:

*   QuantityChangeInCapacity: adds the specified number of ECS instances to or removes the specified number of ECS instances from the scaling group.
*   PercentChangeInCapacity: adds the specified percentage of ECS instances to or removes the specified percentage of ECS instances from the scaling group.
*   TotalCapacity: adjusts the number of ECS instances in the scaling group to a specified number.', example='QuantityChangeInCapacity'),
  adjustmentValue?: int32(name='AdjustmentValue', description='The number of instances in each adjustment. The number of ECS instances in each adjustment cannot exceed 1,000.

*   Valid values if you set the AdjustmentType parameter to QuantityChangeInCapacity: -1000 to 1000.
*   Valid values if you set the AdjustmentType parameter to PercentChangeInCapacity: -100 to 10000.
*   Valid values if you set the AdjustmentType parameter to TotalCapacity: 0 to 2000.', example='100'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that the value is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='123e4567-e89b-12d3-a456-42665544****'),
  minAdjustmentMagnitude?: int32(name='MinAdjustmentMagnitude', description='The minimum number of instances allowed in each adjustment. This parameter takes effect only if you set the `AdjustmentType` parameter to `PercentChangeInCapacity`.', example='1'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  scalingGroupId?: string(name='ScalingGroupId', description='The ID of the scaling group.', example='asg-j6c1o397427hyjdc****'),
  syncActivity?: boolean(name='SyncActivity', description='Specifies whether to trigger the scaling activity in a synchronous manner. This parameter takes effect only on scaling groups for which you specified an expected number of instances. Valid values:

*   true: triggers the scaling activity in a synchronous manner. The scaling activity is triggered at the time when the scaling rule is executed.
*   false: does not trigger the scaling activity in a synchronous manner. After you change the expected number of instances for the scaling group, Auto Scaling checks whether the total number of instances in the scaling group matches the new expected number of instances and determines whether to trigger the scaling activity based on the check result.

> For more information about the Expected Number of Instances feature, see [Expected number of instances](~~146231~~).

Default value: false.', example='false'),
}

model ScaleWithAdjustmentResponseBody = {
  activityType?: string(name='ActivityType', description='The type of scaling activity.

When the ActivityType is CapacityChange, it means that the scaling activity corresponding to the return value ScalingActivityId only modifies the expected number of instances of the scaling group, and does not perform scaling immediately. Scope of application: scaling groups of the expected number of instances.', example='CapacityChange'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3****'),
  scalingActivityId?: string(name='ScalingActivityId', description='The ID of the scaling activity.', example='asa-bp175o6f6ego3r2j****'),
}

model ScaleWithAdjustmentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ScaleWithAdjustmentResponseBody(name='body'),
}

/**
  * Compared with the ExecuteScalingRule operation, the ScaleWithAdjustment operation does not require a scaling rule to be created in advance. Before you call the ScaleWithAdjustment operation, take note of the following items:
  * *   The following conditions must be met:
  *     *   The scaling group is in the Active state.
  *     *   No scaling activities in the scaling group are in progress.
  * *   If no scaling activities in the scaling group are in progress, the operation can trigger scaling activities even before the cooldown time expires.
  * *   If the addition of a specified number of Elastic Compute Service (ECS) instances to a scaling group causes the total number of ECS instances in the scaling group to exceed the maximum number of instances allowed, Auto Scaling adds only a specific number of ECS instances to ensure that the total number of instances is equal to the maximum number of instances.
  * *   If the removal of a specified number of ECS instances from a scaling group causes the total number of ECS instances in the scaling group to drop below the minimum number of instances allowed, Auto Scaling removes only a specific number of ECS instances to ensure that the total number of instances is equal to the minimum number of instances.
  * A successful call indicates that Auto Scaling accepts the request. However, the scaling activity may still fail. You can obtain the status of a scaling activity by using the value of the `ScalingActivityId` parameter in the response.
  *
  * @param request ScaleWithAdjustmentRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ScaleWithAdjustmentResponse
 */
async function scaleWithAdjustmentWithOptions(request: ScaleWithAdjustmentRequest, runtime: Util.RuntimeOptions): ScaleWithAdjustmentResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.adjustmentType)) {
    query['AdjustmentType'] = request.adjustmentType;
  }
  if (!Util.isUnset(request.adjustmentValue)) {
    query['AdjustmentValue'] = request.adjustmentValue;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.minAdjustmentMagnitude)) {
    query['MinAdjustmentMagnitude'] = request.minAdjustmentMagnitude;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.scalingGroupId)) {
    query['ScalingGroupId'] = request.scalingGroupId;
  }
  if (!Util.isUnset(request.syncActivity)) {
    query['SyncActivity'] = request.syncActivity;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ScaleWithAdjustment',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Compared with the ExecuteScalingRule operation, the ScaleWithAdjustment operation does not require a scaling rule to be created in advance. Before you call the ScaleWithAdjustment operation, take note of the following items:
  * *   The following conditions must be met:
  *     *   The scaling group is in the Active state.
  *     *   No scaling activities in the scaling group are in progress.
  * *   If no scaling activities in the scaling group are in progress, the operation can trigger scaling activities even before the cooldown time expires.
  * *   If the addition of a specified number of Elastic Compute Service (ECS) instances to a scaling group causes the total number of ECS instances in the scaling group to exceed the maximum number of instances allowed, Auto Scaling adds only a specific number of ECS instances to ensure that the total number of instances is equal to the maximum number of instances.
  * *   If the removal of a specified number of ECS instances from a scaling group causes the total number of ECS instances in the scaling group to drop below the minimum number of instances allowed, Auto Scaling removes only a specific number of ECS instances to ensure that the total number of instances is equal to the minimum number of instances.
  * A successful call indicates that Auto Scaling accepts the request. However, the scaling activity may still fail. You can obtain the status of a scaling activity by using the value of the `ScalingActivityId` parameter in the response.
  *
  * @param request ScaleWithAdjustmentRequest
  * @return ScaleWithAdjustmentResponse
 */
async function scaleWithAdjustment(request: ScaleWithAdjustmentRequest): ScaleWithAdjustmentResponse {
  var runtime = new Util.RuntimeOptions{};
  return scaleWithAdjustmentWithOptions(request, runtime);
}

model SetGroupDeletionProtectionRequest {
  groupDeletionProtection?: boolean(name='GroupDeletionProtection', description='The ID of the scaling group.', example='true'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The ID of the request.', example='cn-qingdao'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  scalingGroupId?: string(name='ScalingGroupId', description='The region ID of the scaling group.', example='asg-bp1igpak5ft1flyp****'),
}

model SetGroupDeletionProtectionResponseBody = {
  requestId?: string(name='RequestId', description='auditing', example='CCC29E24-3AEC-4F2C-8A14-78B14FA738B7'),
}

model SetGroupDeletionProtectionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetGroupDeletionProtectionResponseBody(name='body'),
}

async function setGroupDeletionProtectionWithOptions(request: SetGroupDeletionProtectionRequest, runtime: Util.RuntimeOptions): SetGroupDeletionProtectionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupDeletionProtection)) {
    query['GroupDeletionProtection'] = request.groupDeletionProtection;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.scalingGroupId)) {
    query['ScalingGroupId'] = request.scalingGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetGroupDeletionProtection',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setGroupDeletionProtection(request: SetGroupDeletionProtectionRequest): SetGroupDeletionProtectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return setGroupDeletionProtectionWithOptions(request, runtime);
}

model SetInstanceHealthRequest {
  healthStatus?: string(name='HealthStatus', description='The ID of the request.', example='Healthy'),
  instanceId?: string(name='InstanceId', description='The health status of the ECS instance. Valid values:

*   Healthy
*   Unhealthy', example='i-bp1ap6bro51a7fsa****'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
}

model SetInstanceHealthResponseBody = {
  requestId?: string(name='RequestId', description='auditing', example='B755AE57-6093-43E4-938E-DEA422A9****'),
}

model SetInstanceHealthResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetInstanceHealthResponseBody(name='body'),
}

/**
  * Configures the health check feature for Elastic Compute Service (ECS) instances.
  *
  * @param request SetInstanceHealthRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return SetInstanceHealthResponse
 */
async function setInstanceHealthWithOptions(request: SetInstanceHealthRequest, runtime: Util.RuntimeOptions): SetInstanceHealthResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.healthStatus)) {
    query['HealthStatus'] = request.healthStatus;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetInstanceHealth',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Configures the health check feature for Elastic Compute Service (ECS) instances.
  *
  * @param request SetInstanceHealthRequest
  * @return SetInstanceHealthResponse
 */
async function setInstanceHealth(request: SetInstanceHealthRequest): SetInstanceHealthResponse {
  var runtime = new Util.RuntimeOptions{};
  return setInstanceHealthWithOptions(request, runtime);
}

model SetInstancesProtectionRequest {
  instanceIds?: [ string ](name='InstanceIds', description='The IDs of the ECS instances.'),
  ownerId?: long(name='OwnerId'),
  protectedFromScaleIn?: boolean(name='ProtectedFromScaleIn', description='The IDs of the ECS instances.', example='true'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  scalingGroupId?: string(name='ScalingGroupId', description='Specifies whether to put ECS instances into the Protected state. Auto Scaling does not remove ECS instances in the Protected state from scaling groups during scale-in activities.

*   true
*   false', example='asg-bp18p2yfxow2dloq****'),
}

model SetInstancesProtectionResponseBody = {
  requestId?: string(name='RequestId', description='auditing', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3****'),
}

model SetInstancesProtectionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetInstancesProtectionResponseBody(name='body'),
}

/**
  * Puts one or more Elastic Compute Service (ECS) instances into the Protected state.
  *
  * @param request SetInstancesProtectionRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return SetInstancesProtectionResponse
 */
async function setInstancesProtectionWithOptions(request: SetInstancesProtectionRequest, runtime: Util.RuntimeOptions): SetInstancesProtectionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.protectedFromScaleIn)) {
    query['ProtectedFromScaleIn'] = request.protectedFromScaleIn;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.scalingGroupId)) {
    query['ScalingGroupId'] = request.scalingGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetInstancesProtection',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Puts one or more Elastic Compute Service (ECS) instances into the Protected state.
  *
  * @param request SetInstancesProtectionRequest
  * @return SetInstancesProtectionResponse
 */
async function setInstancesProtection(request: SetInstancesProtectionRequest): SetInstancesProtectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return setInstancesProtectionWithOptions(request, runtime);
}

model SuspendProcessesRequest {
  clientToken?: string(name='ClientToken', description='The types of the processes that you want to suspend. Valid values:

*   scalein
*   scaleout
*   healthcheck
*   alarmnotification
*   scheduledaction

You can suspend five processes of the preceding types at the same time. If you try to suspend more than five processes at the same time, Auto Scaling automatically removes duplicate processes.', example='123e4567-e89b-12d3-a456-42665544****'),
  ownerId?: long(name='OwnerId'),
  processes?: [ string ](name='Processes', description='The types of the processes that you want to suspend. Valid values:

*   scalein
*   scaleout
*   healthcheck
*   alarmnotification
*   scheduledaction

You can suspend five processes of the preceding types at the same time. If you try to suspend more than five processes at the same time, Auto Scaling automatically removes duplicate processes.'),
  regionId?: string(name='RegionId', description='The ID of the request.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  scalingGroupId?: string(name='ScalingGroupId', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that the value is unique among different requests.

The token can only contain ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25965~~).', example='asg-bp15oubotmrq11xe****'),
}

model SuspendProcessesResponseBody = {
  requestId?: string(name='RequestId', description='auditing', example='3E2033F0-03B4-419D-BCE2-C2339DB51****'),
}

model SuspendProcessesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SuspendProcessesResponseBody(name='body'),
}

async function suspendProcessesWithOptions(request: SuspendProcessesRequest, runtime: Util.RuntimeOptions): SuspendProcessesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.processes)) {
    query['Processes'] = request.processes;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.scalingGroupId)) {
    query['ScalingGroupId'] = request.scalingGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SuspendProcesses',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function suspendProcesses(request: SuspendProcessesRequest): SuspendProcessesResponse {
  var runtime = new Util.RuntimeOptions{};
  return suspendProcessesWithOptions(request, runtime);
}

model TagResourcesRequest {
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The type of the Auto Scaling resource. Only scaling groups are supported. Set the value to scalinggroup.', example='cn-hangzhou'),
  resourceIds?: [ string ](name='ResourceIds', description='The ID of the resource.'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceType?: string(name='ResourceType', description='The ID of the resource.', example='scalinggroup'),
  tags?: [ 
    {
      key?: string(name='Key', description='The value of the tag that you want to add to the Auto Scaling resource.

You can specify empty strings as tag values. The tag value must be 0 to 128 characters in length and cannot contain `http://` or `https://`. The tag value cannot start with `acs:`.', example='TestKey'),
      propagate?: boolean(name='Propagate', description='The ID of the request.', example='false'),
      value?: string(name='Value', description='Specifies whether to propagate the tag that you want to add. Valid values:

*   true: propagates the tag only to instances that are newly created and does not propagate the tag to instances that are already running in the scaling group.
*   false: does not propagate the tag to any instances.

Default value: false.', example='TestValue'),
    }
  ](name='Tags', description='Details of the tags.'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='auditing', example='74C4E313-8570-479F-8791-DC25360D****'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResourcesWithOptions(request: TagResourcesRequest, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceIds)) {
    query['ResourceIds'] = request.resourceIds;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TagResources',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagResourcesWithOptions(request, runtime);
}

model UntagResourcesRequest {
  all?: boolean(name='All', description='The IDs of the Auto Scaling resources. You can specify 1 to 50 resource IDs.', example='false'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The type of the resource. Only scaling groups are supported. Set the value to scalinggroup.', example='cn-hangzhou'),
  resourceIds?: [ string ](name='ResourceIds', description='The IDs of the Auto Scaling resources. You can specify 1 to 50 resource IDs.'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceType?: string(name='ResourceType', description='Specifies whether to remove all tags from the Auto Scaling resource. This parameter takes effect only if you do not specify the `TagKeys` parameter. Valid values:

*   true: removes all tags from the Auto Scaling resource.
*   false: does not remove tags from the Auto Scaling resource.

Default value: false.', example='scalinggroup'),
  tagKeys?: [ string ](name='TagKeys', description='The keys of the tags that you want to remove from the Auto Scaling resource. You can specify 1 to 20 tag keys.'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='auditing', example='3AEBB1B9-5B13-4311-951F-C3C7FA2B****'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResourcesWithOptions(request: UntagResourcesRequest, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.all)) {
    query['All'] = request.all;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceIds)) {
    query['ResourceIds'] = request.resourceIds;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagKeys)) {
    query['TagKeys'] = request.tagKeys;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UntagResources',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return untagResourcesWithOptions(request, runtime);
}

model VerifyAuthenticationRequest {
  onlyCheck?: boolean(name='OnlyCheck'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  uid?: long(name='Uid'),
}

model VerifyAuthenticationResponseBody = {
  requestId?: string(name='RequestId'),
}

model VerifyAuthenticationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: VerifyAuthenticationResponseBody(name='body'),
}

async function verifyAuthenticationWithOptions(request: VerifyAuthenticationRequest, runtime: Util.RuntimeOptions): VerifyAuthenticationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.onlyCheck)) {
    query['OnlyCheck'] = request.onlyCheck;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.uid)) {
    query['Uid'] = request.uid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'VerifyAuthentication',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function verifyAuthentication(request: VerifyAuthenticationRequest): VerifyAuthenticationResponse {
  var runtime = new Util.RuntimeOptions{};
  return verifyAuthenticationWithOptions(request, runtime);
}

model VerifyUserRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model VerifyUserResponseBody = {
  requestId?: string(name='RequestId'),
}

model VerifyUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: VerifyUserResponseBody(name='body'),
}

async function verifyUserWithOptions(request: VerifyUserRequest, runtime: Util.RuntimeOptions): VerifyUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'VerifyUser',
    version = '2022-02-22',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function verifyUser(request: VerifyUserRequest): VerifyUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return verifyUserWithOptions(request, runtime);
}

