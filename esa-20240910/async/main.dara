/**
  *
  */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'ESA';
  @version = '2024-09-10';
  @endpointRule = '';
  @endpointMap = {
  };
}

function close(): void {
  @handler.close();
}

model WafBatchRuleShared {
  action?: string(name='Action'),
  actions?: {
    response?: {
      code?: int32(name='Code'),
      id?: long(name='Id'),
    }(name='Response'),
  }(name='Actions'),
  crossSiteId?: long(name='CrossSiteId'),
  expression?: string(name='Expression'),
  match?: WafRuleMatch2(name='Match'),
  mode?: string(name='Mode'),
  name?: string(name='Name'),
  target?: string(name='Target'),
}

model WafQuotaInteger {
  equal?: int32(name='Equal'),
  greaterThan?: int32(name='GreaterThan'),
  greaterThanOrEqual?: int32(name='GreaterThanOrEqual'),
  lessThan?: int32(name='LessThan'),
  lessThanOrEqual?: int32(name='LessThanOrEqual'),
}

model WafQuotaString {
  regexp?: string(name='Regexp'),
}

model WafRuleConfig {
  action?: string(name='Action'),
  actions?: {
    bypass?: {
      customRules?: [ long ](name='CustomRules'),
      regularRules?: [ long ](name='RegularRules'),
      regularTypes?: [ string ](name='RegularTypes'),
      skip?: string(name='Skip'),
      tags?: [ string ](name='Tags'),
    }(name='Bypass'),
    response?: {
      code?: int32(name='Code'),
      id?: long(name='Id'),
    }(name='Response'),
  }(name='Actions'),
  appPackage?: {
    packageSigns?: [ 
      {
        name?: string(name='Name'),
        sign?: string(name='Sign'),
      }
    ](name='PackageSigns'),
  }(name='AppPackage'),
  appSdk?: {
    customSign?: {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }(name='CustomSign'),
    customSignStatus?: string(name='CustomSignStatus'),
    featureAbnormal?: [ string ](name='FeatureAbnormal'),
  }(name='AppSdk'),
  expression?: string(name='Expression'),
  id?: long(name='Id'),
  managedGroupId?: long(name='ManagedGroupId'),
  managedList?: string(name='ManagedList'),
  managedRulesets?: [ 
    {
      action?: string(name='Action'),
      attackType?: int32(name='AttackType'),
      managedRules?: [ 
        {
          action?: string(name='Action'),
          id?: long(name='Id'),
          status?: string(name='Status'),
        }
      ](name='ManagedRules'),
      numberEnabled?: int32(name='NumberEnabled'),
      numberTotal?: int32(name='NumberTotal'),
      protectionLevel?: int32(name='ProtectionLevel'),
    }
  ](name='ManagedRulesets'),
  match?: WafRuleMatch(name='Match'),
  name?: string(name='Name'),
  rateLimit?: {
    characteristics?: WafRuleMatch2(name='Characteristics'),
    interval?: int32(name='Interval'),
    onHit?: boolean(name='OnHit'),
    TTL?: int32(name='TTL'),
    threshold?: {
      distinctManagedRules?: int32(name='DistinctManagedRules'),
      managedRulesBlocked?: int32(name='ManagedRulesBlocked'),
      request?: int32(name='Request'),
      responseStatus?: {
        code?: int32(name='Code'),
        count?: int32(name='Count'),
        ratio?: int32(name='Ratio'),
      }(name='ResponseStatus'),
      traffic?: string(name='Traffic'),
    }(name='Threshold'),
  }(name='RateLimit'),
  sigchl?: [ string ](name='Sigchl'),
  status?: string(name='Status'),
  timer?: WafTimer(name='Timer'),
  type?: string(name='Type'),
}

model WafRuleMatch {
  convertToLower?: boolean(name='ConvertToLower'),
  criteria?: [
    WafRuleMatch
  ](name='Criteria'),
  logic?: string(name='Logic'),
  matchOperator?: string(name='MatchOperator'),
  matchType?: string(name='MatchType'),
  matchValue?: any(name='MatchValue'),
  negate?: boolean(name='Negate'),
}

model WafRuleMatch2 {
  convertToLower?: boolean(name='ConvertToLower'),
  criteria?: [ 
    {
      convertToLower?: boolean(name='ConvertToLower'),
      criteria?: [ 
        {
          convertToLower?: boolean(name='ConvertToLower'),
          criteria?: [ 
            {
              convertToLower?: boolean(name='ConvertToLower'),
              matchOperator?: string(name='MatchOperator'),
              matchType?: string(name='MatchType'),
              matchValue?: any(name='MatchValue'),
              negate?: boolean(name='Negate'),
            }
          ](name='Criteria'),
          logic?: string(name='Logic'),
          matchOperator?: string(name='MatchOperator'),
          matchType?: string(name='MatchType'),
          matchValue?: any(name='MatchValue'),
          negate?: boolean(name='Negate'),
        }
      ](name='Criteria'),
      logic?: string(name='Logic'),
      matchOperator?: string(name='MatchOperator'),
      matchType?: string(name='MatchType'),
      matchValue?: any(name='MatchValue'),
      negate?: boolean(name='Negate'),
    }
  ](name='Criteria'),
  logic?: string(name='Logic'),
  matchOperator?: string(name='MatchOperator'),
  matchType?: string(name='MatchType'),
  matchValue?: any(name='MatchValue'),
  negate?: boolean(name='Negate'),
}

model WafSiteSettings {
  addBotProtectionHeaders?: {
    enable?: boolean(name='Enable'),
  }(name='AddBotProtectionHeaders'),
  addSecurityHeaders?: {
    enable?: boolean(name='Enable'),
  }(name='AddSecurityHeaders'),
  clientIpIdentifier?: {
    headers?: [ string ](name='Headers'),
    mode?: string(name='Mode'),
  }(name='ClientIpIdentifier'),
  securityLevel?: {
    value?: string(name='Value'),
  }(name='SecurityLevel'),
}

model WafTimer {
  periods?: [ 
    {
      end?: string(name='End'),
      start?: string(name='Start'),
    }
  ](name='Periods'),
  scopes?: string(name='Scopes'),
  weeklyPeriods?: [ 
    {
      dailyPeriods?: [ 
        {
          end?: string(name='End'),
          start?: string(name='Start'),
        }
      ](name='DailyPeriods'),
      days?: string(name='Days'),
    }
  ](name='WeeklyPeriods'),
  zone?: int32(name='Zone'),
}

model ActivateClientCertificateRequest {
  id: string(name='Id', description='The certificate ID, which can be obtained by calling the [ListClientCertificates](https://help.aliyun.com/document_detail/2852848.html) operation.

This parameter is required.', example='babaded901474b9693acf530e0fb****', position='Query'),
  siteId: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.

This parameter is required.', example='1234567890123', position='Query'),
}

model ActivateClientCertificateResponseBody = {
  id?: string(name='Id', description='The certificate ID.', example='babaded901474b9693acf530e0fb****'),
  requestId?: string(name='RequestId', description='The request ID.', example='0AEDAF20-4DDF-4165-8750-47FF9C1929C9'),
  siteId?: long(name='SiteId', description='The website ID.', example='1234567890123'),
  siteName?: string(name='SiteName', description='The website name.', example='example.com'),
}

model ActivateClientCertificateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ActivateClientCertificateResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ActivateClientCertificate  ActivateClientCertificateRequest
  * @return ActivateClientCertificateResponse
 */
async function activateClientCertificate(request: ActivateClientCertificateRequest): ActivateClientCertificateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ActivateClientCertificate', 'GET', '/', 'json', false, 'json', request);
}

model BatchCreateRecordsRequest {
  recordList: [ 
    {
      authConf?: {
        accessKey?: string(name='AccessKey'),
        authType?: string(name='AuthType'),
        region?: string(name='Region'),
        secretKey?: string(name='SecretKey'),
        version?: string(name='Version'),
      }(name='AuthConf'),
      bizName?: string(name='BizName', description='The business scenario of the record for acceleration. Valid values:

*   **image_video**
*   **api**
*   **web**', example='web'),
      data: {
        algorithm?: int32(name='Algorithm', description='The encryption algorithm used for the record. Valid values: 0 to 255. Applicable to CERT and SSHFP records.', example='0'),
        certificate?: string(name='Certificate', description='The public key of the certificate. Applicable to CERT, SMIMEA, and TLSA records.', example='dGVzdGFkYWxrcw=='),
        fingerprint?: string(name='Fingerprint', description='The public key fingerprint of the record. Applicable to SSHFP records.', example='abcdef1234567890'),
        flag?: int32(name='Flag', description='The Flag for a CAA record indicates its priority and how it is processed. Valid values: 0 to 255.', example='128'),
        keyTag?: int32(name='KeyTag', description='The public key identification for the record. Valid values: 0 to 65535. Applicable to CERT records.', example='0'),
        matchingType?: int32(name='MatchingType', description='The algorithm policy used to match or validate the certificate. Valid values: 0 to 255. Applicable to SMIMEA, and TLSA records.', example='0'),
        port?: int32(name='Port', description='The port of the record. Valid values: 0 to 65535. Exclusive to SRV records.', example='0'),
        priority?: int32(name='Priority', description='The priority of the record. Valid values: 0 to 65535. A smaller value indicates a higher priority. This parameter is required when you add MX, SRV, and URI records.', example='2'),
        selector?: int32(name='Selector', description='The type of certificate or public key. Valid values: 0 to 255. Applicable to SMIMEA and TLSA records.', example='0'),
        tag?: string(name='Tag', description='The tag of a CAA record, which indicates its specific type and purpose, such as issue, issuewild, and iodef.', example='issue'),
        type?: int32(name='Type', description='The certificate type of the record (in CERT records), or the public key type (in SSHFP records).', example='0'),
        usage?: int32(name='Usage', description='The usage identifier of the record. Valid values: 0 to 255. Applicable to SMIMEA and TLSA records.', example='0'),
        value?: string(name='Value', description='The record value or part of the record content. A/AAAA: the IP address being pointed to. CNAME: the target domain name being pointed to. MX: valid target mail server domain name. TXT: valid text string. CAA: valid certificate authority domain name. SRV: valid target host domain name. URI: valid URI string.', example='example.com'),
        weight?: int32(name='Weight', description='The weight of the record. Valid values: 0 to 65,535. Applicable to SRV and URI records.', example='0'),
      }(name='Data', description='The DNS information of the record. Enter fields based on the record type.

This parameter is required.', example='{
    "value":"2.2.2.2"
}'),
      proxied: boolean(name='Proxied', description='Specifies whether to proxy the record. Only CNAME and A/AAAA records can be proxied. Valid values:

*   **true**
*   **false**

This parameter is required.', example='true'),
      recordName: string(name='RecordName', description='The record name.

This parameter is required.', example='www.example.com'),
      sourceType?: string(name='SourceType', description='The origin type for the CNAME record. This parameter is required when you add a CNAME record. Valid values:

*   **OSS**: OSS bucket.
*   **S3**: S3 bucket.
*   **LB**: load balancer.
*   **OP**: origin pool.
*   **Domain**: domain name.

If you do not pass this parameter or if you leave its value empty, Domain is used by default.', example='OSS'),
      ttl: int32(name='Ttl', description='The TTL of the record. Unit: seconds. If the value is 1, the TTL of the record is determined by the system.

This parameter is required.', example='60'),
      type: string(name='Type', description='The DNS type of the record.

This parameter is required.', example='A/AAAA'),
    }
  ](name='RecordList', description='The list of DNS records to be created.

This parameter is required.', shrink='json', position='Query'),
  siteId: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.

This parameter is required.', example='1234567890123', position='Query'),
}

model BatchCreateRecordsResponseBody = {
  recordResultList?: {
    failed?: [ 
      {
        bizName?: string(name='BizName', description='The business scenario of the record for acceleration. Valid values:

*   **image_video**
*   **api**
*   **web**', example='web'),
        data?: {
          algorithm?: int32(name='Algorithm', description='The encryption algorithm used for the record. Valid values: 0 to 255. Applicable to CERT and SSHFP records.', example='0'),
          certificate?: string(name='Certificate', description='The public key of the certificate. Applicable to CERT, SMIMEA, and TLSA records.', example='dGVzdGFkYWxrcw=='),
          fingerprint?: string(name='Fingerprint', description='The public key fingerprint of the record. Applicable to SSHFP records.', example='abcdef1234567890'),
          flag?: int32(name='Flag', description='The flag bit of the record. Indicates its priority and handling method, used in CAA records.', example='128'),
          keyTag?: int32(name='KeyTag', description='The public key identification for the record. Valid values: 0 to 65535. Applicable to CERT records.', example='0'),
          matchingType?: int32(name='MatchingType', description='The algorithm policy used to match or validate the certificate. Valid values: 0 to 255. Applicable to SMIMEA and TLSA records.', example='RSA'),
          port?: int32(name='Port', description='The port number of the record, associated with the SRV record. Exclusive to SRV records.', example='0'),
          priority?: int32(name='Priority', description='The priority of the record. Valid values: 0 to 65535. A smaller value indicates a higher priority. Applicable to MX, SRV, and URI records.', example='10'),
          selector?: int32(name='Selector', description='The type of certificate or public key. Valid values: 0 to 255. Applicable to SMIMEA and TLSA records.', example='0'),
          tag?: string(name='Tag', description='Indicates its priority and handling method, used in CAA records.', example='issue'),
          type?: int32(name='Type', description='The certificate type of the record (in CERT records), or the public key type (in SSHFP records).', example='0'),
          usage?: int32(name='Usage', description='The usage identifier of the record. Valid values: 0 to 255. Applicable to SMIMEA and TLSA records.', example='0'),
          value?: string(name='Value', description='The record value or part of the record content. This value is returned when the record is A/AAAA, CNAME, NS, MX, TXT, CAA, SRV, or URI. It has different meanings based on types of records:

*   **A/AAAA**: the IP addresses. IP addresses are separated by commas (,). There is at least one IPv4 address.
*   **CNAME**: the mapped domain name.
*   **NS**: the nameservers for the domain name.
*   **MX**: a valid domain name of the target mail server.
*   **TXT**: a valid text string.
*   **CAA**: a valid domain name of the certificate authority.
*   **SRV**: a valid domain name of the target host.
*   **URI**: a valid URI string.', example='example.com'),
          weight?: int32(name='Weight', description='The weight of the record. Applicable to SRV and URI records.', example='0'),
        }(name='Data', description='The DNS information about the record, which contains various types of record values and their related attributes.', example='{"value":"2.2.2.2"}'),
        description?: string(name='Description', description='The result description.'),
        proxied?: boolean(name='Proxied', description='Indicates whether the record is proxied. Only CNAME and A/AAAA records can be proxied. Valid values:

*   **true**
*   **false**', example='true'),
        recordId?: long(name='RecordId', description='The record ID.', example='1234567890123'),
        recordName?: string(name='RecordName', description='The record name.', example='a.example.com'),
        recordType?: string(name='RecordType', description='The DNS type of the record, such as **A/AAAA, CNAME, and TXT**.', example='A/AAAA'),
        sourceType?: string(name='SourceType', description='The origin type of the CNAME record. This field is left empty for other types of records. The type of the origin server. Valid values:

*   **OSS**: OSS bucket.
*   **S3**: S3 bucket.
*   **LB**: load balancer.
*   **OP**: origin pool.
*   **Domain**: domain name.', example='OSS'),
        ttl?: int32(name='Ttl', description='The TTL of the record. Unit: seconds. If the value is 1, the TTL of the record is determined by the system.', example='60'),
      }
    ](name='Failed', description='The records that failed to be created.'),
    success?: [ 
      {
        bizName?: string(name='BizName', description='The business scenario of the record for acceleration. Valid values:

*   **image_video**
*   **api**
*   **web**', example='web'),
        data?: {
          algorithm?: int32(name='Algorithm', description='The encryption algorithm used for the record. Valid values: 0 to 255. Applicable to CERT and SSHFP records.', example='0'),
          certificate?: string(name='Certificate', description='The public key of the certificate. Applicable to CERT, SMIMEA, and TLSA records.', example='dGVzdGFkYWxrcw=='),
          fingerprint?: string(name='Fingerprint', description='The public key fingerprint of the record. Applicable to SSHFP records.', example='abcdef1234567890'),
          flag?: int32(name='Flag', description='The flag bit of the record. Indicates its priority and handling method, used in CAA records.', example='128'),
          keyTag?: int32(name='KeyTag', description='The public key identification for the record. Valid values: 0 to 65535. Applicable to CERT records.', example='0'),
          matchingType?: int32(name='MatchingType', description='The algorithm policy used to match or validate the certificate. Valid values: 0 to 255. Applicable to SMIMEA and TLSA records.', example='0'),
          port?: int32(name='Port', description='The port of the record. Valid values: 0 to 65535. Exclusive to SRV records.', example='0'),
          priority?: int32(name='Priority', description='The priority of the record. Valid values: 0 to 65535. A smaller value indicates a higher priority. Applicable to MX, SRV, and URI records.', example='10'),
          selector?: int32(name='Selector', description='The type of certificate or public key. Valid values: 0 to 255. Applicable to SMIMEA and TLSA records.', example='0'),
          tag?: string(name='Tag', description='The label of a CAA record, which indicates its specific type and purpose, such as issue, issuewild, and iodef.', example='issue'),
          type?: int32(name='Type', description='The certificate type of the record (in CERT records), or the public key type (in SSHFP records).', example='0'),
          usage?: int32(name='Usage', description='The usage identifier of the record. Valid values: 0 to 255. Applicable to SMIMEA and TLSA records.', example='0'),
          value?: string(name='Value', description='The record value or part of the record content. This value is returned when the record is A/AAAA, CNAME, NS, MX, TXT, CAA, SRV, or URI. It has different meanings based on types of records:

*   **A/AAAA**: the IP addresses. Multiple IPs are separated by commas (,). There is at least one IPv4 address.
*   **CNAME**: the mapped domain name.
*   **NS**: the nameservers for the domain name.
*   **MX**: a valid domain name of the target mail server.
*   **TXT**: a valid text string.
*   **CAA**: a valid domain name of the certificate authority.
*   **SRV**: a valid domain name of the target host.
*   **URI**: a valid URI string.', example='example.com'),
          weight?: int32(name='Weight', description='The weight of the record. Valid values: 0 to 65535. Applicable to SRV and URI records.', example='0'),
        }(name='Data', description='The DNS record information.', example='{"value":"1.1.1.1"}'),
        description?: string(name='Description', description='The result description.', example='success'),
        proxied?: boolean(name='Proxied', description='Indicates whether the record is proxied. Only CNAME and A/AAAA records can be proxied. Valid values:

*   **true**
*   **false**', example='true'),
        recordId?: long(name='RecordId', description='The record ID.', example='1234567890123'),
        recordName?: string(name='RecordName', description='The record name.', example='www.example.com'),
        recordType?: string(name='RecordType', description='The DNS type of the record, such as **A/AAAA, CNAME, and TXT**.', example='A/AAAA'),
        sourceType?: string(name='SourceType', description='The origin type of the CNAME record. This field is left empty for other types of records. The type of the origin server. Valid values:

*   **OSS**: OSS bucket.
*   **S3**: S3 bucket.
*   **LB**: load balancer.
*   **OP**: origin pool.
*   **Domain**: domain name.', example='OSS'),
        ttl?: int32(name='Ttl', description='The TTL of the record. Unit: seconds. If the value is 1, the TTL of the record is determined by the system.', example='60'),
      }
    ](name='Success', description='The records that have been created.'),
    totalCount?: int32(name='TotalCount', description='The total number of returned records.', example='20'),
  }(name='RecordResultList', description='The records that have been created and failed to be created.'),
  requestId?: string(name='RequestId', description='The request ID.', example='2430E05E-1340-5773-B5E1-B743929F46F2'),
}

model BatchCreateRecordsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchCreateRecordsResponseBody(name='body'),
}

/**
  * @description This operation allows you to create or update multiple DNS records at a time. It is suitable for managing a large number of DNS configurations. Supported record types include but are not limited to A/AAAA, CNAME, NS, MX, TXT, CAA, SRV, and URI. The operation allows you to configure the priority, flag, tag, and weight for DNS records. In addition, for specific types of records, such as CERT, SSHFP, SMIMEA, and TLSA, advanced settings such as certificate information and encryption algorithms are also supported.
  * Successful and failed records along with error messages are listed in the response.
  * @param request  the request parameters of BatchCreateRecords  BatchCreateRecordsRequest
  * @return BatchCreateRecordsResponse
 */
async function batchCreateRecords(request: BatchCreateRecordsRequest): BatchCreateRecordsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'BatchCreateRecords', 'POST', '/', 'json', false, 'json', request);
}

model BatchCreateWafRulesRequest {
  configs?: [
    WafRuleConfig
  ](name='Configs', description='The configurations of the rules.', shrink='json', position='Body'),
  phase?: string(name='Phase', description='The WAF rule category.', example='http_custom', position='Body'),
  shared?: WafBatchRuleShared(name='Shared', description='The configurations shared by multiple rules.', shrink='json', position='Body'),
  siteId?: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.', example='1', position='Query'),
  siteVersion?: int32(name='SiteVersion', description='The version of the website.', example='0', position='Query'),
}

model BatchCreateWafRulesResponseBody = {
  ids?: [ long ](name='Ids', description='The IDs of the WAF rules.[](~~2850237~~)'),
  requestId?: string(name='RequestId', description='The request ID.', example='36af3fcc-43d0-441c-86b1-428951dc8225'),
  rulesetId?: long(name='RulesetId', description='The ID of the WAF ruleset.[](~~2850233~~)', example='10000001'),
}

model BatchCreateWafRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchCreateWafRulesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of BatchCreateWafRules  BatchCreateWafRulesRequest
  * @return BatchCreateWafRulesResponse
 */
async function batchCreateWafRules(request: BatchCreateWafRulesRequest): BatchCreateWafRulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'BatchCreateWafRules', 'POST', '/', 'json', true, 'form', request);
}

model BatchDeleteKvRequest {
  keys: [ string ](name='Keys', description='The keys that you want to delete. You can delete a maximum of 10,000 key-value pairs at a time.

This parameter is required.', shrink='json', position='Body'),
  namespace: string(name='Namespace', description='The name of the namespace that you specify when you call the [CreateKvNamespace](https://help.aliyun.com/document_detail/2850317.html) operation.

This parameter is required.', example='test_namespace', position='Query'),
}

model BatchDeleteKvResponseBody = {
  failKeys?: [ string ](name='FailKeys', description='The keys that failed to be deleted.'),
  requestId?: string(name='RequestId', description='The request ID.', example='EEEBE525-F576-1196-8DAF-2D70CA3F4D2F'),
  successKeys?: [ string ](name='SuccessKeys', description='The keys that are deleted.'),
}

model BatchDeleteKvResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchDeleteKvResponseBody(name='body'),
}

/**
  * @param request  the request parameters of BatchDeleteKv  BatchDeleteKvRequest
  * @return BatchDeleteKvResponse
 */
async function batchDeleteKv(request: BatchDeleteKvRequest): BatchDeleteKvResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'BatchDeleteKv', 'POST', '/', 'json', true, 'form', request);
}

model BatchGetExpressionFieldsRequest {
  expressions?: [ 
    {
      expression?: string(name='Expression', description='The content of the regular expression.', example='ip.src eq 1.1.1.1'),
      id?: long(name='Id', description='The ID of the regular expression.', example='1'),
    }
  ](name='Expressions', description='The regular expressions.', example='http_bot', shrink='json', position='Body'),
  phase?: string(name='Phase', description='The WAF rule category.', example='http_bot', position='Body'),
  siteId?: long(name='SiteId', description='The website ID.', example='1', position='Query'),
}

model BatchGetExpressionFieldsResponseBody = {
  fields?: [ 
    {
      fields?: [ string ](name='Fields', description='The fields that match the regular expression.'),
      id?: string(name='Id', description='The ID of the regular expression, which corresponds to the expression ID in the request parameter.', example='1'),
    }
  ](name='Fields', description='The fields that match the regular expressions.'),
  requestId?: string(name='RequestId', description='The request ID.', example='36af3fcc-43d0-441c-86b1-428951dc8225'),
}

model BatchGetExpressionFieldsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchGetExpressionFieldsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of BatchGetExpressionFields  BatchGetExpressionFieldsRequest
  * @return BatchGetExpressionFieldsResponse
 */
async function batchGetExpressionFields(request: BatchGetExpressionFieldsRequest): BatchGetExpressionFieldsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'BatchGetExpressionFields', 'POST', '/', 'json', true, 'form', request);
}

model BatchPutKvRequest {
  kvList: [ 
    {
      expiration?: long(name='Expiration', description='The time when the key-value pair expires, which cannot be earlier than the current time. The value is a timestamp in seconds. If you specify both Expiration and ExpirationTtl, only ExpirationTtl takes effect.', example='1690081381'),
      expirationTtl?: long(name='ExpirationTtl', description='The relative expiration time. Unit: seconds. If you specify both Expiration and ExpirationTtl, only ExpirationTtl takes effect.', example='3600'),
      key: string(name='Key', description='The key name. The name can be up to 512 characters in length and cannot contain spaces or backslashes (\\\\).

This parameter is required.', example='test_key'),
      value: string(name='Value', description='The key content.

This parameter is required.', example='test_value'),
    }
  ](name='KvList', description='The key-value pairs that you want to configure at a time. The total size can be up to 2 MB (2 × 1000 × 1000).

This parameter is required.', shrink='json', position='Body'),
  namespace: string(name='Namespace', description='The name of the namespace that you specify when you call the [CreateKvNamespace](https://help.aliyun.com/document_detail/2850317.html) operation.

This parameter is required.', example='test_namespace', position='Query'),
}

model BatchPutKvResponseBody = {
  failKeys?: [ string ](name='FailKeys', description='The keys that failed to be written.'),
  requestId?: string(name='RequestId', description='The request ID.', example='EEEBE525-F576-1196-8DAF-2D70CA3F4D2F'),
  successKeys?: [ string ](name='SuccessKeys', description='The keys that were written.'),
}

model BatchPutKvResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchPutKvResponseBody(name='body'),
}

/**
  * @param request  the request parameters of BatchPutKv  BatchPutKvRequest
  * @return BatchPutKvResponse
 */
async function batchPutKv(request: BatchPutKvRequest): BatchPutKvResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'BatchPutKv', 'POST', '/', 'json', true, 'form', request);
}

model BatchUpdateWafRulesRequest {
  configs?: [
    WafRuleConfig
  ](name='Configs', description='The configurations of rules.', shrink='json', position='Body'),
  phase?: string(name='Phase', description='The WAF rule category.', example='http_custom', position='Body'),
  rulesetId?: long(name='RulesetId', description='The ID of the WAF ruleset, which can be obtained by calling the [ListWafRulesets](https://help.aliyun.com/document_detail/2850233.html) operation.', example='10000001', position='Body'),
  shared?: WafBatchRuleShared(name='Shared', description='The configurations shared by multiple rules.', shrink='json', position='Body'),
  siteId?: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.', example='1', position='Query'),
  siteVersion?: int32(name='SiteVersion', description='The version of the website.', example='0', position='Query'),
}

model BatchUpdateWafRulesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='36af3fcc-43d0-441c-86b1-428951dc8225'),
}

model BatchUpdateWafRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchUpdateWafRulesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of BatchUpdateWafRules  BatchUpdateWafRulesRequest
  * @return BatchUpdateWafRulesResponse
 */
async function batchUpdateWafRules(request: BatchUpdateWafRulesRequest): BatchUpdateWafRulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'BatchUpdateWafRules', 'POST', '/', 'json', true, 'form', request);
}

model BlockObjectRequest {
  content: [ string ](name='Content', description='The content to block.

This parameter is required.', shrink='json', position='Query'),
  extension?: string(name='Extension', description='The blocking period that you can extend. Set the value to 2year.', example='2year', position='Query'),
  maxage?: int32(name='Maxage', description='The period of time during which the URL is blocked. Unit: seconds. Specify this parameter if Type is set to block.', example='864000', minimum=600, maximum=864000, position='Query'),
  siteId: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.

This parameter is required.', example='BlockObject', position='Query'),
  type: string(name='Type', description='The type. Valid values:

*   **block**
*   **unblock**

This parameter is required.', example='block', position='Query'),
}

model BlockObjectResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='0AEDAF20-4DDF-4165-8750-47FF9C1929C9'),
  taskId?: string(name='TaskId', description='The blocking task ID.', example='15940956620'),
}

model BlockObjectResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BlockObjectResponseBody(name='body'),
}

/**
  * @param request  the request parameters of BlockObject  BlockObjectRequest
  * @return BlockObjectResponse
 */
async function blockObject(request: BlockObjectRequest): BlockObjectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'BlockObject', 'POST', '/', 'json', false, 'json', request);
}

model ChangeResourceGroupRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceGroupId: string(name='ResourceGroupId', description='The ID of the resource group to which you want to move the website.

This parameter is required.', example='rg-axxxxxx', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  siteId?: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.', example='123456****', position='Query'),
}

model ChangeResourceGroupResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='F8AA0364-0FDB-4AD5-AC74-D69FAB8924ED'),
}

model ChangeResourceGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ChangeResourceGroupResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ChangeResourceGroup  ChangeResourceGroupRequest
  * @return ChangeResourceGroupResponse
 */
async function changeResourceGroup(request: ChangeResourceGroupRequest): ChangeResourceGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ChangeResourceGroup', 'POST', '/', 'json', false, 'json', request);
}

model CheckSiteNameRequest {
  siteName: string(name='SiteName', description='The website name.

This parameter is required.', example='example.com', position='Query'),
}

model CheckSiteNameResponseBody = {
  description?: string(name='Description', description='The description of the verification result. Valid values:

*   **success**: The verification is successful.
*   **Site.AlreadyExist**: The website domain name has already been added.
*   **Site.InvalidName**: Invalid website domain name.
*   **Site.SubSiteUnavailable**: Subdomains are not allowed.
*   **Site.InternalError**: An internal error occurs.', example='success'),
  isSubSite?: boolean(name='IsSubSite', description='Indicates whether a subdomain is specified. Valid values:

*   **true**
*   **false**', example='false'),
  messeage?: string(name='Messeage', description='The verification message.'),
  passed?: boolean(name='Passed', description='Indicates whether the verification passed.

*   **true**
*   **false**', example='true'),
  requestId?: string(name='RequestId', description='The request ID.', example='CB1A380B-09F0-41BB-280B-72F8FD6DA2FE'),
}

model CheckSiteNameResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CheckSiteNameResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CheckSiteName  CheckSiteNameRequest
  * @return CheckSiteNameResponse
 */
async function checkSiteName(request: CheckSiteNameRequest): CheckSiteNameResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CheckSiteName', 'POST', '/', 'json', false, 'json', request);
}

model CheckSiteProjectNameRequest {
  projectName: string(name='ProjectName', description='The name of the real-time log delivery task.

This parameter is required.', example='user_log', position='Query'),
  siteId?: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.', example='12312312213212', position='Query'),
}

model CheckSiteProjectNameResponseBody = {
  check?: boolean(name='Check', description='Indicates whether the task name is valid. Valid values:

*   **true**
*   **false**', example='true'),
  description?: string(name='Description', description='The result description.', example='project name pass the check'),
  projectName?: string(name='ProjectName', description='The name of the real-time log delivery task.', example='dcdn_waf_userAccount_log'),
  requestId?: string(name='RequestId', description='The request ID.', example='34DCBC8A-****-****-****-6DAA11D7DDBD'),
}

model CheckSiteProjectNameResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CheckSiteProjectNameResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CheckSiteProjectName  CheckSiteProjectNameRequest
  * @return CheckSiteProjectNameResponse
 */
async function checkSiteProjectName(request: CheckSiteProjectNameRequest): CheckSiteProjectNameResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CheckSiteProjectName', 'GET', '/', 'json', false, 'json', request);
}

model CheckUserProjectNameRequest {
  projectName: string(name='ProjectName', description='The name of the real-time log delivery task.

This parameter is required.', example='ali-dcdn-log-56', position='Query'),
}

model CheckUserProjectNameResponseBody = {
  check?: boolean(name='Check', description='Indicates whether the name is valid. Valid values:

*   **true**
*   **false**', example='true'),
  description?: string(name='Description', description='The reason why the name passed or failed the check.', example='project name pass the check'),
  projectName?: string(name='ProjectName', description='The name of the real-time log delivery task.', example='ali-dcdn-log-56'),
  requestId?: string(name='RequestId', description='The request ID.', example='34DCBC8A-****-****-****-6DAA11D7DDBD'),
}

model CheckUserProjectNameResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CheckUserProjectNameResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CheckUserProjectName  CheckUserProjectNameRequest
  * @return CheckUserProjectNameResponse
 */
async function checkUserProjectName(request: CheckUserProjectNameRequest): CheckUserProjectNameResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CheckUserProjectName', 'GET', '/', 'json', false, 'json', request);
}

model CommitRoutineStagingCodeRequest {
  codeDescription?: string(name='CodeDescription', description='The description of the code version.', example='description of this code ver', position='Body'),
  name: string(name='Name', description='The routine name.

This parameter is required.', example='CommitRoutineStagingCode', position='Body'),
}

model CommitRoutineStagingCodeResponseBody = {
  codeVersion?: string(name='CodeVersion', description='The version number of the newly generated code.', example='1710120201067203242'),
  requestId?: string(name='RequestId', description='The request ID.', example='EDBD3EB3-97DA-5465-AEF5-8DCA5DC5E395'),
}

model CommitRoutineStagingCodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CommitRoutineStagingCodeResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CommitRoutineStagingCode  CommitRoutineStagingCodeRequest
  * @return CommitRoutineStagingCodeResponse
 */
async function commitRoutineStagingCode(request: CommitRoutineStagingCodeRequest): CommitRoutineStagingCodeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CommitRoutineStagingCode', 'POST', '/', 'json', true, 'form', request);
}

model CreateClientCertificateRequest {
  CSR?: string(name='CSR', example='-----BEGIN CERTIFICATE REQUEST-----', position='Body'),
  pkeyType?: string(name='PkeyType', example='RSA', position='Body'),
  siteId: long(name='SiteId', description='This parameter is required.', example='1234567890123', position='Query'),
  validityDays: long(name='ValidityDays', description='This parameter is required.', example='365', position='Body'),
}

model CreateClientCertificateResponseBody = {
  CACertificateId?: string(name='CACertificateId', example='babaded901474b9693acf530e0fb1dbb'),
  certificate?: string(name='Certificate', example='-----BEGIN CERTIFICATE-----'),
  commonName?: string(name='CommonName', example='www.example.com'),
  fingerprintSha256?: string(name='FingerprintSha256', example='1dc5fc9af4eead2570c70d94b416130baeb6d4429b51fd3557379588456aca66'),
  id?: string(name='Id', example='babaded901474b9693acf530e0fb1d95'),
  issuer?: string(name='Issuer', example='DCDN CA'),
  notAfter?: string(name='NotAfter', example='2024-12-01T02:12:49Z'),
  notBefore?: string(name='NotBefore', example='2023-12-01T02:12:49Z'),
  privateKey?: string(name='PrivateKey', example='-----BEGIN PRIVATE KEY-----'),
  requestId?: string(name='RequestId', example='C370DAF1-C838-4288-A1A0-9A87633D248E'),
  serialNumber?: string(name='SerialNumber', example='babaded901474b9693acf530e0fb1daa'),
  signatureAlgorithm?: string(name='SignatureAlgorithm', example='SHA256-RSA'),
  status?: string(name='Status', example='active'),
  validityDays?: string(name='ValidityDays', example='365'),
}

model CreateClientCertificateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateClientCertificateResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateClientCertificate  CreateClientCertificateRequest
  * @return CreateClientCertificateResponse
 */
async function createClientCertificate(request: CreateClientCertificateRequest): CreateClientCertificateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateClientCertificate', 'POST', '/', 'json', true, 'form', request);
}

model CreateCustomScenePolicyRequest {
  endTime: string(name='EndTime', description='The time when the policy expires.

Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

This parameter is required.', example='2021-11-07T18:00:00Z', position='Query'),
  name: string(name='Name', description='The policy name.

This parameter is required.', example='test', maxLength=255, position='Query'),
  objects?: string(name='Objects', description='The IDs of the websites that you want to associate with the policy. Separate multiple IDs with commas (,).', example='7096621098****', position='Query'),
  startTime: string(name='StartTime', description='The time when the policy takes effect.

Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

This parameter is required.', example='2021-11-07T17:00:00Z', position='Query'),
  template: string(name='Template', description='The name of the policy template. Valid value:

*   **promotion**: major events.

This parameter is required.', example='promotion', position='Query'),
}

model CreateCustomScenePolicyResponseBody = {
  endTime?: string(name='EndTime', description='The time when the policy expires.

The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.', example='2021-11-07T18:00:00Z'),
  name?: string(name='Name', description='The policy name.', example='test'),
  objects?: [ string ](name='Objects', description='The IDs of websites associated.'),
  policyId?: long(name='PolicyId', description='The policy ID.', example='1'),
  requestId?: string(name='RequestId', description='The request ID.', example='0AEDAF20-4DDF-4165-8750-47FF9C1929C9'),
  startTime?: string(name='StartTime', description='The time when the policy takes effect.

The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.', example='2021-11-07T17:00:00Z'),
  template?: string(name='Template', description='The name of the policy template.', example='promotion'),
}

model CreateCustomScenePolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateCustomScenePolicyResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateCustomScenePolicy  CreateCustomScenePolicyRequest
  * @return CreateCustomScenePolicyResponse
 */
async function createCustomScenePolicy(request: CreateCustomScenePolicyRequest): CreateCustomScenePolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateCustomScenePolicy', 'POST', '/', 'json', false, 'json', request);
}

model CreateEdgeContainerAppRequest {
  healthCheckFailTimes?: int32(name='HealthCheckFailTimes', description='The number of consecutive failed health checks required for an application to be considered as unhealthy. Valid values: 1 to 10. Default value: 5.', example='3', position='Body'),
  healthCheckHost?: string(name='HealthCheckHost', description='The domain name that is used for health checks. This parameter is empty by default.', example='www.aliyun.com', position='Body'),
  healthCheckHttpCode?: string(name='HealthCheckHttpCode', description='The HTTP status code returned for a successful health check. Valid values:

*   **http_2xx** (default)
*   **http_3xx**', example='http_2xx', position='Body'),
  healthCheckInterval?: int32(name='HealthCheckInterval', description='The interval between two consecutive health checks. Unit: seconds. Valid values: **1** to **50**. Default value: **5**.', example='5', position='Body'),
  healthCheckMethod?: string(name='HealthCheckMethod', description='The HTTP request method for health checks. Valid values:

*   **HEAD** (default): requests the headers of the resource.
*   **GET**: requests the specified resource and returns both the headers and entity body.', example='HEAD', position='Body'),
  healthCheckPort?: int32(name='HealthCheckPort', description='The port used for health checks. Valid values: 1 to 65535. Default value: 80.', example='80', position='Body'),
  healthCheckSuccTimes?: int32(name='HealthCheckSuccTimes', description='The number of consecutive successful health checks required for an application to be considered as healthy. Valid values: 1 to 10. Default value: 2.', example='2', position='Body'),
  healthCheckTimeout?: int32(name='HealthCheckTimeout', description='The timeout period of a health check response. If a backend ECS instance does not respond within the specified timeout period, the ECS instance fails the health check. Unit: seconds.\\
Valid values: **1** to **100**.\\
Default value: **3**.', example='5', position='Body'),
  healthCheckType?: string(name='HealthCheckType', description='The health check type. By default, this parameter is left empty.

Valid values:

*   **l4**: Layer 4 health check.
*   **l7**: Layer 7 health check.', example='l7', position='Body'),
  healthCheckURI?: string(name='HealthCheckURI', description='The URI used for health checks. The URI must be **1** to **80** characters in length. Default value: "/".', example='/health_check', position='Body'),
  name: string(name='Name', description='The name of the application. The name must start with a lowercase letter and can contain lowercase letters, digits, and hyphens (-). The name must be 6 to 128 characters in length.

This parameter is required.', example='app-test', minLength=6, maxLength=128, position='Body'),
  remarks?: string(name='Remarks', description='The remarks. This parameter is empty by default.', example='test app', maxLength=1024, position='Body'),
  servicePort: int32(name='ServicePort', description='The server port. Valid values: 1 to 65535.

This parameter is required.', example='80', minimum=80, maximum=443, position='Body'),
  targetPort: int32(name='TargetPort', description='The backend port, which is also the service port of the application. Valid values: 1 to 65535.

This parameter is required.', example='80', minimum=1, maximum=65535, position='Body'),
}

model CreateEdgeContainerAppResponseBody = {
  appId?: string(name='AppId', description='The ID of the application that is created.', example='app-880688675783794688'),
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model CreateEdgeContainerAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateEdgeContainerAppResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateEdgeContainerApp  CreateEdgeContainerAppRequest
  * @return CreateEdgeContainerAppResponse
 */
async function createEdgeContainerApp(request: CreateEdgeContainerAppRequest): CreateEdgeContainerAppResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateEdgeContainerApp', 'POST', '/', 'json', true, 'form', request);
}

model CreateEdgeContainerAppRecordRequest {
  appId: string(name='AppId', description='The application ID.

This parameter is required.', example='app-88068867578379****', minLength=20, maxLength=64, position='Body'),
  recordName: string(name='RecordName', description='The associated domain name.

This parameter is required.', example='a.example.com', maxLength=1024, position='Body'),
  siteId?: long(name='SiteId', description='The website ID.', example='5407498413****', position='Body'),
}

model CreateEdgeContainerAppRecordResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='0AEDAF20-4DDF-4165-8750-47FF9C1929C9'),
}

model CreateEdgeContainerAppRecordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateEdgeContainerAppRecordResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateEdgeContainerAppRecord  CreateEdgeContainerAppRecordRequest
  * @return CreateEdgeContainerAppRecordResponse
 */
async function createEdgeContainerAppRecord(request: CreateEdgeContainerAppRecordRequest): CreateEdgeContainerAppRecordResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateEdgeContainerAppRecord', 'POST', '/', 'json', true, 'form', request);
}

model CreateEdgeContainerAppVersionRequest {
  appId: string(name='AppId', description='The application ID, which can be obtained by calling the [ListEdgeContainerApps](~~ListEdgeContainerApps~~) operation.

This parameter is required.', example='app-88068867578379****', minLength=20, maxLength=64, position='Body'),
  containers: [ 
    {
      ACRImageInfo?: {
        domain?: string(name='Domain', description='The domain name of the Container Registry image.', example='1500.***.net'),
        instanceId?: string(name='InstanceId', description='The ID of the Container Registry instance.', example='xcdn-9axbo****'),
        isEnterpriseRegistry?: boolean(name='IsEnterpriseRegistry', description='Specifies whether the image is an enterprise-level Container Registry image.', example='false'),
        regionId?: string(name='RegionId', description='The regions in which the Container Registry instance resides.', example='cn-shanghai'),
        repoId?: string(name='RepoId', description='The ID of the image repository.', example='crr-h1ghghu60ct****'),
        repoName?: string(name='RepoName', description='The name of the image repository.', example='test_71'),
        repoNamespace?: string(name='RepoNamespace', description='The namespace to which the image repository belongs.', example='safeline'),
        tag?: string(name='Tag', description='The tag of the Container Registry image.', example='3.40.2'),
        tagUrl?: string(name='TagUrl', description='The URL of the Container Registry image tag.'),
      }(name='ACRImageInfo', description='The information about the Container Registry image.'),
      args?: string(name='Args', description='The arguments that are passed to the container startup command. Separate the parameters with spaces.', example='-a'),
      command?: string(name='Command', description='The command that is used to start the container. Separate the arguments with spaces.', example='nginx'),
      envVariables?: string(name='EnvVariables', description='The environment variables. Separate the environment variables with commas (,).', example='VITE_APP_TITLE=My App'),
      image: string(name='Image', description='The address of the image.

This parameter is required.', example='registry-vpc.cn-shenzhen.aliyuncs.com/lihe****h/ea****ts_serv****am:3.**'),
      isACRImage: boolean(name='IsACRImage', description='Specifies whether the image is a Container Registry image.

This parameter is required.', example='false'),
      name: string(name='Name', description='The name of the container. The name must be unique in the same container group.

This parameter is required.', example='lxg-demo-er'),
      postStart?: string(name='PostStart', description='The command that is run before the container is started. Separate the arguments with spaces.', example='sh poststart.sh "echo hello world"'),
      preStop?: string(name='PreStop', description='The command that is run before the container is stopped. Separate the arguments with spaces.', example='sh prestop.sh "echo hello world"'),
      probeContent: {
        command?: string(name='Command', description='The command of the exec type probe.', example='echo ok'),
        failureThreshold?: int32(name='FailureThreshold', description='The number of consecutive failed health checks required for a container to be considered as unhealthy.', example='3'),
        host?: string(name='Host', description='The domain name that is used for health checks.', example='www.rewrite.com'),
        httpHeaders?: string(name='HttpHeaders', description='The request headers that are included in the container health check request.', example='[{\\"Content-Type\\":\\"application/json\\"}]'),
        initialDelaySeconds?: int32(name='InitialDelaySeconds', description='The latency for container probe initialization.', example='1'),
        path?: string(name='Path', description='The health check path.', example='/'),
        periodSeconds?: int32(name='PeriodSeconds', description='The interval between container health checks.', example='1'),
        port?: int32(name='Port', description='The health check port.', example='9991'),
        scheme?: string(name='Scheme', description='The protocol that the container health check request uses.', example='http'),
        successThreshold?: int32(name='SuccessThreshold', description='The number of consecutive successful health checks required for a container to be considered as healthy.', example='1'),
        timeoutSeconds?: int32(name='TimeoutSeconds', description='The timeout period of the container health check.', example='1'),
      }(name='ProbeContent', description='The content of the container health probe.

This parameter is required.'),
      probeType: string(name='ProbeType', description='The type of the probe. Valid values:

*   exec: the command type.
*   tcpSocket: the TCP probe type.
*   httpGet: the HTTP access type.

This parameter is required.', example='exec'),
      spec: string(name='Spec', description='The compute specification of the container. Valid values: 1C2G, 2C4G, 2C8G, 4C8G, 4C16G, 8C16G, and 8C32G.

This parameter is required.', example='1C2G'),
      storage: string(name='Storage', description='The storage capacity. Valid values: 0.5G, 10G, 20G, and 30G.

This parameter is required.', example='0.5G'),
    }
  ](name='Containers', description='The container group to be deployed for this version, which contains information about images.\\
The image data contains the image address, startup command, parameters, environment variables, and probe rules. You can specify one or more images. The parameter value is a JSON string.

This parameter is required.', example='[
      {
            "Name": "container1",
            "Image": "image1",
            "Spec": "1C2G",
            "Command": "/bin/sh",
            "Args": "-c hello",
            "ProbeType": "tcpSocket",
            "ProbeContent": "{\\"Port\\":8080}"
      },
      {
            "Name": "container2",
            "Image": "image2",
            "Spec": "2C4G",
            "ProbeType": "httpGet",
            "ProbeContent": "{\\"Path\\":\\"/\\",\\"Port\\":80,\\"InitialDelaySeconds\\":10}"
      }
]', shrink='json', position='Body'),
  name: string(name='Name', description='The version name, which must be 6 to 128 characters in length.

This parameter is required.', example='verson1', minLength=6, maxLength=128, position='Body'),
  remarks?: string(name='Remarks', description='The description of the version.', example='test app', maxLength=1024, position='Body'),
}

model CreateEdgeContainerAppVersionResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
  versionId?: string(name='VersionId', description='The ID of the created version.', example='ver-87962637161651****'),
}

model CreateEdgeContainerAppVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateEdgeContainerAppVersionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateEdgeContainerAppVersion  CreateEdgeContainerAppVersionRequest
  * @return CreateEdgeContainerAppVersionResponse
 */
async function createEdgeContainerAppVersion(request: CreateEdgeContainerAppVersionRequest): CreateEdgeContainerAppVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateEdgeContainerAppVersion', 'POST', '/', 'json', true, 'form', request);
}

model CreateKvNamespaceRequest {
  description?: string(name='Description', description='The description of the namespace.', example='this is a test namespace.', position='Body'),
  namespace: string(name='Namespace', description='The name of the namespace.

This parameter is required.', example='test_namespace', position='Body'),
}

model CreateKvNamespaceResponseBody = {
  description?: string(name='Description', description='The description of the namespace.', example='this is a test namespace.'),
  namespace?: string(name='Namespace', description='The name of the namespace.', example='test_namespace'),
  namespaceId?: string(name='NamespaceId', description='The ID of the namespace.', example='657717877171818496'),
  requestId?: string(name='RequestId', description='The request ID.', example='EEEBE525-F576-1196-8DAF-2D70CA3F4D2F'),
  status?: string(name='Status', description='The status of the namespace. Valid values:

*   **online**: working as expected.
*   **delete**: pending deletion.
*   **deleting**: being deleted.
*   **deleted**: deleted.', example='online'),
}

model CreateKvNamespaceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateKvNamespaceResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateKvNamespace  CreateKvNamespaceRequest
  * @return CreateKvNamespaceResponse
 */
async function createKvNamespace(request: CreateKvNamespaceRequest): CreateKvNamespaceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateKvNamespace', 'POST', '/', 'json', true, 'form', request);
}

model CreateListRequest {
  description?: string(name='Description', description='The description of the list that you want to create.', example='a custom list', position='Body'),
  items?: [ string ](name='Items', description='The items in the list that you want to create.', example='a custom list', shrink='json', position='Body'),
  kind?: string(name='Kind', description='The type of the list that you want to create.', example='ip', position='Body'),
  name: string(name='Name', description='The name of the list that you want to create.

This parameter is required.', example='example', position='Body'),
}

model CreateListResponseBody = {
  id?: long(name='Id', description='The ID of the custom list.[](~~2850217~~)', example='40000001'),
  requestId?: string(name='RequestId', description='The request ID.', example='36af3fcc-43d0-441c-86b1-428951dc8225'),
}

model CreateListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateListResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateList  CreateListRequest
  * @return CreateListResponse
 */
async function createList(request: CreateListRequest): CreateListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateList', 'POST', '/', 'json', true, 'form', request);
}

model CreateOriginProtectionRequest {
  siteId: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.

This parameter is required.', example='123456****', position='Query'),
}

model CreateOriginProtectionResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='CB1A380B-09F0-41BB-A198-72F8FD6DA2FE'),
}

model CreateOriginProtectionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateOriginProtectionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateOriginProtection  CreateOriginProtectionRequest
  * @return CreateOriginProtectionResponse
 */
async function createOriginProtection(request: CreateOriginProtectionRequest): CreateOriginProtectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateOriginProtection', 'POST', '/', 'json', false, 'json', request);
}

model CreatePageRequest {
  content?: string(name='Content', description='The Base64-encoded page content. Example: "PGh0bWw+aGVsbG8gcGFnZTwvaHRtbD4=", which indicates "hello page".', example='PGh0bWw+aGVsbG8gcGFnZTwvaHRtbD4=', position='Body'),
  contentType: string(name='ContentType', description='The Content-Type field in the HTTP header. Valid values:

*   text/html
*   application/json

This parameter is required.', example='text/html', position='Body'),
  description?: string(name='Description', description='The description of the page.', example='a custom deny page', position='Body'),
  name: string(name='Name', description='The name of the custom error page.

This parameter is required.', example='example', position='Body'),
}

model CreatePageResponseBody = {
  id?: long(name='Id', description='The ID of the custom error page.[](~~2850223~~)', example='50000001'),
  requestId?: string(name='RequestId', description='The request ID.', example='36af3fcc-43d0-441c-86b1-428951dc8225'),
}

model CreatePageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreatePageResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreatePage  CreatePageRequest
  * @return CreatePageResponse
 */
async function createPage(request: CreatePageRequest): CreatePageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreatePage', 'POST', '/', 'json', true, 'form', request);
}

model CreateRecordRequest {
  authConf?: {
    accessKey?: string(name='AccessKey', description='The access key of the account to which the origin server belongs. This parameter is required when the SourceType is OSS, and AuthType is private_cross_account, or when the SourceType is S3 and AuthType is private.', example='u0Nkg5gBK*******QF5wvKMM504JUHt'),
    authType?: string(name='AuthType', description='The authentication type of the origin server. Different origins support different authentication types. The type of origin refers to the SourceType parameter in this operation. If the type of origin is OSS or S3, you must specify the authentication type of the origin. Valid values:

*   **public**: public read. Select this value when the origin type is OSS or S3 and the origin access is public read.
*   **private**: private read. Select this value when the origin type is S3 and the origin access is private read.
*   **private_same_account**: private read under the same account. Select this value when the origin type is OSS, the origins belong to the same Alibaba Cloud account, and the origins have private read access.
*   **private_cross_account**: private read cross accounts. Select this value when the origin type is OSS, the origins belong to different Alibaba Cloud accounts, and the origins have private read access.', example='private'),
    region?: string(name='Region', description='The region of the origin. If the origin type is S3, you must specify this value. You can get the region information from the official website of S3.', example='us-east-1'),
    secretKey?: string(name='SecretKey', description='The secret access key of the account to which the origin server belongs. This parameter is required when the SourceType is OSS, and AuthType is private_same_account, or when the SourceType is S3 and AuthType is private.', example='VIxuvJSA2S03f******kp208dy5w7'),
    version?: string(name='Version', description='The version of the signature algorithm. This parameter is required when the origin type is S3 and AuthType is private. The following two types are supported:

*   **v2**
*   **v4**

If you leave this parameter empty, the default value v4 is used.', example='v4'),
  }(name='AuthConf', description='The origin authentication information of the CNAME record.', shrink='json', position='Query'),
  bizName?: string(name='BizName', description='The business scenario of the record for acceleration. Leave the parameter empty if your record is not proxied. Valid values:

*   **image_video**: video and image.
*   **api**: API.
*   **web**: web page.', example='web', position='Query'),
  comment?: string(name='Comment', description='The comment of the record. The maximum length is 100 characters.', example='This is a remark.', position='Query'),
  data: {
    algorithm?: int32(name='Algorithm', description='The encryption algorithm used for the record, specified within the range from 0 to 255. This parameter is required when you add CERT or SSHFP records.', example='1'),
    certificate?: string(name='Certificate', description='The public key of the certificate. This parameter is required when you add CERT, SMIMEA, or TLSA records.', example='dGVzdGFkYWxrcw=='),
    fingerprint?: string(name='Fingerprint', description='The public key fingerprint of the record. This parameter is required when you add a SSHFP record.', example='abcdef1234567890'),
    flag?: int32(name='Flag', description='The flag bit of the record. The Flag for a CAA record indicates its priority and how it is processed, specified within the range of 0 to 255. This parameter is required when you add a CAA record.', example='128'),
    keyTag?: int32(name='KeyTag', description='The public key identification for the record, specified within the range of 0 to 65,535. This parameter is required when you add a CAA record.', example='0'),
    matchingType?: int32(name='MatchingType', description='The algorithm policy used to match or validate the certificate, specified within the range 0 to 255. This parameter is required when you add SMIMEA or TLSA records.', example='1'),
    port?: int32(name='Port', description='The port of the record, specified within the range of 0 to 65,535. This parameter is required when you add an SRV record.', example='0'),
    priority?: int32(name='Priority', description='The priority of the record, specified within the range of 0 to 65,535. A smaller value indicates a higher priority. This parameter is required when you add MX, SRV, and URI records.', example='10'),
    selector?: int32(name='Selector', description='The type of certificate or public key, specified within the range of 0 to 255. This parameter is required when you add SMIMEA or TLSA records.', example='1'),
    tag?: string(name='Tag', description='The label of the record. The Tag of a CAA record indicate its specific type and usage. This parameter is required when you add a CAA record. Valid values:

*   **issue**: indicates that a CA is authorized to issue a certificate for the domain name. This is usually followed by the domain name of the CA.
*   **issuewild**: indicates that a CA is authorized to issue a wildcard certificate (such as \\*.example.com) for the domain name.
*   **iodef**: specifies a URI to receive reports about CAA record violations.', example='issue'),
    type?: int32(name='Type', description='The certificate type of the record (in CERT records), or the public key type (in SSHFP records). This parameter is required when you add CERT or SSHFP records.', example='RSA'),
    usage?: int32(name='Usage', description='The usage identifier of the record, specified within the range of 0 to 255. This parameter is required when you add SMIMEA or TLSA records.', example='1'),
    value?: string(name='Value', description='Record value or part of the record content. This parameter is required when you add A/AAAA, CNAME, NS, MX, TXT, CAA, SRV, and URI records. It has different meanings based on types of records:

*   **A/AAAA**: the IP address(es). Separate IP addresses with commas (,). You must have at least one IPv4 address.
*   **CNAME**: the target domain name.
*   **NS**: the name servers for the domain name.
*   **MX**: a valid domain name of the target mail server.
*   **TXT**: a valid text string.
*   **CAA**: a valid domain name of the certificate authority.
*   **SRV**: a valid domain name of the target host.
*   **URI**: a valid URI string.', example='example.com'),
    weight?: int32(name='Weight', description='The weight of the record, specified within the range of 0 to 65,535. This parameter is required when you add SRV or URI records.', example='0'),
  }(name='Data', description='The DNS record information. The format of this field varies based on the record type. For more information, see [References](https://www.alibabacloud.com/help/doc-detail/2708761.html) .

This parameter is required.', example='{
    "value":"2.2.2.2"
}', shrink='json', position='Query'),
  hostPolicy?: string(name='HostPolicy', description='The origin host policy. This policy takes effect when the record type is CNAME. You can set the policy in two modes:

*   **follow_hostname**: Follow the host record.
*   **follow_origin_domain**: match the origin\\"s domain name.', example='follow_origin_domain', position='Query'),
  proxied?: boolean(name='Proxied', description='Specifies whether to proxy the record. Only CNAME and A/AAAA records can be proxied. Valid values:

*   **true**
*   **false**', example='true', position='Query'),
  recordName: string(name='RecordName', description='The record name.

This parameter is required.', example='www.example.com', position='Query'),
  siteId: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.

This parameter is required.', example='1234567890123', position='Query'),
  sourceType?: string(name='SourceType', description='The origin type for the CNAME record. This parameter is required when you add a CNAME record. Valid values:

*   **OSS**: OSS bucket.
*   **S3**: S3 bucket.
*   **LB**: load balancer.
*   **OP**: origin pool.
*   **Domain**: domain name.

If you do not pass this parameter or if you leave its value empty, Domain is used by default.', example='OSS', position='Query'),
  ttl?: int32(name='Ttl', description='The TTL of the record. Unit: seconds. If the value is 1, the TTL of the record is determined by the system.', example='30', position='Query'),
  type: string(name='Type', description='The type of the DNS record. For example, A/AAAA, TXT, MX, or CNAME.

This parameter is required.', example='A/AAAA', position='Query'),
}

model CreateRecordResponseBody = {
  recordId?: long(name='RecordId', description='The record ID.', example='1234567890123'),
  requestId?: string(name='RequestId', description='The request ID.', example='F61CDR30-E83C-4FDA-BF73-9A94CDD44229'),
}

model CreateRecordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateRecordResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateRecord  CreateRecordRequest
  * @return CreateRecordResponse
 */
async function createRecord(request: CreateRecordRequest): CreateRecordResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateRecord', 'POST', '/', 'json', false, 'json', request);
}

model CreateRoutineRequest {
  description?: string(name='Description', description='The routine description.', example='the description of this routine', position='Body'),
  name: string(name='Name', description='The routine name, which must be unique in the same account.

This parameter is required.', example='test-routine1', position='Body'),
  specName: string(name='SpecName', description='The specification of the routine.

This parameter is required.', example='5ms', position='Body'),
}

model CreateRoutineResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='EDBD3EB3-97DA-5465-AEF5-8DCA5DC5E395'),
  status?: string(name='Status', description='Indicates whether the operation is successful.', example='OK'),
}

model CreateRoutineResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateRoutineResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateRoutine  CreateRoutineRequest
  * @return CreateRoutineResponse
 */
async function createRoutine(request: CreateRoutineRequest): CreateRoutineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateRoutine', 'POST', '/', 'json', true, 'form', request);
}

model CreateRoutineRelatedRecordRequest {
  name: string(name='Name', description='The routine name.

This parameter is required.', example='CreateRoutineRelatedRecord', position='Body'),
  recordName: string(name='RecordName', description='The record name.

This parameter is required.', example='test-record-1.example.com', position='Body'),
  siteId: long(name='SiteId', description='The website ID.

This parameter is required.', example='54362329990032', position='Body'),
}

model CreateRoutineRelatedRecordResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='EDBD3EB3-97DA-5465-AEF5-8DCA5DC5E395'),
  status?: string(name='Status', description='Indicates whether the operation is successful.', example='OK'),
}

model CreateRoutineRelatedRecordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateRoutineRelatedRecordResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateRoutineRelatedRecord  CreateRoutineRelatedRecordRequest
  * @return CreateRoutineRelatedRecordResponse
 */
async function createRoutineRelatedRecord(request: CreateRoutineRelatedRecordRequest): CreateRoutineRelatedRecordResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateRoutineRelatedRecord', 'POST', '/', 'json', true, 'form', request);
}

model CreateRoutineRelatedRouteRequest {
  byPass?: string(name='ByPass', position='Body'),
  name: string(name='Name', description='The routine name.

This parameter is required.', example='CreateRoutineRelatedRoute', position='Body'),
  route: string(name='Route', description='The route.

This parameter is required.', example='*.example.com/path1*', position='Body'),
  siteId: long(name='SiteId', description='The website ID.

This parameter is required.', example='54362329990032', position='Body'),
}

model CreateRoutineRelatedRouteResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='EDBD3EB3-97DA-5465-AEF5-8DCA5DC5E395'),
  status?: string(name='Status', description='Indicates whether the operation is successful.', example='OK'),
}

model CreateRoutineRelatedRouteResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateRoutineRelatedRouteResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateRoutineRelatedRoute  CreateRoutineRelatedRouteRequest
  * @return CreateRoutineRelatedRouteResponse
 */
async function createRoutineRelatedRoute(request: CreateRoutineRelatedRouteRequest): CreateRoutineRelatedRouteResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateRoutineRelatedRoute', 'POST', '/', 'json', true, 'form', request);
}

model CreateScheduledPreloadExecutionsRequest {
  executions: [ 
    {
      endTime?: string(name='EndTime', description='The end time of the prefetch plans.', example='2024-06-04T02:02:09Z'),
      interval: int32(name='Interval', description='The time interval between each batch execution. Unit: seconds.

This parameter is required.', example='30', minimum=1),
      sliceLen: int32(name='SliceLen', description='The number of URLs prefetched in each batch.

This parameter is required.', example='10', minimum=1, maximum=100),
      startTime?: string(name='StartTime', description='The start time of the prefetch plans.', example='2024-06-03T16:00:00Z'),
    }
  ](name='Executions', description='The scheduled prefetch plans to create.

This parameter is required.', shrink='json', position='Body'),
  id?: string(name='Id', description='The ID of the prefetch task, which is generated by calling the [CreateScheduledPreloadJob](https://help.aliyun.com/document_detail/2850459.html) operation.', example='CreateScheduledPreloadExecutions', position='Query'),
}

model CreateScheduledPreloadExecutionsResponseBody = {
  failedExecutions?: [ 
    {
      aliUid?: string(name='AliUid', description='The ID of the Alibaba Cloud account.', example='15685865xxx14622'),
      endTime?: string(name='EndTime', description='The end time of the prefetch plans.', example='2024-06-03T02:43:35Z'),
      id?: string(name='Id', description='The ID of the prefetch plan.', example='66599bd7397885b43804901c'),
      interval?: int32(name='Interval', description='The time interval between each batch execution. Unit: seconds.', example='60'),
      jobId?: string(name='JobId', description='The ID of the prefetch task.', example='665d3af3621bccf3fe29e1a4'),
      sliceLen?: int32(name='SliceLen', description='The number of URLs prefetched in each batch.', example='10'),
      startTime?: string(name='StartTime', description='The start time of the prefetch plans.', example='2024-06-02T02:43:35Z'),
      status?: string(name='Status', description='The status of the prefetch plan. Valid values:

*   **waiting**
*   **running**
*   **finished**
*   **failed**
*   **stopped**', example='running'),
    }
  ](name='FailedExecutions', description='The information about prefetch plans that failed to be created.'),
  failedMessages?: [ string ](name='FailedMessages', description='The information about plan failures.'),
  requestId?: string(name='RequestId', description='The request ID.', example='F61CDR30-E83C-4FDA-BF73-9A94CDD44229'),
  successCount?: int32(name='SuccessCount', description='The number of prefetch plans that are created.', example='12'),
  successExecutions?: [ 
    {
      aliUid?: string(name='AliUid', description='The ID of the Alibaba Cloud account.', example='15685865xxx14622'),
      endTime?: string(name='EndTime', description='The end time of the prefetch plans.', example='2024-06-03T02:43:35Z'),
      id?: string(name='Id', description='The ID of the prefetch plan.', example='66599bd7397885b43804901c'),
      interval?: int32(name='Interval', description='The time interval between each batch execution. Unit: seconds.', example='60'),
      jobId?: string(name='JobId', description='The ID of the prefetch task.', example='665d3af3621bccf3fe29e1a4'),
      sliceLen?: int32(name='SliceLen', description='The number of URLs prefetched in each batch.', example='10'),
      startTime?: string(name='StartTime', description='The start time of the prefetch plans.', example='2024-06-02T02:43:35Z'),
      status?: string(name='Status', description='The status of the prefetch plan. Valid values:

*   **waiting**
*   **running**
*   **finished**
*   **failed**
*   **stopped**', example='failed'),
    }
  ](name='SuccessExecutions', description='The information about created prefetch plans.'),
  totalCount?: int32(name='TotalCount', description='The total number of new plans requested.', example='2'),
}

model CreateScheduledPreloadExecutionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateScheduledPreloadExecutionsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateScheduledPreloadExecutions  CreateScheduledPreloadExecutionsRequest
  * @return CreateScheduledPreloadExecutionsResponse
 */
async function createScheduledPreloadExecutions(request: CreateScheduledPreloadExecutionsRequest): CreateScheduledPreloadExecutionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateScheduledPreloadExecutions', 'POST', '/', 'json', true, 'form', request);
}

model CreateScheduledPreloadJobRequest {
  insertWay: string(name='InsertWay', description='The method to submit URLs to be prefetched.

Valid values:

*   **textBox**
*   **oss**

This parameter is required.', example='oss', position='Body'),
  name: string(name='Name', description='The name of the scheduled prefetch task.

This parameter is required.', example='example', minLength=1, maxLength=128, position='Body'),
  ossUrl?: string(name='OssUrl', description='The URL of the OSS object that stores the URLs to be prefetched.', example='https://xxxobject.oss-cn-reginon.aliyuncs.com/9d91_xxxxxxxxxxx_158bb6e0f97c477791209bb46bd599f7', position='Body'),
  siteId: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.

This parameter is required.', example='190007158391808', position='Body'),
  urlList?: string(name='UrlList', description='The URLs to be prefetched. This parameter is required if you set InsertWay to textBox.', example='http://testurl.com/a.txt
http://testurl.com/b.txt', position='Body'),
}

model CreateScheduledPreloadJobResponseBody = {
  aliUid?: string(name='AliUid', description='The ID of the Alibaba Cloud account.', example='15685865xxx14622'),
  createdAt?: string(name='CreatedAt', description='The time when the task was created.', example='2023-06-05T10:04:20+0800'),
  domains?: string(name='Domains', description='The domain names to be prefetched.', example='testurl.com'),
  errorInfo?: string(name='ErrorInfo', description='The error message. Multiple error messages are separated by commas (,). Valid values:

*   **InvalidUrl**: The URL format is invalid.
*   **InvalidDomain**: The domain name fails the domain ownership verification.
*   **QuotaExcess**: the quota limit has been reached.
*   **OtherErrors**: other errors.', example='InvalidDomain'),
  failedFileOss?: string(name='FailedFileOss', description='The URL of the OSS object that stores a list of URLs that failed the conditional check for prefetching.', example='https://xxxobject.oss-cn-reginon.aliyuncs.com/9d91_xxxxxxxxxxx_158bb6e0f97c477791209bb46bd599f7'),
  fileId?: string(name='FileId', description='The ID of the URL list file, which can be used during downloads.', example='665d3b48621bccf3fe29e1a7'),
  id?: string(name='Id', description='The ID of the scheduled prefetch task.', example='665d3af3621bccf3fe29e1a4'),
  insertWay?: string(name='InsertWay', description='The method to submit the URLs to be prefetched.', example='oss'),
  name?: string(name='Name', description='The task name.', example='example'),
  requestId?: string(name='RequestId', description='The request ID.', example='15C66C7B-671A-4297-9187-2C4477247B78'),
  siteId?: long(name='SiteId', description='The website ID.', example='190007158391808'),
  taskSubmitted?: int32(name='TaskSubmitted', description='The number of submitted prefetch tasks.', example='1'),
  taskType?: string(name='TaskType', description='The task type (refresh or preload).', example='preload'),
  urlCount?: int32(name='UrlCount', description='The total number of URLs.', example='2'),
  urlSubmitted?: int32(name='UrlSubmitted', description='The number of submitted URLs.', example='1'),
}

model CreateScheduledPreloadJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateScheduledPreloadJobResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateScheduledPreloadJob  CreateScheduledPreloadJobRequest
  * @return CreateScheduledPreloadJobResponse
 */
async function createScheduledPreloadJob(request: CreateScheduledPreloadJobRequest): CreateScheduledPreloadJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateScheduledPreloadJob', 'POST', '/', 'json', true, 'form', request);
}

model CreateSiteRequest {
  accessType: string(name='AccessType', description='The DNS setup. Valid values:

*   **NS**
*   **CNAME**

This parameter is required.', example='NS', position='Query'),
  coverage: string(name='Coverage', description='The service location. Valid values:

*   **domestic**: the Chinese mainland
*   **global**: global
*   **overseas**: outside the Chinese mainland

This parameter is required.', example='domestic', position='Query'),
  instanceId: string(name='InstanceId', description='The instance ID, which can be obtained by calling the [ListUserRatePlanInstances](https://help.aliyun.com/document_detail/2852398.html) operation. Specify at least one of the instance ID and website ID. If you specify both of them, the instance ID is used.

This parameter is required.', example='dbaudit-cn-nwy349jdb03', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group. If you leave this parameter empty, the system uses the default resource group ID.', example='rg-acfmw4znnok****', position='Query'),
  siteName: string(name='SiteName', description='The website name.

This parameter is required.', example='CreateSite', position='Query'),
}

model CreateSiteResponseBody = {
  nameServerList?: string(name='NameServerList', description='The nameservers assigned by ESA. The values are separated by commas (,). This parameter is returned if you set AccessType to NS. In this case, you must change the nameservers of your domain to the assigned ones. Then, you can verify the domain ownership and activate your website.', example='ns1.example.com,ns2.example.com'),
  requestId?: string(name='RequestId', description='The request ID.', example='CB1A380B-09F0-41BB-3C82-72F8FD6DA2FE'),
  siteId?: long(name='SiteId', description='The website ID.', example='1234567890123'),
  verifyCode?: string(name='VerifyCode', description='The verification code for the website. If you set AccessType to CNAME, you need to add a TXT record whose hostname is **_esaauth.[websiteDomainName]** and record value is the value of VerifyCode to the DNS records of your domain. ****Then, you can verify the domain ownership and activate your website.', example='verify_aah9dioasmov****'),
}

model CreateSiteResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateSiteResponseBody(name='body'),
}

/**
  * @description *   Make sure that you have an available plan before you add a website.
  * *   Make sure that your website domain name has an ICP filing if the location you want to specify covers the Chinese mainland.
  * @param request  the request parameters of CreateSite  CreateSiteRequest
  * @return CreateSiteResponse
 */
async function createSite(request: CreateSiteRequest): CreateSiteResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateSite', 'POST', '/', 'json', false, 'json', request);
}

model CreateSiteCustomLogRequest {
  cookies?: [ string ](name='Cookies', description='The cookie fields.', shrink='json', position='Body'),
  requestHeaders?: [ string ](name='RequestHeaders', description='The request header fields.', shrink='json', position='Body'),
  responseHeaders?: [ string ](name='ResponseHeaders', description='The response header fields.', shrink='json', position='Body'),
  siteId?: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.', example='11223', position='Body'),
}

model CreateSiteCustomLogResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='073bd613-6e72-4461-b6bc-19326dfc6a9c'),
}

model CreateSiteCustomLogResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateSiteCustomLogResponseBody(name='body'),
}

/**
  * @description *   **Custom field limits**: The key name of a custom field can contain only letters, digits, underscores (_), and spaces. The key name cannot contain other characters. Otherwise, errors may occur.
  * *   **Parameter passing**: Submit `SiteId`, `RequestHeaders`, `ResponseHeaders`, and `Cookies` by using `formData`. Each array element matches a custom field name.
  * *   **(Required) SiteId**: Although `SiteId` is not marked as required in the Required column, you must specify a website ID by using this parameter when you can call this API operation.
  * @param request  the request parameters of CreateSiteCustomLog  CreateSiteCustomLogRequest
  * @return CreateSiteCustomLogResponse
 */
async function createSiteCustomLog(request: CreateSiteCustomLogRequest): CreateSiteCustomLogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateSiteCustomLog', 'POST', '/', 'json', true, 'form', request);
}

model CreateSiteDeliveryTaskRequest {
  businessType: string(name='BusinessType', description='The log category. Valid values:

*   **dcdn_log_access_l1** (default): access logs.
*   **dcdn_log_er**: Edge Routine logs.
*   **dcdn_log_waf**: firewall logs.
*   **dcdn_log_ipa**: TCP/UDP proxy logs.

This parameter is required.', example='dcdn_log_access_l1', position='Body'),
  dataCenter: string(name='DataCenter', description='The data center. Valid values:

*   cn: the Chinese mainland.
*   oversea: outside the Chinese mainland.

This parameter is required.', example='cn', position='Body'),
  deliveryType: string(name='DeliveryType', description='The destination of the delivery. Valid values:

*   sls: Alibaba Cloud Simple Log Service (SLS).
*   http: HTTP server.
*   aws3: Amazon Simple Storage Service (S3).
*   oss: Alibaba Cloud Object Storage Service (OSS).
*   kafka: Kafka.
*   aws3cmpt: S3-compatible storage service.

This parameter is required.', example='sls', position='Body'),
  discardRate?: float(name='DiscardRate', description='The discard rate. Default value: 0.', example='0.0', position='Body'),
  fieldName: string(name='FieldName', description='The log fields, which are separated by commas (,).

This parameter is required.', example='user_agent,ip_adress,ip_port', position='Body'),
  httpDelivery?: {
    compress?: string(name='Compress', description='The compression method. By default, data is not compressed.', example='gzip'),
    destUrl?: string(name='DestUrl', description='The address of the HTTP server.', example='http://xxx.aliyun.com/v1/log/upload'),
    headerParam?: map[string]HttpDeliveryHeaderParamValue(name='HeaderParam', description='The custom headers.'),
    logBodyPrefix?: string(name='LogBodyPrefix', description='The prefix of the log delivery package.', example='cdnVersion:1.0'),
    logBodySuffix?: string(name='LogBodySuffix', description='The suffix of the log delivery package.', example='cdnVersion:1.0'),
    maxBatchMB?: long(name='MaxBatchMB', description='The maximum size of data for each delivery. Unit: MB.', example='5'),
    maxBatchSize?: long(name='MaxBatchSize', description='The maximum number of entries for each delivery.', example='1000'),
    maxRetry?: long(name='MaxRetry', description='The maximum number of retries.', example='3'),
    queryParam?: map[string]HttpDeliveryQueryParamValue(name='QueryParam', description='The custom query parameters.'),
    standardAuthOn?: boolean(name='StandardAuthOn', description='Specifies whether to use server authentication.', example='true'),
    standardAuthParam?: {
      expiredTime?: int32(name='ExpiredTime', description='The validity period of the signature.

>  The value must be greater than 0. We recommend that you specify a value that is greater than 300.', example='300'),
      privateKey?: string(name='PrivateKey', description='The private key.', example='***'),
      urlPath?: string(name='UrlPath', description='The URI path for server authentication.', example='v1/log/upload'),
    }(name='StandardAuthParam', description='The authentication configurations.'),
    transformTimeout?: long(name='TransformTimeout', description='The timeout period. Unit: seconds.', example='10'),
  }(name='HttpDelivery', description='The configurations for delivery to an HTTP server.', shrink='json', position='Body'),
  kafkaDelivery?: {
    balancer?: string(name='Balancer', description='The load balancing method.', example='kafka.LeastBytes'),
    brokers?: [ string ](name='Brokers', description='The brokers.'),
    compress?: string(name='Compress', description='The compression method.', example='gzip'),
    machanismType?: string(name='MachanismType', description='The encryption method.', example='plain'),
    password?: string(name='Password', description='The password.', example='***'),
    topic?: string(name='Topic', description='The topic.', example='dqc_test2'),
    userAuth?: boolean(name='UserAuth', description='Specifies whether to enable authentication.', example='true'),
    userName?: string(name='UserName', description='The username.', example='xxx'),
  }(name='KafkaDelivery', description='The configurations for delivery to Kafka.', shrink='json', position='Body'),
  ossDelivery?: {
    aliuid?: string(name='Aliuid', description='The ID of your Alibaba Cloud account.', example='1234***'),
    bucketName?: string(name='BucketName', description='The name of the OSS bucket.', example='test_rlog'),
    prefixPath?: string(name='PrefixPath', description='The prefix of the path in which you want to store logs.', example='logriver-test/log'),
    region?: string(name='Region', description='The region in which the bucket is located.', example='cn-beijing'),
  }(name='OssDelivery', description='The configurations for delivery to OSS.', shrink='json', position='Body'),
  s3Delivery?: {
    accessKey?: string(name='AccessKey', description='The access key ID of your Amazon S3 account.', example='LTAIKh***'),
    bucketPath?: string(name='BucketPath', description='The directory in the bucket.', example='logriver-test/log'),
    endpoint?: string(name='Endpoint', description='The endpoint. This parameter is required when the S3Cmpt parameter is set to true.', example='https://s3.oss-cn-hangzhou.aliyuncs.com'),
    prefixPath?: string(name='PrefixPath', description='The prefix of the path in which you want to store logs.', example='logriver-test/log'),
    region?: string(name='Region', description='The region ID of the service.', example='cn-beijing'),
    s3Cmpt?: boolean(name='S3Cmpt', description='Specifies whether the service is compatible with Amazon S3.', example='true'),
    secretKey?: string(name='SecretKey', description='The secret access key of your Amazon S3 account.', example='LDSIKh***'),
    serverSideEncryption?: boolean(name='ServerSideEncryption'),
    vertifyType?: string(name='VertifyType'),
  }(name='S3Delivery', description='The configurations for delivery to Amazon S3 or an S3-compatible service.', shrink='json', position='Body'),
  siteId: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.

This parameter is required.', example='12312312112***', position='Body'),
  slsDelivery?: {
    SLSLogStore?: string(name='SLSLogStore', description='The name of the Logstore.', example='accesslog-test'),
    SLSProject?: string(name='SLSProject', description='The name of the SLS project.', example='dcdn-test20240417'),
    SLSRegion?: string(name='SLSRegion', description='The region in which the SLS project resides.', example='cn-hangzhou'),
  }(name='SlsDelivery', description='The configurations for delivery to SLS.', shrink='json', position='Body'),
  taskName: string(name='TaskName', description='The name of the delivery task.

This parameter is required.', example='dcdn-test-task', position='Body'),
}

model CreateSiteDeliveryTaskResponseBody = {
  dataCenter?: string(name='DataCenter', description='The data center. Valid values:

*   cn: the Chinese mainland.
*   oversea: outside the Chinese mainland.', example='cn'),
  requestId?: string(name='RequestId', description='The request ID.', example='9358E852-992D-5BC7-8BD7-975CA02773A8'),
  siteId?: string(name='SiteId', description='The website ID.[](~~2850189~~)', example='123456****'),
  taskName?: string(name='TaskName', description='The name of the delivery task.', example='er-oss'),
}

model CreateSiteDeliveryTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateSiteDeliveryTaskResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateSiteDeliveryTask  CreateSiteDeliveryTaskRequest
  * @return CreateSiteDeliveryTaskResponse
 */
async function createSiteDeliveryTask(request: CreateSiteDeliveryTaskRequest): CreateSiteDeliveryTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateSiteDeliveryTask', 'POST', '/', 'json', true, 'form', request);
}

model CreateUserDeliveryTaskRequest {
  businessType: string(name='BusinessType', description='The log category. Valid values:

*   dcdn_log_access_l1 (default): access logs.
*   dcdn_log_er: Edge Routine logs.
*   dcdn_log_waf: firewall logs.
*   dcdn_log_ipa: TCP/UDP proxy logs.

This parameter is required.', example='dcdn_log_access_l1', position='Body'),
  dataCenter: string(name='DataCenter', description='The data center. Valid values:

*   cn: the Chinese mainland.
*   sg: outside the Chinese mainland.

This parameter is required.', example='cn', position='Body'),
  deliveryType: string(name='DeliveryType', description='The destination of the delivery. Valid values:

1.  sls: Alibaba Cloud SLS.
2.  http: HTTP server.
3.  aws3: Amazon S3.
4.  oss: Alibaba Cloud OSS.
5.  kafka: Kafka.
6.  aws3cmpt: S3-compatible storage service.

This parameter is required.', example='sls', position='Body'),
  discardRate?: float(name='DiscardRate', description='The discard rate. Default value: 0.', example='0', position='Body'),
  fieldName: string(name='FieldName', description='The log field. If you specify multiple fields, separate them with commas (,).

This parameter is required.', example='user_agent,ip_address,ip_port', position='Body'),
  httpDelivery?: {
    compress?: string(name='Compress', description='The compression method.', example='gzip'),
    destUrl?: string(name='DestUrl', description='The address of the HTTP server.', example='http://xxx.aliyun.com/v1/log/upload'),
    headerParam?: map[string]HttpDeliveryHeaderParamValue(name='HeaderParam', description='The custom headers.'),
    lastLogSplit?: string(name='LastLogSplit', description='The ending separator.', example='\\n'),
    logBodyPrefix?: string(name='LogBodyPrefix', description='The prefix of the log delivery package.', example='cdnVersion:1.0'),
    logBodySuffix?: string(name='LogBodySuffix', description='The suffix of the log delivery package.', example='cdnVersion:1.0'),
    logSplit?: string(name='LogSplit', description='Specifies whether to enable log splitting. Default value: true.', example='true'),
    logSplitWords?: string(name='LogSplitWords', description='The log separator.', example='\\n'),
    maxBackoffMS?: long(name='MaxBackoffMS', description='The maximum backoff time. Unit: milliseconds.', example='1000'),
    maxBatchMB?: long(name='MaxBatchMB', description='The maximum size of data for each delivery. Unit: MB.', example='5'),
    maxBatchSize?: long(name='MaxBatchSize', description='The maximum number of entries for each delivery.', example='1000'),
    maxRetry?: long(name='MaxRetry', description='The maximum number of retries.', example='3'),
    minBackoffMS?: long(name='MinBackoffMS', description='The minimum backoff time. Unit: milliseconds.', example='100'),
    queryParam?: map[string]HttpDeliveryQueryParamValue(name='QueryParam', description='The custom query parameters.'),
    responseBodyKey?: string(name='ResponseBodyKey', description='The response field key used for success check.', example='err_code'),
    standardAuthOn?: boolean(name='StandardAuthOn', description='Specifies whether to use server authentication.', example='true'),
    standardAuthParam?: {
      expiredTime?: int32(name='ExpiredTime', description='The validity period of the signature.', example='300'),
      privateKey?: string(name='PrivateKey', description='The private key.', example='xxxx'),
      urlPath?: string(name='UrlPath', description='The URL path.', example='v1/log/upload'),
    }(name='StandardAuthParam', description='The authentication configurations.'),
    successCode?: long(name='SuccessCode', description='The custom code for a success.', example='200'),
    transformTimeout?: long(name='TransformTimeout', description='The timeout period. Unit: seconds.', example='10'),
  }(name='HttpDelivery', description='The configurations for delivery to an HTTP server.', shrink='json', position='Body'),
  kafkaDelivery?: {
    balancer?: string(name='Balancer', description='The load balancing method.', example='kafka.LeastBytes'),
    brokers?: [ string ](name='Brokers', description='The brokers.'),
    compress?: string(name='Compress', description='The compression method. By default, data is not compressed.', example='gzip'),
    machanismType?: string(name='MachanismType', description='The encryption method.', example='plain'),
    password?: string(name='Password', description='The password.', example='xxx'),
    topic?: string(name='Topic', description='The topic.', example='dqc_test2'),
    userAuth?: boolean(name='UserAuth', description='Specifies whether to enable authentication.', example='true'),
    userName?: string(name='UserName', description='The username.', example='xxx'),
  }(name='KafkaDelivery', description='The configurations for delivery to Kafka.', shrink='json', position='Body'),
  ossDelivery?: {
    aliuid?: string(name='Aliuid', description='The ID of your Alibaba Cloud account.', example='1234***'),
    bucketName?: string(name='BucketName', description='The name of the OSS bucket.', example='test_rlog'),
    prefixPath?: string(name='PrefixPath', description='The prefix of the path in which you want to store logs.', example='logriver-test/log'),
    region?: string(name='Region', description='The region in which the bucket is located.', example='cn-shanghai'),
  }(name='OssDelivery', description='The configurations for delivery to OSS.', shrink='json', position='Body'),
  s3Delivery?: {
    accessKey?: string(name='AccessKey', description='The access key ID of your Amazon S3 account.', example='g0f46623ll0g0'),
    bucketPath?: string(name='BucketPath', description='The directory in the bucket.', example='logriver-test/log'),
    endpoint?: string(name='Endpoint', description='The endpoint.', example='https://s3.oss-cn-hangzhou.aliyuncs.com'),
    prefixPath?: string(name='PrefixPath', description='The prefix of the path in which you want to store logs.', example='logriver-test/log'),
    region?: string(name='Region', description='The region ID of the service.', example='cn-shanghai'),
    s3Cmpt?: boolean(name='S3Cmpt', description='Specifies whether the service is compatible with Amazon S3.', example='true'),
    secretKey?: string(name='SecretKey', description='The secret access key of your Amazon S3 account.', example='***'),
    serverSideEncryption?: boolean(name='ServerSideEncryption'),
    vertifyType?: string(name='VertifyType'),
  }(name='S3Delivery', description='The configurations for delivery to Amazon S3 or an S3-compatible service.', shrink='json', position='Body'),
  slsDelivery?: {
    SLSLogStore?: string(name='SLSLogStore', description='The name of the SLS Logstore.', example='accesslog-test'),
    SLSProject?: string(name='SLSProject', description='The name of the SLS project.', example='dcdn-test20240417'),
    SLSRegion?: string(name='SLSRegion', description='The region in which the SLS project resides.', example='cn-hangzhou'),
  }(name='SlsDelivery', description='The configurations for delivery to SLS.', shrink='json', position='Body'),
  taskName: string(name='TaskName', description='The task name.

This parameter is required.', example='test_project', position='Body'),
}

model CreateUserDeliveryTaskResponseBody = {
  dataCenter?: string(name='DataCenter', description='The data center. Valid values:

*   cn: the Chinese mainland.
*   sg: outside the Chinese mainland.', example='cn'),
  requestId?: string(name='RequestId', description='The request ID.', example='2CCD40B1-3F20-5FF0-8A67-E3F34B87744F'),
  status?: string(name='Status', description='The status of the delivery task.', example='online'),
  taskName?: string(name='TaskName', description='The name of the delivery task.', example='er-http'),
}

model CreateUserDeliveryTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateUserDeliveryTaskResponseBody(name='body'),
}

/**
  * @description This API operation allows you to deliver logs to destinations such as Simple Log Service (SLS), HTTP servers, Object Storage Service (OSS), Amazon Simple Storage Service (S3), and Kafka. You can specify the task name, log fields to deliver, data center, discard rate, delivery type, and delivery details.
  * *   **Field filtering**: Use the `FieldName` parameter to specify log fields to deliver.
  * *   **Filtering rules**: Use the `FilterRules` parameter to pre-process and filter log data.
  * *   **Diverse delivery destinations**: Logs can be delivered to different destinations. Configuration parameters vary with delivery destinations.
  * ## [](#)Precautions
  * *   Make sure that you have sufficient permissions to perform delivery tasks.
  * *   If you enable encryption or authentication, properly configure corresponding parameters.
  * *   Verify the syntax of `FilterRules` to make sure that filtering logic works as expected.
  * *   Specify advanced settings such as the number of retries and timeout period based on your needs to have optimal delivery efficiency and stability.
  * @param request  the request parameters of CreateUserDeliveryTask  CreateUserDeliveryTaskRequest
  * @return CreateUserDeliveryTaskResponse
 */
async function createUserDeliveryTask(request: CreateUserDeliveryTaskRequest): CreateUserDeliveryTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateUserDeliveryTask', 'POST', '/', 'json', true, 'form', request);
}

model CreateWafRuleRequest {
  config?: WafRuleConfig(name='Config', description='The configuration of the rule that you want to create.', shrink='json', position='Body'),
  phase: string(name='Phase', description='The WAF rule category.

This parameter is required.', example='http_custom', position='Body'),
  siteId: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.

This parameter is required.', example='1', position='Query'),
  siteVersion?: int32(name='SiteVersion', description='The version of the website.', example='0', position='Query'),
}

model CreateWafRuleResponseBody = {
  id?: long(name='Id', description='The ID of the WAF rule.[](~~2850237~~)', example='20000001'),
  requestId?: string(name='RequestId', description='The request ID.', example='36af3fcc-43d0-441c-86b1-428951dc8225'),
  rulesetId?: long(name='RulesetId', description='The ID of the WAF ruleset.[](~~2850233~~)', example='10000001'),
}

model CreateWafRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateWafRuleResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateWafRule  CreateWafRuleRequest
  * @return CreateWafRuleResponse
 */
async function createWafRule(request: CreateWafRuleRequest): CreateWafRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateWafRule', 'POST', '/', 'json', true, 'form', request);
}

model CreateWaitingRoomRequest {
  cookieName: string(name='CookieName', description='The name of the custom cookie.

This parameter is required.', example='__aliwaitingroom_example', position='Query'),
  customPageHtml?: string(name='CustomPageHtml', description='The content of the custom waiting room page. You must specify this parameter if you set WaitingRoomType to custom. The content must be Base64-encoded.', example='Hello%20world!', position='Query'),
  description?: string(name='Description', description='The description of the waiting room.', position='Query'),
  disableSessionRenewalEnable?: string(name='DisableSessionRenewalEnable', description='Specifies whether to disable session renewal. Valid values:

*   on
*   off', example='on', position='Query'),
  enable: string(name='Enable', description='Specifies whether to enable the waiting room. Valid values:

*   on
*   off

This parameter is required.', example='on', position='Query'),
  hostNameAndPath: [ 
    {
      domain: string(name='Domain', description='The domain name.

This parameter is required.', example='example.com'),
      path: string(name='Path', description='The path.

This parameter is required.', example='/test'),
      subdomain: string(name='Subdomain', description='The subdomain.

This parameter is required.', example='test.'),
    }
  ](name='HostNameAndPath', description='The hostname and path.

This parameter is required.', shrink='json', position='Query'),
  jsonResponseEnable?: string(name='JsonResponseEnable', description='Specifies whether to enable JSON response. If you set this parameter to on, a JSON body is returned for requests to the waiting room with the header Accept: application/json. Valid values:

*   on
*   off', example='on', position='Query'),
  language?: string(name='Language', description='The language of the waiting room page. You must specify this parameter if you set WaitingRoomType to default. Valid values:

*   enus: English.
*   zhcn: Simplified Chinese.
*   zhhk: Traditional Chinese.', example='enus', position='Query'),
  name: string(name='Name', description='The name of the waiting room.

This parameter is required.', example='waitingroom_example', position='Query'),
  newUsersPerMinute: string(name='NewUsersPerMinute', description='The maximum number of new users per minute.

This parameter is required.', example='200', position='Query'),
  queueAllEnable?: string(name='QueueAllEnable', description='Specifies whether to queue all requests. Valid values:

*   on
*   off', example='on', position='Query'),
  queuingMethod: string(name='QueuingMethod', description='The queuing method. Valid values:

*   random: Users gain access to the origin randomly, regardless of the arrival time.
*   fifo: Users gain access to the origin in order of arrival.
*   passthrough: Users pass through the waiting room and go straight to the origin.
*   reject-all: Users are blocked from reaching the origin.

This parameter is required.', example='fifo', position='Query'),
  queuingStatusCode: string(name='QueuingStatusCode', description='The HTTP status code to return while a user is in the queue. Valid values:

*   200
*   202
*   429

This parameter is required.', example='200', position='Query'),
  sessionDuration: string(name='SessionDuration', description='The maximum duration for which a session remains valid after a user leaves the origin. Unit: minutes.

This parameter is required.', example='5', position='Query'),
  siteId: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.

This parameter is required.', example='1234567890123', position='Query'),
  totalActiveUsers: string(name='TotalActiveUsers', description='The maximum number of active users.

This parameter is required.', example='300', position='Query'),
  waitingRoomType: string(name='WaitingRoomType', description='The type of the waiting room. Valid values:

*   default
*   custom

This parameter is required.', example='default', position='Query'),
}

model CreateWaitingRoomResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='85H66C7B-671A-4297-9187-2C4477247A74'),
}

model CreateWaitingRoomResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateWaitingRoomResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateWaitingRoom  CreateWaitingRoomRequest
  * @return CreateWaitingRoomResponse
 */
async function createWaitingRoom(request: CreateWaitingRoomRequest): CreateWaitingRoomResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateWaitingRoom', 'POST', '/', 'json', false, 'json', request);
}

model CreateWaitingRoomEventRequest {
  customPageHtml?: string(name='CustomPageHtml', description='The content of the custom waiting room page. You must specify this parameter if you set WaitingRoomType to custom. The content must be Base64-encoded.', example='Hello%20world!', position='Query'),
  description?: string(name='Description', description='The description of the waiting room.', position='Query'),
  disableSessionRenewalEnable?: string(name='DisableSessionRenewalEnable', description='Specifies whether to disable session renewal. Valid values:

*   on
*   off', example='on', position='Query'),
  enable: string(name='Enable', description='Specifies whether to enable the waiting room. Valid values:

*   on
*   off

This parameter is required.', example='on', position='Query'),
  endTime: string(name='EndTime', description='The end time of the event. This value is a UNIX timestamp.

This parameter is required.', example='1719849600', position='Query'),
  jsonResponseEnable?: string(name='JsonResponseEnable', description='Specifies whether to enable JSON response. If you set this parameter to on, a JSON body is returned for requests to the waiting room with the header Accept: application/json. Valid values:

*   on
*   off', example='on', position='Query'),
  language?: string(name='Language', description='The language of the waiting room page. You must specify this parameter if you set WaitingRoomType to default. Valid values:

*   enus: English.
*   zhcn: Simplified Chinese.
*   zhhk: Traditional Chinese.', example='zhcn', position='Query'),
  name: string(name='Name', description='The name of the waiting room event.

This parameter is required.', example='waitingroom_example', position='Query'),
  newUsersPerMinute: string(name='NewUsersPerMinute', description='The maximum number of new users per minute.

This parameter is required.', example='10', position='Query'),
  preQueueEnable?: string(name='PreQueueEnable', description='Specifies whether to enable pre-queuing.

*   on
*   off', example='on', position='Query'),
  preQueueStartTime?: string(name='PreQueueStartTime', description='The start time for pre-queuing.', example='1719763200', position='Query'),
  queuingMethod: string(name='QueuingMethod', description='The queuing method. Valid values:

*   random: Users gain access to the origin randomly, regardless of the arrival time.
*   fifo: Users gain access to the origin in order of arrival.
*   passthrough: Users pass through the waiting room and go straight to the origin.
*   reject-all: Users are blocked from reaching the origin.

This parameter is required.', example='random', position='Query'),
  queuingStatusCode: string(name='QueuingStatusCode', description='The HTTP status code to return while a user is in the queue. Valid values:

*   200
*   202
*   429

This parameter is required.', example='202', position='Query'),
  randomPreQueueEnable?: string(name='RandomPreQueueEnable', description='Specifies whether to enable random queuing.

*   on
*   off', example='on', position='Query'),
  sessionDuration: string(name='SessionDuration', description='The maximum duration for which a session remains valid after a user leaves the origin. Unit: minutes.

This parameter is required.', example='5', position='Query'),
  siteId: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.

This parameter is required.', example='123456****', position='Query'),
  startTime: string(name='StartTime', description='The start time of the event. This value is a UNIX timestamp.

This parameter is required.', example='1719763200', position='Query'),
  totalActiveUsers: string(name='TotalActiveUsers', description='The maximum number of active users.

This parameter is required.', example='100', position='Query'),
  waitingRoomId?: string(name='WaitingRoomId', description='The ID of the waiting room, which can be obtained by calling the [ListWaitingRooms](https://help.aliyun.com/document_detail/2850279.html) operation.', example='6a51d5bc6460887abd1291dc7d4db28b', position='Query'),
  waitingRoomType: string(name='WaitingRoomType', description='The type of the waiting room. Valid values:

*   default
*   custom

This parameter is required.', example='default', position='Query'),
}

model CreateWaitingRoomEventResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='15C66C7B-671A-4297-9187-2C4477247A123425345'),
}

model CreateWaitingRoomEventResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateWaitingRoomEventResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateWaitingRoomEvent  CreateWaitingRoomEventRequest
  * @return CreateWaitingRoomEventResponse
 */
async function createWaitingRoomEvent(request: CreateWaitingRoomEventRequest): CreateWaitingRoomEventResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateWaitingRoomEvent', 'POST', '/', 'json', false, 'json', request);
}

model CreateWaitingRoomRuleRequest {
  rule: string(name='Rule', description='The rule content, which is a policy or conditional expression.

This parameter is required.', example='(http.request.uri.path.file_name eq \\"jpg\\")', position='Query'),
  ruleEnable: string(name='RuleEnable', description='Specifies whether to enable the rule. Valid values:

*   on
*   off

This parameter is required.', example='on', position='Query'),
  ruleName: string(name='RuleName', description='The rule name.

This parameter is required.', example='waitingroom_example', position='Query'),
  siteId: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.

This parameter is required.', example='123456****', position='Query'),
  waitingRoomId: string(name='WaitingRoomId', description='The ID of the waiting room to be bypassed.

This parameter is required.', example='25133f536f1b1f6b6091f6a92c614dd4', position='Query'),
}

model CreateWaitingRoomRuleResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='EEEBE525-F576-1196-8DAF-2D70CA3F4D2F'),
}

model CreateWaitingRoomRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateWaitingRoomRuleResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateWaitingRoomRule  CreateWaitingRoomRuleRequest
  * @return CreateWaitingRoomRuleResponse
 */
async function createWaitingRoomRule(request: CreateWaitingRoomRuleRequest): CreateWaitingRoomRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateWaitingRoomRule', 'POST', '/', 'json', false, 'json', request);
}

model DeleteCertificateRequest {
  id: string(name='Id', description='This parameter is required.', example='babaded901474b9693acf530e0fb1d95', position='Query'),
  siteId: long(name='SiteId', description='This parameter is required.', example='1234567890123', position='Query'),
}

model DeleteCertificateResponseBody = {
  id?: string(name='Id', example='babaded901474b9693acf530e0fb1d95'),
  requestId?: string(name='RequestId', example='F32C57AA-7BF8-49AE-A2CC-9F42390F5A19'),
  siteId?: long(name='SiteId', example='1234567890123'),
  siteName?: string(name='SiteName', example='example.com'),
}

model DeleteCertificateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteCertificateResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteCertificate  DeleteCertificateRequest
  * @return DeleteCertificateResponse
 */
async function deleteCertificate(request: DeleteCertificateRequest): DeleteCertificateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteCertificate', 'GET', '/', 'json', false, 'json', request);
}

model DeleteClientCaCertificateRequest {
  id: string(name='Id', description='This parameter is required.', example='baba39055622c008b90285a8838ed09a', position='Query'),
  siteId: long(name='SiteId', description='This parameter is required.', example='1234567890123', position='Query'),
}

model DeleteClientCaCertificateResponseBody = {
  id?: string(name='Id', example='baba39055622c008b90285a8838ed09a'),
  requestId?: string(name='RequestId', example='CB1A380B-09F0-41BB-280B-72F8FD6DA2FE'),
  siteId?: long(name='SiteId', example='1234567890123'),
  siteName?: string(name='SiteName', example='example.com'),
}

model DeleteClientCaCertificateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteClientCaCertificateResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteClientCaCertificate  DeleteClientCaCertificateRequest
  * @return DeleteClientCaCertificateResponse
 */
async function deleteClientCaCertificate(request: DeleteClientCaCertificateRequest): DeleteClientCaCertificateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteClientCaCertificate', 'GET', '/', 'json', false, 'json', request);
}

model DeleteClientCertificateRequest {
  id: string(name='Id', description='This parameter is required.', example='baba39055622c008b90285a8838ed09a', position='Query'),
  siteId: long(name='SiteId', description='This parameter is required.', example='1234567890123', position='Query'),
}

model DeleteClientCertificateResponseBody = {
  id?: string(name='Id', example='baba39055622c008b90285a8838ed09a'),
  requestId?: string(name='RequestId', example='15C66C7B-671A-4297-9187-2C4477247A74'),
  siteId?: long(name='SiteId', example='1234567890123'),
  siteName?: string(name='SiteName', example='example.com'),
}

model DeleteClientCertificateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteClientCertificateResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteClientCertificate  DeleteClientCertificateRequest
  * @return DeleteClientCertificateResponse
 */
async function deleteClientCertificate(request: DeleteClientCertificateRequest): DeleteClientCertificateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteClientCertificate', 'GET', '/', 'json', false, 'json', request);
}

model DeleteCustomScenePolicyRequest {
  policyId: long(name='PolicyId', description='The policy ID, which can be obtained by calling the [DescribeCustomScenePolicies](https://help.aliyun.com/document_detail/2850508.html) operation.

This parameter is required.', example='1', minimum=1, position='Query'),
}

model DeleteCustomScenePolicyResponseBody = {
  policyId?: long(name='PolicyId', description='The policy ID.', example='1'),
  requestId?: string(name='RequestId', description='The request ID.', example='5CC228B4-7A67-4016-9C9F-4A4133494A91'),
}

model DeleteCustomScenePolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteCustomScenePolicyResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteCustomScenePolicy  DeleteCustomScenePolicyRequest
  * @return DeleteCustomScenePolicyResponse
 */
async function deleteCustomScenePolicy(request: DeleteCustomScenePolicyRequest): DeleteCustomScenePolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteCustomScenePolicy', 'POST', '/', 'json', false, 'json', request);
}

model DeleteEdgeContainerAppRequest {
  appId?: string(name='AppId', description='The application ID, which can be obtained by calling the [ListEdgeContainerApps](~~ListEdgeContainerApps~~) operation.', example='app-1232321454***', position='Query'),
}

model DeleteEdgeContainerAppResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
  state?: string(name='State', description='Specifies whether the deletion is successful.', example='ok'),
}

model DeleteEdgeContainerAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteEdgeContainerAppResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteEdgeContainerApp  DeleteEdgeContainerAppRequest
  * @return DeleteEdgeContainerAppResponse
 */
async function deleteEdgeContainerApp(request: DeleteEdgeContainerAppRequest): DeleteEdgeContainerAppResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteEdgeContainerApp', 'POST', '/', 'json', false, 'json', request);
}

model DeleteEdgeContainerAppRecordRequest {
  appId: string(name='AppId', description='The application ID.

This parameter is required.', example='app-88068867578379****', minLength=20, maxLength=64, position='Body'),
  recordName: string(name='RecordName', description='The associated domain name.

This parameter is required.', example='a.example.com', maxLength=1024, position='Body'),
  siteId?: long(name='SiteId', description='The website ID.', example='5407498413****', position='Body'),
}

model DeleteEdgeContainerAppRecordResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model DeleteEdgeContainerAppRecordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteEdgeContainerAppRecordResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteEdgeContainerAppRecord  DeleteEdgeContainerAppRecordRequest
  * @return DeleteEdgeContainerAppRecordResponse
 */
async function deleteEdgeContainerAppRecord(request: DeleteEdgeContainerAppRecordRequest): DeleteEdgeContainerAppRecordResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteEdgeContainerAppRecord', 'POST', '/', 'json', true, 'form', request);
}

model DeleteEdgeContainerAppVersionRequest {
  appId: string(name='AppId', description='The application ID, which can be obtained by calling the [ListEdgeContainerApps](~~ListEdgeContainerApps~~) operation.

This parameter is required.', example='app-96253477062511****', position='Query'),
  versionId: string(name='VersionId', description='The ID of the version that you want to delete. To obtain the version ID, call the [ListEdgeContainerAppVersions](~~ListEdgeContainerAppVersions~~) operation.

This parameter is required.', example='ver-89884764010378****', position='Query'),
}

model DeleteEdgeContainerAppVersionResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='b021e538-9dde-46ed-a1f2-9469da8f3e77'),
}

model DeleteEdgeContainerAppVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteEdgeContainerAppVersionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteEdgeContainerAppVersion  DeleteEdgeContainerAppVersionRequest
  * @return DeleteEdgeContainerAppVersionResponse
 */
async function deleteEdgeContainerAppVersion(request: DeleteEdgeContainerAppVersionRequest): DeleteEdgeContainerAppVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteEdgeContainerAppVersion', 'POST', '/', 'json', false, 'json', request);
}

model DeleteKvRequest {
  key: string(name='Key', description='The name of the key that you want to delete.

This parameter is required.', example='test_key', position='Query'),
  namespace: string(name='Namespace', description='The name of the namespace that you specify when you call the [CreateKvNamespace](https://help.aliyun.com/document_detail/2850317.html) operation.

This parameter is required.', example='test_namespace', position='Query'),
}

model DeleteKvResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='EEEBE525-F576-1196-8DAF-2D70CA3F4D2F'),
}

model DeleteKvResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteKvResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteKv  DeleteKvRequest
  * @return DeleteKvResponse
 */
async function deleteKv(request: DeleteKvRequest): DeleteKvResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteKv', 'GET', '/', 'json', false, 'json', request);
}

model DeleteKvNamespaceRequest {
  namespace: string(name='Namespace', description='The name of the namespace that you specify when you call the [CreateKvNamespace](https://help.aliyun.com/document_detail/2850317.html) operation.

This parameter is required.', example='test_namespace', position='Query'),
}

model DeleteKvNamespaceResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='EEEBE525-F576-1196-8DAF-2D70CA3F4D2F'),
}

model DeleteKvNamespaceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteKvNamespaceResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteKvNamespace  DeleteKvNamespaceRequest
  * @return DeleteKvNamespaceResponse
 */
async function deleteKvNamespace(request: DeleteKvNamespaceRequest): DeleteKvNamespaceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteKvNamespace', 'POST', '/', 'json', false, 'json', request);
}

model DeleteListRequest {
  id: long(name='Id', description='The ID of the custom list, which can be obtained by calling the [ListLists](https://help.aliyun.com/document_detail/2850217.html) operation.

This parameter is required.', example='40000001', position='Body'),
}

model DeleteListResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='36af3fcc-43d0-441c-86b1-428951dc8225'),
}

model DeleteListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteListResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteList  DeleteListRequest
  * @return DeleteListResponse
 */
async function deleteList(request: DeleteListRequest): DeleteListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteList', 'POST', '/', 'json', true, 'form', request);
}

model DeleteOriginProtectionRequest {
  siteId: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.

This parameter is required.', example='123456****', position='Query'),
}

model DeleteOriginProtectionResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='CB1A380B-09F0-41BB-A198-72F8FD6DA2FE'),
}

model DeleteOriginProtectionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteOriginProtectionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteOriginProtection  DeleteOriginProtectionRequest
  * @return DeleteOriginProtectionResponse
 */
async function deleteOriginProtection(request: DeleteOriginProtectionRequest): DeleteOriginProtectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteOriginProtection', 'POST', '/', 'json', false, 'json', request);
}

model DeletePageRequest {
  id: long(name='Id', description='The ID of the custom error page, which can be obtained by calling the [ListPages](https://help.aliyun.com/document_detail/2850223.html) operation.

This parameter is required.', example='50000001', position='Body'),
}

model DeletePageResponseBody = {
  id?: long(name='Id', description='The ID of the custom error page.[](~~2850223~~)', example='50000001'),
  requestId?: string(name='RequestId', description='The request ID.', example='36af3fcc-43d0-441c-86b1-428951dc8225'),
}

model DeletePageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeletePageResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeletePage  DeletePageRequest
  * @return DeletePageResponse
 */
async function deletePage(request: DeletePageRequest): DeletePageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeletePage', 'POST', '/', 'json', true, 'form', request);
}

model DeleteRecordRequest {
  recordId: long(name='RecordId', description='The record ID, which can be obtained by calling [ListRecords](https://help.aliyun.com/document_detail/2850265.html).

This parameter is required.', example='1234567890123', position='Query'),
}

model DeleteRecordResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='F61CDR30-E83C-4FDA-BF73-9A94CDD44229'),
}

model DeleteRecordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteRecordResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteRecord  DeleteRecordRequest
  * @return DeleteRecordResponse
 */
async function deleteRecord(request: DeleteRecordRequest): DeleteRecordResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteRecord', 'POST', '/', 'json', false, 'json', request);
}

model DeleteRoutineRequest {
  name: string(name='Name', description='The routine name.

This parameter is required.', example='test-routine1', position='Body'),
}

model DeleteRoutineResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='EDBD3EB3-97DA-5465-AEF5-8DCA5DC5E395'),
  status?: string(name='Status', description='Indicates whether the operation is successful.', example='OK'),
}

model DeleteRoutineResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteRoutineResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteRoutine  DeleteRoutineRequest
  * @return DeleteRoutineResponse
 */
async function deleteRoutine(request: DeleteRoutineRequest): DeleteRoutineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteRoutine', 'POST', '/', 'json', true, 'form', request);
}

model DeleteRoutineCodeVersionRequest {
  codeVersion: string(name='CodeVersion', description='The code version.

This parameter is required.', example='1710120201067203242', position='Body'),
  name: string(name='Name', description='The routine name.

This parameter is required.', example='test-routine1', position='Body'),
}

model DeleteRoutineCodeVersionResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='EDBD3EB3-97DA-5465-AEF5-8DCA5DC5E395'),
  status?: string(name='Status', description='Indicates whether the operation is successful.', example='OK'),
}

model DeleteRoutineCodeVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteRoutineCodeVersionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteRoutineCodeVersion  DeleteRoutineCodeVersionRequest
  * @return DeleteRoutineCodeVersionResponse
 */
async function deleteRoutineCodeVersion(request: DeleteRoutineCodeVersionRequest): DeleteRoutineCodeVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteRoutineCodeVersion', 'POST', '/', 'json', true, 'form', request);
}

model DeleteRoutineRelatedRecordRequest {
  name: string(name='Name', description='The routine name.

This parameter is required.', example='DeleteRoutineRelatedRecord', position='Body'),
  recordId: long(name='RecordId', description='The record ID.

This parameter is required.', example='12345', position='Body'),
  recordName: string(name='RecordName', description='The record name.

This parameter is required.', example='test-xxx.example.com', position='Body'),
  siteId: long(name='SiteId', description='The website ID.

This parameter is required.', example='12345', position='Query'),
}

model DeleteRoutineRelatedRecordResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='EDBD3EB3-97DA-5465-AEF5-8DCA5DC5E395'),
  status?: string(name='Status', description='Indicates whether the operation is successful.

*   OK
*   Fail', example='OK'),
}

model DeleteRoutineRelatedRecordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteRoutineRelatedRecordResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteRoutineRelatedRecord  DeleteRoutineRelatedRecordRequest
  * @return DeleteRoutineRelatedRecordResponse
 */
async function deleteRoutineRelatedRecord(request: DeleteRoutineRelatedRecordRequest): DeleteRoutineRelatedRecordResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteRoutineRelatedRecord', 'POST', '/', 'json', true, 'form', request);
}

model DeleteRoutineRelatedRouteRequest {
  name: string(name='Name', description='The routine name.

This parameter is required.', example='DeleteRoutineRelatedRoute', position='Body'),
  route: string(name='Route', description='The route URL.

This parameter is required.', example='*.example.com/path1*', position='Body'),
  routeId: string(name='RouteId', description='The route ID.

This parameter is required.', example='0c3b82a3d1524e9f750da11d0cc0be0a', position='Body'),
  siteId: long(name='SiteId', description='The website ID.

This parameter is required.', example='54362329990032', position='Body'),
}

model DeleteRoutineRelatedRouteResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='EDBD3EB3-97DA-5465-AEF5-8DCA5DC5E395'),
  status?: string(name='Status', description='Indicates whether the operation is successful.', example='OK'),
}

model DeleteRoutineRelatedRouteResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteRoutineRelatedRouteResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteRoutineRelatedRoute  DeleteRoutineRelatedRouteRequest
  * @return DeleteRoutineRelatedRouteResponse
 */
async function deleteRoutineRelatedRoute(request: DeleteRoutineRelatedRouteRequest): DeleteRoutineRelatedRouteResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteRoutineRelatedRoute', 'POST', '/', 'json', true, 'form', request);
}

model DeleteScheduledPreloadExecutionRequest {
  id: string(name='Id', description='The ID of the prefetch plan.

This parameter is required.', example='DeleteScheduledPreloadExecution', position='Query'),
}

model DeleteScheduledPreloadExecutionResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model DeleteScheduledPreloadExecutionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteScheduledPreloadExecutionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteScheduledPreloadExecution  DeleteScheduledPreloadExecutionRequest
  * @return DeleteScheduledPreloadExecutionResponse
 */
async function deleteScheduledPreloadExecution(request: DeleteScheduledPreloadExecutionRequest): DeleteScheduledPreloadExecutionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteScheduledPreloadExecution', 'POST', '/', 'json', false, 'json', request);
}

model DeleteScheduledPreloadJobRequest {
  id: string(name='Id', description='The ID of the scheduled prefetch task.

This parameter is required.', example='DeleteScheduledPreloadJob', position='Query'),
}

model DeleteScheduledPreloadJobResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='C370DAF1-C838-4288-A1A0-9A87633D248E'),
}

model DeleteScheduledPreloadJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteScheduledPreloadJobResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteScheduledPreloadJob  DeleteScheduledPreloadJobRequest
  * @return DeleteScheduledPreloadJobResponse
 */
async function deleteScheduledPreloadJob(request: DeleteScheduledPreloadJobRequest): DeleteScheduledPreloadJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteScheduledPreloadJob', 'POST', '/', 'json', false, 'json', request);
}

model DeleteSiteRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  siteId?: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.', example='1234567890123', position='Query'),
}

model DeleteSiteResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='15C66C7B-671A-4297-9187-2C4477247B78'),
}

model DeleteSiteResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteSiteResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteSite  DeleteSiteRequest
  * @return DeleteSiteResponse
 */
async function deleteSite(request: DeleteSiteRequest): DeleteSiteResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteSite', 'POST', '/', 'json', false, 'json', request);
}

model DeleteSiteDeliveryTaskRequest {
  siteId: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.

This parameter is required.', example='123456******', position='Body'),
  taskName: string(name='TaskName', description='The name of the delivery task.

This parameter is required.', example='cdn-test-task', position='Body'),
}

model DeleteSiteDeliveryTaskResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='F61CDR30-E83C-4FDA-BF73-9A94CDD44229'),
}

model DeleteSiteDeliveryTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteSiteDeliveryTaskResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteSiteDeliveryTask  DeleteSiteDeliveryTaskRequest
  * @return DeleteSiteDeliveryTaskResponse
 */
async function deleteSiteDeliveryTask(request: DeleteSiteDeliveryTaskRequest): DeleteSiteDeliveryTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteSiteDeliveryTask', 'POST', '/', 'json', true, 'form', request);
}

model DeleteUserDeliveryTaskRequest {
  taskName: string(name='TaskName', description='The name of the delivery task.

This parameter is required.', example='test-project', position='Body'),
}

model DeleteUserDeliveryTaskResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='952ea16b-1f05-4a76-bb32-420282d8aeb9'),
}

model DeleteUserDeliveryTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteUserDeliveryTaskResponseBody(name='body'),
}

/**
  * @description ******> 
  * *   Deleted tasks cannot be restored. Proceed with caution.
  * *   To call this operation, you must have an account that has the required permissions.
  * *   The returned `RequestId` value can be used to track the request processing progress and troubleshoot issues.
  * @param request  the request parameters of DeleteUserDeliveryTask  DeleteUserDeliveryTaskRequest
  * @return DeleteUserDeliveryTaskResponse
 */
async function deleteUserDeliveryTask(request: DeleteUserDeliveryTaskRequest): DeleteUserDeliveryTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteUserDeliveryTask', 'POST', '/', 'json', true, 'form', request);
}

model DeleteWafRuleRequest {
  id: long(name='Id', description='The ID of the WAF rule, which can be obtained by calling the [ListWafRules](https://help.aliyun.com/document_detail/2850237.html) operation.

This parameter is required.', example='20000001', position='Body'),
  siteId: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.

This parameter is required.', example='1', position='Query'),
  siteVersion?: int32(name='SiteVersion', description='The version of the website.', example='1', position='Query'),
}

model DeleteWafRuleResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='36af3fcc-43d0-441c-86b1-428951dc8225'),
}

model DeleteWafRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteWafRuleResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteWafRule  DeleteWafRuleRequest
  * @return DeleteWafRuleResponse
 */
async function deleteWafRule(request: DeleteWafRuleRequest): DeleteWafRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteWafRule', 'POST', '/', 'json', true, 'form', request);
}

model DeleteWafRulesetRequest {
  id: long(name='Id', description='The ID of the WAF ruleset, which can be obtained by calling the [ListWafRulesets](https://help.aliyun.com/document_detail/2850233.html) operation.

This parameter is required.', example='10000001', position='Body'),
  siteId?: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.', example='1', position='Query'),
  siteVersion?: int32(name='SiteVersion', description='The version of the website.', example='1', position='Query'),
}

model DeleteWafRulesetResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='36af3fcc-43d0-441c-86b1-428951dc8225'),
}

model DeleteWafRulesetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteWafRulesetResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteWafRuleset  DeleteWafRulesetRequest
  * @return DeleteWafRulesetResponse
 */
async function deleteWafRuleset(request: DeleteWafRulesetRequest): DeleteWafRulesetResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteWafRuleset', 'POST', '/', 'json', true, 'form', request);
}

model DeleteWaitingRoomRequest {
  siteId: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.

This parameter is required.', example='123456****', position='Query'),
  waitingRoomId: string(name='WaitingRoomId', description='The waiting room ID.

This parameter is required.', example='25133f536f1b1f6b6091f6a92c614dd4', position='Query'),
}

model DeleteWaitingRoomResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='15C66C7B-671A-4297-9187-2C4477247A123425345'),
}

model DeleteWaitingRoomResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteWaitingRoomResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteWaitingRoom  DeleteWaitingRoomRequest
  * @return DeleteWaitingRoomResponse
 */
async function deleteWaitingRoom(request: DeleteWaitingRoomRequest): DeleteWaitingRoomResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteWaitingRoom', 'POST', '/', 'json', false, 'json', request);
}

model DeleteWaitingRoomEventRequest {
  siteId: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.

This parameter is required.', example='123456****', position='Query'),
  waitingRoomEventId?: long(name='WaitingRoomEventId', description='The ID of the waiting room event.', example='302909890***', position='Query'),
}

model DeleteWaitingRoomEventResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='0AEDAF20-4DDF-4165-8750-47FF9C1929C9'),
}

model DeleteWaitingRoomEventResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteWaitingRoomEventResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteWaitingRoomEvent  DeleteWaitingRoomEventRequest
  * @return DeleteWaitingRoomEventResponse
 */
async function deleteWaitingRoomEvent(request: DeleteWaitingRoomEventRequest): DeleteWaitingRoomEventResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteWaitingRoomEvent', 'POST', '/', 'json', false, 'json', request);
}

model DeleteWaitingRoomRuleRequest {
  siteId: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.

This parameter is required.', example='123456****', position='Query'),
  waitingRoomRuleId?: long(name='WaitingRoomRuleId', description='The ID of the waiting room bypass rule.', example='3672886****', position='Query'),
}

model DeleteWaitingRoomRuleResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='15C66C7B-671A-4297-9187-2C4477247A74'),
}

model DeleteWaitingRoomRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteWaitingRoomRuleResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteWaitingRoomRule  DeleteWaitingRoomRuleRequest
  * @return DeleteWaitingRoomRuleResponse
 */
async function deleteWaitingRoomRule(request: DeleteWaitingRoomRuleRequest): DeleteWaitingRoomRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteWaitingRoomRule', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCustomScenePoliciesRequest {
  pageNumber: int32(name='PageNumber', description='The page number. Valid values: 1 to 100000.

This parameter is required.', example='1', minimum=1, maximum=100000, position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 10. Valid values: 5, 10, and 20.', example='10', position='Query'),
  policyId?: long(name='PolicyId', description='The ID of the policy, which can be obtained by calling the [ListWafRulesets](https://help.aliyun.com/document_detail/2850233.html) operation.', example='1234****', minimum=0, position='Query'),
}

model DescribeCustomScenePoliciesResponseBody = {
  dataModule?: [ 
    {
      endTime?: string(name='EndTime', description='The time when the policy expires.

The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.', example='2023-03-06T16:00:00Z'),
      name?: string(name='Name', description='The name of the scenario-specific policy.', example='test'),
      objects?: [ string ](name='Objects', description='The IDs of websites that are associated with the policy.'),
      policyId?: long(name='PolicyId', description='The policy ID.', example='1234****'),
      startTime?: string(name='StartTime', description='The time when the policy takes effect.

The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.', example='2023-03-04T16:00:00Z'),
      status?: string(name='Status', description='The status of the policy. Valid values:

*   **Disabled**
*   **Pending**
*   **Running**
*   **Expired**', example='Expired'),
      template?: string(name='Template', description='The name of the policy template. Valid value:

*   **promotion**: major events.', example='promotion'),
    }
  ](name='DataModule', description='The scenario-specific policies.'),
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
  quota?: int32(name='Quota', description='The policy quota.', example='10'),
  requestId?: string(name='RequestId', description='The request ID.', example='85H66C7B-671A-4297-9187-2C4477247A74'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='1'),
}

model DescribeCustomScenePoliciesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCustomScenePoliciesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeCustomScenePolicies  DescribeCustomScenePoliciesRequest
  * @return DescribeCustomScenePoliciesResponse
 */
async function describeCustomScenePolicies(request: DescribeCustomScenePoliciesRequest): DescribeCustomScenePoliciesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCustomScenePolicies', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDDoSAllEventListRequest {
  endTime?: string(name='EndTime', description='The end of the time range to query.

Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. The maximum time range is 31 days.

If you do not configure this parameter, the current time is used as the end of the time range to query.', example='2023-02-22T15:59:59Z', position='Query'),
  eventType?: string(name='EventType', description='The type of DDoS attacks to query. Valid values:

*   **web-cc**: web resource exhaustion attacks.
*   **cc**: connection flood attacks.
*   **traffic**: volumetric attacks.

Default value: web-cc.', example='web-cc', position='Query'),
  pageNumber: int32(name='PageNumber', description='The page number. Valid values: **1** to **100000**.

This parameter is required.', example='1', minimum=1, maximum=100000, position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: **10**. Valid values: 5, 10, and 20.', example='10', position='Query'),
  siteId: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.

This parameter is required.', example='7096621098****', minimum=1, position='Query'),
  startTime: string(name='StartTime', description='The beginning of the time range to query.

Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

This parameter is required.', example='2023-02-12T15:00:00Z', position='Query'),
}

model DescribeDDoSAllEventListResponseBody = {
  dataList?: [ 
    {
      bps?: long(name='Bps', description='The peak of volumetric attacks. Unit: bit/s.', example='800'),
      coverage?: string(name='Coverage'),
      cps?: long(name='Cps', description='The peak of connection flood attacks. Unit: connections per seconds (CPS).', example='50'),
      endTime?: string(name='EndTime', description='The time when the DDoS attack ends.

The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.', example='2023-02-12T15:59:59Z'),
      eventId?: string(name='EventId', description='The attack event ID.', example='web-cc_1'),
      eventResult?: string(name='EventResult'),
      eventType?: string(name='EventType', description='The type of DDoS attacks that was queried. Valid values:

*   **web-cc**: web resource exhaustion attacks.
*   **cc**: connection flood attacks.
*   **traffic**: volumetric attacks.', example='web-cc'),
      pps?: long(name='Pps', description='The peak of volumetric attacks. Unit: packets per second (PPS).', example='12000'),
      qps?: long(name='Qps', description='The peak QPS of web resource exhaustion attacks.', example='7692'),
      startTime?: string(name='StartTime', description='The time when the DDoS attack starts.

The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.', example='2023-02-12T15:00:00Z'),
      target?: string(name='Target', description='The attack target.', example='example.com'),
      targetId?: string(name='TargetId', description='The ID of the web resource exhaustion attack target.', example='000000000155****'),
    }
  ](name='DataList', description='The DDoS attack events.'),
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
  requestId?: string(name='RequestId', description='The request ID.', example='D73A4243-CFBD-5110-876F-09237E77ECBD'),
  siteId?: long(name='SiteId', description='The website ID.', example='7096621098****'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='1'),
}

model DescribeDDoSAllEventListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDDoSAllEventListResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeDDoSAllEventList  DescribeDDoSAllEventListRequest
  * @return DescribeDDoSAllEventListResponse
 */
async function describeDDoSAllEventList(request: DescribeDDoSAllEventListRequest): DescribeDDoSAllEventListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDDoSAllEventList', 'POST', '/', 'json', false, 'json', request);
}

model DescribeHttpDDoSAttackIntelligentProtectionRequest {
  siteId: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.

This parameter is required.', example='123456****', minimum=1, position='Query'),
}

model DescribeHttpDDoSAttackIntelligentProtectionResponseBody = {
  aiMode?: string(name='AiMode', description='The mode of smart HTTP DDoS protection. Valid values:

*   **observe**: alert.
*   **defense**: block.', example='defense'),
  aiTemplate?: string(name='AiTemplate', description='The level of smart HTTP DDoS protection. Valid values:

*   **level0**: very loose.
*   **level30**: loose.
*   **level60**: normal.
*   **level90**: strict.', example='level60'),
  requestId?: string(name='RequestId', description='The request ID.', example='CB1A380B-09F0-41BB-3C82-72F8FD6DA2FE'),
  siteId?: long(name='SiteId', description='The website ID.', example='123456****'),
}

model DescribeHttpDDoSAttackIntelligentProtectionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeHttpDDoSAttackIntelligentProtectionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeHttpDDoSAttackIntelligentProtection  DescribeHttpDDoSAttackIntelligentProtectionRequest
  * @return DescribeHttpDDoSAttackIntelligentProtectionResponse
 */
async function describeHttpDDoSAttackIntelligentProtection(request: DescribeHttpDDoSAttackIntelligentProtectionRequest): DescribeHttpDDoSAttackIntelligentProtectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeHttpDDoSAttackIntelligentProtection', 'POST', '/', 'json', false, 'json', request);
}

model DescribeHttpDDoSAttackProtectionRequest {
  siteId: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.

This parameter is required.', example='123456****', minimum=1, position='Query'),
}

model DescribeHttpDDoSAttackProtectionResponseBody = {
  globalMode?: string(name='GlobalMode', description='The level of HTTP DDoS attack protection. Valid values:

*   **very weak**: very loose.
*   **weak**: loose.
*   **default**: normal.
*   **hard**: strict.', example='default'),
  requestId?: string(name='RequestId', description='The request ID.', example='35C66C7B-671H-4297-9187-2C4477247A78'),
  siteId?: long(name='SiteId', description='The website ID.', example='123456****'),
}

model DescribeHttpDDoSAttackProtectionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeHttpDDoSAttackProtectionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeHttpDDoSAttackProtection  DescribeHttpDDoSAttackProtectionRequest
  * @return DescribeHttpDDoSAttackProtectionResponse
 */
async function describeHttpDDoSAttackProtection(request: DescribeHttpDDoSAttackProtectionRequest): DescribeHttpDDoSAttackProtectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeHttpDDoSAttackProtection', 'POST', '/', 'json', false, 'json', request);
}

model DescribeKvAccountStatusRequest {
}

model DescribeKvAccountStatusResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='EEEBE525-F576-1196-8DAF-2D70CA3F4D2F'),
  status?: string(name='Status', description='Indicates whether Edge KV is activated for the Alibaba Cloud account.

*   **online**
*   **offline**', example='online'),
}

model DescribeKvAccountStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeKvAccountStatusResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeKvAccountStatus  DescribeKvAccountStatusRequest
  * @return DescribeKvAccountStatusResponse
 */
async function describeKvAccountStatus(request: DescribeKvAccountStatusRequest): DescribeKvAccountStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeKvAccountStatus', 'GET', '/', 'json', false, 'json', request);
}

model DescribePreloadTasksRequest {
  content?: string(name='Content', description='The content to prefetch. Exact match is supported.', example='http://a.com/1.jpg?b=2', position='Query'),
  endTime?: string(name='EndTime', description='The end time. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

>  The end time must be later than the start time.', example='2023-03-23T06:23:00Z', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number. Valid values: **1** to **100000**. Default value: **1**.', example='1', minimum=1, maximum=100000, position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 20. Valid values: 1 to 50.', example='20', minimum=1, maximum=100, position='Query'),
  siteId?: long(name='SiteId', description='The website ID. You can call the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation to obtain the ID.', example='123456789****', position='Query'),
  startTime?: string(name='StartTime', description='The start time. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2023-03-22T17:00:00Z', position='Query'),
  status?: string(name='Status', description='The task status. Valid values:

*   **Complete**: The task is complete.
*   **Refreshing**: The task is running.
*   **Failed**: The task failed.', example='Complete', position='Query'),
}

model DescribePreloadTasksResponseBody = {
  pageNumber?: long(name='PageNumber', description='The page number.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries per page.', example='10'),
  requestId?: string(name='RequestId', description='The request ID.', example='0AEDAF20-4DDF-4165-8750-47FF9C1929C9'),
  tasks?: [ 
    {
      content?: string(name='Content', description='The prefetched content.', example='http://a.com/1.jpg?b=2'),
      createTime?: string(name='CreateTime', description='The time when the task was created.', example='2023-03-28 14:28:57'),
      description?: string(name='Description', description='The error message returned upon a prefetch task failure. Valid values:

*   **Internal Error**
*   **Origin Timeout**
*   **Origin Return StatusCode 5XX**', example='Internal Error'),
      process?: string(name='Process', description='The progress of the task, in percentage.', example='100%'),
      status?: string(name='Status', description='The task status.

*   **Complete**: The task is complete.
*   **Refreshing**: The task is in progress.
*   **Failed**: The task failed.', example='Complete'),
      taskId?: string(name='TaskId', description='The ID of the queried task.', example='1597854579687428'),
    }
  ](name='Tasks', description='The tasks.'),
  totalCount?: long(name='TotalCount', description='The total number of entries returned.', example='83'),
}

model DescribePreloadTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePreloadTasksResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribePreloadTasks  DescribePreloadTasksRequest
  * @return DescribePreloadTasksResponse
 */
async function describePreloadTasks(request: DescribePreloadTasksRequest): DescribePreloadTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePreloadTasks', 'GET', '/', 'json', false, 'json', request);
}

model DescribePurgeTasksRequest {
  content?: string(name='Content', description='The content to purge. Exact match is supported.', example='http://a.com/1.jpg?b=1', position='Query'),
  endTime?: string(name='EndTime', description='The end time. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

>  The end time must be later than the start time.', example='2022-11-18T15:59:59Z', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number. Valid values: 1 to 100000.', example='1', minimum=1, maximum=100000, position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 20. Valid values: 1 to 50.', example='20', minimum=1, maximum=100, position='Query'),
  siteId?: long(name='SiteId', description='The website ID. You can call the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation to obtain the ID.', example='123456789****', position='Query'),
  startTime?: string(name='StartTime', description='The start time. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2022-11-16T05:33:00Z', position='Query'),
  status?: string(name='Status', description='The task status. Valid values:

*   **Complete**: The task is complete.
*   **Refreshing**: The task is in progress.
*   **Failed**: The task failed.', example='Complete', position='Query'),
  type?: string(name='Type', description='The task type. Valid values:

*   **file** (default): purges the cache by file.
*   **cachetag**: purges the cache by cache tag.
*   **directory**: purges the cache by directory.
*   **ignoreParams**: purges the cache by URL with specified parameters ignored.
*   **hostname**: purges the cache by hostname.
*   **purgeall**: purges all cache.', example='file', position='Query'),
}

model DescribePurgeTasksResponseBody = {
  pageNumber?: long(name='PageNumber', description='The page number.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries per page.', example='20'),
  requestId?: string(name='RequestId', description='The request ID.', example='15C66C7B-671A-4297-9187-2C4477247A123425345'),
  tasks?: [ 
    {
      content?: string(name='Content', description='The purged content.', example='http://a.com/1.jpg?b=1'),
      createTime?: string(name='CreateTime', description='The time when the task was created.', example='2023-07-26T01:56:15Z'),
      description?: string(name='Description', description='The error description returned when the purge task failed.', example='Internal Error'),
      process?: string(name='Process', description='The progress of the task, in percentage.', example='100%'),
      status?: string(name='Status', description='The task status.

*   **Complete**: The task is complete.
*   **Refreshing**: The task is in progress.
*   **Failed**: The task failed.', example='Complete'),
      taskId?: string(name='TaskId', description='The task ID.', example='16346513304'),
      type?: string(name='Type', description='The type of the purge task. Valid values:

*   **file** (default): purges the cache by file.
*   **cachetag**: purges the cache by cache tag.
*   **directory**: purges the cache by directory.
*   **ignoreParams**: purges the cache by URL with specified parameters ignored.
*   **hostname**: purges the cache by hostname.
*   **purgeall**: purges all cache.', example='file'),
    }
  ](name='Tasks', description='The tasks.'),
  totalCount?: long(name='TotalCount', description='The total number of entries returned.', example='15'),
}

model DescribePurgeTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePurgeTasksResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribePurgeTasks  DescribePurgeTasksRequest
  * @return DescribePurgeTasksResponse
 */
async function describePurgeTasks(request: DescribePurgeTasksRequest): DescribePurgeTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePurgeTasks', 'GET', '/', 'json', false, 'json', request);
}

model DisableCustomScenePolicyRequest {
  policyId: long(name='PolicyId', description='The policy ID, which can be obtained by calling the [DescribeCustomScenePolicies](https://help.aliyun.com/document_detail/2850508.html) operation.

This parameter is required.', example='100001', minimum=1, position='Query'),
}

model DisableCustomScenePolicyResponseBody = {
  policyId?: long(name='PolicyId', description='The ID of the disabled policy.', example='100001'),
  requestId?: string(name='RequestId', description='The request ID.', example='9732E117-8A37-49FD-A36F-ABBB87556CA7'),
}

model DisableCustomScenePolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DisableCustomScenePolicyResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DisableCustomScenePolicy  DisableCustomScenePolicyRequest
  * @return DisableCustomScenePolicyResponse
 */
async function disableCustomScenePolicy(request: DisableCustomScenePolicyRequest): DisableCustomScenePolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DisableCustomScenePolicy', 'POST', '/', 'json', false, 'json', request);
}

model EditSiteWafSettingsRequest {
  settings?: WafSiteSettings(name='Settings', description='The WAF configuration of the website in the JSON format.', shrink='json', position='Body'),
  siteId?: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.', example='1', position='Query'),
  siteVersion?: int32(name='SiteVersion', description='The version of the website.', example='0', position='Query'),
}

model EditSiteWafSettingsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='36af3fcc-43d0-441c-86b1-428951dc8225'),
}

model EditSiteWafSettingsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EditSiteWafSettingsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of EditSiteWafSettings  EditSiteWafSettingsRequest
  * @return EditSiteWafSettingsResponse
 */
async function editSiteWafSettings(request: EditSiteWafSettingsRequest): EditSiteWafSettingsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EditSiteWafSettings', 'POST', '/', 'json', true, 'form', request);
}

model EnableCustomScenePolicyRequest {
  policyId: long(name='PolicyId', description='The policy ID, which can be obtained by calling the [DescribeCustomScenePolicies](https://help.aliyun.com/document_detail/2850508.html) operation.

This parameter is required.', example='1', minimum=1, position='Query'),
}

model EnableCustomScenePolicyResponseBody = {
  policyId?: long(name='PolicyId', description='The policy ID.', example='1'),
  requestId?: string(name='RequestId', description='The request ID.', example='65C66B7B-671A-8297-9187-2R5477247B76'),
}

model EnableCustomScenePolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EnableCustomScenePolicyResponseBody(name='body'),
}

/**
  * @param request  the request parameters of EnableCustomScenePolicy  EnableCustomScenePolicyRequest
  * @return EnableCustomScenePolicyResponse
 */
async function enableCustomScenePolicy(request: EnableCustomScenePolicyRequest): EnableCustomScenePolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EnableCustomScenePolicy', 'POST', '/', 'json', false, 'json', request);
}

model ExportRecordsRequest {
  siteId?: long(name='SiteId', description='The website ID. You can call the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation to obtain the ID.', example='1234567890123', position='Query'),
}

model ExportRecordsResponseBody = {
  content?: string(name='Content', description='The exported DNS records.', example=';; site:example.com.\\n;; Exported:2024-01-24 15:54:35\\n\\n;; A Records\\na1.example.com. 30 IN A 1.1.1.1 direct\\na2.example.com. 30 IN A 1.1.1.1 direct\\na3.example.com. 30 IN A 1.1.1.1 direct\\n'),
  requestId?: string(name='RequestId', description='The request ID.', example='C69B5894-D1BA-592C-95D0-DADBE7AEAC63'),
}

model ExportRecordsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ExportRecordsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ExportRecords  ExportRecordsRequest
  * @return ExportRecordsResponse
 */
async function exportRecords(request: ExportRecordsRequest): ExportRecordsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ExportRecords', 'GET', '/', 'json', false, 'json', request);
}

model GetCacheReserveSpecificationRequest {
}

model GetCacheReserveSpecificationResponseBody = {
  cacheReserveCapacity?: [ string ](name='CacheReserveCapacity', description='The capacities of cache reserve instances that can be created.'),
  cacheReserveRegion?: [ string ](name='CacheReserveRegion', description='The regions in which cache reserve instances can be created.'),
  requestId?: string(name='RequestId', description='The request ID.', example='EEEBE525-F576-1196-8DAF-2D70CA3F4D2F'),
}

model GetCacheReserveSpecificationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetCacheReserveSpecificationResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetCacheReserveSpecification  GetCacheReserveSpecificationRequest
  * @return GetCacheReserveSpecificationResponse
 */
async function getCacheReserveSpecification(request: GetCacheReserveSpecificationRequest): GetCacheReserveSpecificationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetCacheReserveSpecification', 'GET', '/', 'json', false, 'json', request);
}

model GetCertificateQuotaRequest {
  siteId: long(name='SiteId', description='This parameter is required.', example='1234567890123', position='Query'),
  type: string(name='Type', description='This parameter is required.', example='free', position='Query'),
}

model GetCertificateQuotaResponseBody = {
  quota?: long(name='Quota', example='10'),
  quotaUsage?: long(name='QuotaUsage', example='5'),
  requestId?: string(name='RequestId', example='0AEDAF20-4DDF-4165-8750-47FF9C1929C9'),
  siteCount?: long(name='SiteCount', example='2'),
  siteUsage?: [ 
    {
      siteId?: string(name='SiteId', example='165929521496928'),
      siteName?: string(name='SiteName', example='example.com'),
      siteUsage?: long(name='SiteUsage', example='5'),
    }
  ](name='SiteUsage'),
  type?: string(name='Type', example='free'),
}

model GetCertificateQuotaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetCertificateQuotaResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetCertificateQuota  GetCertificateQuotaRequest
  * @return GetCertificateQuotaResponse
 */
async function getCertificateQuota(request: GetCertificateQuotaRequest): GetCertificateQuotaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetCertificateQuota', 'GET', '/', 'json', false, 'json', request);
}

model GetClientCaCertificateRequest {
  id: string(name='Id', description='This parameter is required.', example='babab9db65ee5efcca9f3d41d4b5****', position='Query'),
  siteId: long(name='SiteId', description='This parameter is required.', example='1234567890123', position='Query'),
}

model GetClientCaCertificateResponseBody = {
  certificate?: string(name='Certificate', example='-----BEGIN CERTIFICATE-----'),
  requestId?: string(name='RequestId', example='0AEDAF20-4DDF-4165-8750-47FF9C1929C9'),
  result?: {
    commonName?: string(name='CommonName', example='www.example.com'),
    createTime?: string(name='CreateTime', example='2024-03-05 18:24:04'),
    id?: string(name='Id', example='babab9db65ee5efcca9f3d41d4b5****'),
    issuer?: string(name='Issuer', example='GlobalSign nv-sa'),
    name?: string(name='Name', example='yourCertName'),
    notAfter?: string(name='NotAfter', example='2024-03-31 02:08:00'),
    notBefore?: string(name='NotBefore', example='2023-03-31 02:08:00'),
    pubkeyAlgorithm?: string(name='PubkeyAlgorithm', example='RSA'),
    SAN?: string(name='SAN', example='www.example.com,*.example.com'),
    signatureAlgorithm?: string(name='SignatureAlgorithm', example='SHA256-RSA'),
    status?: string(name='Status', example='OK'),
    type?: string(name='Type', example='upload'),
    updateTime?: string(name='UpdateTime', example='2024-03-05 18:24:04'),
  }(name='Result'),
  siteId?: long(name='SiteId', example='1234567890123'),
  siteName?: string(name='SiteName', example='example.com'),
  status?: string(name='Status', example='OK'),
}

model GetClientCaCertificateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetClientCaCertificateResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetClientCaCertificate  GetClientCaCertificateRequest
  * @return GetClientCaCertificateResponse
 */
async function getClientCaCertificate(request: GetClientCaCertificateRequest): GetClientCaCertificateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetClientCaCertificate', 'GET', '/', 'json', false, 'json', request);
}

model GetClientCertificateRequest {
  id: string(name='Id', description='This parameter is required.', example='baba39055622c008b90285a8838ed09a', position='Query'),
  siteId: long(name='SiteId', description='This parameter is required.', example='1234567890123', position='Query'),
}

model GetClientCertificateResponseBody = {
  certificate?: string(name='Certificate', example='-----BEGIN CERTIFICATE-----'),
  requestId?: string(name='RequestId', example='0AEDAF20-4DDF-4165-8750-47FF9C1929C9'),
  result?: {
    CACertificateId?: string(name='CACertificateId', example='babab9db65ee5efcca9f3d41d4b50d66'),
    commonName?: string(name='CommonName', example='www.example.com'),
    createTime?: string(name='CreateTime', example='2024-06-24 07:48:51'),
    id?: string(name='Id', example='baba39055622c008b90285a8838ed09a'),
    issuer?: string(name='Issuer', example='GlobalSign nv-sa'),
    name?: string(name='Name', example='yourCertName'),
    notAfter?: string(name='NotAfter', example='2024-03-31 02:08:00'),
    notBefore?: string(name='NotBefore', example='2023-03-31 02:08:00'),
    pubkeyAlgorithm?: string(name='PubkeyAlgorithm', example='RSA'),
    SAN?: string(name='SAN', example='www.example.com,*.example.com'),
    signatureAlgorithm?: string(name='SignatureAlgorithm', example='SHA256-RSA'),
    status?: string(name='Status', example='active'),
    type?: string(name='Type', example='dcdn'),
    updateTime?: string(name='UpdateTime', example='2024-09-22 05:33:13'),
  }(name='Result'),
  siteId?: long(name='SiteId', example='1234567890123'),
  siteName?: string(name='SiteName', example='example.com'),
  status?: string(name='Status', example='active'),
}

model GetClientCertificateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetClientCertificateResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetClientCertificate  GetClientCertificateRequest
  * @return GetClientCertificateResponse
 */
async function getClientCertificate(request: GetClientCertificateRequest): GetClientCertificateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetClientCertificate', 'GET', '/', 'json', false, 'json', request);
}

model GetClientCertificateHostnamesRequest {
  id?: string(name='Id', example='baba39055622c008b90285a8838ed09a', position='Query'),
  siteId: long(name='SiteId', description='This parameter is required.', example='1234567890123', position='Query'),
}

model GetClientCertificateHostnamesResponseBody = {
  hostnames?: [ string ](name='Hostnames'),
  id?: string(name='Id', example='baba39055622c008b90285a8838ed09a'),
  requestId?: string(name='RequestId', example='EEEBE525-F576-1196-8DAF-2D70CA3F4D2F'),
  siteId?: long(name='SiteId', example='1234567890123'),
  siteName?: string(name='SiteName', example='example.com'),
}

model GetClientCertificateHostnamesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetClientCertificateHostnamesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetClientCertificateHostnames  GetClientCertificateHostnamesRequest
  * @return GetClientCertificateHostnamesResponse
 */
async function getClientCertificateHostnames(request: GetClientCertificateHostnamesRequest): GetClientCertificateHostnamesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetClientCertificateHostnames', 'GET', '/', 'json', false, 'json', request);
}

model GetEdgeContainerAppRequest {
  appId: string(name='AppId', description='The application ID, which can be obtained by calling the [ListEdgeContainerApps](~~ListEdgeContainerApps~~) operation.

This parameter is required.', example='app-88068867578379****', minLength=20, maxLength=64, position='Query'),
}

model GetEdgeContainerAppResponseBody = {
  app?: {
    appId?: string(name='AppId', description='The application ID.', example='app-88068867578379****'),
    createTime?: string(name='CreateTime', description='The time when the application was created.', example='2023-07-25T05:58:05Z'),
    domainName?: string(name='DomainName', description='The domain name that is associated with the application. If no domain name is associated with the application, the value is an empty string.', example='www.1feel.cn'),
    gatewayType?: string(name='GatewayType', description='The type of the gateway. Valid values:

*   l7: Layer 7 gateway.
*   l4: Layer 4 gateway.', example='l7'),
    healthCheck?: {
      failTimes?: int32(name='FailTimes', description='The number of consecutive failed health checks required for an application to be considered as unhealthy.', example='5'),
      host?: string(name='Host', description='The domain name that is used for health checks.', example='test.com'),
      httpCode?: string(name='HttpCode', description='The range of health check status codes that indicate successful health checks.', example='http_2xx'),
      interval?: int32(name='Interval', description='The interval between health checks. Unit: seconds.', example='5'),
      method?: string(name='Method', description='The HTTP method that the health check request uses.', example='HEAD'),
      port?: int32(name='Port', description='The health check port.', example='80'),
      succTimes?: int32(name='SuccTimes', description='The number of consecutive successful health checks required for an application to be considered as healthy.', example='3'),
      timeout?: int32(name='Timeout', description='The timeout period of the health check. Unit: seconds.', example='60'),
      type?: string(name='Type', description='The health check type. Valid values:

*   l7
*   l4', example='l7'),
      uri?: string(name='Uri', description='The health check URL.', example='/health_check'),
    }(name='HealthCheck', description='The information about health checks.'),
    name?: string(name='Name', description='The application name.', example='test-app1'),
    quicCid?: string(name='QuicCid', description='Indicates whether QUIC is enabled.', example='false'),
    remarks?: string(name='Remarks', description='The remarks about the application.', example='test app'),
    servicePort?: int32(name='ServicePort', description='The server port. Valid values: 1 to 65535.', example='80'),
    status?: string(name='Status', description='The status of the application. Valid values:

*   creating: The application is being created.
*   failed: The application failed to be created.
*   created: The application is created.', example='created'),
    targetPort?: int32(name='TargetPort', description='The backend port, which is also the service port of the application. Valid values: 1 to 65535.', example='80'),
    updateTime?: string(name='UpdateTime', description='The time when the application was last modified. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.', example='2023-03-26T02:35:58Z'),
    versionCount?: int32(name='VersionCount', description='The number of versions of the application.', example='1'),
  }(name='App', description='The basic information about the application.'),
  requestId?: string(name='RequestId', description='The request ID.', example='156A6B-677B1A-4297B7-9187B7-2B44792'),
}

model GetEdgeContainerAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetEdgeContainerAppResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetEdgeContainerApp  GetEdgeContainerAppRequest
  * @return GetEdgeContainerAppResponse
 */
async function getEdgeContainerApp(request: GetEdgeContainerAppRequest): GetEdgeContainerAppResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetEdgeContainerApp', 'POST', '/', 'json', false, 'json', request);
}

model GetEdgeContainerAppStatusRequest {
  appId: string(name='AppId', description='The application ID, which can be obtained by calling the [ListEdgeContainerApps](~~ListEdgeContainerApps~~) operation.

This parameter is required.', example='app-88068867578379****', minLength=20, maxLength=64, position='Query'),
  publishEnv?: string(name='PublishEnv', description='The release environment. Valid values: prod and staging.', example='staging', position='Query'),
}

model GetEdgeContainerAppStatusResponseBody = {
  appStatus?: {
    baseLineVersion?: string(name='BaseLineVersion', description='The base version of the application.', example='ver-123123123123****'),
    deployStatus?: string(name='DeployStatus', description='The deployment status of the application.

*   **undeploy**: The application is not deployed.
*   **deploying**: The application is being deployed.
*   **deployed**: The application is deployed.
*   **undeploying**: The deployment is being canceled.', example='undeploy'),
    deployTime?: string(name='DeployTime', description='The time when the application was deployed. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format. The time is displayed in UTC.', example='2024-07-25T05:58:05Z'),
    deployedVersion?: string(name='DeployedVersion', description='The release version of the application.', example='ver-123123123123****'),
    expectPercentage?: int32(name='ExpectPercentage', description='The expected release percentage of the application.', example='50%'),
    fullRelease?: boolean(name='FullRelease', description='Specifies whether to fully release the version. This parameter takes effect only when PublishType is set to region.', example='true'),
    publishEnv?: string(name='PublishEnv', description='The environment to which the application was released. Valid values:

*   **prod**: the production environment.
*   **staging**: the staging environment.', example='prod'),
    publishPercentage?: int32(name='PublishPercentage', description='The release percentage of the application.', example='50%'),
    publishStatus?: string(name='PublishStatus', description='The release status of the application. Valid values:

*   **publishing**
*   **published**
*   **rollbacking**
*   **rollbacked**', example='pubishing'),
    publishTime?: string(name='PublishTime', description='The time when the application was released. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format. The time is displayed in UTC.', example='2024-07-25T05:58:05Z'),
    publishType?: string(name='PublishType', description='Specifies how the version is released. Valid values:

*   percentage: releases the version by percentage.
*   region: releases the version by region.

If you do not specify this parameter, the version is released by percentage by default.', example='percentage'),
    publishingVersion?: string(name='PublishingVersion', description='The release version of the application.', example='ver-123123123123****'),
    regions?: {
      region?: [ string ](name='Region')
    }(name='Regions', description='The regions to which the version is released.'),
    rollbackTime?: string(name='RollbackTime', description='The time when the last rollback was performed.', example='2024-07-25T05:58:05Z'),
    unDeployTime?: string(name='UnDeployTime', description='The time when the application deployment was canceled. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format. The time is displayed in UTC.', example='2024-07-25T05:58:05Z'),
  }(name='AppStatus', description='The status of the application.'),
  requestId?: string(name='RequestId', description='The request ID.', example='15C66C7B-671A-4297-9187-2C4477247B78'),
}

model GetEdgeContainerAppStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetEdgeContainerAppStatusResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetEdgeContainerAppStatus  GetEdgeContainerAppStatusRequest
  * @return GetEdgeContainerAppStatusResponse
 */
async function getEdgeContainerAppStatus(request: GetEdgeContainerAppStatusRequest): GetEdgeContainerAppStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetEdgeContainerAppStatus', 'POST', '/', 'json', false, 'json', request);
}

model GetEdgeContainerAppVersionRequest {
  appId: string(name='AppId', description='The application ID, which can be obtained by calling the [ListEdgeContainerApps](~~ListEdgeContainerApps~~) operation.

This parameter is required.', example='app-88068867578379****', minLength=20, maxLength=64, position='Query'),
  versionId: string(name='VersionId', description='The version ID, which can be obtained by calling the [ListEdgeContainerAppVersions](~~ListEdgeContainerAppVersions~~) operation.

This parameter is required.', example='ver-87962637161651****', minLength=20, maxLength=64, position='Query'),
}

model GetEdgeContainerAppVersionResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
  version?: {
    appId?: string(name='AppId', description='The application ID.', example='app-88068867578379****'),
    containers?: [ 
      {
        ACRImageInfo?: {
          domain?: string(name='Domain', description='The domain name of the Container Registry image.', example='*.mooc.seewo.com'),
          instanceId?: string(name='InstanceId', description='The ID of the Container Registry instance.', example='xcdn-9ak2thl14z5s'),
          isEnterpriseRegistry?: boolean(name='IsEnterpriseRegistry', description='Indicates whether the image is an enterprise-level image.', example='false'),
          regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
          repoId?: string(name='RepoId', description='The ID of the image repository.', example='crr-zeu0xyk28alyxozh'),
          repoName?: string(name='RepoName', description='The name of the image repository.', example='test_1'),
          repoNamespace?: string(name='RepoNamespace', description='The namespace to which the image repository belongs.', example='wpy1'),
          tag?: string(name='Tag', description='The tag value.', example='test-healthy-100-soa-1710987653'),
          tagUrl?: string(name='TagUrl', description='The URL of the Container Registry image tag.', example='registry-vpc.cn-shenzhen.aliyuncs.com/lihetech/easywits_server_exam:3.40.2'),
        }(name='ACRImageInfo', description='The information about the Container Registry image.'),
        args?: string(name='Args', description='The arguments that are passed to the container startup command.', example='-c /path/config.toml'),
        command?: string(name='Command', description='The command that is used to start the container.', example='sh abc.sh 1 2 3'),
        envVariables?: string(name='EnvVariables', description='The environment variables.', example='ENV=prod'),
        image?: string(name='Image', description='The image address.', example='nginx:1.14.0'),
        isACRImage?: boolean(name='IsACRImage', description='Indicates whether the image is a Container Registry image.', example='false'),
        name?: string(name='Name', description='The version name.', example='version01'),
        postStart?: string(name='PostStart', description='The command that is run before the container is started. Format: `{"exec":{"command":["cat","/etc/group"\\]}}`. If you want to cancel this configuration, set the parameter value to `""` or `{}`. If you do not specify this parameter, this configuration is ignored.', example='{\\"exec\\":{\\"command\\":[\\"touch\\",\\"/home/admin/checkpoststartV1\\"]}}'),
        preStop?: string(name='PreStop', description='The command that is run before the container is stopped.', example='sh prestop.sh "echo hello world"'),
        probeContent?: {
          command?: string(name='Command', description='The probe command.', example='sh test.sh'),
          failureThreshold?: int32(name='FailureThreshold', description='The number of consecutive failed health checks required for a container to be considered as unhealthy.', example='3'),
          host?: string(name='Host', description='The domain name that is used for health checks.', example='test.com'),
          httpHeaders?: string(name='HttpHeaders', description='The request headers that are included in the container health check request.', example='[{\\"Content-Type\\":\\"application/json'),
          initialDelaySeconds?: int32(name='InitialDelaySeconds', description='The latency for container probe initialization.', example='20'),
          path?: string(name='Path', description='The path of the container health check.', example='/health_check'),
          periodSeconds?: int32(name='PeriodSeconds', description='The interval between container health checks.', example='5'),
          port?: int32(name='Port', description='The port of the container health check. Valid values: **1** to **65535**.', example='80'),
          scheme?: string(name='Scheme', description='The protocol that the container health check request uses.', example='http'),
          successThreshold?: int32(name='SuccessThreshold', description='The number of consecutive successful health checks required for a container to be considered as healthy.', example='1'),
          timeoutSeconds?: int32(name='TimeoutSeconds', description='The timeout period of the container health check.', example='5'),
        }(name='ProbeContent', description='The probe content.'),
        probeType?: string(name='ProbeType', description='The probe type.', example='httpGet'),
        spec?: string(name='Spec', description='The compute specification.', example='1C2G'),
        storage?: string(name='Storage', description='The storage capacity of the container. Valid values: 0.5G, 10G, 20G, and 30G.'),
      }
    ](name='Containers', description='The container images deployed for this version.'),
    createTime?: string(name='CreateTime', description='The time when the version was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.', example='2022-07-01T09:32:33Z'),
    lastPublishTime?: string(name='LastPublishTime', description='The time when the version was last released. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.', example='2023-07-25T04:58:05Z'),
    name?: string(name='Name', description='The version name.', example='test'),
    publishTime?: string(name='PublishTime', description='The time when the version was released. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.', example='2022-11-14T02:04:03Z'),
    remarks?: string(name='Remarks', description='The remarks.', example='aaa'),
    status?: string(name='Status', description='The status of the current version. Valid values:

*   created: The version is created.
*   failed: The version failed to be created.
*   creating: The version is being created.', example='created'),
    updateTime?: string(name='UpdateTime', description='The time when the version was last modified. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.', example='2021-12-03T10:52:52Z'),
    versionId?: string(name='VersionId', description='The ID of the created version.', example='ver-87962637161651****'),
  }(name='Version', description='The information about the version.'),
}

model GetEdgeContainerAppVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetEdgeContainerAppVersionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetEdgeContainerAppVersion  GetEdgeContainerAppVersionRequest
  * @return GetEdgeContainerAppVersionResponse
 */
async function getEdgeContainerAppVersion(request: GetEdgeContainerAppVersionRequest): GetEdgeContainerAppVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetEdgeContainerAppVersion', 'GET', '/', 'json', false, 'json', request);
}

model GetEdgeContainerDeployRegionsRequest {
  appId?: string(name='AppId', description='The application ID, which can be obtained by calling the [ListEdgeContainerApps](~~ListEdgeContainerApps~~) operation.', example='GetEdgeContainerDeployRegions', position='Query'),
}

model GetEdgeContainerDeployRegionsResponseBody = {
  regions?: [ string ](name='Regions', description='The regions.'),
  requestId?: string(name='RequestId', description='The request ID.', example='EDBD3EB3-97DA-5465-AEF5-8DCA5DC5E395'),
}

model GetEdgeContainerDeployRegionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetEdgeContainerDeployRegionsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetEdgeContainerDeployRegions  GetEdgeContainerDeployRegionsRequest
  * @return GetEdgeContainerDeployRegionsResponse
 */
async function getEdgeContainerDeployRegions(request: GetEdgeContainerDeployRegionsRequest): GetEdgeContainerDeployRegionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetEdgeContainerDeployRegions', 'GET', '/', 'json', false, 'json', request);
}

model GetEdgeContainerLogsRequest {
  appId: string(name='AppId', description='The application ID, which can be obtained by calling the [ListEdgeContainerApps](~~ListEdgeContainerApps~~) operation.

This parameter is required.', example='app-88068867578379****', position='Query'),
  lines: int32(name='Lines', description='The number of log entries to output.

This parameter is required.', example='500', position='Query'),
}

model GetEdgeContainerLogsResponseBody = {
  items?: [ string ](name='Items', description='The logs.'),
  requestId?: string(name='RequestId', description='The request ID.', example='15C66C7B-671A-4297-9187-2C4477247B78'),
}

model GetEdgeContainerLogsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetEdgeContainerLogsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetEdgeContainerLogs  GetEdgeContainerLogsRequest
  * @return GetEdgeContainerLogsResponse
 */
async function getEdgeContainerLogs(request: GetEdgeContainerLogsRequest): GetEdgeContainerLogsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetEdgeContainerLogs', 'GET', '/', 'json', false, 'json', request);
}

model GetEdgeContainerStagingDeployStatusRequest {
  appId?: string(name='AppId', description='The application ID, which can be obtained by calling the [ListEdgeContainerApps](~~ListEdgeContainerApps~~) operation.', example='GetEdgeContainerStagingDeployStatus', position='Query'),
}

model GetEdgeContainerStagingDeployStatusResponseBody = {
  containersReady?: string(name='ContainersReady', description='Indicates whether the container is ready.

*   ok
*   unready', example='ok'),
  creationTimestamp?: string(name='CreationTimestamp', description='The time when the container was created. The value is a timestamp.', example='2024-09-24T06:46:35Z'),
  initialized?: string(name='Initialized', description='The initialization status of the container.

*   ok
*   unready', example='ok'),
  phase?: string(name='Phase', description='The status of the container in the staging environment.

*   NoContainer: created.
*   Running: running.
*   Failed: abnormal.', example='Running'),
  podRestartState?: {
    lastTerminatedReason?: string(name='LastTerminatedReason', description='The reason for the last restart.', example='OOMKilled'),
    restartCount?: int32(name='RestartCount', description='The number of times that the container restarted.', example='1'),
  }(name='PodRestartState', description='The details of container restart.'),
  ready?: string(name='Ready', description='Indicates whether domain names are associated with the container.

*   ok
*   unready', example='ok'),
  requestId?: string(name='RequestId', description='The request ID.', example='2F2C992B-3FE2-5EBB-A61F-F9DD4EB257DA'),
  scheduled?: string(name='Scheduled', description='The scheduling status of the container.

*   ok
*   unready', example='ok'),
  VIPs?: [ string ](name='VIPs', description='The virtual IP addresses.'),
}

model GetEdgeContainerStagingDeployStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetEdgeContainerStagingDeployStatusResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetEdgeContainerStagingDeployStatus  GetEdgeContainerStagingDeployStatusRequest
  * @return GetEdgeContainerStagingDeployStatusResponse
 */
async function getEdgeContainerStagingDeployStatus(request: GetEdgeContainerStagingDeployStatusRequest): GetEdgeContainerStagingDeployStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetEdgeContainerStagingDeployStatus', 'GET', '/', 'json', false, 'json', request);
}

model GetEdgeContainerTerminalRequest {
  appId?: string(name='AppId', description='The application ID, which can be obtained by calling the [ListEdgeContainerApps](~~ListEdgeContainerApps~~) operation.', example='app-88068867578379****', position='Query'),
}

model GetEdgeContainerTerminalResponseBody = {
  cluster?: string(name='Cluster', description='The cluster name.', example='c497b44c2a59f4ae0bd2826edc40a2c6e'),
  container?: string(name='Container', description='The container name.', example='worker0'),
  namespace?: string(name='Namespace', description='The name of the namespace.', example='ns1'),
  pod?: string(name='Pod', description='The name of the container group.', example='1775b9e0-8463-457e-89e8-fb7b6d125b2e'),
  requestId?: string(name='RequestId', description='The request ID.', example='9732E117-8A37-49FD-A36F-ABBB87556CA7'),
  sessionId?: string(name='SessionId', description='The session ID.', example='af22f4xxxxxxxxxxxxxxxxxx'),
  token?: string(name='Token', description='The information about the shared token.', example='af22f4-xxxxx-xxxx-xxxx-xxxx'),
}

model GetEdgeContainerTerminalResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetEdgeContainerTerminalResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetEdgeContainerTerminal  GetEdgeContainerTerminalRequest
  * @return GetEdgeContainerTerminalResponse
 */
async function getEdgeContainerTerminal(request: GetEdgeContainerTerminalRequest): GetEdgeContainerTerminalResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetEdgeContainerTerminal', 'POST', '/', 'json', false, 'json', request);
}

model GetErServiceRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model GetErServiceResponseBody = {
  planName?: string(name='PlanName', description='The billing mode. Valid values:

*   er_paymode: billed for customers on the China site.
*   er_freemode: free for customers on the China site.
*   er_paymodeintl: billed for customers on the International site.
*   err_freemodeintl: free for customers on the International site', example='er_paymode'),
  requestId?: string(name='RequestId', description='The request ID.', example='CB1A380B-09F0-41BB-A198-72F8FD6DA2FE'),
  status?: string(name='Status', description='The service status. Valid values:

*   Creating
*   Running
*   NotOpened', example='Running'),
}

model GetErServiceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetErServiceResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetErService  GetErServiceRequest
  * @return GetErServiceResponse
 */
async function getErService(request: GetErServiceRequest): GetErServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetErService', 'GET', '/', 'json', false, 'json', request);
}

model GetKvRequest {
  base64?: boolean(name='Base64', description='Specifies whether to decode the value by using Base 64. If you call the [PutKv](https://help.aliyun.com/document_detail/2850482.html) operation and set the Base64 parameter to true, set this parameter to true to read the original content.', example='true', position='Query'),
  key: string(name='Key', description='The key name for the query.

This parameter is required.', example='test_key', position='Query'),
  namespace: string(name='Namespace', description='The name of the namespace that you specify when you call the [CreateKvNamespace](https://help.aliyun.com/document_detail/2850317.html) operation.

This parameter is required.', example='test_namespace', position='Query'),
}

model GetKvResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='EEEBE525-F576-1196-8DAF-2D70CA3F4D2F'),
  value?: string(name='Value', description='The value of the key.', example='test_value'),
}

model GetKvResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetKvResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetKv  GetKvRequest
  * @return GetKvResponse
 */
async function getKv(request: GetKvRequest): GetKvResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetKv', 'GET', '/', 'json', false, 'json', request);
}

model GetKvAccountRequest {
}

model GetKvAccountResponseBody = {
  capacity?: long(name='Capacity', description='The available capacity of all namespaces in the account. Unit: bytes.', example='1073741824'),
  capacityString?: string(name='CapacityString', description='The available capacity of all namespaces in the account.', example='1 GB'),
  capacityUsed?: long(name='CapacityUsed', description='The used capacity of all namespaces in the account. Unit: bytes.', example='10048576'),
  capacityUsedString?: string(name='CapacityUsedString', description='The used capacity of all namespaces in the account.', example='100 MB'),
  namespaceList?: [ 
    {
      capacity?: long(name='Capacity', description='The available capacity of the namespace. Unit: bytes.', example='1073741824'),
      capacityString?: string(name='CapacityString', description='The available capacity of the namespace.', example='1 GB'),
      capacityUsed?: long(name='CapacityUsed', description='The used capacity of the namespace. Unit: bytes.', example='100048576'),
      capacityUsedString?: string(name='CapacityUsedString', description='The used capacity of the namespace.', example='100 MB'),
      description?: string(name='Description', description='The description of the namespace.', example='the first namespace'),
      namespace?: string(name='Namespace', description='The name of the namespace.', example='test_namespace'),
      namespaceId?: string(name='NamespaceId', description='The ID of the namespace.', example='643355322374688768'),
      status?: string(name='Status', description='The status of the namespace. Valid values:

*   **online**: normal.
*   **delete**: pending deletion.
*   **deleting**: being deleted.
*   **deleted**: deleted.', example='online'),
    }
  ](name='NamespaceList', description='The namespaces in the account.'),
  namespaceQuota?: int32(name='NamespaceQuota', description='The maximum number of namespaces that can be created in the account.', example='10'),
  namespaceUsed?: int32(name='NamespaceUsed', description='The number of created namespaces that store key-value data in the account.', example='1'),
  requestId?: string(name='RequestId', description='The request ID.', example='EEEBE525-F576-1196-8DAF-2D70CA3F4D2F'),
  status?: string(name='Status', description='Indicates whether Edge KV is activated for the Alibaba Cloud account.

*   **online**
*   **offline**', example='online'),
}

model GetKvAccountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetKvAccountResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetKvAccount  GetKvAccountRequest
  * @return GetKvAccountResponse
 */
async function getKvAccount(request: GetKvAccountRequest): GetKvAccountResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetKvAccount', 'GET', '/', 'json', false, 'json', request);
}

model GetKvNamespaceRequest {
  namespace: string(name='Namespace', description='The name of the namespace that you specify when you call the [CreateKvNamespace](https://help.aliyun.com/document_detail/2850317.html) operation.

This parameter is required.', example='test_namespace', position='Query'),
}

model GetKvNamespaceResponseBody = {
  capacity?: long(name='Capacity', description='The available capacity of the namespace. Unit: bytes.', example='1073741824'),
  capacityString?: string(name='CapacityString', description='The available capacity of the namespace.', example='1 GB'),
  capacityUsed?: long(name='CapacityUsed', description='The used capacity of the namespace. Unit: bytes.', example='10048576'),
  capacityUsedString?: string(name='CapacityUsedString', description='The used capacity of the namespace.', example='100 MB'),
  description?: string(name='Description', description='The description of the namespace.', example='this is a test namespace.'),
  namespace?: string(name='Namespace', description='The name of the namespace.', example='test_namespace'),
  namespaceId?: string(name='NamespaceId', description='The ID of the namespace.', example='643355322374688768'),
  requestId?: string(name='RequestId', description='The request ID.', example='EEEBE525-F576-1196-8DAF-2D70CA3F4D2F'),
  status?: string(name='Status', description='The status of the namespace. Valid values:

*   **online**: working as expected.
*   **delete**: pending deletion.
*   **deleting**: being deleted.
*   **deleted**: deleted.', example='online'),
}

model GetKvNamespaceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetKvNamespaceResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetKvNamespace  GetKvNamespaceRequest
  * @return GetKvNamespaceResponse
 */
async function getKvNamespace(request: GetKvNamespaceRequest): GetKvNamespaceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetKvNamespace', 'GET', '/', 'json', false, 'json', request);
}

model GetListRequest {
  id?: long(name='Id', description='The ID of the custom list, which can be obtained by calling the [ListLists](https://help.aliyun.com/document_detail/2850217.html) operation.', example='40000001', position='Query'),
}

model GetListResponseBody = {
  description?: string(name='Description', description='The description of the custom list.', example='a custom list', maxLength=1024),
  id?: long(name='Id', description='The ID of the custom list.[](~~2850217~~)', example='40000001'),
  items?: [ string ](name='Items', description='The items in the custom list, which are displayed as an array.'),
  kind?: string(name='Kind', description='The type of the custom list.', example='ip'),
  name: string(name='Name', description='The name of the custom list.

This parameter is required.', example='example', maxLength=128),
  requestId?: string(name='RequestId', description='The request ID.', example='36af3fcc-43d0-441c-86b1-428951dc8225'),
  updateTime?: string(name='UpdateTime', description='The time when the custom list was last modified.', example='2024-01-01T00:00:00Z'),
}

model GetListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetListResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetList  GetListRequest
  * @return GetListResponse
 */
async function getList(request: GetListRequest): GetListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetList', 'POST', '/', 'json', false, 'json', request);
}

model GetOriginProtectionRequest {
  siteId?: long(name='SiteId', description='The website ID. You can call the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation to obtain the ID.', example='123456789****', position='Query'),
}

model GetOriginProtectionResponseBody = {
  currentIPWhitelist?: {
    iPv4?: [ string ](name='IPv4', description='The IP whitelist for origin protection used by the website, specified as IPv4 addresses or CIDR blocks.'),
    iPv6?: [ string ](name='IPv6', description='The IP whitelist for origin protection used by the website, specified as IPv6 addresses or CIDR blocks.'),
  }(name='CurrentIPWhitelist', description='The IP whitelist for origin protection used by the website.'),
  diffIPWhitelist?: {
    addedIPWhitelist?: {
      iPv4?: [ string ](name='IPv4', description='The IP whitelist for origin protection, specified as IPv4 addresses or CIDR blocks.'),
      iPv6?: [ string ](name='IPv6', description='The IP whitelist for origin protection, specified as IPv6 addresses or CIDR blocks.'),
    }(name='AddedIPWhitelist', description='The new IP whitelist for origin protection.'),
    noChangeIpWhitelist?: {
      iPv4?: [ string ](name='IPv4', description='The IP whitelist for origin protection, specified as IPv4 addresses or CIDR blocks.'),
      iPv6?: [ string ](name='IPv6', description='The IP whitelist for origin protection, specified as IPv6 addresses or CIDR blocks.'),
    }(name='NoChangeIpWhitelist', description='The IP whitelist for origin protection that remains unchanged.'),
    removedIPWhitelist?: {
      iPv4?: [ string ](name='IPv4', description='The IP whitelist for origin protection, specified as IPv4 addresses or CIDR blocks.'),
      iPv6?: [ string ](name='IPv6', description='The IP whitelist for origin protection, specified as IPv6 addresses or CIDR blocks.'),
    }(name='RemovedIPWhitelist', description='The IP whitelist for origin protection that has been deleted.'),
  }(name='DiffIPWhitelist', description='The IP whitelist for origin protection that has been updated.'),
  latestIPWhitelist?: {
    iPv4?: [ string ](name='IPv4', description='The latest IP whitelist for origin protection, specified as IPv4 addresses or CIDR blocks.'),
    iPv6?: [ string ](name='IPv6', description='The latest IP whitelist for origin protection, specified as IPv6 addresses or CIDR blocks.'),
  }(name='LatestIPWhitelist', description='The latest IP whitelist for origin protection.'),
  needUpdate?: boolean(name='NeedUpdate', description='Indicates whether the IP whitelist for origin protection needs to be updated. If the currently used IP whitelist is different from the latest IP whitelist, it needs to be updated, and the value is true.

*   true: The update is required.
*   false: No update is required.', example='true'),
  originConverge?: string(name='OriginConverge', description='Indicates whether IP convergence is enabled.

*   on
*   off', example='on'),
  originProtection?: string(name='OriginProtection', description='Indicates whether origin protection is enabled.

*   on
*   off', example='on'),
  requestId?: string(name='RequestId', description='The request ID.', example='CB1A380B-09F0-41BB-A198-72F8FD6DA2FE'),
  siteId?: long(name='SiteId', description='The website ID.', example='123456****'),
}

model GetOriginProtectionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetOriginProtectionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetOriginProtection  GetOriginProtectionRequest
  * @return GetOriginProtectionResponse
 */
async function getOriginProtection(request: GetOriginProtectionRequest): GetOriginProtectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetOriginProtection', 'GET', '/', 'json', false, 'json', request);
}

model GetPageRequest {
  id?: long(name='Id', description='The ID of the custom error page, which can be obtained by calling the [ListPages](https://help.aliyun.com/document_detail/2850223.html) operation.', example='50000001', position='Query'),
}

model GetPageResponseBody = {
  content: string(name='Content', description='The Base64-encoded content of the error page. The content type is specified by the Content-Type field.

This parameter is required.', example='PGh0bWw+aGVsbG8gcGFnZTwvaHRtbD4='),
  contentType: string(name='ContentType', description='The Content-Type field in the HTTP header.

This parameter is required.', example='text/html'),
  description?: string(name='Description', description='The description of the custom error page.', example='a custom deny page', maxLength=1024),
  id?: long(name='Id', description='The ID of the custom error page.[](~~2850223~~)', example='50000001'),
  kind?: string(name='Kind', description='The type of the custom response page.', example='custom'),
  name: string(name='Name', description='The name of the custom response page.

This parameter is required.', example='example', maxLength=128),
  requestId?: string(name='RequestId', description='The request ID.', example='36af3fcc-43d0-441c-86b1-428951dc8225'),
  updateTime?: string(name='UpdateTime', description='The time when the custom error page was last modified.', example='2024-01-01T00:00:00Z'),
}

model GetPageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetPageResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetPage  GetPageRequest
  * @return GetPageResponse
 */
async function getPage(request: GetPageRequest): GetPageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetPage', 'POST', '/', 'json', false, 'json', request);
}

model GetPurgeQuotaRequest {
  siteId?: long(name='SiteId', description='The website ID. You can call the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation to obtain the ID.', example='123456789****', position='Query'),
  type?: string(name='Type', description='The type of the purge task. Valid values:

*   **file** (default): purges the cache by file.
*   **cachetag**: purges the cache by cache tag.
*   **directory**: purges the cache by directory.
*   **ignoreParams**: purges the cache by URL with specific parameters ignored.
*   **hostname**: purges the cache by hostname.
*   **purgeall**: purges all cache.', example='file', position='Query'),
}

model GetPurgeQuotaResponseBody = {
  quota?: string(name='Quota', description='The total quota.', example='100000'),
  requestId?: string(name='RequestId', description='The request ID.', example='15C66C7B-671A-4297-9187-2C4477247A74'),
  usage?: string(name='Usage', description='The quota usage.', example='10'),
}

model GetPurgeQuotaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetPurgeQuotaResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetPurgeQuota  GetPurgeQuotaRequest
  * @return GetPurgeQuotaResponse
 */
async function getPurgeQuota(request: GetPurgeQuotaRequest): GetPurgeQuotaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetPurgeQuota', 'GET', '/', 'json', false, 'json', request);
}

model GetRealtimeDeliveryFieldRequest {
  businessType: string(name='BusinessType', description='The log category. Valid values:

*   **dcdn_log_access_l1** (default): access logs.
*   **dcdn_log_er**: Edge Routine logs.
*   **dcdn_log_waf**: firewall logs.
*   **dcdn_log_ipa**: TCP/UDP proxy logs.

This parameter is required.', example='dcdn_log_er', position='Query'),
}

model GetRealtimeDeliveryFieldResponseBody = {
  fieldContent?: map[string]FieldContentValue(name='FieldContent', description='The fields returned.'),
  requestId?: string(name='RequestId', description='The request ID.', example='15C66C7B-671A-4297-9187-2C4477247B78'),
}

model GetRealtimeDeliveryFieldResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetRealtimeDeliveryFieldResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetRealtimeDeliveryField  GetRealtimeDeliveryFieldRequest
  * @return GetRealtimeDeliveryFieldResponse
 */
async function getRealtimeDeliveryField(request: GetRealtimeDeliveryFieldRequest): GetRealtimeDeliveryFieldResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetRealtimeDeliveryField', 'GET', '/', 'json', false, 'json', request);
}

model GetRecordRequest {
  recordId: long(name='RecordId', description='The record ID, which can be obtained by calling [ListRecords](https://help.aliyun.com/document_detail/2850265.html).

This parameter is required.', example='1234567890123', position='Query'),
}

model GetRecordResponseBody = {
  recordModel?: {
    authConf?: {
      accessKey?: string(name='AccessKey', description='The access key ID of the account to which the origin server belongs. This parameter is returned if the origin type is OSS and AuthType is set to private_cross_account, or the origin type is S3 and AuthType is set to private.', example='VIxuvJSA2S03f******kp208dy5w7'),
      authType?: string(name='AuthType', description='The authentication type of the origin server. Different origins support different authentication types. The origin type refers to the SourceType parameter in this operation. This parameter is returned if the origin type is OSS or S3Valid values:

*   **public**: public read. This value is returned when the origin is a public OSS or S3 bucket.
*   **private**: private read. This value is returned when the origin is a private S3 bucket.
*   **private_same_account**: private read in the same account. This value is returned when the origin is a private OSS bucket in your account.
*   **private_cross_account**: private read across accounts. This value is returned when the origin is a private OSS bucket in a different Alibaba Cloud account.', example='public'),
      region?: string(name='Region', description='The region of the origin. If the origin type is S3, you must specify this value. You can obtain the region information from the official website of S3.', example='us-east-1'),
      secretKey?: string(name='SecretKey', description='The secret access key of the account to which the origin server belongs. This parameter is returned if the origin type is OSS and AuthType is set to private_cross_account, or the origin type is S3 and AuthType is set to private.SecretKey', example='u0Nkg5gBK*******QF5wvKMM504JUHt'),
      version?: string(name='Version', description='The version of the signature algorithm. This parameter is returned when the origin type is S3 and AuthType is private. The following two types are supported:

*   **v2**
*   **v4**

If this parameter is left empty, the default value v4 is used.', example='v2'),
    }(name='AuthConf', description='The origin authentication information of the CNAME record.'),
    bizName?: string(name='BizName', description='The business scenario of the record for acceleration. Leave this parameter empty if your record is not proxied. Valid values:

*   **image_video**
*   **api**
*   **web**', example='image_video'),
    comment?: string(name='Comment', description='The comments of the record.', example='This is a comment.'),
    createTime?: string(name='CreateTime', description='The time when the record was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.', example='2023-03-10T13:30:39Z'),
    data?: {
      algorithm?: int32(name='Algorithm', description='The encryption algorithm used for the record, specified within the range from 0 to 255. This parameter is required when you add CERT or SSHFP records.', example='1'),
      certificate?: string(name='Certificate', description='The public key of the certificate. This parameter is required when you add CERT, SMIMEA, or TLSA records.', example='dGVzdGFkYWxrcw=='),
      fingerprint?: string(name='Fingerprint', description='The public key fingerprint of the record. This parameter is required when you add a SSHFP record.', example='abcdef1234567890'),
      flag?: int32(name='Flag', description='The flag bit of the record. The Flag for a CAA record indicates its priority and how it is processed, specified within the range of 0 to 255. This parameter is required when you add a CAA record.', example='128'),
      keyTag?: int32(name='KeyTag', description='The public key identification for the record. Valid values: 0 to 65535. This parameter is required when you add a CAA record.', example='1'),
      matchingType?: int32(name='MatchingType', description='The algorithm policy used to match or validate the certificate, specified within the range 0 to 255. This parameter is required when you add SMIMEA or TLSA records.', example='1'),
      port?: int32(name='Port', description='The port of the record. Valid values: 0 to 65535. This parameter is required when you add an SRV record.', example='8707'),
      priority?: int32(name='Priority', description='The priority of the record. Valid values: 0 to 65535. A smaller value indicates a higher priority. This parameter is required when you add MX, SRV, and URI records.', example='10'),
      selector?: int32(name='Selector', description='The type of the certificate or public key, specified within the range of 0 to 255. This parameter is required when you add SMIMEA or TLSA records.', example='1'),
      tag?: string(name='Tag', description='The tag of the record. The Tag of a CAA record indicate its specific type and usage.', example='issue'),
      type?: int32(name='Type', description='The certificate type of the record (in CERT records), or the public key type (in SSHFP records). This parameter is required when you add CERT or SSHFP records.', example='RSA'),
      usage?: int32(name='Usage', description='The usage identifier of the record, specified within the range of 0 to 255. This parameter is required when you add SMIMEA or TLSA records.', example='0'),
      value?: string(name='Value', description='The record value or part of the record content. This parameter is returned when you add A/AAAA, CNAME, NS, MX, TXT, CAA, SRV, and URI records. It has different meanings based on types of records.

*   **A/AAAA**: the IP address. Multiple IP addresses are separated with commas (,). There is at least one IPv4 address.
*   **CNAME**: the target domain name.
*   **NS**: the nameserver for the domain name.
*   **MX**: a valid domain name of the target mail server.
*   **TXT**: a valid text string.
*   **CAA**: a valid domain name of the certificate authority.
*   **SRV**: a valid domain name of the target host.
*   **URI**: a valid URI string.', example='example.com'),
      weight?: int32(name='Weight', description='The weight of the record, specified within the range of 0 to 65535. This parameter is required when you add SRV or URI records.', example='0'),
    }(name='Data', description='The DNS record information. The content returned by this parameter varies based on the record type.', example='{"value":"1.1.1.1"}'),
    hostPolicy?: string(name='HostPolicy', description='The origin host policy. This policy takes effect when the record type is CNAME. Valid values:

*   follow_hostname: matches the requested domain name.
*   follow_origin_domain: matches the origin\\"s domain name.', example='follow_origin_domain'),
    proxied?: boolean(name='Proxied', description='Indicates whether the record is proxied. Only CNAME and A/AAAA records can be proxied. Valid values:

*   **true**
*   **false**', example='true'),
    recordCname?: string(name='RecordCname', description='The CNAME. If you use CNAME setup when you add your website to ESA, the value is the CNAME that you configured then.', example='a.example.com.cnamezone.com'),
    recordId?: long(name='RecordId', description='The record ID.', example='1234567890123'),
    recordName?: string(name='RecordName', description='The record name.', example='a.example.com'),
    recordSourceType?: string(name='RecordSourceType', description='The origin type for the CNAME record. This parameter is required when you add a CNAME record. Valid values:

*   **OSS**: OSS bucket.
*   **S3**: S3 bucket.
*   **LB**: load balancer.
*   **OP**: origin pool.
*   **Domain**: domain name.

If you do not pass this parameter or if you leave its value empty, Domain is returned by default.', example='OSS'),
    recordType?: string(name='RecordType', description='The type of the DNS record, such as **A/AAAA, CNAME, and TXT**.', example='A/AAAA'),
    siteId?: long(name='SiteId', description='The website ID.', example='1234567890123'),
    siteName?: string(name='SiteName', description='The website name.', example='example.com'),
    ttl?: int32(name='Ttl', description='The TTL of the record. Unit: seconds. If the value is 1, the TTL of the record is determined by the system.', example='20'),
    updateTime?: string(name='UpdateTime', description='The time when the record was updated. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.', example='2023-01-27T02:26:22Z'),
  }(name='RecordModel', description='The information about the queried record.'),
  requestId?: string(name='RequestId', description='The request ID.', example='F32C57AA-7BF8-49AE-A2CC-9F42390F5A19'),
}

model GetRecordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetRecordResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetRecord  GetRecordRequest
  * @return GetRecordResponse
 */
async function getRecord(request: GetRecordRequest): GetRecordResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetRecord', 'GET', '/', 'json', false, 'json', request);
}

model GetRoutineRequest {
  name: string(name='Name', description='The routine name.

This parameter is required.', example='GetRoutine', position='Body'),
}

model GetRoutineResponseBody = {
  codeVersions?: [ 
    {
      codeDescription?: string(name='CodeDescription', description='The description of the code version.', example='test ver code desc'),
      codeVersion?: string(name='CodeVersion', description='The code version.', example='1710120201067203242'),
      createTime?: string(name='CreateTime', description='The time when the code version was created.', example='2024-03-11T01:23:21Z'),
    }
  ](name='CodeVersions', description='The code versions.'),
  createTime?: string(name='CreateTime', description='The time when the routine was created.', example='2024-03-11T01:23:21Z'),
  defaultRelatedRecord?: string(name='DefaultRelatedRecord', description='The default record name to access.', example='routine1.example.com'),
  description?: string(name='Description', description='The description of the routine.', example='ZWRpdCByb3V0aW5lIGNvbmZpZyBkZXNjcmlwdGlvbg'),
  envs?: [ 
    {
      canaryAreaList?: [ string ](name='CanaryAreaList', description='The regions for canary release.'),
      canaryCodeVersion?: string(name='CanaryCodeVersion', description='The version number for canary release.', example='1710120201067577628'),
      codeVersion?: string(name='CodeVersion', description='The version number of the code in the environment.', example='1710120201067577628'),
      env?: string(name='Env', description='The environment type.', example='production'),
      specName?: string(name='SpecName', description='The specification.', example='5ms'),
    }
  ](name='Envs', description='The information about the environments.'),
  relatedRecords?: [ 
    {
      recordId?: long(name='RecordId', description='The record ID.', example='509348423011904'),
      recordName?: string(name='RecordName', description='The record name.', example='test-record-1.example.com'),
      siteId?: long(name='SiteId', description='The website ID.', example='54362329990032'),
      siteName?: string(name='SiteName', description='The website name.', example='example.com'),
    }
  ](name='RelatedRecords', description='The records associated with the routine.'),
  relatedRoutes?: [ 
    {
      byPass?: string(name='ByPass'),
      route?: string(name='Route', description='The route.', example='*.example.com/path1*'),
      routeId?: string(name='RouteId', description='The route ID.', example='d501cb8a2c951f32922d260040780c06'),
      siteId?: long(name='SiteId', description='The website ID.', example='54362329990032'),
      siteName?: string(name='SiteName', description='The website name.', example='example.com'),
    }
  ](name='RelatedRoutes', description='The routes associated with the routine.'),
  requestId?: string(name='RequestId', description='The request ID.', example='EDBD3EB3-97DA-5465-AEF5-8DCA5DC5E395'),
}

model GetRoutineResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetRoutineResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetRoutine  GetRoutineRequest
  * @return GetRoutineResponse
 */
async function getRoutine(request: GetRoutineRequest): GetRoutineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetRoutine', 'POST', '/', 'json', true, 'form', request);
}

model GetRoutineStagingCodeUploadInfoRequest {
  codeDescription?: string(name='CodeDescription', description='The code description.', example='the description of code', position='Body'),
  name: string(name='Name', description='The routine name.

This parameter is required.', example='GetRoutineStagingCodeUploadInfo', position='Body'),
}

model GetRoutineStagingCodeUploadInfoResponseBody = {
  codeVersion?: string(name='CodeVersion', description='The code version.', example='1710120201067203242'),
  ossPostConfig?: map[string]any(name='OssPostConfig', description='The configuration information that can be used to upload to OSS.', example='{
            "Url": "http://oss_fake_bucket_url",
            "OSSAccessKeyId": "xxx",
            "key": "site_er_js/hello.1418586423220543.unstable.js",
            "callback": "xxx==",
            "x:codeDescription": "xxx=",
            "policy": "xxx",
            "Signature": "xxx="
}'),
  requestId?: string(name='RequestId', description='The request ID.', example='EDBD3EB3-97DA-5465-AEF5-8DCA5DC5E395'),
}

model GetRoutineStagingCodeUploadInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetRoutineStagingCodeUploadInfoResponseBody(name='body'),
}

/**
  * @description *   Every time the code of a routine is released to the staging environment, a version number is generated. Such code is for tests only.
  * *   A routine can retain a maximum of 10 code versions. If the number of versions reaches the limit, you must call the DeleteRoutineCodeRevision operation to delete unwanted versions.
  * @param request  the request parameters of GetRoutineStagingCodeUploadInfo  GetRoutineStagingCodeUploadInfoRequest
  * @return GetRoutineStagingCodeUploadInfoResponse
 */
async function getRoutineStagingCodeUploadInfo(request: GetRoutineStagingCodeUploadInfoRequest): GetRoutineStagingCodeUploadInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetRoutineStagingCodeUploadInfo', 'POST', '/', 'json', true, 'form', request);
}

model GetRoutineStagingEnvIpRequest {
}

model GetRoutineStagingEnvIpResponseBody = {
  IPV4?: [ string ](name='IPV4', description='The IPv4 addresses.'),
  requestId?: string(name='RequestId', description='The request ID.', example='EDBD3EB3-97DA-5465-AEF5-8DCA5DC5E395'),
}

model GetRoutineStagingEnvIpResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetRoutineStagingEnvIpResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetRoutineStagingEnvIp  GetRoutineStagingEnvIpRequest
  * @return GetRoutineStagingEnvIpResponse
 */
async function getRoutineStagingEnvIp(request: GetRoutineStagingEnvIpRequest): GetRoutineStagingEnvIpResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetRoutineStagingEnvIp', 'POST', '/', 'json', false, 'json', request);
}

model GetRoutineUserInfoRequest {
}

model GetRoutineUserInfoResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='EDBD3EB3-97DA-5465-AEF5-8DCA5DC5E395'),
  routines?: [ 
    {
      createTime?: string(name='CreateTime', description='The time when the routine was created.', example='2024-03-11T01:23:02.883361712Z'),
      description?: string(name='Description', description='The routine description, which is Base64-encoded.', example='ZWRpdCByb3V0aW5lIGNvbmZpZyBkZXNjcmlwdGlvbg'),
      routineName?: string(name='RoutineName', description='The routine name.', example='test-routine1'),
    }
  ](name='Routines', description='The routines.'),
  subdomains?: [ string ](name='Subdomains', description='The subdomains.'),
}

model GetRoutineUserInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetRoutineUserInfoResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetRoutineUserInfo  GetRoutineUserInfoRequest
  * @return GetRoutineUserInfoResponse
 */
async function getRoutineUserInfo(request: GetRoutineUserInfoRequest): GetRoutineUserInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetRoutineUserInfo', 'POST', '/', 'json', false, 'json', request);
}

model GetScheduledPreloadJobRequest {
  id: string(name='Id', description='The ID of the scheduled prefetch task.

This parameter is required.', example='GetScheduledPreloadJob', position='Query'),
}

model GetScheduledPreloadJobResponseBody = {
  aliUid?: string(name='AliUid', description='The ID of the Alibaba Cloud account.', example='15685865xxx14622'),
  createdAt?: string(name='CreatedAt', description='The time when the task was created.', example='2024-06-02T02:23:26Z'),
  domains?: string(name='Domains', description='The domain names to be prefetched.', example='testurl.com'),
  errorInfo?: string(name='ErrorInfo', description='The error message that is returned.', example='invalid domain:test.com'),
  failedFileOss?: string(name='FailedFileOss', description='The URL of the OSS object that stores a list of URLs that failed the conditional check for prefetching.', example='https://xxxobject.oss-cn-reginon.aliyuncs.com/9d91_xxxxxxxxxxx_158bb6e0f97c477791209bb46bd599f7'),
  fileId?: string(name='FileId', description='The ID of the URL list file, which can be used during downloads.', example='665d3b48621bccf3fe29e1a7'),
  id?: string(name='Id', description='The ID of the prefetch task.', example='665d3af3621bccf3fe29e1a4'),
  insertWay?: string(name='InsertWay', description='The method to submit the URLs to be prefetched.', example='oss'),
  name?: string(name='Name', description='The task name.', example='example'),
  requestId?: string(name='RequestId', description='The request ID.', example='15C66C7B-671A-4297-9187-2C4477247A74'),
  siteId?: long(name='SiteId', description='The website ID.', example='190007158391808'),
  taskSubmitted?: int32(name='TaskSubmitted', description='The number of submitted prefetch tasks.', example='1'),
  taskType?: string(name='TaskType', description='The task type. Valid values: refresh and preload.', example='preload'),
  urlCount?: int32(name='UrlCount', description='The total number of URLs.', example='2'),
  urlSubmitted?: int32(name='UrlSubmitted', description='The number of submitted URLs.', example='1'),
}

model GetScheduledPreloadJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetScheduledPreloadJobResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetScheduledPreloadJob  GetScheduledPreloadJobRequest
  * @return GetScheduledPreloadJobResponse
 */
async function getScheduledPreloadJob(request: GetScheduledPreloadJobRequest): GetScheduledPreloadJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetScheduledPreloadJob', 'GET', '/', 'json', false, 'json', request);
}

model GetSiteRequest {
  siteId: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.

This parameter is required.', example='1234567890123', position='Query'),
}

model GetSiteResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='9732E117-8A37-49FD-A36F-ABBB87556CA7'),
  siteModel?: {
    accessType?: string(name='AccessType', description='The DNS setup option for the website. Valid values:

*   **NS**
*   **CNAME**', example='NS'),
    cnameZone?: string(name='CnameZone', description='The CNAME of the website domain. If you use CNAME setup when you add your website to ESA, the value is the CNAME that you configured then.', example='example.cname.com'),
    coverage?: string(name='Coverage', description='The service location. Valid values:

*   **domestic**: the Chinese mainland.
*   **global**: global.
*   **overseas**: outside the Chinese mainland.', example='domestic'),
    createTime?: string(name='CreateTime', description='The time when the WEBsite was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format and is displayed in UTC.', example='2023-12-24T02:01:11Z'),
    instanceId?: string(name='InstanceId', description='The plan ID.', example='cas-merge-q6h0bv'),
    nameServerList?: string(name='NameServerList', description='The nameservers assigned to the website domain. They are separated by commas (,).', example='male1-1.ialicdn.com,female1-1.ialicdn.com'),
    planName?: string(name='PlanName', description='The plan name.', example='plan-168777532****'),
    planSpecName?: string(name='PlanSpecName', description='The specification of the plan associated with the website.', example='normal'),
    resourceGroupId?: string(name='ResourceGroupId', description='The ID of your Alibaba Cloud resource group.', example='rg-aek26g6i6se****'),
    siteId?: long(name='SiteId', description='The website ID.', example='1234567890123'),
    siteName?: string(name='SiteName', description='The website name.', example='example.com'),
    status?: string(name='Status', description='The website status. Valid values:

*   **pending**: The website is to be configured.
*   **active**: The website is active.
*   **offline**: The website is suspended.
*   **moved**: The website has been added and verified by another Alibaba Cloud account.', example='pending'),
    tags?: map[string]any(name='Tags', description='The tags of the website.', example='{"tag1":"value1"}'),
    updateTime?: string(name='UpdateTime', description='The time when the WEBsite was updated. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format and is displayed in UTC.', example='2023-12-24T02:01:11Z'),
    vanityNSList?: map[string]string(name='VanityNSList', description='The information about custom nameservers of the website domain. The key is a custom nameserver name, and the value is the IP address of the custom nameserver. Multiple IP addresses are separated by commas (,).'),
    verifyCode?: string(name='VerifyCode', description='The code that is used to verify the website domain ownership. As part of the verification TXT record, this parameter is returned for websites that use CNAME setup.', example='verify_d516cb3740f81f0cef77d162edd1****'),
    versionManagement?: boolean(name='VersionManagement', description='The status of version management. If true is returned, version management is enabled for the website.', example='true'),
  }(name='SiteModel', description='The queried website information.'),
}

model GetSiteResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetSiteResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetSite  GetSiteRequest
  * @return GetSiteResponse
 */
async function getSite(request: GetSiteRequest): GetSiteResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetSite', 'GET', '/', 'json', false, 'json', request);
}

model GetSiteCurrentNSRequest {
  siteId: long(name='SiteId', description='The website ID. It can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.

This parameter is required.', example='1234567890123', position='Query'),
}

model GetSiteCurrentNSResponseBody = {
  NSList?: [ string ](name='NSList', description='The nameservers of the website.'),
  requestId?: string(name='RequestId', description='The request ID.', example='2430E05E-1340-5773-B5E1-B743929F46F2'),
}

model GetSiteCurrentNSResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetSiteCurrentNSResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetSiteCurrentNS  GetSiteCurrentNSRequest
  * @return GetSiteCurrentNSResponse
 */
async function getSiteCurrentNS(request: GetSiteCurrentNSRequest): GetSiteCurrentNSResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetSiteCurrentNS', 'GET', '/', 'json', false, 'json', request);
}

model GetSiteCustomLogRequest {
  siteId: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.

This parameter is required.', example='11223***', position='Query'),
}

model GetSiteCustomLogResponseBody = {
  configId?: long(name='ConfigId', description='The ID of the custom log field configuration.', example='6befa4aa-2a94-4f51-a245-295787192d2c'),
  isExist?: boolean(name='IsExist', description='Indicates whether the custom configuration exists.', example='true'),
  logCustomField?: {
    cookies?: [ string ](name='Cookies', description='The cookie fields.'),
    requestHeaders?: [ string ](name='RequestHeaders', description='The request header fields.'),
    responseHeaders?: [ string ](name='ResponseHeaders', description='The response header fields.'),
  }(name='LogCustomField', description='The custom fields.'),
  requestId?: string(name='RequestId', description='The request ID.', example='6befa4aa-2a94-4f51-a245-295787192d2c'),
  siteId?: long(name='SiteId', description='The website ID.', example='167026711***'),
}

model GetSiteCustomLogResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetSiteCustomLogResponseBody(name='body'),
}

/**
  * @description *   **Description**: You can call this operation to query the configuration of custom log fields for a website, including custom fields in request headers, response headers, and cookies.
  * *   **Scenarios**: You can call this operation in scenarios where you need to obtain specific HTTP headers or cookie information for log analysis.
  * *   ****
  * @param request  the request parameters of GetSiteCustomLog  GetSiteCustomLogRequest
  * @return GetSiteCustomLogResponse
 */
async function getSiteCustomLog(request: GetSiteCustomLogRequest): GetSiteCustomLogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetSiteCustomLog', 'GET', '/', 'json', false, 'json', request);
}

model GetSiteDeliveryTaskRequest {
  siteId?: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.', example='123456***', position='Query'),
  taskName: string(name='TaskName', description='The name of the delivery task.

This parameter is required.', example='cdn-test-task', position='Query'),
}

model GetSiteDeliveryTaskResponseBody = {
  businessType?: string(name='BusinessType', description='The log category. Valid values:

*   dcdn_log_access_l1 (default): access logs.
*   dcdn_log_er: Edge Routine logs.
*   dcdn_log_waf: firewall logs.
*   dcdn_log_ipa: TCP/UDP proxy logs.', example='dcdn_log_access_l1'),
  dataCenter?: string(name='DataCenter', description='The data center. Valid values:

1.  cn: the Chinese mainland.
2.  sg: outside the Chinese mainland.', example='cn'),
  deliveryType?: string(name='DeliveryType', description='The destination of the delivery. Valid values:

1.  sls: Alibaba Cloud Simple Log Service (SLS).
2.  http: HTTP server.
3.  aws3: Amazon Simple Storage Service (S3).
4.  oss: Alibaba Cloud Object Storage Service (OSS).
5.  kafka: Kafka.
6.  aws3cmpt: S3-compatible storage service.', example='sls'),
  discardRate?: float(name='DiscardRate', description='The discard rate.', example='0.0'),
  fieldList?: string(name='FieldList', description='The log fields.', example='Client,UserAgent'),
  filterRules?: string(name='FilterRules', description='The filtering rules.', example='[]'),
  requestId?: string(name='RequestId', description='The request ID.', example='34DCBC8A-****-****-****-6DAA11D7DDBD'),
  sinkConfig?: any(name='SinkConfig', description='The delivery configuration.', example='{\\"Region\\": \\"cn-hangzhou\\", \\"Endpoint\\": \\"https://***.oss-cn-hangzhou.aliyuncs.com\\", \\"BucketPath\\": \\"hjy-test002/online-logs\\"}'),
  siteId?: long(name='SiteId', description='The website ID.', example='123456****'),
  siteName?: string(name='SiteName', description='The website name.', example='test.***.com'),
  status?: string(name='Status', description='The status of the delivery task.

*   **online**
*   **offline**', example='online'),
  taskName?: string(name='TaskName', description='The name of the delivery task.', example='cdn-test-task'),
}

model GetSiteDeliveryTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetSiteDeliveryTaskResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetSiteDeliveryTask  GetSiteDeliveryTaskRequest
  * @return GetSiteDeliveryTaskResponse
 */
async function getSiteDeliveryTask(request: GetSiteDeliveryTaskRequest): GetSiteDeliveryTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetSiteDeliveryTask', 'GET', '/', 'json', false, 'json', request);
}

model GetSiteLogDeliveryQuotaRequest {
  businessType: string(name='BusinessType', description='The log category. Valid values:

1.  dcdn_log_access_l1 (default): access logs.
2.  dcdn_log_er: Edge Routine logs.
3.  dcdn_log_waf: firewall logs.
4.  dcdn_log_ipa: TCP/UDP proxy logs.

This parameter is required.', example='dcdn_log_access_l1', position='Query'),
  siteId: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.

This parameter is required.', example='123456****', position='Query'),
}

model GetSiteLogDeliveryQuotaResponseBody = {
  businessType?: string(name='BusinessType', description='The log category. Valid values:

1.  dcdn_log_access_l1 (default): access logs.
2.  dcdn_log_er: Edge Routine logs.
3.  dcdn_log_waf: firewall logs.
4.  dcdn_log_ipa: TCP/UDP proxy logs.', example='dcdn_log_access_l1'),
  freeQuota?: long(name='FreeQuota', description='The remaining quota.', example='3'),
  requestId?: string(name='RequestId', description='The request ID.', example='4C14840EF0EAAB6D97CDE0C5F6554ACE'),
  siteId?: long(name='SiteId', description='The website ID.', example='123456****'),
}

model GetSiteLogDeliveryQuotaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetSiteLogDeliveryQuotaResponseBody(name='body'),
}

/**
  * @description You can call this operation to query the remaining quota for delivering a specific category of real-time logs in a website within an Alibaba Cloud account. This is essential for monitoring and managing your log delivery capacity to ensure that logs can be delivered to the destination and prevent data loss or latency caused by insufficient quota.
  * **Take note of the following parameters:**
  * *   ``
  * *   `BusinessType` is required. You must specify a log category to obtain the corresponding quota information.
  * *   `SiteId` specifies the ID of a website, which must be a valid integer that corresponds to a website that you configured on Alibaba Cloud.
  * **Response:**
  * *   If a request is successful, the system returns the remaining log delivery quota (`FreeQuota`), request ID (`RequestId`), website ID (`SiteId`), and log category (`BusinessType`). You can confirm and record the returned data.
  * @param request  the request parameters of GetSiteLogDeliveryQuota  GetSiteLogDeliveryQuotaRequest
  * @return GetSiteLogDeliveryQuotaResponse
 */
async function getSiteLogDeliveryQuota(request: GetSiteLogDeliveryQuotaRequest): GetSiteLogDeliveryQuotaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetSiteLogDeliveryQuota', 'GET', '/', 'json', false, 'json', request);
}

model GetSiteWafSettingsRequest {
  siteId?: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.', example='1', position='Query'),
  siteVersion?: int32(name='SiteVersion', description='The version of the website.', example='0', position='Query'),
}

model GetSiteWafSettingsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='36af3fcc-43d0-441c-86b1-428951dc8225'),
  settings?: WafSiteSettings(name='Settings', description='The WAF configurations of the website.'),
}

model GetSiteWafSettingsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetSiteWafSettingsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetSiteWafSettings  GetSiteWafSettingsRequest
  * @return GetSiteWafSettingsResponse
 */
async function getSiteWafSettings(request: GetSiteWafSettingsRequest): GetSiteWafSettingsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetSiteWafSettings', 'POST', '/', 'json', false, 'json', request);
}

model GetUploadTaskRequest {
  siteId?: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.', example='123456****', position='Query'),
  uploadId?: long(name='UploadId', description='The ID of the file upload task. This field is assigned after you call the [UploadFile](https://help.aliyun.com/document_detail/2850466.html) operation.', example='159253299357****', position='Query'),
}

model GetUploadTaskResponseBody = {
  description?: string(name='Description', description='The error message returned when the file upload task failed.', example='invalid url'),
  requestId?: string(name='RequestId', description='The request ID.', example='ET5BF670-09D5-4D0B-BEBY-D96A2A52****'),
  status?: string(name='Status', description='The task status.

*   **INIT**: The task is being initialized.
*   **activacted**: The task is activated.
*   **running**: The task is running.
*   **success**: The task is successful.
*   **partial**: The task is partially successful.
*   **fail**: The task failed.', example='running'),
}

model GetUploadTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetUploadTaskResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetUploadTask  GetUploadTaskRequest
  * @return GetUploadTaskResponse
 */
async function getUploadTask(request: GetUploadTaskRequest): GetUploadTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetUploadTask', 'GET', '/', 'json', false, 'json', request);
}

model GetUserDeliveryTaskRequest {
  taskName: string(name='TaskName', description='The name of the delivery task.

This parameter is required.', example='test_project', position='Query'),
}

model GetUserDeliveryTaskResponseBody = {
  businessType?: string(name='BusinessType', description='The log category. Valid values:

*   **dcdn_log_access_l1** (default): access logs.
*   **dcdn_log_er**: Edge Routine logs.
*   **dcdn_log_waf**: firewall logs.
*   **dcdn_log_ipa**: TCP/UDP proxy logs.', example='dcdn_log_er'),
  dataCenter?: string(name='DataCenter', description='The data center. Valid values:

*   cn: the Chinese mainland.
*   sg: outside the Chinese mainland.', example='cn'),
  deliveryType?: string(name='DeliveryType', description='The destination of the delivery. Valid values:

*   sls: Alibaba Cloud Simple Log Service (SLS).
*   http: HTTP server.
*   aws3: Amazon Simple Storage Service (S3).
*   oss: Alibaba Cloud Object Storage Service (OSS).
*   kafka: Kafka.
*   aws3cmpt: S3-compatible storage service.', example='oss'),
  discardRate?: float(name='DiscardRate', description='The discard rate.', example='0'),
  fieldList?: string(name='FieldList', description='The fields.', example='ClientRequestID,ClientRequestHost'),
  filterRules?: string(name='FilterRules', description='The filtering rules.', example='[{"ClientSSLProtocol": {"equals": ["TLSv1.3"]}}]'),
  requestId?: string(name='RequestId', description='The request ID.', example='7072132a-bd3c-46a6-9e81-aba3e0e3f861'),
  sinkConfig?: any(name='SinkConfig', description='The delivery configuration.', example='{\\"Project\\": \\"er-online-hjy-pro\\", \\"Logstore\\": \\"er-online-hjy-log\\", \\"Region\\": \\"cn-hangzhou\\", \\"Endpoint\\": \\"cn-hangzhou.log.aliyuncs.com\\", \\"Aliuid\\": \\"1077912128805410\\"}'),
  status?: string(name='Status', description='The status of the delivery task.', example='online'),
  taskName?: string(name='TaskName', description='The name of the delivery task.', example='testoss11'),
}

model GetUserDeliveryTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetUserDeliveryTaskResponseBody(name='body'),
}

/**
  * @description *   This API operation queries the details of a delivery task, including the task name, discard rate, region, log category, status, delivery destination, configuration, and filtering rules.****
  * *   You can call this operation to query detailed information about a log delivery task to analyze log processing efficiency or troubleshoot delivery problems.****
  * *   ****````
  * @param request  the request parameters of GetUserDeliveryTask  GetUserDeliveryTaskRequest
  * @return GetUserDeliveryTaskResponse
 */
async function getUserDeliveryTask(request: GetUserDeliveryTaskRequest): GetUserDeliveryTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetUserDeliveryTask', 'GET', '/', 'json', false, 'json', request);
}

model GetUserLogDeliveryQuotaRequest {
  businessType: string(name='BusinessType', description='The log category. Valid values:

*   dcdn_log_access_l1 (default): access logs.
*   dcdn_log_er: Edge Routine logs.
*   dcdn_log_waf: firewall logs.
*   dcdn_log_ipa: TCP/UDP proxy logs.

This parameter is required.', example='dcdn_log_access_l1', position='Query'),
}

model GetUserLogDeliveryQuotaResponseBody = {
  businessType?: string(name='BusinessType', description='The log category. Valid values:

*   dcdn_log_access_l1 (default): access logs.
*   dcdn_log_er: Edge Routine logs.
*   dcdn_log_waf: firewall logs.
*   dcdn_log_ipa: TCP/UDP proxy logs.', example='dcdn_log_access_l1'),
  freeQuota?: long(name='FreeQuota', description='The remaining quota.', example='3'),
  requestId?: string(name='RequestId', description='The request ID.', example='34DCBC8A-****-****-****-6DAA11D7DDBD'),
}

model GetUserLogDeliveryQuotaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetUserLogDeliveryQuotaResponseBody(name='body'),
}

/**
  * @description This operation allows you to query the remaining real-time log delivery quota of each log category in your Alibaba Cloud account. You must provide your Alibaba Cloud account ID (aliUid) and log category (BusinessType). The system then returns the remaining quota of the log category to help you track the usage.
  * @param request  the request parameters of GetUserLogDeliveryQuota  GetUserLogDeliveryQuotaRequest
  * @return GetUserLogDeliveryQuotaResponse
 */
async function getUserLogDeliveryQuota(request: GetUserLogDeliveryQuotaRequest): GetUserLogDeliveryQuotaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetUserLogDeliveryQuota', 'GET', '/', 'json', false, 'json', request);
}

model GetWafBotAppKeyRequest {
}

model GetWafBotAppKeyResponseBody = {
  appKey?: string(name='AppKey', description='The application key.', example='example_appkey'),
  requestId?: string(name='RequestId', description='The request ID.', example='36af3fcc-43d0-441c-86b1-428951dc8225'),
}

model GetWafBotAppKeyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetWafBotAppKeyResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetWafBotAppKey  GetWafBotAppKeyRequest
  * @return GetWafBotAppKeyResponse
 */
async function getWafBotAppKey(request: GetWafBotAppKeyRequest): GetWafBotAppKeyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetWafBotAppKey', 'POST', '/', 'json', false, 'json', request);
}

model GetWafFilterRequest {
  phase?: string(name='Phase', description='The WAF rule category to which the filter conditions to query belong.', example='http_bot', position='Query'),
  siteId?: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.', example='1', position='Query'),
  target?: string(name='Target', description='The condition for matching incoming requests.', example='characteristics', position='Query'),
  type?: string(name='Type', description='The rule type.', example='http_custom_cc', position='Query'),
}

model GetWafFilterResponseBody = {
  filter?: {
    fields?: [ 
      {
        key?: string(name='Key', description='The field for matched objects in the system.', example='http.request.headers'),
        label?: string(name='Label', description='The label of the matched object.', example='Header'),
        logics?: [ 
          {
            attributes?: int32(name='Attributes', description='A custom attribute. For example, this parameter can specify whether the value is case-sensitive.', example='1'),
            kind?: string(name='Kind', description='The type of the value input box. Valid values:

*   select:single
*   select:multi
*   input:single
*   input:multi', example='input:single'),
            negative?: boolean(name='Negative', description='Indicates whether the match result is inverted.'),
            operator?: string(name='Operator', description='The displayed matching characters.', example='Does not equal'),
            symbol?: string(name='Symbol', description='The matching characters in the system.', example='eq'),
            tip?: string(name='Tip', description='The tip on how to enter a valid value that is required by the rules.', example='e.g. image/jpeg'),
            type?: string(name='Type', description='The type of the value. Valid values:

*   integer
*   integer_slice
*   string
*   string_slice', example='string'),
            validator?: {
              errMsg?: string(name='ErrMsg', description='The error message when the validation fails.', example='Enter a valid expression'),
              length?: WafQuotaInteger(name='Length', description='The length of the value.'),
              pattern?: string(name='Pattern', description='The regular expression pattern of the value, which is used to validate strings.', example='^example$'),
              range?: WafQuotaInteger(name='Range', description='The range of the value, which is used to validate numbers.'),
            }(name='Validator', description='The validator, which defines the validation rules for a value.'),
          }
        ](name='Logics', description='The logical conditions.'),
        selector?: {
          data?: [ 
            {
              label?: string(name='Label', description='The label of the data.', example='China'),
              value?: string(name='Value', description='The value of the data.', example='CN'),
            }
          ](name='Data', description='The data. This parameter is available only when the value of the Kind parameter is data.'),
          kind?: string(name='Kind', description='The type of selector. Valid values: data and others.', example='data'),
        }(name='Selector', description='The selector, which defines how to select a matched object.'),
        sub?: boolean(name='Sub', description='Indicates whether the matched object contains a subfield.', example='true'),
        subTip?: string(name='SubTip', description='The tip on how to enter a subfield.', example='e.g. Content-Type'),
      }
    ](name='Fields', description='The matched objects and related properties.'),
    phase?: string(name='Phase', description='The WAF rule category.', example='http_bot'),
    target?: string(name='Target', description='The condition for matching incoming requests.', example='characteristics'),
    type?: string(name='Type', description='The rule type.', example='http_custom_cc'),
  }(name='Filter', description='The returned match conditions.'),
  requestId?: string(name='RequestId', description='The request ID.', example='36af3fcc-43d0-441c-86b1-428951dc8225'),
}

model GetWafFilterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetWafFilterResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetWafFilter  GetWafFilterRequest
  * @return GetWafFilterResponse
 */
async function getWafFilter(request: GetWafFilterRequest): GetWafFilterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetWafFilter', 'POST', '/', 'json', false, 'json', request);
}

model GetWafQuotaRequest {
  paths?: string(name='Paths', description='The type of WAF resources. Valid values:

*   managed_rules_group: the managed rule group.
*   list: the custom list.
*   page: the custom error page.
*   scene_policy: the scenario-specific policy.', example='page', position='Query'),
}

model GetWafQuotaResponseBody = {
  quota?: {
    list?: {
      enable?: boolean(name='Enable', description='Indicates whether custom lists are enabled.'),
      items?: map[string]QuotaListItemsValue(name='Items', description='The quota information about all item types in the custom lists.'),
      numberItemsPerList?: WafQuotaInteger(name='NumberItemsPerList', description='The maximum number of items in each custom list.'),
      numberItemsTotal?: WafQuotaInteger(name='NumberItemsTotal', description='The maximum number of items in all custom lists.'),
      numberTotal?: WafQuotaInteger(name='NumberTotal', description='The maximum number of custom lists.'),
    }(name='List', description='The quota information about custom lists.'),
    managedRulesGroup?: {
      enable?: boolean(name='Enable', description='Indicates whether the WAF managed rule group is enabled.'),
      numberTotal?: WafQuotaInteger(name='NumberTotal', description='The maximum number of WAF managed rule groups.'),
    }(name='ManagedRulesGroup', description='The quota information about WAF managed rule groups.'),
    page?: {
      contentTypes?: map[string]QuotaPageContentTypesValue(name='ContentTypes', description='The quota information about custom error pages of all Content-Types.'),
      enable?: boolean(name='Enable', description='Indicates whether custom error pages are enabled.'),
      numberTotal?: WafQuotaInteger(name='NumberTotal', description='The maximum number of custom error pages.'),
    }(name='Page', description='The quota information about custom error pages.'),
    scenePolicy?: {
      enable?: boolean(name='Enable', description='Indicates whether scenario-specific policies are enabled.'),
      numberTotal?: WafQuotaInteger(name='NumberTotal', description='The maximum number of scenario-specific policies.'),
    }(name='ScenePolicy', description='The quota information about scenario-specific policies.'),
  }(name='Quota', description='The quota information returned.'),
  requestId?: string(name='RequestId', description='The request ID.', example='36af3fcc-43d0-441c-86b1-428951dc8225'),
}

model GetWafQuotaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetWafQuotaResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetWafQuota  GetWafQuotaRequest
  * @return GetWafQuotaResponse
 */
async function getWafQuota(request: GetWafQuotaRequest): GetWafQuotaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetWafQuota', 'POST', '/', 'json', false, 'json', request);
}

model GetWafRuleRequest {
  id: long(name='Id', description='The ID of the WAF rule, which can be obtained by calling the [ListWafRules](https://help.aliyun.com/document_detail/2850237.html) operation.

This parameter is required.', example='20000001', position='Query'),
  siteId: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.

This parameter is required.', example='1', position='Query'),
}

model GetWafRuleResponseBody = {
  config?: WafRuleConfig(name='Config', description='The configuration of the rule.'),
  id?: long(name='Id', description='The ID of the WAF rule.[](~~2850237~~)', example='2000001'),
  name: string(name='Name', description='The rule name.

This parameter is required.', example='example', maxLength=128),
  phase: string(name='Phase', description='The WAF rule category.

This parameter is required.', example='http_custom'),
  position?: long(name='Position', description='The order of the rule in the ruleset.', example='1'),
  requestId?: string(name='RequestId', description='The request ID.', example='36af3fcc-43d0-441c-86b1-428951dc8225'),
  status?: string(name='Status', description='Indicates whether the rule is enabled.', example='on'),
  updateTime?: string(name='UpdateTime', description='The time when the rule was last modified.', example='2024-01-01T00:00:00Z'),
}

model GetWafRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetWafRuleResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetWafRule  GetWafRuleRequest
  * @return GetWafRuleResponse
 */
async function getWafRule(request: GetWafRuleRequest): GetWafRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetWafRule', 'POST', '/', 'json', false, 'json', request);
}

model GetWafRulesetRequest {
  id?: long(name='Id', description='The ID of the WAF ruleset, which can be obtained by calling the [ListWafRulesets](https://help.aliyun.com/document_detail/2850233.html) operation.', example='10000001', position='Query'),
  phase?: string(name='Phase', description='The WAF rule category of rulesets to query.', example='http_bot', position='Query'),
  siteId?: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.', example='1', position='Query'),
}

model GetWafRulesetResponseBody = {
  id?: long(name='Id', description='The ruleset ID.', example='10000001'),
  name: string(name='Name', description='The ruleset name.

This parameter is required.', example='example', maxLength=128),
  phase: string(name='Phase', description='The WAF rule category of the ruleset.

This parameter is required.', example='http_bot'),
  requestId?: string(name='RequestId', description='The request ID.', example='36af3fcc-43d0-441c-86b1-428951dc8225'),
  rules?: [
    WafRuleConfig
  ](name='Rules', description='The rule configurations in the ruleset.'),
  shared?: WafBatchRuleShared(name='Shared', description='The configurations shared by the rules in the ruleset.'),
  status?: string(name='Status', description='The ruleset status.', example='on'),
  updateTime?: string(name='UpdateTime', description='The time when the ruleset was last modified.', example='2024-01-01T00:00:00Z'),
}

model GetWafRulesetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetWafRulesetResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetWafRuleset  GetWafRulesetRequest
  * @return GetWafRulesetResponse
 */
async function getWafRuleset(request: GetWafRulesetRequest): GetWafRulesetResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetWafRuleset', 'POST', '/', 'json', false, 'json', request);
}

model ListCacheReserveInstancesRequest {
  instanceId?: string(name='InstanceId', description='The ID of the cache reserve instance.', example='sp-xcdn-96wblslz****', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values: **1 to 500**. Default value: **500**.', example='20', position='Query'),
  sortBy?: string(name='SortBy', description='The criterion by which you want to sort the queried instances. Valid values:

*   ExpireTime: sorts the instances by the time when the instances expire.
*   CreateTime: sorts the instances by the time when the instances were purchased.', example='ExpireTime', position='Query'),
  sortOrder?: string(name='SortOrder', description='The order by which you want to sort the queried instances. Valid values:

*   asc: in ascending order.
*   desc: in descending order.', example='desc', position='Query'),
  status?: string(name='Status', description='The status of the cache reserve instance. Valid values:

*   online: The instance is in service.
*   offline: The instance has expired within an allowable period. In this state, the plan is unavailable.
*   disable: The instance is released.
*   overdue: The instance is stopped due to overdue payments.', example='ListCacheReserveInstances', position='Query'),
}

model ListCacheReserveInstancesResponseBody = {
  instanceInfo?: [ 
    {
      cacheReserveCapacity?: string(name='CacheReserveCapacity', description='The capacity of the cache reserve instance. Unit: GB.', example='512000'),
      cacheReserveRegion?: string(name='CacheReserveRegion', description='The region in which the cache reserve instance resides.', example='HK'),
      createTime?: string(name='CreateTime', description='The time when the cache reserve instance was purchased.', example='2024-04-12T05:41:51Z'),
      duration?: int32(name='Duration', description='The subscription period of the cache reserve instance. Unit: months.', example='3'),
      expireTime?: string(name='ExpireTime', description='The time when the cache reserve instance expires.', example='2024-10-05T16:00:00Z'),
      instanceId?: string(name='InstanceId', description='The ID of the cache reserve instance.', example='sp-xcdn-96wblslz****'),
      status?: string(name='Status', description='The status of the cache reserve instance. Valid values:

*   online: The instance is in service.
*   offline: The instance has expired within an allowable period. In this state, the plan is unavailable.
*   disable: The instance is released.
*   overdue: The service was stopped due to overdue payments.', example='online'),
    }
  ](name='InstanceInfo', description='The cache reserve instances.'),
  pageNumber?: int32(name='PageNumber', description='The page number. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: **500**. Valid values: **1 to 500**.', example='500'),
  requestId?: string(name='RequestId', description='The request ID.', example='65C66B7B-671A-8297-9187-2R5477247B76'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='16'),
  totalPage?: int32(name='TotalPage', description='The total number of pages returned.', example='1'),
}

model ListCacheReserveInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListCacheReserveInstancesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListCacheReserveInstances  ListCacheReserveInstancesRequest
  * @return ListCacheReserveInstancesResponse
 */
async function listCacheReserveInstances(request: ListCacheReserveInstancesRequest): ListCacheReserveInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListCacheReserveInstances', 'GET', '/', 'json', false, 'json', request);
}

model ListCiphersRequest {
  ciphersGroup: string(name='CiphersGroup', description='This parameter is required.', example='strict', position='Query'),
}

model ListCiphersResponseBody = {
  ciphersGroup?: string(name='CiphersGroup', example='all'),
  requestId?: string(name='RequestId', example='0AEDAF20-4DDF-4165-8750-47FF9C1929C9'),
  result?: [ string ](name='Result'),
  totalCount?: long(name='TotalCount', example='16'),
}

model ListCiphersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListCiphersResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListCiphers  ListCiphersRequest
  * @return ListCiphersResponse
 */
async function listCiphers(request: ListCiphersRequest): ListCiphersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListCiphers', 'GET', '/', 'json', false, 'json', request);
}

model ListClientCaCertificatesRequest {
  pageNumber?: long(name='PageNumber', example='1', position='Query'),
  pageSize?: long(name='PageSize', example='20', position='Query'),
  siteId: long(name='SiteId', description='This parameter is required.', example='1234567890123', position='Query'),
}

model ListClientCaCertificatesResponseBody = {
  pageNumber?: long(name='PageNumber', example='1'),
  pageSize?: long(name='PageSize', example='20'),
  requestId?: string(name='RequestId', example='F61CDR30-E83C-4FDA-BF73-9A94CDD44229'),
  result?: [ 
    {
      commonName?: string(name='CommonName', example='www.example.com'),
      createTime?: string(name='CreateTime', example='2024-06-24 07:48:51'),
      id?: string(name='Id', example='babab9db65ee5efcca9f3d41d4b5****'),
      issuer?: string(name='Issuer', example='GlobalSign nv-sa'),
      name?: string(name='Name', example='yourCertName'),
      notAfter?: string(name='NotAfter', example='2024-03-31 02:08:00'),
      notBefore?: string(name='NotBefore', example='2023-03-31 02:08:00'),
      pubkeyAlgorithm?: string(name='PubkeyAlgorithm', example='RSA'),
      SAN?: string(name='SAN', example='www.example.com,*.example.com'),
      signatureAlgorithm?: string(name='SignatureAlgorithm', example='SHA256-RSA'),
      status?: string(name='Status', example='OK'),
      type?: string(name='Type', example='upload'),
      updateTime?: string(name='UpdateTime', example='2024-07-20 06:18:42'),
    }
  ](name='Result'),
  siteId?: long(name='SiteId', example='1234567890123'),
  siteName?: string(name='SiteName', example='example.com'),
  totalCount?: long(name='TotalCount', example='16'),
}

model ListClientCaCertificatesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListClientCaCertificatesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListClientCaCertificates  ListClientCaCertificatesRequest
  * @return ListClientCaCertificatesResponse
 */
async function listClientCaCertificates(request: ListClientCaCertificatesRequest): ListClientCaCertificatesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListClientCaCertificates', 'GET', '/', 'json', false, 'json', request);
}

model ListClientCertificatesRequest {
  pageNumber?: long(name='PageNumber', description='The page number.', example='1', position='Query'),
  pageSize?: long(name='PageSize', description='The number of entries per page.', example='20', position='Query'),
  siteId: long(name='SiteId', description='The website ID.

This parameter is required.', example='1234567890123', position='Query'),
}

model ListClientCertificatesResponseBody = {
  pageNumber?: long(name='PageNumber', description='The page number returned.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries per page.', example='20'),
  requestId?: string(name='RequestId', description='The request ID.', example='15C66C7B-671A-4297-9187-2C4477247A74'),
  result?: [ 
    {
      CACertificateId?: string(name='CACertificateId', description='The ID of the CA certificate.', example='baba39055622c008b90285a8838ed09a'),
      commonName?: string(name='CommonName', description='The Common Name of the certificate.', example='www.example.com'),
      createTime?: string(name='CreateTime', description='The time when the certificate was created.', example='2024-06-24 07:48:51'),
      id?: string(name='Id', description='The certificate ID.', example='babab9db65ee5efcca9f3d41d4b50d66'),
      issuer?: string(name='Issuer', description='The certificate authority (CA) that issued the certificate.', example='GlobalSign nv-sa'),
      name?: string(name='Name', description='The certificate name.', example='yourCertName'),
      notAfter?: string(name='NotAfter', description='The time when the certificate expires.', example='2024-03-31 02:08:00'),
      notBefore?: string(name='NotBefore', description='The time when the certificate takes effect.', example='2023-03-31 02:08:00'),
      pubkeyAlgorithm?: string(name='PubkeyAlgorithm', description='The public key algorithm of the certificate.', example='RSA'),
      SAN?: string(name='SAN', description='The Subject Alternative Name (SAN) of the certificate.', example='www.example.com,*.example.com'),
      signatureAlgorithm?: string(name='SignatureAlgorithm', description='The signature algorithm of the certificate.', example='SHA256-RSA'),
      status?: string(name='Status', description='The certificate status.', example='active'),
      type?: string(name='Type', description='The certificate type.', example='dcdn'),
      updateTime?: string(name='UpdateTime', description='The time when the certificate was updated.', example='2024-07-20 06:18:42'),
    }
  ](name='Result', description='The client certificates.'),
  siteId?: long(name='SiteId', description='The website ID.', example='1234567890123'),
  siteName?: string(name='SiteName', description='The website name.', example='example.com'),
  totalCount?: long(name='TotalCount', description='The total number of entries.', example='5'),
}

model ListClientCertificatesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListClientCertificatesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListClientCertificates  ListClientCertificatesRequest
  * @return ListClientCertificatesResponse
 */
async function listClientCertificates(request: ListClientCertificatesRequest): ListClientCertificatesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListClientCertificates', 'GET', '/', 'json', false, 'json', request);
}

model ListEdgeContainerAppRecordsRequest {
  appId: string(name='AppId', description='The application ID, which can be obtained by calling the [ListEdgeContainerApps](~~ListEdgeContainerApps~~) operation.

This parameter is required.', example='app-88068867578379****', minLength=20, maxLength=64, position='Query'),
  orderKey?: string(name='OrderKey', description='The sorting field. Valid values:

*   CreateTime: the time when the domain name was associated.
*   CreateTime: the time when the domain name was last modified.', example='CreateTime', position='Query'),
  orderType?: string(name='OrderType', description='The order in which you want to sort the query results. Valid values:

*   ASC: in ascending order.
*   DESC: in descending order.', example='DESC', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number. Valid values: **1** to **100000**. Default value: 1.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 20. Valid values: 1 to 500.', example='10', position='Query'),
  searchKey?: string(name='SearchKey', description='The keyword that is used for the search.', example='ver-1006157458290860032', position='Query'),
}

model ListEdgeContainerAppRecordsResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
  records?: [ 
    {
      appId?: string(name='AppId', description='The application ID.', example='app-88068867578379****'),
      cname?: string(name='Cname', description='The CNAME of the associated domain name.', example='kdxceo****.yun****.com'),
      configId?: long(name='ConfigId', description='The configuration ID of the associated domain name.', example='27522948436****'),
      createTime?: string(name='CreateTime', description='The time when the domain name was added. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.', example='2023-12-24T02:01:11Z'),
      recordId?: long(name='RecordId', description='The record ID of the associated domain name.', example='266****'),
      recordName?: string(name='RecordName', description='The associated domain name.', example='a.example.com'),
      schemdId?: int32(name='SchemdId', description='The scheduling domain ID of the associated domain name.', example='123456'),
      siteId?: long(name='SiteId', description='The website ID.', example='5407498413****'),
      updateTime?: string(name='UpdateTime', description='The time when the scheduling domain ID or CNAME was last modified. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.', example='2021-12-22T08:32:02Z'),
    }
  ](name='Records', description='The details about the associated domain names.'),
  requestId?: string(name='RequestId', description='The request ID.', example='CB1A380B-09F0-41BB-A198-72F8FD6DA2FE'),
  totalCount?: int32(name='TotalCount', description='The number of domain names that are associated with the specified application.', example='2'),
}

model ListEdgeContainerAppRecordsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListEdgeContainerAppRecordsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListEdgeContainerAppRecords  ListEdgeContainerAppRecordsRequest
  * @return ListEdgeContainerAppRecordsResponse
 */
async function listEdgeContainerAppRecords(request: ListEdgeContainerAppRecordsRequest): ListEdgeContainerAppRecordsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListEdgeContainerAppRecords', 'GET', '/', 'json', false, 'json', request);
}

model ListEdgeContainerAppVersionsRequest {
  appId: string(name='AppId', description='The application ID, which can be obtained by calling the [ListEdgeContainerApps](~~ListEdgeContainerApps~~) operation.

This parameter is required.', example='app-88068867578379****', minLength=20, maxLength=64, position='Query'),
  orderKey?: string(name='OrderKey', description='The sorting field. Valid values:

*   Name: the version name.
*   CreateTime: the time when the version was created.
*   UpdateTime: the time when the version was last modified.', example='Name', position='Query'),
  orderType?: string(name='OrderType', description='The order in which you want to sort the query results. Valid values:

*   ASC: in ascending order.
*   DESC: in descending order.', example='DESC', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number. Valid values: 1 to 65535.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values: 1 to 100.', example='10', position='Query'),
  searchKey?: string(name='SearchKey', description='The keyword used for the search.', example='ver-100568263967926****', position='Query'),
  searchType?: string(name='SearchType', description='The parameter used for fuzzy search. Valid values: VersionId and Name.', example='VersionId', position='Query'),
}

model ListEdgeContainerAppVersionsResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
  requestId?: string(name='RequestId', description='The request ID.', example='F61CDR30-E83C-4FDA-BF73-9A94CDD44229'),
  totalCount?: int32(name='TotalCount', description='The total number of entries.', example='20'),
  versions?: [ 
    {
      appId?: string(name='AppId', description='The application ID.', example='app-88068867578379****'),
      containers?: [ 
        {
          args?: string(name='Args', description='The arguments that are passed to the container startup command.', example='-c a=1'),
          command?: string(name='Command', description='The command that is used to start the container.', example='openresty -g \\"daemon off;\\"'),
          envVariables?: string(name='EnvVariables', description='The environment variables of the container.', example='ENV=prod'),
          image?: string(name='Image', description='The address of the container image.', example='nginx'),
          name?: string(name='Name', description='The container name.', example='container1'),
          postStart?: string(name='PostStart', description='The command that is run before the container is started. Format: `{"exec":{"command":["cat","/etc/group"\\]}}`.

If you want to cancel this configuration, set the parameter value to `""` or `{}`. If you do not specify this parameter, this configuration is ignored.', example='{\\"exec\\":{\\"command\\":[\\"bash\\",\\"-c\\",\\"cd /home/admin/'),
          preStop?: string(name='PreStop', description='The command that is run before the container is stopped.', example='sh stop.sh'),
          probeContent?: {
            command?: string(name='Command', description='The probe command.', example='openresty -g  "daemon off;'),
            failureThreshold?: int32(name='FailureThreshold', description='The number of consecutive failed health checks required for a container to be considered as unhealthy.', example='3'),
            host?: string(name='Host', description='The domain name that is used for health checks.', example='test.com'),
            httpHeaders?: string(name='HttpHeaders', description='The request headers that are included in the container health check request.', example='{\\"Content-Type\\":\\"application/json\\"}'),
            initialDelaySeconds?: int32(name='InitialDelaySeconds', description='The latency for container probe initialization.', example='10'),
            path?: string(name='Path', description='The path of the container health check.', example='/health_check'),
            periodSeconds?: int32(name='PeriodSeconds', description='The interval between container health checks.', example='5'),
            port?: int32(name='Port', description='The port of the container health check.', example='80'),
            scheme?: string(name='Scheme', description='The protocol that the container health check request uses.', example='http'),
            successThreshold?: int32(name='SuccessThreshold', description='The number of consecutive successful health checks required for a container to be considered as healthy.', example='1'),
            timeoutSeconds?: int32(name='TimeoutSeconds', description='The timeout period of the container health check.', example='30'),
          }(name='ProbeContent', description='The container probe content.'),
          probeType?: string(name='ProbeType', description='The probe type of the container.', example='httpGet'),
          spec?: string(name='Spec', description='The compute specification of the container.', example='1C2G'),
        }
      ](name='Containers', description='The containers in the version.'),
      createTime?: string(name='CreateTime', description='The time when the version was created. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.', example='2022-11-10T02:53:16Z'),
      lastPublishTime?: string(name='LastPublishTime', description='The time when the version was last released. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.', example='2023-02-10T02:48:36Z'),
      name?: string(name='Name', description='The version name.', example='version01'),
      publishTime?: string(name='PublishTime', description='The time when the version was released. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.', example='2023-02-10T02:48:36Z'),
      remarks?: string(name='Remarks', description='The remarks.', example='test version'),
      status?: string(name='Status', description='The status of the current version. Valid values:

*   **created**
*   **failed**
*   **creating**', example='created'),
      updateTime?: string(name='UpdateTime', description='The time when the version was last modified. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.', example='2023-04-16 10:51:00'),
      versionId?: string(name='VersionId', description='The version ID.', example='ver-87962637161651****'),
    }
  ](name='Versions', description='The versions.'),
}

model ListEdgeContainerAppVersionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListEdgeContainerAppVersionsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListEdgeContainerAppVersions  ListEdgeContainerAppVersionsRequest
  * @return ListEdgeContainerAppVersionsResponse
 */
async function listEdgeContainerAppVersions(request: ListEdgeContainerAppVersionsRequest): ListEdgeContainerAppVersionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListEdgeContainerAppVersions', 'GET', '/', 'json', false, 'json', request);
}

model ListEdgeContainerAppsRequest {
  orderKey?: string(name='OrderKey', description='The sorting field. This parameter is left empty by default. Valid values:

*   Name: the version name.
*   CreateTime: the time when the version was created.
*   UpdateTime: the time when the version was last modified.', example='CreateTime', position='Query'),
  orderType?: string(name='OrderType', description='The order in which you want to sort the query results. This parameter is left empty by default. Valid values:

*   ASC: in ascending order.
*   DESC: in descending order.', example='Asc', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number. Default value: **1**. Valid values: 1 to 65535.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: **20**. Valid values: 1 to 500.', example='20', position='Query'),
  searchKey?: string(name='SearchKey', description='The search keyword.', example='ver-1005682639679266816', position='Query'),
  searchType?: string(name='SearchType', description='The search criterion based on which you want to perform fuzzy search. Valid values:

*   Appid: the application ID.
*   Name: the application name.', example='Appid', position='Query'),
}

model ListEdgeContainerAppsResponseBody = {
  apps?: [ 
    {
      appId?: string(name='AppId', description='The application ID.', example='app-88068867578379****'),
      createTime?: string(name='CreateTime', description='The time when the version was created.', example='2022-12-01T16:16:27.418298794+08:00'),
      domainName?: string(name='DomainName', description='The domain name associated with the application.', example='test.com'),
      gatewayType?: string(name='GatewayType', description='The type of the gateway. Valid values:

*   l7: Layer 7 gateway.
*   l4: Layer 4 gateway.', example='l7'),
      healthCheck?: {
        failTimes?: int32(name='FailTimes', description='The number of consecutive failed health checks for an application to be considered unhealthy.', example='5'),
        host?: string(name='Host', description='The domain name that is used for health checks.', example='test.com'),
        httpCode?: string(name='HttpCode', description='The range of health check status codes that indicate successful health checks.', example='http_2XX'),
        interval?: int32(name='Interval', description='The interval between health checks. Unit: seconds.', example='5'),
        method?: string(name='Method', description='The HTTP method used for health checks.', example='GET'),
        port?: int32(name='Port', description='The health check port.', example='8080'),
        succTimes?: int32(name='SuccTimes', description='The number of consecutive successful health checks for an application to be considered healthy.', example='1'),
        timeout?: int32(name='Timeout', description='The timeout period of health checks. Unit: seconds.', example='60'),
        type?: string(name='Type', description='The type of health checks. Valid values:

*   l7
*   l4', example='l7'),
        uri?: string(name='Uri', description='The health check URL.', example='/health_check'),
      }(name='HealthCheck', description='The information about health checks.'),
      name?: string(name='Name', description='The application name.', example='app-test'),
      percentage?: int32(name='Percentage', description='The progress of the application creation task in percentage.', example='100'),
      quicCid?: string(name='QuicCid', description='Indicates whether QUIC is enabled.', example='false'),
      remarks?: string(name='Remarks', description='The remarks.', example='test app'),
      servicePort?: int32(name='ServicePort', description='The server port. Valid values: 1 to 65535.', example='80'),
      status?: string(name='Status', description='The status of the application. Valid values:

*   creating: The application is being created.
*   failed: The application failed to be created.
*   created: The application is created.', example='created'),
      targetPort?: int32(name='TargetPort', description='The backend port, which is also the service port of the application. Valid values: 1 to 65535.', example='80'),
      updateTime?: string(name='UpdateTime', description='The time when the application was last modified. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.', example='2023-11-15T12:11:02Z'),
      versionCount?: int32(name='VersionCount', description='The number of versions of the application.', example='10'),
    }
  ](name='Apps', description='The queried applications.'),
  pageNumber?: int32(name='PageNumber', description='The page number. Default value: **1**. Valid values: 1 to 65535.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values: 1 to 500.', example='10'),
  requestId?: string(name='RequestId', description='The request ID.', example='2430E05E-1340-5773-B5E1-B743929F46F2'),
  totalCount?: int32(name='TotalCount', description='The total number of entries.', example='10'),
}

model ListEdgeContainerAppsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListEdgeContainerAppsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListEdgeContainerApps  ListEdgeContainerAppsRequest
  * @return ListEdgeContainerAppsResponse
 */
async function listEdgeContainerApps(request: ListEdgeContainerAppsRequest): ListEdgeContainerAppsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListEdgeContainerApps', 'POST', '/', 'json', false, 'json', request);
}

model ListEdgeContainerRecordsRequest {
  pageNumber?: int32(name='PageNumber', description='The page number. Default value: **1**.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: **500**.', example='20', position='Query'),
  recordMatchType?: string(name='RecordMatchType', description='The match mode to filter the record names:

*   **fuzzy**
*   **prefix**
*   **suffix**
*   **exact** (default)', example='fuzzy', position='Query'),
  recordName?: string(name='RecordName', description='The record name.', example='a.example.com', position='Query'),
  siteId: long(name='SiteId', description='The website ID. You can call the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation to obtain the ID.

This parameter is required.', example='1234567890123', position='Query'),
}

model ListEdgeContainerRecordsResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
  records?: [ 
    {
      createTime?: string(name='CreateTime', description='The time when the record was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.', example='2023-12-24T02:01:11Z'),
      recordCname?: string(name='RecordCname', description='The CNAME. If you use CNAME setup when you add your website to ESA, the value is the CNAME that you configured.', example='a.example.com.cnamezone.com'),
      recordName?: string(name='RecordName', description='The record name.', example='a.example.com'),
      siteId?: long(name='SiteId', description='The website ID.', example='1234567890123'),
      siteName?: string(name='SiteName', description='The website name.', example='example.com'),
      updateTime?: string(name='UpdateTime', description='The time when the record was updated. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.', example='2021-12-22T08:32:02Z'),
    }
  ](name='Records', description='The records.'),
  requestId?: string(name='RequestId', description='Id of the request', example='EEEBE525-F576-1196-8DAF-2D70CA3F4D2F'),
  totalCount?: int32(name='TotalCount', description='The total number of records returned.', example='50'),
}

model ListEdgeContainerRecordsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListEdgeContainerRecordsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListEdgeContainerRecords  ListEdgeContainerRecordsRequest
  * @return ListEdgeContainerRecordsResponse
 */
async function listEdgeContainerRecords(request: ListEdgeContainerRecordsRequest): ListEdgeContainerRecordsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListEdgeContainerRecords', 'GET', '/', 'json', false, 'json', request);
}

model ListEdgeRoutinePlansRequest {
}

model ListEdgeRoutinePlansResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values: 1 to 500.', example='20'),
  planInfo?: [ 
    {
      billingMode?: string(name='BillingMode', description='The billing method. Valid values:

*   PREPAY: subscription.
*   POSTPAY: pay-as-you-go.', example='POSTPAY'),
      erRoutineCodeVersionQuota?: string(name='ErRoutineCodeVersionQuota', description='The maximum number of versions that each routine supports.', example='20'),
      erRoutineQuota?: string(name='ErRoutineQuota', description='The maximum of routines that can be created.', example='100'),
      erRoutineRouteSiteCountQuota?: string(name='ErRoutineRouteSiteCountQuota', description='The maximum number of websites with which each routine can be associated.', example='100'),
      paymentMethod?: string(name='PaymentMethod', description='The payment method. Valid values:

*   er_free
*   er_pay', example='er_free'),
      planName?: string(name='PlanName', description='The plan name.', example='test_plan'),
    }
  ](name='PlanInfo', description='The plans.'),
  requestId?: string(name='RequestId', description='The request ID.', example='0AEDAF20-4DDF-4165-8750-47FF9C1929C9'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='12'),
  totalPage?: int32(name='TotalPage', description='The total number of pages returned.', example='1'),
}

model ListEdgeRoutinePlansResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListEdgeRoutinePlansResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListEdgeRoutinePlans  ListEdgeRoutinePlansRequest
  * @return ListEdgeRoutinePlansResponse
 */
async function listEdgeRoutinePlans(request: ListEdgeRoutinePlansRequest): ListEdgeRoutinePlansResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListEdgeRoutinePlans', 'GET', '/', 'json', false, 'json', request);
}

model ListEdgeRoutineRecordsRequest {
  pageNumber?: int32(name='PageNumber', description='The page number. Default value: **1**.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: **500**.', example='20', position='Query'),
  recordMatchType?: string(name='RecordMatchType', description='The match mode to filter the record names.

*   **fuzzy**: fuzzy match.
*   **prefix**: match by prefix.
*   **suffix**: match by suffix.
*   **exact** (default): exact match .', example='fuzzy', position='Query'),
  recordName?: string(name='RecordName', description='The record name.', example='a.example.com', position='Query'),
  siteId: long(name='SiteId', description='The website ID. You can call the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation to obtain the ID.

This parameter is required.', example='123456****', position='Query'),
}

model ListEdgeRoutineRecordsResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The total number of pages returned.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
  records?: [ 
    {
      createTime?: string(name='CreateTime', description='The time when the record was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.', example='2023-12-24T02:01:11Z'),
      recordCname?: string(name='RecordCname', description='The CNAME. If you use CNAME setup when you add your website to ESA, the value is the CNAME that you configured then.', example='a.example.com.cnamezone.com'),
      recordName?: string(name='RecordName', description='The record name.', example='a.example.com'),
      siteId?: long(name='SiteId', description='The website ID.', example='5407498413****'),
      siteName?: string(name='SiteName', description='The website name.', example='example.com'),
      updateTime?: string(name='UpdateTime', description='The time when the record was updated. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.', example='2023-12-22T08:32:02Z'),
    }
  ](name='Records', description='The list of records.'),
  requestId?: string(name='RequestId', description='The request ID.', example='EEEBE525-F576-1196-8DAF-2D70CA3F4D2F'),
  totalCount?: int32(name='TotalCount', description='The total number of records returned.', example='121'),
}

model ListEdgeRoutineRecordsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListEdgeRoutineRecordsResponseBody(name='body'),
}

/**
  * @description >  You can call this operation 100 times per second.
  * @param request  the request parameters of ListEdgeRoutineRecords  ListEdgeRoutineRecordsRequest
  * @return ListEdgeRoutineRecordsResponse
 */
async function listEdgeRoutineRecords(request: ListEdgeRoutineRecordsRequest): ListEdgeRoutineRecordsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListEdgeRoutineRecords', 'GET', '/', 'json', false, 'json', request);
}

model ListInstanceQuotasRequest {
  instanceId?: string(name='InstanceId', description='The plan ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.', example='sp-xcdn-96wblslz****', position='Query'),
  quotaNames: string(name='QuotaNames', description='The quota names in the plan. Separate multiple names with commas (,). Valid values:

*   **waf:phase:http_anti_scan:actions**: the actions in WAF scan protection rules.
*   **waf:phase:http_bot:actions**: all actions in WAF bot management rules.
*   **waf:phase:http_bot:http_custom_cc_dev:characteristic:fields**: the statistical objects for the custom device-based throttling in WAF bot management rules.
*   **waf:phase:http_bot:http_custom_cc_ip:characteristic:fields**: the statistical objects for the custom IP address-based throttling in WAF bot management rules.
*   ****waf:phase:http_bot:match:symbols****: the match operators in WAF bot management rules.
*   **waf:phase:http_bot:http_custom_cc:characteristic:fields**: the statistical objects for the custom session-based throttling in WAF bot management rules.
*   **waf:phase:http_bot:match:fields**: the match fields in WAF bot management rules.
*   **waf:phase:http_whitelist:match:symbols**: the match operators in WAF whitelist rules.
*   **waf:phase:http_whitelist:match:fields**: the match fields in WAF whitelist rules.
*   **waf:phase:http_anti_scan:http_directory_traversal:characteristic:fields**: the statistical objects for directory traversal blocking in WAF scan protection rules.
*   **waf:phase:http_anti_scan:http_high_frequency:characteristic:fields**: the statistical objects for high-frequency scanning blocking in WAF scan protection rules.
*   **waf:phase:http_anti_scan:match:symbols**: the match operators in WAF scan protection rules.
*   **waf:phase:http_anti_scan:match:fields**: the match fields in WAF scan protection rules.
*   **waf:phase:http_managed:actions**: the actions in WAF managed rules.
*   **waf:phase:http_managed:group:reference:ids**: the referenced rule groups in WAF managed rules.
*   **waf:phase:http_ratelimit:actions**: the actions in WAF rate limiting rules.
*   **waf:phase:http_ratelimit:ttls**: the action durations in WAF rate limiting rules.
*   **waf:phase:http_ratelimit:intervals**: the statistical durations in WAF rate limiting rules.
*   **waf:phase:http_ratelimit:http_ratelimit:characteristic:fields**: the match characteristics in WAF rate limiting rules.
*   **waf:phase:http_ratelimit:match:symbols**: the match operators in WAF rate limiting rules.
*   **waf:phase:http_ratelimit:match:fields**: the match fields in WAF rate limiting rules.
*   **waf:phase:http_custom:actions**: the actions in custom WAF rules.
*   **waf:phase:http_custom:match:symbols**: the match operators in custom WAF rules.
*   **waf:phase:http_custom:match:fields**: the match fields in custom WAF rules.
*   **waiting_room|queuing_method**: the queuing method in Waiting Room.
*   **origin_rules|origin_scheme**: the origin protocol in origin rules.
*   **origin_rules|origin_sni**: the origin Server Name Indication (SNI) in origin rules.
*   **origin_rules|origin_host**: the origin host in origin rules.
*   **fourlayeracceleration**: TCP/UDP proxy.
*   **rtlog_service**: the availability to collect real-time logs.
*   **dashboard_traffic**: the value-added capability of traffic analytics.
*   **custom_name_server**: the availability to configure custom nameservers.
*   **waf:phase:http_bot:enable**: the availability to enable WAF bot management.
*   **waf:phase:http_whitelist:enable**: the availability to configure WAF whitelist rules.
*   **instantlog**: the availability to collect instant logs.
*   **waf:phase:http_anti_scan:enable**: the availability to enable WAF scan protection.
*   **waf:phase:http_managed:group:reference:enable**: the availability to configure reference rule groups in WAF managed rules.
*   **waf:phase:http_managed:enable**: the availability to configure WAF managed rules.
*   **waf:phase:http_ratelimit:on_hit:enable**: the availability to configure whether to apply rate limiting to all requests that hit the cache.
*   **ddos**: DDoS mitigation.
*   **waf:phase:http_ratelimit:enable**: the availability to configure WAF rate limiting.
*   **waf:phase:http_custom:enable**: the availability to configure custom WAF rules.
*   **waf:phase:all:page:reference:enable**: the availability to configure custom error pages.
*   **rules_support_regex**: the support for regular expressions in rules engine.
*   **waiting_room_event**: scheduled events in Waiting Room.
*   **waiting_room_rule**: the availability to allow requests to bypass the waiting room.
*   **waiting_room|json_response**: the availability to enable JSON response in Waiting Room.
*   **waiting_room|disable_session_renewal**: the availability to disable session renewal in Waiting Room.
*   **origin_rules|dns_record**: DNS records in origin rules.
*   **managed_transforms|add_client_geolocation_headers**: the availability to configure whether to add geolocation headers in transform rules.
*   **tiered_cache|regional_enable**: regional tiered cache.
*   **real_client_ip_header**: the availability to configure whether to add the real IP address of a client to the request header.
*   **data_timerange**: minute-level time range for data query.
*   **cache_rules|edge_cache_ttl**: POP cache TTL.
*   **cache_rules|browser_cache_ttl**: browser cache TTL.
*   **fourLayerRecordCount**: the maximum number of records of websites for which TCP/UDP acceleration is enabled.
*   **waitingroomRuleCount**: the maximum number of rules per waiting room.
*   **waitingroomEventCount**: the maximum number of events per waiting room.
*   **waitingroom_custom_pathhost**: the availability to configure the hostname and path in Waiting Room.
*   **er_routers**: Edge Routine routes.
*   **cache_rules|rule_quota**: the maximum number of cache rules.
*   **configuration_rules|rule_quota**: the maximum number of configuration rules.
*   **redirect_rules|rule_quota**: the redirect rules.
*   **compression_rules|rule_quota**: the maximum number of compression rules.
*   **origin_rules|rule_quota**: the maximum number of origin rules.
*   **waf:phase:http_bot:rulesets_per_instance:less_than_or_equal**: the maximum number of rulesets in WAF bot management per plan.
*   **waf:phase:http_whitelist:rules_per_instance:less_than_or_equal**: the maximum number of WAF whitelist rules per plan.
*   **rtlog_quota**: the maximum number of real-time log delivery tasks.
*   **waf:phase:http_anti_scan:rulesets_per_instance:less_than_or_equal**: the maximum number of rulesets in WAF scan protection per plan.
*   **ddos_instance**: the number of Anti-DDoS Proxy instances.
*   **waf:phase:http_ratelimit:rules_per_instance:less_than_or_equal**: the maximum number of WAF rate limiting rules.
*   **waf:phase:http_custom:rules_per_instance:less_than_or_equal**: the maximum number of custom WAF rules per plan.
*   **ruleNestedConditionalCount**: the number of nested layers in a rule.
*   **waiting_room_rule**: Waiting Room.
*   **transition_rule**: the maximum number of transform rules.
*   **customHttpCert**: the maximum number of custom certificates.
*   **free_cert**: the maximum number of free certificates.
*   **preload**: prefetch.
*   **refresh_cache_tag**: purge by cache tag.
*   **refresh_ignore_param**: purge by URL with specified parameters ignored.
*   **refresh_directory**: purge by directory.
*   **refresh_hostname**: purge by hostname.
*   **refresh_all**: purge all cache.
*   **refresh_file**: purge by URL.
*   **wildcard**: the maximum number of wildcard domains.
*   **recordCount**: the maximum number of Layer 7 records.
*   **siteCount**: the maximum number of websites that can be associated with the plan.
*   **https|rule_quota**: the maximum number of SSL/TLS rules.

This parameter is required.', example='preload, free_cert', position='Query'),
  siteId?: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.', example='2882900****', position='Query'),
}

model ListInstanceQuotasResponseBody = {
  instanceId?: string(name='InstanceId', description='The plan ID.', example='sp-xcdn-96wblslz****'),
  quotas?: [ 
    {
      quotaName?: string(name='QuotaName', description='The quota name.', example='customHttpCert'),
      quotaValue?: string(name='QuotaValue', description='The quota value.', example='10'),
      quotaValueType?: string(name='QuotaValueType', description='The threshold type of the quota. Valid values:

*   value: enumerates the values of the quota.
*   bool: specifies whether the quota is available.
*   num: the upper limit of the quota.
*   range: the value range for the quota.
*   custom: other types than the preceding four quota threshold types.', example='bool'),
    }
  ](name='Quotas', description='The quotas in the plan.'),
  requestId?: string(name='RequestId', description='The request ID.', example='15C66C7B-671A-4297-9187-2C4477247B78'),
  status?: string(name='Status', description='The plan status. Valid values:

*   online: The plan is in service.
*   offline: The plan has expired within an allowable period. In this state, the plan is unavailable.
*   disable: The plan is released.', example='online'),
}

model ListInstanceQuotasResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListInstanceQuotasResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListInstanceQuotas  ListInstanceQuotasRequest
  * @return ListInstanceQuotasResponse
 */
async function listInstanceQuotas(request: ListInstanceQuotasRequest): ListInstanceQuotasResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListInstanceQuotas', 'GET', '/', 'json', false, 'json', request);
}

model ListInstanceQuotasWithUsageRequest {
  instanceId?: string(name='InstanceId', description='The plan ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.', example='sp-xcdn-96wblslz****', position='Query'),
  quotaNames: string(name='QuotaNames', description='The quota names in the plan. Separate the quota names with commas (,). You can query up to 10 quota names at a time. Valid values:

*   **customHttpCert**: the custom certificates.
*   **transition_rule**: the transform rules.
*   **waiting_room**: the waiting rooms.
*   **https|rule_quota**: the SSL/TLS rules.
*   **cache_rules|rule_quota**: the cache rules.
*   **configuration_rules|rule_quota**: the configuration rules.
*   **redirect_rules|rule_quota**: the redirect rules.
*   **compression_rules|rule_quota**: the compression rules.
*   **origin_rules|rule_quota**: the origin rules.

This parameter is required.', example='customHttpCert', position='Query'),
  siteId?: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.', example='1232223****', position='Query'),
}

model ListInstanceQuotasWithUsageResponseBody = {
  instanceId?: string(name='InstanceId', description='The plan ID.[](~~2850189~~)', example='sp-xcdn-96wblslz****'),
  quotas?: [ 
    {
      quotaName?: string(name='QuotaName', description='The quota name.', example='redirect_rules|rule_quota'),
      quotaValue?: string(name='QuotaValue', description='The quota value.', example='10'),
      siteUsage?: [ 
        {
          siteId?: long(name='SiteId', description='The website ID.', example='34818329392****'),
          siteName?: string(name='SiteName', description='The website name.', example='test.top'),
          siteUsage?: string(name='SiteUsage', description='The quota usage of the website.', example='1'),
        }
      ](name='SiteUsage', description='The usage of the quota in each website associated with the plan.'),
      usage?: string(name='Usage', description='The quota usage.', example='3'),
    }
  ](name='Quotas', description='The quotas and their actual usage in the plan.'),
  requestId?: string(name='RequestId', description='The request ID.', example='85H66C7B-671A-4297-9187-2C4477247A74'),
  status?: string(name='Status', description='The plan status. Valid values:

*   online: The plan is in service.
*   offline: The plan has expired within an allowable period. In this state, the plan is unavailable.
*   disable: The plan is released.', example='online'),
}

model ListInstanceQuotasWithUsageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListInstanceQuotasWithUsageResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListInstanceQuotasWithUsage  ListInstanceQuotasWithUsageRequest
  * @return ListInstanceQuotasWithUsageResponse
 */
async function listInstanceQuotasWithUsage(request: ListInstanceQuotasWithUsageRequest): ListInstanceQuotasWithUsageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListInstanceQuotasWithUsage', 'GET', '/', 'json', false, 'json', request);
}

model ListKvsRequest {
  namespace: string(name='Namespace', description='The name of the namespace that you specify when you call the [CreatevNamespace](https://help.aliyun.com/document_detail/2850317.html) operation.

This parameter is required.', example='test_namespace', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number. The product of PageNumber and PageSize cannot exceed 50,000.', example='10', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 50. Maximum value: 100.', example='50', minimum=1, maximum=100, position='Query'),
  prefix?: string(name='Prefix', description='The prefix to query.', example='prefix-', maxLength=1000, position='Query'),
}

model ListKvsResponseBody = {
  keys?: [ 
    {
      name?: string(name='Name', description='The key name.', example='Key1'),
      updateTime?: string(name='UpdateTime', description='The time when the key was last updated.', example='2021-12-13T07:46:03Z'),
    }
  ](name='Keys', description='The key-value pairs.'),
  pageNumber?: int32(name='PageNumber', description='The total number of pages returned.', example='100'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='50'),
  requestId?: string(name='RequestId', description='The request ID.', example='0AEDAF20-4DDF-4165-8750-47FF9C1929C9'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='1024'),
}

model ListKvsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListKvsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListKvs  ListKvsRequest
  * @return ListKvsResponse
 */
async function listKvs(request: ListKvsRequest): ListKvsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListKvs', 'GET', '/', 'json', false, 'json', request);
}

model ListListsRequest {
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20', position='Query'),
  queryArgs?: {
    desc?: boolean(name='Desc', description='Specifies whether to sort the returned data in descending order.', example='true'),
    descriptionLike?: string(name='DescriptionLike', description='The list description for fuzzy search.', example='a custom list'),
    idLike?: string(name='IdLike', description='The list ID for fuzzy search.', example='40000001'),
    itemLike?: string(name='ItemLike', description='The list content for fuzzy search.', example='10.1.1.1'),
    kind?: string(name='Kind', example='ip'),
    nameItemLike?: string(name='NameItemLike', description='The list name and content for fuzzy search.', example='10.1.1.1'),
    nameLike?: string(name='NameLike', description='The list name for fuzzy search.', example='example'),
    orderBy?: string(name='OrderBy', description='The column by which you want to sort the returned data.', example='id'),
  }(name='QueryArgs', description='The query arguments in the JSON format, which contain filter conditions.', example='ListLists', shrink='json', position='Query'),
}

model ListListsResponseBody = {
  lists?: [ 
    {
      description?: string(name='Description', description='The list description.', example='a custom list', maxLength=1024),
      id?: long(name='Id', description='The ID of the custom list.[](~~2850217~~)', example='40000001'),
      kind?: string(name='Kind', description='The list type.', example='ip'),
      length?: long(name='Length', description='The length of the list information array, which indicates how many items the list contains.', example='100'),
      name?: string(name='Name', description='The list name.', example='example'),
      updateTime?: string(name='UpdateTime', description='The time when the list was last modified.', example='2024-01-01T00:00:00Z'),
    }
  ](name='Lists', description='The array that contains list information, including list data after paging.'),
  pageNumber?: int32(name='PageNumber', description='The page number returned.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
  requestId?: string(name='RequestId', description='The request ID.', example='36af3fcc-43d0-441c-86b1-428951dc8225'),
  totalCount?: int32(name='TotalCount', description='The total number of filtered lists.', example='5'),
  usage?: long(name='Usage', description='The number of created lists.', example='10'),
}

model ListListsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListListsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListLists  ListListsRequest
  * @return ListListsResponse
 */
async function listLists(request: ListListsRequest): ListListsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListLists', 'POST', '/', 'json', false, 'json', request);
}

model ListLoadBalancerRegionsRequest {
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='1024', position='Query'),
}

model ListLoadBalancerRegionsResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='1024'),
  regions?: [ 
    {
      regionCnName?: string(name='RegionCnName', description='The Chinese name of the region.'),
      regionCode?: string(name='RegionCode', description='The code of the region.', example='SEAS'),
      regionEnName?: string(name='RegionEnName', description='The English name of the region.', example='South East Asia'),
      subRegions?: [ 
        {
          subRegionCnName?: string(name='SubRegionCnName', description='The Chinese name of the region.'),
          subRegionCode?: string(name='SubRegionCode', description='The code of the subregion.', example='ID'),
          subRegionEnName?: string(name='SubRegionEnName', description='The English name of the subregion.', example='Indonesia'),
        }
      ](name='SubRegions', description='The subregions of the region.'),
    }
  ](name='Regions', description='The regions.'),
  requestId?: string(name='RequestId', description='The request ID.', example='81A5E222-24BF-17EF-9E80-A68D9B8F363D'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='12'),
  totalPage?: int32(name='TotalPage', description='The total number of pages returned.', example='1'),
}

model ListLoadBalancerRegionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListLoadBalancerRegionsResponseBody(name='body'),
}

/**
  * @description When you call an operation to create a traffic steering policy based on the originating country or region for a load balancer, you can use the code of a region or subregion to specify traffic that is sent from the region or subregion.
  * @param request  the request parameters of ListLoadBalancerRegions  ListLoadBalancerRegionsRequest
  * @return ListLoadBalancerRegionsResponse
 */
async function listLoadBalancerRegions(request: ListLoadBalancerRegionsRequest): ListLoadBalancerRegionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListLoadBalancerRegions', 'GET', '/', 'json', false, 'json', request);
}

model ListManagedRulesGroupsRequest {
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20', position='Query'),
}

model ListManagedRulesGroupsResponseBody = {
  managedRulesGroups?: [ 
    {
      name?: string(name='Name', description='The name of the managed rule group.', example='example'),
      ruleCount?: long(name='RuleCount', description='The number of rules in the managed rule group.', example='1000'),
    }
  ](name='ManagedRulesGroups', description='The information about the managed rule groups.'),
  pageNumber?: int32(name='PageNumber', description='The page number returned.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
  requestId?: string(name='RequestId', description='The request ID.', example='36af3fcc-43d0-441c-86b1-428951dc8225'),
  totalCount?: int32(name='TotalCount', description='The total number of managed rule groups returned.', example='5'),
}

model ListManagedRulesGroupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListManagedRulesGroupsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListManagedRulesGroups  ListManagedRulesGroupsRequest
  * @return ListManagedRulesGroupsResponse
 */
async function listManagedRulesGroups(request: ListManagedRulesGroupsRequest): ListManagedRulesGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListManagedRulesGroups', 'POST', '/', 'json', false, 'json', request);
}

model ListPagesRequest {
  pageNumber?: int32(name='PageNumber', description='The page number. Valid values: **1 to 100000**. Default value: 1.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 20.', example='20', position='Query'),
}

model ListPagesResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number returned.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
  pages?: [ 
    {
      content: string(name='Content', description='The Base64-encoded content of the error page. The content type is specified by the Content-Type field.

This parameter is required.', example='PGh0bWw+aGVsbG8gcGFnZTwvaHRtbD4='),
      contentType: string(name='ContentType', description='The Content-Type field in the HTTP header.

This parameter is required.', example='text/html'),
      description?: string(name='Description', description='The description of the custom error page.', example='a custom deny page', maxLength=1024),
      id?: long(name='Id', description='The ID of the custom error page.[](~~2850223~~)', example='50000001'),
      kind?: string(name='Kind', description='The type of the custom error page.', example='custom'),
      name?: string(name='Name', description='The name of the custom error page.', example='example'),
      updateTime?: string(name='UpdateTime', description='The time when the custom error page was last modified.', example='2024-01-01T00:00:00Z'),
    }
  ](name='Pages', description='The custom error pages. Each element in the array contains error page-specific information.'),
  requestId?: string(name='RequestId', description='The request ID.', example='36af3fcc-43d0-441c-86b1-428951dc8225'),
  totalCount?: int32(name='TotalCount', description='The number of custom error pages after filtering.', example='10'),
  usage?: long(name='Usage', description='The number of custom error pages that you created.', example='10'),
}

model ListPagesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListPagesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListPages  ListPagesRequest
  * @return ListPagesResponse
 */
async function listPages(request: ListPagesRequest): ListPagesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListPages', 'POST', '/', 'json', false, 'json', request);
}

model ListRecordsRequest {
  bizName?: string(name='BizName', description='The business scenario of the record for acceleration. Valid values:

*   **image_video**: video and image.
*   **api**: API.
*   **web**: web page.', example='web', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number. Default value: **1**.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: **500**.', example='10', position='Query'),
  proxied?: boolean(name='Proxied', description='Filters by whether the record is proxied. Valid values:

*   **true**
*   **false**', example='true', position='Query'),
  recordMatchType?: string(name='RecordMatchType', description='The match mode to search for the record name. Default value: exact. Valid values:

*   **prefix**: match by prefix.
*   **suffix**: match by suffix.
*   **exact**: exact match.
*   **fuzzy**: fuzzy match.', example='fuzzy', position='Query'),
  recordName?: string(name='RecordName', description='The record name. This parameter specifies a filter condition for the query.', example='www.example.com', position='Query'),
  siteId: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.

This parameter is required.', example='1234567890123', position='Query'),
  sourceType?: string(name='SourceType', description='The origin type of the record. Only CNAME records can be filtered by using this field. Valid values:

*   **OSS**: OSS bucket.
*   **S3**: S3 bucket.
*   **LB**: load balancer.
*   **OP**: origin pool.
*   **Domain**: domain name.', example='OSS', position='Query'),
  type?: string(name='Type', description='The DNS record type.', example='CNAME', position='Query'),
}

model ListRecordsResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number returned.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
  records?: [ 
    {
      authConf?: {
        accessKey?: string(name='AccessKey', description='The access key of the account to which the origin server belongs. This value is returned when the SourceType is OSS, and AuthType is private_cross_account, or when the SourceType is S3 and AuthType is private.', example='u0Nkg5gBK***QF5wvKMM504JUHt'),
        authType?: string(name='AuthType', description='The authentication type of the origin server. Different origins support different authentication types. The type of origin refers to the SourceType parameter in this operation. If the type of origin is OSS or S3, the authentication type of the origin must be specified. Valid values:

*   **public**: public read. This value is returned when the origin is a public OSS or S3 bucket.
*   **private**: private read. This value is returned when the origin is a private S3 bucket.
*   **private_same_account**: private read under the same account. This value is returned when the origin is a private OSS bucket in your Alibaba Cloud account.
*   **private_cross_account**: private read across accounts. This value is returned when the origin is a private OSS bucket in a different Alibaba Cloud account.', example='private'),
        region?: string(name='Region', description='The region of the origin. This parameter is returned if the origin type is S3. You can get the region information from the official website of Amazon S3.', example='us-east-1'),
        secretKey?: string(name='SecretKey', description='The secret access key of the account to which the origin server belongs. This value is returned when the SourceType is OSS, and AuthType is private_same_account, or when the SourceType is S3 and AuthType is private.', example='VIxuvJSA2S03f***kp208dy5w7'),
        version?: string(name='Version', description='The version of the signature algorithm. This value is returned when the origin type is S3 and AuthType is private. Valid values:

*   **v2**
*   **v4**

If this parameter is left empty, the default value v4 is used.', example='v4'),
      }(name='AuthConf', description='The origin authentication information of the CNAME record.'),
      bizName?: string(name='BizName', description='The business scenario of the record for acceleration. Valid values:

*   **image_video**: video and image.
*   **api**: API.
*   **web**: web page.', example='web'),
      comment?: string(name='Comment', description='The comments of the record.', example='this is a remark.'),
      createTime?: string(name='CreateTime', description='The time when the record was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.', example='2023-12-24T02:01:11Z'),
      data?: {
        algorithm?: int32(name='Algorithm', description='The encryption algorithm used for the record. Valid values: 0 to 255. Exclusive to CERT and SSHFP records.', example='0'),
        certificate?: string(name='Certificate', description='The public key of the certificate. Exclusive to CERT, SMIMEA, and TLSA records.', example='dGVzdGFkYWxrcw=='),
        fingerprint?: string(name='Fingerprint', description='The public key fingerprint of the record. Exclusive to SSHFP records.', example='abcdef1234567890'),
        flag?: int32(name='Flag', description='The flag bit of the record. The Flag for a CAA record indicates its priority and how it is processed. Valid values: 0 to 255. Exclusive to CAA records.', example='128'),
        keyTag?: int32(name='KeyTag', description='The public key identification for the record. Valid values: 0 to 65535. Exclusive to CERT records.', example='0'),
        matchingType?: int32(name='MatchingType', description='The algorithm policy used to match or validate the certificate. Valid values: 0 to 255. Exclusive to SMIMEA and TLSA records.', example='0'),
        port?: int32(name='Port', description='The port of the record. Valid values: 0 to 65535. Exclusive to SRV records.', example='80'),
        priority?: int32(name='Priority', description='The priority of the record. Valid values: 0 to 65535. A smaller value indicates a higher priority. Exclusive to MX, SRV, and URI records.', example='0'),
        selector?: int32(name='Selector', description='The type of certificate or public key. Valid values: 0 to 255. Exclusive to SMIMEA, and TLSA records.', example='0'),
        tag?: string(name='Tag', description='The tag of the record. The Tag of a CAA record indicate its specific type and usage. Exclusive to CAA records.', example='issue'),
        type?: int32(name='Type', description='The certificate type of the record (in CERT records), or the public key type (in SSHFP records).', example='0'),
        usage?: int32(name='Usage', description='The usage identifier of the record. Valid values: 0 to 255. Exclusive to SMIMEA, and TLSA records.', example='0'),
        value?: string(name='Value', description='Record value or part of the record content. This value is returned when the record is A/AAAA, CNAME, NS, MX, TXT, CAA, SRV, or URI. It has different meanings based on types of records:

*   **A/AAAA**: the IP addresses. IP addresses are separated by commas (,). There is at least one IPv4 address.
*   **CNAME**: the pointed/mapped domain name.
*   **NS**: the nameservers for the domain name.
*   **MX**: a valid domain name of the mail server.
*   **TXT**: a valid text string.
*   **CAA**: a valid domain name of the certificate authority.
*   **SRV**: a valid domain name of the target host.
*   **URI**: a valid URI string.', example='CNAME'),
        weight?: int32(name='Weight', description='The weight of the record. Valid values: 0 to 65535. Exclusive to SRV and URI records.', example='0'),
      }(name='Data', description='The DNS record information. Different types of records contain different information.', example='{"value":"1.1.1.1"}'),
      hostPolicy?: string(name='HostPolicy', description='The origin host policy. This policy takes effect when the record type is CNAME. Valid values:

*   follow_hostname: matches the requested domain name.
*   follow_origin_domain: matches the origin\\"s domain name.', example='follow_origin_domain'),
      proxied?: boolean(name='Proxied', description='Indicates whether the record is proxied. Valid values:

*   **true**
*   **false**', example='true'),
      recordCname?: string(name='RecordCname', description='The CNAME. If you use CNAME setup when you add your website to ESA, the value is the CNAME that you configured then.', example='a.example.com.cnamezone.com'),
      recordId?: long(name='RecordId', description='The record ID.', example='1234567890123'),
      recordName?: string(name='RecordName', description='The record name.', example='a.example.com'),
      recordSourceType?: string(name='RecordSourceType', description='The origin type for the CNAME record. This parameter is returned when you add a CNAME record. Valid values:

*   **OSS**: OSS bucket.
*   **S3**: S3 bucket.
*   **LB**: load balancer.
*   **OP**: origin pool.
*   **Domain**: domain name.

If you do not pass this parameter or if you leave its value empty, Domain is returned by default.', example='OSS'),
      recordType?: string(name='RecordType', description='The DNS type of the record, such as **A/AAAA, CNAME, and TXT**.', example='A/AAAA'),
      siteId?: long(name='SiteId', description='The website ID.', example='1234567890123'),
      siteName?: string(name='SiteName', description='The website name.', example='example.com'),
      ttl?: long(name='Ttl', description='The TTL of the record. Unit: seconds. If the value is 1, the TTL of the record is determined by the system.', example='30'),
      updateTime?: string(name='UpdateTime', description='The time when the record was updated. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.', example='2023-06-07T10:02:59Z'),
    }
  ](name='Records', description='The DNS record information. The format of this field varies based on the record type. For more information, see Add DNS records.'),
  requestId?: string(name='RequestId', description='The request ID.', example='15C66C7B-671A-4297-9187-2C4477247A74'),
  totalCount?: int32(name='TotalCount', description='The total number of records returned.', example='20'),
}

model ListRecordsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListRecordsResponseBody(name='body'),
}

/**
  * @description The DNS records related to Edge Container, Edge Routine, and TCP/UDP proxy are not returned in this operation.
  * @param request  the request parameters of ListRecords  ListRecordsRequest
  * @return ListRecordsResponse
 */
async function listRecords(request: ListRecordsRequest): ListRecordsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListRecords', 'GET', '/', 'json', false, 'json', request);
}

model ListRoutineCanaryAreasRequest {
}

model ListRoutineCanaryAreasResponseBody = {
  canaryAreas?: [ string ](name='CanaryAreas', description='The regions for canary release.'),
  requestId?: string(name='RequestId', description='The request ID.', example='EDBD3EB3-97DA-5465-AEF5-8DCA5DC5E395'),
}

model ListRoutineCanaryAreasResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListRoutineCanaryAreasResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListRoutineCanaryAreas  ListRoutineCanaryAreasRequest
  * @return ListRoutineCanaryAreasResponse
 */
async function listRoutineCanaryAreas(request: ListRoutineCanaryAreasRequest): ListRoutineCanaryAreasResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListRoutineCanaryAreas', 'POST', '/', 'json', false, 'json', request);
}

model ListRoutineOptionalSpecsRequest {
}

model ListRoutineOptionalSpecsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='1234567890ABCDEF01234567890ABCDEF'),
  specs?: [ 
    {
      isAvailable?: boolean(name='IsAvailable', description='Indicates whether the specification is available. Valid values:

*   true
*   false', example='true'),
      specName?: string(name='SpecName', description='The specification name.', example='5ms'),
    }
  ](name='Specs', description='The available specifications.'),
}

model ListRoutineOptionalSpecsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListRoutineOptionalSpecsResponseBody(name='body'),
}

/**
  * @description You can call this operation to query the specifications that you can select for a routine.
  * @param request  the request parameters of ListRoutineOptionalSpecs  ListRoutineOptionalSpecsRequest
  * @return ListRoutineOptionalSpecsResponse
 */
async function listRoutineOptionalSpecs(request: ListRoutineOptionalSpecsRequest): ListRoutineOptionalSpecsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListRoutineOptionalSpecs', 'POST', '/', 'json', false, 'json', request);
}

model ListScheduledPreloadExecutionsRequest {
  id: string(name='Id', description='The ID of the scheduled prefetch task.

This parameter is required.', example='ListScheduledPreloadExecutions', position='Query'),
}

model ListScheduledPreloadExecutionsResponseBody = {
  executions?: [ 
    {
      aliUid?: string(name='AliUid', description='The ID of the Alibaba Cloud account.', example='15685865xxx14622'),
      endTime?: string(name='EndTime', description='The end time of the prefetch plan.', example='2024-05-31T18:10:48.849+08:00'),
      id?: string(name='Id', description='The ID of the prefetch plan.', example='66599bd7397885b43804901c'),
      interval?: int32(name='Interval', description='The time interval between each batch execution in the plan. Unit: seconds.', example='60'),
      jobId?: string(name='JobId', description='The ID of the prefetch task.', example='665d3af3621bccf3fe29e1a4'),
      sliceLen?: int32(name='SliceLen', description='The number of URLs prefetched in each batch.', example='10'),
      startTime?: string(name='StartTime', description='The start time of the prefetch plan.', example='2024-05-31T17:10:48.849+08:00'),
      status?: string(name='Status', description='The status of the prefetch plan. Valid values:

*   **waiting**
*   **running**
*   **finished**
*   **failed**
*   **stopped**', example='running'),
    }
  ](name='Executions', description='The information about prefetch plans returned.'),
  requestId?: string(name='RequestId', description='The request ID.', example='ET5BF670-09D5-4D0B-BEBY-D96A2A528000'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='2'),
}

model ListScheduledPreloadExecutionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListScheduledPreloadExecutionsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListScheduledPreloadExecutions  ListScheduledPreloadExecutionsRequest
  * @return ListScheduledPreloadExecutionsResponse
 */
async function listScheduledPreloadExecutions(request: ListScheduledPreloadExecutionsRequest): ListScheduledPreloadExecutionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListScheduledPreloadExecutions', 'GET', '/', 'json', false, 'json', request);
}

model ListScheduledPreloadJobsRequest {
  endTime?: long(name='EndTime', description='The end time for querying the task creation time range. Specify the timestamp in milliseconds.', example='1717225277000', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20', minimum=1, maximum=100, position='Query'),
  siteId: long(name='SiteId', description='The website ID.

This parameter is required.', example='ListScheduledPreloadJobs', position='Query'),
  startTime?: long(name='StartTime', description='The beginning of the task creation time range to query. Specify the timestamp in milliseconds.', example='1717225276000', position='Query'),
}

model ListScheduledPreloadJobsResponseBody = {
  jobs?: [ 
    {
      aliUid?: string(name='AliUid', description='The ID of the Alibaba Cloud account.', example='15685865xxx14622'),
      createdAt?: string(name='CreatedAt', description='The time when the task was created.', example='2024-06-01T08:53:13Z'),
      domains?: string(name='Domains', description='The domain names to be prefetched.', example='testurl.com'),
      errorInfo?: string(name='ErrorInfo', description='The error message that is returned.', example='invalid domain:test.com'),
      failedFileOss?: string(name='FailedFileOss', description='The URL of the OSS object that stores a list of URLs that failed the conditional check for prefetching.', example='https://xxxobject.oss-cn-reginon.aliyuncs.com/9d91_xxxxxxxxxxx_158bb6e0f97c477791209bb46bd599f7'),
      fileId?: string(name='FileId', description='The ID of the URL list file, which can be used during downloads.', example='665d3b48621bccf3fe29e1a7'),
      id?: string(name='Id', description='The ID of the prefetch task.', example='665d3af3621bccf3fe29e1a4'),
      insertWay?: string(name='InsertWay', description='The method to submit the URLs to be prefetched.', example='oss'),
      name?: string(name='Name', description='The task name.', example='example'),
      siteId?: long(name='SiteId', description='The website ID.', example='190007158391808'),
      taskSubmitted?: int32(name='TaskSubmitted', description='The number of submitted prefetch tasks.', example='1'),
      taskType?: string(name='TaskType', description='The task type. Valid values: refresh and preload.', example='preload'),
      urlCount?: int32(name='UrlCount', description='The total number of URLs.', example='2'),
      urlSubmitted?: int32(name='UrlSubmitted', description='The number of submitted URLs.', example='1'),
    }
  ](name='Jobs', description='The list of the prefetch tasks.'),
  requestId?: string(name='RequestId', description='The request ID.', example='CB1A380B-09F0-41BB-A198-72F8FD6DA2FE'),
  totalCount?: string(name='TotalCount', description='The total number of tasks returned.', example='5'),
}

model ListScheduledPreloadJobsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListScheduledPreloadJobsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListScheduledPreloadJobs  ListScheduledPreloadJobsRequest
  * @return ListScheduledPreloadJobsResponse
 */
async function listScheduledPreloadJobs(request: ListScheduledPreloadJobsRequest): ListScheduledPreloadJobsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListScheduledPreloadJobs', 'GET', '/', 'json', false, 'json', request);
}

model ListSiteDeliveryTasksRequest {
  businessType?: string(name='BusinessType', description='The log category. Valid values:

*   dcdn_log_access_l1 (default): access logs.
*   dcdn_log_er: Edge Routine logs.
*   dcdn_log_waf: firewall logs.
*   dcdn_log_ipa: TCP/UDP proxy logs.', example='dcdn_log_access_l1', position='Query'),
  pageNumber?: long(name='PageNumber', description='The page number. Default value: 1.', example='1', position='Query'),
  pageSize?: long(name='PageSize', description='The number of entries per page. Default value: 20.', example='20', position='Query'),
  siteId: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.

This parameter is required.', example='123456***', position='Query'),
}

model ListSiteDeliveryTasksResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number. Default value: 0.', example='0'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values: **1 to 500**. Default value: **20**.', example='20'),
  requestId?: string(name='RequestId', description='The request ID.', example='34DCBC8A-****-****-****-6DAA11D7DDBD'),
  tasks?: [ 
    {
      businessType?: string(name='BusinessType', description='The log category. Valid values:

*   dcdn_log_access_l1 (default): access logs.
*   dcdn_log_er: Edge Routine logs.
*   dcdn_log_waf: firewall logs.
*   dcdn_log_ipa: TCP/UDP proxy logs.', example='dcdn_log_access_l1'),
      dataCenter?: string(name='DataCenter', description='The data center. Valid values:

*   cn: the Chinese mainland.
*   sg: outside the Chinese mainland.', example='cn'),
      deliveryType?: string(name='DeliveryType', description='The destination of the delivery. Valid values:

1.  sls: Alibaba Cloud Simple Log Service (SLS).
2.  http: HTTP server.
3.  aws3: Amazon Simple Storage Service (S3).
4.  oss: Alibaba Cloud Object Storage Service (OSS).
5.  kafka: Kafka.
6.  aws3cmpt: S3-compatible storage service.', example='sls'),
      status?: string(name='Status', description='The status of the delivery task.

*   **online**
*   **offline**', example='online'),
      taskName?: string(name='TaskName', description='The name of the delivery task.', example='cdn-test-task'),
    }
  ](name='Tasks', description='The delivery tasks.'),
  totalCount?: int32(name='TotalCount', description='The total number of log delivery tasks.', example='20'),
}

model ListSiteDeliveryTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListSiteDeliveryTasksResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListSiteDeliveryTasks  ListSiteDeliveryTasksRequest
  * @return ListSiteDeliveryTasksResponse
 */
async function listSiteDeliveryTasks(request: ListSiteDeliveryTasksRequest): ListSiteDeliveryTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListSiteDeliveryTasks', 'GET', '/', 'json', false, 'json', request);
}

model ListSitesRequest {
  accessType?: string(name='AccessType', description='The DNS setup. Valid values:

*   **NS**
*   **CNAME**', example='NS', position='Query'),
  coverage?: string(name='Coverage', description='The service location. Valid values:

*   **domestic**: the Chinese mainland
*   **global**: global
*   **overseas**: outside the Chinese mainland', example='global', position='Query'),
  onlyEnterprise?: boolean(name='OnlyEnterprise', description='Specifies whether to query only websites on Enterprise plans. Valid values: **true and false**.', example='false', position='Query'),
  orderBy?: string(name='OrderBy', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number. Default value: **1**.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: **500**.', example='20', position='Query'),
  planSubscribeType?: string(name='PlanSubscribeType', description='The plan type. Valid values:

*   **basicplan**: Entrance (coming soon)
*   **standardplan**: Pro
*   **advancedplan**: Premium
*   **enterpriseplan**: Enterprise', example='basicplan', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group. This parameter specifies a filter condition for the query.', example='rg-aekzd3styujvyei', position='Query'),
  siteName?: string(name='SiteName', description='The website name. This parameter specifies a filter condition for the query.', example='example.com', position='Query'),
  siteSearchType?: string(name='SiteSearchType', description='The match mode to search for the website name. Default value: exact. Valid values:

*   **prefix**: match by prefix.
*   **suffix**: match by suffix.
*   **exact**: exact match.
*   **fuzzy**: fuzzy match.', example='fuzzy', position='Query'),
  status?: string(name='Status', description='The website status. This parameter specifies a filter condition for the query.', example='pending', position='Query'),
  tagFilter?: [ 
    {
      key?: string(name='Key', description='The tag key. This parameter specifies a filter condition for the query.', example='tag1'),
      value?: string(name='Value', description='The tag value. This parameter specifies a filter condition for the query.', example='aaa'),
    }
  ](name='TagFilter', description='The tag filtering rule.', shrink='json', position='Query'),
}

model ListSitesResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of websites per page.', example='20'),
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
  sites?: [ 
    {
      accessType?: string(name='AccessType', description='The DNS setup for the website. Valid values:

*   **NS**
*   **CNAME**', example='NS'),
      cnameZone?: string(name='CnameZone', description='The CNAME of the website domain. If you use CNAME setup when you add your website to ESA, the value is the CNAME that you configured then.', example='example.cname.com'),
      coverage?: string(name='Coverage', description='The service location for the website. Valid values:

*   **domestic**: the Chinese mainland
*   **global**: global
*   **overseas**: outside the Chinese mainland', example='domestic'),
      createTime?: string(name='CreateTime', description='The time when the website was added. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.', example='2023-12-24T02:01:11Z'),
      instanceId?: string(name='InstanceId', description='The ID of the plan associated with the website.', example='onBvtlmIyeXLbiDw81F9'),
      nameServerList?: string(name='NameServerList', description='The nameservers assigned to the website domain, which are separated by commas (,).', example='male1-1.ialicdn.com,female1-1.ialicdn.com'),
      planName?: string(name='PlanName', description='The plan name.', example='plan-168656498****'),
      planSpecName?: string(name='PlanSpecName', description='The plan associated with the website.', example='normal'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-aek26g6i6se6pna'),
      siteId?: long(name='SiteId', description='The website ID.', example='123456789****'),
      siteName?: string(name='SiteName', description='The website name.', example='example.com'),
      status?: string(name='Status', description='The website status. Valid values:

*   **pending**: The website is to be configured.
*   **active**: The website is active.
*   **offline**: The website is suspended.
*   **moved**: The website has been added and verified by another Alibaba Cloud account.', example='pending'),
      tags?: map[string]any(name='Tags', description='The tags of the website.', example='{"tag1":"value1"}'),
      updateTime?: string(name='UpdateTime', description='The time when the website was updated. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.', example='2023-12-24T02:01:11Z'),
      verifyCode?: string(name='VerifyCode', description='The code that is used to verify the website domain ownership. As part of the verification TXT record, this parameter is returned for websites that use CNAME setup.', example='verify_d516cb3740f81f0cef77d162edd1****'),
      visitTime?: string(name='VisitTime'),
    }
  ](name='Sites', description='The queried websites.'),
  totalCount?: int32(name='TotalCount', description='The total number of websites.', example='40'),
}

model ListSitesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListSitesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListSites  ListSitesRequest
  * @return ListSitesResponse
 */
async function listSites(request: ListSitesRequest): ListSitesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListSites', 'GET', '/', 'json', false, 'json', request);
}

model ListTagResourcesRequest {
  maxItem?: int32(name='MaxItem', description='The maximum number of tags to return.', example='20', position='Query'),
  nextToken?: string(name='NextToken', description='The pagination token that is used in the next request to retrieve a new page of results.

>  This parameter is not required for the first request. If not all results are returned in one query, you can specify the token that is obtained from the previous query as the value of **NextToken**.', example='AAAAAZjtYxxxxxxxx', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='The ID of the region where the resources reside.

This parameter is required.', example='cn-hangzhou', position='Query'),
  resourceId?: [ string ](name='ResourceId', description='The website information. Valid values of he number of website IDs: **1** to **50**.', position='Query'),
  resourceType: string(name='ResourceType', description='The resource type.

This parameter is required.', example='site', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key.', example='env'),
      value?: string(name='Value', description='The tag value.', example='value'),
    }
  ](name='Tag', description='A list of tags. You can enter up to 20 tags.', position='Query'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken', description='The pagination token that is used in the next request to retrieve a new page of results. If NextToken is empty, no next page exists.', example='AAAAAYwsxxxxxxx'),
  requestId?: string(name='RequestId', description='The request ID.', example='CB1A380B-09F0-41BB-280B-72F8FD6DA2FE'),
  tagResources?: [ 
    {
      resourceId?: string(name='ResourceId', description='The resource ID.', example='example.com'),
      resourceType?: string(name='ResourceType', description='The resource type.', example='site'),
      tagKey?: string(name='TagKey', description='The tag key.', example='env'),
      tagValue?: string(name='TagValue', description='The tag value.', example='value'),
    }
  ](name='TagResources', description='The tags of the resource.'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='16'),
}

model ListTagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTagResourcesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListTagResources  ListTagResourcesRequest
  * @return ListTagResourcesResponse
 */
async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTagResources', 'POST', '/', 'json', false, 'json', request);
}

model ListUploadTasksRequest {
  endTime?: string(name='EndTime', description='The time when the task ends. Specify the time in the YYYY-MM-DDThh:mm:ssZ format.', example='2019-12-06T12:00:00Z', position='Query'),
  siteId?: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.', example='123456****', position='Query'),
  startTime?: string(name='StartTime', description='The time when the task starts. Specify the time in the YYYY-MM-DDThh:mm:ssZ format.', example='2018-11-29T00:00:00Z', position='Query'),
  type?: string(name='Type', description='The task type. Valid values:

*   **file**: purges the cache by file URL.
*   **preload**: prefetches files.
*   **directory**: purges the cache by directory.
*   **ignoreparams**: purges the cache by URL with specified parameters ignored.', example='file', position='Query'),
}

model ListUploadTasksResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CB1A380B-09F0-41BB-A198-72F8FD6D****'),
  tasks?: [ 
    {
      createTime?: string(name='CreateTime', description='The time when the task was created.', example='2023-07-26T01:56:15Z'),
      description?: string(name='Description', description='The error message returned when the file upload task failed.', example='invalid url'),
      errorCode?: string(name='ErrorCode', description='The error code. Multiple error codes are separated by commas (,).

*   **InvalidUrl**: The URL format is incorrect.
*   **InvalidDomain**: The domain ownership fails to be verified.
*   **QuotaExcess**: The quota limit has been reached.
*   **OtherErrors**: Other errors.', example='InvalidUrl,InvalidDomain'),
      status?: string(name='Status', description='The task status.

*   **Complete**: The task is complete.
*   **Refreshing**: The task is in progress.
*   **Failed**: The task failed.', example='Complete'),
      type?: string(name='Type', description='The task type. Valid values:

*   **file**: purges the cache by file URL.
*   **preload**: prefetches files.
*   **directory**: purges the cache by directory.
*   **ignoreparams**: purges the cache by URL with specified parameters ignored.', example='file'),
      uploadId?: string(name='UploadId', description='The ID of the file upload task.', example='159253299357****'),
      uploadTaskName?: string(name='UploadTaskName', description='The name of the file upload task.', example='purge_file_task'),
    }
  ](name='Tasks', description='The file upload tasks.'),
}

model ListUploadTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListUploadTasksResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListUploadTasks  ListUploadTasksRequest
  * @return ListUploadTasksResponse
 */
async function listUploadTasks(request: ListUploadTasksRequest): ListUploadTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListUploadTasks', 'GET', '/', 'json', false, 'json', request);
}

model ListUserDeliveryTasksRequest {
  businessType?: string(name='BusinessType', description='The log category. Valid values:

1.  dcdn_log_access_l1 (default): access logs.
2.  dcdn_log_er: Edge Routine logs.
3.  dcdn_log_waf: firewall logs.
4.  dcdn_log_ipa: TCP/UDP proxy logs.', example='dcdn_log_access_l1', position='Query'),
  pageNumber?: long(name='PageNumber', description='The page number. Default value: 1.', example='1', position='Query'),
  pageSize?: long(name='PageSize', description='The number of entries per page. Default value: 20.', example='20', position='Query'),
}

model ListUserDeliveryTasksResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number returned.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
  requestId?: string(name='RequestId', description='The request ID.', example='1f94c47f-3a1a-4f69-8d6c-bfeee1b49aab'),
  tasks?: [ 
    {
      businessType?: string(name='BusinessType', description='The log category.', example='dcdn_log_er'),
      dataCenter?: string(name='DataCenter', description='The data center. Valid values:

1.  cn: the Chinese mainland.
2.  sg: outside the Chinese mainland.', example='cn'),
      deliveryType?: string(name='DeliveryType', description='The delivery destination.', example='oss'),
      status?: string(name='Status', description='The status of the delivery task.', example='online'),
      taskName?: string(name='TaskName', description='The name of the delivery task.', example='testoss11'),
    }
  ](name='Tasks', description='The delivery tasks.'),
  totalCount?: int32(name='TotalCount', description='The total number of delivery tasks.', example='68'),
}

model ListUserDeliveryTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListUserDeliveryTasksResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListUserDeliveryTasks  ListUserDeliveryTasksRequest
  * @return ListUserDeliveryTasksResponse
 */
async function listUserDeliveryTasks(request: ListUserDeliveryTasksRequest): ListUserDeliveryTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListUserDeliveryTasks', 'GET', '/', 'json', false, 'json', request);
}

model ListUserRatePlanInstancesRequest {
  checkRemainingSiteQuota?: string(name='CheckRemainingSiteQuota', description='Specifies whether to query only the plans that have remaining quota for associating websites. Valid values:

*   true: queries only the plans that have remaining quota for associating websites.
*   false: queries all plans in your account.', example='true', position='Query'),
  instanceId?: string(name='InstanceId', description='The plan ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.', example='sp-xcdn-96wblslz****', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number. Valid values: **1** to **100000**. Default value: **1**.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='500', position='Query'),
  remainingExpireDays?: int32(name='RemainingExpireDays', position='Query'),
  sortBy?: string(name='SortBy', description='The sorting field. By default, the queried plans are sorted by purchase time. Valid values:

*   CreateTime: the time when the plans were purchased.
*   ExpireTime: the time when the plans expire.', example='CreateTime', position='Query'),
  sortOrder?: string(name='SortOrder', description='The order in which you want to sort the query results. Default value: desc. Valid values:

*   asc: in ascending order.
*   desc: in descending order.', example='asc', position='Query'),
  status?: string(name='Status', description='The plan status. Valid values:

*   online: The plan is in service.
*   offline: The plan has expired within an allowable period. In this state, the plan is unavailable.
*   disable: The plan is released.
*   overdue: The plan is stopped due to overdue payments.', example='online', position='Query'),
}

model ListUserRatePlanInstancesResponseBody = {
  instanceInfo?: [ 
    {
      billingMode?: string(name='BillingMode', description='The billing method. Valid values:

*   PREPAY: subscription.
*   POSTPAY: pay-as-you-go.', example='PREPAY'),
      botInstanceLevel?: string(name='BotInstanceLevel'),
      coverages?: string(name='Coverages', description='The service locations for the websites that can be associated with the plan. Multiple values are separated by commas (,). Valid values:

*   domestic: the Chinese mainland.
*   overseas: outside the Chinese mainland.
*   global: global.', example='domestic,overseas'),
      createTime?: string(name='CreateTime', description='The time when the plan was purchased.', example='YYYY-MM-DDThh:mm:ssZ'),
      crossborderTraffic?: string(name='CrossborderTraffic'),
      ddosBurstableDomesticProtection?: string(name='DdosBurstableDomesticProtection'),
      ddosBurstableOverseasProtection?: string(name='DdosBurstableOverseasProtection'),
      ddosInstanceLevel?: string(name='DdosInstanceLevel'),
      duration?: int32(name='Duration', description='The subscription duration of the plan. Unit: month.', example='3'),
      edgeRoutineRquest?: string(name='EdgeRoutineRquest'),
      edgeWafRequest?: string(name='EdgeWafRequest'),
      expireTime?: string(name='ExpireTime', description='The time when the plan expires.', example='YYYY-MM-DDThh:mm:ssZ'),
      instanceId?: string(name='InstanceId', description='The plan ID.', example='sp-xcdn-96wblslz****'),
      layer4Traffic?: string(name='Layer4Traffic'),
      layer4TrafficIntl?: string(name='Layer4TrafficIntl'),
      planName?: string(name='PlanName', description='The plan name.', example='basic'),
      planTraffic?: string(name='PlanTraffic'),
      planType?: string(name='PlanType', description='The plan type. Valid values:

*   normal
*   enterprise', example='normal'),
      siteQuota?: string(name='SiteQuota', description='The maximum number of websites that can be associated with the plan.', example='1'),
      sites?: [ 
        {
          siteId?: long(name='SiteId', description='The website ID.', example='123456****'),
          siteName?: string(name='SiteName', description='The website name.', example='example.com'),
          siteStatus?: string(name='SiteStatus', description='The website status. Valid values:

*   pending: The website is to be configured.
*   active: The website is active.
*   offline: The website is suspended.
*   moved: The website has been added and verified by another Alibaba Cloud account.', example='pending'),
        }
      ](name='Sites', description='The websites that have been associated with the plan.'),
      smartRoutingRequest?: string(name='SmartRoutingRequest'),
      staticRequest?: string(name='StaticRequest'),
      status?: string(name='Status', description='The plan status. Valid values:

*   online: The plan is in service.
*   offline: The plan has expired within an allowable period. In this state, the plan is unavailable.
*   disable: The plan is released.', example='online'),
    }
  ](name='InstanceInfo', description='The queried plans.'),
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
  requestId?: string(name='RequestId', description='The request ID.', example='CB1A380B-09F0-41BB-3C82-72F8FD6DA2FE'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='68'),
  totalPage?: int32(name='TotalPage', description='The total number of pages returned.', example='1'),
}

model ListUserRatePlanInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListUserRatePlanInstancesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListUserRatePlanInstances  ListUserRatePlanInstancesRequest
  * @return ListUserRatePlanInstancesResponse
 */
async function listUserRatePlanInstances(request: ListUserRatePlanInstancesRequest): ListUserRatePlanInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListUserRatePlanInstances', 'GET', '/', 'json', false, 'json', request);
}

model ListWafManagedRulesRequest {
  attackType: int32(name='AttackType', description='The attack type. Valid values:

*   SQL injection
*   Cross-site scripting
*   Code execution
*   CRLF
*   Local file inclusion
*   Remote file inclusion
*   webshell
*   Cross-site request forgery
*   Others
*   SEMA

This parameter is required.', example='11', position='Query'),
  id: long(name='Id', description='The ID of the WAF rule, which can be obtained by calling the [ListWafRules](~~ListWafRules~~) operation.

This parameter is required.', example='10000001', position='Query'),
  language?: string(name='Language', description='The language of the response. Valid values:

*   **en**: English.
*   **zh**: Chinese.', example='zh', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20', position='Query'),
  protectionLevel?: int32(name='ProtectionLevel', position='Query'),
  queryArgs?: {
    action?: string(name='Action', description='The action that you want WAF to perform on requests that match the rule.', example='deny'),
    idNameLike?: string(name='IdNameLike', description='The rule ID or name for fuzzy search.', example='example'),
    protectionLevels?: [ int32 ](name='ProtectionLevels', description='The protection levels of the rules.'),
    status?: string(name='Status', description='The status.', example='on'),
  }(name='QueryArgs', description='The query conditions.', shrink='json', position='Query'),
  siteId: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](~~ListSites~~) operation.

This parameter is required.', example='1', position='Query'),
}

model ListWafManagedRulesResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
  requestId?: string(name='RequestId', description='The request ID.', example='36af3fcc-43d0-441c-86b1-428951dc8225'),
  rules?: [ 
    {
      action?: string(name='Action', description='The action that WAF performs on requests that match the managed rule.', example='deny'),
      id?: long(name='Id', description='The ID of the managed rule.', example='100001'),
      name?: string(name='Name', description='The name of the managed rule.'),
      protectionLevel?: int32(name='ProtectionLevel', description='The protection level of the managed rule.', example='1'),
      status?: string(name='Status', description='The status of the protection rule.', example='on'),
    }
  ](name='Rules', description='The managed rules.'),
  totalCount?: long(name='TotalCount', description='The total number of filtered rules.', example='20'),
}

model ListWafManagedRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListWafManagedRulesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListWafManagedRules  ListWafManagedRulesRequest
  * @return ListWafManagedRulesResponse
 */
async function listWafManagedRules(request: ListWafManagedRulesRequest): ListWafManagedRulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListWafManagedRules', 'POST', '/', 'json', false, 'json', request);
}

model ListWafPhasesRequest {
  siteId: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.

This parameter is required.', example='1', position='Query'),
  siteVersion?: int32(name='SiteVersion', description='The version of the website.', example='0', position='Query'),
}

model ListWafPhasesResponseBody = {
  phases?: [ 
    {
      phase?: string(name='Phase', description='The name of the WAF rule category.', example='http_custom'),
      rulesets?: [ 
        {
          id?: long(name='Id', description='The ID of the WAF ruleset.[](~~2850233~~)', example='10000001'),
          name?: string(name='Name', description='The name of the WAF ruleset.', example='example'),
          rules?: [
            WafRuleConfig
          ](name='Rules', description='The rule configurations in the WAF ruleset.'),
          shared?: WafBatchRuleShared(name='Shared', description='The configurations shared by the rules in the WAF ruleset.'),
        }
      ](name='Rulesets', description='The WAF rulesets.'),
    }
  ](name='Phases', description='The WAF rule categories.'),
  requestId?: string(name='RequestId', description='The request ID.', example='36af3fcc-43d0-441c-86b1-428951dc8225'),
}

model ListWafPhasesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListWafPhasesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListWafPhases  ListWafPhasesRequest
  * @return ListWafPhasesResponse
 */
async function listWafPhases(request: ListWafPhasesRequest): ListWafPhasesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListWafPhases', 'POST', '/', 'json', false, 'json', request);
}

model ListWafRulesRequest {
  pageNumber?: int32(name='PageNumber', description='The page number.', example='http_custom', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='1', position='Query'),
  phase?: string(name='Phase', description='The WAF rule category. You can filter rules of a specific category.', example='0', position='Query'),
  queryArgs?: {
    desc?: boolean(name='Desc', description='Specifies whether to sort the returned data in descending order.', example='true'),
    id?: long(name='Id', description='The ID of a WAF rule for exact search.', example='20000001'),
    idNameLike?: string(name='IdNameLike', description='The ID or name of a WAF rule for fuzzy search.', example='example'),
    nameLike?: string(name='NameLike', description='The name of a WAF rule for fuzzy search.', example='example'),
    orderBy?: string(name='OrderBy', description='The column by which you want to sort the returned data.', example='position'),
    rulesetId?: long(name='RulesetId', description='The ID of a WAF ruleset for exact search.', example='10000001'),
    status?: string(name='Status', description='The status of a WAF rule for exact search.', example='on'),
  }(name='QueryArgs', description='The filter conditions.', example='http_custom', shrink='json', position='Query'),
  siteId: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.

This parameter is required.', example='1', position='Query'),
  siteVersion?: int32(name='SiteVersion', description='The version of the website.', example='1', position='Query'),
}

model ListWafRulesResponseBody = {
  instanceUsage?: long(name='InstanceUsage', description='The rule usage of the instance that corresponds to the website in the WAF rule category.', example='10'),
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
  requestId?: string(name='RequestId', description='The request ID.', example='36af3fcc-43d0-441c-86b1-428951dc8225'),
  rules?: [ 
    {
      action?: string(name='Action', description='The action triggered when requests match conditions defined in the rule.', example='deny'),
      characteristicsFields?: [ string ](name='CharacteristicsFields', description='The fields in rate limiting rules.'),
      config?: WafRuleConfig(name='Config', description='The configuration of the rule.'),
      fields?: [ string ](name='Fields', description='The fields in the rule.'),
      id?: long(name='Id', description='The rule ID.', example='20000001'),
      name?: string(name='Name', description='The rule name.', example='example'),
      phase?: string(name='Phase', description='The WAF rule category.', example='http_custom'),
      position?: long(name='Position', description='The position of the rule in the ruleset.', example='1'),
      rulesetId?: long(name='RulesetId', description='The ruleset ID.', example='10000001'),
      skip?: string(name='Skip', description='The skip scope applied when requests match conditions defined in the whitelist rule.', example='part'),
      status?: string(name='Status', description='Indicates whether the rule is enabled.', example='on'),
      tags?: [ string ](name='Tags', description='The skipped WAF rule categories when requests match conditions defined in the whitelist rule.'),
      timer?: WafTimer(name='Timer', description='The time when the rule takes effect.'),
      type?: string(name='Type', description='The WAF rule type.', example='http_custom'),
      updateTime?: string(name='UpdateTime', description='The time when the rule was modified.', example='2024-01-01T00:00:00Z'),
    }
  ](name='Rules', description='The rules returned.'),
  siteUsage?: long(name='SiteUsage', description='The rule usage of the website.', example='5'),
  totalCount?: long(name='TotalCount', description='The total number of filtered rules.', example='20'),
}

model ListWafRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListWafRulesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListWafRules  ListWafRulesRequest
  * @return ListWafRulesResponse
 */
async function listWafRules(request: ListWafRulesRequest): ListWafRulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListWafRules', 'POST', '/', 'json', false, 'json', request);
}

model ListWafRulesetsRequest {
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20', position='Query'),
  phase?: string(name='Phase', description='The WAF rule category of rulesets to query.', example='http_bot', position='Query'),
  queryArgs?: {
    anyLike?: string(name='AnyLike', description='The ruleset ID, ruleset name, rule ID, or rule name for fuzzy search.', example='example'),
    desc?: boolean(name='Desc', description='Specifies whether to sort the returned data in descending order.'),
    nameLike?: string(name='NameLike', description='The ruleset name for fuzzy search.', example='example'),
    orderBy?: string(name='OrderBy', description='The column by which you want to sort the returned data.', example='id'),
  }(name='QueryArgs', description='The query arguments in the JSON format, which contain filter conditions.', example='http_bot', shrink='json', position='Query'),
  siteId?: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.', example='1', position='Query'),
  siteVersion?: int32(name='SiteVersion', description='The version of the website.', example='1', position='Query'),
}

model ListWafRulesetsResponseBody = {
  instanceUsage?: long(name='InstanceUsage', description='The number of WAF rulesets that are used by the instance in the WAF rule category.', example='10'),
  pageNumber?: int32(name='PageNumber', description='The page number returned.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
  requestId?: string(name='RequestId', description='The request ID.', example='36af3fcc-43d0-441c-86b1-428951dc8225'),
  rulesets?: [ 
    {
      fields?: [ string ](name='Fields', description='The matched objects.'),
      id?: long(name='Id', description='The ID of the WAF ruleset.[](~~2850233~~)', example='10000001'),
      name?: string(name='Name', description='The ruleset name.', example='example'),
      phase?: string(name='Phase', description='The WAF rule category.', example='http_bot'),
      status?: string(name='Status', description='The ruleset status.', example='on'),
      target?: string(name='Target', description='The type of the protection target in the http_bot rule category.', example='web'),
      types?: [ string ](name='Types', description='The types of rules.'),
      updateTime?: string(name='UpdateTime', description='The time when the ruleset was last modified.', example='2024-01-01T00:00:00Z'),
    }
  ](name='Rulesets', description='The details of the rulesets.'),
  siteUsage?: long(name='SiteUsage', description='The number of WAF rulesets that are used by the website in the WAF rule category.', example='5'),
  totalCount?: long(name='TotalCount', description='The total number of filtered rulesets.', example='5'),
}

model ListWafRulesetsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListWafRulesetsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListWafRulesets  ListWafRulesetsRequest
  * @return ListWafRulesetsResponse
 */
async function listWafRulesets(request: ListWafRulesetsRequest): ListWafRulesetsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListWafRulesets', 'POST', '/', 'json', false, 'json', request);
}

model ListWafTemplateRulesRequest {
  phase?: string(name='Phase', description='The WAF rule category, which is used to filter template rules of a specific category.', example='http_anti_scan', position='Query'),
  queryArgs?: {
    type?: string(name='Type', description='The rule type.', example='http_directory_traversal'),
  }(name='QueryArgs', description='The query parameter, which is used to filter template rules based on criteria such as the rule type.', example='http_anti_scan', shrink='json', position='Query'),
  siteId?: long(name='SiteId', description='站点ID，可通过调用[ListSites](https://help.aliyun.com/document_detail/2850189.html)接口获取。', example='1', position='Query'),
}

model ListWafTemplateRulesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='36af3fcc-43d0-441c-86b1-428951dc8225'),
  rules?: [ 
    {
      config?: WafRuleConfig(name='Config', description='The configuration of the rule.'),
      name?: string(name='Name', description='The rule name.', example='HTTP Directory Traversal Rule [Template]'),
      phase?: string(name='Phase', description='The WAF rule category.', example='http_anti_scan'),
      status?: string(name='Status', description='Indicates whether the rule is enabled.', example='on'),
      type?: string(name='Type', description='The rule type.', example='http_directory_traversal'),
    }
  ](name='Rules', description='The returned template rules.'),
}

model ListWafTemplateRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListWafTemplateRulesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListWafTemplateRules  ListWafTemplateRulesRequest
  * @return ListWafTemplateRulesResponse
 */
async function listWafTemplateRules(request: ListWafTemplateRulesRequest): ListWafTemplateRulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListWafTemplateRules', 'POST', '/', 'json', false, 'json', request);
}

model ListWafUsageOfRulesRequest {
  phase?: string(name='Phase', description='The WAF rule category.', example='http_anti_scan', position='Query'),
  siteId?: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.', example='ListWafUsageOfRules', position='Query'),
}

model ListWafUsageOfRulesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='36af3fcc-43d0-441c-86b1-428951dc8225'),
  sites?: [ 
    {
      id?: long(name='Id', description='The website ID.', example='1'),
      name?: string(name='Name', description='The website name.', example='example.com'),
      usage?: long(name='Usage', description='The usage of WAF rules or WAF rulesets.', example='1'),
    }
  ](name='Sites', description='The usage details of WAF rules of the website.'),
}

model ListWafUsageOfRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListWafUsageOfRulesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListWafUsageOfRules  ListWafUsageOfRulesRequest
  * @return ListWafUsageOfRulesResponse
 */
async function listWafUsageOfRules(request: ListWafUsageOfRulesRequest): ListWafUsageOfRulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListWafUsageOfRules', 'POST', '/', 'json', false, 'json', request);
}

model ListWaitingRoomEventsRequest {
  siteId: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.

This parameter is required.', example='7096621098****', position='Query'),
  waitingRoomEventId?: long(name='WaitingRoomEventId', description='The ID of the waiting room event. This parameter is optional. You can specify this parameter to query a specific waiting room event.', example='89677721098****', position='Query'),
  waitingRoomId: string(name='WaitingRoomId', description='The unique ID of the waiting room, which can be obtained by calling the [ListWaitingRooms](https://help.aliyun.com/document_detail/2850279.html) operation.

This parameter is required.', example='6a51d5bc6460887abd129****', position='Query'),
}

model ListWaitingRoomEventsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID, which is used to trace a call.', example='f3c3700a-4c0f-4a24-b576-fd7dbf9e7c55'),
  waitingRoomEvents?: [ 
    {
      customPageHtml?: string(name='CustomPageHtml', description='The content of the custom waiting room page. This parameter is returned when the waiting room type is set to custom. The content is URL-encoded.', example='html-yets-maqi1111'),
      description?: string(name='Description', description='The event description.', example='terraform-example'),
      disableSessionRenewalEnable?: string(name='DisableSessionRenewalEnable', description='Indicates whether session renewal is disabled. Valid values:

*   on
*   off', example='off'),
      enable?: string(name='Enable', description='The event status. Valid values:

*   on
*   off', example='on'),
      endTime?: string(name='EndTime', description='The end time of the event. This value is a UNIX timestamp.', example='1719814497'),
      jsonResponseEnable?: string(name='JsonResponseEnable', description='Indicates whether JOSN response is enabled. If JSON response is enabled, a JSON body is returned for requests to the waiting room with the header Accept: application/json. Valid values:

*   on
*   off', example='off'),
      language?: string(name='Language', description='The language of the waiting room page. This parameter is returned when the waiting room type is set to default. Valid values:

*   enus: English.
*   zhcn: Simplified Chinese.
*   zhhk: Traditional Chinese.', example='zhcn'),
      name?: string(name='Name', description='The custom event name.'),
      newUsersPerMinute?: string(name='NewUsersPerMinute', description='The maximum number of new users per minute.', example='11'),
      preQueueEnable?: string(name='PreQueueEnable', description='Indicates whether pre-queuing is enabled. Valid values:

*   on
*   off', example='on'),
      preQueueStartTime?: string(name='PreQueueStartTime', description='The start time for pre-queuing. This value is a UNIX timestamp. This parameter is valid only when pre-queuing is enabled.', example='1719814097'),
      queuingMethod?: string(name='QueuingMethod', description='The queuing method. Valid values:

*   random: Users gain access to the origin randomly, regardless of the arrival time.
*   fifo: Users gain access to the origin in order of arrival.
*   passthrough: Users pass through the waiting room and go straight to the origin.
*   reject-all: Users are blocked from reaching the origin.', example='fifo'),
      queuingStatusCode?: string(name='QueuingStatusCode', description='The HTTP status code to return while a user is in the queue. Valid values:

*   200
*   202
*   429', example='200'),
      randomPreQueueEnable?: string(name='RandomPreQueueEnable', description='Indicates whether random queuing is enabled. Valid values:

*   on
*   off', example='on'),
      sessionDuration?: string(name='SessionDuration', description='The maximum duration for which a session remains valid after a user leaves the origin. Unit: minutes.', example='3'),
      startTime?: string(name='StartTime', description='The start time of the event. This value is a UNIX timestamp.', example='1719814398'),
      totalActiveUsers?: string(name='TotalActiveUsers', description='The maximum number of active users.', example='22'),
      waitingRoomEventId?: long(name='WaitingRoomEventId', description='The unique ID of the waiting room event.', example='89677721098****'),
      waitingRoomId?: string(name='WaitingRoomId', description='The ID of the waiting room associated with the event.', example='5c938a045c9ca46607163d34966****'),
      waitingRoomType?: string(name='WaitingRoomType', description='The type of the waiting room. Valid values:

*   default
*   custom', example='custom'),
    }
  ](name='WaitingRoomEvents', description='The details of the waiting room events.'),
}

model ListWaitingRoomEventsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListWaitingRoomEventsResponseBody(name='body'),
}

/**
  * @description You can call this operation to query details of all waiting room events related to a waiting room in a website.
  * @param request  the request parameters of ListWaitingRoomEvents  ListWaitingRoomEventsRequest
  * @return ListWaitingRoomEventsResponse
 */
async function listWaitingRoomEvents(request: ListWaitingRoomEventsRequest): ListWaitingRoomEventsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListWaitingRoomEvents', 'GET', '/', 'json', false, 'json', request);
}

model ListWaitingRoomRulesRequest {
  ruleName?: string(name='RuleName', description='Optional. The rule name, which can be used to query a specific bypass rule.', example='test', position='Query'),
  siteId: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.

This parameter is required.', example='123456****', position='Query'),
  waitingRoomId: string(name='WaitingRoomId', description='The ID of the waiting room to be bypassed, which can be obtained by calling the [ListWatingRooms](https://help.aliyun.com/document_detail/2850279.html) operation.

This parameter is required.', example='6a51d5bc6460887abd129****', position='Query'),
  waitingRoomRuleId?: long(name='WaitingRoomRuleId', description='Optional. The rule ID, which can be used to query a specific rule.', example='37286782688****', position='Query'),
}

model ListWaitingRoomRulesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID, which is used to trace a call.', example='15C66C7B-671A-4297-9187-2C4477247A123425345'),
  waitingRoomRules?: [ 
    {
      rule?: string(name='Rule', description='The rule content, which is a policy or conditional expression.', example='(http.request.uri.path.file_name eq \\"jpg\\")'),
      ruleEnable?: string(name='RuleEnable', description='Indicates whether the rule is enabled. Valid values:

*   on
*   off', example='on'),
      ruleName?: string(name='RuleName', description='The rule name.', example='ip'),
      waitingRoomRuleId?: long(name='WaitingRoomRuleId', description='The rule ID.', example='37286782688****'),
    }
  ](name='WaitingRoomRules', description='The waiting room bypass rules.'),
}

model ListWaitingRoomRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListWaitingRoomRulesResponseBody(name='body'),
}

/**
  * @description You can call this operation to query the waiting room bypass rules that are associated with a website.
  * @param request  the request parameters of ListWaitingRoomRules  ListWaitingRoomRulesRequest
  * @return ListWaitingRoomRulesResponse
 */
async function listWaitingRoomRules(request: ListWaitingRoomRulesRequest): ListWaitingRoomRulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListWaitingRoomRules', 'GET', '/', 'json', false, 'json', request);
}

model ListWaitingRoomsRequest {
  siteId: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.

This parameter is required.', example='120876698010528', position='Query'),
  waitingRoomId?: string(name='WaitingRoomId', description='The ID of the waiting room. Specify this parameter to query the information about a specific waiting room.', example='6a51d5bc6460887abd1291dc7d4d****', position='Query'),
}

model ListWaitingRoomsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID, which is used to trace a call.', example='CB1A380B-09F0-41BB-A198-72F8FD6DA2FE'),
  waitingRooms?: [ 
    {
      cookieName?: string(name='CookieName', description='The name of the custom cookie.', example='__aliwaitingroom_example'),
      customPageHtml?: string(name='CustomPageHtml', description='The HTML content or identifier of the custom queuing page. This parameter is valid only when `WaitingRoomType` is set to `custom`. The content must be URL-encoded.'),
      description?: string(name='Description', description='The description of the waiting room.'),
      disableSessionRenewalEnable?: string(name='DisableSessionRenewalEnable', description='Indicates whether session renewal is disabled. Valid values:

*   on
*   off', example='on'),
      enable?: string(name='Enable', description='Indicates whether the waiting room is enabled. Valid values:

*   on
*   off', example='on'),
      hostNameAndPath?: [ 
        {
          domain?: string(name='Domain', description='The domain name.', example='example.com'),
          path?: string(name='Path', description='The path.', example='/test'),
          subdomain?: string(name='Subdomain', description='The subdomain.', example='test.'),
        }
      ](name='HostNameAndPath', description='The hostname and path.'),
      jsonResponseEnable?: string(name='JsonResponseEnable', description='Indicates whether JSON response is enabled. If you set this parameter to on, a JSON body is returned for requests to the waiting room with the header Accept: application/json. Valid values:

*   on
*   off', example='on'),
      language?: string(name='Language', description='The language of the waiting room page. This parameter is returned when the waiting room type is set to default. Valid values:

*   enus: English.
*   zhcn: Simplified Chinese.
*   zhhk: Traditional Chinese.', example='zhcn'),
      name?: string(name='Name', description='The name of the waiting room.'),
      newUsersPerMinute?: string(name='NewUsersPerMinute', description='The maximum number of new users per minute.', example='200'),
      queueAllEnable?: string(name='QueueAllEnable', description='Indicates whether all requests must be queued. Valid values:

*   on
*   off', example='on'),
      queuingMethod?: string(name='QueuingMethod', description='The queuing method. Valid values:

*   random: Users gain access to the origin randomly, regardless of the arrival time.
*   fifo: Users gain access to the origin in order of arrival.
*   passthrough: Users pass through the waiting room and go straight to the origin.
*   reject-all: Users are blocked from reaching the origin.', example='random'),
      queuingStatusCode?: string(name='QueuingStatusCode', description='The HTTP status code to return while a user is in the queue. Valid values:

*   200
*   202
*   429', example='200'),
      sessionDuration?: string(name='SessionDuration', description='The maximum duration for which a session remains valid after a user leaves the origin. Unit: minutes.', example='3600'),
      totalActiveUsers?: string(name='TotalActiveUsers', description='The maximum number of active users.', example='300'),
      waitingRoomId?: string(name='WaitingRoomId', description='The unique ID of the waiting room.', example='6a51d5bc6460887abd1291dc7d4d****'),
      waitingRoomType?: string(name='WaitingRoomType', description='The type of the waiting room. Valid values:

*   default
*   custom', example='default'),
    }
  ](name='WaitingRooms', description='The waiting rooms.'),
}

model ListWaitingRoomsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListWaitingRoomsResponseBody(name='body'),
}

/**
  * @description You can call this operation to query detailed configurations about all waiting rooms in a website, including the status, name, and queuing rules of each waiting room.
  * @param request  the request parameters of ListWaitingRooms  ListWaitingRoomsRequest
  * @return ListWaitingRoomsResponse
 */
async function listWaitingRooms(request: ListWaitingRoomsRequest): ListWaitingRoomsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListWaitingRooms', 'GET', '/', 'json', false, 'json', request);
}

model PreloadCachesRequest {
  content?: [ string ](name='Content', description='The files to be prefetched.', shrink='json', position='Query'),
  headers?: map[string]string(name='Headers', description='By default, prefetch requests include the Accept-Encoding:gzip header. If you want a prefetch request to include other headers or implement multi-replica prefetch, you can specify a custom prefetch header by configuring the Headers parameter.', shrink='json', position='Query'),
  siteId?: long(name='SiteId', description='The website ID. You can call the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation to obtain the ID.', example='123456789****', position='Query'),
}

model PreloadCachesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='9732E117-8A37-49FD-A36F-ABBB87556CA7'),
  taskId?: string(name='TaskId', description='The prefetch task ID.', example='16401427840'),
}

model PreloadCachesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PreloadCachesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of PreloadCaches  PreloadCachesRequest
  * @return PreloadCachesResponse
 */
async function preloadCaches(request: PreloadCachesRequest): PreloadCachesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PreloadCaches', 'POST', '/', 'json', false, 'json', request);
}

model PublishEdgeContainerAppVersionRequest {
  appId: string(name='AppId', description='The application ID.

This parameter is required.', example='app-88068867578379****', minLength=20, maxLength=64, position='Body'),
  fullRelease?: boolean(name='FullRelease', description='Specifies whether to fully release the version. This parameter takes effect only when PublishType is set to region.', example='true', position='Query'),
  percentage?: int32(name='Percentage', description='The release percentage. Valid values: 1 to 100. Default value: 100.', example='100', minimum=1, maximum=100, position='Body'),
  publishEnv: string(name='PublishEnv', description='The environment to which you want to release the version. Valid values:

*   prod: the production environment.
*   staging: the staging environment.

This parameter is required.', example='prod', position='Body'),
  publishType?: string(name='PublishType', description='Specifies how the version is released. Valid values:

*   percentage: releases the version by percentage.
*   region: releases the version by region.

If you do not specify this parameter, the version is released by percentage by default.', example='percentage', position='Query'),
  regions?: [ string ](name='Regions', description='The regions to which the version is released.', shrink='json', position='Query'),
  remarks?: string(name='Remarks', description='The remarks. This parameter is empty by default.', example='test publish app', maxLength=1024, position='Body'),
  startTime?: string(name='StartTime', description='The time when the application version starts to be released. If you do not specify this parameter, the current time is used by default.

Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2023-06-05T16:00:00Z', position='Body'),
  versionId: string(name='VersionId', description='The version ID.

This parameter is required.', example='ver-87962637161651****', minLength=20, maxLength=64, position='Query'),
}

model PublishEdgeContainerAppVersionResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model PublishEdgeContainerAppVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PublishEdgeContainerAppVersionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of PublishEdgeContainerAppVersion  PublishEdgeContainerAppVersionRequest
  * @return PublishEdgeContainerAppVersionResponse
 */
async function publishEdgeContainerAppVersion(request: PublishEdgeContainerAppVersionRequest): PublishEdgeContainerAppVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PublishEdgeContainerAppVersion', 'POST', '/', 'json', true, 'form', request);
}

model PublishRoutineCodeVersionRequest {
  canaryAreaList?: [ string ](name='CanaryAreaList', description='The regions for canary release.', shrink='json', position='Body'),
  canaryCodeVersion?: string(name='CanaryCodeVersion', description='The version number for canary release.', example='1710120201067203242', position='Body'),
  codeVersion?: string(name='CodeVersion', description='The code version to be released.', example='1710120201067203242', position='Body'),
  env: string(name='Env', description='The environment name.

This parameter is required.', example='production', position='Body'),
  name: string(name='Name', description='The routine name.

This parameter is required.', example='PublishRoutineCodeVersion', position='Body'),
}

model PublishRoutineCodeVersionResponseBody = {
  codeVersion?: string(name='CodeVersion', description='The code version.', example='1710120201067203242'),
  requestId?: string(name='RequestId', description='The request ID.', example='EDBD3EB3-97DA-5465-AEF5-8DCA5DC5E395'),
}

model PublishRoutineCodeVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PublishRoutineCodeVersionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of PublishRoutineCodeVersion  PublishRoutineCodeVersionRequest
  * @return PublishRoutineCodeVersionResponse
 */
async function publishRoutineCodeVersion(request: PublishRoutineCodeVersionRequest): PublishRoutineCodeVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PublishRoutineCodeVersion', 'POST', '/', 'json', true, 'form', request);
}

model PurgeCachesRequest {
  content?: {
    cacheTags?: [ string ](name='CacheTags', description='The cache tags that are used to purge the cache. This parameter is required if Type is set to cachetag.'),
    directories?: [ string ](name='Directories', description='The directories that are used to purge the cache. This parameter is required if Type is set to directory.'),
    files?: [ any ](name='Files', description='The files to purge. This parameter is required if Type is set to file.'),
    hostnames?: [ string ](name='Hostnames', description='The hostnames that are used to purge the cache. This parameter is required if Type is set to hostname.'),
    ignoreParams?: [ string ](name='IgnoreParams', description='The file URLs with parameters ignored that are used to purge the cache. This parameter is required if Type is set to ignoreParams.'),
    purgeAll?: boolean(name='PurgeAll', description='Specifies whether to purge all cache of the website. Default value: false. The value is true when Type is set to purgeall.', example='true'),
  }(name='Content', description='The content to purge.', shrink='json', position='Query'),
  edgeComputePurge?: boolean(name='EdgeComputePurge', description='Specifies whether to purge cached resources for edge computing. For example, purge the resources cached by the CacheAPI operation of Edge Routine.', example='true', position='Query'),
  force?: boolean(name='Force', description='Specifies whether to purge resources in a directory if the resources requested are different from the resources on the origin server. Default value: false.

*   **true**: purges all resources in the directory.
*   **false**: purges only changed resources in the directory.

>  This configuration takes effect for the following purge task types: directory, cachetag, ignoreParams, hostname, and purgeall.', example='true', position='Query'),
  siteId?: long(name='SiteId', description='The website ID. You can call the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation to obtain the ID.', example='123456789****', position='Query'),
  type: string(name='Type', description='The type of the purge task. Valid values:

*   **file** (default): purges the cache by file.
*   **cachetag**: purges the cache by cache tag.
*   **directory**: purges the cache by directory.
*   **ignoreParams**: purges the cache by URL with specific parameters ignored. This option ignores the question mark (?) and parameters after the question mark (?) in a request URL and purges the cache. After you call this operation with the request URL submitted, the system compares the submitted URL with the URL of the cached resource without specified parameters. If the URLs match, the POPs purge the cached resources.
*   **hostname**: purges the cache by hostname.
*   **purgeall**: purges all cache.

This parameter is required.', example='file', position='Query'),
}

model PurgeCachesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='ET5BF670-09D5-4D0B-BEBY-D96A2A528000'),
  taskId?: string(name='TaskId', description='The task ID, which is generated after you create a task.', example='15940956620'),
}

model PurgeCachesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PurgeCachesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of PurgeCaches  PurgeCachesRequest
  * @return PurgeCachesResponse
 */
async function purgeCaches(request: PurgeCachesRequest): PurgeCachesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PurgeCaches', 'POST', '/', 'json', false, 'json', request);
}

model PutKvRequest {
  base64?: boolean(name='Base64', description='Specifies whether the content of the key is Base64-encoded. Set this parameter to true if you want to store the key content in binary format. When this parameter is set to true, the Value parameter must be Base64-encoded.', example='true', position='Query'),
  expiration?: long(name='Expiration', description='The time when the key-value pair expires, which cannot be earlier than the current time. The value is a timestamp in seconds. If you specify both Expiration and ExpirationTtl, only ExpirationTtl takes effect.', example='1690081381', position='Query'),
  expirationTtl?: long(name='ExpirationTtl', description='The relative expiration time. Unit: seconds. If you specify both Expiration and ExpirationTtl, only ExpirationTtl takes effect.', example='3600', position='Query'),
  key: string(name='Key', description='The key name. The name can be up to 512 characters in length and cannot contain spaces or backslashes (\\\\).

This parameter is required.', example='test_key', position='Query'),
  namespace: string(name='Namespace', description='The name of the namespace that you specify when you call the [CreateKvNamespace](https://help.aliyun.com/document_detail/2850317.html) operation.

This parameter is required.', example='test_namespace', position='Query'),
  value: string(name='Value', description='The content of the key, which can be up to 2 MB (2 × 1000 × 1000). If the content is larger than 2 MB, call [PutKvWithHighCapacity](https://help.aliyun.com/document_detail/2850486.html).

This parameter is required.', example='test_value', position='Body'),
}

model PutKvResponseBody = {
  length?: string(name='Length', description='The length of the value in the key-value pair.', example='4'),
  requestId?: string(name='RequestId', description='The request ID.', example='EEEBE525-F576-1196-8DAF-2D70CA3F4D2F'),
  value?: string(name='Value', description='The content of the key. If the content has more than 256 characters in length, the system displays the first 100 and the last 100 characters, and omits the middle part.', example='test'),
}

model PutKvResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PutKvResponseBody(name='body'),
}

/**
  * @param request  the request parameters of PutKv  PutKvRequest
  * @return PutKvResponse
 */
async function putKv(request: PutKvRequest): PutKvResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PutKv', 'POST', '/', 'json', true, 'form', request);
}

model RebuildEdgeContainerAppStagingEnvRequest {
  appId?: string(name='AppId', description='The application ID, which can be obtained by calling the [ListEdgeContainerApps](~~ListEdgeContainerApps~~) operation.', example='app-88068867578379****', position='Query'),
}

model RebuildEdgeContainerAppStagingEnvResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='CB1A380B-09F0-41BB-3C82-72F8FD6DA2FE'),
}

model RebuildEdgeContainerAppStagingEnvResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RebuildEdgeContainerAppStagingEnvResponseBody(name='body'),
}

/**
  * @param request  the request parameters of RebuildEdgeContainerAppStagingEnv  RebuildEdgeContainerAppStagingEnvRequest
  * @return RebuildEdgeContainerAppStagingEnvResponse
 */
async function rebuildEdgeContainerAppStagingEnv(request: RebuildEdgeContainerAppStagingEnvRequest): RebuildEdgeContainerAppStagingEnvResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RebuildEdgeContainerAppStagingEnv', 'POST', '/', 'json', false, 'json', request);
}

model ResetScheduledPreloadJobRequest {
  id?: string(name='Id', description='The ID of the scheduled prefetch task.', example='ResetScheduledPreloadJob', position='Query'),
}

model ResetScheduledPreloadJobResponseBody = {
  aliUid?: string(name='AliUid', description='The ID of the Alibaba Cloud account.', example='15685865xxx14622'),
  createdAt?: string(name='CreatedAt', description='The time when the SQL task was created.', example='2024-06-02T02:23:26Z'),
  domains?: string(name='Domains', description='The domain names to be prefetched.', example='testurl.com'),
  errorInfo?: string(name='ErrorInfo', description='The error message that is returned.', example='invalid domain:test.com'),
  failedFileOss?: string(name='FailedFileOss', description='The URL of the OSS object that stores a list of URLs that failed the conditional check for prefetching.', example='https://xxxobject.oss-cn-reginon.aliyuncs.com/9d91_xxxxxxxxxxx_158bb6e0f97c477791209bb46bd599f7'),
  fileId?: string(name='FileId', description='The ID of the URL list file, which can be used during downloads.', example='665d3b48621bccf3fe29e1a7'),
  id?: string(name='Id', description='The ID of the prefetch task.', example='665d3af3621bccf3fe29e1a4'),
  insertWay?: string(name='InsertWay', description='The method to submit the URLs to be prefetched.', example='oss'),
  name?: string(name='Name', description='The delivery project name.', example='example'),
  requestId?: string(name='RequestId', description='The request ID.', example='15C66C7B-671A-4297-9187-2C4477247A74'),
  siteId?: long(name='SiteId', description='The website ID.', example='190007158391808'),
  taskSubmitted?: int32(name='TaskSubmitted', description='The number of submitted prefetch tasks.', example='1'),
  taskType?: string(name='TaskType', description='The task type. Valid values: refresh and preload.', example='preload'),
  urlCount?: int32(name='UrlCount', description='The total number of URLs.', example='2'),
  urlSubmitted?: int32(name='UrlSubmitted', description='The number of submitted URLs.', example='1'),
}

model ResetScheduledPreloadJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ResetScheduledPreloadJobResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ResetScheduledPreloadJob  ResetScheduledPreloadJobRequest
  * @return ResetScheduledPreloadJobResponse
 */
async function resetScheduledPreloadJob(request: ResetScheduledPreloadJobRequest): ResetScheduledPreloadJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ResetScheduledPreloadJob', 'POST', '/', 'json', false, 'json', request);
}

model RevokeClientCertificateRequest {
  id: string(name='Id', description='This parameter is required.', example='baba39055622c008b90285a8838ed09a', position='Query'),
  siteId: long(name='SiteId', description='This parameter is required.', example='1234567890123', position='Query'),
}

model RevokeClientCertificateResponseBody = {
  id?: string(name='Id', example='baba39055622c008b90285a8838ed09a'),
  requestId?: string(name='RequestId', example='15C66C7B-671A-4297-9187-2C4477247A123425345'),
  siteId?: long(name='SiteId', example='1234567890123'),
  siteName?: string(name='SiteName', example='example.com'),
}

model RevokeClientCertificateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RevokeClientCertificateResponseBody(name='body'),
}

/**
  * @param request  the request parameters of RevokeClientCertificate  RevokeClientCertificateRequest
  * @return RevokeClientCertificateResponse
 */
async function revokeClientCertificate(request: RevokeClientCertificateRequest): RevokeClientCertificateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RevokeClientCertificate', 'GET', '/', 'json', false, 'json', request);
}

model RollbackEdgeContainerAppVersionRequest {
  appId: string(name='AppId', description='The application ID.

This parameter is required.', example='app-88068867578379****', minLength=20, maxLength=64, position='Body'),
  remarks?: string(name='Remarks', description='The remarks.', example='test rollback app', maxLength=1024, position='Body'),
  versionId: string(name='VersionId', description='The ID of version that you want to roll back.

This parameter is required.', example='ver-87962637161651****', minLength=20, maxLength=64, position='Query'),
}

model RollbackEdgeContainerAppVersionResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='C370DAF1-C838-4288-A1A0-9A87633D248E'),
}

model RollbackEdgeContainerAppVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RollbackEdgeContainerAppVersionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of RollbackEdgeContainerAppVersion  RollbackEdgeContainerAppVersionRequest
  * @return RollbackEdgeContainerAppVersionResponse
 */
async function rollbackEdgeContainerAppVersion(request: RollbackEdgeContainerAppVersionRequest): RollbackEdgeContainerAppVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RollbackEdgeContainerAppVersion', 'POST', '/', 'json', true, 'form', request);
}

model SetCertificateRequest {
  casId?: long(name='CasId', description='The certificate ID on Certificate Management Service.', example='30000478', position='Body'),
  certificate?: string(name='Certificate', description='The certificate content.', example='-----BEGIN CERTIFICATE-----', position='Body'),
  id?: string(name='Id', description='The certificate ID on ESA.', example='30001303', position='Body'),
  name?: string(name='Name', description='The certificate name.', example='yourCertName', maxLength=128, position='Body'),
  ownerId?: long(name='OwnerId', position='Query'),
  privateKey?: string(name='PrivateKey', description='The private key of the certificate.', example='-----BEGIN PRIVATE KEY-----', position='Body'),
  region?: string(name='Region', description='The region.', example='cn-hangzhou', position='Body'),
  securityToken?: string(name='SecurityToken', position='Query'),
  siteId: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.

This parameter is required.', example='1234567890123', position='Body'),
  type: string(name='Type', description='The certificate type. Valid values:

*   cas: a certificate purchased by using Certificate Management Service.
*   upload: a custom certificate that you upload.

This parameter is required.', example='cas', position='Body'),
  update?: boolean(name='Update', description='Specifies whether to update the certificate.', example='true', position='Body'),
}

model SetCertificateResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='A666D44F-19D6-490E-97CF-1A64AB962C57'),
}

model SetCertificateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetCertificateResponseBody(name='body'),
}

/**
  * @param request  the request parameters of SetCertificate  SetCertificateRequest
  * @return SetCertificateResponse
 */
async function setCertificate(request: SetCertificateRequest): SetCertificateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetCertificate', 'POST', '/', 'json', true, 'form', request);
}

model SetClientCertificateHostnamesRequest {
  hostnames: [ string ](name='Hostnames', description='This parameter is required.', shrink='json', position='Body'),
  id?: string(name='Id', example='babab9db65ee5efcca9f3d41d4b50d66', position='Body'),
  siteId: long(name='SiteId', description='This parameter is required.', example='1234567890123', position='Query'),
}

model SetClientCertificateHostnamesResponseBody = {
  id?: string(name='Id', example='babab9db65ee5efcca9f3d41d4b50d66'),
  requestId?: string(name='RequestId', example='ET5BF670-09D5-4D0B-BEBY-D96A2A528000'),
  siteId?: long(name='SiteId', example='1234567890123'),
  siteName?: string(name='SiteName', example='example.com'),
}

model SetClientCertificateHostnamesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetClientCertificateHostnamesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of SetClientCertificateHostnames  SetClientCertificateHostnamesRequest
  * @return SetClientCertificateHostnamesResponse
 */
async function setClientCertificateHostnames(request: SetClientCertificateHostnamesRequest): SetClientCertificateHostnamesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetClientCertificateHostnames', 'POST', '/', 'json', true, 'form', request);
}

model SetHttpDDoSAttackIntelligentProtectionRequest {
  aiMode: string(name='AiMode', description='The mode of smart HTTP DDoS protection. Valid values:

*   **observe**: alert.
*   **defense**: block.

This parameter is required.', example='defense', position='Query'),
  aiTemplate: string(name='AiTemplate', description='The level of smart HTTP DDoS protection. Valid values:

*   **level0**: very loose.
*   **level30**: loose.
*   **level60**: normal.
*   **level90**: strict.

This parameter is required.', example='level60', position='Query'),
  siteId: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.

This parameter is required.', example='123456****', minimum=1, position='Query'),
}

model SetHttpDDoSAttackIntelligentProtectionResponseBody = {
  aiMode?: string(name='AiMode', description='The mode of smart HTTP DDoS protection. Valid values:

*   **observe**: alert.
*   **defense**: block.', example='defense'),
  aiTemplate?: string(name='AiTemplate', description='The level of smart HTTP DDoS protection. Valid values:

*   **level0**: very loose.
*   **level30**: loose.
*   **level60**: normal.
*   **level90**: strict.', example='level60'),
  requestId?: string(name='RequestId', description='The request ID.', example='156A6B-677B1A-4297B7-9187B7-2B44792'),
  siteId?: long(name='SiteId', description='The website ID.', example='123456****'),
}

model SetHttpDDoSAttackIntelligentProtectionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetHttpDDoSAttackIntelligentProtectionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of SetHttpDDoSAttackIntelligentProtection  SetHttpDDoSAttackIntelligentProtectionRequest
  * @return SetHttpDDoSAttackIntelligentProtectionResponse
 */
async function setHttpDDoSAttackIntelligentProtection(request: SetHttpDDoSAttackIntelligentProtectionRequest): SetHttpDDoSAttackIntelligentProtectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetHttpDDoSAttackIntelligentProtection', 'POST', '/', 'json', false, 'json', request);
}

model SetHttpDDoSAttackProtectionRequest {
  globalMode: string(name='GlobalMode', description='The level of HTTP DDoS attack protection. Valid values:

*   **very weak**: very loose.
*   **weak**: loose.
*   **default**: normal.
*   **hard**: strict.

This parameter is required.', example='default', position='Query'),
  siteId: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.

This parameter is required.', example='123456****', minimum=1, position='Query'),
}

model SetHttpDDoSAttackProtectionResponseBody = {
  globalMode?: string(name='GlobalMode', description='The level of HTTP DDoS attack protection.', example='default'),
  requestId?: string(name='RequestId', description='The request ID.', example='C370DAF1-C838-4288-A1A0-9A87633D248E'),
  siteId?: long(name='SiteId', description='The website ID.', example='123456****'),
}

model SetHttpDDoSAttackProtectionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetHttpDDoSAttackProtectionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of SetHttpDDoSAttackProtection  SetHttpDDoSAttackProtectionRequest
  * @return SetHttpDDoSAttackProtectionResponse
 */
async function setHttpDDoSAttackProtection(request: SetHttpDDoSAttackProtectionRequest): SetHttpDDoSAttackProtectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetHttpDDoSAttackProtection', 'POST', '/', 'json', false, 'json', request);
}

model StartScheduledPreloadExecutionRequest {
  id: string(name='Id', description='The ID of the prefetch plan.

This parameter is required.', example='StartScheduledPreloadExecution', position='Query'),
}

model StartScheduledPreloadExecutionResponseBody = {
  aliUid?: string(name='AliUid', description='The ID of the Alibaba Cloud account.', example='15685865xxx14622'),
  endTime?: string(name='EndTime', description='The end time of the prefetch plan.', example='2024-05-31T18:10:48.849+08:00'),
  id?: string(name='Id', description='The ID of the prefetch plan.', example='665d3b48621bccf3fe29e1a7'),
  interval?: int32(name='Interval', description='The time interval between each batch execution. Unit: seconds.', example='60'),
  jobId?: string(name='JobId', description='The ID of the prefetch task.', example='665d3af3621bccf3fe29e1a4'),
  requestId?: string(name='RequestId', description='The request ID.', example='65C66B7B-671A-8297-9187-2R5477247B76'),
  sliceLen?: int32(name='SliceLen', description='The number of URLs prefetched in each batch.', example='10'),
  startTime?: string(name='StartTime', description='The start time of the prefetch plan.', example='2024-05-31T17:10:48.849+08:00'),
  status?: string(name='Status', description='The status of the prefetch plan. Valid values:

*   **waiting**
*   **running**
*   **finished**
*   **failed**
*   **stopped**', example='waiting'),
}

model StartScheduledPreloadExecutionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StartScheduledPreloadExecutionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of StartScheduledPreloadExecution  StartScheduledPreloadExecutionRequest
  * @return StartScheduledPreloadExecutionResponse
 */
async function startScheduledPreloadExecution(request: StartScheduledPreloadExecutionRequest): StartScheduledPreloadExecutionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StartScheduledPreloadExecution', 'POST', '/', 'json', false, 'json', request);
}

model StopScheduledPreloadExecutionRequest {
  id: string(name='Id', description='The ID of the prefetch plan.

This parameter is required.', example='StopScheduledPreloadExecution', position='Query'),
}

model StopScheduledPreloadExecutionResponseBody = {
  aliUid?: string(name='AliUid', description='The ID of the Alibaba Cloud account.', example='15685865xxx14622'),
  endTime?: string(name='EndTime', description='The end time of the prefetch plan.', example='2024-05-31T18:10:48.849+08:00'),
  id?: string(name='Id', description='The ID of the prefetch plan.', example='66599bd7397885b43804901c'),
  interval?: int32(name='Interval', description='The time interval between each batch execution in the plan. Unit: seconds.', example='60'),
  jobId?: string(name='JobId', description='The ID of the prefetch task.', example='665d3af3621bccf3fe29e1a4'),
  requestId?: string(name='RequestId', description='The request ID.', example='CB1A380B-09F0-41BB-A198-72F8FD6DA2FE'),
  sliceLen?: int32(name='SliceLen', description='The number of URLs prefetched in each batch.', example='10'),
  startTime?: string(name='StartTime', description='The start time of the prefetch plan.', example='2024-05-31T17:10:48.849+08:00'),
  status?: string(name='Status', description='The status of the prefetch plan. Valid values:

*   **waiting**
*   **running**
*   **finished**
*   **failed**
*   **stopped**', example='stopped'),
}

model StopScheduledPreloadExecutionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StopScheduledPreloadExecutionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of StopScheduledPreloadExecution  StopScheduledPreloadExecutionRequest
  * @return StopScheduledPreloadExecutionResponse
 */
async function stopScheduledPreloadExecution(request: StopScheduledPreloadExecutionRequest): StopScheduledPreloadExecutionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StopScheduledPreloadExecution', 'POST', '/', 'json', false, 'json', request);
}

model UntagResourcesRequest {
  all?: boolean(name='All', description='Specifies whether to remove all tags. Valid values:

*   **true**
*   **false**

Default value: **false**.', example='false', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='The ID of the region where the resources reside. Set the value to **cn-hangzhou**.

This parameter is required.', example='cn-hangzhou', position='Query'),
  resourceId: [ string ](name='ResourceId', description='The ID of resource N. Valid values of N: **1** to **50**.

This parameter is required.', position='Query'),
  resourceType: string(name='ResourceType', description='The resource type.

This parameter is required.', example='site', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  tagKey?: [ string ](name='TagKey', description='The key of tag N to remove from the resource. Valid values of N: **1** to **20**.', position='Query'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='85H66C7B-671A-4297-9187-2C4477247A74'),
}

model UntagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UntagResourcesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UntagResources  UntagResourcesRequest
  * @return UntagResourcesResponse
 */
async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UntagResources', 'POST', '/', 'json', false, 'json', request);
}

model UpdateCustomScenePolicyRequest {
  endTime: string(name='EndTime', description='The time when the policy expires.

Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

This parameter is required.', example='2023-04-03T19:00:00Z', position='Query'),
  name: string(name='Name', description='The policy name.

This parameter is required.', example='test', maxLength=128, position='Query'),
  objects?: string(name='Objects', description='The IDs of the websites that you want to associate with the policy. Separate multiple IDs with commas (,).', example='123456****', position='Query'),
  policyId: long(name='PolicyId', description='The policy ID, which can be obtained by calling the [DescribeCustomScenePolicies](https://help.aliyun.com/document_detail/2850508.html) operation.

This parameter is required.', example='1', minimum=1, position='Query'),
  startTime: string(name='StartTime', description='The time when the policy takes effect.

Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

This parameter is required.', example='2023-04-03T16:00:00Z', position='Query'),
  template: string(name='Template', description='The name of the policy template. Valid value:

*   **promotion**: major events.

This parameter is required.', example='promotion', position='Query'),
}

model UpdateCustomScenePolicyResponseBody = {
  endTime?: string(name='EndTime', description='The time when the policy expires.

The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.', example='2023-04-03T19:00:00Z'),
  name?: string(name='Name', description='The policy name.', example='test'),
  objects?: [ string ](name='Objects', description='The IDs of websites associated.'),
  policyId?: long(name='PolicyId', description='The policy ID.', example='1'),
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
  startTime?: string(name='StartTime', description='The time when the policy takes effect.

The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.', example='2023-04-03T16:00:00Z'),
  template?: string(name='Template', description='The name of the policy template. Valid value:

*   **promotion**: major events.', example='promotion'),
}

model UpdateCustomScenePolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCustomScenePolicyResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateCustomScenePolicy  UpdateCustomScenePolicyRequest
  * @return UpdateCustomScenePolicyResponse
 */
async function updateCustomScenePolicy(request: UpdateCustomScenePolicyRequest): UpdateCustomScenePolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateCustomScenePolicy', 'POST', '/', 'json', false, 'json', request);
}

model UpdateKvNamespaceRequest {
  namespace: string(name='Namespace', description='The name of the namespace that you specify when you call the [CreateKvNamespace](https://help.aliyun.com/document_detail/2850317.html) operation.

This parameter is required.', example='ns1', position='Query'),
  title: string(name='Title', description='The new name of the namespace.

This parameter is required.', example='new_ns', position='Query'),
}

model UpdateKvNamespaceResponseBody = {
  description?: string(name='Description', description='The description of the namespace.', example='this is a test ns.'),
  namespace?: string(name='Namespace', description='The updated name of the namespace.', example='new_ns1'),
  namespaceId?: string(name='NamespaceId', description='The ID of the namespace.', example='643355322374688768'),
  requestId?: string(name='RequestId', description='The request ID.', example='0AEDAF20-4DDF-4165-8750-47FF9C1929C9'),
  status?: string(name='Status', description='The status of the namespace. Valid values:

*   **online**: normal.
*   **delete**: pending deletion.
*   **deleting**: being deleted.
*   **deleted**: deleted.', example='online'),
}

model UpdateKvNamespaceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateKvNamespaceResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateKvNamespace  UpdateKvNamespaceRequest
  * @return UpdateKvNamespaceResponse
 */
async function updateKvNamespace(request: UpdateKvNamespaceRequest): UpdateKvNamespaceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateKvNamespace', 'POST', '/', 'json', false, 'json', request);
}

model UpdateListRequest {
  description?: string(name='Description', description='The new description of the list.', example='a custom list', position='Body'),
  id: long(name='Id', description='The ID of the custom list, which can be obtained by calling the [ListLists](https://help.aliyun.com/document_detail/2850217.html) operation.

This parameter is required.', example='40000001', position='Body'),
  items?: [ string ](name='Items', description='The items in the updated list. The value is a JSON array.', example='a custom list', shrink='json', position='Body'),
  name?: string(name='Name', description='The new name of the list.', example='example', position='Body'),
}

model UpdateListResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='36af3fcc-43d0-441c-86b1-428951dc8225'),
}

model UpdateListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateListResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateList  UpdateListRequest
  * @return UpdateListResponse
 */
async function updateList(request: UpdateListRequest): UpdateListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateList', 'POST', '/', 'json', true, 'form', request);
}

model UpdateOriginProtectionRequest {
  originConverge: string(name='OriginConverge', description='The IP convergence status.

*   on
*   off

This parameter is required.', example='on', position='Query'),
  siteId: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.

This parameter is required.', example='123456****', position='Query'),
}

model UpdateOriginProtectionResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='4C6B5E5A-42FC-5DF2-986C-4DAAE3C55086'),
}

model UpdateOriginProtectionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateOriginProtectionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateOriginProtection  UpdateOriginProtectionRequest
  * @return UpdateOriginProtectionResponse
 */
async function updateOriginProtection(request: UpdateOriginProtectionRequest): UpdateOriginProtectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateOriginProtection', 'POST', '/', 'json', false, 'json', request);
}

model UpdateOriginProtectionIpWhiteListRequest {
  siteId: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.

This parameter is required.', example='123456****', position='Query'),
}

model UpdateOriginProtectionIpWhiteListResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='CB1A380B-09F0-41BB-A198-72F8FD6DA2FE'),
}

model UpdateOriginProtectionIpWhiteListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateOriginProtectionIpWhiteListResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateOriginProtectionIpWhiteList  UpdateOriginProtectionIpWhiteListRequest
  * @return UpdateOriginProtectionIpWhiteListResponse
 */
async function updateOriginProtectionIpWhiteList(request: UpdateOriginProtectionIpWhiteListRequest): UpdateOriginProtectionIpWhiteListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateOriginProtectionIpWhiteList', 'POST', '/', 'json', false, 'json', request);
}

model UpdatePageRequest {
  content: string(name='Content', description='The Base64-encoded content of the error page. The content type is specified by the Content-Type field.

This parameter is required.', example='PGh0bWw+aGVsbG8gcGFnZTwvaHRtbD4=', position='Body'),
  contentType: string(name='ContentType', description='The Content-Type field in the HTTP header. Valid values:

*   text/html
*   application/json

This parameter is required.', example='text/html', position='Body'),
  description?: string(name='Description', description='The description of the custom error page.', example='a custom deny page', position='Body'),
  id: long(name='Id', description='The ID of the custom error page, which can be obtained by calling the [ListPages](https://help.aliyun.com/document_detail/2850223.html) operation.

This parameter is required.', example='50000001', position='Body'),
  name: string(name='Name', description='The name of the custom error page.

This parameter is required.', example='example', position='Body'),
}

model UpdatePageResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='36af3fcc-43d0-441c-86b1-428951dc8225'),
}

model UpdatePageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdatePageResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdatePage  UpdatePageRequest
  * @return UpdatePageResponse
 */
async function updatePage(request: UpdatePageRequest): UpdatePageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdatePage', 'POST', '/', 'json', true, 'form', request);
}

model UpdateRecordRequest {
  authConf?: {
    accessKey?: string(name='AccessKey', description='The access key of the account to which the origin server belongs. This parameter is required when the SourceType is OSS, and AuthType is private_same_account, or when the SourceType is S3 and AuthType is private.', example='VIxuvJSA2S03f******kp208dy5w7'),
    authType?: string(name='AuthType', description='The authentication type of the origin server. Different origins support different authentication types. The type of origin refers to the SourceType parameter in this operation. If the type of origin is OSS or S3, you must specify the authentication type of the origin. Valid values:

*   **public**: public read. Select this value when the origin type is OSS or S3 and the origin access is public read.
*   **private**: private read. Select this value when the origin type is S3 and the origin access is private read.
*   **private_same_account**: private read under the same account. Select this value when the origin type is OSS, the origins belong to the same Alibaba Cloud account, and the origins have private read access.', example='private'),
    region?: string(name='Region', description='The version of the signature algorithm. This parameter is required when the origin type is S3 and AuthType is private. The following two types are supported:

*   **v2**
*   **v4**

If you leave this parameter empty, the default value v4 is used.', example='v2'),
    secretKey?: string(name='SecretKey', description='The secret access key of the account to which the origin server belongs. This parameter is required when the SourceType is OSS, and AuthType is private_same_account, or when the SourceType is S3 and AuthType is private.', example='u0Nkg5gBK*******QF5wvKMM504JUHt'),
    version?: string(name='Version', description='The region of the origin. If the origin type is S3, you must specify this value. You can get the region information from the official website of S3.', example='us-east-1'),
  }(name='AuthConf', description='The origin authentication information of the CNAME record.', shrink='json', position='Query'),
  bizName?: string(name='BizName', description='The business scenario of the record for acceleration. Leave the parameter empty if your record is not proxied. Valid values:

*   **video_image**: video and image.
*   **api**: API.
*   **web**: web page.', example='web', position='Query'),
  comment?: string(name='Comment', description='The comments of the record.', example='This is a remark.', position='Query'),
  data: {
    algorithm?: int32(name='Algorithm', description='The encryption algorithm used for the record, specified within the range from 0 to 255. This parameter is required when you add CERT or SSHFP records.', example='0'),
    certificate?: string(name='Certificate', description='The public key of the certificate. This parameter is required when you add CERT, SMIMEA, or TLSA records.', example='dGVzdGFkYWxrcw=='),
    fingerprint?: string(name='Fingerprint', description='The public key fingerprint of the record. This parameter is required when you add a SSHFP record.', example='abcdef1234567890'),
    flag?: int32(name='Flag', description='The flag bit of the record. The Flag for a CAA record indicates its priority and how it is processed, specified within the range of 0 to 255. This parameter is required when you add a CAA record.', example='128'),
    keyTag?: int32(name='KeyTag', description='The public key identification for the record, specified within the range of 0 to 65,535. This parameter is required when you add a CAA record.', example='0'),
    matchingType?: int32(name='MatchingType', description='The algorithm policy used to match or validate the certificate, specified within the range 0 to 255. This parameter is required when you add SMIMEA or TLSA records.', example='0'),
    port?: int32(name='Port', description='The port of the record, specified within the range of 0 to 65,535. This parameter is required when you add an SRV record.', example='0'),
    priority?: int32(name='Priority', description='The priority of the record, specified within the range of 0 to 65,535. A smaller value indicates a higher priority. This parameter is required when you add MX, SRV, and URI records.', example='10'),
    selector?: int32(name='Selector', description='The type of certificate or public key, specified within the range of 0 to 255. This parameter is required when you add SMIMEA or TLSA records.', example='0'),
    tag?: string(name='Tag', description='The label of the record. The Tag of a CAA record indicate its specific type and usage. This parameter is required when you add a CAA record.', example='issue'),
    type?: int32(name='Type', description='The certificate type of the record (in CERT records), or the public key type (in SSHFP records). This parameter is required when you add CERT or SSHFP records.', example='0'),
    usage?: int32(name='Usage', description='The usage identifier of the record, specified within the range of 0 to 255. This parameter is required when you add SMIMEA or TLSA records.', example='0'),
    value?: string(name='Value', description='The record value or part of the record content. This parameter is required when you add A/AAAA, CNAME, NS, MX, TXT, CAA, SRV, and URI records. It has different meanings based on different types of records:

*   **A/AAAA**: the IP address(es). Separate multiple IPs with commas (,). You must have at least one IPv4 address.
*   **CNAME**: the target domain name.
*   **NS**: the name servers for the domain name.
*   **MX**: a valid domain name of the target mail server.
*   **TXT**: a valid text string.
*   **CAA**: a valid domain name of the certificate authority.
*   **SRV**: a valid domain name of the target host.
*   **URI**: a valid URI string.', example='example.com'),
    weight?: int32(name='Weight', description='The weight of the record, specified within the range of 0 to 65,535. This parameter is required when you add SRV or URI records.', example='0'),
  }(name='Data', description='The DNS record information. The format of this field varies based on the record type. For more information, see [Add DNS records](https://www.alibabacloud.com/help/doc-detail/2708761.html).

This parameter is required.', example='{
    "value":"2.2.2.2"
}', shrink='json', position='Query'),
  hostPolicy?: string(name='HostPolicy', description='The origin host policy. This policy takes effect when the record type is CNAME. You can set the policy in two modes:

*   **follow_hostname**: match the requested domain name.
*   **follow_origin_domain**: match the origin\\"s domain name.', example='follow_origin_domain', position='Query'),
  proxied?: boolean(name='Proxied', description='Specifies whether to proxy the record. Only CNAME and A/AAAA records can be proxied. Valid values:

*   **true**
*   **false**', example='true', position='Query'),
  recordId: long(name='RecordId', description='The record ID, which can be obtained by calling [ListRecords](https://help.aliyun.com/document_detail/2850265.html).

This parameter is required.', example='1234567890123', position='Query'),
  sourceType?: string(name='SourceType', description='The type of the origin for the CNAME record. This parameter is required when you add a CNAME record. Valid values:

*   **OSS** : OSS origin.
*   **S3** : S3 origin.
*   **LB**: Load Balancer origin.
*   **OP**: origin in an origin pool.
*   **Domain**: common domain name.

If you leave the parameter empty or set its value as null, the default is Domain, which is common domain name.', example='OSS', position='Query'),
  ttl?: int32(name='Ttl', description='The TTL of the record. Unit: seconds. The range is 30 to 86,400, or 1. If the value is 1, the TTL of the record is determined by the system.', example='30', position='Query'),
}

model UpdateRecordResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0AEDAF20-4DDF-4165-8750-47FF9C1929C9'),
}

model UpdateRecordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateRecordResponseBody(name='body'),
}

/**
  * @description This operation allows you to update multiple types of DNS records, including but not limited to A/AAAA, CNAME, NS, MX, TXT, CAA, SRV, and URI. You can modify the record content by providing the necessary fields such as Value, Priority, and Flag. For origins added in CNAME records such as OSS and S3, the API enables you to configure authentication details to ensure secure access.
  * ### [](#)Usage notes
  * *   The record value (Value) must match the record type. For example, the CNAME record should correspond to the target domain name.
  * *   You must specify a priority (Priority) for some record types, such as MX and SRV.
  * *   You must specify specific fields such as Flag and Tag for CAA records.
  * *   When you update security records such as CERT and SSHFP, you must accurately set fields such as Type and Algorithm.
  * *   If your origin type is OSS or S3, configure the authentication details in AuthConf based on the permissions.
  * @param request  the request parameters of UpdateRecord  UpdateRecordRequest
  * @return UpdateRecordResponse
 */
async function updateRecord(request: UpdateRecordRequest): UpdateRecordResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateRecord', 'POST', '/', 'json', false, 'json', request);
}

model UpdateScheduledPreloadExecutionRequest {
  endTime?: string(name='EndTime', description='The end time of the prefetch plan.', example='2024-05-31T18:10:48.849+08:00', position='Body'),
  id: string(name='Id', description='The ID of the prefetch plan.

This parameter is required.', example='UpdateScheduledPreloadExecution', position='Query'),
  interval?: int32(name='Interval', description='The time interval between each batch execution. Unit: seconds.', example='60', position='Body'),
  sliceLen?: int32(name='SliceLen', description='The number of URLs prefetched in each batch.', example='10', position='Body'),
  startTime?: string(name='StartTime', description='The start time of the prefetch plan.', example='2024-05-31T17:10:48.849+08:00', position='Body'),
}

model UpdateScheduledPreloadExecutionResponseBody = {
  aliUid?: string(name='AliUid', description='The ID of the Alibaba Cloud account.', example='15685865xxx14622'),
  endTime?: string(name='EndTime', description='The end time of the prefetch plan.', example='2024-05-31T18:10:48.849+08:00'),
  id?: string(name='Id', description='The ID of the prefetch plan.', example='66599bd7397885b43804901c'),
  interval?: int32(name='Interval', description='The time interval between each batch execution. Unit: seconds.', example='60'),
  jobId?: string(name='JobId', description='The ID of the prefetch task.', example='665d3af3621bccf3fe29e1a4'),
  requestId?: string(name='RequestId', description='The request ID.', example='15C66C7B-671A-4297-9187-2C4477247A123425345'),
  sliceLen?: int32(name='SliceLen', description='The number of URLs prefetched in each batch.', example='10'),
  startTime?: string(name='StartTime', description='The start time of the prefetch plan.', example='2024-05-31T17:10:48.849+08:00'),
  status?: string(name='Status', description='The status of the prefetch plan. Valid values:

*   **waiting**
*   **running**
*   **finished**
*   **failed**
*   **stopped**', example='running'),
}

model UpdateScheduledPreloadExecutionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateScheduledPreloadExecutionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateScheduledPreloadExecution  UpdateScheduledPreloadExecutionRequest
  * @return UpdateScheduledPreloadExecutionResponse
 */
async function updateScheduledPreloadExecution(request: UpdateScheduledPreloadExecutionRequest): UpdateScheduledPreloadExecutionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateScheduledPreloadExecution', 'POST', '/', 'json', true, 'form', request);
}

model UpdateSiteAccessTypeRequest {
  accessType: string(name='AccessType', description='The new DNS setup of the website. Valid values:

*   **NS**
*   **CNAME**

This parameter is required.', example='NS', position='Query'),
  siteId: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.

This parameter is required.', example='1234567890', position='Query'),
}

model UpdateSiteAccessTypeResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='15C66C7B-671A-4297-9187-2C4477247A74'),
}

model UpdateSiteAccessTypeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateSiteAccessTypeResponseBody(name='body'),
}

/**
  * @description When you change the DNS setup of a website from NS to CNAME, take note of the following items:
  * *   Make sure that the website has only proxied A/AAAA and CNAME records.
  * *   Make sure that ESA proxy is not disabled for the website and custom nameservers are not configured.
  * @param request  the request parameters of UpdateSiteAccessType  UpdateSiteAccessTypeRequest
  * @return UpdateSiteAccessTypeResponse
 */
async function updateSiteAccessType(request: UpdateSiteAccessTypeRequest): UpdateSiteAccessTypeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateSiteAccessType', 'POST', '/', 'json', false, 'json', request);
}

model UpdateSiteCoverageRequest {
  coverage: string(name='Coverage', description='The desired service location. Valid values:

*   **domestic**: the Chinese mainland
*   **global**: global
*   **overseas**: outside the Chinese mainland

This parameter is required.', example='global', position='Query'),
  siteId: long(name='SiteId', description='The website ID. You can call the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation to obtain the ID.

This parameter is required.', example='1234567890123', position='Query'),
}

model UpdateSiteCoverageResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='65C66B7B-671A-8297-9187-2R5477247B76'),
}

model UpdateSiteCoverageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateSiteCoverageResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateSiteCoverage  UpdateSiteCoverageRequest
  * @return UpdateSiteCoverageResponse
 */
async function updateSiteCoverage(request: UpdateSiteCoverageRequest): UpdateSiteCoverageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateSiteCoverage', 'POST', '/', 'json', false, 'json', request);
}

model UpdateSiteCustomLogRequest {
  cookies?: [ string ](name='Cookies', description='The cookie fields.', shrink='json', position='Body'),
  requestHeaders?: [ string ](name='RequestHeaders', description='The request header fields.', shrink='json', position='Body'),
  responseHeaders?: [ string ](name='ResponseHeaders', description='The response header fields.', shrink='json', position='Body'),
  siteId?: long(name='SiteId', description='site id', example='11223****', position='Body'),
}

model UpdateSiteCustomLogResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='ET5BF670-09D5-4D0B-BEBY-D96A2A528000'),
}

model UpdateSiteCustomLogResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateSiteCustomLogResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateSiteCustomLog  UpdateSiteCustomLogRequest
  * @return UpdateSiteCustomLogResponse
 */
async function updateSiteCustomLog(request: UpdateSiteCustomLogRequest): UpdateSiteCustomLogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateSiteCustomLog', 'POST', '/', 'json', true, 'form', request);
}

model UpdateSiteDeliveryTaskRequest {
  businessType?: string(name='BusinessType', description='The log category. Valid values:

*   dcdn_log_access_l1 (default): access logs.
*   dcdn_log_er: Edge Routine logs.
*   dcdn_log_waf: firewall logs.
*   dcdn_log_ipa: TCP/UDP proxy logs.', example='dcdn_log_er', position='Body'),
  discardRate?: float(name='DiscardRate', description='The discard rate.', example='0.0', position='Body'),
  fieldName: string(name='FieldName', description='The log fields that you want to include in real-time logs to be delivered. Separate the log fields with commas (,).

This parameter is required.', example='ClientIP,UserAgent', position='Body'),
  siteId?: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.', example='123456****', position='Body'),
  taskName: string(name='TaskName', description='The name of the delivery task.

This parameter is required.', example='cdn-test-task', position='Body'),
}

model UpdateSiteDeliveryTaskResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='34DCBC8A-****-****-****-6DAA11D7DDBD'),
}

model UpdateSiteDeliveryTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateSiteDeliveryTaskResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateSiteDeliveryTask  UpdateSiteDeliveryTaskRequest
  * @return UpdateSiteDeliveryTaskResponse
 */
async function updateSiteDeliveryTask(request: UpdateSiteDeliveryTaskRequest): UpdateSiteDeliveryTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateSiteDeliveryTask', 'POST', '/', 'json', true, 'form', request);
}

model UpdateSiteDeliveryTaskStatusRequest {
  method: string(name='Method', description='Specifies whether to enable the delivery task.

This parameter is required.', example='online', position='Query'),
  siteId?: long(name='SiteId', description='The website ID.', example='123456****', position='Query'),
  taskName: string(name='TaskName', description='The name of the delivery task.

This parameter is required.', example='cdn-test-task', position='Query'),
}

model UpdateSiteDeliveryTaskStatusResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='34DCBC8A-****-****-****-6DAA11D7DDBD'),
  status?: string(name='Status', description='The status of the delivery task. Valid values:

*   **online**
*   **offline**', example='online'),
  taskName?: string(name='TaskName', description='The name of the delivery task.', example='cdn-test-task'),
}

model UpdateSiteDeliveryTaskStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateSiteDeliveryTaskStatusResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateSiteDeliveryTaskStatus  UpdateSiteDeliveryTaskStatusRequest
  * @return UpdateSiteDeliveryTaskStatusResponse
 */
async function updateSiteDeliveryTaskStatus(request: UpdateSiteDeliveryTaskStatusRequest): UpdateSiteDeliveryTaskStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateSiteDeliveryTaskStatus', 'GET', '/', 'json', false, 'json', request);
}

model UpdateSiteVanityNSRequest {
  siteId: long(name='SiteId', description='The website ID. You can call the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation to obtain the ID.

This parameter is required.', example='1234567890123', position='Query'),
  vanityNSList?: string(name='VanityNSList', description='The custom nameserver names. You can specify two to five custom nameserver names. Separate multiple names with commas (,).', example='ns1.example.com,ns2.example.com', position='Query'),
}

model UpdateSiteVanityNSResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='0AEDAF20-4DDF-4165-8750-47FF9C1929C9'),
}

model UpdateSiteVanityNSResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateSiteVanityNSResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateSiteVanityNS  UpdateSiteVanityNSRequest
  * @return UpdateSiteVanityNSResponse
 */
async function updateSiteVanityNS(request: UpdateSiteVanityNSRequest): UpdateSiteVanityNSResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateSiteVanityNS', 'POST', '/', 'json', false, 'json', request);
}

model UpdateUserDeliveryTaskRequest {
  businessType?: string(name='BusinessType', description='The log category. Valid values:

*   dcdn_log_access_l1 (default): access logs.
*   dcdn_log_er: Edge Routine logs.
*   dcdn_log_waf: firewall logs.
*   dcdn_log_ipa: TCP/UDP proxy logs.', example='dcdn_log_er', position='Body'),
  discardRate?: float(name='DiscardRate', description='The discard rate. Default value: 0.', example='0', position='Body'),
  fieldName: string(name='FieldName', description='The log fields that you want to include in logs to be delivered. Separate the log fields with commas (,).

This parameter is required.', example='ClientRequestID,ClientRequestHost', position='Body'),
  taskName: string(name='TaskName', description='The name of the delivery task.

This parameter is required.', example='test_project', position='Body'),
}

model UpdateUserDeliveryTaskResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='34DCBC8A-****-****-****-6DAA11D7DDBD'),
}

model UpdateUserDeliveryTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateUserDeliveryTaskResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateUserDeliveryTask  UpdateUserDeliveryTaskRequest
  * @return UpdateUserDeliveryTaskResponse
 */
async function updateUserDeliveryTask(request: UpdateUserDeliveryTaskRequest): UpdateUserDeliveryTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateUserDeliveryTask', 'POST', '/', 'json', true, 'form', request);
}

model UpdateUserDeliveryTaskStatusRequest {
  method: string(name='Method', description='Enables or disables the delivery task. Valid values: online and offline.

This parameter is required.', example='online', position='Query'),
  taskName: string(name='TaskName', description='The name of the delivery task.

This parameter is required.', example='test_project', position='Query'),
}

model UpdateUserDeliveryTaskStatusResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='34DCBC8A-****-****-****-6DAA11D7DDBD'),
  status?: string(name='Status', description='The status of the delivery task.', example='online'),
  taskName?: string(name='TaskName', description='The name of the delivery task.', example='test_project'),
}

model UpdateUserDeliveryTaskStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateUserDeliveryTaskStatusResponseBody(name='body'),
}

/**
  * @description ## [](#)
  * You can call this operation to enable or disable a delivery task by using TaskName and Method. The response includes the most recent status and operation result details of the task.
  * @param request  the request parameters of UpdateUserDeliveryTaskStatus  UpdateUserDeliveryTaskStatusRequest
  * @return UpdateUserDeliveryTaskStatusResponse
 */
async function updateUserDeliveryTaskStatus(request: UpdateUserDeliveryTaskStatusRequest): UpdateUserDeliveryTaskStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateUserDeliveryTaskStatus', 'GET', '/', 'json', false, 'json', request);
}

model UpdateWafRuleRequest {
  config?: WafRuleConfig(name='Config', description='The configuration of the rule.', shrink='json', position='Body'),
  id: long(name='Id', description='The ID of the WAF rule, which can be obtained by calling the [ListWafRules](https://help.aliyun.com/document_detail/2850237.html) operation.

This parameter is required.', example='20000001', position='Body'),
  position?: long(name='Position', description='The order of the rule in the ruleset.', example='1', position='Body'),
  siteId: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.

This parameter is required.', example='1', position='Query'),
  siteVersion?: int32(name='SiteVersion', description='The version of the website.', example='0', position='Query'),
  status?: string(name='Status', description='The status of the rule.', example='on', position='Body'),
}

model UpdateWafRuleResponseBody = {
  id?: long(name='Id', description='The ID of the WAF rule.[](~~2850237~~)', example='20000001'),
  requestId?: string(name='RequestId', description='The request ID.', example='36af3fcc-43d0-441c-86b1-428951dc8225'),
}

model UpdateWafRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateWafRuleResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateWafRule  UpdateWafRuleRequest
  * @return UpdateWafRuleResponse
 */
async function updateWafRule(request: UpdateWafRuleRequest): UpdateWafRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateWafRule', 'POST', '/', 'json', true, 'form', request);
}

model UpdateWafRulesetRequest {
  id: long(name='Id', description='The ID of the WAF ruleset, which can be obtained by calling the [ListWafRulesets](https://help.aliyun.com/document_detail/2850233.html) operation.

This parameter is required.', example='10000001', position='Body'),
  siteId?: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.', example='1', position='Query'),
  siteVersion?: int32(name='SiteVersion', description='The version of the website.', example='1', position='Query'),
  status?: string(name='Status', description='The status to which you want to change the ruleset.', example='on', position='Body'),
}

model UpdateWafRulesetResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='36af3fcc-43d0-441c-86b1-428951dc8225'),
}

model UpdateWafRulesetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateWafRulesetResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateWafRuleset  UpdateWafRulesetRequest
  * @return UpdateWafRulesetResponse
 */
async function updateWafRuleset(request: UpdateWafRulesetRequest): UpdateWafRulesetResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateWafRuleset', 'POST', '/', 'json', true, 'form', request);
}

model UpdateWaitingRoomRequest {
  cookieName?: string(name='CookieName', description='The name of the custom cookie.', example='__aliwaitingroom_example', position='Query'),
  customPageHtml?: string(name='CustomPageHtml', description='The content of the custom waiting room page. You must specify this parameter if you set WaitingRoomType to custom. The content must be Base64-encoded.', example='Hello%20world!', position='Query'),
  description?: string(name='Description', description='The description of the waiting room.', position='Query'),
  disableSessionRenewalEnable?: string(name='DisableSessionRenewalEnable', description='Specifies whether to disable session renewal. Valid values:

*   on
*   off', example='on', position='Query'),
  enable?: string(name='Enable', description='Specifies whether to enable the waiting room. Valid values:

*   on
*   off', example='on', position='Query'),
  hostNameAndPath?: [ 
    {
      domain?: string(name='Domain', description='The domain name.', example='example.com'),
      path?: string(name='Path', description='The probe path.', example='/test'),
      subdomain?: string(name='Subdomain', description='The subdomain.', example='test.'),
    }
  ](name='HostNameAndPath', description='The hostname and path.', shrink='json', position='Query'),
  jsonResponseEnable?: string(name='JsonResponseEnable', description='Specifies whether to enable JSON response. If JSON response is enabled, a JSON body is returned for requests to the waiting room with the header Accept: application/json. Valid values:

*   on
*   off', example='on', position='Query'),
  language?: string(name='Language', description='The language of the waiting room page. You must specify this parameter if you set WaitingRoomType to default. Valid values:

*   enus: English.
*   zhcn: Simplified Chinese.
*   zhhk: Traditional Chinese.', example='zhcn', position='Query'),
  name?: string(name='Name', description='The name of the waiting room.', position='Query'),
  newUsersPerMinute?: string(name='NewUsersPerMinute', description='The maximum number of new users per minute.', example='200', position='Query'),
  queueAllEnable?: string(name='QueueAllEnable', description='Specifies whether to queue all requests. Valid values:

*   on
*   off', example='on', position='Query'),
  queuingMethod?: string(name='QueuingMethod', description='The queuing method. Valid values:

*   random: Users gain access to the origin randomly, regardless of the arrival time.
*   fifo: Users gain access to the origin in order of arrival.
*   passthrough: Users pass through the waiting room and go straight to the origin.
*   reject-all: Users are blocked from reaching the origin.', example='random', position='Query'),
  queuingStatusCode?: string(name='QueuingStatusCode', description='The HTTP status code to return while a user is in the queue. Valid values:

*   200
*   202
*   429', example='200', position='Query'),
  sessionDuration?: string(name='SessionDuration', description='The maximum duration for which a session remains valid after a user leaves the origin. Unit: minutes.', example='5', position='Query'),
  siteId: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.

This parameter is required.', example='7096621098****', position='Query'),
  totalActiveUsers?: string(name='TotalActiveUsers', description='The maximum number of active users.', example='300', position='Query'),
  waitingRoomId: string(name='WaitingRoomId', description='The ID of the waiting room, which can be obtained by calling the [ListWaitingRooms](https://help.aliyun.com/document_detail/2850279.html) operation.

This parameter is required.', example='6a51d5bc6460887abd129****', position='Query'),
  waitingRoomType?: string(name='WaitingRoomType', description='The type of the waiting room. Valid values:

*   default
*   custom', example='default', position='Query'),
}

model UpdateWaitingRoomResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='0195619f-eab3-4a66-ac00-ed53d913e72e'),
}

model UpdateWaitingRoomResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateWaitingRoomResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateWaitingRoom  UpdateWaitingRoomRequest
  * @return UpdateWaitingRoomResponse
 */
async function updateWaitingRoom(request: UpdateWaitingRoomRequest): UpdateWaitingRoomResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateWaitingRoom', 'POST', '/', 'json', false, 'json', request);
}

model UpdateWaitingRoomEventRequest {
  customPageHtml?: string(name='CustomPageHtml', description='The content of the custom waiting room page. You must specify this parameter if you set WaitingRoomType to custom. The content must be Base64-encoded.', example='html-yets-maqi1111', position='Query'),
  description?: string(name='Description', description='The description of the waiting room.', example='http://yywyyw.com', position='Query'),
  disableSessionRenewalEnable?: string(name='DisableSessionRenewalEnable', description='Specifies whether to disable session renewal. Valid values:

*   on
*   off', example='off', position='Query'),
  enable?: string(name='Enable', description='Specifies whether to enable the waiting room event. Valid values:

*   `on`
*   `off`', example='on', position='Query'),
  endTime?: string(name='EndTime', description='The end time of the event. This value is a UNIX timestamp.', example='1719849600', position='Query'),
  jsonResponseEnable?: string(name='JsonResponseEnable', description='Specifies whether to enable JSON response. Valid values:

*   on
*   off', example='off', position='Query'),
  language?: string(name='Language', description='The default language. Valid values:

*   `enus`: English.
*   `zhcn`: Simplified Chinese.
*   `zhhk`: Traditional Chinese.', example='enus', position='Query'),
  name?: string(name='Name', description='The name of the waiting room event.', position='Query'),
  newUsersPerMinute?: string(name='NewUsersPerMinute', description='The maximum number of new users per minute.', example='300', position='Query'),
  preQueueEnable?: string(name='PreQueueEnable', description='Specifies whether to enable pre-queuing.

*   on
*   off', example='on', position='Query'),
  preQueueStartTime?: string(name='PreQueueStartTime', description='The start time for pre-queuing.', example='1719763200', position='Query'),
  queuingMethod?: string(name='QueuingMethod', description='The queuing method. Valid values:

*   random: Users gain access to the origin randomly, regardless of the arrival time.
*   fifo: Users gain access to the origin in order of arrival.
*   passthrough: Users pass through the waiting room and go straight to the origin.
*   reject-all: All requests are blocked from accessing the origin.', example='fifo', position='Query'),
  queuingStatusCode?: string(name='QueuingStatusCode', description='The HTTP status code to return while a user is in the queue. Valid values:

*   200
*   202
*   429', example='200', position='Query'),
  randomPreQueueEnable?: string(name='RandomPreQueueEnable', description='Specifies whether to enable random queuing.

*   on
*   off', example='on', position='Query'),
  sessionDuration?: string(name='SessionDuration', description='The maximum duration for which a session remains valid after a user leaves the origin. Unit: minutes.', example='5', position='Query'),
  siteId: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.

This parameter is required.', example='123456****', position='Query'),
  startTime?: string(name='StartTime', description='The start time of the event. This value is a UNIX timestamp.', example='1719763200', position='Query'),
  totalActiveUsers?: string(name='TotalActiveUsers', description='The maximum number of active users.', example='200', position='Query'),
  waitingRoomEventId?: long(name='WaitingRoomEventId', description='The ID of the waiting room event, which can be obtained by calling the [ListWaitingRoomEvents](https://help.aliyun.com/document_detail/2850279.html) operation.', example='89677721098****', position='Query'),
  waitingRoomType?: string(name='WaitingRoomType', description='The type of the waiting room. Valid values:

*   default
*   custom', example='custom', position='Query'),
}

model UpdateWaitingRoomEventResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='0195619f-eab3-4a66-ac00-ed53d913e72e'),
}

model UpdateWaitingRoomEventResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateWaitingRoomEventResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateWaitingRoomEvent  UpdateWaitingRoomEventRequest
  * @return UpdateWaitingRoomEventResponse
 */
async function updateWaitingRoomEvent(request: UpdateWaitingRoomEventRequest): UpdateWaitingRoomEventResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateWaitingRoomEvent', 'POST', '/', 'json', false, 'json', request);
}

model UpdateWaitingRoomRuleRequest {
  rule: string(name='Rule', description='The rule content, which is a policy or conditional expression.

This parameter is required.', example='(http.request.uri.path.file_name eq \\"jpg\\")', position='Query'),
  ruleEnable: string(name='RuleEnable', description='Specifies whether to enable the rule. Valid values:

*   on
*   off

This parameter is required.', example='on', position='Query'),
  ruleName: string(name='RuleName', description='The rule name.

This parameter is required.', example='test1', position='Query'),
  siteId: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.

This parameter is required.', example='123456****', position='Query'),
  waitingRoomRuleId?: long(name='WaitingRoomRuleId', description='The ID of the waiting room bypass rule that you want to update. You can call [ListWaitingRoomRules](https://help.aliyun.com/document_detail/2850279.html) to obtain the ID.', example='8987739839****', position='Query'),
}

model UpdateWaitingRoomRuleResponseBody = {
  requestId?: string(name='RequestId', description='The request ID, which is used to trace a call.', example='9bfe9d95-7bf6-469d-a628-ed7bc9f25073'),
}

model UpdateWaitingRoomRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateWaitingRoomRuleResponseBody(name='body'),
}

/**
  * @description You can call this API operation to modify the configurations of a waiting room bypass rule for your website, including the rule name, status, and rule content.
  * @param request  the request parameters of UpdateWaitingRoomRule  UpdateWaitingRoomRuleRequest
  * @return UpdateWaitingRoomRuleResponse
 */
async function updateWaitingRoomRule(request: UpdateWaitingRoomRuleRequest): UpdateWaitingRoomRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateWaitingRoomRule', 'POST', '/', 'json', false, 'json', request);
}

model UploadClientCaCertificateRequest {
  certificate: string(name='Certificate', description='This parameter is required.', example='-----BEGIN CERTIFICATE-----', position='Body'),
  name?: string(name='Name', example='yourCertName', position='Body'),
  siteId: long(name='SiteId', description='This parameter is required.', example='1234567890123', position='Query'),
}

model UploadClientCaCertificateResponseBody = {
  commonName?: string(name='CommonName', example='www.example.com'),
  fingerprintSha256?: string(name='FingerprintSha256', example='1dc5fc9af4eead2570c70d94b416130baeb6d4429b51fd3557379588456aca66'),
  id?: string(name='Id', example='baba39055622c008b90285a8838ed09a'),
  issuer?: string(name='Issuer', example='GlobalSign nv-sa'),
  notAfter?: string(name='NotAfter', example='2024-12-01T02:13:07Z'),
  notBefore?: string(name='NotBefore', example='2023-12-01T02:13:07Z'),
  requestId?: string(name='RequestId', example='0AEDAF20-4DDF-4165-8750-47FF9C1929C9'),
  serialNumber?: string(name='SerialNumber', example='babab9db65ee5efcca9f3d41d4b50d66'),
  signatureAlgorithm?: string(name='SignatureAlgorithm', example='SHA256-RSA'),
  status?: string(name='Status', example='OK'),
  validityDays?: string(name='ValidityDays', example='300'),
}

model UploadClientCaCertificateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UploadClientCaCertificateResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UploadClientCaCertificate  UploadClientCaCertificateRequest
  * @return UploadClientCaCertificateResponse
 */
async function uploadClientCaCertificate(request: UploadClientCaCertificateRequest): UploadClientCaCertificateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UploadClientCaCertificate', 'POST', '/', 'json', true, 'form', request);
}

model VerifySiteRequest {
  siteId: long(name='SiteId', description='The website ID, which can be obtained by calling the [ListSites](https://help.aliyun.com/document_detail/2850189.html) operation.

This parameter is required.', example='1234567890123', position='Query'),
}

model VerifySiteResponseBody = {
  passed?: boolean(name='Passed', description='Indicates whether the verification passed. Valid values:

*   **true**
*   **false**', example='true'),
  requestId?: string(name='RequestId', description='The request ID.', example='65C66B7B-671A-8297-9187-2R5477247B76'),
}

model VerifySiteResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: VerifySiteResponseBody(name='body'),
}

/**
  * @description 1.  For a website connected by using NS setup, this operation verifies whether the nameservers of the website are the nameservers assigned by Alibaba Cloud.
  * 2.  For a website connected by using CNAME setup, this operation verifies whether the website has a TXT record whose hostname is  _esaauth.[websiteDomainName] and record value is the value of VerifyCode to the DNS records of your domain. You can see the VerifyCode field in the site information.
  * @param request  the request parameters of VerifySite  VerifySiteRequest
  * @return VerifySiteResponse
 */
async function verifySite(request: VerifySiteRequest): VerifySiteResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'VerifySite', 'POST', '/', 'json', false, 'json', request);
}

model HttpDeliveryHeaderParamValue = {
  staticValue?: string(name='StaticValue', description='The static variable.', example='alicdn'),
}

model HttpDeliveryQueryParamValue = {
  staticValue?: string(name='StaticValue', description='The static variable.', example='alicdn'),
}

model FieldContentValue = {
  sortOrder?: long(name='SortOrder', description='The sequence number of the fields.', example='1'),
  fieldList?: [ 
    {
      fieldName?: string(name='FieldName', description='The field name.', example='ClientIp'),
      description?: string(name='Description', description='The description of the field in English.', example='IP address of the client.'),
      descriptionCn?: string(name='DescriptionCn', description='The description of the field in Chinese.'),
      category?: string(name='Category', description='The category of the field.', example='Client'),
      dataType?: string(name='DataType', description='The data type of the field.', example='String'),
      sortOrder?: long(name='SortOrder', description='The sequence number of the field.', example='1'),
      isDefault?: boolean(name='IsDefault', description='Indicates whether the field is available by default.', example='true'),
    }
  ](name='FieldList', description='The fields.'),
}

model QuotaListItemsValue = {
  enable?: boolean(name='Enable', description='Indicates whether the item type is configured in the custom list.'),
  value?: WafQuotaString(name='Value', description='The format restrictions for the item type in the custom list.'),
}

model QuotaPageContentTypesValue = {
  enable?: boolean(name='Enable', description='Indicates whether the custom error pages of the Content-Type are configured.'),
  contentLength?: WafQuotaInteger(name='ContentLength', description='The maximum length of the custom error pages of the Content-Type.'),
}

