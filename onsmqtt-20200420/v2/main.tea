/**
 *
 */
import OpenApi;
import OpenApi.OpenApiUtil;

extends OpenApi;


init(config: OpenApiUtil.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('onsmqtt', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!$isNull(endpoint)) {
    return endpoint;
  }
  
  if (!$isNull(endpointMap) && !$isNull(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return OpenApiUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model ActiveCaCertificateRequest {
  mqttInstanceId?: string(name='MqttInstanceId', description='The ID of the ApsaraMQ for MQTT instance to which the CA certificate is bound.

This parameter is required.', example='post-cn-7mz2d******'),
  sn?: string(name='Sn', description='The serial number of the CA certificate that you want to reactivate. The serial number is the unique identifier of a CA certificate.

The serial number of a CA certificate cannot exceed 128 bytes in size.

This parameter is required.', example='007269004887******'),
}

model ActiveCaCertificateResponseBody = {
  requestId?: string(name='RequestId', description='Public parameters, each request ID is unique and can be used for troubleshooting and problem localization.', example='020F6A43-19E6-4B6E-B846-44EB31DF****'),
  sn?: string(name='Sn', description='The SN serial number of the activated CA certificate, used to uniquely identify a CA certificate.', example='007269004887******'),
}

model ActiveCaCertificateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ActiveCaCertificateResponseBody(name='body'),
}

/**
 * @summary Activate CA Certificate
 *
 * @description *   Only ApsaraMQ for MQTT Enterprise Platinum Edition instances support this operation.
 * *   You can call this operation up to 500 times per second per Alibaba Cloud account. If you want to increase the limit, join the DingTalk group (ID: 35228338) to contact ApsaraMQ for MQTT technical support.
 * *   You can call this operation to reactivate only CA certificates that are registered with ApsaraMQ for MQTT brokers. You can call the [ListCaCertificate](https://help.aliyun.com/document_detail/2604958.html) operation to query CA certificates that are registered with an ApsaraMQ for MQTT instance.
 *
 * @param request ActiveCaCertificateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ActiveCaCertificateResponse
 */
async function activeCaCertificateWithOptions(request: ActiveCaCertificateRequest, runtime: $RuntimeOptions): ActiveCaCertificateResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.mqttInstanceId)) {
    query['MqttInstanceId'] = request.mqttInstanceId;
  }
  if (!$isNull(request.sn)) {
    query['Sn'] = request.sn;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ActiveCaCertificate',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Activate CA Certificate
 *
 * @description *   Only ApsaraMQ for MQTT Enterprise Platinum Edition instances support this operation.
 * *   You can call this operation up to 500 times per second per Alibaba Cloud account. If you want to increase the limit, join the DingTalk group (ID: 35228338) to contact ApsaraMQ for MQTT technical support.
 * *   You can call this operation to reactivate only CA certificates that are registered with ApsaraMQ for MQTT brokers. You can call the [ListCaCertificate](https://help.aliyun.com/document_detail/2604958.html) operation to query CA certificates that are registered with an ApsaraMQ for MQTT instance.
 *
 * @param request ActiveCaCertificateRequest
 * @return ActiveCaCertificateResponse
 */
async function activeCaCertificate(request: ActiveCaCertificateRequest): ActiveCaCertificateResponse {
  var runtime = new $RuntimeOptions{};
  return activeCaCertificateWithOptions(request, runtime);
}

model ActiveDeviceCertificateRequest {
  caSn?: string(name='CaSn', description='The serial number of the CA certificate to which the device certificate belongs. The serial number is the unique identifier of a CA certificate.

The serial number of a CA certificate cannot exceed 128 bytes in size.

This parameter is required.', example='007269004887******'),
  deviceSn?: string(name='DeviceSn', description='The serial number of the device certificate that you want to reactivate. The serial number is the unique identifier of a device.

This parameter is required.', example='356217374433******'),
  mqttInstanceId?: string(name='MqttInstanceId', description='The ID of the ApsaraMQ for MQTT instance to which the device certificate is bound.

This parameter is required.', example='post-cn-7mz2d******'),
}

model ActiveDeviceCertificateResponseBody = {
  deviceSn?: string(name='DeviceSn', description='The serial number of the device certificate that you reactivated. The serial number is the unique identifier of a device certificate.', example='356217374433******'),
  requestId?: string(name='RequestId', description='The request ID.', example='020F6A43-19E6-4B6E-B846-44EB31DF****'),
}

model ActiveDeviceCertificateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ActiveDeviceCertificateResponseBody(name='body'),
}

/**
 * @summary Reactivates a device certificate. Device certificates are digital certificates issued to clients by certificate authority (CA) root certificates. When you connect an ApsaraMQ for MQTT client to an ApsaraMQ for MQTT broker, the broker uses the device certificate to authenticate the client based on the registered CA certificate. If the CA certificate matches the device certificate, the client passes the authentication and the system automatically registers the device certificate with the ApsaraMQ for MQTT broker. After a device certificate is registered with an ApsaraMQ for MQTT broker, the certificate is automatically activated. If your device certificate is changed to the inactivated state, you can call this operation to reactivate the device certificate.
 *
 * @description *   Only ApsaraMQ for MQTT Enterprise Platinum Edition instances support this operation.
 * *   You can call this operation up to 500 times per second per Alibaba Cloud account. If you want to increase the limit, join the DingTalk group (ID: 35228338) to contact ApsaraMQ for MQTT technical support.
 *
 * @param request ActiveDeviceCertificateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ActiveDeviceCertificateResponse
 */
async function activeDeviceCertificateWithOptions(request: ActiveDeviceCertificateRequest, runtime: $RuntimeOptions): ActiveDeviceCertificateResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.caSn)) {
    query['CaSn'] = request.caSn;
  }
  if (!$isNull(request.deviceSn)) {
    query['DeviceSn'] = request.deviceSn;
  }
  if (!$isNull(request.mqttInstanceId)) {
    query['MqttInstanceId'] = request.mqttInstanceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ActiveDeviceCertificate',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Reactivates a device certificate. Device certificates are digital certificates issued to clients by certificate authority (CA) root certificates. When you connect an ApsaraMQ for MQTT client to an ApsaraMQ for MQTT broker, the broker uses the device certificate to authenticate the client based on the registered CA certificate. If the CA certificate matches the device certificate, the client passes the authentication and the system automatically registers the device certificate with the ApsaraMQ for MQTT broker. After a device certificate is registered with an ApsaraMQ for MQTT broker, the certificate is automatically activated. If your device certificate is changed to the inactivated state, you can call this operation to reactivate the device certificate.
 *
 * @description *   Only ApsaraMQ for MQTT Enterprise Platinum Edition instances support this operation.
 * *   You can call this operation up to 500 times per second per Alibaba Cloud account. If you want to increase the limit, join the DingTalk group (ID: 35228338) to contact ApsaraMQ for MQTT technical support.
 *
 * @param request ActiveDeviceCertificateRequest
 * @return ActiveDeviceCertificateResponse
 */
async function activeDeviceCertificate(request: ActiveDeviceCertificateRequest): ActiveDeviceCertificateResponse {
  var runtime = new $RuntimeOptions{};
  return activeDeviceCertificateWithOptions(request, runtime);
}

model AddCustomAuthConnectBlackRequest {
  clientId?: string(name='ClientId', description='The client ID of the device whose connections you want to disable.

This parameter is required.', example='GID_test@@@test'),
  instanceId?: string(name='InstanceId', description='The ID of the ApsaraMQ for MQTT instance.

This parameter is required.', example='mqtt-cn-i7m26mf****'),
}

model AddCustomAuthConnectBlackResponseBody = {
  code?: int32(name='Code', description='The HTTP status code. The value 200 indicates that the request is successful.', example='200'),
  message?: string(name='Message', description='The message returned.', example='operation success.'),
  requestId?: string(name='RequestId', description='The request ID.', example='82B9E503-F4A1-4F30-976F-C6999FF9****'),
  success?: boolean(name='Success', description='Indicates whether the operation is successful. Valid values: true and false.', example='True'),
}

model AddCustomAuthConnectBlackResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddCustomAuthConnectBlackResponseBody(name='body'),
}

/**
 * @summary Adds a device to the connection blacklist to disable connections from the device.
 *
 * @param request AddCustomAuthConnectBlackRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddCustomAuthConnectBlackResponse
 */
async function addCustomAuthConnectBlackWithOptions(request: AddCustomAuthConnectBlackRequest, runtime: $RuntimeOptions): AddCustomAuthConnectBlackResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.clientId)) {
    body['ClientId'] = request.clientId;
  }
  if (!$isNull(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'AddCustomAuthConnectBlack',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Adds a device to the connection blacklist to disable connections from the device.
 *
 * @param request AddCustomAuthConnectBlackRequest
 * @return AddCustomAuthConnectBlackResponse
 */
async function addCustomAuthConnectBlack(request: AddCustomAuthConnectBlackRequest): AddCustomAuthConnectBlackResponse {
  var runtime = new $RuntimeOptions{};
  return addCustomAuthConnectBlackWithOptions(request, runtime);
}

model AddCustomAuthIdentityRequest {
  clientId?: string(name='ClientId', description='The client ID if you set IdentityType to CLIENT.', example='GID_test@@@test'),
  identityType?: string(name='IdentityType', description='The identity type. Valid values:

*   USER
*   CLIENT

This parameter is required.', example='USER'),
  instanceId?: string(name='InstanceId', description='The ID of the Message Queue for MQTT instance.

This parameter is required.', example='mqtt-cn-xxxx'),
  secret?: string(name='Secret', description='The AccessKey secret.

This parameter is required.', example='xxxxx'),
  signMode?: string(name='SignMode', description='The signature verification mode. ORIGIN: compares the password and the AccessKey secret. SIGNED: uses the HMAC_SHA1 algorithm to sign the client ID to obtain a password and then compares the password.

This parameter is required.', example='SIGNED'),
  username?: string(name='Username', description='The username.

This parameter is required.', example='test'),
}

model AddCustomAuthIdentityResponseBody = {
  code?: int32(name='Code', description='The HTTP status code. The status code 200 indicates that the request is successful.', example='200'),
  message?: string(name='Message', description='The message returned.', example='operation success.'),
  requestId?: string(name='RequestId', description='The request ID.', example='020F6A43-19E6-4B6E-B846-44EB31DF****'),
  success?: boolean(name='Success', description='Indicates whether the operation is successful. Valid values: true and false.', example='True'),
}

model AddCustomAuthIdentityResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddCustomAuthIdentityResponseBody(name='body'),
}

/**
 * @summary Adds the information about identity authentication. The identity can be accurate to a client.
 *
 * @param request AddCustomAuthIdentityRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddCustomAuthIdentityResponse
 */
async function addCustomAuthIdentityWithOptions(request: AddCustomAuthIdentityRequest, runtime: $RuntimeOptions): AddCustomAuthIdentityResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.clientId)) {
    body['ClientId'] = request.clientId;
  }
  if (!$isNull(request.identityType)) {
    body['IdentityType'] = request.identityType;
  }
  if (!$isNull(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.secret)) {
    body['Secret'] = request.secret;
  }
  if (!$isNull(request.signMode)) {
    body['SignMode'] = request.signMode;
  }
  if (!$isNull(request.username)) {
    body['Username'] = request.username;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'AddCustomAuthIdentity',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Adds the information about identity authentication. The identity can be accurate to a client.
 *
 * @param request AddCustomAuthIdentityRequest
 * @return AddCustomAuthIdentityResponse
 */
async function addCustomAuthIdentity(request: AddCustomAuthIdentityRequest): AddCustomAuthIdentityResponse {
  var runtime = new $RuntimeOptions{};
  return addCustomAuthIdentityWithOptions(request, runtime);
}

model AddCustomAuthPermissionRequest {
  effect?: string(name='Effect', description='Specifies whether to allow or deny access.

This parameter is required.', example='ALLOW'),
  identity?: string(name='Identity', description='The username or client ID.

This parameter is required.', example='test'),
  identityType?: string(name='IdentityType', description='The identity type. Valid values: USER and CLIENT.

This parameter is required.', example='USER'),
  instanceId?: string(name='InstanceId', description='The ID of the ApsaraMQ for MQTT instance.

This parameter is required.', example='mqtt-cn-0pp12gl****'),
  permitAction?: string(name='PermitAction', description='The permissions that you want to grant.

This parameter is required.', example='PUB_SUB'),
  topic?: string(name='Topic', description='The topics on which you want to grant permissions. Multi-level topics and wildcard characters are supported.

This parameter is required.', example='test/t1'),
}

model AddCustomAuthPermissionResponseBody = {
  code?: int32(name='Code', description='The HTTP status code. The status code 200 indicates that the request is successful.', example='200'),
  message?: string(name='Message', description='The error message returned.', example='operation success.'),
  requestId?: string(name='RequestId', description='The request ID.', example='82B9E503-F4A1-4F30-976F-C6999FF9****'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values: true and false.', example='True'),
}

model AddCustomAuthPermissionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddCustomAuthPermissionResponseBody(name='body'),
}

/**
 * @summary Grants permissions on topics. You must create a parent topic in the console before you call this API operation.
 *
 * @param request AddCustomAuthPermissionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddCustomAuthPermissionResponse
 */
async function addCustomAuthPermissionWithOptions(request: AddCustomAuthPermissionRequest, runtime: $RuntimeOptions): AddCustomAuthPermissionResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.effect)) {
    body['Effect'] = request.effect;
  }
  if (!$isNull(request.identity)) {
    body['Identity'] = request.identity;
  }
  if (!$isNull(request.identityType)) {
    body['IdentityType'] = request.identityType;
  }
  if (!$isNull(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.permitAction)) {
    body['PermitAction'] = request.permitAction;
  }
  if (!$isNull(request.topic)) {
    body['Topic'] = request.topic;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'AddCustomAuthPermission',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Grants permissions on topics. You must create a parent topic in the console before you call this API operation.
 *
 * @param request AddCustomAuthPermissionRequest
 * @return AddCustomAuthPermissionResponse
 */
async function addCustomAuthPermission(request: AddCustomAuthPermissionRequest): AddCustomAuthPermissionResponse {
  var runtime = new $RuntimeOptions{};
  return addCustomAuthPermissionWithOptions(request, runtime);
}

model ApplyTokenRequest {
  actions?: string(name='Actions', description='The permission type of the token. Valid values:

*   **R**: read-only. You can only subscribe to the specified topics.
*   **W**: write-only. You can only send messages to the specified topics.
*   **R,W**: read and write. You can send messages to and subscribe to the specified topics. Separate **R** and **W** with a comma (,).

This parameter is required.', example='R'),
  expireTime?: long(name='ExpireTime', description='The timestamp that indicates the point in time when the token expires. Unit: milliseconds. The minimum validity period of a token is 60 seconds, and the maximum validity period of a token is 30 days. If you specify a validity period of more than 30 days for a token, no errors are returned. However, the token is valid only for 30 days.

For example, you want to specify a validity period of 60 seconds for a token. If the current system timestamp is 1609434061000, you must set this parameter to **1609434121000**. The value is calculated by using the following formula: 1609434061000 + 60 x 1000 = 1609434121000.

This parameter is required.', example='1609434121000'),
  instanceId?: string(name='InstanceId', description='The ID of the ApsaraMQ for MQTT instance. The ID must be consistent with the ID of the instance that the ApsaraMQ for MQTT client uses. You can obtain the instance ID on the **Instance Details** page that corresponds to the instance in the [ApsaraMQ for MQTT console](https://mqtt.console.aliyun.com/).

This parameter is required.', example='post-cn-0pp12gl****'),
  resources?: string(name='Resources', description='The topics on the ApsaraMQ for MQTT instance. Separate multiple topics with commas (,). Each token can be used to access up to 100 topics. Multiple topics are sorted in alphabetic order. MQTT wildcards, including single-level wildcards represented by plus signs (+) and multi-level wildcards represented by number signs (#), can be used for the Resources parameter that you register to apply for a token.

For example, if you set the **Resources** parameter to Topic1/+ when you apply for a token, the ApsaraMQ for MQTT client can manage the topics in Topic1/xxx. If you set the **Resources** parameter to Topic1/# when you apply for a token, the ApsaraMQ for MQTT client can manage topics of any level in Topic1/xxx/xxx/xxx.

>  ApsaraMQ for MQTT supports subtopics. You can specify subtopics in the code for messaging instead of configuring them in the ApsaraMQ for MQTT console. Forward slashes (/) are used to separate topics of different levels. For more information, see [Terms](https://help.aliyun.com/document_detail/42420.html).

This parameter is required.', example='TopicA/+'),
}

model ApplyTokenResponseBody = {
  requestId?: string(name='RequestId', description='The request ID. This parameter is a common parameter.', example='31782AAF-D0CC-44C3-ABFD-1B500276****'),
  token?: string(name='Token', description='The token that is returned by the ApsaraMQ for MQTT broker.

>  Do not assume the length, format, or rule of the token to return. The actual returned token shall prevail.', example='LzMT+XLFl5s/YWJ/MlDz4t/Lq5HC1iGU1P28HAMaxYxn8aQbALNtml7QZKl9L9kPe6LqUb95tEVo+zUqOogs9+jZwDUSzsd4X4qaD3n2TrBEuMOqKkk1Xdrvu9VBQQvIYbz7MJWZDYC3DlW7gLEr33Cuj54iIhagtBi3epStJitsssWs7otY9zhKOSZxhr49G3d0bh35mwyP18EMvDas8UlzeSozsSrujNUqZXOGK0PEBSd+rWMGDJlCt6GFmJgm2JFY7PJwf/7OOSmUYIYFs5o/PuPpoTMF+hcVXMs+0yDukIMTOzG9m3t8k36PVrghFmnK6pC3Rt3mibjW****ng=='),
}

model ApplyTokenResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ApplyTokenResponseBody(name='body'),
}

/**
 * @summary Applies for a token from ApsaraMQ for MQTT. If token-based authentication is used for permission authentication on an ApsaraMQ for MQTT broker, a token that is issued by the broker is required for authentication each time a client is connected to the broker.
 *
 * @description *   You can call this operation up to 100 times per second per account. If you want to increase the limit, join the DingTalk group 35228338 to contact ApsaraMQ for MQTT technical support.
 * *   Each successful call to the **ApplyToken** operation increases the messaging transactions per second (TPS) by one. This affects the billing of your instance. For more information, see [Billing rules](https://help.aliyun.com/document_detail/52819.html).
 *
 * @param request ApplyTokenRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ApplyTokenResponse
 */
async function applyTokenWithOptions(request: ApplyTokenRequest, runtime: $RuntimeOptions): ApplyTokenResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.actions)) {
    query['Actions'] = request.actions;
  }
  if (!$isNull(request.expireTime)) {
    query['ExpireTime'] = request.expireTime;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.resources)) {
    query['Resources'] = request.resources;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ApplyToken',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Applies for a token from ApsaraMQ for MQTT. If token-based authentication is used for permission authentication on an ApsaraMQ for MQTT broker, a token that is issued by the broker is required for authentication each time a client is connected to the broker.
 *
 * @description *   You can call this operation up to 100 times per second per account. If you want to increase the limit, join the DingTalk group 35228338 to contact ApsaraMQ for MQTT technical support.
 * *   Each successful call to the **ApplyToken** operation increases the messaging transactions per second (TPS) by one. This affects the billing of your instance. For more information, see [Billing rules](https://help.aliyun.com/document_detail/52819.html).
 *
 * @param request ApplyTokenRequest
 * @return ApplyTokenResponse
 */
async function applyToken(request: ApplyTokenRequest): ApplyTokenResponse {
  var runtime = new $RuntimeOptions{};
  return applyTokenWithOptions(request, runtime);
}

model BatchQuerySessionByClientIdsRequest {
  clientIdList?: [ string ](name='ClientIdList', description='The ApsaraMQ for MQTT clients.

This parameter is required.', example='ClientIdList.1'),
  instanceId?: string(name='InstanceId', description='The ID of the ApsaraMQ for MQTT instance. The ID must be consistent with the ID of the instance that the ApsaraMQ for MQTT client uses. You can obtain the instance ID on the **Instance Details** page that corresponds to the instance in the [ApsaraMQ for MQTT console](https://mqtt.console.aliyun.com).

This parameter is required.', example='post-cn-0pp12gl****'),
}

model BatchQuerySessionByClientIdsResponseBody = {
  onlineStatusList?: [ 
    {
      clientId?: string(name='ClientId', description='The ID of the ApsaraMQ for MQTT client. For more information about client IDs, see [Terms](https://help.aliyun.com/document_detail/42420.html).', example='GID_test@0001'),
      onlineStatus?: boolean(name='OnlineStatus', description='Indicates whether the ApsaraMQ for MQTT client is online. Valid values:

*   **true**
*   **false**', example='true'),
    }
  ](name='OnlineStatusList', description='The status list of all queried ApsaraMQ for MQTT clients.'),
  requestId?: string(name='RequestId', description='The request ID. This parameter is a common parameter.', example='63309FDB-ED6C-46AE-B31C-A172FBA0****'),
}

model BatchQuerySessionByClientIdsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchQuerySessionByClientIdsResponseBody(name='body'),
}

/**
 * @summary Queries the status of multiple ApsaraMQ for MQTT clients by client ID.
 *
 * @description *   You can call the **BatchQuerySessionByClientIds** operation up to 100 times per second. For more information, see [Limits on QPS](https://help.aliyun.com/document_detail/163047.html).
 * *   You can call the **BatchQuerySessionByClientIds** operation to query the status of up to 10 ApsaraMQ for MQTT clients in a single query.
 * *   Each successful call to the **BatchQuerySessionByClientIds** operation increases the messaging transactions per second (TPS) by one. This affects the billing of your instance. For more information, see [Billing rules](https://help.aliyun.com/document_detail/52819.html).
 *
 * @param request BatchQuerySessionByClientIdsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchQuerySessionByClientIdsResponse
 */
async function batchQuerySessionByClientIdsWithOptions(request: BatchQuerySessionByClientIdsRequest, runtime: $RuntimeOptions): BatchQuerySessionByClientIdsResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.clientIdList)) {
    query['ClientIdList'] = request.clientIdList;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'BatchQuerySessionByClientIds',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the status of multiple ApsaraMQ for MQTT clients by client ID.
 *
 * @description *   You can call the **BatchQuerySessionByClientIds** operation up to 100 times per second. For more information, see [Limits on QPS](https://help.aliyun.com/document_detail/163047.html).
 * *   You can call the **BatchQuerySessionByClientIds** operation to query the status of up to 10 ApsaraMQ for MQTT clients in a single query.
 * *   Each successful call to the **BatchQuerySessionByClientIds** operation increases the messaging transactions per second (TPS) by one. This affects the billing of your instance. For more information, see [Billing rules](https://help.aliyun.com/document_detail/52819.html).
 *
 * @param request BatchQuerySessionByClientIdsRequest
 * @return BatchQuerySessionByClientIdsResponse
 */
async function batchQuerySessionByClientIds(request: BatchQuerySessionByClientIdsRequest): BatchQuerySessionByClientIdsResponse {
  var runtime = new $RuntimeOptions{};
  return batchQuerySessionByClientIdsWithOptions(request, runtime);
}

model CloseConnectionRequest {
  clientId?: string(name='ClientId', description='Client ID of the device

This parameter is required.', example='GID_test@@@test'),
  instanceId?: string(name='InstanceId', description='ID of the Micro Message Queue MQTT version instance.

This parameter is required.', example='post-cn-0pp12gl****'),
}

model CloseConnectionResponseBody = {
  code?: int32(name='Code', description='Return code of the interface: 200 indicates success. Other values indicate error codes. For details about the error codes, see Error Codes.', example='200'),
  message?: string(name='Message', description='Call result information', example='operation success.'),
  requestId?: string(name='RequestId', description='Id of the request', example='82B9E503-F4A1-4F30-976F-C6999FF9****'),
  success?: boolean(name='Success', description='Indicates whether the operation was successful. true means success, false means failure.', example='True'),
}

model CloseConnectionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CloseConnectionResponseBody(name='body'),
}

/**
 * @summary Proactively closes an online connection. After you call this API operation, the device may reconnect to the broker based on the client reconnection mechanism.
 *
 * @description This API is still in the testing phase and is only available for Professional Edition instances in the Shanghai region. Legacy instances are not supported at this time.
 *
 * @param request CloseConnectionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CloseConnectionResponse
 */
async function closeConnectionWithOptions(request: CloseConnectionRequest, runtime: $RuntimeOptions): CloseConnectionResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CloseConnection',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Proactively closes an online connection. After you call this API operation, the device may reconnect to the broker based on the client reconnection mechanism.
 *
 * @description This API is still in the testing phase and is only available for Professional Edition instances in the Shanghai region. Legacy instances are not supported at this time.
 *
 * @param request CloseConnectionRequest
 * @return CloseConnectionResponse
 */
async function closeConnection(request: CloseConnectionRequest): CloseConnectionResponse {
  var runtime = new $RuntimeOptions{};
  return closeConnectionWithOptions(request, runtime);
}

model CreateGroupIdRequest {
  groupId?: string(name='GroupId', description='The ID of the group that you want to create. The group ID must meet the following conventions:

*   The ID must be 7 to 64 characters in length. It must start with GID_ or GID- and can contain only letters, digits, hyphens (-), and underscores (_).
*   The ID cannot be changed after the group is created. For more information, see [Terms](https://help.aliyun.com/document_detail/42420.html).

This parameter is required.', example='GID_test'),
  instanceId?: string(name='InstanceId', description='The ID of the ApsaraMQ for MQTT instance to which the group belongs.

This parameter is required.', example='mqtt-cn-0pp1ldu****'),
}

model CreateGroupIdResponseBody = {
  requestId?: string(name='RequestId', description='The request ID. This parameter is a common parameter.', example='2C7D722D-0F3D-4415-A9CD-A464D82C****'),
}

model CreateGroupIdResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateGroupIdResponseBody(name='body'),
}

/**
 * @summary Creates a group ID. Before you connect producers and consumers to an ApsaraMQ for MQTT broker to send and receive messages, you must specify a unique ID for each client for identification. A client ID is in the format of \\<GroupID>@@@\\<DeviceID>. In the preceding format, DeviceID is the custom ID that you specify for the client, and GroupID is the ID of the group that you create on the ApsaraMQ for MQTT broker in advance.
 *
 * @description Each successful call to the **CreateGroupId** operation increases the messaging transactions per second (TPS) by one. This affects the billing of your instance. For more information, see [Billing rules](https://help.aliyun.com/document_detail/52819.html).
 *
 * @param request CreateGroupIdRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateGroupIdResponse
 */
async function createGroupIdWithOptions(request: CreateGroupIdRequest, runtime: $RuntimeOptions): CreateGroupIdResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateGroupId',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a group ID. Before you connect producers and consumers to an ApsaraMQ for MQTT broker to send and receive messages, you must specify a unique ID for each client for identification. A client ID is in the format of \\<GroupID>@@@\\<DeviceID>. In the preceding format, DeviceID is the custom ID that you specify for the client, and GroupID is the ID of the group that you create on the ApsaraMQ for MQTT broker in advance.
 *
 * @description Each successful call to the **CreateGroupId** operation increases the messaging transactions per second (TPS) by one. This affects the billing of your instance. For more information, see [Billing rules](https://help.aliyun.com/document_detail/52819.html).
 *
 * @param request CreateGroupIdRequest
 * @return CreateGroupIdResponse
 */
async function createGroupId(request: CreateGroupIdRequest): CreateGroupIdResponse {
  var runtime = new $RuntimeOptions{};
  return createGroupIdWithOptions(request, runtime);
}

model DeleteCaCertificateRequest {
  mqttInstanceId?: string(name='MqttInstanceId', description='The ID of the ApsaraMQ for MQTT instance to which the CA certificate is bound.

This parameter is required.', example='post-cn-7mz2d******'),
  sn?: string(name='Sn', description='The serial number of the CA certificate that you want to delete. The serial number is the unique identifier of a CA certificate.

The serial number of a CA certificate cannot exceed 128 bytes in size.

This parameter is required.', example='007269004887******'),
}

model DeleteCaCertificateResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='020F6A43-19E6-4B6E-B846-44EB31DF****'),
  sn?: string(name='Sn', description='The serial number of the CA certificate that you deleted. The serial number is the unique identifier of a CA certificate.', example='007269004887******'),
}

model DeleteCaCertificateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteCaCertificateResponseBody(name='body'),
}

/**
 * @summary Deletes a certificate authority (CA) certificate from an ApsaraMQ for MQTT broker. ApsaraMQ for MQTT allows you to use X.509 certificates for authentication. When you connect an ApsaraMQ for MQTT client to an ApsaraMQ for MQTT broker, you can use the device certificate to implement authentication. CA certificates are used to issue device certificates to clients and validate the device certificates. Before you can use a CA certificate, you must register the certificate with an ApsaraMQ for MQTT broker. If you no longer require a CA certificate, you can call this operation to delete the certificate from the ApsaraMQ for MQTT broker.
 *
 * @description *   Only ApsaraMQ for MQTT Enterprise Platinum Edition instances support this operation.
 * *   You can call this operation up to 500 times per second per Alibaba Cloud account. If you want to increase the limit, join the DingTalk group (ID: 35228338) to contact ApsaraMQ for MQTT technical support.
 * *   You can call this operation to delete only CA certificates that are registered with ApsaraMQ for MQTT brokers. You can call the [ListCaCertificate](https://help.aliyun.com/document_detail/2604958.html) operation to query CA certificates that are registered with an ApsaraMQ for MQTT instance.
 * *   If you delete a specific CA certificate from an ApsaraMQ for MQTT broker, all device certificates that are issued by the CA certificate and are registered with the ApsaraMQ for MQTT broker are automatically deleted.
 *
 * @param request DeleteCaCertificateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteCaCertificateResponse
 */
async function deleteCaCertificateWithOptions(request: DeleteCaCertificateRequest, runtime: $RuntimeOptions): DeleteCaCertificateResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.mqttInstanceId)) {
    query['MqttInstanceId'] = request.mqttInstanceId;
  }
  if (!$isNull(request.sn)) {
    query['Sn'] = request.sn;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteCaCertificate',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes a certificate authority (CA) certificate from an ApsaraMQ for MQTT broker. ApsaraMQ for MQTT allows you to use X.509 certificates for authentication. When you connect an ApsaraMQ for MQTT client to an ApsaraMQ for MQTT broker, you can use the device certificate to implement authentication. CA certificates are used to issue device certificates to clients and validate the device certificates. Before you can use a CA certificate, you must register the certificate with an ApsaraMQ for MQTT broker. If you no longer require a CA certificate, you can call this operation to delete the certificate from the ApsaraMQ for MQTT broker.
 *
 * @description *   Only ApsaraMQ for MQTT Enterprise Platinum Edition instances support this operation.
 * *   You can call this operation up to 500 times per second per Alibaba Cloud account. If you want to increase the limit, join the DingTalk group (ID: 35228338) to contact ApsaraMQ for MQTT technical support.
 * *   You can call this operation to delete only CA certificates that are registered with ApsaraMQ for MQTT brokers. You can call the [ListCaCertificate](https://help.aliyun.com/document_detail/2604958.html) operation to query CA certificates that are registered with an ApsaraMQ for MQTT instance.
 * *   If you delete a specific CA certificate from an ApsaraMQ for MQTT broker, all device certificates that are issued by the CA certificate and are registered with the ApsaraMQ for MQTT broker are automatically deleted.
 *
 * @param request DeleteCaCertificateRequest
 * @return DeleteCaCertificateResponse
 */
async function deleteCaCertificate(request: DeleteCaCertificateRequest): DeleteCaCertificateResponse {
  var runtime = new $RuntimeOptions{};
  return deleteCaCertificateWithOptions(request, runtime);
}

model DeleteCustomAuthConnectBlackRequest {
  clientId?: string(name='ClientId', description='The ID of the ApsaraMQ for MQTT client.

This parameter is required.', example='GID_test@@@test'),
  instanceId?: string(name='InstanceId', description='The ID of the ApsaraMQ for MQTT instance.

This parameter is required.', example='post-cn-0pp12gl****'),
}

model DeleteCustomAuthConnectBlackResponseBody = {
  code?: int32(name='Code', description='The response code. The status code 200 indicates that the request was successful.', example='200'),
  message?: string(name='Message', description='The error message.', example='operation success.'),
  requestId?: string(name='RequestId', description='The request ID.', example='317076B7-F946-46BC-A98F-4CF9777C****'),
  success?: boolean(name='Success', description='Indicates whether the operation was successful. Valid values: true and false.', example='True'),
}

model DeleteCustomAuthConnectBlackResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteCustomAuthConnectBlackResponseBody(name='body'),
}

/**
 * @summary Deletes a connection blacklist.
 *
 * @param request DeleteCustomAuthConnectBlackRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteCustomAuthConnectBlackResponse
 */
async function deleteCustomAuthConnectBlackWithOptions(request: DeleteCustomAuthConnectBlackRequest, runtime: $RuntimeOptions): DeleteCustomAuthConnectBlackResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.clientId)) {
    body['ClientId'] = request.clientId;
  }
  if (!$isNull(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteCustomAuthConnectBlack',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes a connection blacklist.
 *
 * @param request DeleteCustomAuthConnectBlackRequest
 * @return DeleteCustomAuthConnectBlackResponse
 */
async function deleteCustomAuthConnectBlack(request: DeleteCustomAuthConnectBlackRequest): DeleteCustomAuthConnectBlackResponse {
  var runtime = new $RuntimeOptions{};
  return deleteCustomAuthConnectBlackWithOptions(request, runtime);
}

model DeleteCustomAuthIdentityRequest {
  clientId?: string(name='ClientId', description='The client ID if you set IdentityType to CLIENT.', example='GID_test@@@test'),
  identityType?: string(name='IdentityType', description='The identity type. Valid values:

*   USER
*   CLIENT

This parameter is required.', example='USER'),
  instanceId?: string(name='InstanceId', description='The ID of the ApsaraMQ for MQTT instance.

This parameter is required.', example='post-cn-0pp12gl****'),
  username?: string(name='Username', description='The username.

This parameter is required.', example='test'),
}

model DeleteCustomAuthIdentityResponseBody = {
  code?: int32(name='Code', description='The HTTP status code. The status code 200 indicates that the request is successful. Other status codes indicate that the request failed.', example='200'),
  message?: string(name='Message', description='The returned message.', example='operation success.'),
  requestId?: string(name='RequestId', description='The request ID.', example='11568B5B-13A8-4E72-9DBA-3A14F7D3****'),
  success?: boolean(name='Success', description='Indicates whether the operation is successful. Valid values: true and false.', example='True'),
}

model DeleteCustomAuthIdentityResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteCustomAuthIdentityResponseBody(name='body'),
}

/**
 * @summary Deletes an identity for custom authorization.
 *
 * @param request DeleteCustomAuthIdentityRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteCustomAuthIdentityResponse
 */
async function deleteCustomAuthIdentityWithOptions(request: DeleteCustomAuthIdentityRequest, runtime: $RuntimeOptions): DeleteCustomAuthIdentityResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.clientId)) {
    body['ClientId'] = request.clientId;
  }
  if (!$isNull(request.identityType)) {
    body['IdentityType'] = request.identityType;
  }
  if (!$isNull(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.username)) {
    body['Username'] = request.username;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteCustomAuthIdentity',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes an identity for custom authorization.
 *
 * @param request DeleteCustomAuthIdentityRequest
 * @return DeleteCustomAuthIdentityResponse
 */
async function deleteCustomAuthIdentity(request: DeleteCustomAuthIdentityRequest): DeleteCustomAuthIdentityResponse {
  var runtime = new $RuntimeOptions{};
  return deleteCustomAuthIdentityWithOptions(request, runtime);
}

model DeleteCustomAuthPermissionRequest {
  identity?: string(name='Identity', description='The username or client ID.

This parameter is required.', example='test'),
  identityType?: string(name='IdentityType', description='The identity type. Valid values:

*   USER
*   CLIENT

This parameter is required.', example='USER'),
  instanceId?: string(name='InstanceId', description='The ID of the ApsaraMQ for MQTT instance.

This parameter is required.', example='mqtt-cn-0pp1ldu****'),
  topic?: string(name='Topic', description='The topic on which you want to grant permissions. Multi-level topics and Wildcard characters are supported.

This parameter is required.', example='test/t1'),
}

model DeleteCustomAuthPermissionResponseBody = {
  code?: int32(name='Code', description='The HTTP status code.', example='200'),
  message?: string(name='Message', description='The message returned.', example='operation success.'),
  requestId?: string(name='RequestId', description='The request ID.', example='34063BCA-0946-49C1-B824-2ED2C905****'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values: true and false.', example='True'),
}

model DeleteCustomAuthPermissionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteCustomAuthPermissionResponseBody(name='body'),
}

/**
 * @summary Deletes permissions on a topic.
 *
 * @param request DeleteCustomAuthPermissionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteCustomAuthPermissionResponse
 */
async function deleteCustomAuthPermissionWithOptions(request: DeleteCustomAuthPermissionRequest, runtime: $RuntimeOptions): DeleteCustomAuthPermissionResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.identity)) {
    body['Identity'] = request.identity;
  }
  if (!$isNull(request.identityType)) {
    body['IdentityType'] = request.identityType;
  }
  if (!$isNull(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.topic)) {
    body['Topic'] = request.topic;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteCustomAuthPermission',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes permissions on a topic.
 *
 * @param request DeleteCustomAuthPermissionRequest
 * @return DeleteCustomAuthPermissionResponse
 */
async function deleteCustomAuthPermission(request: DeleteCustomAuthPermissionRequest): DeleteCustomAuthPermissionResponse {
  var runtime = new $RuntimeOptions{};
  return deleteCustomAuthPermissionWithOptions(request, runtime);
}

model DeleteDeviceCertificateRequest {
  caSn?: string(name='CaSn', description='The serial number of the CA certificate to which the device certificate belongs. The serial number is the unique identifier of a CA certificate. CA certificates are used to validate device certificates.

The serial number of a CA certificate cannot exceed 128 bytes in size.

This parameter is required.', example='007269004887******'),
  deviceSn?: string(name='DeviceSn', description='The serial number of the device certificate whose registration information you want to delete. The serial number is the unique identifier of a device.

The serial number of a device certificate cannot exceed 128 bytes in size.

This parameter is required.', example='356217374433****'),
  mqttInstanceId?: string(name='MqttInstanceId', description='The ID of the ApsaraMQ for MQTT instance to which the device certificate is bound.

This parameter is required.', example='post-cn-7mz2d******'),
}

model DeleteDeviceCertificateResponseBody = {
  deviceSn?: string(name='DeviceSn', description='The serial number of the device certificate whose registration information is deleted. The serial number is the unique identifier of a device certificate.', example='356217374433******'),
  requestId?: string(name='RequestId', description='The request ID.', example='020F6A43-19E6-4B6E-B846-44EB31DF****'),
}

model DeleteDeviceCertificateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDeviceCertificateResponseBody(name='body'),
}

/**
 * @summary Deletes the registration information about a specific device certificate from an ApsaraMQ for MQTT broker. Device certificates are digital certificates issued to clients by certificate authority (CA) root certificates. When you connect an ApsaraMQ for MQTT client to an ApsaraMQ for MQTT broker, the broker uses the device certificate to authenticate the client. If the client passes the authentication, the client and the broker can communicate with each other based on the encrypted private key in the device certificate. If the client fails the authentication, access requests from the client are denied by the client. If you no longer require a device certificate, you can call this operation to delete the registration information about the certificate from an ApsaraMQ for MQTT broker.
 *
 * @description *   Only ApsaraMQ for MQTT Enterprise Platinum Edition instances support this operation.
 * *   You can call this operation up to 500 times per second per Alibaba Cloud account. If you want to increase the limit, join the DingTalk group (ID: 35228338) to contact ApsaraMQ for MQTT technical support.
 *
 * @param request DeleteDeviceCertificateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDeviceCertificateResponse
 */
async function deleteDeviceCertificateWithOptions(request: DeleteDeviceCertificateRequest, runtime: $RuntimeOptions): DeleteDeviceCertificateResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.caSn)) {
    query['CaSn'] = request.caSn;
  }
  if (!$isNull(request.deviceSn)) {
    query['DeviceSn'] = request.deviceSn;
  }
  if (!$isNull(request.mqttInstanceId)) {
    query['MqttInstanceId'] = request.mqttInstanceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteDeviceCertificate',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes the registration information about a specific device certificate from an ApsaraMQ for MQTT broker. Device certificates are digital certificates issued to clients by certificate authority (CA) root certificates. When you connect an ApsaraMQ for MQTT client to an ApsaraMQ for MQTT broker, the broker uses the device certificate to authenticate the client. If the client passes the authentication, the client and the broker can communicate with each other based on the encrypted private key in the device certificate. If the client fails the authentication, access requests from the client are denied by the client. If you no longer require a device certificate, you can call this operation to delete the registration information about the certificate from an ApsaraMQ for MQTT broker.
 *
 * @description *   Only ApsaraMQ for MQTT Enterprise Platinum Edition instances support this operation.
 * *   You can call this operation up to 500 times per second per Alibaba Cloud account. If you want to increase the limit, join the DingTalk group (ID: 35228338) to contact ApsaraMQ for MQTT technical support.
 *
 * @param request DeleteDeviceCertificateRequest
 * @return DeleteDeviceCertificateResponse
 */
async function deleteDeviceCertificate(request: DeleteDeviceCertificateRequest): DeleteDeviceCertificateResponse {
  var runtime = new $RuntimeOptions{};
  return deleteDeviceCertificateWithOptions(request, runtime);
}

model DeleteGroupIdRequest {
  groupId?: string(name='GroupId', description='The ID of the group that you want to delete.

This parameter is required.', example='GID_test'),
  instanceId?: string(name='InstanceId', description='The ID of the ApsaraMQ for MQTT instance from which you want to delete a group.

This parameter is required.', example='mqtt-cn-0pp1ldu****'),
}

model DeleteGroupIdResponseBody = {
  requestId?: string(name='RequestId', description='The request ID. This parameter is a common parameter.', example='0621DDD7-F0E9-4D35-8900-518116D6****'),
}

model DeleteGroupIdResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteGroupIdResponseBody(name='body'),
}

/**
 * @summary Deletes a group from an ApsaraMQ for MQTT instance.
 *
 * @description Each successful call to the **DeleteGroupId** operation increases the messaging transactions per second (TPS) by one. This affects the billing of your instance. For more information, see [Billing rules](https://help.aliyun.com/document_detail/52819.html).
 *
 * @param request DeleteGroupIdRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteGroupIdResponse
 */
async function deleteGroupIdWithOptions(request: DeleteGroupIdRequest, runtime: $RuntimeOptions): DeleteGroupIdResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteGroupId',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes a group from an ApsaraMQ for MQTT instance.
 *
 * @description Each successful call to the **DeleteGroupId** operation increases the messaging transactions per second (TPS) by one. This affects the billing of your instance. For more information, see [Billing rules](https://help.aliyun.com/document_detail/52819.html).
 *
 * @param request DeleteGroupIdRequest
 * @return DeleteGroupIdResponse
 */
async function deleteGroupId(request: DeleteGroupIdRequest): DeleteGroupIdResponse {
  var runtime = new $RuntimeOptions{};
  return deleteGroupIdWithOptions(request, runtime);
}

model DisasterDowngradeRequest {
  downgradeInstanceId?: string(name='DowngradeInstanceId', description='This parameter is required.', example='mqtt-cn-xxxx'),
  instanceId?: string(name='InstanceId', description='This parameter is required.', example='mqtt-cn-xxx'),
}

model DisasterDowngradeResponseBody = {
  accessDeniedDetail?: string(name='AccessDeniedDetail', example='None'),
  code?: int32(name='Code', example='200'),
  message?: string(name='Message', example='operation success.'),
  requestId?: string(name='RequestId', description='Id of the request', example='82B9E503-F4A1-4F30-976F-C6999FF9****'),
  success?: boolean(name='Success', example='True'),
}

model DisasterDowngradeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DisasterDowngradeResponseBody(name='body'),
}

/**
 * @summary DisasterDowngrade
 *
 * @param request DisasterDowngradeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DisasterDowngradeResponse
 */
async function disasterDowngradeWithOptions(request: DisasterDowngradeRequest, runtime: $RuntimeOptions): DisasterDowngradeResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.downgradeInstanceId)) {
    body['DowngradeInstanceId'] = request.downgradeInstanceId;
  }
  if (!$isNull(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'DisasterDowngrade',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary DisasterDowngrade
 *
 * @param request DisasterDowngradeRequest
 * @return DisasterDowngradeResponse
 */
async function disasterDowngrade(request: DisasterDowngradeRequest): DisasterDowngradeResponse {
  var runtime = new $RuntimeOptions{};
  return disasterDowngradeWithOptions(request, runtime);
}

model DisasterRecoveryRequest {
  instanceId?: string(name='InstanceId', description='This parameter is required.', example='mqtt-cn-xxx'),
  recoveryInstanceId?: string(name='RecoveryInstanceId', description='This parameter is required.', example='mqtt-cn-xxx'),
}

model DisasterRecoveryResponseBody = {
  accessDeniedDetail?: string(name='AccessDeniedDetail', example='{}'),
  code?: int32(name='Code', example='200'),
  message?: string(name='Message', example='operation success.'),
  requestId?: string(name='RequestId', description='Id of the request', example='135F8639-F262-4417-98D1-4DE4595C****'),
  success?: boolean(name='Success', example='True'),
}

model DisasterRecoveryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DisasterRecoveryResponseBody(name='body'),
}

/**
 * @summary DisasterRecovery
 *
 * @param request DisasterRecoveryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DisasterRecoveryResponse
 */
async function disasterRecoveryWithOptions(request: DisasterRecoveryRequest, runtime: $RuntimeOptions): DisasterRecoveryResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.recoveryInstanceId)) {
    body['RecoveryInstanceId'] = request.recoveryInstanceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'DisasterRecovery',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary DisasterRecovery
 *
 * @param request DisasterRecoveryRequest
 * @return DisasterRecoveryResponse
 */
async function disasterRecovery(request: DisasterRecoveryRequest): DisasterRecoveryResponse {
  var runtime = new $RuntimeOptions{};
  return disasterRecoveryWithOptions(request, runtime);
}

model GetCaCertificateRequest {
  mqttInstanceId?: string(name='MqttInstanceId', description='The instance ID bound to the CA certificate, which is the instance ID of the MQTT version of the cloud message queue.

This parameter is required.', example='post-cn-7mz2d******'),
  sn?: string(name='Sn', description='The SN serial number of the CA certificate to be queried, used to uniquely identify a CA certificate.

This parameter is required.', example='007269004887******'),
}

model GetCaCertificateResponseBody = {
  data?: {
    caContent?: string(name='CaContent', description='Content of the CA certificate.
> \\\\n represents a new line.', example='-----BEGIN CERTIFICATE-----\\\\nMIIDuzCCAqdGVzdC5jbi1xaW5n******\\\\n-----END CERTIFICATE-----'),
    caName?: string(name='CaName', description='Name of the CA certificate', example='mqtt_ca'),
    registrationCode?: string(name='RegistrationCode', description='Registration code of the CA certificate', example='13274673-8f90-4630-bea1-9cccb25756ad2089******'),
    sn?: string(name='Sn', description='The SN serial number of the CA certificate, used to uniquely identify a CA certificate. Value range: no more than 128 bytes.', example='00f26900ba87******'),
    status?: string(name='Status', description='The status of the CA certificate. The values are as follows:
- **0**: Indicates that the certificate is in an inactive state. - **1**: Indicates that the certificate is in an active state.
> After the CA certificate is registered, it is in an active state by default.', example='1'),
    validBegin?: string(name='ValidBegin', description='The start time when the CA certificate becomes effective. The format is a Unix timestamp in milliseconds.', example='1654137303000'),
    validEnd?: string(name='ValidEnd', description='The end time when the CA certificate becomes effective. The format is a Unix timestamp in milliseconds.', example='1969497303000'),
    verificationContent?: string(name='VerificationContent', description='Content of the Verification certificate.
> \\\\n represents a new line.', example='-----BEGIN CERTIFICATE-----\\\\nMIID/DCCAu+Y5sRMpp9tnd+4s******\\\\n-----END CERTIFICATE-----'),
  }(name='Data', description='Certificate details.'),
  requestId?: string(name='RequestId', description='Public parameters, each request ID is unique and can be used for troubleshooting and problem localization.', example='020F6A43-19E6-4B6E-B846-44EB31DF****'),
}

model GetCaCertificateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetCaCertificateResponseBody(name='body'),
}

/**
 * @summary Queries the details of a certificate authority (CA) certificate, such as the content and status of the certificate. ApsaraMQ for MQTT allows you to use X.509 certificates for authentication. When you connect an ApsaraMQ for MQTT client to an ApsaraMQ for MQTT broker, you can use the device certificate to implement authentication. CA certificates are used to issue device certificates to clients and validate the device certificates.
 *
 * @description *   Only ApsaraMQ for MQTT Enterprise Platinum Edition instances support this operation.
 * *   You can call this operation up to 500 times per second per Alibaba Cloud account. If you want to increase the limit, join the DingTalk group (ID: 35228338) to contact ApsaraMQ for MQTT technical support.
 *
 * @param request GetCaCertificateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetCaCertificateResponse
 */
async function getCaCertificateWithOptions(request: GetCaCertificateRequest, runtime: $RuntimeOptions): GetCaCertificateResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetCaCertificate',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the details of a certificate authority (CA) certificate, such as the content and status of the certificate. ApsaraMQ for MQTT allows you to use X.509 certificates for authentication. When you connect an ApsaraMQ for MQTT client to an ApsaraMQ for MQTT broker, you can use the device certificate to implement authentication. CA certificates are used to issue device certificates to clients and validate the device certificates.
 *
 * @description *   Only ApsaraMQ for MQTT Enterprise Platinum Edition instances support this operation.
 * *   You can call this operation up to 500 times per second per Alibaba Cloud account. If you want to increase the limit, join the DingTalk group (ID: 35228338) to contact ApsaraMQ for MQTT technical support.
 *
 * @param request GetCaCertificateRequest
 * @return GetCaCertificateResponse
 */
async function getCaCertificate(request: GetCaCertificateRequest): GetCaCertificateResponse {
  var runtime = new $RuntimeOptions{};
  return getCaCertificateWithOptions(request, runtime);
}

model GetDeviceCertificateRequest {
  caSn?: string(name='CaSn', description='The SN serial number of the CA certificate to which the device certificate to be queried belongs, used to uniquely identify a CA certificate. Value range: no more than 128 bytes.

This parameter is required.', example='007269004887******'),
  deviceSn?: string(name='DeviceSn', description='The SN serial number of the device certificate to be queried, used to uniquely identify a device certificate. Value range: no more than 128 bytes.

This parameter is required.', example='356217374433******'),
  mqttInstanceId?: string(name='MqttInstanceId', description='The instance ID to which the device certificate is bound, i.e., the instance ID of the Cloud Message Queue MQTT version.

This parameter is required.', example='post-cn-7mz2d******'),
}

model GetDeviceCertificateResponseBody = {
  data?: {
    caSn?: string(name='CaSn', description='The SN serial number of the CA certificate to which the device certificate belongs, used to uniquely identify a CA certificate.', example='00f26900ba87******'),
    deviceContent?: string(name='DeviceContent', description='Content of the device certificate.

 represents a new line.', example='-----BEGIN DEVICECERTIFICATE-----\\\\nMIIDuzCCAqdGVzdC5jbi1xaW5n******\\\\n-----END DEVICECERTIFICATE-----'),
    deviceName?: string(name='DeviceName', description='Name of the device certificate.', example='mqtt_device'),
    deviceSn?: string(name='DeviceSn', description='The SN serial number of the device certificate, used to uniquely identify a device certificate.', example='356217374433******'),
    status?: string(name='Status', description='The status of the device certificate. The values are as follows:
- **0**: Indicates that the certificate is in an inactive state. - **1**: Indicates that the certificate is in an active state.
> After the device certificate is registered, it is in an active state by default.', example='1'),
    validBegin?: string(name='ValidBegin', description='The start time when the device certificate becomes effective. The format is a Unix timestamp in milliseconds.', example='1654137303000'),
    validEnd?: string(name='ValidEnd', description='The end time when the device certificate becomes effective. The format is a Unix timestamp in milliseconds.', example='1969497303000'),
  }(name='Data', description='Certificate details.'),
  requestId?: string(name='RequestId', description='Public parameters, each request ID is unique and can be used for troubleshooting and problem localization.', example='020F6A43-19E6-4B6E-B846-44EB31DF****'),
}

model GetDeviceCertificateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDeviceCertificateResponseBody(name='body'),
}

/**
 * @summary Queries the details of a device certificate. Device certificates are digital certificates issued to clients by certificate authority (CA) root certificates. When you connect an ApsaraMQ for MQTT client to an ApsaraMQ for MQTT broker, the broker uses the device certificate to authenticate the client. If the client passes the authentication, the client and the broker can communicate with each other based on the encrypted private key in the device certificate. If the client fails the authentication, access requests from the client are denied by the client.
 *
 * @description *   Only ApsaraMQ for MQTT Enterprise Platinum Edition instances support this operation.
 * *   You can call this operation up to 500 times per second per Alibaba Cloud account. If you want to increase the limit, join the DingTalk group (ID: 35228338) to contact ApsaraMQ for MQTT technical support.
 *
 * @param request GetDeviceCertificateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDeviceCertificateResponse
 */
async function getDeviceCertificateWithOptions(request: GetDeviceCertificateRequest, runtime: $RuntimeOptions): GetDeviceCertificateResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetDeviceCertificate',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the details of a device certificate. Device certificates are digital certificates issued to clients by certificate authority (CA) root certificates. When you connect an ApsaraMQ for MQTT client to an ApsaraMQ for MQTT broker, the broker uses the device certificate to authenticate the client. If the client passes the authentication, the client and the broker can communicate with each other based on the encrypted private key in the device certificate. If the client fails the authentication, access requests from the client are denied by the client.
 *
 * @description *   Only ApsaraMQ for MQTT Enterprise Platinum Edition instances support this operation.
 * *   You can call this operation up to 500 times per second per Alibaba Cloud account. If you want to increase the limit, join the DingTalk group (ID: 35228338) to contact ApsaraMQ for MQTT technical support.
 *
 * @param request GetDeviceCertificateRequest
 * @return GetDeviceCertificateResponse
 */
async function getDeviceCertificate(request: GetDeviceCertificateRequest): GetDeviceCertificateResponse {
  var runtime = new $RuntimeOptions{};
  return getDeviceCertificateWithOptions(request, runtime);
}

model GetDeviceCredentialRequest {
  clientId?: string(name='ClientId', description='The client ID of the device whose access credential you want to query.

This parameter is required.', example='GID_test@@@test'),
  instanceId?: string(name='InstanceId', description='The ID of the ApsaraMQ for MQTT instance. The ID must be consistent with the ID of the instance that the ApsaraMQ for MQTT client uses. You can obtain the instance ID on the **Instance Details** page that corresponds to the instance in the ApsaraMQ for MQTT console.

This parameter is required.', example='post-cn-0pp12gl****'),
}

model GetDeviceCredentialResponseBody = {
  deviceCredential?: {
    clientId?: string(name='ClientId', description='The client ID of the device.', example='GID_test@@@test'),
    createTime?: long(name='CreateTime', description='The timestamp that indicates when the access credential of the device was created. Unit: milliseconds.', example='1605541382000'),
    deviceAccessKeyId?: string(name='DeviceAccessKeyId', description='The AccessKey ID of the device.', example='DC.Z5fXh9sRRVufyLi6wo****'),
    deviceAccessKeySecret?: string(name='DeviceAccessKeySecret', description='The AccessKey secret of the device.', example='DC.BJMkn4eMQJK2vaApTS****'),
    instanceId?: string(name='InstanceId', description='The ID of the ApsaraMQ for MQTT instance.', example='post-cn-0pp12gl****'),
    updateTime?: long(name='UpdateTime', description='The timestamp that indicates when the access credential of the device was last updated. The value of this parameter is a UNIX timestamp in milliseconds.', example='1605541382000'),
  }(name='DeviceCredential', description='The information about the access credential of the device.'),
  requestId?: string(name='RequestId', description='The request ID. This parameter is a common parameter.', example='E4581CCF-62AF-44D9-B5B4-D1DQDC0E****'),
}

model GetDeviceCredentialResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDeviceCredentialResponseBody(name='body'),
}

/**
 * @summary Queries the access credential of a device. If unique-certificate-per-device authentication is used as the authentication method on an ApsaraMQ for MQTT broker, an access credential that you apply for in advance is required for authentication when you connect your device to the broker. The connection can be established only after the authentication is passed.
 *
 * @description *   You can call this operation up to 500 times per second per account. If the limit is exceeded, throttling is triggered. We recommend that you take note of this limit when you call this operation. For more information, see [Limits on QPS](https://help.aliyun.com/document_detail/163047.html).
 * *   Each successful call to the **GetDeviceCredential** operation increases the messaging transactions per second (TPS) by one. This affects the billing of your instance. For more information, see [Billing rules](https://help.aliyun.com/document_detail/52819.html).
 *
 * @param request GetDeviceCredentialRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDeviceCredentialResponse
 */
async function getDeviceCredentialWithOptions(request: GetDeviceCredentialRequest, runtime: $RuntimeOptions): GetDeviceCredentialResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetDeviceCredential',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the access credential of a device. If unique-certificate-per-device authentication is used as the authentication method on an ApsaraMQ for MQTT broker, an access credential that you apply for in advance is required for authentication when you connect your device to the broker. The connection can be established only after the authentication is passed.
 *
 * @description *   You can call this operation up to 500 times per second per account. If the limit is exceeded, throttling is triggered. We recommend that you take note of this limit when you call this operation. For more information, see [Limits on QPS](https://help.aliyun.com/document_detail/163047.html).
 * *   Each successful call to the **GetDeviceCredential** operation increases the messaging transactions per second (TPS) by one. This affects the billing of your instance. For more information, see [Billing rules](https://help.aliyun.com/document_detail/52819.html).
 *
 * @param request GetDeviceCredentialRequest
 * @return GetDeviceCredentialResponse
 */
async function getDeviceCredential(request: GetDeviceCredentialRequest): GetDeviceCredentialResponse {
  var runtime = new $RuntimeOptions{};
  return getDeviceCredentialWithOptions(request, runtime);
}

model GetRegisterCodeRequest {
  mqttInstanceId?: string(name='MqttInstanceId', description='The ID of the ApsaraMQ for MQTT instance.

This parameter is required.', example='post-cn-7mz2d******'),
}

model GetRegisterCodeResponseBody = {
  registerCode?: string(name='RegisterCode', description='The registration code of the CA certificate.', example='13274673-8f90-4630-bea1-9cccb25756ad2089******'),
  requestId?: string(name='RequestId', description='The request ID.', example='020F6A43-19E6-4B6E-B846-44EB31DF****'),
}

model GetRegisterCodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetRegisterCodeResponseBody(name='body'),
}

/**
 * @summary Obtains the registration code of a specific certificate authority (CA) certificate. When you register a CA certificate with an ApsaraMQ for MQTT broker, you must upload the validation certificate of the CA certificate to verify whether you have the private key of the CA certificate. The validation certificate of a CA certificate must be generated by using the registration code of the CA certificate.
 *
 * @description *   Only ApsaraMQ for MQTT Enterprise Platinum Edition instances support this operation.
 * *   You can call this operation up to 500 times per second per Alibaba Cloud account. If you want to increase the limit, join the DingTalk group (ID: 35228338) to contact ApsaraMQ for MQTT technical support.
 *
 * @param request GetRegisterCodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetRegisterCodeResponse
 */
async function getRegisterCodeWithOptions(request: GetRegisterCodeRequest, runtime: $RuntimeOptions): GetRegisterCodeResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetRegisterCode',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Obtains the registration code of a specific certificate authority (CA) certificate. When you register a CA certificate with an ApsaraMQ for MQTT broker, you must upload the validation certificate of the CA certificate to verify whether you have the private key of the CA certificate. The validation certificate of a CA certificate must be generated by using the registration code of the CA certificate.
 *
 * @description *   Only ApsaraMQ for MQTT Enterprise Platinum Edition instances support this operation.
 * *   You can call this operation up to 500 times per second per Alibaba Cloud account. If you want to increase the limit, join the DingTalk group (ID: 35228338) to contact ApsaraMQ for MQTT technical support.
 *
 * @param request GetRegisterCodeRequest
 * @return GetRegisterCodeResponse
 */
async function getRegisterCode(request: GetRegisterCodeRequest): GetRegisterCodeResponse {
  var runtime = new $RuntimeOptions{};
  return getRegisterCodeWithOptions(request, runtime);
}

model InactivateCaCertificateRequest {
  mqttInstanceId?: string(name='MqttInstanceId', description='The ID of the ApsaraMQ for MQTT instance to which the CA certificate is bound.

This parameter is required.', example='post-cn-7mz2d******'),
  sn?: string(name='Sn', description='The serial number of the CA certificate that you want to deregister. The serial number is the unique identifier of a CA certificate.

The serial number of a CA certificate cannot exceed 128 bytes in size.

This parameter is required.', example='007269004887******'),
}

model InactivateCaCertificateResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='020F6A43-19E6-4B6E-B846-44EB31DF****'),
  sn?: string(name='Sn', description='The serial number of the CA certificate that is deregistered. The serial number is the unique identifier of a CA certificate.', example='007269004887******'),
}

model InactivateCaCertificateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: InactivateCaCertificateResponseBody(name='body'),
}

/**
 * @summary Deregister a certificate authority (CA) certificate. ApsaraMQ for MQTT allows you to use X.509 certificates for authentication. When you connect an ApsaraMQ for MQTT client to an ApsaraMQ for MQTT broker, you can use the device certificate to implement authentication. CA certificates are used to issue device certificates to clients and validate the device certificates. If you no longer require a CA certificate, you can call this operation to deregister the certificate. If you want to continue using a deregistered CA certificate, you can call the ActiveCaCertificate operation to reactivate the certificate.
 *
 * @description *   Only ApsaraMQ for MQTT Enterprise Platinum Edition instances support this operation.
 * *   You can call this operation up to 500 times per second per Alibaba Cloud account. If you want to increase the limit, join the DingTalk group (ID: 35228338) to contact ApsaraMQ for MQTT technical support.
 * *   You can call this operation to deregister only CA certificates that are registered with ApsaraMQ for MQTT brokers. You can call the [ListCaCertificate](https://help.aliyun.com/document_detail/2604958.html) operation to query CA certificates that are registered with an ApsaraMQ for MQTT instance.
 *
 * @param request InactivateCaCertificateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return InactivateCaCertificateResponse
 */
async function inactivateCaCertificateWithOptions(request: InactivateCaCertificateRequest, runtime: $RuntimeOptions): InactivateCaCertificateResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.mqttInstanceId)) {
    query['MqttInstanceId'] = request.mqttInstanceId;
  }
  if (!$isNull(request.sn)) {
    query['Sn'] = request.sn;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'InactivateCaCertificate',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deregister a certificate authority (CA) certificate. ApsaraMQ for MQTT allows you to use X.509 certificates for authentication. When you connect an ApsaraMQ for MQTT client to an ApsaraMQ for MQTT broker, you can use the device certificate to implement authentication. CA certificates are used to issue device certificates to clients and validate the device certificates. If you no longer require a CA certificate, you can call this operation to deregister the certificate. If you want to continue using a deregistered CA certificate, you can call the ActiveCaCertificate operation to reactivate the certificate.
 *
 * @description *   Only ApsaraMQ for MQTT Enterprise Platinum Edition instances support this operation.
 * *   You can call this operation up to 500 times per second per Alibaba Cloud account. If you want to increase the limit, join the DingTalk group (ID: 35228338) to contact ApsaraMQ for MQTT technical support.
 * *   You can call this operation to deregister only CA certificates that are registered with ApsaraMQ for MQTT brokers. You can call the [ListCaCertificate](https://help.aliyun.com/document_detail/2604958.html) operation to query CA certificates that are registered with an ApsaraMQ for MQTT instance.
 *
 * @param request InactivateCaCertificateRequest
 * @return InactivateCaCertificateResponse
 */
async function inactivateCaCertificate(request: InactivateCaCertificateRequest): InactivateCaCertificateResponse {
  var runtime = new $RuntimeOptions{};
  return inactivateCaCertificateWithOptions(request, runtime);
}

model InactivateDeviceCertificateRequest {
  caSn?: string(name='CaSn', description='The serial number of the CA certificate to which the device certificate that you want to deregister belongs. The serial number is the unique identifier of a CA certificate.

The serial number of a CA certificate cannot exceed 128 bytes in size.

This parameter is required.', example='007269004887******'),
  deviceSn?: string(name='DeviceSn', description='The serial number of the device certificate that you want to deregister. The serial number is the unique identifier of a device.

This parameter is required.', example='356217374433******'),
  mqttInstanceId?: string(name='MqttInstanceId', description='The ID of the ApsaraMQ for MQTT instance to which the device certificate that you want to deregister is bound.

This parameter is required.', example='post-cn-7mz2d******'),
}

model InactivateDeviceCertificateResponseBody = {
  deviceSn?: string(name='DeviceSn', description='The serial number of the device certificate that is deregistered. The serial number is the unique identifier of a device certificate.', example='356217374433******'),
  requestId?: string(name='RequestId', description='The request ID.', example='020F6A43-19E6-4B6E-B846-44EB31DF****'),
}

model InactivateDeviceCertificateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: InactivateDeviceCertificateResponseBody(name='body'),
}

/**
 * @summary Deregisters a device certificate. Device certificates are digital certificates issued to clients by certificate authority (CA) root certificates. When you connect an ApsaraMQ for MQTT client to an ApsaraMQ for MQTT broker, the broker uses the device certificate to authenticate the client. If the client passes the authentication, the client and the broker can communicate with each other based on the encrypted private key in the device certificate. If the client fails the authentication, access requests from the client are denied by the client.
 *
 * @description *   Only ApsaraMQ for MQTT Enterprise Platinum Edition instances support this operation.
 * *   You can call this operation up to 500 times per second per Alibaba Cloud account. If you want to increase the limit, join the DingTalk group (ID: 35228338) to contact ApsaraMQ for MQTT technical support.
 *
 * @param request InactivateDeviceCertificateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return InactivateDeviceCertificateResponse
 */
async function inactivateDeviceCertificateWithOptions(request: InactivateDeviceCertificateRequest, runtime: $RuntimeOptions): InactivateDeviceCertificateResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.caSn)) {
    query['CaSn'] = request.caSn;
  }
  if (!$isNull(request.deviceSn)) {
    query['DeviceSn'] = request.deviceSn;
  }
  if (!$isNull(request.mqttInstanceId)) {
    query['MqttInstanceId'] = request.mqttInstanceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'InactivateDeviceCertificate',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deregisters a device certificate. Device certificates are digital certificates issued to clients by certificate authority (CA) root certificates. When you connect an ApsaraMQ for MQTT client to an ApsaraMQ for MQTT broker, the broker uses the device certificate to authenticate the client. If the client passes the authentication, the client and the broker can communicate with each other based on the encrypted private key in the device certificate. If the client fails the authentication, access requests from the client are denied by the client.
 *
 * @description *   Only ApsaraMQ for MQTT Enterprise Platinum Edition instances support this operation.
 * *   You can call this operation up to 500 times per second per Alibaba Cloud account. If you want to increase the limit, join the DingTalk group (ID: 35228338) to contact ApsaraMQ for MQTT technical support.
 *
 * @param request InactivateDeviceCertificateRequest
 * @return InactivateDeviceCertificateResponse
 */
async function inactivateDeviceCertificate(request: InactivateDeviceCertificateRequest): InactivateDeviceCertificateResponse {
  var runtime = new $RuntimeOptions{};
  return inactivateDeviceCertificateWithOptions(request, runtime);
}

model ListCaCertificateRequest {
  mqttInstanceId?: string(name='MqttInstanceId', description='The instance ID of the Cloud Message Queue MQTT version, indicating which instance\\\\"s CA certificates need to be viewed.

This parameter is required.', example='post-cn-7mz2d******'),
  pageNo?: string(name='PageNo', description='Indicates the page number of the returned results. The starting page is counted from 1.

This parameter is required.', example='2'),
  pageSize?: string(name='PageSize', description='The maximum number of query records to display per page. Value range: 1 to 100.

This parameter is required.', example='10'),
}

model ListCaCertificateResponseBody = {
  data?: {
    caCertificateVOS?: [ 
      {
        caContent?: string(name='CaContent', description='Content of the CA certificate. 
> \\\\n represents a new line.', example='-----BEGIN CERTIFICATE-----\\\\nMIIDuzCCAqdGVzdC5jbi1xaW5n******\\\\n-----END CERTIFICATE-----'),
        caName?: string(name='CaName', description='Name of the CA certificate', example='mqtt_ca'),
        registrationCode?: string(name='RegistrationCode', description='Registration code of the CA certificate', example='13274673-8f90-4630-bea1-9cccb25756ad2089******'),
        sn?: string(name='Sn', description='SN serial number of the CA certificate', example='007269004887******'),
        status?: string(name='Status', description='The status of the CA certificate. The values are as follows:
- **0**: Indicates that the certificate is in an inactive state. - **1**: Indicates that the certificate is in an active state.
> After the CA certificate is registered, it is in an active state by default.', example='1'),
        validBegin?: string(name='ValidBegin', description='The start time when the CA certificate becomes effective. The format is a Unix timestamp in milliseconds.', example='1654137303000'),
        validEnd?: string(name='ValidEnd', description='The end time when the CA certificate becomes effective. The format is a Unix timestamp in milliseconds.', example='1969497303000'),
        verificationContent?: string(name='VerificationContent', description='Verify the content of the certificate. 
> \\\\n represents a new line.', example='-----BEGIN CERTIFICATE-----\\\\nMIID/DCCAu+Y5sRMpp9tnd+4s******\\\\n-----END CERTIFICATE-----'),
      }
    ](name='CaCertificateVOS', description='Details of the CA certificate'),
    pageNo?: int32(name='PageNo', description='The current page number of the returned query records.', example='2'),
    pageSize?: int32(name='PageSize', description='The maximum number of results to display per page.', example='10'),
    total?: int32(name='Total', description='Maximum number of pages in the query result.', example='1'),
  }(name='Data', description='Query result.'),
  requestId?: string(name='RequestId', description='Public parameters, each request ID is unique and can be used for troubleshooting and problem localization.', example='020F6A43-19E6-4B6E-B846-44EB31DF****'),
}

model ListCaCertificateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListCaCertificateResponseBody(name='body'),
}

/**
 * @summary Queries all certificate authority (CA) certificates that are registered with an ApsaraMQ for MQTT instance. ApsaraMQ for MQTT allows you to use X.509 certificates for authentication. When you connect an ApsaraMQ for MQTT client to an ApsaraMQ for MQTT broker, you can use the device certificate to implement authentication. CA certificates are used to issue device certificates to clients and validate the device certificates.
 *
 * @description *   Only ApsaraMQ for MQTT Enterprise Platinum Edition instances support this operation.
 * *   You can call this operation up to 500 times per second per Alibaba Cloud account. If you want to increase the limit, join the DingTalk group (ID: 35228338) to contact ApsaraMQ for MQTT technical support.
 *
 * @param request ListCaCertificateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListCaCertificateResponse
 */
async function listCaCertificateWithOptions(request: ListCaCertificateRequest, runtime: $RuntimeOptions): ListCaCertificateResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListCaCertificate',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries all certificate authority (CA) certificates that are registered with an ApsaraMQ for MQTT instance. ApsaraMQ for MQTT allows you to use X.509 certificates for authentication. When you connect an ApsaraMQ for MQTT client to an ApsaraMQ for MQTT broker, you can use the device certificate to implement authentication. CA certificates are used to issue device certificates to clients and validate the device certificates.
 *
 * @description *   Only ApsaraMQ for MQTT Enterprise Platinum Edition instances support this operation.
 * *   You can call this operation up to 500 times per second per Alibaba Cloud account. If you want to increase the limit, join the DingTalk group (ID: 35228338) to contact ApsaraMQ for MQTT technical support.
 *
 * @param request ListCaCertificateRequest
 * @return ListCaCertificateResponse
 */
async function listCaCertificate(request: ListCaCertificateRequest): ListCaCertificateResponse {
  var runtime = new $RuntimeOptions{};
  return listCaCertificateWithOptions(request, runtime);
}

model ListDeviceCertificateRequest {
  mqttInstanceId?: string(name='MqttInstanceId', description='The instance ID of the Cloud Message Queue MQTT version, indicating which instance\\\\"s device certificates need to be viewed.

This parameter is required.', example='post-cn-7mz2d******'),
  pageNo?: string(name='PageNo', description='Indicates which page of the results to return. The starting page is counted from 1.

This parameter is required.', example='2'),
  pageSize?: string(name='PageSize', description='The maximum number of query records to display per page. Value range: 1 to 100.

This parameter is required.', example='10'),
}

model ListDeviceCertificateResponseBody = {
  data?: {
    deviceCertificateVOS?: [ 
      {
        caSn?: string(name='CaSn', description='The SN serial number of the CA certificate to which the device certificate belongs, used to uniquely identify a CA certificate.', example='00f26900ba87******'),
        deviceContent?: string(name='DeviceContent', description='Content of the device certificate.

 represents a new line.', example='-----BEGIN DEVICECERTIFICATE-----\\\\nMIIDuzCCAqdGVzdC5jbi1xaW5n******\\\\n-----END DEVICECERTIFICATE-----'),
        deviceName?: string(name='DeviceName', description='Name of the device certificate.', example='mqtt_device'),
        deviceSn?: string(name='DeviceSn', description='The SN serial number of the device certificate, used to uniquely identify a device certificate.', example='356217374433******'),
        status?: string(name='Status', description='The status of the device certificate. The values are as follows:
- 0: indicates that the certificate is in an inactive state. - 1: indicates that the certificate is in an active state.
After the device certificate is registered, it defaults to the active state.', example='1'),
        validBegin?: string(name='ValidBegin', description='The start time when the device certificate becomes effective. The format is a Unix timestamp in milliseconds.', example='1654137303000'),
        validEnd?: string(name='ValidEnd', description='The end time when the device certificate becomes effective. Formatted as a Unix timestamp in milliseconds.', example='1969497303000'),
      }
    ](name='DeviceCertificateVOS', description='Details of the device certificate.'),
    pageNo?: int32(name='PageNo', description='The current page number of the returned query records.', example='2'),
    pageSize?: int32(name='PageSize', description='The maximum number of results to display per page.', example='10'),
    total?: int32(name='Total', description='Maximum number of pages in the query result.', example='1'),
  }(name='Data', description='Query result.'),
  requestId?: string(name='RequestId', description='Public parameters, each request ID is unique and can be used for troubleshooting and problem localization.', example='020F6A43-19E6-4B6E-B846-44EB31DF****'),
}

model ListDeviceCertificateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDeviceCertificateResponseBody(name='body'),
}

/**
 * @summary Queries all device certificates that are registered with an ApsaraMQ for MQTT instance. Device certificates are digital certificates issued to clients by certificate authority (CA) root certificates. When you connect an ApsaraMQ for MQTT client to an ApsaraMQ for MQTT broker, the broker uses the device certificate to authenticate the client. If the client passes the authentication, the client and the broker can communicate with each other based on the encrypted private key in the device certificate. If the client fails the authentication, access requests from the client are denied by the client.
 *
 * @description *   Only ApsaraMQ for MQTT Enterprise Platinum Edition instances support this operation.
 * *   You can call this operation up to 500 times per second per Alibaba Cloud account. If you want to increase the limit, join the DingTalk group (ID: 35228338) to contact ApsaraMQ for MQTT technical support.
 *
 * @param request ListDeviceCertificateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDeviceCertificateResponse
 */
async function listDeviceCertificateWithOptions(request: ListDeviceCertificateRequest, runtime: $RuntimeOptions): ListDeviceCertificateResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListDeviceCertificate',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries all device certificates that are registered with an ApsaraMQ for MQTT instance. Device certificates are digital certificates issued to clients by certificate authority (CA) root certificates. When you connect an ApsaraMQ for MQTT client to an ApsaraMQ for MQTT broker, the broker uses the device certificate to authenticate the client. If the client passes the authentication, the client and the broker can communicate with each other based on the encrypted private key in the device certificate. If the client fails the authentication, access requests from the client are denied by the client.
 *
 * @description *   Only ApsaraMQ for MQTT Enterprise Platinum Edition instances support this operation.
 * *   You can call this operation up to 500 times per second per Alibaba Cloud account. If you want to increase the limit, join the DingTalk group (ID: 35228338) to contact ApsaraMQ for MQTT technical support.
 *
 * @param request ListDeviceCertificateRequest
 * @return ListDeviceCertificateResponse
 */
async function listDeviceCertificate(request: ListDeviceCertificateRequest): ListDeviceCertificateResponse {
  var runtime = new $RuntimeOptions{};
  return listDeviceCertificateWithOptions(request, runtime);
}

model ListDeviceCertificateByCaSnRequest {
  caSn?: string(name='CaSn', description='The SN serial number of the CA certificate to be queried, indicating which CA certificate\\\\"s registered device certificates are to be retrieved.

This parameter is required.', example='007269004887******'),
  mqttInstanceId?: string(name='MqttInstanceId', description='The instance ID bound to the CA certificate, which is the instance ID of the MQTT version of the cloud message queue.

This parameter is required.', example='post-cn-7mz2d******'),
  pageNo?: string(name='PageNo', description='Indicates the page number of the returned results. The starting page is counted from 1.

This parameter is required.', example='2'),
  pageSize?: string(name='PageSize', description='The maximum number of query records to display per page. Value range: 1 to 100.

This parameter is required.', example='10'),
}

model ListDeviceCertificateByCaSnResponseBody = {
  data?: {
    deviceCertificateVOS?: [ 
      {
        caSn?: string(name='CaSn', description='The SN serial number of the CA certificate to which the device certificate belongs, used to uniquely identify a CA certificate.', example='00f26900ba87******'),
        deviceContent?: string(name='DeviceContent', description='Content of the device certificate.

 represents a new line.', example='-----BEGIN DEVICECERTIFICATE-----\\\\nMIIDuzCCAqdGVzdC5jbi1xaW5n******\\\\n-----END DEVICECERTIFICATE-----'),
        deviceName?: string(name='DeviceName', description='Name of the device certificate.', example='mqtt_device'),
        deviceSn?: string(name='DeviceSn', description='The SN serial number of the device certificate, used to uniquely identify a device certificate.', example='356217374433******'),
        status?: string(name='Status', description='The status of the device certificate. The values are as follows:
- 0: indicates that the certificate is in an inactive state. 
- 1: indicates that the certificate is in an active state.

After the device certificate is registered, it is in an active state by default.', example='1'),
        validBegin?: string(name='ValidBegin', description='The start time when the device certificate becomes effective. The format is a Unix timestamp in milliseconds.', example='1654137303000'),
        validEnd?: string(name='ValidEnd', description='The end time when the device certificate becomes effective. The format is a Unix timestamp in milliseconds.', example='1969497303000'),
      }
    ](name='DeviceCertificateVOS', description='Details of the device certificate.'),
    pageNo?: int32(name='PageNo', description='The current page number of the returned query records.', example='2'),
    pageSize?: int32(name='PageSize', description='The maximum number of results to display per page.', example='10'),
    total?: int32(name='Total', description='Total number of query results.', example='1'),
  }(name='Data', description='Query result.'),
  requestId?: string(name='RequestId', description='Public parameters, each request ID is unique and can be used for troubleshooting and problem localization.', example='020F6A43-19E6-4B6E-B846-44EB31DF****'),
}

model ListDeviceCertificateByCaSnResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDeviceCertificateByCaSnResponseBody(name='body'),
}

/**
 * @summary Queries all device certificates that are issued by a certificate authority (CA) certificate and registered with ApsaraMQ for MQTT brokers. Device certificates are digital certificates issued to clients by CA root certificates. When you connect an ApsaraMQ for MQTT client to an ApsaraMQ for MQTT broker, the broker uses the device certificate to authenticate the client. If the client passes the authentication, the client and the broker can communicate with each other based on the encrypted private key in the device certificate. If the client fails the authentication, access requests from the client are denied by the client.
 *
 * @description *   Only ApsaraMQ for MQTT Enterprise Platinum Edition instances support this operation.
 * *   You can call this operation up to 500 times per second per Alibaba Cloud account. If you want to increase the limit, join the DingTalk group (ID: 35228338) to contact ApsaraMQ for MQTT technical support.
 *
 * @param request ListDeviceCertificateByCaSnRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDeviceCertificateByCaSnResponse
 */
async function listDeviceCertificateByCaSnWithOptions(request: ListDeviceCertificateByCaSnRequest, runtime: $RuntimeOptions): ListDeviceCertificateByCaSnResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListDeviceCertificateByCaSn',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries all device certificates that are issued by a certificate authority (CA) certificate and registered with ApsaraMQ for MQTT brokers. Device certificates are digital certificates issued to clients by CA root certificates. When you connect an ApsaraMQ for MQTT client to an ApsaraMQ for MQTT broker, the broker uses the device certificate to authenticate the client. If the client passes the authentication, the client and the broker can communicate with each other based on the encrypted private key in the device certificate. If the client fails the authentication, access requests from the client are denied by the client.
 *
 * @description *   Only ApsaraMQ for MQTT Enterprise Platinum Edition instances support this operation.
 * *   You can call this operation up to 500 times per second per Alibaba Cloud account. If you want to increase the limit, join the DingTalk group (ID: 35228338) to contact ApsaraMQ for MQTT technical support.
 *
 * @param request ListDeviceCertificateByCaSnRequest
 * @return ListDeviceCertificateByCaSnResponse
 */
async function listDeviceCertificateByCaSn(request: ListDeviceCertificateByCaSnRequest): ListDeviceCertificateByCaSnResponse {
  var runtime = new $RuntimeOptions{};
  return listDeviceCertificateByCaSnWithOptions(request, runtime);
}

model ListDeviceCredentialClientIdRequest {
  groupId?: string(name='GroupId', description='Group ID of the MQTT version of the micro message queue.

This parameter is required.', example='GID_xxx'),
  instanceId?: string(name='InstanceId', description='The ID of the Cloud Message Queue MQTT version instance, which must match the actual instance ID used by the client. You can obtain this ID from the **Instance Details** page in the console.

This parameter is required.', example='mqtt-xxxxxxxx'),
  nextToken?: string(name='NextToken', description='Token for starting the next page query.', example='FFdXXXXXWa'),
  pageNo?: string(name='PageNo', description='Indicates the page number of the returned results. The starting page is counted from 1.', example='1'),
  pageSize?: string(name='PageSize', description='The maximum number of query records to display per page. 
Value range: 1 to 100.

This parameter is required.', example='100'),
}

model ListDeviceCredentialClientIdResponseBody = {
  deviceCredentialClientIdList?: {
    clientIdList?: [ string ](name='ClientIdList', description='Client list.'),
    nextToken?: string(name='NextToken', description='Indicates whether there is a token (Token) for the next query. Values: 
- For the first query and when there is no next query, this field does not need to be filled. 
- If there is a next query, the value should be the NextToken returned from the previous API call.', example='634dxxxxx75b5f'),
    pageNo?: string(name='PageNo', description='The current page number of the returned query records.', example='1'),
    pageSize?: string(name='PageSize', description='The maximum number of results to display per page.', example='100'),
    total?: string(name='Total', description='Total number of query results.', example='10'),
  }(name='DeviceCredentialClientIdList', description='Returns the information list.'),
  requestId?: string(name='RequestId', description='Public parameters, each request ID is unique and can be used for troubleshooting and problem localization.', example='020F6A43-19E6-4B6E-B846-44EB31DF****'),
}

model ListDeviceCredentialClientIdResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDeviceCredentialClientIdResponseBody(name='body'),
}

/**
 * @summary Queries clients that have applied for access credentials in unique-certificate-per-device authentication mode in an ApsaraMQ for MQTT instance.
 *
 * @param request ListDeviceCredentialClientIdRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDeviceCredentialClientIdResponse
 */
async function listDeviceCredentialClientIdWithOptions(request: ListDeviceCredentialClientIdRequest, runtime: $RuntimeOptions): ListDeviceCredentialClientIdResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!$isNull(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListDeviceCredentialClientId',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries clients that have applied for access credentials in unique-certificate-per-device authentication mode in an ApsaraMQ for MQTT instance.
 *
 * @param request ListDeviceCredentialClientIdRequest
 * @return ListDeviceCredentialClientIdResponse
 */
async function listDeviceCredentialClientId(request: ListDeviceCredentialClientIdRequest): ListDeviceCredentialClientIdResponse {
  var runtime = new $RuntimeOptions{};
  return listDeviceCredentialClientIdWithOptions(request, runtime);
}

model ListGroupIdRequest {
  instanceId?: string(name='InstanceId', description='The ID of the ApsaraMQ for MQTT instance whose groups you want to query.

This parameter is required.', example='mqtt-cn-0pp1ldu****'),
}

model ListGroupIdResponseBody = {
  data?: [ 
    {
      createTime?: long(name='CreateTime', description='The time when the group was created.', example='1564577317000'),
      groupId?: string(name='GroupId', description='The queried group that belongs to the ApsaraMQ for MQTT instance.', example='GID_test1'),
      independentNaming?: boolean(name='IndependentNaming', description='Indicates whether a separate namespace is configured for the ApsaraMQ for MQTT instance. Valid values:

*   **true**: A separate namespace is configured for the ApsaraMQ for MQTT instance. Resource names must be unique within an ApsaraMQ for MQTT instance but can be the same across ApsaraMQ for MQTT instances.
*   **false**: No separate namespace is configured for the ApsaraMQ for MQTT instance. Resource names must be globally unique within an ApsaraMQ for MQTT instance and across ApsaraMQ for MQTT instances.', example='true'),
      instanceId?: string(name='InstanceId', description='The ID of the ApsaraMQ for MQTT instance to which the group belongs.', example='post-cn-45910tj****'),
      updateTime?: long(name='UpdateTime', description='The time when the group was last updated.', example='1564577317000'),
    }
  ](name='Data', description='The details of a queried group.'),
  requestId?: string(name='RequestId', description='The request ID. This parameter is a common parameter.', example='95996EEB-D894-44FA-A87C-940F5CD9****'),
}

model ListGroupIdResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListGroupIdResponseBody(name='body'),
}

/**
 * @summary Queries all groups on an ApsaraMQ for MQTT instance.
 *
 * @description Each successful call to the **ListGroupId** operation increases the messaging transactions per second (TPS) by one. This affects the billing of your instance. For more information, see [Billing rules](https://help.aliyun.com/document_detail/52819.html).
 *
 * @param request ListGroupIdRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListGroupIdResponse
 */
async function listGroupIdWithOptions(request: ListGroupIdRequest, runtime: $RuntimeOptions): ListGroupIdResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListGroupId',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries all groups on an ApsaraMQ for MQTT instance.
 *
 * @description Each successful call to the **ListGroupId** operation increases the messaging transactions per second (TPS) by one. This affects the billing of your instance. For more information, see [Billing rules](https://help.aliyun.com/document_detail/52819.html).
 *
 * @param request ListGroupIdRequest
 * @return ListGroupIdResponse
 */
async function listGroupId(request: ListGroupIdRequest): ListGroupIdResponse {
  var runtime = new $RuntimeOptions{};
  return listGroupIdWithOptions(request, runtime);
}

model ListInstancesRequest {
  tags?: string(name='Tags', example='[{"key":"test","value":"test"}]'),
}

model ListInstancesResponseBody = {
  code?: string(name='Code', example='200'),
  instances?: [ 
    {
      createTime?: long(name='CreateTime', example='1739345768000'),
      expireTime?: long(name='ExpireTime', example='1741795200000'),
      instanceId?: string(name='InstanceId', example='mqtt-cn-xxxxxxx'),
      instanceName?: string(name='InstanceName', example='mqtt-cn-xxxxxxx'),
      instanceStatus?: int32(name='InstanceStatus', example='5'),
      instanceType?: int32(name='InstanceType', example='4'),
      kernelVersion?: string(name='KernelVersion', example='V3.3.0'),
      mqttTags?: [ 
        {
          tagKey?: string(name='TagKey', example='test'),
          tagValue?: string(name='TagValue', example='test'),
        }
      ](name='MqttTags'),
      orderId?: string(name='OrderId', example='245949616640095'),
      regionId?: string(name='RegionId', example='cn-shenzhen'),
      specific?: string(name='Specific', example='mqtt.p2.1xlarge'),
    }
  ](name='Instances'),
  message?: string(name='Message', example='operation success.'),
  requestId?: string(name='RequestId', description='Id of the request', example='294F5B26-FADF-41D0-BE68-14ABE4EB****'),
  success?: string(name='Success', example='true'),
}

model ListInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListInstancesResponseBody(name='body'),
}

/**
 * @summary 
 *
 * @param request ListInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListInstancesResponse
 */
async function listInstancesWithOptions(request: ListInstancesRequest, runtime: $RuntimeOptions): ListInstancesResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.tags)) {
    query['Tags'] = request.tags;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListInstances',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary 
 *
 * @param request ListInstancesRequest
 * @return ListInstancesResponse
 */
async function listInstances(request: ListInstancesRequest): ListInstancesResponse {
  var runtime = new $RuntimeOptions{};
  return listInstancesWithOptions(request, runtime);
}

model ListTagResourcesRequest {
  nextToken?: string(name='NextToken', example='AAAAAaFXUH1VTHnBlds7StUakOQ='),
  resourceId?: [ string ](name='ResourceId'),
  resourceType?: string(name='ResourceType', description='This parameter is required.', example='instance'),
  tag?: [ 
    {
      key?: string(name='Key', example='test'),
      value?: string(name='Value', example='test'),
    }
  ](name='Tag'),
}

model ListTagResourcesResponseBody = {
  code?: string(name='Code', example='200'),
  message?: string(name='Message', example='operation success.'),
  nextToken?: string(name='NextToken', example='AAAAAaFXUH1VTHnBlds7StUakOQ='),
  requestId?: string(name='RequestId', description='Id of the request', example='34063BCA-0946-49C1-B824-2ED2C905****'),
  success?: string(name='Success', example='true'),
  tagResources?: [ 
    {
      resourceId?: string(name='ResourceId', example='mqtt-cn-5yd3xxx'),
      resourceType?: string(name='ResourceType', example='instance'),
      tagKey?: string(name='TagKey', example='test'),
      tagValue?: string(name='TagValue', example='test'),
    }
  ](name='TagResources'),
}

model ListTagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTagResourcesResponseBody(name='body'),
}

/**
 * @summary 
 *
 * @param request ListTagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTagResourcesResponse
 */
async function listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: $RuntimeOptions): ListTagResourcesResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!$isNull(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!$isNull(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!$isNull(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListTagResources',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary 
 *
 * @param request ListTagResourcesRequest
 * @return ListTagResourcesResponse
 */
async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new $RuntimeOptions{};
  return listTagResourcesWithOptions(request, runtime);
}

model QueryCustomAuthConnectBlackRequest {
  clientId?: string(name='ClientId', description='The ID of the client to be queried.', example='GID_test@@@test'),
  instanceId?: string(name='InstanceId', description='The ID of the ApsaraMQ for MQTT instance.

This parameter is required.', example='post-111****'),
  nextToken?: string(name='NextToken', description='The token that marks the end position of the previous returned page. To obtain the next batch of data, call the operation again by using the value of NextToken returned by the previous request. If you call this operation for the first time or want to query all results, set NextToken to an empty string.', example='xOfRU60sGEwN1OlFBIL8Ew=='),
  size?: int32(name='Size', description='The number of clients to be queried. Maximum value: 100.

This parameter is required.', example='100'),
}

model QueryCustomAuthConnectBlackResponseBody = {
  code?: int32(name='Code', description='The HTTP status code. The status code 200 indicates that the request is successful. Other status codes indicate that the request failed. For a list of error codes, see Error codes.', example='200'),
  data?: {
    nextToken?: string(name='NextToken', description='The pagination token that is used in the next request to retrieve a new page of results.', example='AAAAAZ0cM0HTqLXvgm7oMHWXcvc='),
    results?: [ 
      {
        clientId?: string(name='ClientId', description='The client ID.', example='GID_TEST@@@test'),
        effect?: string(name='Effect', description='Indicates whether to allow or deny access.', example='ALLOW'),
        permitAction?: string(name='PermitAction', description='The authorized permissions.', example='CONNECT'),
      }
    ](name='Results', description='The returned results.'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned message.', example='operation success.'),
  requestId?: string(name='RequestId', description='The request ID.', example='020F6A43-19E6-4B6E-B846-44EB31DF****'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values: true and false.', example='True'),
}

model QueryCustomAuthConnectBlackResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryCustomAuthConnectBlackResponseBody(name='body'),
}

/**
 * @summary Queries a client ID in a connection blacklist.
 *
 * @param request QueryCustomAuthConnectBlackRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryCustomAuthConnectBlackResponse
 */
async function queryCustomAuthConnectBlackWithOptions(request: QueryCustomAuthConnectBlackRequest, runtime: $RuntimeOptions): QueryCustomAuthConnectBlackResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'QueryCustomAuthConnectBlack',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries a client ID in a connection blacklist.
 *
 * @param request QueryCustomAuthConnectBlackRequest
 * @return QueryCustomAuthConnectBlackResponse
 */
async function queryCustomAuthConnectBlack(request: QueryCustomAuthConnectBlackRequest): QueryCustomAuthConnectBlackResponse {
  var runtime = new $RuntimeOptions{};
  return queryCustomAuthConnectBlackWithOptions(request, runtime);
}

model QueryCustomAuthIdentityRequest {
  clientId?: string(name='ClientId', description='The client ID if you set IdentityType to CLIENT.', example='GID_test@@@test'),
  identityType?: string(name='IdentityType', description='The identity type.', example='USER'),
  instanceId?: string(name='InstanceId', description='The ID of the ApsaraMQ for MQTT instance.

This parameter is required.', example='post-111****'),
  nextToken?: string(name='NextToken', description='The token that marks the end position of the previous returned page. To obtain the next batch of data, call the operation again by using the value of NextToken returned by the previous request. If you call this operation for the first time or want to query all results, set NextToken to an empty string.', example='eyJhY2NvdW50IjoiMTM4MTcxODk3NDQzMjQ1OSIsImV2ZW50SWQiOiJGMkUxOUE3QS1FM0Q0LTVCOEYtQkU4OS1CNkMyM0RBM0UyRjIiLCJsb2dJZCI6IjY2LTEzODE3MTg5NzQ0MzI0NTkiLCJydyI6IlciLCJ0aW1lIjoxNjc4MzI2MTI1MDAwfQ'),
  size?: int32(name='Size', description='The number of identities to be queried. Maximum value: 100.

This parameter is required.', example='100'),
  username?: string(name='Username', description='The username.', example='test'),
}

model QueryCustomAuthIdentityResponseBody = {
  code?: int32(name='Code', description='The HTTP status code. The status code 200 indicates that the request is successful. Other status codes indicate that the request failed. For a list of error codes, see Error codes.', example='200'),
  data?: {
    nextToken?: string(name='NextToken', description='If excess return values exist, this parameter is returned.', example='AAAAAXA+GzVqTutYpgkFjBrchKzuvSbpuTqtt6OF9tsC9QnJ'),
    results?: [ 
      {
        clientId?: string(name='ClientId', description='The client ID if IdentityType is set to CLIENT.', example='GID_ICP@@@4d378084'),
        identityType?: string(name='IdentityType', description='The identity type. Valid values:

*   USER
*   CLIENT', example='USER'),
        secret?: string(name='Secret', description='The AccessKey secret.', example='62a5916d71767185b48907d85c2efae2'),
        signMode?: string(name='SignMode', description='The signature verification mode. ORIGIN: compares the password and the AccessKey secret. SIGNED: uses the HMAC_SHA1 algorithm to sign the client ID to obtain a password and then compares the password.', example='SIGNED'),
        username?: string(name='Username', description='The username.', example='test'),
      }
    ](name='Results', description='The returned results.'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned message.', example='operation success.'),
  requestId?: string(name='RequestId', description='The request ID.', example='11568B5B-13A8-4E72-9DBA-3A14F7D3****'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values: true and false.', example='True'),
}

model QueryCustomAuthIdentityResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryCustomAuthIdentityResponseBody(name='body'),
}

/**
 * @summary Queries the information about custom identity authentication.
 *
 * @param request QueryCustomAuthIdentityRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryCustomAuthIdentityResponse
 */
async function queryCustomAuthIdentityWithOptions(request: QueryCustomAuthIdentityRequest, runtime: $RuntimeOptions): QueryCustomAuthIdentityResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'QueryCustomAuthIdentity',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about custom identity authentication.
 *
 * @param request QueryCustomAuthIdentityRequest
 * @return QueryCustomAuthIdentityResponse
 */
async function queryCustomAuthIdentity(request: QueryCustomAuthIdentityRequest): QueryCustomAuthIdentityResponse {
  var runtime = new $RuntimeOptions{};
  return queryCustomAuthIdentityWithOptions(request, runtime);
}

model QueryCustomAuthPermissionRequest {
  identity?: string(name='Identity', description='The username or client ID.', example='test'),
  identityType?: string(name='IdentityType', description='The identity type.', example='USER'),
  instanceId?: string(name='InstanceId', description='The ID of the ApsaraMQ for MQTT instance.

This parameter is required.', example='post-cn-0pp12gl****'),
  nextToken?: string(name='NextToken', description='The token that marks the end position of the previous returned page. To obtain the next batch of data, call the operation again by using the value of NextToken returned by the previous request. If you call this operation for the first time or want to query all results, set NextToken to an empty string.', example='AAAAAThmKW2HkRgzo4G7IRRTK2fC6zZmAk6y0bwoNPFOOcSP'),
  size?: int32(name='Size', description='The number of queries to be returned. Maximum value: 100.

This parameter is required.', example='100'),
  topic?: string(name='Topic', description='The topic whose authorization information you want to query. Multi-level topics and wildcard characters are supported.', example='test'),
}

model QueryCustomAuthPermissionResponseBody = {
  code?: int32(name='Code', description='The HTTP status code.', example='200'),
  data?: {
    nextToken?: string(name='NextToken', description='The token that marks the end position of the previous returned page. To obtain the next batch of data, call the operation again by using the value of NextToken returned by the previous request. If you call this operation for the first time or want to query all results, set NextToken to an empty string.', example='AAAAAV/vsqTyeMlX1MIk7/b6NrZLIlsSVf49O04ac7HAmlBoaYspakK7ZZkR3vRDp5Y9Nz0EmuWYrtF+1qkUwuJzPk/qEto/FGxl5Kd+qdwNt3t8'),
    results?: [ 
      {
        effect?: string(name='Effect', description='Indicates whether to allow or deny access.', example='ALLOW'),
        identity?: string(name='Identity', description='The username or client ID.', example='test'),
        identityType?: string(name='IdentityType', description='The identity type. Valid values:

*   USER
*   CLIENT', example='USER'),
        permitAction?: string(name='PermitAction', description='The authorized permissions.', example='PUB_SUB'),
        topic?: string(name='Topic', description='The topic name. Multi-level topics and wildcard characters are supported.', example='test'),
      }
    ](name='Results', description='The response results.'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned message.', example='operation success.'),
  requestId?: string(name='RequestId', description='The request ID.', example='63309FDB-ED6C-46AE-B31C-A172FBA0****'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values: true and false.', example='True'),
}

model QueryCustomAuthPermissionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryCustomAuthPermissionResponseBody(name='body'),
}

/**
 * @summary Queries the authorization information about a topic.
 *
 * @param request QueryCustomAuthPermissionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryCustomAuthPermissionResponse
 */
async function queryCustomAuthPermissionWithOptions(request: QueryCustomAuthPermissionRequest, runtime: $RuntimeOptions): QueryCustomAuthPermissionResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'QueryCustomAuthPermission',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the authorization information about a topic.
 *
 * @param request QueryCustomAuthPermissionRequest
 * @return QueryCustomAuthPermissionResponse
 */
async function queryCustomAuthPermission(request: QueryCustomAuthPermissionRequest): QueryCustomAuthPermissionResponse {
  var runtime = new $RuntimeOptions{};
  return queryCustomAuthPermissionWithOptions(request, runtime);
}

model QueryMqttTraceDeviceRequest {
  beginTime?: long(name='BeginTime', description='The beginning of the time range to query. The value of this parameter is a UNIX timestamp in milliseconds.

This parameter is required.', example='1621580400000'),
  clientId?: string(name='ClientId', description='The client ID of the device whose trace you want to query.

This parameter is required.', example='GID_test@@@producer'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Pages start from page 1. If the input parameter value is greater than the total number of pages, the returned result is empty.

This parameter is required.', example='1'),
  endTime?: long(name='EndTime', description='The end of the time range to query. The value of this parameter is a UNIX timestamp in milliseconds.

This parameter is required.', example='1621584000000'),
  instanceId?: string(name='InstanceId', description='The ID of the ApsaraMQ for MQTT instance. The ID must be consistent with the ID of the instance that the ApsaraMQ for MQTT client uses. You can view the instance ID in the **Basic Information** section on the **Instance Details** page that corresponds to the instance in the ApsaraMQ for MQTT console.

This parameter is required.', example='mqtt-cn-i7m26mf****'),
  mqttRegionId?: string(name='MqttRegionId', description='The ID of the region where the ApsaraMQ for MQTT instance resides. For more information, see [Endpoints](https://help.aliyun.com/document_detail/181438.html).

This parameter is required.', example='cn-hangzhou'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 100.

This parameter is required.', example='5'),
  reverse?: boolean(name='Reverse', description='Specifies whether the returned results are displayed in reverse chronological order. Valid values:

*   **true**: The returned results are displayed in reverse time order of actions on the device. This means that the information about the latest action on the device is displayed as the first entry and the information about the earliest action on the device is displayed as the last entry.
*   **false**: The returned results are displayed in time order of actions on the device. This means that the information about the earliest action on the device is displayed as the first entry and the information about the latest action on the device is displayed as the last entry.

If you do not specify this parameter, the returned results are displayed in time order of actions on the device by default.', example='false'),
}

model QueryMqttTraceDeviceResponseBody = {
  currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
  deviceInfoList?: [ 
    {
      action?: string(name='Action', description='The action on the device. Valid values:

*   **connect**: The ApsaraMQ for MQTT client requests a connection to the ApsaraMQ for MQTT broker.
*   **close**: The TCP connection is closed.
*   **disconnect**: The ApsaraMQ for MQTT client requests a disconnection from the ApsaraMQ for MQTT broker.', example='connect'),
      actionCode?: string(name='ActionCode', description='The returned code for the action on the device. Valid values:

*   **mqtt.trace.action.connect**: This value is returned if the value of Action is **connect**.
*   **mqtt.trace.action.close**: This value is returned if the value of Action is **close**.
*   **mqtt.trace.action.disconnect**: This value is returned if the value of Action is **disconnect**.', example='mqtt.trace.action.connect'),
      actionInfo?: string(name='ActionInfo', description='The returned information for the action on the device. Valid values:

*   **accepted**: The ApsaraMQ for MQTT broker accepts the connection request from the ApsaraMQ for MQTT client.
*   **not authorized**: The TCP connection is closed because the permission verification of the client to access the instance fails.
*   **clientId conflict**: The TCP connection is closed due to a conflict in the ID of the ApsaraMQ for MQTT client.
*   **resource auth failed**: The TCP connection is closed because the permission verification for the ApsaraMQ for MQTT client to access the topic or group fails.
*   **no heart**: The TCP connection is closed because no heartbeat is detected on the client.
*   **closed by client**: The TCP connection is closed because an exception occurs on the client.
*   **disconnected by client**: The client requests a disconnection.
*   **invalid param**: The TCP connection is closed due to invalid request parameters.
*   **Socket IOException**: The TCP connection is closed due to network jitter or packet loss.', example='accept'),
      channelId?: string(name='ChannelId', description='The connection ID.', example='c69fe839209547fa9d073781b9cd****'),
      time?: string(name='Time', description='The time when the action occurred on the device.', example='2021-05-21 15:51:54.867'),
    }
  ](name='DeviceInfoList', description='The details of the action on the device.'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='2'),
  requestId?: string(name='RequestId', description='The request ID. You can use the ID to troubleshoot issues. This parameter is a common parameter.', example='317076B7-F946-46BC-A98F-4CF9777C****'),
  total?: long(name='Total', description='The total number of returned actions on the device.', example='3'),
}

model QueryMqttTraceDeviceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMqttTraceDeviceResponseBody(name='body'),
}

/**
 * @summary Queries the trace of a device that corresponds to an ApsaraMQ for MQTT client by page. When the status of a device is abnormal, you can call this operation to query the connection history of the device. This helps you efficiently troubleshoot issues.
 *
 * @description *   Each successful call to the **QueryMqttTraceDevice** operation increases the messaging transactions per second (TPS) by one. This affects the billing of your instance. For more information, see [Billing rules](https://help.aliyun.com/document_detail/52819.html).
 * *   You can call this operation up to 500 times per second per account. If the limit is exceeded, throttling is triggered. This may affect your business. We recommend that you take note of this limit when you call this operation. For more information, see [Limits on QPS](https://help.aliyun.com/document_detail/163047.html).
 *
 * @param request QueryMqttTraceDeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryMqttTraceDeviceResponse
 */
async function queryMqttTraceDeviceWithOptions(request: QueryMqttTraceDeviceRequest, runtime: $RuntimeOptions): QueryMqttTraceDeviceResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.beginTime)) {
    query['BeginTime'] = request.beginTime;
  }
  if (!$isNull(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!$isNull(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!$isNull(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.mqttRegionId)) {
    query['MqttRegionId'] = request.mqttRegionId;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.reverse)) {
    query['Reverse'] = request.reverse;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'QueryMqttTraceDevice',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the trace of a device that corresponds to an ApsaraMQ for MQTT client by page. When the status of a device is abnormal, you can call this operation to query the connection history of the device. This helps you efficiently troubleshoot issues.
 *
 * @description *   Each successful call to the **QueryMqttTraceDevice** operation increases the messaging transactions per second (TPS) by one. This affects the billing of your instance. For more information, see [Billing rules](https://help.aliyun.com/document_detail/52819.html).
 * *   You can call this operation up to 500 times per second per account. If the limit is exceeded, throttling is triggered. This may affect your business. We recommend that you take note of this limit when you call this operation. For more information, see [Limits on QPS](https://help.aliyun.com/document_detail/163047.html).
 *
 * @param request QueryMqttTraceDeviceRequest
 * @return QueryMqttTraceDeviceResponse
 */
async function queryMqttTraceDevice(request: QueryMqttTraceDeviceRequest): QueryMqttTraceDeviceResponse {
  var runtime = new $RuntimeOptions{};
  return queryMqttTraceDeviceWithOptions(request, runtime);
}

model QueryMqttTraceMessageOfClientRequest {
  beginTime?: long(name='BeginTime', description='The beginning of the time range to query. The value of this parameter is a UNIX timestamp in milliseconds.

This parameter is required.', example='1618646400000'),
  clientId?: string(name='ClientId', description='The client ID of the device whose messages you want to query.

This parameter is required.', example='GID_test@@@producer'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Pages start from page 1. If the input parameter value is greater than the total number of pages, the returned result is empty.

This parameter is required.', example='1'),
  endTime?: long(name='EndTime', description='The end of the time range to query. The value of this parameter is a UNIX timestamp in milliseconds.

This parameter is required.', example='1621591200000'),
  instanceId?: string(name='InstanceId', description='The ID of the ApsaraMQ for MQTT instance. The ID must be consistent with the ID of the instance that the ApsaraMQ for MQTT client uses. You can view the instance ID in the **Basic Information** section of the **Instance Details** page that corresponds to the instance in the ApsaraMQ for MQTT console.

This parameter is required.', example='mqtt-cn-i7m26mf****'),
  mqttRegionId?: string(name='MqttRegionId', description='The ID of the region where the ApsaraMQ for MQTT instance resides. For more information, see [Endpoints](https://help.aliyun.com/document_detail/181438.html).

This parameter is required.', example='cn-hangzhou'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 100.

This parameter is required.', example='5'),
  reverse?: boolean(name='Reverse', description='Specifies whether the returned results are displayed in reverse chronological order. Valid values:

*   **true**: The returned results are displayed in reverse order of the time when messages are sent or received. This means that the latest sent or received message is displayed as the first entry and the earliest sent or received message is displayed as the last entry.
*   **false**: The returned results are displayed in order of the time when messages are sent or received. This means that the earliest sent or received message is displayed as the first entry and the latest sent or received message is displayed as the last entry.

If this parameter is not specified, the returned results are displayed in order of the time when messages are sent or received.', example='false'),
}

model QueryMqttTraceMessageOfClientResponseBody = {
  currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
  messageOfClientList?: [ 
    {
      action?: string(name='Action', description='The action on the message. Valid values:

*   **pub_mqtt**: The ApsaraMQ for MQTT client sends the message.
*   **sub**: The ApsaraMQ for MQTT client subscribes to the message.
*   **push_offline**: The ApsaraMQ for MQTT broker pushes the offline message to the ApsaraMQ for MQTT client.', example='pub_mqtt'),
      actionCode?: string(name='ActionCode', description='The returned code for the action on the message. Valid values:

*   **mqtt.trace.action.msg.pub.mqtt**: This value is returned if the value of Action is **pub_mqtt**.
*   **mqtt.trace.action.msg.sub**: This value is returned if the value of Action is **sub**.
*   **mqtt.trace.action.msg.push.offline**: This value is returned if the value of Action is **push_offline**.', example='mqtt.trace.action.msg.pub.mqtt'),
      actionInfo?: string(name='ActionInfo', description='The information returned for the action on the message. Valid values:

*   **Pub From Mqtt Client**: This value is returned if the value of Action is **pub_mqtt**.
*   **Push To Mqtt Client**: This value is returned if the value of Action is **sub**.
*   **Push Offline Msg To Mqtt Client**: This value is returned if the value of Action is **push_offline**.', example='Pub From Mqtt Client'),
      clientId?: string(name='ClientId', description='The client ID of the device.', example='GID_test@@@producer'),
      msgId?: string(name='MsgId', description='The message ID.', example='AC1EC0030EAB78308DB16A3EC773****'),
      time?: string(name='Time', description='The time when the message was sent or received.', example='2021-05-21 15:08:19.234'),
    }
  ](name='MessageOfClientList', description='The returned messages.'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='10'),
  requestId?: string(name='RequestId', description='The request ID. You can use the ID to troubleshoot issues. This parameter is a common parameter.', example='B096B9D6-62F3-4567-BB59-58D1362E****'),
  total?: long(name='Total', description='The total number of messages returned.', example='5'),
}

model QueryMqttTraceMessageOfClientResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMqttTraceMessageOfClientResponseBody(name='body'),
}

/**
 * @summary Queries messages on a device within a specific period of time. If a message is not sent or received as expected, you can call this operation to query the messaging status of the message to efficiently troubleshoot issues.
 *
 * @description *   Each successful call to the **QueryMqttTraceMessageOfClient** operation increases the messaging transactions per second (TPS) by one. This affects the billing of your instance. For more information, see [Billing rules](https://help.aliyun.com/document_detail/52819.html).
 * *   You can call this operation up to 500 times per second per account. If the limit is exceeded, throttling is triggered. This may affect your business. We recommend that you take note of this limit when you call this operation. For more information, see [Limits on QPS](https://help.aliyun.com/document_detail/163047.html).
 *
 * @param request QueryMqttTraceMessageOfClientRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryMqttTraceMessageOfClientResponse
 */
async function queryMqttTraceMessageOfClientWithOptions(request: QueryMqttTraceMessageOfClientRequest, runtime: $RuntimeOptions): QueryMqttTraceMessageOfClientResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.beginTime)) {
    query['BeginTime'] = request.beginTime;
  }
  if (!$isNull(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!$isNull(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!$isNull(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.mqttRegionId)) {
    query['MqttRegionId'] = request.mqttRegionId;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.reverse)) {
    query['Reverse'] = request.reverse;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'QueryMqttTraceMessageOfClient',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries messages on a device within a specific period of time. If a message is not sent or received as expected, you can call this operation to query the messaging status of the message to efficiently troubleshoot issues.
 *
 * @description *   Each successful call to the **QueryMqttTraceMessageOfClient** operation increases the messaging transactions per second (TPS) by one. This affects the billing of your instance. For more information, see [Billing rules](https://help.aliyun.com/document_detail/52819.html).
 * *   You can call this operation up to 500 times per second per account. If the limit is exceeded, throttling is triggered. This may affect your business. We recommend that you take note of this limit when you call this operation. For more information, see [Limits on QPS](https://help.aliyun.com/document_detail/163047.html).
 *
 * @param request QueryMqttTraceMessageOfClientRequest
 * @return QueryMqttTraceMessageOfClientResponse
 */
async function queryMqttTraceMessageOfClient(request: QueryMqttTraceMessageOfClientRequest): QueryMqttTraceMessageOfClientResponse {
  var runtime = new $RuntimeOptions{};
  return queryMqttTraceMessageOfClientWithOptions(request, runtime);
}

model QueryMqttTraceMessagePublishRequest {
  beginTime?: long(name='BeginTime', description='The beginning of the time range to query. The value of this parameter is a UNIX timestamp in milliseconds.

This parameter is required.', example='1618646400000'),
  endTime?: long(name='EndTime', description='The end of the time range to query. The value of this parameter is a UNIX timestamp in milliseconds.

This parameter is required.', example='1621591200000'),
  instanceId?: string(name='InstanceId', description='The ID of the ApsaraMQ for MQTT instance. The ID must be consistent with the ID of the instance that the ApsaraMQ for MQTT client uses. You can view the instance ID in the **Basic Information** section on the **Instance Details** page that corresponds to the instance in the ApsaraMQ for MQTT console.

This parameter is required.', example='mqtt-cn-i7m26mf****'),
  mqttRegionId?: string(name='MqttRegionId', description='The ID of the region where the ApsaraMQ for MQTT instance resides. For more information, see [Endpoints](https://help.aliyun.com/document_detail/181438.html).

This parameter is required.', example='cn-hangzhou'),
  msgId?: string(name='MsgId', description='The message ID.

This parameter is required.', example='AC1EC0030EAB78308DB16A3EC773****'),
}

model QueryMqttTraceMessagePublishResponseBody = {
  messageTraceLists?: [ 
    {
      action?: string(name='Action', description='The action on the message. Valid values:

*   **pub_mqtt**: indicates that the message was sent by an ApsaraMQ for MQTT client.
*   **pub_mq**: indicates that the message was sent by an ApsaraMQ for RocketMQ client.', example='pub_mqtt'),
      actionCode?: string(name='ActionCode', description='The returned code for the action on the message. Valid values:

*   **mqtt.trace.action.msg.pub.mqtt**: This value is returned if the value of Action is **pub_mqtt**.
*   **mqtt.trace.action.msg.pub.mq**: This value is returned if the value of Action is **pub_mq**.', example='mqtt.trace.action.msg.pub.mqtt'),
      actionInfo?: string(name='ActionInfo', description='The returned information for the action on the message. Valid values:

*   **Pub From Mqtt Client**: This value is returned if the value of Action is **pub_mqtt**.
*   **Pub From MQ**: This value is returned if the value of Action is **pub_mq**.', example='Pub From Mqtt Client'),
      clientId?: string(name='ClientId', description='The ID of the client that sends the message.', example='GID_test@@@producer'),
      msgId?: string(name='MsgId', description='The message ID.', example='AC1EC0030EAB78308DB16A3EC773BD95'),
      time?: string(name='Time', description='The time when the message was sent.', example='2021-05-21 15:08:19.210'),
    }
  ](name='MessageTraceLists', description='The message traces.'),
  requestId?: string(name='RequestId', description='The request ID. You can use the ID to troubleshoot issues. This parameter is a common parameter.', example='69AD5550-BF22-438A-9202-A6E89185****'),
}

model QueryMqttTraceMessagePublishResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMqttTraceMessagePublishResponseBody(name='body'),
}

/**
 * @summary Queries the trace of a message. If a message is not sent or received as expected, you can call this operation to view the message details to troubleshoot the issue. For example, you can query the time when the message is published and the client that publishes the message.
 *
 * @description *   Each successful call to the **QueryMqttTraceMessagePublish** operation increases the messaging transactions per second (TPS). This affects the billing of your instance. For more information, see [Billing rules](https://help.aliyun.com/document_detail/52819.html).
 * *   You can call this operation up to 500 times per second per account. If the limit is exceeded, throttling is triggered. This may affect your business. We recommend that you take note of this limit when you call this operation. For more information, see [Limits on QPS](https://help.aliyun.com/document_detail/163047.html).
 *
 * @param request QueryMqttTraceMessagePublishRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryMqttTraceMessagePublishResponse
 */
async function queryMqttTraceMessagePublishWithOptions(request: QueryMqttTraceMessagePublishRequest, runtime: $RuntimeOptions): QueryMqttTraceMessagePublishResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.beginTime)) {
    query['BeginTime'] = request.beginTime;
  }
  if (!$isNull(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.mqttRegionId)) {
    query['MqttRegionId'] = request.mqttRegionId;
  }
  if (!$isNull(request.msgId)) {
    query['MsgId'] = request.msgId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'QueryMqttTraceMessagePublish',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the trace of a message. If a message is not sent or received as expected, you can call this operation to view the message details to troubleshoot the issue. For example, you can query the time when the message is published and the client that publishes the message.
 *
 * @description *   Each successful call to the **QueryMqttTraceMessagePublish** operation increases the messaging transactions per second (TPS). This affects the billing of your instance. For more information, see [Billing rules](https://help.aliyun.com/document_detail/52819.html).
 * *   You can call this operation up to 500 times per second per account. If the limit is exceeded, throttling is triggered. This may affect your business. We recommend that you take note of this limit when you call this operation. For more information, see [Limits on QPS](https://help.aliyun.com/document_detail/163047.html).
 *
 * @param request QueryMqttTraceMessagePublishRequest
 * @return QueryMqttTraceMessagePublishResponse
 */
async function queryMqttTraceMessagePublish(request: QueryMqttTraceMessagePublishRequest): QueryMqttTraceMessagePublishResponse {
  var runtime = new $RuntimeOptions{};
  return queryMqttTraceMessagePublishWithOptions(request, runtime);
}

model QueryMqttTraceMessageSubscribeRequest {
  beginTime?: long(name='BeginTime', description='The beginning of the time range to query. The value of this parameter is a UNIX timestamp in milliseconds.

This parameter is required.', example='1621936800000'),
  clientId?: string(name='ClientId', description='The ID of the client that subscribes to the message. If you do not specify this parameter, the IDs of all clients that subscribe to the message are returned.', example='GID_test@@@consumer'),
  currentPage?: int32(name='CurrentPage', description='The number of the page to return. Pages start from page 1. If the input parameter value is greater than the total number of pages, the returned result is empty.

This parameter is required.', example='1'),
  endTime?: long(name='EndTime', description='The end of the time range to query. The value of this parameter is a UNIX timestamp in milliseconds.

This parameter is required.', example='1618646400000'),
  instanceId?: string(name='InstanceId', description='The ID of the ApsaraMQ for MQTT instance. The ID must be consistent with the ID of the instance that the ApsaraMQ for MQTT client uses. You can view the instance ID in the **Basic Information** section of the **Instance Details** page that corresponds to the instance in the ApsaraMQ for MQTT console.

This parameter is required.', example='mqtt-cn-i7m26mf****'),
  mqttRegionId?: string(name='MqttRegionId', description='The ID of the region where the ApsaraMQ for MQTT instance resides. For more information, see [Endpoints](https://help.aliyun.com/document_detail/181438.html).

This parameter is required.', example='cn-hangzhou'),
  msgId?: string(name='MsgId', description='The message ID.

This parameter is required.', example='AC1EC1B33D5978308DB17F3245E4****'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 100.

This parameter is required.', example='5'),
  reverse?: boolean(name='Reverse', description='Specifies whether the returned results are displayed in reverse chronological order. Valid values:

*   **true**: The returned results are displayed in reverse order of the time when messages are delivered. This means that the latest consumed message is displayed as the first entry and the earliest consumed message is displayed as the last entry.
*   **false**: The returned results are displayed in order of the time when messages are delivered. This means that the earliest consumed message is displayed as the first entry and the latest consumed message is displayed as the last entry.

If you do not specify this parameter, the returned results are displayed in order of time when messages are delivered.', example='false'),
}

model QueryMqttTraceMessageSubscribeResponseBody = {
  currentPage?: int32(name='CurrentPage', description='The page number of the returned page.', example='1'),
  messageTraceLists?: [ 
    {
      action?: string(name='Action', description='The action on the message. Valid values:

*   **sub**: The ApsaraMQ for MQTT client subscribes to the message.
*   **push_offline**: The ApsaraMQ for MQTT broker pushes the offline message to the ApsaraMQ for MQTT client.', example='sub'),
      actionCode?: string(name='ActionCode', description='The code returned for the action on the message. Valid values:

*   **mqtt.trace.action.msg.sub**: The value that is returned if the value of Action is **sub**.
*   **mqtt.trace.action.msg.push.offline**: The value that is returned if the value of Action is **push_offline**.', example='mqtt.trace.action.msg.sub'),
      actionInfo?: string(name='ActionInfo', description='The returned information for the action on the message. Valid values:

*   **Push To Mqtt Client**: The value that is returned if the value of Action is **sub**.
*   **Push Offline Msg To Mqtt Client**: The value that is returned if the value of Action is **push_offline**.', example='Push To Mqtt Client'),
      clientId?: string(name='ClientId', description='The ID of the client that subscribes to the message.', example='GID_test@@@consumer'),
      msgId?: string(name='MsgId', description='The message ID.', example='AC1EC1B33D5978308DB17F3245E4****'),
      time?: string(name='Time', description='The time when the message was delivered.', example='2021-05-25 16:46:41.274'),
    }
  ](name='MessageTraceLists', description='The delivery trace of the queried message.'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='5'),
  requestId?: string(name='RequestId', description='The unique ID that the system generates for the request. You can use the ID to troubleshoot issues. This parameter is a common parameter.', example='4E685844-ADAF-4D85-9EAC-F9471E8C****'),
  total?: long(name='Total', description='The returned delivery traces.', example='2'),
}

model QueryMqttTraceMessageSubscribeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMqttTraceMessageSubscribeResponseBody(name='body'),
}

/**
 * @summary Queries the delivery trace of a message. If a message is not sent or received as expected, you can call this operation to view the details about the message. For example, you can query the clients that subscribe to the message and the time when the message is delivered. This operation helps you locate the problem and identify the cause of the problem.
 *
 * @description *   Each successful call to the **QueryMqttTraceMessageSubscribe** operation increases the messaging transactions per second (TPS) by one. This affects the billing of your instance. For more information, see [Billing rules](https://help.aliyun.com/document_detail/52819.html).
 * *   You can call this operation up to 500 times per second per account. If the limit is exceeded, throttling is triggered. This may affect your business. We recommend that you take note of this limit when you call this operation. For more information, see [Limits on QPS](https://help.aliyun.com/document_detail/163047.html).
 *
 * @param request QueryMqttTraceMessageSubscribeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryMqttTraceMessageSubscribeResponse
 */
async function queryMqttTraceMessageSubscribeWithOptions(request: QueryMqttTraceMessageSubscribeRequest, runtime: $RuntimeOptions): QueryMqttTraceMessageSubscribeResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.beginTime)) {
    query['BeginTime'] = request.beginTime;
  }
  if (!$isNull(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!$isNull(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!$isNull(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.mqttRegionId)) {
    query['MqttRegionId'] = request.mqttRegionId;
  }
  if (!$isNull(request.msgId)) {
    query['MsgId'] = request.msgId;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.reverse)) {
    query['Reverse'] = request.reverse;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'QueryMqttTraceMessageSubscribe',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the delivery trace of a message. If a message is not sent or received as expected, you can call this operation to view the details about the message. For example, you can query the clients that subscribe to the message and the time when the message is delivered. This operation helps you locate the problem and identify the cause of the problem.
 *
 * @description *   Each successful call to the **QueryMqttTraceMessageSubscribe** operation increases the messaging transactions per second (TPS) by one. This affects the billing of your instance. For more information, see [Billing rules](https://help.aliyun.com/document_detail/52819.html).
 * *   You can call this operation up to 500 times per second per account. If the limit is exceeded, throttling is triggered. This may affect your business. We recommend that you take note of this limit when you call this operation. For more information, see [Limits on QPS](https://help.aliyun.com/document_detail/163047.html).
 *
 * @param request QueryMqttTraceMessageSubscribeRequest
 * @return QueryMqttTraceMessageSubscribeResponse
 */
async function queryMqttTraceMessageSubscribe(request: QueryMqttTraceMessageSubscribeRequest): QueryMqttTraceMessageSubscribeResponse {
  var runtime = new $RuntimeOptions{};
  return queryMqttTraceMessageSubscribeWithOptions(request, runtime);
}

model QuerySessionByClientIdRequest {
  clientId?: string(name='ClientId', description='The ID of the ApsaraMQ for MQTT client that you want to query.

This parameter is required.', example='GID_test@@@test'),
  instanceId?: string(name='InstanceId', description='The ID of the ApsaraMQ for MQTT instance. The ID must be consistent with the ID of the instance that the ApsaraMQ for MQTT client uses. You can obtain the instance ID on the **Instance Details** page that corresponds to the instance in the [ApsaraMQ for MQTT console](https://mqtt.console.aliyun.com).

This parameter is required.', example='post-cn-0pp12gl****'),
}

model QuerySessionByClientIdResponseBody = {
  onlineStatus?: boolean(name='OnlineStatus', description='Indicates whether the ApsaraMQ for MQTT client is connected to the ApsaraMQ for MQTT broker. Valid values:

*   **true**
*   **false**', example='true'),
  requestId?: string(name='RequestId', description='The request ID. This parameter is a common parameter.', example='E4581CCF-62AF-44D9-B5B4-D1DBBC0E****'),
}

model QuerySessionByClientIdResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QuerySessionByClientIdResponseBody(name='body'),
}

/**
 * @summary Queries the running status of an ApsaraMQ for MQTT client. You can troubleshoot issues based on the queried results. You can enter the ID of an ApsaraMQ for MQTT client to check the connection status and IP address of the device.
 *
 * @description *   You can call this operation up to 500 times per second.**** For more information, see [Limits on QPS](https://help.aliyun.com/document_detail/163047.html).
 * *   Each successful call to the **QuerySessionByClientId** operation increases the messaging transactions per second (TPS) by one. This affects the billing of your instance. For more information, see [Billing rules](https://help.aliyun.com/document_detail/52819.html).
 *
 * @param request QuerySessionByClientIdRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QuerySessionByClientIdResponse
 */
async function querySessionByClientIdWithOptions(request: QuerySessionByClientIdRequest, runtime: $RuntimeOptions): QuerySessionByClientIdResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'QuerySessionByClientId',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the running status of an ApsaraMQ for MQTT client. You can troubleshoot issues based on the queried results. You can enter the ID of an ApsaraMQ for MQTT client to check the connection status and IP address of the device.
 *
 * @description *   You can call this operation up to 500 times per second.**** For more information, see [Limits on QPS](https://help.aliyun.com/document_detail/163047.html).
 * *   Each successful call to the **QuerySessionByClientId** operation increases the messaging transactions per second (TPS) by one. This affects the billing of your instance. For more information, see [Billing rules](https://help.aliyun.com/document_detail/52819.html).
 *
 * @param request QuerySessionByClientIdRequest
 * @return QuerySessionByClientIdResponse
 */
async function querySessionByClientId(request: QuerySessionByClientIdRequest): QuerySessionByClientIdResponse {
  var runtime = new $RuntimeOptions{};
  return querySessionByClientIdWithOptions(request, runtime);
}

model QueryTokenRequest {
  instanceId?: string(name='InstanceId', description='The ID of the ApsaraMQ for MQTT instance. The ID must be consistent with the ID of the instance that the ApsaraMQ for MQTT client uses. You can obtain the instance ID on the **Instance Details** page that corresponds to the instance in the [ApsaraMQ for MQTT console](https://mqtt.console.aliyun.com/).

This parameter is required.', example='post-cn-0pp12gl****'),
  token?: string(name='Token', description='The token that you want to query.

This parameter is required.', example='LzMT+XLFl5s/YWJ/MlDz4t/Lq5HC1iGU1P28HAMaxYxn8aQbALNtml7QZKl9L9kPe6LqUb95tEVo+zUqOogs9+jZwDUSzsd4X4qaD3n2TrBEuMOqKkk1Xdrvu9VBQQvIYbz7MJWZDYC3DlW7gLEr33Cuj54iIhagtBi3epStJitsssWs7otY9zhKOSZxhr49G3d0bh35mwyP18EMvDas8UlzeSozsSrujNUqZXOGK0PEBSd+rWMGDJlCt6GFmJgm2JFY7PJwf/7OOSmUYIYFs5o/PuPpoTMF+hcVXMs+0yDukIMTOzG9m3t8k36PVrghFmnK6pC3Rt3mibjW****ng=='),
}

model QueryTokenResponseBody = {
  requestId?: string(name='RequestId', description='The unique ID that the system generates for the request. This parameter is a common parameter.', example='5C8AADD0-6A95-436D-AFA0-3405CCE3****'),
  tokenStatus?: boolean(name='TokenStatus', description='The status of the queried token. Valid values:

*   **true**: indicates the token is valid.
*   **false**: indicates the token is invalid.', example='true'),
}

model QueryTokenResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryTokenResponseBody(name='body'),
}

/**
 * @summary Queries the status of a token. If token-based authentication is used for permission authentication on an ApsaraMQ for MQTT broker, a token that is issued by the broker is required for authentication each time a client is connected to the broker. A token is a temporary credential and is valid only within a specific period of time. You can call this operation to query whether a token expires.
 *
 * @description *   You can call this operation up to 100 times per second per account. If you want to increase the limit, join the DingTalk group 35228338 to contact ApsaraMQ for MQTT technical support.
 * *   Each successful call to the **QueryToken** operation increases the messaging transactions per second (TPS) by one. This affects the billing of your instance. For more information, see [Billing rules](https://help.aliyun.com/document_detail/52819.html).
 *
 * @param request QueryTokenRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryTokenResponse
 */
async function queryTokenWithOptions(request: QueryTokenRequest, runtime: $RuntimeOptions): QueryTokenResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.token)) {
    query['Token'] = request.token;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'QueryToken',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the status of a token. If token-based authentication is used for permission authentication on an ApsaraMQ for MQTT broker, a token that is issued by the broker is required for authentication each time a client is connected to the broker. A token is a temporary credential and is valid only within a specific period of time. You can call this operation to query whether a token expires.
 *
 * @description *   You can call this operation up to 100 times per second per account. If you want to increase the limit, join the DingTalk group 35228338 to contact ApsaraMQ for MQTT technical support.
 * *   Each successful call to the **QueryToken** operation increases the messaging transactions per second (TPS) by one. This affects the billing of your instance. For more information, see [Billing rules](https://help.aliyun.com/document_detail/52819.html).
 *
 * @param request QueryTokenRequest
 * @return QueryTokenResponse
 */
async function queryToken(request: QueryTokenRequest): QueryTokenResponse {
  var runtime = new $RuntimeOptions{};
  return queryTokenWithOptions(request, runtime);
}

model RefreshDeviceCredentialRequest {
  clientId?: string(name='ClientId', description='The client ID of the device whose access credential you want to update.

This parameter is required.', example='GID_test@@@test'),
  instanceId?: string(name='InstanceId', description='The ID of the ApsaraMQ for MQTT instance. The ID must be consistent with the ID of the instance that the ApsaraMQ for MQTT client uses. You can obtain the instance ID on the **Instance Details** page that corresponds to the instance in the ApsaraMQ for MQTT console.

This parameter is required.', example='post-cn-0pp12gl****'),
}

model RefreshDeviceCredentialResponseBody = {
  deviceCredential?: {
    clientId?: string(name='ClientId', description='The client ID of the device.', example='GID_test@@@test'),
    createTime?: long(name='CreateTime', description='The timestamp that indicates when the access credential of the device was created. The value of this parameter is a UNIX timestamp in milliseconds.', example='1605541382000'),
    deviceAccessKeyId?: string(name='DeviceAccessKeyId', description='The AccessKey ID of the device.', example='DC.Z5fXh9sRRVufyLi6wo****'),
    deviceAccessKeySecret?: string(name='DeviceAccessKeySecret', description='The AccessKey secret of the device.', example='DC.BJMkn4eMQJK2vaApTS****'),
    instanceId?: string(name='InstanceId', description='The ID of the ApsaraMQ for MQTT instance.', example='post-cn-0pp12gl****'),
    updateTime?: long(name='UpdateTime', description='The timestamp that indicates when the access credential of the device was last updated. The value of this parameter is a UNIX timestamp in milliseconds.', example='1605541382000'),
  }(name='DeviceCredential', description='The access credential of the device.'),
  requestId?: string(name='RequestId', description='The request ID. This parameter is a common parameter.', example='E4581CCF-62AF-44D9-B5B4-D1DBDC0F****'),
}

model RefreshDeviceCredentialResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RefreshDeviceCredentialResponseBody(name='body'),
}

/**
 * @summary Updates the access credential of a device.
 *
 * @description ## [](#)Limits
 * You can call this operation up to 500 times per second per account. If the limit is exceeded, throttling is triggered. This may affect your business. We recommend that you take note of this limit when you call this operation. For more information, see [Limits on QPS](https://help.aliyun.com/document_detail/163047.html).
 * >  Each successful call to the **RefreshDeviceCredential** operation increases the messaging transactions per second (TPS) by one. This affects the billing of your instance. For more information, see [Billing rules](https://help.aliyun.com/document_detail/52819.html).
 *
 * @param request RefreshDeviceCredentialRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RefreshDeviceCredentialResponse
 */
async function refreshDeviceCredentialWithOptions(request: RefreshDeviceCredentialRequest, runtime: $RuntimeOptions): RefreshDeviceCredentialResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'RefreshDeviceCredential',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Updates the access credential of a device.
 *
 * @description ## [](#)Limits
 * You can call this operation up to 500 times per second per account. If the limit is exceeded, throttling is triggered. This may affect your business. We recommend that you take note of this limit when you call this operation. For more information, see [Limits on QPS](https://help.aliyun.com/document_detail/163047.html).
 * >  Each successful call to the **RefreshDeviceCredential** operation increases the messaging transactions per second (TPS) by one. This affects the billing of your instance. For more information, see [Billing rules](https://help.aliyun.com/document_detail/52819.html).
 *
 * @param request RefreshDeviceCredentialRequest
 * @return RefreshDeviceCredentialResponse
 */
async function refreshDeviceCredential(request: RefreshDeviceCredentialRequest): RefreshDeviceCredentialResponse {
  var runtime = new $RuntimeOptions{};
  return refreshDeviceCredentialWithOptions(request, runtime);
}

model RegisterCaCertificateRequest {
  caContent?: string(name='CaContent', description='The content of the CA certificate that you want to register with an ApsaraMQ for MQTT broker.


> In the example, \\\\n indicates a line feed.

This parameter is required.', example='-----BEGIN CERTIFICATE-----\\\\nMIIDuzCCAqdGVzdC5jbi1xaW5n******\\\\n-----END CERTIFICATE-----'),
  caName?: string(name='CaName', description='The name of the CA certificate that you want to register with an ApsaraMQ for MQTT broker.

This parameter is required.', example='mqtt_ca'),
  mqttInstanceId?: string(name='MqttInstanceId', description='The ID of the ApsaraMQ for MQTT instance to which you want to bind the CA certificate.

This parameter is required.', example='post-cn-7mz2d******'),
  verificationContent?: string(name='VerificationContent', description='The content of the validation certificate issued by the CA certificate that you want to register with an ApsaraMQ for MQTT broker. The validation certificate must be used together with the registration code of the CA certificate to verify the private key of the CA certificate.
> In the example, \\\\n indicates a line feed.

This parameter is required.', example='-----BEGIN CERTIFICATE-----\\\\nMIID/DCCAu+Y5sRMpp9tnd+4s******\\\\n-----END CERTIFICATE-----'),
}

model RegisterCaCertificateResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='020F6A43-19E6-4B6E-B846-44EB31DF****'),
  sn?: string(name='Sn', description='The serial number of the registered CA certificate. The serial number is the unique identifier of a CA certificate.', example='007269004887******'),
}

model RegisterCaCertificateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RegisterCaCertificateResponseBody(name='body'),
}

/**
 * @summary RegisterCaCertificate
 *
 * @description *   Only ApsaraMQ for MQTT Enterprise Platinum Edition instances support this operation.
 * *   You can call this operation up to 500 times per second per Alibaba Cloud account. If you want to increase the limit, join the DingTalk group (ID: 35228338) to contact ApsaraMQ for MQTT technical support.
 *
 * @param request RegisterCaCertificateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RegisterCaCertificateResponse
 */
async function registerCaCertificateWithOptions(request: RegisterCaCertificateRequest, runtime: $RuntimeOptions): RegisterCaCertificateResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.caContent)) {
    query['CaContent'] = request.caContent;
  }
  if (!$isNull(request.caName)) {
    query['CaName'] = request.caName;
  }
  if (!$isNull(request.mqttInstanceId)) {
    query['MqttInstanceId'] = request.mqttInstanceId;
  }
  if (!$isNull(request.verificationContent)) {
    query['VerificationContent'] = request.verificationContent;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'RegisterCaCertificate',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary RegisterCaCertificate
 *
 * @description *   Only ApsaraMQ for MQTT Enterprise Platinum Edition instances support this operation.
 * *   You can call this operation up to 500 times per second per Alibaba Cloud account. If you want to increase the limit, join the DingTalk group (ID: 35228338) to contact ApsaraMQ for MQTT technical support.
 *
 * @param request RegisterCaCertificateRequest
 * @return RegisterCaCertificateResponse
 */
async function registerCaCertificate(request: RegisterCaCertificateRequest): RegisterCaCertificateResponse {
  var runtime = new $RuntimeOptions{};
  return registerCaCertificateWithOptions(request, runtime);
}

model RegisterDeviceCredentialRequest {
  clientId?: string(name='ClientId', description='The client ID of the device for which you want to create an access credential.

This parameter is required.', example='GID_test@@@test'),
  instanceId?: string(name='InstanceId', description='The ID of the ApsaraMQ for MQTT instance. The ID must be consistent with the ID of the instance that the ApsaraMQ for MQTT client uses. You can obtain the instance ID on the **Instance Details** page that corresponds to the instance in the ApsaraMQ for MQTT console.

This parameter is required.', example='post-cn-0pp12gl****'),
}

model RegisterDeviceCredentialResponseBody = {
  deviceCredential?: {
    clientId?: string(name='ClientId', description='The client ID of the device.', example='GID_test@@@test'),
    createTime?: long(name='CreateTime', description='The timestamp that indicates when the access credential of the device was created. Unit: milliseconds.', example='1605541382000'),
    deviceAccessKeyId?: string(name='DeviceAccessKeyId', description='The AccessKey ID of the device.', example='DC.Z5fXh9sRRVufyLi6wo****'),
    deviceAccessKeySecret?: string(name='DeviceAccessKeySecret', description='The AccessKey secret of the device.', example='DC.BJMkn4eMQJK2vaApTS****'),
    instanceId?: string(name='InstanceId', description='The ID of the ApsaraMQ for MQTT instance.', example='post-cn-0pp12gl****'),
    updateTime?: long(name='UpdateTime', description='The timestamp that indicates when the access credential of the device was last updated. Unit: milliseconds.', example='1605541382000'),
  }(name='DeviceCredential', description='The access credential of the device.'),
  requestId?: string(name='RequestId', description='The request ID. This parameter is a common parameter.', example='E4581CCF-62AF-44D9-B5B4-D1DBDC0E****'),
}

model RegisterDeviceCredentialResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RegisterDeviceCredentialResponseBody(name='body'),
}

/**
 * @summary Registers an access credential for a device. In unique-certificate-per-device authentication mode, an application server applies a unique access credential for each device from the corresponding ApsaraMQ for MQTT broker. The access credential of a device consists of the client ID, AccessKey ID, and AccessKey secret of the device. When you connect a device to ApsaraMQ for MQTT, you must configure Username and Password based on the access credential of the device for authentication. You can activate the device and transfer data between the device and ApsaraMQ for MQTT only after the authentication is passed.
 *
 * @description *   You can call this operation up to 500 times per second per account. If the limit is exceeded, throttling is triggered. This may affect your business. We recommend that you take note of this limit when you call this operation. For more information, see [Limits on QPS](https://help.aliyun.com/document_detail/163047.html).
 * *   Each successful call to the **RegisterDeviceCredential** operation increases the messaging transactions per second (TPS) by one. This affects the billing of your instance. For more information, see [Billing rules](https://help.aliyun.com/document_detail/52819.html).
 *
 * @param request RegisterDeviceCredentialRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RegisterDeviceCredentialResponse
 */
async function registerDeviceCredentialWithOptions(request: RegisterDeviceCredentialRequest, runtime: $RuntimeOptions): RegisterDeviceCredentialResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'RegisterDeviceCredential',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Registers an access credential for a device. In unique-certificate-per-device authentication mode, an application server applies a unique access credential for each device from the corresponding ApsaraMQ for MQTT broker. The access credential of a device consists of the client ID, AccessKey ID, and AccessKey secret of the device. When you connect a device to ApsaraMQ for MQTT, you must configure Username and Password based on the access credential of the device for authentication. You can activate the device and transfer data between the device and ApsaraMQ for MQTT only after the authentication is passed.
 *
 * @description *   You can call this operation up to 500 times per second per account. If the limit is exceeded, throttling is triggered. This may affect your business. We recommend that you take note of this limit when you call this operation. For more information, see [Limits on QPS](https://help.aliyun.com/document_detail/163047.html).
 * *   Each successful call to the **RegisterDeviceCredential** operation increases the messaging transactions per second (TPS) by one. This affects the billing of your instance. For more information, see [Billing rules](https://help.aliyun.com/document_detail/52819.html).
 *
 * @param request RegisterDeviceCredentialRequest
 * @return RegisterDeviceCredentialResponse
 */
async function registerDeviceCredential(request: RegisterDeviceCredentialRequest): RegisterDeviceCredentialResponse {
  var runtime = new $RuntimeOptions{};
  return registerDeviceCredentialWithOptions(request, runtime);
}

model RevokeTokenRequest {
  instanceId?: string(name='InstanceId', description='The ID of the ApsaraMQ for MQTT instance. The ID must be consistent with the ID of the instance that the ApsaraMQ for MQTT client uses. You can obtain the instance ID on the **Instance Details** page that corresponds to the instance in the [ApsaraMQ for MQTT console](https://mqtt.console.aliyun.com/).

This parameter is required.', example='post-cn-0pp12gl****'),
  token?: string(name='Token', description='The token that you want to revoke.

This parameter is required.', example='LzMT+XLFl5s/YWJ/MlDz4t/Lq5HC1iGU1P28HAMaxYxn8aQbALNtml7QZKl9L9kPe6LqUb95tEVo+zUqOogs9+jZwDUSzsd4X4qaD3n2TrBEuMOqKkk1Xdrvu9VBQQvIYbz7MJWZDYC3DlW7gLEr33Cuj54iIhagtBi3epStJitsssWs7otY9zhKOSZxhr49G3d0bh35mwyP18EMvDas8UlzeSozsSrujNUqZXOGK0PEBSd+rWMGDJlCt6GFmJgm2JFY7PJwf/7OOSmUYIYFs5o/PuPpoTMF+hcVXMs+0yDukIMTOzG9m3t8k36PVrghFmnK6pC3Rt3mibjW****ng=='),
}

model RevokeTokenResponseBody = {
  requestId?: string(name='RequestId', description='The request ID. This parameter is a common parameter.', example='833EDFCB-C447-4CE3-B21F-3A4C2D1B****'),
}

model RevokeTokenResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RevokeTokenResponseBody(name='body'),
}

/**
 * @summary Revokes a token.
 *
 * @description *   You can call this operation up to 5 times per second per account. If you want to increase the limit, join the DingTalk group 35228338 to contact ApsaraMQ for MQTT technical support.
 * *   Each successful call to the **RevokeToken** operation increases the messaging transactions per second (TPS). This affects the billing of your instance. For more information, see [Billing rules](https://help.aliyun.com/document_detail/52819.html).
 *
 * @param request RevokeTokenRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RevokeTokenResponse
 */
async function revokeTokenWithOptions(request: RevokeTokenRequest, runtime: $RuntimeOptions): RevokeTokenResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.token)) {
    query['Token'] = request.token;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'RevokeToken',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Revokes a token.
 *
 * @description *   You can call this operation up to 5 times per second per account. If you want to increase the limit, join the DingTalk group 35228338 to contact ApsaraMQ for MQTT technical support.
 * *   Each successful call to the **RevokeToken** operation increases the messaging transactions per second (TPS). This affects the billing of your instance. For more information, see [Billing rules](https://help.aliyun.com/document_detail/52819.html).
 *
 * @param request RevokeTokenRequest
 * @return RevokeTokenResponse
 */
async function revokeToken(request: RevokeTokenRequest): RevokeTokenResponse {
  var runtime = new $RuntimeOptions{};
  return revokeTokenWithOptions(request, runtime);
}

model SendMessageRequest {
  instanceId?: string(name='InstanceId', description='The ID of the ApsaraMQ for MQTT instance. The ID must be consistent with the ID of the instance that the ApsaraMQ for MQTT client uses. You can view the instance ID in the **Basic Information** section on the **Instance Details** page that corresponds to the instance in the [ApsaraMQ for MQTT console](https://mqtt.console.aliyun.com).

This parameter is required.', example='post-cn-0pp12gl****'),
  mqttTopic?: string(name='MqttTopic', description='The topic to which you want to send a message on the ApsaraMQ for MQTT instance.

This parameter is required.', example='TopicA'),
  payload?: string(name='Payload', description='The message content, which is the payload of the message. We recommend that you encode the content in Base64 to prevent non-printable characters from being transmitted.

This parameter is required.', example='test'),
}

model SendMessageResponseBody = {
  msgId?: string(name='MsgId', description='The unique message ID that is returned by the ApsaraMQ for MQTT broker after the message is sent.', example='0B736D997B7F45FF54E61C1C1B58****'),
  requestId?: string(name='RequestId', description='The unique ID that the system generates for the request. This parameter is a common parameter.', example='020F6A43-19E6-4B6E-B846-44EB31DF****'),
}

model SendMessageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SendMessageResponseBody(name='body'),
}

/**
 * @summary Sends a single message from an application on a cloud server to ApsaraMQ for MQTT.
 *
 * @description *   The **SendMessage** operation is called by an application on a cloud server. This operation is complementary to the operation that is called to send a message from an ApsaraMQ for MQTT client. For information about the differences between the scenarios of sending messages from applications on cloud servers and the scenarios of sending messages from ApsaraMQ for MQTT clients, see [Developer guide](https://help.aliyun.com/document_detail/179160.html).
 * *   Messages that are sent by calling the **SendMessage** operation cannot be forwarded to ApsaraMQ for RocketMQ. If you want to use an ApsaraMQ for MQTT broker to forward messages to ApsaraMQ for RocketMQ, use [an SDK to send the messages](https://help.aliyun.com/document_detail/174527.html). The **SendMessage** operation supports up to 1,000 queries per second (QPS). For more information, see [QPS limits](https://help.aliyun.com/document_detail/163047.html).
 * *   Each successful call to the **SendMessage** operation is calculated as a message transaction per second (TPS). This affects the billing of your instance. For more information, see [Billing rules](https://help.aliyun.com/document_detail/52819.html).
 *
 * @param request SendMessageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SendMessageResponse
 */
async function sendMessageWithOptions(request: SendMessageRequest, runtime: $RuntimeOptions): SendMessageResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.mqttTopic)) {
    query['MqttTopic'] = request.mqttTopic;
  }
  if (!$isNull(request.payload)) {
    query['Payload'] = request.payload;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'SendMessage',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Sends a single message from an application on a cloud server to ApsaraMQ for MQTT.
 *
 * @description *   The **SendMessage** operation is called by an application on a cloud server. This operation is complementary to the operation that is called to send a message from an ApsaraMQ for MQTT client. For information about the differences between the scenarios of sending messages from applications on cloud servers and the scenarios of sending messages from ApsaraMQ for MQTT clients, see [Developer guide](https://help.aliyun.com/document_detail/179160.html).
 * *   Messages that are sent by calling the **SendMessage** operation cannot be forwarded to ApsaraMQ for RocketMQ. If you want to use an ApsaraMQ for MQTT broker to forward messages to ApsaraMQ for RocketMQ, use [an SDK to send the messages](https://help.aliyun.com/document_detail/174527.html). The **SendMessage** operation supports up to 1,000 queries per second (QPS). For more information, see [QPS limits](https://help.aliyun.com/document_detail/163047.html).
 * *   Each successful call to the **SendMessage** operation is calculated as a message transaction per second (TPS). This affects the billing of your instance. For more information, see [Billing rules](https://help.aliyun.com/document_detail/52819.html).
 *
 * @param request SendMessageRequest
 * @return SendMessageResponse
 */
async function sendMessage(request: SendMessageRequest): SendMessageResponse {
  var runtime = new $RuntimeOptions{};
  return sendMessageWithOptions(request, runtime);
}

model SetSniConfigRequest {
  defaultCertificate?: string(name='DefaultCertificate', description='The default certificate. If the domain name that you access cannot match the certificates of the broker, the default certificate is returned.

This parameter is required.', example='1533xxxx-cn-hangzhou'),
  mqttInstanceId?: string(name='MqttInstanceId', description='The instance ID.

This parameter is required.', example='mqtt-cn-5yd3xxx'),
  sniConfig?: string(name='SniConfig', description='The Server Name Indication (SNI) configuration. This parameter is used to map domain names and certificates. Format: Domain name#Certificate ID#Password (if available);Domain name#Certificate ID#Password (if available).', example='*.mqtt.aliyuncs.com#15xxxxx-cn-hangzhou;mqtt-test.mqtt.aliyuncs.com#15xxxx9-cn-hangzhou'),
}

model SetSniConfigResponseBody = {
  accessDeniedDetail?: {
    authAction?: string(name='AuthAction', example='SetSniConfig'),
    authPrincipalDisplayName?: string(name='AuthPrincipalDisplayName', example='2063xxxxxxxx533'),
    authPrincipalOwnerId?: string(name='AuthPrincipalOwnerId', example='1245xxxxx34343'),
    authPrincipalType?: string(name='AuthPrincipalType', example='SubUser'),
    encodedDiagnosticMessage?: string(name='EncodedDiagnosticMessage', example='AQFma6gWZmuoFkMxQ0M3MUVCLTRFQzQtNTI1OS1BQ0Q0LTlBMTFGQkVDOTA3Qw=='),
    noPermissionType?: string(name='NoPermissionType', example='ImplicitDeny'),
    policyType?: string(name='PolicyType', example='AccountLevelIdentityBasedPolicy'),
  }(name='AccessDeniedDetail'),
  requestId?: string(name='RequestId', description='The request ID.', example='E4581CCF-62AF-44D9-B5B4-D1DQDC0E****'),
  success?: string(name='Success', example='True'),
}

model SetSniConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetSniConfigResponseBody(name='body'),
}

/**
 * @summary Configures a multi-domain certificate.
 *
 * @param request SetSniConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetSniConfigResponse
 */
async function setSniConfigWithOptions(request: SetSniConfigRequest, runtime: $RuntimeOptions): SetSniConfigResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.defaultCertificate)) {
    query['DefaultCertificate'] = request.defaultCertificate;
  }
  if (!$isNull(request.mqttInstanceId)) {
    query['MqttInstanceId'] = request.mqttInstanceId;
  }
  if (!$isNull(request.sniConfig)) {
    query['SniConfig'] = request.sniConfig;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'SetSniConfig',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Configures a multi-domain certificate.
 *
 * @param request SetSniConfigRequest
 * @return SetSniConfigResponse
 */
async function setSniConfig(request: SetSniConfigRequest): SetSniConfigResponse {
  var runtime = new $RuntimeOptions{};
  return setSniConfigWithOptions(request, runtime);
}

model TagResourcesRequest {
  resourceId?: [ string ](name='ResourceId', description='This parameter is required.'),
  resourceType?: string(name='ResourceType', description='This parameter is required.', example='instance'),
  tag?: [ 
    {
      key?: string(name='Key', example='test'),
      value?: string(name='Value', example='test'),
    }
  ](name='Tag', description='This parameter is required.'),
}

model TagResourcesResponseBody = {
  code?: string(name='Code', example='200'),
  data?: boolean(name='Data', example='true'),
  message?: string(name='Message', example='operation success.'),
  requestId?: string(name='RequestId', description='Id of the request', example='82B9E503-F4A1-4F30-976F-C6999FF9****'),
}

model TagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: TagResourcesResponseBody(name='body'),
}

/**
 * @summary tag
 *
 * @param request TagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return TagResourcesResponse
 */
async function tagResourcesWithOptions(request: TagResourcesRequest, runtime: $RuntimeOptions): TagResourcesResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!$isNull(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!$isNull(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'TagResources',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary tag
 *
 * @param request TagResourcesRequest
 * @return TagResourcesResponse
 */
async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new $RuntimeOptions{};
  return tagResourcesWithOptions(request, runtime);
}

model UnRegisterDeviceCredentialRequest {
  clientId?: string(name='ClientId', description='The client ID of the device whose access credential you want to deregister.

This parameter is required.', example='GID_test@@@test'),
  instanceId?: string(name='InstanceId', description='The ID of the ApsaraMQ for MQTT instance. The ID must be consistent with the ID of the instance that the ApsaraMQ for MQTT client uses. You can obtain the instance ID on the **Instance Details** page that corresponds to the instance in the ApsaraMQ for MQTT console.

This parameter is required.', example='post-cn-0pp12gl****'),
}

model UnRegisterDeviceCredentialResponseBody = {
  requestId?: string(name='RequestId', description='The unique ID that the system generates for the request. This parameter is a common parameter.', example='E4581CCD-62AF-44D9-B5B4-D1DBDC0E****'),
}

model UnRegisterDeviceCredentialResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UnRegisterDeviceCredentialResponseBody(name='body'),
}

/**
 * @summary Deregisters the access credential of a device. After the access credential of a device is deregistered, you can no longer use the access credential to authenticate the device on the ApsaraMQ for MQTT broker.
 *
 * @description *   You can call this operation up to 500 times per second per account. If the limit is exceeded, throttling is triggered. This may affect your business. We recommend that you take note of this limit when you call this operation. For more information, see [Limits on QPS](https://help.aliyun.com/document_detail/163047.html).
 * *   Each successful call to the **UnRegisterDeviceCredential** operation increases the number of transactions per second (TPS) by one. This affects the billing of your instance. For more information, see [Billing rules](https://help.aliyun.com/document_detail/52819.html).
 *
 * @param request UnRegisterDeviceCredentialRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UnRegisterDeviceCredentialResponse
 */
async function unRegisterDeviceCredentialWithOptions(request: UnRegisterDeviceCredentialRequest, runtime: $RuntimeOptions): UnRegisterDeviceCredentialResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'UnRegisterDeviceCredential',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deregisters the access credential of a device. After the access credential of a device is deregistered, you can no longer use the access credential to authenticate the device on the ApsaraMQ for MQTT broker.
 *
 * @description *   You can call this operation up to 500 times per second per account. If the limit is exceeded, throttling is triggered. This may affect your business. We recommend that you take note of this limit when you call this operation. For more information, see [Limits on QPS](https://help.aliyun.com/document_detail/163047.html).
 * *   Each successful call to the **UnRegisterDeviceCredential** operation increases the number of transactions per second (TPS) by one. This affects the billing of your instance. For more information, see [Billing rules](https://help.aliyun.com/document_detail/52819.html).
 *
 * @param request UnRegisterDeviceCredentialRequest
 * @return UnRegisterDeviceCredentialResponse
 */
async function unRegisterDeviceCredential(request: UnRegisterDeviceCredentialRequest): UnRegisterDeviceCredentialResponse {
  var runtime = new $RuntimeOptions{};
  return unRegisterDeviceCredentialWithOptions(request, runtime);
}

model UntagResourcesRequest {
  all?: boolean(name='All', example='False'),
  resourceId?: [ string ](name='ResourceId', description='This parameter is required.'),
  resourceType?: string(name='ResourceType', description='This parameter is required.', example='instance'),
  tagKey?: [ string ](name='TagKey'),
}

model UntagResourcesResponseBody = {
  code?: string(name='Code', example='200'),
  data?: boolean(name='Data', example='true'),
  message?: string(name='Message', example='operation success.'),
  requestId?: string(name='RequestId', description='Id of the request', example='B3C2F69B-B543-49B0-8B21-C8843AE0****'),
}

model UntagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UntagResourcesResponseBody(name='body'),
}

/**
 * @summary 
 *
 * @param request UntagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UntagResourcesResponse
 */
async function untagResourcesWithOptions(request: UntagResourcesRequest, runtime: $RuntimeOptions): UntagResourcesResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.all)) {
    query['All'] = request.all;
  }
  if (!$isNull(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!$isNull(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!$isNull(request.tagKey)) {
    query['TagKey'] = request.tagKey;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'UntagResources',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary 
 *
 * @param request UntagResourcesRequest
 * @return UntagResourcesResponse
 */
async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new $RuntimeOptions{};
  return untagResourcesWithOptions(request, runtime);
}

model UpdateCustomAuthIdentityRequest {
  clientId?: string(name='ClientId', description='The client ID if you set IdentityType to CLIENT.', example='GID_test@@@test'),
  identityType?: string(name='IdentityType', description='The identity type. Valid values:

*   USER
*   CLIENT

This parameter is required.', example='USER'),
  instanceId?: string(name='InstanceId', description='The ID of the ApsaraMQ for MQTT instance.

This parameter is required.', example='post-111****'),
  secret?: string(name='Secret', description='The AccessKey secret.

This parameter is required.', example='xxxx'),
  signMode?: string(name='SignMode', description='The signature verification mode. ORIGIN: compares the password and the AccessKey secret. SIGNED: uses the HMAC_SHA1 algorithm to sign the client ID to obtain a password and then compares the password.

This parameter is required.', example='SIGNED'),
  username?: string(name='Username', description='The username. The value cannot exceed 64 characters in length.

This parameter is required.', example='test'),
}

model UpdateCustomAuthIdentityResponseBody = {
  code?: int32(name='Code', description='The HTTP status code.', example='200'),
  message?: string(name='Message', description='The returned message.', example='operation success.'),
  requestId?: string(name='RequestId', description='The request ID.', example='3F00084A-7F07-4B15-BADA-8903A4FB****'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values: true and false.', example='True'),
}

model UpdateCustomAuthIdentityResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCustomAuthIdentityResponseBody(name='body'),
}

/**
 * @summary Updates the information about custom identity authentication.
 *
 * @param request UpdateCustomAuthIdentityRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateCustomAuthIdentityResponse
 */
async function updateCustomAuthIdentityWithOptions(request: UpdateCustomAuthIdentityRequest, runtime: $RuntimeOptions): UpdateCustomAuthIdentityResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.clientId)) {
    body['ClientId'] = request.clientId;
  }
  if (!$isNull(request.identityType)) {
    body['IdentityType'] = request.identityType;
  }
  if (!$isNull(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.secret)) {
    body['Secret'] = request.secret;
  }
  if (!$isNull(request.signMode)) {
    body['SignMode'] = request.signMode;
  }
  if (!$isNull(request.username)) {
    body['Username'] = request.username;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateCustomAuthIdentity',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Updates the information about custom identity authentication.
 *
 * @param request UpdateCustomAuthIdentityRequest
 * @return UpdateCustomAuthIdentityResponse
 */
async function updateCustomAuthIdentity(request: UpdateCustomAuthIdentityRequest): UpdateCustomAuthIdentityResponse {
  var runtime = new $RuntimeOptions{};
  return updateCustomAuthIdentityWithOptions(request, runtime);
}

model UpdateCustomAuthPermissionRequest {
  effect?: string(name='Effect', description='Specifies whether to allow or deny access.

This parameter is required.', example='ALLOW'),
  identity?: string(name='Identity', description='Username or Client ID.

This parameter is required.', example='test'),
  identityType?: string(name='IdentityType', description='The identity type. Valid values:

*   USER
*   CLIENT

This parameter is required.', example='USER'),
  instanceId?: string(name='InstanceId', description='ID of the Cloud Message Queue MQTT version instance.

This parameter is required.', example='post-cn-0pp12gl****'),
  permitAction?: string(name='PermitAction', description='The permissions that you want to grant.

This parameter is required.', example='PUB_SUB'),
  topic?: string(name='Topic', description='Authorized Topic, supporting multi-level MQTT topics and wildcards.

This parameter is required.', example='test/t1'),
}

model UpdateCustomAuthPermissionResponseBody = {
  code?: int32(name='Code', description='Error code returned upon failed invocation. For more information, see Error Codes.', example='200'),
  message?: string(name='Message', description='Information', example='operation success.'),
  requestId?: string(name='RequestId', description='Id of the request', example='8CC04203-679B-4DED-89D9-E7C2E979****'),
  success?: boolean(name='Success', description='Indicates whether the call was successful. true: Call succeeded. false: Call failed.', example='True'),
}

model UpdateCustomAuthPermissionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCustomAuthPermissionResponseBody(name='body'),
}

/**
 * @summary Updates the permissions on a topic.
 *
 * @param request UpdateCustomAuthPermissionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateCustomAuthPermissionResponse
 */
async function updateCustomAuthPermissionWithOptions(request: UpdateCustomAuthPermissionRequest, runtime: $RuntimeOptions): UpdateCustomAuthPermissionResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.effect)) {
    body['Effect'] = request.effect;
  }
  if (!$isNull(request.identity)) {
    body['Identity'] = request.identity;
  }
  if (!$isNull(request.identityType)) {
    body['IdentityType'] = request.identityType;
  }
  if (!$isNull(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.permitAction)) {
    body['PermitAction'] = request.permitAction;
  }
  if (!$isNull(request.topic)) {
    body['Topic'] = request.topic;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateCustomAuthPermission',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Updates the permissions on a topic.
 *
 * @param request UpdateCustomAuthPermissionRequest
 * @return UpdateCustomAuthPermissionResponse
 */
async function updateCustomAuthPermission(request: UpdateCustomAuthPermissionRequest): UpdateCustomAuthPermissionResponse {
  var runtime = new $RuntimeOptions{};
  return updateCustomAuthPermissionWithOptions(request, runtime);
}

