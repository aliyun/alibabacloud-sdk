/**
 *
 */
import Util;
import OpenApi;

import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('onsmqtt', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model ApplyTokenRequest {
  resources?: string(name='Resources'),
  instanceId?: string(name='InstanceId'),
  expireTime?: long(name='ExpireTime'),
  actions?: string(name='Actions'),
}

model ApplyTokenResponseBody = {
  token?: string(name='Token'),
  requestId?: string(name='RequestId'),
}

model ApplyTokenResponse = {
  headers: map[string]string(name='headers'),
  body: ApplyTokenResponseBody(name='body'),
}

async function applyTokenWithOptions(request: ApplyTokenRequest, runtime: Util.RuntimeOptions): ApplyTokenResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ApplyToken', '2020-04-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function applyToken(request: ApplyTokenRequest): ApplyTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return applyTokenWithOptions(request, runtime);
}

model BatchQuerySessionByClientIdsRequest {
  instanceId?: string(name='InstanceId'),
  clientIdList?: [ string ](name='ClientIdList'),
}

model BatchQuerySessionByClientIdsResponseBody = {
  requestId?: string(name='RequestId'),
  onlineStatusList?: [ 
    {
      onlineStatus?: boolean(name='OnlineStatus'),
      clientId?: string(name='ClientId'),
    }
  ](name='OnlineStatusList'),
}

model BatchQuerySessionByClientIdsResponse = {
  headers: map[string]string(name='headers'),
  body: BatchQuerySessionByClientIdsResponseBody(name='body'),
}

async function batchQuerySessionByClientIdsWithOptions(request: BatchQuerySessionByClientIdsRequest, runtime: Util.RuntimeOptions): BatchQuerySessionByClientIdsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('BatchQuerySessionByClientIds', '2020-04-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function batchQuerySessionByClientIds(request: BatchQuerySessionByClientIdsRequest): BatchQuerySessionByClientIdsResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchQuerySessionByClientIdsWithOptions(request, runtime);
}

model CreateGroupIdRequest {
  groupId?: string(name='GroupId'),
  instanceId?: string(name='InstanceId'),
}

model CreateGroupIdResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateGroupIdResponse = {
  headers: map[string]string(name='headers'),
  body: CreateGroupIdResponseBody(name='body'),
}

async function createGroupIdWithOptions(request: CreateGroupIdRequest, runtime: Util.RuntimeOptions): CreateGroupIdResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateGroupId', '2020-04-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createGroupId(request: CreateGroupIdRequest): CreateGroupIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return createGroupIdWithOptions(request, runtime);
}

model DeleteGroupIdRequest {
  groupId?: string(name='GroupId'),
  instanceId?: string(name='InstanceId'),
}

model DeleteGroupIdResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteGroupIdResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteGroupIdResponseBody(name='body'),
}

async function deleteGroupIdWithOptions(request: DeleteGroupIdRequest, runtime: Util.RuntimeOptions): DeleteGroupIdResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteGroupId', '2020-04-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteGroupId(request: DeleteGroupIdRequest): DeleteGroupIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGroupIdWithOptions(request, runtime);
}

model GetDeviceCredentialRequest {
  clientId?: string(name='ClientId'),
  instanceId?: string(name='InstanceId'),
}

model GetDeviceCredentialResponseBody = {
  requestId?: string(name='RequestId'),
  deviceCredential?: {
    updateTime?: long(name='UpdateTime'),
    deviceAccessKeyId?: string(name='DeviceAccessKeyId'),
    createTime?: long(name='CreateTime'),
    instanceId?: string(name='InstanceId'),
    deviceAccessKeySecret?: string(name='DeviceAccessKeySecret'),
    clientId?: string(name='ClientId'),
  }(name='DeviceCredential'),
}

model GetDeviceCredentialResponse = {
  headers: map[string]string(name='headers'),
  body: GetDeviceCredentialResponseBody(name='body'),
}

async function getDeviceCredentialWithOptions(request: GetDeviceCredentialRequest, runtime: Util.RuntimeOptions): GetDeviceCredentialResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetDeviceCredential', '2020-04-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getDeviceCredential(request: GetDeviceCredentialRequest): GetDeviceCredentialResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDeviceCredentialWithOptions(request, runtime);
}

model ListGroupIdRequest {
  instanceId?: string(name='InstanceId'),
}

model ListGroupIdResponseBody = {
  requestId?: string(name='RequestId'),
  data?: [ 
    {
      updateTime?: long(name='UpdateTime'),
      instanceId?: string(name='InstanceId'),
      independentNaming?: boolean(name='IndependentNaming'),
      groupId?: string(name='GroupId'),
      createTime?: long(name='CreateTime'),
    }
  ](name='Data'),
}

model ListGroupIdResponse = {
  headers: map[string]string(name='headers'),
  body: ListGroupIdResponseBody(name='body'),
}

async function listGroupIdWithOptions(request: ListGroupIdRequest, runtime: Util.RuntimeOptions): ListGroupIdResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListGroupId', '2020-04-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listGroupId(request: ListGroupIdRequest): ListGroupIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return listGroupIdWithOptions(request, runtime);
}

model QueryMqttTraceDeviceRequest {
  mqttRegionId?: string(name='MqttRegionId'),
  instanceId?: string(name='InstanceId'),
  reverse?: boolean(name='Reverse'),
  clientId?: string(name='ClientId'),
  beginTime?: long(name='BeginTime'),
  endTime?: long(name='EndTime'),
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
}

model QueryMqttTraceDeviceResponseBody = {
  currentPage?: int32(name='CurrentPage'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  total?: long(name='Total'),
  deviceInfoList?: [ 
    {
      channelId?: string(name='ChannelId'),
      time?: string(name='Time'),
      actionCode?: string(name='ActionCode'),
      action?: string(name='Action'),
      actionInfo?: string(name='ActionInfo'),
    }
  ](name='DeviceInfoList'),
}

model QueryMqttTraceDeviceResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMqttTraceDeviceResponseBody(name='body'),
}

async function queryMqttTraceDeviceWithOptions(request: QueryMqttTraceDeviceRequest, runtime: Util.RuntimeOptions): QueryMqttTraceDeviceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryMqttTraceDevice', '2020-04-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryMqttTraceDevice(request: QueryMqttTraceDeviceRequest): QueryMqttTraceDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMqttTraceDeviceWithOptions(request, runtime);
}

model QueryMqttTraceMessageOfClientRequest {
  mqttRegionId?: string(name='MqttRegionId'),
  instanceId?: string(name='InstanceId'),
  clientId?: string(name='ClientId'),
  beginTime?: long(name='BeginTime'),
  endTime?: long(name='EndTime'),
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
  reverse?: boolean(name='Reverse'),
}

model QueryMqttTraceMessageOfClientResponseBody = {
  currentPage?: int32(name='CurrentPage'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  total?: long(name='Total'),
  messageOfClientList?: [ 
    {
      time?: string(name='Time'),
      action?: string(name='Action'),
      actionCode?: string(name='ActionCode'),
      actionInfo?: string(name='ActionInfo'),
      msgId?: string(name='MsgId'),
      clientId?: string(name='ClientId'),
    }
  ](name='MessageOfClientList'),
}

model QueryMqttTraceMessageOfClientResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMqttTraceMessageOfClientResponseBody(name='body'),
}

async function queryMqttTraceMessageOfClientWithOptions(request: QueryMqttTraceMessageOfClientRequest, runtime: Util.RuntimeOptions): QueryMqttTraceMessageOfClientResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryMqttTraceMessageOfClient', '2020-04-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryMqttTraceMessageOfClient(request: QueryMqttTraceMessageOfClientRequest): QueryMqttTraceMessageOfClientResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMqttTraceMessageOfClientWithOptions(request, runtime);
}

model QueryMqttTraceMessagePublishRequest {
  mqttRegionId?: string(name='MqttRegionId'),
  instanceId?: string(name='InstanceId'),
  msgId?: string(name='MsgId'),
  beginTime?: long(name='BeginTime'),
  endTime?: long(name='EndTime'),
}

model QueryMqttTraceMessagePublishResponseBody = {
  requestId?: string(name='RequestId'),
  messageTraceLists?: [ 
    {
      time?: string(name='Time'),
      action?: string(name='Action'),
      actionCode?: string(name='ActionCode'),
      actionInfo?: string(name='ActionInfo'),
      msgId?: string(name='MsgId'),
      clientId?: string(name='ClientId'),
    }
  ](name='MessageTraceLists'),
}

model QueryMqttTraceMessagePublishResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMqttTraceMessagePublishResponseBody(name='body'),
}

async function queryMqttTraceMessagePublishWithOptions(request: QueryMqttTraceMessagePublishRequest, runtime: Util.RuntimeOptions): QueryMqttTraceMessagePublishResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryMqttTraceMessagePublish', '2020-04-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryMqttTraceMessagePublish(request: QueryMqttTraceMessagePublishRequest): QueryMqttTraceMessagePublishResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMqttTraceMessagePublishWithOptions(request, runtime);
}

model QueryMqttTraceMessageSubscribeRequest {
  mqttRegionId?: string(name='MqttRegionId'),
  instanceId?: string(name='InstanceId'),
  reverse?: boolean(name='Reverse'),
  clientId?: string(name='ClientId'),
  beginTime?: long(name='BeginTime'),
  endTime?: long(name='EndTime'),
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
  msgId?: string(name='MsgId'),
}

model QueryMqttTraceMessageSubscribeResponseBody = {
  currentPage?: int32(name='CurrentPage'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  total?: long(name='Total'),
  messageTraceLists?: [ 
    {
      time?: string(name='Time'),
      action?: string(name='Action'),
      actionCode?: string(name='ActionCode'),
      actionInfo?: string(name='ActionInfo'),
      msgId?: string(name='MsgId'),
      clientId?: string(name='ClientId'),
    }
  ](name='MessageTraceLists'),
}

model QueryMqttTraceMessageSubscribeResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMqttTraceMessageSubscribeResponseBody(name='body'),
}

async function queryMqttTraceMessageSubscribeWithOptions(request: QueryMqttTraceMessageSubscribeRequest, runtime: Util.RuntimeOptions): QueryMqttTraceMessageSubscribeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryMqttTraceMessageSubscribe', '2020-04-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryMqttTraceMessageSubscribe(request: QueryMqttTraceMessageSubscribeRequest): QueryMqttTraceMessageSubscribeResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMqttTraceMessageSubscribeWithOptions(request, runtime);
}

model QuerySessionByClientIdRequest {
  clientId?: string(name='ClientId'),
  instanceId?: string(name='InstanceId'),
}

model QuerySessionByClientIdResponseBody = {
  onlineStatus?: boolean(name='OnlineStatus'),
  requestId?: string(name='RequestId'),
}

model QuerySessionByClientIdResponse = {
  headers: map[string]string(name='headers'),
  body: QuerySessionByClientIdResponseBody(name='body'),
}

async function querySessionByClientIdWithOptions(request: QuerySessionByClientIdRequest, runtime: Util.RuntimeOptions): QuerySessionByClientIdResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QuerySessionByClientId', '2020-04-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function querySessionByClientId(request: QuerySessionByClientIdRequest): QuerySessionByClientIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySessionByClientIdWithOptions(request, runtime);
}

model QueryTokenRequest {
  token?: string(name='Token'),
  instanceId?: string(name='InstanceId'),
}

model QueryTokenResponseBody = {
  tokenStatus?: boolean(name='TokenStatus'),
  requestId?: string(name='RequestId'),
}

model QueryTokenResponse = {
  headers: map[string]string(name='headers'),
  body: QueryTokenResponseBody(name='body'),
}

async function queryTokenWithOptions(request: QueryTokenRequest, runtime: Util.RuntimeOptions): QueryTokenResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryToken', '2020-04-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryToken(request: QueryTokenRequest): QueryTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTokenWithOptions(request, runtime);
}

model RefreshDeviceCredentialRequest {
  clientId?: string(name='ClientId'),
  instanceId?: string(name='InstanceId'),
}

model RefreshDeviceCredentialResponseBody = {
  requestId?: string(name='RequestId'),
  deviceCredential?: {
    updateTime?: long(name='UpdateTime'),
    deviceAccessKeyId?: string(name='DeviceAccessKeyId'),
    createTime?: long(name='CreateTime'),
    instanceId?: string(name='InstanceId'),
    deviceAccessKeySecret?: string(name='DeviceAccessKeySecret'),
    clientId?: string(name='ClientId'),
  }(name='DeviceCredential'),
}

model RefreshDeviceCredentialResponse = {
  headers: map[string]string(name='headers'),
  body: RefreshDeviceCredentialResponseBody(name='body'),
}

async function refreshDeviceCredentialWithOptions(request: RefreshDeviceCredentialRequest, runtime: Util.RuntimeOptions): RefreshDeviceCredentialResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RefreshDeviceCredential', '2020-04-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function refreshDeviceCredential(request: RefreshDeviceCredentialRequest): RefreshDeviceCredentialResponse {
  var runtime = new Util.RuntimeOptions{};
  return refreshDeviceCredentialWithOptions(request, runtime);
}

model RegisterDeviceCredentialRequest {
  clientId?: string(name='ClientId'),
  instanceId?: string(name='InstanceId'),
}

model RegisterDeviceCredentialResponseBody = {
  requestId?: string(name='RequestId'),
  deviceCredential?: {
    updateTime?: long(name='UpdateTime'),
    deviceAccessKeyId?: string(name='DeviceAccessKeyId'),
    createTime?: long(name='CreateTime'),
    instanceId?: string(name='InstanceId'),
    deviceAccessKeySecret?: string(name='DeviceAccessKeySecret'),
    clientId?: string(name='ClientId'),
  }(name='DeviceCredential'),
}

model RegisterDeviceCredentialResponse = {
  headers: map[string]string(name='headers'),
  body: RegisterDeviceCredentialResponseBody(name='body'),
}

async function registerDeviceCredentialWithOptions(request: RegisterDeviceCredentialRequest, runtime: Util.RuntimeOptions): RegisterDeviceCredentialResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RegisterDeviceCredential', '2020-04-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function registerDeviceCredential(request: RegisterDeviceCredentialRequest): RegisterDeviceCredentialResponse {
  var runtime = new Util.RuntimeOptions{};
  return registerDeviceCredentialWithOptions(request, runtime);
}

model RevokeTokenRequest {
  token?: string(name='Token'),
  instanceId?: string(name='InstanceId'),
}

model RevokeTokenResponseBody = {
  requestId?: string(name='RequestId'),
}

model RevokeTokenResponse = {
  headers: map[string]string(name='headers'),
  body: RevokeTokenResponseBody(name='body'),
}

async function revokeTokenWithOptions(request: RevokeTokenRequest, runtime: Util.RuntimeOptions): RevokeTokenResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RevokeToken', '2020-04-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function revokeToken(request: RevokeTokenRequest): RevokeTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return revokeTokenWithOptions(request, runtime);
}

model SendMessageRequest {
  mqttTopic?: string(name='MqttTopic'),
  instanceId?: string(name='InstanceId'),
  payload?: string(name='Payload'),
}

model SendMessageResponseBody = {
  msgId?: string(name='MsgId'),
  requestId?: string(name='RequestId'),
}

model SendMessageResponse = {
  headers: map[string]string(name='headers'),
  body: SendMessageResponseBody(name='body'),
}

async function sendMessageWithOptions(request: SendMessageRequest, runtime: Util.RuntimeOptions): SendMessageResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SendMessage', '2020-04-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function sendMessage(request: SendMessageRequest): SendMessageResponse {
  var runtime = new Util.RuntimeOptions{};
  return sendMessageWithOptions(request, runtime);
}

model UnRegisterDeviceCredentialRequest {
  clientId?: string(name='ClientId'),
  instanceId?: string(name='InstanceId'),
}

model UnRegisterDeviceCredentialResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnRegisterDeviceCredentialResponse = {
  headers: map[string]string(name='headers'),
  body: UnRegisterDeviceCredentialResponseBody(name='body'),
}

async function unRegisterDeviceCredentialWithOptions(request: UnRegisterDeviceCredentialRequest, runtime: Util.RuntimeOptions): UnRegisterDeviceCredentialResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UnRegisterDeviceCredential', '2020-04-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function unRegisterDeviceCredential(request: UnRegisterDeviceCredentialRequest): UnRegisterDeviceCredentialResponse {
  var runtime = new Util.RuntimeOptions{};
  return unRegisterDeviceCredentialWithOptions(request, runtime);
}

