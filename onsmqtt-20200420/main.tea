/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('onsmqtt', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model ActiveCaCertificateRequest {
  mqttInstanceId?: string(name='MqttInstanceId'),
  sn?: string(name='Sn'),
}

model ActiveCaCertificateResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  sn?: string(name='Sn'),
}

model ActiveCaCertificateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ActiveCaCertificateResponseBody(name='body'),
}

async function activeCaCertificateWithOptions(request: ActiveCaCertificateRequest, runtime: Util.RuntimeOptions): ActiveCaCertificateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.mqttInstanceId)) {
    query['MqttInstanceId'] = request.mqttInstanceId;
  }
  if (!Util.isUnset(request.sn)) {
    query['Sn'] = request.sn;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ActiveCaCertificate',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function activeCaCertificate(request: ActiveCaCertificateRequest): ActiveCaCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return activeCaCertificateWithOptions(request, runtime);
}

model ApplyTokenRequest {
  actions?: string(name='Actions'),
  expireTime?: long(name='ExpireTime'),
  instanceId?: string(name='InstanceId'),
  resources?: string(name='Resources'),
}

model ApplyTokenResponseBody = {
  requestId?: string(name='RequestId'),
  token?: string(name='Token'),
}

model ApplyTokenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ApplyTokenResponseBody(name='body'),
}

async function applyTokenWithOptions(request: ApplyTokenRequest, runtime: Util.RuntimeOptions): ApplyTokenResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.actions)) {
    query['Actions'] = request.actions;
  }
  if (!Util.isUnset(request.expireTime)) {
    query['ExpireTime'] = request.expireTime;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.resources)) {
    query['Resources'] = request.resources;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ApplyToken',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function applyToken(request: ApplyTokenRequest): ApplyTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return applyTokenWithOptions(request, runtime);
}

model BatchQuerySessionByClientIdsRequest {
  clientIdList?: [ string ](name='ClientIdList'),
  instanceId?: string(name='InstanceId'),
}

model BatchQuerySessionByClientIdsResponseBody = {
  onlineStatusList?: [ 
    {
      clientId?: string(name='ClientId'),
      onlineStatus?: boolean(name='OnlineStatus'),
    }
  ](name='OnlineStatusList'),
  requestId?: string(name='RequestId'),
}

model BatchQuerySessionByClientIdsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchQuerySessionByClientIdsResponseBody(name='body'),
}

async function batchQuerySessionByClientIdsWithOptions(request: BatchQuerySessionByClientIdsRequest, runtime: Util.RuntimeOptions): BatchQuerySessionByClientIdsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientIdList)) {
    query['ClientIdList'] = request.clientIdList;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BatchQuerySessionByClientIds',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function batchQuerySessionByClientIds(request: BatchQuerySessionByClientIdsRequest): BatchQuerySessionByClientIdsResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchQuerySessionByClientIdsWithOptions(request, runtime);
}

model CreateGroupIdRequest {
  groupId?: string(name='GroupId'),
  instanceId?: string(name='InstanceId'),
}

model CreateGroupIdResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateGroupIdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateGroupIdResponseBody(name='body'),
}

async function createGroupIdWithOptions(request: CreateGroupIdRequest, runtime: Util.RuntimeOptions): CreateGroupIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateGroupId',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createGroupId(request: CreateGroupIdRequest): CreateGroupIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return createGroupIdWithOptions(request, runtime);
}

model DeleteCaCertificateRequest {
  mqttInstanceId?: string(name='MqttInstanceId'),
  sn?: string(name='Sn'),
}

model DeleteCaCertificateResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  sn?: string(name='Sn'),
}

model DeleteCaCertificateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteCaCertificateResponseBody(name='body'),
}

async function deleteCaCertificateWithOptions(request: DeleteCaCertificateRequest, runtime: Util.RuntimeOptions): DeleteCaCertificateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.mqttInstanceId)) {
    query['MqttInstanceId'] = request.mqttInstanceId;
  }
  if (!Util.isUnset(request.sn)) {
    query['Sn'] = request.sn;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCaCertificate',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteCaCertificate(request: DeleteCaCertificateRequest): DeleteCaCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCaCertificateWithOptions(request, runtime);
}

model DeleteGroupIdRequest {
  groupId?: string(name='GroupId'),
  instanceId?: string(name='InstanceId'),
}

model DeleteGroupIdResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteGroupIdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteGroupIdResponseBody(name='body'),
}

async function deleteGroupIdWithOptions(request: DeleteGroupIdRequest, runtime: Util.RuntimeOptions): DeleteGroupIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGroupId',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteGroupId(request: DeleteGroupIdRequest): DeleteGroupIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGroupIdWithOptions(request, runtime);
}

model GetCaCertificateRequest {
  mqttInstanceId?: string(name='MqttInstanceId'),
  sn?: string(name='Sn'),
}

model GetCaCertificateResponseBody = {
  data?: {
    caContent?: string(name='CaContent'),
    caName?: string(name='CaName'),
    registrationCode?: string(name='RegistrationCode'),
    sn?: string(name='Sn'),
    status?: string(name='Status'),
    validBegin?: string(name='ValidBegin'),
    validEnd?: string(name='ValidEnd'),
    verificationContent?: string(name='VerificationContent'),
  }(name='Data'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model GetCaCertificateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetCaCertificateResponseBody(name='body'),
}

async function getCaCertificateWithOptions(request: GetCaCertificateRequest, runtime: Util.RuntimeOptions): GetCaCertificateResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCaCertificate',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getCaCertificate(request: GetCaCertificateRequest): GetCaCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCaCertificateWithOptions(request, runtime);
}

model GetDeviceCredentialRequest {
  clientId?: string(name='ClientId'),
  instanceId?: string(name='InstanceId'),
}

model GetDeviceCredentialResponseBody = {
  deviceCredential?: {
    clientId?: string(name='ClientId'),
    createTime?: long(name='CreateTime'),
    deviceAccessKeyId?: string(name='DeviceAccessKeyId'),
    deviceAccessKeySecret?: string(name='DeviceAccessKeySecret'),
    instanceId?: string(name='InstanceId'),
    updateTime?: long(name='UpdateTime'),
  }(name='DeviceCredential'),
  requestId?: string(name='RequestId'),
}

model GetDeviceCredentialResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDeviceCredentialResponseBody(name='body'),
}

async function getDeviceCredentialWithOptions(request: GetDeviceCredentialRequest, runtime: Util.RuntimeOptions): GetDeviceCredentialResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDeviceCredential',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDeviceCredential(request: GetDeviceCredentialRequest): GetDeviceCredentialResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDeviceCredentialWithOptions(request, runtime);
}

model GetRegisterCodeRequest {
  mqttInstanceId?: string(name='MqttInstanceId'),
}

model GetRegisterCodeResponseBody = {
  registerCode?: string(name='RegisterCode', description='注册码'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model GetRegisterCodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRegisterCodeResponseBody(name='body'),
}

async function getRegisterCodeWithOptions(request: GetRegisterCodeRequest, runtime: Util.RuntimeOptions): GetRegisterCodeResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRegisterCode',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRegisterCode(request: GetRegisterCodeRequest): GetRegisterCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRegisterCodeWithOptions(request, runtime);
}

model ListCaCertificateRequest {
  mqttInstanceId?: string(name='MqttInstanceId'),
  pageNo?: string(name='PageNo'),
  pageSize?: string(name='PageSize'),
}

model ListCaCertificateResponseBody = {
  data?: {
    caCertificateVOS?: [ 
      {
        caContent?: string(name='CaContent'),
        caName?: string(name='CaName'),
        registrationCode?: string(name='RegistrationCode'),
        sn?: string(name='Sn'),
        status?: string(name='Status'),
        validBegin?: string(name='ValidBegin'),
        validEnd?: string(name='ValidEnd'),
        verificationContent?: string(name='VerificationContent'),
      }
    ](name='CaCertificateVOS'),
    pageNo?: int32(name='PageNo'),
    pageSize?: int32(name='PageSize'),
    total?: int32(name='Total'),
  }(name='Data'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ListCaCertificateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListCaCertificateResponseBody(name='body'),
}

async function listCaCertificateWithOptions(request: ListCaCertificateRequest, runtime: Util.RuntimeOptions): ListCaCertificateResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCaCertificate',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listCaCertificate(request: ListCaCertificateRequest): ListCaCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCaCertificateWithOptions(request, runtime);
}

model ListGroupIdRequest {
  instanceId?: string(name='InstanceId'),
}

model ListGroupIdResponseBody = {
  data?: [ 
    {
      createTime?: long(name='CreateTime'),
      groupId?: string(name='GroupId'),
      independentNaming?: boolean(name='IndependentNaming'),
      instanceId?: string(name='InstanceId'),
      updateTime?: long(name='UpdateTime'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
}

model ListGroupIdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListGroupIdResponseBody(name='body'),
}

async function listGroupIdWithOptions(request: ListGroupIdRequest, runtime: Util.RuntimeOptions): ListGroupIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListGroupId',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listGroupId(request: ListGroupIdRequest): ListGroupIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return listGroupIdWithOptions(request, runtime);
}

model QueryMqttTraceDeviceRequest {
  beginTime?: long(name='BeginTime'),
  clientId?: string(name='ClientId'),
  currentPage?: int32(name='CurrentPage'),
  endTime?: long(name='EndTime'),
  instanceId?: string(name='InstanceId'),
  mqttRegionId?: string(name='MqttRegionId'),
  pageSize?: int32(name='PageSize'),
  reverse?: boolean(name='Reverse'),
}

model QueryMqttTraceDeviceResponseBody = {
  currentPage?: int32(name='CurrentPage'),
  deviceInfoList?: [ 
    {
      action?: string(name='Action'),
      actionCode?: string(name='ActionCode'),
      actionInfo?: string(name='ActionInfo'),
      channelId?: string(name='ChannelId'),
      time?: string(name='Time'),
    }
  ](name='DeviceInfoList'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  total?: long(name='Total'),
}

model QueryMqttTraceDeviceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryMqttTraceDeviceResponseBody(name='body'),
}

async function queryMqttTraceDeviceWithOptions(request: QueryMqttTraceDeviceRequest, runtime: Util.RuntimeOptions): QueryMqttTraceDeviceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.beginTime)) {
    query['BeginTime'] = request.beginTime;
  }
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.mqttRegionId)) {
    query['MqttRegionId'] = request.mqttRegionId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.reverse)) {
    query['Reverse'] = request.reverse;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryMqttTraceDevice',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryMqttTraceDevice(request: QueryMqttTraceDeviceRequest): QueryMqttTraceDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMqttTraceDeviceWithOptions(request, runtime);
}

model QueryMqttTraceMessageOfClientRequest {
  beginTime?: long(name='BeginTime'),
  clientId?: string(name='ClientId'),
  currentPage?: int32(name='CurrentPage'),
  endTime?: long(name='EndTime'),
  instanceId?: string(name='InstanceId'),
  mqttRegionId?: string(name='MqttRegionId'),
  pageSize?: int32(name='PageSize'),
  reverse?: boolean(name='Reverse'),
}

model QueryMqttTraceMessageOfClientResponseBody = {
  currentPage?: int32(name='CurrentPage'),
  messageOfClientList?: [ 
    {
      action?: string(name='Action'),
      actionCode?: string(name='ActionCode'),
      actionInfo?: string(name='ActionInfo'),
      clientId?: string(name='ClientId'),
      msgId?: string(name='MsgId'),
      time?: string(name='Time'),
    }
  ](name='MessageOfClientList'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  total?: long(name='Total'),
}

model QueryMqttTraceMessageOfClientResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryMqttTraceMessageOfClientResponseBody(name='body'),
}

async function queryMqttTraceMessageOfClientWithOptions(request: QueryMqttTraceMessageOfClientRequest, runtime: Util.RuntimeOptions): QueryMqttTraceMessageOfClientResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.beginTime)) {
    query['BeginTime'] = request.beginTime;
  }
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.mqttRegionId)) {
    query['MqttRegionId'] = request.mqttRegionId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.reverse)) {
    query['Reverse'] = request.reverse;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryMqttTraceMessageOfClient',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryMqttTraceMessageOfClient(request: QueryMqttTraceMessageOfClientRequest): QueryMqttTraceMessageOfClientResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMqttTraceMessageOfClientWithOptions(request, runtime);
}

model QueryMqttTraceMessagePublishRequest {
  beginTime?: long(name='BeginTime'),
  endTime?: long(name='EndTime'),
  instanceId?: string(name='InstanceId'),
  mqttRegionId?: string(name='MqttRegionId'),
  msgId?: string(name='MsgId'),
}

model QueryMqttTraceMessagePublishResponseBody = {
  messageTraceLists?: [ 
    {
      action?: string(name='Action'),
      actionCode?: string(name='ActionCode'),
      actionInfo?: string(name='ActionInfo'),
      clientId?: string(name='ClientId'),
      msgId?: string(name='MsgId'),
      time?: string(name='Time'),
    }
  ](name='MessageTraceLists'),
  requestId?: string(name='RequestId'),
}

model QueryMqttTraceMessagePublishResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryMqttTraceMessagePublishResponseBody(name='body'),
}

async function queryMqttTraceMessagePublishWithOptions(request: QueryMqttTraceMessagePublishRequest, runtime: Util.RuntimeOptions): QueryMqttTraceMessagePublishResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.beginTime)) {
    query['BeginTime'] = request.beginTime;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.mqttRegionId)) {
    query['MqttRegionId'] = request.mqttRegionId;
  }
  if (!Util.isUnset(request.msgId)) {
    query['MsgId'] = request.msgId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryMqttTraceMessagePublish',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryMqttTraceMessagePublish(request: QueryMqttTraceMessagePublishRequest): QueryMqttTraceMessagePublishResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMqttTraceMessagePublishWithOptions(request, runtime);
}

model QueryMqttTraceMessageSubscribeRequest {
  beginTime?: long(name='BeginTime'),
  clientId?: string(name='ClientId'),
  currentPage?: int32(name='CurrentPage'),
  endTime?: long(name='EndTime'),
  instanceId?: string(name='InstanceId'),
  mqttRegionId?: string(name='MqttRegionId'),
  msgId?: string(name='MsgId'),
  pageSize?: int32(name='PageSize'),
  reverse?: boolean(name='Reverse'),
}

model QueryMqttTraceMessageSubscribeResponseBody = {
  currentPage?: int32(name='CurrentPage'),
  messageTraceLists?: [ 
    {
      action?: string(name='Action'),
      actionCode?: string(name='ActionCode'),
      actionInfo?: string(name='ActionInfo'),
      clientId?: string(name='ClientId'),
      msgId?: string(name='MsgId'),
      time?: string(name='Time'),
    }
  ](name='MessageTraceLists'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  total?: long(name='Total'),
}

model QueryMqttTraceMessageSubscribeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryMqttTraceMessageSubscribeResponseBody(name='body'),
}

async function queryMqttTraceMessageSubscribeWithOptions(request: QueryMqttTraceMessageSubscribeRequest, runtime: Util.RuntimeOptions): QueryMqttTraceMessageSubscribeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.beginTime)) {
    query['BeginTime'] = request.beginTime;
  }
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.mqttRegionId)) {
    query['MqttRegionId'] = request.mqttRegionId;
  }
  if (!Util.isUnset(request.msgId)) {
    query['MsgId'] = request.msgId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.reverse)) {
    query['Reverse'] = request.reverse;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryMqttTraceMessageSubscribe',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryMqttTraceMessageSubscribe(request: QueryMqttTraceMessageSubscribeRequest): QueryMqttTraceMessageSubscribeResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMqttTraceMessageSubscribeWithOptions(request, runtime);
}

model QuerySessionByClientIdRequest {
  clientId?: string(name='ClientId'),
  instanceId?: string(name='InstanceId'),
}

model QuerySessionByClientIdResponseBody = {
  onlineStatus?: boolean(name='OnlineStatus'),
  requestId?: string(name='RequestId'),
}

model QuerySessionByClientIdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QuerySessionByClientIdResponseBody(name='body'),
}

async function querySessionByClientIdWithOptions(request: QuerySessionByClientIdRequest, runtime: Util.RuntimeOptions): QuerySessionByClientIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QuerySessionByClientId',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function querySessionByClientId(request: QuerySessionByClientIdRequest): QuerySessionByClientIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySessionByClientIdWithOptions(request, runtime);
}

model QueryTokenRequest {
  instanceId?: string(name='InstanceId'),
  token?: string(name='Token'),
}

model QueryTokenResponseBody = {
  requestId?: string(name='RequestId'),
  tokenStatus?: boolean(name='TokenStatus'),
}

model QueryTokenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTokenResponseBody(name='body'),
}

async function queryTokenWithOptions(request: QueryTokenRequest, runtime: Util.RuntimeOptions): QueryTokenResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.token)) {
    query['Token'] = request.token;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryToken',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryToken(request: QueryTokenRequest): QueryTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTokenWithOptions(request, runtime);
}

model RefreshDeviceCredentialRequest {
  clientId?: string(name='ClientId'),
  instanceId?: string(name='InstanceId'),
}

model RefreshDeviceCredentialResponseBody = {
  deviceCredential?: {
    clientId?: string(name='ClientId'),
    createTime?: long(name='CreateTime'),
    deviceAccessKeyId?: string(name='DeviceAccessKeyId'),
    deviceAccessKeySecret?: string(name='DeviceAccessKeySecret'),
    instanceId?: string(name='InstanceId'),
    updateTime?: long(name='UpdateTime'),
  }(name='DeviceCredential'),
  requestId?: string(name='RequestId'),
}

model RefreshDeviceCredentialResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RefreshDeviceCredentialResponseBody(name='body'),
}

async function refreshDeviceCredentialWithOptions(request: RefreshDeviceCredentialRequest, runtime: Util.RuntimeOptions): RefreshDeviceCredentialResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RefreshDeviceCredential',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function refreshDeviceCredential(request: RefreshDeviceCredentialRequest): RefreshDeviceCredentialResponse {
  var runtime = new Util.RuntimeOptions{};
  return refreshDeviceCredentialWithOptions(request, runtime);
}

model RegisterCaCertificateRequest {
  caContent?: string(name='CaContent'),
  caName?: string(name='CaName'),
  mqttInstanceId?: string(name='MqttInstanceId'),
  verificationContent?: string(name='VerificationContent'),
}

model RegisterCaCertificateResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  sn?: string(name='Sn'),
}

model RegisterCaCertificateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RegisterCaCertificateResponseBody(name='body'),
}

async function registerCaCertificateWithOptions(request: RegisterCaCertificateRequest, runtime: Util.RuntimeOptions): RegisterCaCertificateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.caContent)) {
    query['CaContent'] = request.caContent;
  }
  if (!Util.isUnset(request.caName)) {
    query['CaName'] = request.caName;
  }
  if (!Util.isUnset(request.mqttInstanceId)) {
    query['MqttInstanceId'] = request.mqttInstanceId;
  }
  if (!Util.isUnset(request.verificationContent)) {
    query['VerificationContent'] = request.verificationContent;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RegisterCaCertificate',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function registerCaCertificate(request: RegisterCaCertificateRequest): RegisterCaCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return registerCaCertificateWithOptions(request, runtime);
}

model RegisterDeviceCredentialRequest {
  clientId?: string(name='ClientId'),
  instanceId?: string(name='InstanceId'),
}

model RegisterDeviceCredentialResponseBody = {
  deviceCredential?: {
    clientId?: string(name='ClientId'),
    createTime?: long(name='CreateTime'),
    deviceAccessKeyId?: string(name='DeviceAccessKeyId'),
    deviceAccessKeySecret?: string(name='DeviceAccessKeySecret'),
    instanceId?: string(name='InstanceId'),
    updateTime?: long(name='UpdateTime'),
  }(name='DeviceCredential'),
  requestId?: string(name='RequestId'),
}

model RegisterDeviceCredentialResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RegisterDeviceCredentialResponseBody(name='body'),
}

async function registerDeviceCredentialWithOptions(request: RegisterDeviceCredentialRequest, runtime: Util.RuntimeOptions): RegisterDeviceCredentialResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RegisterDeviceCredential',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function registerDeviceCredential(request: RegisterDeviceCredentialRequest): RegisterDeviceCredentialResponse {
  var runtime = new Util.RuntimeOptions{};
  return registerDeviceCredentialWithOptions(request, runtime);
}

model RevokeTokenRequest {
  instanceId?: string(name='InstanceId'),
  token?: string(name='Token'),
}

model RevokeTokenResponseBody = {
  requestId?: string(name='RequestId'),
}

model RevokeTokenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RevokeTokenResponseBody(name='body'),
}

async function revokeTokenWithOptions(request: RevokeTokenRequest, runtime: Util.RuntimeOptions): RevokeTokenResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.token)) {
    query['Token'] = request.token;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RevokeToken',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function revokeToken(request: RevokeTokenRequest): RevokeTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return revokeTokenWithOptions(request, runtime);
}

model SendMessageRequest {
  instanceId?: string(name='InstanceId'),
  mqttTopic?: string(name='MqttTopic'),
  payload?: string(name='Payload'),
}

model SendMessageResponseBody = {
  msgId?: string(name='MsgId'),
  requestId?: string(name='RequestId'),
}

model SendMessageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SendMessageResponseBody(name='body'),
}

async function sendMessageWithOptions(request: SendMessageRequest, runtime: Util.RuntimeOptions): SendMessageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.mqttTopic)) {
    query['MqttTopic'] = request.mqttTopic;
  }
  if (!Util.isUnset(request.payload)) {
    query['Payload'] = request.payload;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SendMessage',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function sendMessage(request: SendMessageRequest): SendMessageResponse {
  var runtime = new Util.RuntimeOptions{};
  return sendMessageWithOptions(request, runtime);
}

model UnRegisterDeviceCredentialRequest {
  clientId?: string(name='ClientId'),
  instanceId?: string(name='InstanceId'),
}

model UnRegisterDeviceCredentialResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnRegisterDeviceCredentialResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UnRegisterDeviceCredentialResponseBody(name='body'),
}

async function unRegisterDeviceCredentialWithOptions(request: UnRegisterDeviceCredentialRequest, runtime: Util.RuntimeOptions): UnRegisterDeviceCredentialResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UnRegisterDeviceCredential',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function unRegisterDeviceCredential(request: UnRegisterDeviceCredentialRequest): UnRegisterDeviceCredentialResponse {
  var runtime = new Util.RuntimeOptions{};
  return unRegisterDeviceCredentialWithOptions(request, runtime);
}

model UnregisterCaCertificateRequest {
  mqttInstanceId?: string(name='MqttInstanceId'),
  sn?: string(name='Sn'),
}

model UnregisterCaCertificateResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  sn?: string(name='Sn'),
}

model UnregisterCaCertificateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UnregisterCaCertificateResponseBody(name='body'),
}

async function unregisterCaCertificateWithOptions(request: UnregisterCaCertificateRequest, runtime: Util.RuntimeOptions): UnregisterCaCertificateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.mqttInstanceId)) {
    query['MqttInstanceId'] = request.mqttInstanceId;
  }
  if (!Util.isUnset(request.sn)) {
    query['Sn'] = request.sn;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UnregisterCaCertificate',
    version = '2020-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function unregisterCaCertificate(request: UnregisterCaCertificateRequest): UnregisterCaCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return unregisterCaCertificateWithOptions(request, runtime);
}

