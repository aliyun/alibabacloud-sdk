/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'central';
  @endpointMap = {
    ap-northeast-1 = 'cdn.ap-southeast-1.aliyuncs.com',
    ap-south-1 = 'cdn.ap-southeast-1.aliyuncs.com',
    ap-southeast-1 = 'cdn.ap-southeast-1.aliyuncs.com',
    ap-southeast-2 = 'cdn.ap-southeast-1.aliyuncs.com',
    ap-southeast-3 = 'cdn.ap-southeast-1.aliyuncs.com',
    ap-southeast-5 = 'cdn.ap-southeast-1.aliyuncs.com',
    eu-central-1 = 'cdn.ap-southeast-1.aliyuncs.com',
    eu-west-1 = 'cdn.ap-southeast-1.aliyuncs.com',
    me-east-1 = 'cdn.ap-southeast-1.aliyuncs.com',
    us-east-1 = 'cdn.ap-southeast-1.aliyuncs.com',
    us-west-1 = 'cdn.ap-southeast-1.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('cdn', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AddCdnDomainRequest {
  cdnType?: string(name='CdnType'),
  checkUrl?: string(name='CheckUrl'),
  domainName?: string(name='DomainName'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  priorities?: string(name='Priorities'),
  region?: string(name='Region'),
  resourceGroupId?: string(name='ResourceGroupId'),
  scope?: string(name='Scope'),
  securityToken?: string(name='SecurityToken'),
  sourcePort?: int32(name='SourcePort'),
  sourceType?: string(name='SourceType'),
  sources?: string(name='Sources'),
  topLevelDomain?: string(name='TopLevelDomain'),
}

model AddCdnDomainResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddCdnDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddCdnDomainResponseBody(name='body'),
}

async function addCdnDomainWithOptions(request: AddCdnDomainRequest, runtime: Util.RuntimeOptions): AddCdnDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cdnType)) {
    query['CdnType'] = request.cdnType;
  }
  if (!Util.isUnset(request.checkUrl)) {
    query['CheckUrl'] = request.checkUrl;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.priorities)) {
    query['Priorities'] = request.priorities;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.scope)) {
    query['Scope'] = request.scope;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.sourcePort)) {
    query['SourcePort'] = request.sourcePort;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  if (!Util.isUnset(request.sources)) {
    query['Sources'] = request.sources;
  }
  if (!Util.isUnset(request.topLevelDomain)) {
    query['TopLevelDomain'] = request.topLevelDomain;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddCdnDomain',
    version = '2014-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addCdnDomain(request: AddCdnDomainRequest): AddCdnDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return addCdnDomainWithOptions(request, runtime);
}

model DescribeCdnDomainDetailRequest {
  domainName?: string(name='DomainName'),
  ownerId?: long(name='OwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeCdnDomainDetailResponseBody = {
  getDomainDetailModel?: {
    cdnType?: string(name='CdnType'),
    cname?: string(name='Cname'),
    description?: string(name='Description'),
    domainName?: string(name='DomainName'),
    domainStatus?: string(name='DomainStatus'),
    gmtCreated?: string(name='GmtCreated'),
    gmtModified?: string(name='GmtModified'),
    httpsCname?: string(name='HttpsCname'),
    region?: string(name='Region'),
    resourceGroupId?: string(name='ResourceGroupId'),
    scope?: string(name='Scope'),
    serverCertificateStatus?: string(name='ServerCertificateStatus'),
    sourceModels?: {
      sourceModel?: [ 
      {
        content?: string(name='Content'),
        enabled?: string(name='Enabled'),
        port?: int32(name='Port'),
        priority?: string(name='Priority'),
        type?: string(name='Type'),
      }
    ](name='SourceModel')
    }(name='SourceModels'),
    sourcePort?: int32(name='SourcePort'),
    sourceType?: string(name='SourceType'),
    sources?: {
      source?: [ string ](name='Source')
    }(name='Sources'),
  }(name='GetDomainDetailModel'),
  requestId?: string(name='RequestId'),
}

model DescribeCdnDomainDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCdnDomainDetailResponseBody(name='body'),
}

async function describeCdnDomainDetailWithOptions(request: DescribeCdnDomainDetailRequest, runtime: Util.RuntimeOptions): DescribeCdnDomainDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCdnDomainDetail',
    version = '2014-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCdnDomainDetail(request: DescribeCdnDomainDetailRequest): DescribeCdnDomainDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCdnDomainDetailWithOptions(request, runtime);
}

model DescribeCdnDomainLogsRequest {
  domainName?: string(name='DomainName'),
  endTime?: string(name='EndTime'),
  logDay?: string(name='LogDay'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  securityToken?: string(name='SecurityToken'),
  startTime?: string(name='StartTime'),
}

model DescribeCdnDomainLogsResponseBody = {
  domainLogModel?: {
    domainLogDetails?: {
      domainLogDetail?: [ 
      {
        endTime?: string(name='EndTime'),
        logName?: string(name='LogName'),
        logPath?: string(name='LogPath'),
        logSize?: long(name='LogSize'),
        startTime?: string(name='StartTime'),
      }
    ](name='DomainLogDetail')
    }(name='DomainLogDetails'),
    domainName?: string(name='DomainName'),
  }(name='DomainLogModel'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribeCdnDomainLogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCdnDomainLogsResponseBody(name='body'),
}

async function describeCdnDomainLogsWithOptions(request: DescribeCdnDomainLogsRequest, runtime: Util.RuntimeOptions): DescribeCdnDomainLogsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.logDay)) {
    query['LogDay'] = request.logDay;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCdnDomainLogs',
    version = '2014-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCdnDomainLogs(request: DescribeCdnDomainLogsRequest): DescribeCdnDomainLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCdnDomainLogsWithOptions(request, runtime);
}

model DescribeCdnServiceRequest {
  ownerId?: long(name='OwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeCdnServiceResponseBody = {
  changingAffectTime?: string(name='ChangingAffectTime'),
  changingChargeType?: string(name='ChangingChargeType'),
  instanceId?: string(name='InstanceId'),
  internetChargeType?: string(name='InternetChargeType'),
  openingTime?: string(name='OpeningTime'),
  operationLocks?: {
    lockReason?: [ 
    {
      lockReason?: string(name='LockReason'),
    }
  ](name='LockReason')
  }(name='OperationLocks'),
  requestId?: string(name='RequestId'),
}

model DescribeCdnServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCdnServiceResponseBody(name='body'),
}

async function describeCdnServiceWithOptions(request: DescribeCdnServiceRequest, runtime: Util.RuntimeOptions): DescribeCdnServiceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCdnService',
    version = '2014-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCdnService(request: DescribeCdnServiceRequest): DescribeCdnServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCdnServiceWithOptions(request, runtime);
}

model DescribeDomainBpsDataRequest {
  domainName?: string(name='DomainName'),
  domainType?: string(name='DomainType'),
  endTime?: string(name='EndTime'),
  interval?: string(name='Interval'),
  ispNameEn?: string(name='IspNameEn'),
  locationNameEn?: string(name='LocationNameEn'),
  startTime?: string(name='StartTime'),
  timeMerge?: string(name='TimeMerge'),
}

model DescribeDomainBpsDataResponseBody = {
  bpsDataPerInterval?: {
    dataModule?: [ 
    {
      domesticL2Value?: string(name='DomesticL2Value'),
      domesticValue?: string(name='DomesticValue'),
      dynamicDomesticValue?: string(name='DynamicDomesticValue'),
      dynamicOverseasValue?: string(name='DynamicOverseasValue'),
      dynamicValue?: string(name='DynamicValue'),
      l2Value?: string(name='L2Value'),
      overseasL2Value?: string(name='OverseasL2Value'),
      overseasValue?: string(name='OverseasValue'),
      staticDomesticValue?: string(name='StaticDomesticValue'),
      staticOverseasValue?: string(name='StaticOverseasValue'),
      staticValue?: string(name='StaticValue'),
      timeStamp?: string(name='TimeStamp'),
      value?: string(name='Value'),
    }
  ](name='DataModule')
  }(name='BpsDataPerInterval'),
  dataInterval?: string(name='DataInterval'),
  domainName?: string(name='DomainName'),
  endTime?: string(name='EndTime'),
  ispName?: string(name='IspName'),
  ispNameEn?: string(name='IspNameEn'),
  locationName?: string(name='LocationName'),
  locationNameEn?: string(name='LocationNameEn'),
  requestId?: string(name='RequestId'),
  startTime?: string(name='StartTime'),
}

model DescribeDomainBpsDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDomainBpsDataResponseBody(name='body'),
}

async function describeDomainBpsDataWithOptions(request: DescribeDomainBpsDataRequest, runtime: Util.RuntimeOptions): DescribeDomainBpsDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.domainType)) {
    query['DomainType'] = request.domainType;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.ispNameEn)) {
    query['IspNameEn'] = request.ispNameEn;
  }
  if (!Util.isUnset(request.locationNameEn)) {
    query['LocationNameEn'] = request.locationNameEn;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.timeMerge)) {
    query['TimeMerge'] = request.timeMerge;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainBpsData',
    version = '2014-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDomainBpsData(request: DescribeDomainBpsDataRequest): DescribeDomainBpsDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainBpsDataWithOptions(request, runtime);
}

model DescribeDomainBpsDataByTimeStampRequest {
  domainName?: string(name='DomainName'),
  ispNames?: string(name='IspNames'),
  locationNames?: string(name='LocationNames'),
  timePoint?: string(name='TimePoint'),
}

model DescribeDomainBpsDataByTimeStampResponseBody = {
  bpsDataList?: {
    bpsDataModel?: [ 
    {
      bps?: long(name='Bps'),
      ispName?: string(name='IspName'),
      locationName?: string(name='LocationName'),
      timeStamp?: string(name='TimeStamp'),
    }
  ](name='BpsDataModel')
  }(name='BpsDataList'),
  domainName?: string(name='DomainName'),
  requestId?: string(name='RequestId'),
  timeStamp?: string(name='TimeStamp'),
}

model DescribeDomainBpsDataByTimeStampResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDomainBpsDataByTimeStampResponseBody(name='body'),
}

async function describeDomainBpsDataByTimeStampWithOptions(request: DescribeDomainBpsDataByTimeStampRequest, runtime: Util.RuntimeOptions): DescribeDomainBpsDataByTimeStampResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.ispNames)) {
    query['IspNames'] = request.ispNames;
  }
  if (!Util.isUnset(request.locationNames)) {
    query['LocationNames'] = request.locationNames;
  }
  if (!Util.isUnset(request.timePoint)) {
    query['TimePoint'] = request.timePoint;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainBpsDataByTimeStamp',
    version = '2014-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDomainBpsDataByTimeStamp(request: DescribeDomainBpsDataByTimeStampRequest): DescribeDomainBpsDataByTimeStampResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainBpsDataByTimeStampWithOptions(request, runtime);
}

model DescribeDomainHitRateDataRequest {
  domainName?: string(name='DomainName'),
  endTime?: string(name='EndTime'),
  interval?: string(name='Interval'),
  startTime?: string(name='StartTime'),
}

model DescribeDomainHitRateDataResponseBody = {
  dataInterval?: string(name='DataInterval'),
  domainName?: string(name='DomainName'),
  endTime?: string(name='EndTime'),
  hitRateInterval?: {
    dataModule?: [ 
    {
      timeStamp?: string(name='TimeStamp'),
      value?: string(name='Value'),
    }
  ](name='DataModule')
  }(name='HitRateInterval'),
  requestId?: string(name='RequestId'),
  startTime?: string(name='StartTime'),
}

model DescribeDomainHitRateDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDomainHitRateDataResponseBody(name='body'),
}

async function describeDomainHitRateDataWithOptions(request: DescribeDomainHitRateDataRequest, runtime: Util.RuntimeOptions): DescribeDomainHitRateDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainHitRateData',
    version = '2014-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDomainHitRateData(request: DescribeDomainHitRateDataRequest): DescribeDomainHitRateDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainHitRateDataWithOptions(request, runtime);
}

model DescribeDomainHttpCodeDataRequest {
  domainName?: string(name='DomainName'),
  endTime?: string(name='EndTime'),
  interval?: string(name='Interval'),
  ispNameEn?: string(name='IspNameEn'),
  locationNameEn?: string(name='LocationNameEn'),
  startTime?: string(name='StartTime'),
  timeMerge?: string(name='TimeMerge'),
}

model DescribeDomainHttpCodeDataResponseBody = {
  dataInterval?: string(name='DataInterval'),
  domainName?: string(name='DomainName'),
  endTime?: string(name='EndTime'),
  httpCodeData?: {
    usageData?: [ 
    {
      timeStamp?: string(name='TimeStamp'),
      value?: {
        codeProportionData?: [ 
        {
          code?: string(name='Code'),
          count?: string(name='Count'),
          proportion?: string(name='Proportion'),
        }
      ](name='CodeProportionData')
      }(name='Value'),
    }
  ](name='UsageData')
  }(name='HttpCodeData'),
  requestId?: string(name='RequestId'),
  startTime?: string(name='StartTime'),
}

model DescribeDomainHttpCodeDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDomainHttpCodeDataResponseBody(name='body'),
}

async function describeDomainHttpCodeDataWithOptions(request: DescribeDomainHttpCodeDataRequest, runtime: Util.RuntimeOptions): DescribeDomainHttpCodeDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.ispNameEn)) {
    query['IspNameEn'] = request.ispNameEn;
  }
  if (!Util.isUnset(request.locationNameEn)) {
    query['LocationNameEn'] = request.locationNameEn;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.timeMerge)) {
    query['TimeMerge'] = request.timeMerge;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainHttpCodeData',
    version = '2014-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDomainHttpCodeData(request: DescribeDomainHttpCodeDataRequest): DescribeDomainHttpCodeDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainHttpCodeDataWithOptions(request, runtime);
}

model DescribeDomainQpsDataRequest {
  domainName?: string(name='DomainName'),
  domainType?: string(name='DomainType'),
  endTime?: string(name='EndTime'),
  interval?: string(name='Interval'),
  ispNameEn?: string(name='IspNameEn'),
  locationNameEn?: string(name='LocationNameEn'),
  startTime?: string(name='StartTime'),
  timeMerge?: string(name='TimeMerge'),
}

model DescribeDomainQpsDataResponseBody = {
  dataInterval?: string(name='DataInterval'),
  domainName?: string(name='DomainName'),
  endTime?: string(name='EndTime'),
  qpsDataInterval?: {
    dataModule?: [ 
    {
      accDomesticValue?: string(name='AccDomesticValue'),
      accOverseasValue?: string(name='AccOverseasValue'),
      accValue?: string(name='AccValue'),
      domesticValue?: string(name='DomesticValue'),
      dynamicDomesticValue?: string(name='DynamicDomesticValue'),
      dynamicOverseasValue?: string(name='DynamicOverseasValue'),
      dynamicValue?: string(name='DynamicValue'),
      overseasValue?: string(name='OverseasValue'),
      staticDomesticValue?: string(name='StaticDomesticValue'),
      staticOverseasValue?: string(name='StaticOverseasValue'),
      staticValue?: string(name='StaticValue'),
      timeStamp?: string(name='TimeStamp'),
      value?: string(name='Value'),
    }
  ](name='DataModule')
  }(name='QpsDataInterval'),
  requestId?: string(name='RequestId'),
  startTime?: string(name='StartTime'),
}

model DescribeDomainQpsDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDomainQpsDataResponseBody(name='body'),
}

async function describeDomainQpsDataWithOptions(request: DescribeDomainQpsDataRequest, runtime: Util.RuntimeOptions): DescribeDomainQpsDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.domainType)) {
    query['DomainType'] = request.domainType;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.ispNameEn)) {
    query['IspNameEn'] = request.ispNameEn;
  }
  if (!Util.isUnset(request.locationNameEn)) {
    query['LocationNameEn'] = request.locationNameEn;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.timeMerge)) {
    query['TimeMerge'] = request.timeMerge;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainQpsData',
    version = '2014-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDomainQpsData(request: DescribeDomainQpsDataRequest): DescribeDomainQpsDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainQpsDataWithOptions(request, runtime);
}

model DescribeDomainReqHitRateDataRequest {
  domainName?: string(name='DomainName'),
  endTime?: string(name='EndTime'),
  interval?: string(name='Interval'),
  startTime?: string(name='StartTime'),
}

model DescribeDomainReqHitRateDataResponseBody = {
  dataInterval?: string(name='DataInterval'),
  domainName?: string(name='DomainName'),
  endTime?: string(name='EndTime'),
  reqHitRateInterval?: {
    dataModule?: [ 
    {
      timeStamp?: string(name='TimeStamp'),
      value?: string(name='Value'),
    }
  ](name='DataModule')
  }(name='ReqHitRateInterval'),
  requestId?: string(name='RequestId'),
  startTime?: string(name='StartTime'),
}

model DescribeDomainReqHitRateDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDomainReqHitRateDataResponseBody(name='body'),
}

async function describeDomainReqHitRateDataWithOptions(request: DescribeDomainReqHitRateDataRequest, runtime: Util.RuntimeOptions): DescribeDomainReqHitRateDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainReqHitRateData',
    version = '2014-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDomainReqHitRateData(request: DescribeDomainReqHitRateDataRequest): DescribeDomainReqHitRateDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainReqHitRateDataWithOptions(request, runtime);
}

model DescribeDomainSrcBpsDataRequest {
  domainName?: string(name='DomainName'),
  endTime?: string(name='EndTime'),
  fixTimeGap?: string(name='FixTimeGap'),
  interval?: string(name='Interval'),
  startTime?: string(name='StartTime'),
  timeMerge?: string(name='TimeMerge'),
}

model DescribeDomainSrcBpsDataResponseBody = {
  dataInterval?: string(name='DataInterval'),
  domainName?: string(name='DomainName'),
  endTime?: string(name='EndTime'),
  requestId?: string(name='RequestId'),
  srcBpsDataPerInterval?: {
    dataModule?: [ 
    {
      timeStamp?: string(name='TimeStamp'),
      value?: string(name='Value'),
    }
  ](name='DataModule')
  }(name='SrcBpsDataPerInterval'),
  startTime?: string(name='StartTime'),
}

model DescribeDomainSrcBpsDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDomainSrcBpsDataResponseBody(name='body'),
}

async function describeDomainSrcBpsDataWithOptions(request: DescribeDomainSrcBpsDataRequest, runtime: Util.RuntimeOptions): DescribeDomainSrcBpsDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.fixTimeGap)) {
    query['FixTimeGap'] = request.fixTimeGap;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.timeMerge)) {
    query['TimeMerge'] = request.timeMerge;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainSrcBpsData',
    version = '2014-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDomainSrcBpsData(request: DescribeDomainSrcBpsDataRequest): DescribeDomainSrcBpsDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainSrcBpsDataWithOptions(request, runtime);
}

model DescribeDomainSrcFlowDataRequest {
  domainName?: string(name='DomainName'),
  endTime?: string(name='EndTime'),
  fixTimeGap?: string(name='FixTimeGap'),
  interval?: string(name='Interval'),
  startTime?: string(name='StartTime'),
  timeMerge?: string(name='TimeMerge'),
}

model DescribeDomainSrcFlowDataResponseBody = {
  dataInterval?: string(name='DataInterval'),
  domainName?: string(name='DomainName'),
  endTime?: string(name='EndTime'),
  requestId?: string(name='RequestId'),
  srcFlowDataPerInterval?: {
    dataModule?: [ 
    {
      timeStamp?: string(name='TimeStamp'),
      value?: string(name='Value'),
    }
  ](name='DataModule')
  }(name='SrcFlowDataPerInterval'),
  startTime?: string(name='StartTime'),
}

model DescribeDomainSrcFlowDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDomainSrcFlowDataResponseBody(name='body'),
}

async function describeDomainSrcFlowDataWithOptions(request: DescribeDomainSrcFlowDataRequest, runtime: Util.RuntimeOptions): DescribeDomainSrcFlowDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.fixTimeGap)) {
    query['FixTimeGap'] = request.fixTimeGap;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.timeMerge)) {
    query['TimeMerge'] = request.timeMerge;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainSrcFlowData',
    version = '2014-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDomainSrcFlowData(request: DescribeDomainSrcFlowDataRequest): DescribeDomainSrcFlowDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainSrcFlowDataWithOptions(request, runtime);
}

model DescribeDomainUvDataRequest {
  domainName?: string(name='DomainName'),
  endTime?: string(name='EndTime'),
  ownerId?: long(name='OwnerId'),
  securityToken?: string(name='SecurityToken'),
  startTime?: string(name='StartTime'),
}

model DescribeDomainUvDataResponseBody = {
  dataInterval?: string(name='DataInterval'),
  domainName?: string(name='DomainName'),
  endTime?: string(name='EndTime'),
  requestId?: string(name='RequestId'),
  startTime?: string(name='StartTime'),
  uvDataInterval?: {
    usageData?: [ 
    {
      timeStamp?: string(name='TimeStamp'),
      value?: string(name='Value'),
    }
  ](name='UsageData')
  }(name='UvDataInterval'),
}

model DescribeDomainUvDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDomainUvDataResponseBody(name='body'),
}

async function describeDomainUvDataWithOptions(request: DescribeDomainUvDataRequest, runtime: Util.RuntimeOptions): DescribeDomainUvDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainUvData',
    version = '2014-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDomainUvData(request: DescribeDomainUvDataRequest): DescribeDomainUvDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainUvDataWithOptions(request, runtime);
}

model DescribeUserDomainsRequest {
  cdnType?: string(name='CdnType'),
  checkDomainShow?: boolean(name='CheckDomainShow'),
  domainName?: string(name='DomainName'),
  domainSearchType?: string(name='DomainSearchType'),
  domainStatus?: string(name='DomainStatus'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  resourceGroupId?: string(name='ResourceGroupId'),
  securityToken?: string(name='SecurityToken'),
  sources?: string(name='Sources'),
}

model DescribeUserDomainsResponseBody = {
  domains?: {
    pageData?: [ 
    {
      cdnType?: string(name='CdnType'),
      cname?: string(name='Cname'),
      description?: string(name='Description'),
      domainName?: string(name='DomainName'),
      domainStatus?: string(name='DomainStatus'),
      gmtCreated?: string(name='GmtCreated'),
      gmtModified?: string(name='GmtModified'),
      resourceGroupId?: string(name='ResourceGroupId'),
      sandbox?: string(name='Sandbox'),
      sourceType?: string(name='SourceType'),
      sources?: {
        source?: [ string ](name='Source')
      }(name='Sources'),
      sslProtocol?: string(name='SslProtocol'),
    }
  ](name='PageData')
  }(name='Domains'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribeUserDomainsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeUserDomainsResponseBody(name='body'),
}

async function describeUserDomainsWithOptions(request: DescribeUserDomainsRequest, runtime: Util.RuntimeOptions): DescribeUserDomainsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cdnType)) {
    query['CdnType'] = request.cdnType;
  }
  if (!Util.isUnset(request.checkDomainShow)) {
    query['CheckDomainShow'] = request.checkDomainShow;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.domainSearchType)) {
    query['DomainSearchType'] = request.domainSearchType;
  }
  if (!Util.isUnset(request.domainStatus)) {
    query['DomainStatus'] = request.domainStatus;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.sources)) {
    query['Sources'] = request.sources;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeUserDomains',
    version = '2014-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeUserDomains(request: DescribeUserDomainsRequest): DescribeUserDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUserDomainsWithOptions(request, runtime);
}

model OpenCdnServiceRequest {
  internetChargeType?: string(name='InternetChargeType'),
  ownerId?: long(name='OwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model OpenCdnServiceResponseBody = {
  requestId?: string(name='RequestId'),
}

model OpenCdnServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OpenCdnServiceResponseBody(name='body'),
}

async function openCdnServiceWithOptions(request: OpenCdnServiceRequest, runtime: Util.RuntimeOptions): OpenCdnServiceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.internetChargeType)) {
    query['InternetChargeType'] = request.internetChargeType;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OpenCdnService',
    version = '2014-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function openCdnService(request: OpenCdnServiceRequest): OpenCdnServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return openCdnServiceWithOptions(request, runtime);
}

model PushObjectCacheRequest {
  area?: string(name='Area'),
  objectPath?: string(name='ObjectPath'),
  ownerId?: long(name='OwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model PushObjectCacheResponseBody = {
  pushTaskId?: string(name='PushTaskId'),
  requestId?: string(name='RequestId'),
}

model PushObjectCacheResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PushObjectCacheResponseBody(name='body'),
}

async function pushObjectCacheWithOptions(request: PushObjectCacheRequest, runtime: Util.RuntimeOptions): PushObjectCacheResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.area)) {
    query['Area'] = request.area;
  }
  if (!Util.isUnset(request.objectPath)) {
    query['ObjectPath'] = request.objectPath;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PushObjectCache',
    version = '2014-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function pushObjectCache(request: PushObjectCacheRequest): PushObjectCacheResponse {
  var runtime = new Util.RuntimeOptions{};
  return pushObjectCacheWithOptions(request, runtime);
}

model RefreshObjectCachesRequest {
  objectPath?: string(name='ObjectPath'),
  objectType?: string(name='ObjectType'),
  ownerId?: long(name='OwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model RefreshObjectCachesResponseBody = {
  refreshTaskId?: string(name='RefreshTaskId'),
  requestId?: string(name='RequestId'),
}

model RefreshObjectCachesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RefreshObjectCachesResponseBody(name='body'),
}

async function refreshObjectCachesWithOptions(request: RefreshObjectCachesRequest, runtime: Util.RuntimeOptions): RefreshObjectCachesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.objectPath)) {
    query['ObjectPath'] = request.objectPath;
  }
  if (!Util.isUnset(request.objectType)) {
    query['ObjectType'] = request.objectType;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RefreshObjectCaches',
    version = '2014-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function refreshObjectCaches(request: RefreshObjectCachesRequest): RefreshObjectCachesResponse {
  var runtime = new Util.RuntimeOptions{};
  return refreshObjectCachesWithOptions(request, runtime);
}

model TestDescribeDomainBpsDataRequest {
  domainName?: string(name='DomainName'),
  domainType?: string(name='DomainType'),
  endTime?: string(name='EndTime'),
  interval?: string(name='Interval'),
  ispNameEn?: string(name='IspNameEn'),
  locationNameEn?: string(name='LocationNameEn'),
  startTime?: string(name='StartTime'),
  timeMerge?: string(name='TimeMerge'),
}

model TestDescribeDomainBpsDataResponseBody = {
  bpsDataPerInterval?: {
    dataModule?: [ 
    {
      domesticL2Value?: string(name='DomesticL2Value'),
      domesticValue?: string(name='DomesticValue'),
      dynamicDomesticValue?: string(name='DynamicDomesticValue'),
      dynamicOverseasValue?: string(name='DynamicOverseasValue'),
      dynamicValue?: string(name='DynamicValue'),
      l2Value?: string(name='L2Value'),
      overseasL2Value?: string(name='OverseasL2Value'),
      overseasValue?: string(name='OverseasValue'),
      staticDomesticValue?: string(name='StaticDomesticValue'),
      staticOverseasValue?: string(name='StaticOverseasValue'),
      staticValue?: string(name='StaticValue'),
      timeStamp?: string(name='TimeStamp'),
      value?: string(name='Value'),
    }
  ](name='DataModule')
  }(name='BpsDataPerInterval'),
  dataInterval?: string(name='DataInterval'),
  domainName?: string(name='DomainName'),
  endTime?: string(name='EndTime'),
  ispName?: string(name='IspName'),
  ispNameEn?: string(name='IspNameEn'),
  locationName?: string(name='LocationName'),
  locationNameEn?: string(name='LocationNameEn'),
  requestId?: string(name='RequestId'),
  startTime?: string(name='StartTime'),
}

model TestDescribeDomainBpsDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TestDescribeDomainBpsDataResponseBody(name='body'),
}

async function testDescribeDomainBpsDataWithOptions(request: TestDescribeDomainBpsDataRequest, runtime: Util.RuntimeOptions): TestDescribeDomainBpsDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.domainType)) {
    query['DomainType'] = request.domainType;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.ispNameEn)) {
    query['IspNameEn'] = request.ispNameEn;
  }
  if (!Util.isUnset(request.locationNameEn)) {
    query['LocationNameEn'] = request.locationNameEn;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.timeMerge)) {
    query['TimeMerge'] = request.timeMerge;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TestDescribeDomainBpsData',
    version = '2014-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function testDescribeDomainBpsData(request: TestDescribeDomainBpsDataRequest): TestDescribeDomainBpsDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return testDescribeDomainBpsDataWithOptions(request, runtime);
}

