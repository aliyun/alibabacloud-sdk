/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('cc5g', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AddDNSAuthorizationRuleRequest {
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  destinationIp?: string(name='DestinationIp'),
  dryRun?: boolean(name='DryRun'),
  name?: string(name='Name'),
  sourceDNSIp?: string(name='SourceDNSIp'),
  wirelessCloudConnectorId?: string(name='WirelessCloudConnectorId'),
}

model AddDNSAuthorizationRuleResponseBody = {
  authorizationRuleId?: string(name='AuthorizationRuleId'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model AddDNSAuthorizationRuleResponse = {
  headers: map[string]string(name='headers'),
  body: AddDNSAuthorizationRuleResponseBody(name='body'),
}

async function addDNSAuthorizationRuleWithOptions(request: AddDNSAuthorizationRuleRequest, runtime: Util.RuntimeOptions): AddDNSAuthorizationRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.destinationIp)) {
    query['DestinationIp'] = request.destinationIp;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.sourceDNSIp)) {
    query['SourceDNSIp'] = request.sourceDNSIp;
  }
  if (!Util.isUnset(request.wirelessCloudConnectorId)) {
    query['WirelessCloudConnectorId'] = request.wirelessCloudConnectorId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddDNSAuthorizationRule',
    version = '2022-03-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addDNSAuthorizationRule(request: AddDNSAuthorizationRuleRequest): AddDNSAuthorizationRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return addDNSAuthorizationRuleWithOptions(request, runtime);
}

model AttachVpcToNetLinkRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  netLinkId?: string(name='NetLinkId'),
  regionId?: string(name='RegionId'),
  vSwitches?: [ string ](name='VSwitches'),
  vpcId?: string(name='VpcId'),
  wirelessCloudConnectorId?: string(name='WirelessCloudConnectorId'),
}

model AttachVpcToNetLinkResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model AttachVpcToNetLinkResponse = {
  headers: map[string]string(name='headers'),
  body: AttachVpcToNetLinkResponseBody(name='body'),
}

async function attachVpcToNetLinkWithOptions(request: AttachVpcToNetLinkRequest, runtime: Util.RuntimeOptions): AttachVpcToNetLinkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.netLinkId)) {
    query['NetLinkId'] = request.netLinkId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.vSwitches)) {
    query['VSwitches'] = request.vSwitches;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.wirelessCloudConnectorId)) {
    query['WirelessCloudConnectorId'] = request.wirelessCloudConnectorId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AttachVpcToNetLink',
    version = '2022-03-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function attachVpcToNetLink(request: AttachVpcToNetLinkRequest): AttachVpcToNetLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachVpcToNetLinkWithOptions(request, runtime);
}

model CreateAuthorizationRuleRequest {
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  destination?: string(name='Destination'),
  destinationType?: string(name='DestinationType'),
  dryRun?: boolean(name='DryRun'),
  name?: string(name='Name'),
  policy?: string(name='Policy'),
  sourceCidr?: string(name='SourceCidr'),
  wirelessCloudConnectorId?: string(name='WirelessCloudConnectorId'),
}

model CreateAuthorizationRuleResponseBody = {
  authorizationRuleId?: string(name='AuthorizationRuleId'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model CreateAuthorizationRuleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateAuthorizationRuleResponseBody(name='body'),
}

async function createAuthorizationRuleWithOptions(request: CreateAuthorizationRuleRequest, runtime: Util.RuntimeOptions): CreateAuthorizationRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.destination)) {
    query['Destination'] = request.destination;
  }
  if (!Util.isUnset(request.destinationType)) {
    query['DestinationType'] = request.destinationType;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.policy)) {
    query['Policy'] = request.policy;
  }
  if (!Util.isUnset(request.sourceCidr)) {
    query['SourceCidr'] = request.sourceCidr;
  }
  if (!Util.isUnset(request.wirelessCloudConnectorId)) {
    query['WirelessCloudConnectorId'] = request.wirelessCloudConnectorId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateAuthorizationRule',
    version = '2022-03-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createAuthorizationRule(request: CreateAuthorizationRuleRequest): CreateAuthorizationRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAuthorizationRuleWithOptions(request, runtime);
}

model CreateWirelessCloudConnectorRequest {
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  dryRun?: boolean(name='DryRun'),
  ISP?: string(name='ISP'),
  name?: string(name='Name'),
  netLinks?: [ 
    {
      APN?: string(name='APN'),
      regionId?: string(name='RegionId'),
      vSwitchs?: [ string ](name='VSwitchs'),
      vpcId?: string(name='VpcId'),
    }
  ](name='NetLinks'),
  regionId?: string(name='RegionId'),
  useCase?: string(name='UseCase'),
}

model CreateWirelessCloudConnectorResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  wirelessCloudConnectorId?: string(name='WirelessCloudConnectorId'),
}

model CreateWirelessCloudConnectorResponse = {
  headers: map[string]string(name='headers'),
  body: CreateWirelessCloudConnectorResponseBody(name='body'),
}

async function createWirelessCloudConnectorWithOptions(request: CreateWirelessCloudConnectorRequest, runtime: Util.RuntimeOptions): CreateWirelessCloudConnectorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.ISP)) {
    query['ISP'] = request.ISP;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.netLinks)) {
    query['NetLinks'] = request.netLinks;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.useCase)) {
    query['UseCase'] = request.useCase;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateWirelessCloudConnector',
    version = '2022-03-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createWirelessCloudConnector(request: CreateWirelessCloudConnectorRequest): CreateWirelessCloudConnectorResponse {
  var runtime = new Util.RuntimeOptions{};
  return createWirelessCloudConnectorWithOptions(request, runtime);
}

model DeleteAuthorizationRuleRequest {
  authorizationRuleId?: string(name='AuthorizationRuleId'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  wirelessCloudConnectorId?: string(name='WirelessCloudConnectorId'),
}

model DeleteAuthorizationRuleResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteAuthorizationRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAuthorizationRuleResponseBody(name='body'),
}

async function deleteAuthorizationRuleWithOptions(request: DeleteAuthorizationRuleRequest, runtime: Util.RuntimeOptions): DeleteAuthorizationRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.authorizationRuleId)) {
    query['AuthorizationRuleId'] = request.authorizationRuleId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.wirelessCloudConnectorId)) {
    query['WirelessCloudConnectorId'] = request.wirelessCloudConnectorId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAuthorizationRule',
    version = '2022-03-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteAuthorizationRule(request: DeleteAuthorizationRuleRequest): DeleteAuthorizationRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAuthorizationRuleWithOptions(request, runtime);
}

model DeleteWirelessCloudConnectorRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  wirelessCloudConnectorId?: string(name='WirelessCloudConnectorId'),
}

model DeleteWirelessCloudConnectorResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteWirelessCloudConnectorResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteWirelessCloudConnectorResponseBody(name='body'),
}

async function deleteWirelessCloudConnectorWithOptions(request: DeleteWirelessCloudConnectorRequest, runtime: Util.RuntimeOptions): DeleteWirelessCloudConnectorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.wirelessCloudConnectorId)) {
    query['WirelessCloudConnectorId'] = request.wirelessCloudConnectorId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteWirelessCloudConnector',
    version = '2022-03-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteWirelessCloudConnector(request: DeleteWirelessCloudConnectorRequest): DeleteWirelessCloudConnectorResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteWirelessCloudConnectorWithOptions(request, runtime);
}

model DetachVpcFromNetLinkRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  netLinkId?: string(name='NetLinkId'),
  wirelessCloudConnectorId?: string(name='WirelessCloudConnectorId'),
}

model DetachVpcFromNetLinkResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DetachVpcFromNetLinkResponse = {
  headers: map[string]string(name='headers'),
  body: DetachVpcFromNetLinkResponseBody(name='body'),
}

async function detachVpcFromNetLinkWithOptions(request: DetachVpcFromNetLinkRequest, runtime: Util.RuntimeOptions): DetachVpcFromNetLinkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.netLinkId)) {
    query['NetLinkId'] = request.netLinkId;
  }
  if (!Util.isUnset(request.wirelessCloudConnectorId)) {
    query['WirelessCloudConnectorId'] = request.wirelessCloudConnectorId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DetachVpcFromNetLink',
    version = '2022-03-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detachVpcFromNetLink(request: DetachVpcFromNetLinkRequest): DetachVpcFromNetLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachVpcFromNetLinkWithOptions(request, runtime);
}

model ListZonesRequest {
  regionId?: string(name='RegionId'),
}

model ListZonesResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  zones?: [ 
    {
      localName?: string(name='LocalName', description='创建时间'),
      zoneId?: string(name='ZoneId', description='资源名称'),
    }
  ](name='Zones', description='数组，返回示例目录。'),
}

model ListZonesResponse = {
  headers: map[string]string(name='headers'),
  body: ListZonesResponseBody(name='body'),
}

async function listZonesWithOptions(request: ListZonesRequest, runtime: Util.RuntimeOptions): ListZonesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListZones',
    version = '2022-03-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listZones(request: ListZonesRequest): ListZonesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listZonesWithOptions(request, runtime);
}

model OpenCc5gServiceRequest {
  regionId?: string(name='RegionId'),
}

model OpenCc5gServiceResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model OpenCc5gServiceResponse = {
  headers: map[string]string(name='headers'),
  body: OpenCc5gServiceResponseBody(name='body'),
}

async function openCc5gServiceWithOptions(request: OpenCc5gServiceRequest, runtime: Util.RuntimeOptions): OpenCc5gServiceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OpenCc5gService',
    version = '2022-03-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function openCc5gService(request: OpenCc5gServiceRequest): OpenCc5gServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return openCc5gServiceWithOptions(request, runtime);
}

model UpdateAuthorizationRuleRequest {
  authorizationRuleId?: string(name='AuthorizationRuleId'),
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  destination?: string(name='Destination'),
  dryRun?: boolean(name='DryRun'),
  name?: string(name='Name'),
  policy?: string(name='Policy'),
  sourceCidr?: string(name='SourceCidr'),
  wirelessCloudConnectorId?: string(name='WirelessCloudConnectorId'),
}

model UpdateAuthorizationRuleResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model UpdateAuthorizationRuleResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAuthorizationRuleResponseBody(name='body'),
}

async function updateAuthorizationRuleWithOptions(request: UpdateAuthorizationRuleRequest, runtime: Util.RuntimeOptions): UpdateAuthorizationRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.authorizationRuleId)) {
    query['AuthorizationRuleId'] = request.authorizationRuleId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.destination)) {
    query['Destination'] = request.destination;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.policy)) {
    query['Policy'] = request.policy;
  }
  if (!Util.isUnset(request.sourceCidr)) {
    query['SourceCidr'] = request.sourceCidr;
  }
  if (!Util.isUnset(request.wirelessCloudConnectorId)) {
    query['WirelessCloudConnectorId'] = request.wirelessCloudConnectorId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAuthorizationRule',
    version = '2022-03-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAuthorizationRule(request: UpdateAuthorizationRuleRequest): UpdateAuthorizationRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAuthorizationRuleWithOptions(request, runtime);
}

model UpdateCardRequest {
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  dryRun?: boolean(name='DryRun'),
  iccid?: string(name='Iccid'),
  name?: string(name='Name'),
  wirelessCloudConnectorId?: string(name='WirelessCloudConnectorId'),
}

model UpdateCardResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model UpdateCardResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateCardResponseBody(name='body'),
}

async function updateCardWithOptions(request: UpdateCardRequest, runtime: Util.RuntimeOptions): UpdateCardResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.iccid)) {
    query['Iccid'] = request.iccid;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.wirelessCloudConnectorId)) {
    query['WirelessCloudConnectorId'] = request.wirelessCloudConnectorId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateCard',
    version = '2022-03-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateCard(request: UpdateCardRequest): UpdateCardResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateCardWithOptions(request, runtime);
}

model UpdateDNSAuthorizationRuleRequest {
  authorizationRuleId?: string(name='AuthorizationRuleId'),
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  destinationIp?: string(name='DestinationIp'),
  dryRun?: boolean(name='DryRun'),
  name?: string(name='Name'),
  sourceDNSIp?: string(name='SourceDNSIp'),
  wirelessCloudConnectorId?: string(name='WirelessCloudConnectorId'),
}

model UpdateDNSAuthorizationRuleResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model UpdateDNSAuthorizationRuleResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateDNSAuthorizationRuleResponseBody(name='body'),
}

async function updateDNSAuthorizationRuleWithOptions(request: UpdateDNSAuthorizationRuleRequest, runtime: Util.RuntimeOptions): UpdateDNSAuthorizationRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.authorizationRuleId)) {
    query['AuthorizationRuleId'] = request.authorizationRuleId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.destinationIp)) {
    query['DestinationIp'] = request.destinationIp;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.sourceDNSIp)) {
    query['SourceDNSIp'] = request.sourceDNSIp;
  }
  if (!Util.isUnset(request.wirelessCloudConnectorId)) {
    query['WirelessCloudConnectorId'] = request.wirelessCloudConnectorId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDNSAuthorizationRule',
    version = '2022-03-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDNSAuthorizationRule(request: UpdateDNSAuthorizationRuleRequest): UpdateDNSAuthorizationRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDNSAuthorizationRuleWithOptions(request, runtime);
}

model UpdateWirelessCloudConnectorRequest {
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  dryRun?: boolean(name='DryRun'),
  name?: string(name='Name'),
  wirelessCloudConnectorId?: string(name='WirelessCloudConnectorId'),
}

model UpdateWirelessCloudConnectorResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model UpdateWirelessCloudConnectorResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateWirelessCloudConnectorResponseBody(name='body'),
}

async function updateWirelessCloudConnectorWithOptions(request: UpdateWirelessCloudConnectorRequest, runtime: Util.RuntimeOptions): UpdateWirelessCloudConnectorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.wirelessCloudConnectorId)) {
    query['WirelessCloudConnectorId'] = request.wirelessCloudConnectorId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateWirelessCloudConnector',
    version = '2022-03-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateWirelessCloudConnector(request: UpdateWirelessCloudConnectorRequest): UpdateWirelessCloudConnectorResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateWirelessCloudConnectorWithOptions(request, runtime);
}

