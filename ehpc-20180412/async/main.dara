/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'EHPC';
  @version = '2018-04-12';
  @endpointRule = 'regional';
  @endpointMap = {
  };
}

function close(): void {
  @handler.close();
}

model AddContainerAppRequest {
  containerType?: string(name='ContainerType', description='The type of the container. Set the value to singularity.', example='singularity', position='Query'),
  description?: string(name='Description', description='The description of the container.', example='descriptionContainer', position='Query'),
  imageTag?: string(name='ImageTag', description='The tags of the image.

The repository stores a type of images such as Ubuntu images. Tags are used to identify the images. Examples: 16.04, 17.04, and latest.

Default value: latest', example='latest', position='Query'),
  name: string(name='Name', description='The name of the container. The name must be 2 to 64 characters in length. It must start with a letter and can contain letters, digits, hyphens (-), and underscores (\\_).', example='container1', position='Query'),
  repository: string(name='Repository', description='The name of the repository. The image that has the same name as the repository is pulled.

For information about image names, visit [Docker Hub official website](https://hub.docker.com/search?q=\\&type=image).', example='repo1', position='Query'),
}

model AddContainerAppResponseBody = {
  containerId?: {
    containerId?: [ string ](name='ContainerId')
  }(name='ContainerId', description='The ID of the container.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model AddContainerAppResponse = {
  headers: map[string]string(name='headers'),
  body: AddContainerAppResponseBody(name='body'),
}

/**
  * If you select an image for a new containerized application, the image is pulled from Docker Hub by default. However, the version of the image may not be up to date. You can call the [PullImage](~~159052~~) operation to pull the latest image.
  *
 */
async function addContainerApp(request: AddContainerAppRequest): AddContainerAppResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddContainerApp', 'GET', '/', 'json', false, 'json', request);
}

model AddExistedNodesRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****', position='Query'),
  imageId: string(name='ImageId', description='The ID of the image that is specified for the compute nodes. The image must meet the following requirements:

*   The operating system that is specified by the image must be the same as that of the existing cluster nodes. For example, if the operating system of the cluster nodes is CentOS, you can select only a CentOS image.

> If you add nodes to a hybrid cloud cluster that supports multiple operating systems, you can select a Windows Server image or a CentOS image when the operating system of the cluster nodes is Windows.

*   The major version of the image specified for the compute nodes that you want to add is the same as that of the image of the cluster. For example, if the version of the cluster image is CentOS 7.x, the version of the image specified for the compute nodes must be CentOS 7.x.

You can call the [ListImages](~~87213~~) and [ListCustomImages](~~87215~~) operations to query the image ID.', example='centos_7_06_64_20G_alibase_20190711.vhd', position='Query'),
  imageOwnerAlias: string(name='ImageOwnerAlias', description='The type of the image. Valid values:

*   system: public image
*   self: custom image
*   others: shared image
*   marketplace: Alibaba Cloud Marketplace image

Default value: system', example='system', position='Query'),
  instance: [ 
    {
      id: string(name='Id', description='The Nth node ID. N starts from 1. Valid values: 1 to 100.', example='i-bp16mxn6mt3t7ftk****'),
    }
  ](name='Instance', position='Query'),
  jobQueue?: string(name='JobQueue', description='The queue in the cluster to which the node is to be added.', example='workq', position='Query'),
}

model AddExistedNodesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  taskId?: string(name='TaskId', description='The ID of the task.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model AddExistedNodesResponse = {
  headers: map[string]string(name='headers'),
  body: AddExistedNodesResponseBody(name='body'),
}

/**
  * *   The compute nodes to be added are in the Stopped state.
  * *   After the compute nodes are added to the cluster, the operating systems of the nodes are replaced with the operating system specified by the ImageId parameter.
  * *   The hosts of the compute nodes must be different from those of the existing compute nodes in the cluster. Otherwise, the add operation fails.
  *
 */
async function addExistedNodes(request: AddExistedNodesRequest): AddExistedNodesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddExistedNodes', 'GET', '/', 'json', false, 'json', request);
}

model AddLocalNodesRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-FYUr32****', position='Query'),
  nodes: string(name='Nodes', description='The information of the local node. A JSON string that contains the HostName, IpAddress, CpuCores, and Memory (Unit: MB) of the local node.', example='[{"HostName":"test-HostName","IpAddress":"192.168.**.**"},{"CpuCores":2,"Memory":1024}]', position='Query'),
  queue?: string(name='Queue', description='The queue to which to add the local node.', example='test.q', position='Query'),
}

model AddLocalNodesResponseBody = {
  instanceIds?: {
    instanceId?: [ string ](name='InstanceId')
  }(name='InstanceIds', description='The local nodes in the cluster.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model AddLocalNodesResponse = {
  headers: map[string]string(name='headers'),
  body: AddLocalNodesResponseBody(name='body'),
}

async function addLocalNodes(request: AddLocalNodesRequest): AddLocalNodesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddLocalNodes', 'GET', '/', 'json', false, 'json', request);
}

model AddNodesRequest {
  allocatePublicAddress?: boolean(name='AllocatePublicAddress', description='Specifies whether to allocate a public IP address to the compute nodes. Valid values:

*   true
*   false

Default value: false.', example='false', position='Query'),
  autoRenew?: string(name='AutoRenew', description='Specifies whether to enable auto-renewal. The parameter takes effect only when EcsChargeType is set to PrePaid. Valid values:

*   true: enables auto-renewal
*   false: disables auto-renewal

Default value: true.', example='true', position='Query'),
  autoRenewPeriod?: int32(name='AutoRenewPeriod', description='The auto-renewal period of the subscription compute nodes. The parameter takes effect when AutoRenew is set to true.

*   Valid values when PeriodUnit is set to Week: 1, 2, and 3.
*   Valid values when PeriodUnit is set to Month: 1, 2, 3, 6, and 12.

Default value: 1.', example='1', position='Query'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence of a request?](~~25693~~)', example='123e4567-e89b-12d3-a456-426655440000', position='Query'),
  clusterId: string(name='ClusterId', description='The ID of the E-HPC cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****', position='Query'),
  computeEnableHt?: boolean(name='ComputeEnableHt', description='Specifies whether to enable hyper-threading for the compute node. Valid values:

*   true
*   false

Default value: true.', example='true', position='Query'),
  computeSpotDuration?: int32(name='ComputeSpotDuration', description='The protection period of the preemptible instance. Unit: hours. Valid values: 0 and 1. A value of 0 indicates that the preemptible instance has no protection period.', example='1', minimum=0, maximum=6, position='Query'),
  computeSpotInterruptionBehavior?: string(name='ComputeSpotInterruptionBehavior', description='The interruption mode of the preemptible instance. Default value: Terminate. Set the value to Terminate, which indicates that the instance is released.', example='Terminate', position='Query'),
  computeSpotPriceLimit?: string(name='ComputeSpotPriceLimit', description='The maximum hourly price of the compute nodes. The value can be accurate to three decimal places. The parameter only takes effect when SpotStrategy is set to SpotWithPriceLimit.', example='0.68', position='Query'),
  computeSpotStrategy?: string(name='ComputeSpotStrategy', description='The preemption policy of the compute nodes. The parameter only takes effect when EcsChargeType is set to PostPaid. Valid values:

*   NoSpot: The instance is a regular pay-as-you-go instance.
*   SpotWithPriceLimit: The policy applies to preemptible instances for which a maximum hourly price is specified.
*   SpotAsPriceGo: The compute nodes are preemptible instances for which the market price at the time of purchase is used as the bid price.

Default value: NoSpot.', example='NoSpot', position='Query'),
  count: int32(name='Count', description='The number of compute nodes that you want to add. Valid values: 1 to 99. The value of this parameter is greater than that of the MinCount parameter.

*   If the number of available ECS instances is less than the value of the MinCount parameter, the compute nodes cannot be added.
*   If the number of available ECS instances is greater than the value of the MinCount parameter and less than that of the Count parameter, the compute nodes are added based on the value of the MinCount parameter.
*   If the number of available ECS instances is greater than the value of the Count parameter, the compute nodes are added based on the value of the Count parameter.', example='10', position='Query'),
  createMode?: string(name='CreateMode', description='The mode in which the compute nodes are added. Valid values:

*   manual: The compute nodes are manually added.
*   autoscale: The compute nodes are automatically added.

Default value: manual.', example='manual', position='Query'),
  dataDisks?: [ 
    {
      dataDiskCategory?: string(name='DataDiskCategory', description='The type of the data disk. Valid values:

*   cloud_efficiency: ultra disk
*   cloud_ssd: SSD
*   cloud_essd: ESSD
*   cloud: basic disk

Default value: cloud_efficiency.

Valid values of N: 0 to 16.', example='cloud_efficiency'),
      dataDiskDeleteWithInstance?: boolean(name='DataDiskDeleteWithInstance', description='Specifies whether the data disk is released when the node is released. Valid values:

*   true
*   false

Default value: true.

Valid values of N: 0 to 16.', example='true'),
      dataDiskEncrypted?: boolean(name='DataDiskEncrypted', description='Specifies whether to encrypt the data disk. Valid values:

*   true
*   false

Default value: false.

Valid values of N: 0 to 16.', example='false'),
      dataDiskKMSKeyId?: string(name='DataDiskKMSKeyId', description='The KMS key ID of the data disk.

Valid values of N: 0 to 16.', example='0e478b7a-4262-4802-b8cb-00d3fb40826X'),
      dataDiskPerformanceLevel?: string(name='DataDiskPerformanceLevel', description='The performance level of the ESSD used as the data disk. The parameter only takes effect only when the DataDisks.N.DataDiskCategory parameter is set to cloud_essd. Valid values:

*   PL0: A single ESSD can deliver up to 10,000 random read/write IOPS.
*   PL1: A single ESSD can deliver up to 50,000 random read/write IOPS.
*   PL2: A single ESSD can deliver up to 100,000 random read/write IOPS.
*   PL3: A single ESSD can deliver up to 1,000,000 random read/write IOPS.

Default value: PL1.

Valid values of N: 0 to 16.', example='PL1'),
      dataDiskSize?: int32(name='DataDiskSize', description='The size of the data disk. Unit: GB.

Valid values: 40 to 500.

Default value: 40.

Valid values of N: 0 to 16.', example='40'),
    }
  ](name='DataDisks', description='The list of data disks.', position='Query'),
  dnsConfig?: string(name='DnsConfig', position='Query'),
  ecsChargeType?: string(name='EcsChargeType', description='The billing method of the compute nodes. Valid values:

*   PostPaid: pay-as-you-go
*   PrePaid: subscription

Default value: PostPaid.

If the parameter is set to PrePaid, auto-renewal is enabled by default. After the E-HPC cluster is released, auto-renewal is disabled.', example='PostPaid', position='Query'),
  hostNamePrefix?: string(name='HostNamePrefix', description='The prefix of the hostname. You can specify the parameter to manage the compute nodes in an efficient manner.', example='compute', position='Query'),
  hostNameSuffix?: string(name='HostNameSuffix', description='The suffix of the hostname. You can specify the parameter to manage the compute nodes in an efficient manner.', example='01', position='Query'),
  imageId?: string(name='ImageId', description='The ID of the image that is specified for the compute nodes. The image must meet the following requirements:

*   The operating system that is specified by the image must be the same as that of the existing cluster nodes. For example, if the operating system of the cluster nodes is CentOS, you can select only a CentOS image.

> If you add nodes to a hybrid cloud cluster that supports multiple operating systems, you can select a Windows Server image or a CentOS image when the operating system of nodes is Windows.

*   The major version of the image specified for the compute nodes that you want to add is the same as that of the image of the cluster. For example, if the version of the cluster image is CentOS 7.x, the version of the image specified for the compute nodes must be CentOS 7.x.

You can call the [ListImages](~~87213~~) and [ListCustomImages](~~87215~~) operations to query the image ID.', example='centos_7_06_64_20G_alibase_20190711.vhd', position='Query'),
  imageOwnerAlias?: string(name='ImageOwnerAlias', description='The type of the image. Valid values:

*   system: public image
*   self: custom image
*   others: shared image
*   marketplace: Alibaba Cloud Marketplace image

Default value: system.', example='system', position='Query'),
  instanceType?: string(name='InstanceType', description='The instance type of the compute nodes. The default value is the instance type that was specified when you created the E-HPC cluster or the last time when you added compute nodes.', example='ecs.n1.tiny', position='Query'),
  internetChargeType?: string(name='InternetChargeType', description='The billing method of the elastic IP address (EIP). Valid values:

*   PayByBandwidth: pay-by-bandwidth
*   PayByTraffic: pay-by-traffic', example='PayByTraffic', position='Query'),
  internetMaxBandWidthIn?: int32(name='InternetMaxBandWidthIn', description='The maximum inbound public bandwidth. Unit: Mbit/s. Valid values:

*   If the purchased outbound public bandwidth is less than or equal to 10 Mbit/s, the valid values of the parameter are 1 to 10 and the default value is 10.
*   If the purchased outbound public bandwidth is greater than 10 Mbit/s, the valid values of this parameter are 1 to the amount of the outbound bandwidth that is purchased.', example='10', minimum=0, maximum=100, position='Query'),
  internetMaxBandWidthOut?: int32(name='InternetMaxBandWidthOut', description='The maximum outbound public bandwidth. Unit: Mbit/s. Valid values: 0 to 100.

Default value: 0.', example='10', minimum=0, maximum=100, position='Query'),
  jobQueue?: string(name='JobQueue', description='The queue to which the compute nodes are added.', example='workq', position='Query'),
  minCount?: int32(name='MinCount', description='The minimum number of the compute nodes that you want to add. Valid values: 1 to 99. The value of the parameter is less than that of the Count parameter.

*   If the number of available ECS instances is less than the value of the MinCount parameter, the compute nodes cannot be added.
*   If the number of available ECS instances is greater than the value of the MinCount parameter and less than that of the Count parameter, the compute nodes are added based on the value of the MinCount parameter.
*   If the number of available ECS instances is greater than the value of the Count parameter, the compute nodes are added based on the value of the Count parameter.

Default value: 1.', example='1', position='Query'),
  networkInterfaceTrafficMode?: string(name='NetworkInterfaceTrafficMode', description='The communication mode of the ENI. Valid values:

*   Standard: uses the TCP communication mode.
*   HighPerformance: enables the Elastic RDMA Interface (ERI) and uses the remote direct memory access (RDMA) communication mode.', example='Standard', position='Query'),
  period?: int32(name='Period', description='The duration of the subscription. The unit of the duration is specified by the PeriodUnit parameter. The parameter only takes effect when InstanceChargeType is set to PrePaid. Valid values:

*   Valid values when PeriodUnit is set to Week: 1, 2, 3, and 4.
*   Valid values when PeriodUnit is set to Month: 1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 24, 36, 48, and 60.

Default value: 1.', example='1', position='Query'),
  periodUnit?: string(name='PeriodUnit', description='The unit of the subscription period of the resource. Valid values:

*   Week
*   Month

Default value: Month.', example='Month', position='Query'),
  sync?: boolean(name='Sync', description='Specifies whether to set this operation as a synchronous operation. Valid values:

*   true
*   false

Default value: false.', example='false', position='Query'),
  systemDiskLevel?: string(name='SystemDiskLevel', description='The performance level of the ESSD to be used as the system disk. Default value: PL1. Valid values:

*   PL0: A single ESSD can deliver up to 10,000 random read/write IOPS.
*   PL1: A single ESSD can deliver up to 50,000 random read/write IOPS.
*   PL2: A single ESSD can deliver up to 100,000 random read/write IOPS.
*   PL3: A single ESSD can deliver up to 1,000,000 random read/write IOPS.

Default value: PL1.

For more information about ESSD performance parameters, see [ESSD](~~122389~~).', example='PL0', position='Query'),
  systemDiskSize?: int32(name='SystemDiskSize', description='The size of the system disk. Unit: GiB.

Valid values: 40 to 500.

Default value: 40.', example='40', position='Query'),
  systemDiskType?: string(name='SystemDiskType', description='The type of the system disk. Valid values:

*   cloud_efficiency: ultra disk
*   cloud_ssd: SSD
*   cloud_essd: enhanced SSD (ESSD)
*   cloud: basic disk. Disks of this type are retired.

Default value: cloud_efficiency.', example='cloud_ssd', position='Query'),
  vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch.', example='vsw-bp1lfcjbfb099rrjn****', position='Query'),
  zoneId?: string(name='ZoneId', description='The ID of the zone.', example='cn-hangzhou-b', position='Query'),
}

model AddNodesResponseBody = {
  instanceIds?: {
    instanceId?: [ string ](name='InstanceId')
  }(name='InstanceIds'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='B745C159-3155-4B94-95D0-4B73D4D2****'),
  taskId?: string(name='TaskId', description='The ID of the task.', example='B745C159-3155-4B94-95D0-4B73D4D2****'),
}

model AddNodesResponse = {
  headers: map[string]string(name='headers'),
  body: AddNodesResponseBody(name='body'),
}

async function addNodes(request: AddNodesRequest): AddNodesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddNodes', 'GET', '/', 'json', false, 'json', request);
}

model AddQueueRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****', position='Query'),
  deploymentSetId?: string(name='DeploymentSetId', position='Query'),
  networkInterfaceTrafficMode?: string(name='NetworkInterfaceTrafficMode', example='Standard', position='Query'),
  queueName: string(name='QueueName', description='The name of the queue. The name must be 1 to 63 characters in length and start with a letter. It can contain letters, digits, and underscores (\\_).', example='test1', position='Query'),
}

model AddQueueResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='7ABFF29F-BD9C-4663-AD5D-E620FA48****'),
}

model AddQueueResponse = {
  headers: map[string]string(name='headers'),
  body: AddQueueResponseBody(name='body'),
}

async function addQueue(request: AddQueueRequest): AddQueueResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddQueue', 'GET', '/', 'json', false, 'json', request);
}

model AddSecurityGroupRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that the value is unique among different requests. The ClientToken value can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure the idempotence of a request](~~25693~~).', example='123e4567-e89b-12d3-a456-426655440000', position='Query'),
  clusterId: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****', position='Query'),
  securityGroupId: string(name='SecurityGroupId', description='The ID of the security group.

You can call the [DescribeSecurityGroups](~~25556~~) operation to query available security groups in the current region.', example='sg-bp13n61xsydodfyg****', position='Query'),
}

model AddSecurityGroupResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model AddSecurityGroupResponse = {
  headers: map[string]string(name='headers'),
  body: AddSecurityGroupResponseBody(name='body'),
}

async function addSecurityGroup(request: AddSecurityGroupRequest): AddSecurityGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddSecurityGroup', 'GET', '/', 'json', false, 'json', request);
}

model AddUsersRequest {
  async?: boolean(name='Async', description='Specifies whether to enable the asynchronous mode for this request.

Default value: false.', example='false', position='Query'),
  clusterId: string(name='ClusterId', description='The cluster ID.

You can call the [ListClusters](~~87116~~) operation to obtain the cluster ID.', example='ehpc-hz-FYUr32****', position='Query'),
  user: [ 
    {
      group?: string(name='Group', description='The permission group to which the user N belongs. Valid values:

*   users: an ordinary permission group. It is applicable to ordinary users that need only to submit and debug jobs.
*   wheel: a sudo permission group. It is applicable to the administrator who needs to manage the cluster. In addition to submitting and debugging jobs, users who have sudo permissions can run sudo commands to install software and restart nodes.

Valid values of N: 1 to 100.', example='users'),
      name?: string(name='Name', description='The name of the user that you want to add. The name must be 6 to 30 characters in length and can contain letters, digits, and periods (.). It must start with a letter.

Valid values of N: 1 to 100.', example='user1'),
      password?: string(name='Password', description='The password of the Nth user. The password must be 8 to 30 characters in length and contain three of the following items:

*   Uppercase letter
*   Lowercase letter
*   Digit
*   Special character: `()~!@#$%^&*-_+=|{}[]:;\\"/<>,.?/`

Valid values of N: 1 to 100.

>  We recommend that you use HTTPS to call API operations to avoid password leaks.', example='1@a2****'),
    }
  ](name='User', description='The information about the user.', position='Query'),
}

model AddUsersResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model AddUsersResponse = {
  headers: map[string]string(name='headers'),
  body: AddUsersResponseBody(name='body'),
}

async function addUsers(request: AddUsersRequest): AddUsersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddUsers', 'GET', '/', 'json', false, 'json', request);
}

model ApplyNodesRequest {
  allocatePublicAddress?: boolean(name='AllocatePublicAddress', description='Specifies whether to allocate a public IP address to the compute nodes. Valid values:

*   true: A public IP address is allocated to the compute nodes.
*   false: A public IP address is not allocated to the compute nodes.

Default value: false', example='false', position='Query'),
  clusterId: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87126~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****', position='Query'),
  computeSpotPriceLimit?: float(name='ComputeSpotPriceLimit', description='The maximum hourly price of the compute nodes. The value is a floating-point number that supports up to three decimal places. The parameter takes effect only when ComputeSpotStrategy is set to SpotWithPriceLimit.

If ComputeSpotPriceLimit and InstanceTypeModel.N.MaxPrice are specified at the same time, compute nodes are created based on the smaller value of these parameters.', example='0.68', position='Query'),
  computeSpotStrategy?: string(name='ComputeSpotStrategy', description='The preemption policy of the compute nodes. Valid values:

*   NoSpot: The compute nodes use the pay-as-you-go billing method.
*   SpotWithPriceLimit: The compute nodes are preemptible instances that have a user-defined maximum hourly price.
*   SpotAsPriceGo: The compute nodes are preemptible instances for which the market price at the time of purchase is used as the bid price.

Default value: NoSpot', example='NoSpot', position='Query'),
  cores?: int32(name='Cores', description='The number of vCPUs. The parameter is required when the ResourceAmountType parameter is set to Cores.

You can set Cores, vCPU, and Memory to query node specifications. For example, you can query the available compute nodes that have 2 vCPUs and 16 GB of memory by setting vCPU to 2 and Memory to 16. You can also query compute nodes by zone. Query results are sorted by price.', example='2', position='Query'),
  hostNamePrefix?: string(name='HostNamePrefix', description='The prefix of the hostname. You can specify the parameter to manage the compute nodes in an efficient manner.', example='compute', position='Query'),
  hostNameSuffix?: string(name='HostNameSuffix', description='The suffix of the hostname. You can specify the parameter to manage the compute nodes in an efficient manner.', example='01', position='Query'),
  imageId?: string(name='ImageId', description='The image ID of the compute nodes to be added. The parameter takes effect only when the TargetImageId parameter is not specified.

You can call the [ListImages](~~87213~~) and [ListCustomImages](~~87215~~) operations to query the image ID.

>  If you add multiple compute nodes, the TargetImageId parameter takes effect only on the nodes for which the TargetImageId parameter is specified.', example='centos_7_06_64_20G_alibase_20190711.vhd', position='Query'),
  instanceFamilyLevel?: string(name='InstanceFamilyLevel', description='The level of the instance family. The parameter takes effect only when Cores and Memory are specified. Valid values:

*   EntryLevel.
*   EnterpriseLevel.
*   CreditEntryLevel. For more information, see [What are burstable instances?](~~59977~~)

Default value: EnterpriseLevel', example='EntryLevel', position='Query'),
  instanceTypeModel?: [ 
    {
      instanceType?: string(name='InstanceType', description='The instance type of the compute node. The default value is the instance type that was specified when you created the cluster or the last time when you added compute nodes.

Valid values of N: 1 to 10', example='ecs.n1.tiny'),
      maxPrice?: float(name='MaxPrice', description='The maximum hourly price that you can pay for the preemptible node. The value is a floating-point number that supports up to three decimal places.

The parameter takes effect only when ComputeSpotStrategy is set to SpotWithPriceLimit.

Valid values of N: 1 to 10', example='0.034'),
      targetImageId?: string(name='TargetImageId', description='The image ID of the compute node. You must select a Windows image.

Valid values of N: 1 to 10', example='win2016_1607_x64_dtc_zh-cn_40G_alibase_20210516.vhd'),
    }
  ](name='InstanceTypeModel', position='Query'),
  internetChargeType?: string(name='InternetChargeType', description='The billing method of the elastic IP address (EIP). Valid values:

*   PayByBandwidth: pay-by-bandwidth
*   PayByTraffic: pay-by-traffic', example='PayByTraffic', position='Query'),
  internetMaxBandWidthIn?: int32(name='InternetMaxBandWidthIn', description='The maximum inbound public bandwidth. Unit: Mbit/s. Valid values:

*   If the purchased outbound public bandwidth is less than or equal to 10 Mbit/s, the valid values of the parameter are 1 to 10 and the default value is 10.
*   If the purchased outbound public bandwidth is greater than 10 Mbit/s, the valid values of this parameter are 1 to the amount of the outbound bandwidth that is purchased.', example='10', minimum=0, maximum=100, position='Query'),
  internetMaxBandWidthOut?: int32(name='InternetMaxBandWidthOut', description='The maximum outbound public bandwidth. Unit: Mbit/s. Valid values: 0 to 100.

Default value: 0', example='10', minimum=0, maximum=100, position='Query'),
  interval?: int32(name='Interval', description='The interval between two consecutive batches. Valid values: 60 to 600. Unit: seconds.

Default value: 60', example='60', minimum=60, maximum=600, position='Query'),
  jobQueue?: string(name='JobQueue', description='The queue to which the compute nodes are added.

You can call the [ListQueues](~~92176~~) operation to query the queue name.', example='workq', position='Query'),
  memory?: int32(name='Memory', description='The memory capacity. The parameter is required when the ResourceAmountType parameter is set to Cores. Unit: GB.

You can set Cores, vCPU, and Memory to query node specifications. For example, you can query the available compute nodes that have 2 vCPUs and 16 GB of memory by setting vCPU to 2 and Memory to 16. You can also query compute nodes by zone. Query results are sorted by price.', example='16', position='Query'),
  priorityStrategy?: string(name='PriorityStrategy', description='The application policy of the preemptible nodes. Valid values:

*   LowPriceResourcePlanning: Preemptible nodes are created based on the unit prices of vCPUs in ascending order. Preemptible nodes are created first when preemptible instance types are specified.
*   CapacityOptResourcePlanning: Preemptible nodes are created based on the prices and release rates in ascending order.
*   CustomizedResourcePlanning: Nodes are added based on the predefined value of the ZoneIds.N parameter. Instances of a zone that has a higher priority are used first.', example='LowPriceResourcePlanning', position='Query'),
  resourceAmountType?: string(name='ResourceAmountType', description='The type of the resource to be added. Valid values:

*   Instances: compute node
*   Cores: vCPU and memory

Default value: Instances', example='Instances', position='Query'),
  round?: int32(name='Round', description='The total number of batches to create nodes. Valid values: 1 to 10.

Default value: 1', example='1', minimum=1, maximum=10, position='Query'),
  strictResourceProvision?: boolean(name='StrictResourceProvision', description='Specifies whether to strictly meet the requirements of the TargetCapacity parameter. The parameter takes effect only when StrictSatisfiedTargetCapacity is set to true. Valid values:

*   true: Check the inventory of the resources. Compute nodes are created based on the value of the TargetCapacity parameter only when the available resources are sufficient. Otherwise, no compute nodes are created.
*   false: Check the inventory of the resources. Compute nodes are created only when the available resources are sufficient. However, some compute nodes may fail to be created because resources become insufficient after the inventory is checked.

Default value: false', example='false', position='Query'),
  strictSatisfiedTargetCapacity?: boolean(name='StrictSatisfiedTargetCapacity', description='Specifies whether to meet the requirements of the TargetCapacity parameter. Valid values:

*   true: If the available resources are fewer than the resources that you want to add, no compute nodes are created and an error is returned. If the available resources are more than the resources that you want to add, the following cases may occur:

    *   If StrictResourceProvision is set to true, check the inventory of the resources. Compute nodes are created based on the value of the TargetCapacity parameter only when the available resources are sufficient. Otherwise, no compute nodes are created.
    *   If StrictResourceProvision is set to false, check the inventory of the resources. Compute nodes are created only when the available resources are sufficient. However, some compute nodes may fail to be created because resources become insufficient after the inventory is checked.

*   false: If the available resources are insufficient, compute nodes are created based on the inventory of the resources.

Default value: true', example='true', position='Query'),
  systemDiskLevel?: string(name='SystemDiskLevel', description='The performance level of the ESSD used as the system disk. Valid values:

*   PL0: A single ESSD can deliver up to 10,000 random read/write IOPS.
*   PL1: A single ESSD can deliver up to 50,000 random read/write IOPS.
*   PL2: A single ESSD can deliver up to 100,000 random read/write IOPS.
*   PL3: A single ESSD can deliver up to 1,000,000 random read/write IOPS.

Default value: PL0

For more information, see [ESSDs](~~122389~~).', example='PL0', position='Query'),
  systemDiskSize?: int32(name='SystemDiskSize', description='The size of the system disk. Unit: GB.

Valid values: 40 to 500

Default value: 40', example='40', position='Query'),
  systemDiskType?: string(name='SystemDiskType', description='The type of the system disk. Valid values:

*   cloud_efficiency: ultra disk.
*   cloud_ssd: SSD.
*   cloud_essd: ESSD.
*   cloud: basic disk. Disks of this type are retired.', example='cloud_ssd', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key of the compute node that you want to attach. Valid values of N: 1 to 20. The tag key cannot be an empty string. It can be up to 128 characters in length and cannot start with acs: or aliyun. It cannot contain http:// or https://.

Valid values of N: 1 to 10', example='TestKey'),
      value?: string(name='Value', description='The tag value of the compute node that you want to add. Valid values of N: 1 to 20. The tag value can be an empty string. It can be up to 128 characters in length and cannot start with acs: or contain http:// or https://.

Valid values of N: 1 to 10', example='TestValue'),
    }
  ](name='Tag', position='Query'),
  targetCapacity: int32(name='TargetCapacity', description='The number of the resource that you want to add. The specific number depends on the value of the ResourceAmountType parameter:

*   If ResourceAmountType is set to Instance, the value range of TargetCapacity is 1 to 200.
*   If ResourceAmountType is set to Cores, the value range of TargetCapacity is 1 to 1,000.', example='20', position='Query'),
  zoneInfos: [ 
    {
      vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch. Valid values of N: 1 to 10.', example='vsw-bp1e47optm9g58zcu****'),
      zoneId?: string(name='ZoneId', description='The ID of the zone to which the cluster belongs. Valid values of N: 1 to 10.

>  Each zone ID must be unique.', example='cn-hangzhou-b'),
    }
  ](name='ZoneInfos', position='Query'),
}

model ApplyNodesResponseBody = {
  detail?: string(name='Detail', description='The detailed result of the request.', example='Resources Application is satisfied. Creating...'),
  instanceIds?: {
    instanceId?: [ string ](name='InstanceId')
  }(name='InstanceIds', description='The ID of the Elastic Compute Service (ECS) instance.

>  AddNodes is an asynchronous API operation. If a request succeeds, a response is immediately generated before ECS instances are created. Therefore, the value of the parameter is null. You can call the [ListNodes](~~87161~~) operation to query the ID of the ECS instance.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='B745C159-3155-4B94-95D0-4B73D4D2****'),
  satisfiedAmount?: int32(name='SatisfiedAmount', description='The number of the compute nodes that were created.', example='10'),
  taskId?: string(name='TaskId', description='The ID of the task.', example='B745C159-3155-4B94-95D0-4B73D4D2****'),
}

model ApplyNodesResponse = {
  headers: map[string]string(name='headers'),
  body: ApplyNodesResponseBody(name='body'),
}

/**
  * You can call the ApplyNodes operation to specify the number of compute nodes, the number of vCPUs, and the memory size when you add nodes to a cluster.
  *
 */
async function applyNodes(request: ApplyNodesRequest): ApplyNodesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ApplyNodes', 'GET', '/', 'json', false, 'json', request);
}

model CreateClusterRequest {
  ecsOrder?: {
    compute: {
        count?: int32(name='Count', description='The instance type of the compute nodes.

You can call the [ListPreferredEcsTypes](~~188592~~) operation to query the recommended instance types.', example='1'),
        instanceType?: string(name='InstanceType', description='The number of the logon nodes. Valid value: 1.', example='ecs.n1.tiny'),
    }(name='Compute'),
    login: {
        count?: int32(name='Count', description='The instance type of the logon nodes.

You can call the [ListPreferredEcsTypes](~~188592~~) operation to query the recommended instance types.', example='1'),
        instanceType?: string(name='InstanceType', description='The ID of the Super Computing Cluster (SCC) instance.

If you specify the parameter, the SCC instance is moved to a new SCC cluster.', example='ecs.n1.tiny'),
    }(name='Login'),
    manager: {
        count?: int32(name='Count', description='The instance type of the management nodes.

You can call the [ListPreferredEcsTypes](~~188592~~) operation to query the recommended instance types.', example='1'),
        instanceType?: string(name='InstanceType', description='The number of the compute nodes. Valid values: 1 to 99.', example='ecs.n1.tiny'),
    }(name='Manager'),
  }(name='EcsOrder', position='Query'),
  accountType?: string(name='AccountType', description='The domain name of the on-premises E-HPC cluster.

This parameter takes effect only when the AccoutType parameter is set to Idap.', example='nis', position='Query'),
  addOns?: [ 
    {
      configFile?: string(name='ConfigFile'),
      DBType?: string(name='DBType'),
      defaultStart?: boolean(name='DefaultStart'),
      deployMode?: string(name='DeployMode'),
      name?: string(name='Name'),
      port?: float(name='Port'),
      version?: string(name='Version'),
    }
  ](name='AddOns', position='Query'),
  additionalVolumes?: [ 
    {
      jobQueue?: string(name='JobQueue', description='The mount target of the additional file system.

Valid values of N: 1 to 10', example='high'),
      localDirectory?: string(name='LocalDirectory', description='The URL that is used to download the script after the E-HPC cluster is created.

Valid values of N: 0 to 16', example='/ff'),
      location?: string(name='Location', description='Specifies whether not to install the agent.

*   true: The agent is not installed.
*   false: The agent is installed.

Default value: false', example='PublicCloud'),
      remoteDirectory?: string(name='RemoteDirectory', description='The type of the E-HPC cluster. Set the value to PublicCloud.

Valid values of N: 1 to 10', example='/test'),
      roles?: [ 
        {
          name?: string(name='Name', description='The type of the additional shared storage. Only NAS file systems are supported.

Valid values of N: 1 to 10', example='["Compute"]'),
        }
      ](name='Roles', description='The remote directory on which the additional file system is mounted.

Valid values of N: 1 to 10'),
      volumeId?: string(name='VolumeId', description='The mount options of the additional file system.

Valid values of N: 1 to 10', example='extreme-00b88****'),
      volumeMountOption?: string(name='VolumeMountOption', description='The type of the protocol that is used by the additional file system. Valid values:

*   NFS
*   SMB

Valid values of N: 1 to 10

Default value: NFS', example='-t nfs -o vers=4.0'),
      volumeMountpoint?: string(name='VolumeMountpoint', description='The local directory on which the additional file system is mounted.

Valid values of N: 1 to 10', example='0088****-sihc.cn-hangzhou.extreme.nas.aliyuncs.com'),
      volumeProtocol?: string(name='VolumeProtocol', description='The mode configurations of the plug-in. This parameter takes effect only when the SchedulerType parameter is set to custom.

The value must be a JSON string. The parameter contains the following parameters: pluginMod, pluginLocalPath, and pluginOssPath.

*   pluginMod: the mode of the plug-in. The following modes are supported:

    *   oss: The plug-in is downloaded and decompressed from OSS to a local path. The local path is specified by the pluginLocalPath parameter.
    *   image: By default, the plug-in is stored in a pre-defined local path. The local path is specified by the pluginLocalPath parameter.

*   pluginLocalPath: the local path where the plug-in is stored. We recommend that you select a shared directory in oss mode and a non-shared directory in image mode.

*   pluginOssPath: the remote path where the plug-in is stored in OSS. This parameter takes effect only when the pluginMod parameter is set to oss.', example='NFS'),
      volumeType?: string(name='VolumeType', description='The parameter that is used to run the script after the E-HPC cluster is created.

Valid values of N: 0 to 16', example='nas'),
    }
  ](name='AdditionalVolumes', description='The type of the nodes to which the additional file system is attached.

Valid values of N in AdditionalVolumes.N.Roles: 1 to 10

Valid values of N in Roles.N.Name: 0 to 8', position='Query'),
  application?: [ 
    {
      tag?: string(name='Tag', description='The ID of the additional file system.

Valid values of N: 1 to 10', example='OpenMPI_11.1'),
    }
  ](name='Application', description='The queue of the nodes to which the additional file system is attached.

Valid values of N: 1 to 10', position='Query'),
  autoRenew?: string(name='AutoRenew', description='The auto-renewal period of the subscription compute nodes. The parameter takes effect when AutoRenew is set to true.', example='false', position='Query'),
  autoRenewPeriod?: int32(name='AutoRenewPeriod', description='The URL of the job files that are uploaded to an Object Storage Service (OSS) bucket.', example='1', position='Query'),
  clientToken?: string(name='ClientToken', description='Specifies whether the logon node uses an elastic IP address (EIP). Default value: false', example='123e4567-e89b-12d3-a456-426655440000', position='Query'),
  clientVersion?: string(name='ClientVersion', description='The operating system tag of the image.', example='1.0.64', position='Query'),
  clusterVersion?: string(name='ClusterVersion', description='The tag of the software.

Valid values of N: 0 to 100

You can call the [ListSoftwares](~~87216~~) operation to query the tag of the software.', example='1.0', position='Query'),
  computeEnableHt?: boolean(name='ComputeEnableHt', description='The duration of the subscription. The unit of the duration is specified by the `PeriodUnit` parameter.

*   If you set PriceUnit to Year, the valid values of the Period parameter are 1, 2, and 3.
*   If you set PriceUnit to Month, the valid values of the Period parameter are 1, 2, 3, 4, 5, 6, 7, 8, and 9.
*   If you set PriceUnit to Hour, the valid value of the Period parameter is 1.

Default value: 1', example='true', position='Query'),
  computeSpotPriceLimit?: string(name='ComputeSpotPriceLimit', description='Specifies whether the compute nodes support hyper-threading. Valid values:

*   true
*   false

Default value: true', example='0.034', position='Query'),
  computeSpotStrategy?: string(name='ComputeSpotStrategy', description='The maximum hourly price of the compute nodes. A maximum of three decimal places can be used in the value of the parameter. The parameter is valid only when the ComputeSpotStrategy parameter is set to SpotWithPriceLimit.', example='NoSpot', position='Query'),
  deployMode?: string(name='DeployMode', description='Specifies whether to enable the high availability feature. Valid values:

*   true
*   false

Default value: false

>  If high availability is enabled, a primary management node and a secondary management node are used.', example='Simple', position='Query'),
  deploymentSetId?: string(name='DeploymentSetId', position='Query'),
  description?: string(name='Description', description='The version of E-HPC. By default, the parameter is set to the latest version number.', example='TestDescription', position='Query'),
  domain?: string(name='Domain', description='The type of the scheduler. Valid values:

*   pbs
*   slurm
*   opengridscheduler
*   deadline

Default value: pbs', example='ldap', position='Query'),
  ecsChargeType?: string(name='EcsChargeType', description='The root password of the logon node. The password must be 8 to 30 characters in length and contain at least three of the following items: uppercase letters, lowercase letters, digits, and special characters. The password can contain the following special characters:

`( ) ~ ! @ # $ % ^ & * - + = | { } [ ] : ; â€˜ < > , . ? /`

You must specify either Password or KeyPairName. If both are specified, the Password parameter prevails.

>  We recommend that you use HTTPS to call the API operation to prevent password leakages.', example='PostPaid', position='Query'),
  ehpcVersion?: string(name='EhpcVersion', description='The version of the E-HPC client. By default, the parameter is set to the latest version number.

You can call the [ListCurrentClientVersion](~~87223~~) operation to query the latest version of the E-HPC client.', example='1.0.0', position='Query'),
  haEnable?: boolean(name='HaEnable', description='The billing method of the nodes. Valid values:

*   PostPaid: pay-as-you-go
*   PrePaid: subscription

If you set the parameter to PrePaid, auto-renewal is enabled by default.', example='true', position='Query'),
  imageId?: string(name='ImageId', description='The number of the management nodes. Valid values: 1 and 2.', example='centos_7_02_64_20G_alibase_20170818****', position='Query'),
  imageOwnerAlias?: string(name='ImageOwnerAlias', description='The ID of the image.

You can call the [ListImages](~~87213~~) and [ListCustomImages](~~87215~~) operations to query the images that are supported by E-HPC.', example='self', position='Query'),
  inputFileUrl?: string(name='InputFileUrl', description='The queue to which the compute nodes are added.', example='https://ehpc-tianshui.oss-cn-beijing.aliyuncs.com/test-u****/testlist_ehpc.sh', position='Query'),
  isComputeEss?: boolean(name='IsComputeEss', description='The version of the E-HPC cluster.

Default value: 1.0', example='false', position='Query'),
  jobQueue?: string(name='JobQueue', description='The type of the system disk. Valid values:

*   cloud_efficiency: ultra disk.
*   cloud_ssd: standard SSD.
*   cloud_essd: enhanced SSD (ESSD).
*   cloud: basic disk. Disks of this type are retired.

Default value: cloud_ssd', example='workq', position='Query'),
  keyPairName?: string(name='KeyPairName', description='The type of the image. Valid values:

*   system: public image
*   self: custom image
*   others: shared image

Default value: system', example='test', position='Query'),
  name: string(name='Name', description='The description of the E-HPC cluster. The description must be 2 to 256 characters in length. It cannot start with http:// or https://.', example='test', position='Query'),
  networkInterfaceTrafficMode?: string(name='NetworkInterfaceTrafficMode', example='Standard', position='Query'),
  osTag?: string(name='OsTag', description='The type of the domain account service. Valid values:

*   nis
*   ldap

Default value: nis', example='CentOS_7.2_64', position='Query'),
  password?: string(name='Password', description='The name of the AccessKey pair.

>  For more information, see [Create an SSH key pair](~~51793~~).', example='123****', position='Query'),
  period?: int32(name='Period', description='The unit of the subscription duration. Valid values:

*   Year
*   Month
*   Hour

Default value: Month', example='1', position='Query'),
  periodUnit?: string(name='PeriodUnit', description='Specifies whether to enable auto-renewal for the subscription. Valid values:

*   true
*   false

Default value: false', example='Year', position='Query'),
  plugin?: string(name='Plugin', description='The value of the tag.', example='{"pluginMod": "oss","pluginLocalPath": "/opt/plugin","pluginOssPath": "https://bucket.oss-cn-hangzhou.aliyuncs.com/plugin/plugin.tgz"}', position='Query'),
  postInstallScript?: [ 
    {
      args?: string(name='Args', description='The node of the RAM role.

Valid values of N: 0 to 4

*   If the DeployMode parameter is set to Standard, the following values are valid: scheduler, account, login, and compute. Separate multiple values with commas (,).
*   If the DeployMode parameter is set to Simple, the following values are valid: manager, login, and compute. Separate multiple values with commas (,).
*   If the DeployMode parameter is set to Tiny, the following values are valid: manager and compute.', example='bashfile.sh'),
      url?: string(name='Url', description='The key of the tag.', example='/opt/job.sh'),
    }
  ](name='PostInstallScript', description='The name of the Resource Access Management (RAM) role.

You can call the [ListRoles](~~28713~~) operation provided by RAM to query the created RAM roles.', position='Query'),
  ramNodeTypes?: [ string ](name='RamNodeTypes', example='Standard', position='Query'),
  ramRoleName?: string(name='RamRoleName', description='The ID of the task.

>  CreateCluster is an asynchronous API operation. If a request succeeds, a response is immediately generated before nodes are created. You can call the [ListTasks](~~268225~~) operation to query the result of the task.', example='testRamRoleName', position='Query'),
  remoteDirectory?: string(name='RemoteDirectory', description='The mode in which the E-HPC cluster is deployed. Valid values:

*   Standard: An account node, a scheduling node, a logon node, and multiple compute nodes are separately deployed.
*   Simple: A management node, a logon node, and multiple compute nodes are deployed. The management node consists of an account node and a scheduling node. The logon node and compute nodes are separately deployed.
*   Tiny: A management node and multiple compute nodes are deployed. The management node consists of an account node, a scheduling node, and a logon node. The compute nodes are separately deployed.

Default value: Standard', example='NasMountpoint:/RemoteDirectory', position='Query'),
  remoteVisEnable?: string(name='RemoteVisEnable', description='The ID of the resource group.

You can call the [ListResourceGroups](~~158855~~) operation to obtain the ID of the resource group.', example='false', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that the value is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence of a request?](~~25693~~)', example='rg-acfmxazb4ph****', position='Query'),
  sccClusterId?: string(name='SccClusterId', description='The bidding method of the compute nodes. Valid values:

*   NoSpot: The compute nodes are pay-as-you-go instances.
*   SpotWithPriceLimit: The compute nodes are preemptible instances that have a user-defined maximum hourly price.
*   SpotAsPriceGo: The compute nodes are preemptible instances for which the market price at the time of purchase is used as the bid price.

Default value: NoSpot', example='00b648b****', position='Query'),
  schedulerType?: string(name='SchedulerType', description='The ID of the security group to which the E-HPC cluster belongs.

You can call the [DescribeSecurityGroups](~~25556~~) operation to query available security groups in the current region.', example='pbs', position='Query'),
  securityGroupId?: string(name='SecurityGroupId', description='If you do not use an existing security group, set the parameter to the name of a new security group. A default policy is applied to the new security group.', example='sg-bp13n61xsydodfyg****', position='Query'),
  securityGroupName?: string(name='SecurityGroupName', description='The ID of the virtual private cloud (VPC) to which the E-HPC cluster belongs.

You can call the [DescribeVpcs](~~35739~~) operation to query available VPCs.', example='ehpc-SecurityGroup', position='Query'),
  systemDiskLevel?: string(name='SystemDiskLevel', description='Specifies whether to enable auto scaling. Valid values:

*   true
*   false

Default value: false', example='PL0', position='Query'),
  systemDiskSize?: int32(name='SystemDiskSize', description='Specifies whether to enable Virtual Network Computing (VNC). Valid values:

*   true
*   false

Default value: false', example='40', position='Query'),
  systemDiskType?: string(name='SystemDiskType', description='The size of the system disk. Unit: GB.

Valid values: 40 to 500

Default value: 40', example='cloud_ssd', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key', example='TestKey'),
      value?: string(name='Value', example='TestValue'),
    }
  ](name='Tag', position='Query'),
  vSwitchId?: string(name='VSwitchId', description='The type of the shared storage. Set the value to `nas`, which indicates a NAS file system.', example='vsw-bp1lfcjbfb099rrjn****', position='Query'),
  volumeId?: string(name='VolumeId', description='The type of the protocol that is used by the file system. Valid values:

*   NFS
*   SMB

Default value: NFS', example='008b64****', position='Query'),
  volumeMountOption?: string(name='VolumeMountOption', description='The remote directory on which the file system is mounted.', example='-t nfs -o vers=4', position='Query'),
  volumeMountpoint?: string(name='VolumeMountpoint', description='The mount options of the NFS file system that you want to mount by running the mount command.

For more information, see [Mount an NFS file system on a Linux ECS instance](https://www.alibabacloud.com/help/en/nas/latest/mount-an-nfs-file-system-on-a-linux-ecs-instance#section-jyi-hyd-hbr).', example='008b648bcb-s****.cn-hangzhou.nas.aliyuncs.com', position='Query'),
  volumeProtocol?: string(name='VolumeProtocol', description='The mount target of the file system. Take note of the following information:

*   If you do not specify the VolumeId parameter, you can leave the VolumeMountpoint parameter empty. A mount target is created by default.
*   If you specify the VolumeId parameter, the VolumeMountpoint parameter is required. You can call the [ListFileSystemWithMountTargets](~~204364~~) operation to query available mount targets.', example='NFS', position='Query'),
  volumeType?: string(name='VolumeType', description='The ID of the file system. If you leave the parameter empty, a Performance NAS file system is created by default.

You can call the [ListFileSystemWithMountTargets](~~204364~~) operation to query available mount targets.', example='nas', position='Query'),
  vpcId?: string(name='VpcId', description='The ID of the vSwitch. E-HPC supports only VPC networks.

You can call the [DescribeVSwitches](~~35748~~) operation to query available vSwitches.', example='vpc-b3f3edefefeep0760yju****', position='Query'),
  withoutAgent?: boolean(name='WithoutAgent', description='The ID of the request.', example='false', position='Query'),
  withoutElasticIp?: boolean(name='WithoutElasticIp', description='The performance level of the ESSD that is used as the system disk. Valid values:

*   PL0: An ESSD can deliver up to 10,000 random read/write IOPS.
*   PL1: A single ESSD can deliver up to 50,000 random read/write IOPS.
*   PL2: A single ESSD can deliver up to 100,000 random read/write IOPS.
*   PL3: An ESSD delivers up to 1,000,000 random read/write IOPS.

Default value: PL1

For more information, see [ESSDs](~~122389~~).', example='true', position='Query'),
  withoutNas?: boolean(name='WithoutNas', position='Query'),
  zoneId?: string(name='ZoneId', description='The name of the E-HPC cluster. The name must be 2 to 64 characters in length.', example='cn-hangzhou-b', position='Query'),
}

model CreateClusterResponseBody = {
  clusterId?: string(name='ClusterId', example='ehpc-hz-FYUr32****'),
  requestId?: string(name='RequestId', example='F6757FA4-8FED-4602-B7F5-3550C084****'),
  taskId?: string(name='TaskId', example='F6757FA4-8FED-4602-B7F5-3550C084****'),
}

model CreateClusterResponse = {
  headers: map[string]string(name='headers'),
  body: CreateClusterResponseBody(name='body'),
}

/**
  * The ID of the zone.
  * You can call the [ListRegions](~~188593~~) and [DescribeZones](~~25610~~) operations to query IDs of the zones where E-HPC is supported.
  *
 */
async function createCluster(request: CreateClusterRequest): CreateClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateCluster', 'GET', '/', 'json', false, 'json', request);
}

model CreateGWSClusterRequest {
  clusterType: string(name='ClusterType', example='gws.s1.standard', position='Query'),
  name?: string(name='Name', example='TestGWS', position='Query'),
  vSwitchId?: string(name='VSwitchId', example='vsw-bp1lfcjbfb099rrjn****', position='Query'),
  vpcId: string(name='VpcId', description='VPC IDã€‚', example='vpc-bp1se4wjbp0760yju****', position='Query'),
}

model CreateGWSClusterResponseBody = {
  clusterId?: string(name='ClusterId', example='gws-rhz397kdngua****'),
  requestId?: string(name='RequestId', example='5198C3E8-85F5-4280-8547-687C1710FE08'),
}

model CreateGWSClusterResponse = {
  headers: map[string]string(name='headers'),
  body: CreateGWSClusterResponseBody(name='body'),
}

async function createGWSCluster(request: CreateGWSClusterRequest): CreateGWSClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateGWSCluster', 'GET', '/', 'json', false, 'json', request);
}

model CreateGWSImageRequest {
  instanceId: string(name='InstanceId', description='The ID of the visualization instance.', example='i-bp66guhybgtrftpa1****', position='Query'),
  name?: string(name='Name', description='The image name of the visualization instance.', example='EHPC-TEST', position='Query'),
}

model CreateGWSImageResponseBody = {
  imageId?: string(name='ImageId', description='The image ID of the visualization instance.', example='ehs-fakeid-****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='5198C3E8-85F5-4280-8547-687C1710FE08'),
}

model CreateGWSImageResponse = {
  headers: map[string]string(name='headers'),
  body: CreateGWSImageResponseBody(name='body'),
}

async function createGWSImage(request: CreateGWSImageRequest): CreateGWSImageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateGWSImage', 'GET', '/', 'json', false, 'json', request);
}

model CreateGWSInstanceRequest {
  allocatePublicAddress: boolean(name='AllocatePublicAddress', example='false', position='Query'),
  appList?: string(name='AppList', example='[{AppName: notepad},{AppArgs:c:/temp.txt}]', position='Query'),
  autoRenew?: boolean(name='AutoRenew', example='false', position='Query'),
  clusterId: string(name='ClusterId', example='gws-rhzxpazwebua****', position='Query'),
  imageId: string(name='ImageId', example='ehs-faeid-****', position='Query'),
  instanceChargeType: string(name='InstanceChargeType', example='Postpaid', position='Query'),
  instanceType: string(name='InstanceType', example='ecs.g6.large', position='Query'),
  internetChargeType?: string(name='InternetChargeType', example='PayByTraffic', position='Query'),
  internetMaxBandwidthIn?: int32(name='InternetMaxBandwidthIn', example='122', position='Query'),
  internetMaxBandwidthOut?: int32(name='InternetMaxBandwidthOut', example='122', position='Query'),
  name?: string(name='Name', example='Test-ehpc', position='Query'),
  period?: string(name='Period', example='1', position='Query'),
  periodUnit?: string(name='PeriodUnit', example='Month', position='Query'),
  systemDiskCategory: string(name='SystemDiskCategory', example='cloud', position='Query'),
  systemDiskSize: int32(name='SystemDiskSize', example='20', position='Query'),
  vSwitchId?: string(name='VSwitchId', example='vsw-bp1gb5gf5546rn****', position='Query'),
  workMode: string(name='WorkMode', example='Desktop', position='Query'),
}

model CreateGWSInstanceResponseBody = {
  instanceId?: string(name='InstanceId', example='i-bp1bzqddeemudsdsdsdsdn****'),
  requestId?: string(name='RequestId', example='5198C3E8-85F5-4280-8547-687C1710FE08'),
}

model CreateGWSInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateGWSInstanceResponseBody(name='body'),
}

async function createGWSInstance(request: CreateGWSInstanceRequest): CreateGWSInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateGWSInstance', 'GET', '/', 'json', false, 'json', request);
}

model CreateHybridClusterRequest {
  ecsOrder?: {
    compute: {
        instanceType: string(name='InstanceType', description='The instance type of the compute nodes.', example='ecs.n1.tiny'),
    }(name='Compute'),
    manager: {
        instanceType?: string(name='InstanceType', description='The instance type of the management node. Only Proxy Mode is supported.', example='ecs.n1.tiny'),
    }(name='Manager'),
  }(name='EcsOrder', position='Query'),
  application?: [ 
    {
      tag?: string(name='Tag', description='The tag of the software.', example='OpenMPI_11.1'),
    }
  ](name='Application', description='An array that consists of the information about the software.', position='Query'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence of a request?](~~25693~~)', example='123e4567-e89b-12d3-a456-426655440000', position='Query'),
  clientVersion?: string(name='ClientVersion', description='The version of the client. By default, the latest version is used.', example='1.0.64', position='Query'),
  computeSpotPriceLimit?: float(name='ComputeSpotPriceLimit', description='The maximum hourly price for the ECS instance under the compute node. A maximum of three decimal places can be used in the value of the parameter. The parameter is valid only when the ComputeSpotStrategy parameter is set to SpotWithPriceLimit.', example='0.034', position='Query'),
  computeSpotStrategy?: string(name='ComputeSpotStrategy', description='The preemption policy of the compute nodes. Valid values:

*   NoSpot: The compute nodes are pay-as-you-go instances.
*   SpotWithPriceLimit: The instance is created as a preemptible instance with a user-defined maximum hourly price.
*   SpotAsPriceGo: The instance is created as a preemptible instance for which the market price at the time of purchase is automatically used as the bidding price.

Default value: NoSpot.', example='NoSpot', position='Query'),
  description?: string(name='Description', description='The description of the E-HPC cluster. The description must be 2 to 256 characters in length and cannot start with [http:// or https://](http://https://ã€‚).

This parameter is empty by default.', example='TestDescription', position='Query'),
  domain?: string(name='Domain', description='The type of the domain account service. Valid values:

*   nis
*   ldap

Default value: nis.', example='nis', position='Query'),
  ehpcVersion?: string(name='EhpcVersion', description='The version of E-HPC. By default, the latest version is used.', example='1.0.0', position='Query'),
  hybridClusterOpMode?: string(name='HybridClusterOpMode', description='The mode in which the proxy node manages the offline nodes. Valid values:

*   SSH: indicates management via SSH logon.
*   CA: indicates management through Cloud Assistant.', example='SSH', position='Query'),
  imageId?: string(name='ImageId', description='The IDs of the images.', example='wi_1607_x64_dtc_zh_40G_alibase****', position='Query'),
  imageOwnerAlias?: string(name='ImageOwnerAlias', description='The type of the image. Valid values:

*   system: public image
*   self: custom image
*   others: shared image
*   marketplace: Alibaba Cloud Marketplace image', example='system', position='Query'),
  jobQueue?: string(name='JobQueue', description='The default queue of the scale-out nodes.', example='workq', position='Query'),
  keyPairName?: string(name='KeyPairName', description='The name of the key pair. The name must be 2 to 128 characters in length, and can contain letters, digits, colons (:), underscores (\\_), and hyphens (-). It must start with a letter and cannot start with http:// or https://.[](http://https://ã€‚ã€ï¼ˆ:ï¼‰ã€ï¼ˆ\\_ï¼‰ï¼ˆ-ï¼‰ã€‚)

> To use an SSH key pair, see [Create an SSH key pair](~~51793~~).', example='test', position='Query'),
  location?: string(name='Location', description='The location where the cluster resides. Set the value to OnPremise.', example='OnPremise', position='Query'),
  multiOs?: boolean(name='MultiOs', description='Specifies whether the cluster supports multiple operating systems. Valid values:

*   true
*   false

Default value: false.', example='false', position='Query'),
  name: string(name='Name', description='The name of the cluster. The name must be 2 to 64 characters in length, and can contain only letters, digits, hyphens (-), and underscores (\\_). It must start with a letter.', example='hybridcluster', position='Query'),
  nodes?: [ 
    {
      accountType?: string(name='AccountType', description='The service type of the domain account to which the on-premises node in the cluster belongs. Valid values:

*   nis
*   ldap

Default value: nis.', example='nis'),
      dir?: string(name='Dir', description='The directory of the on-premises node in the cluster.', example='/opt/sge/default/'),
      hostName?: string(name='HostName', description='The hostname of the on-premises node in the cluster.', example='test1'),
      ipAddress?: string(name='IpAddress', description='The IP address of the on-premises node in the cluster.', example='00b648b****'),
      role?: string(name='Role', description='The role of the on-premises node in the cluster. Valid values:

*   Manager: management node
*   Login: logon node
*   Compute: compute node', example='Compute'),
      schedulerType?: string(name='SchedulerType', description='The scheduler type of the on-premises node in the cluster. Valid values:

*   pbs
*   slurm
*   opengridscheduler
*   deadline

Default value: pbs.', example='pbs'),
    }
  ](name='Nodes', description='The information about the nodes in the local cluster.', position='Query'),
  onPremiseVolumeLocalPath?: string(name='OnPremiseVolumeLocalPath', description='The path in which the on-premises file system is mounted on the nodes on the cloud.', example='/OnCloudDirectory', position='Query'),
  onPremiseVolumeMountPoint?: string(name='OnPremiseVolumeMountPoint', description='The mount target of the on-premises file system.', example='RemoteNasDomain.com', position='Query'),
  onPremiseVolumeProtocol?: string(name='OnPremiseVolumeProtocol', description='The type of the protocol that is used by the on-premises file system. Only NFS is supported.', example='NFS', position='Query'),
  onPremiseVolumeRemotePath?: string(name='OnPremiseVolumeRemotePath', description='The mount path of the on-premises file system.', example='/RemoteDirectory', position='Query'),
  openldapPar?: {
    baseDn?: string(name='BaseDn', description='The BaseDN of the LDAP server.', example='ehpctest'),
    fallbackHomeDir?: string(name='FallbackHomeDir', description='The home directory of the Linux server.', example='/home'),
    ldapServerIp?: string(name='LdapServerIp', description='The IP address of the LDAP server.', example='192.168.1.2'),
  }(name='OpenldapPar', description='The parameter that is used to connect to the OpenLDAP server.', position='Query'),
  osTag: string(name='OsTag', description='The image tag of the operating system. You can call the [ListImages](~~87213~~) operation to query the image tag.', example='CentOS_7.2_64', position='Query'),
  password?: string(name='Password', description='The root password of the logon node. The password must be 8 to 30 characters in length and contain at least three of the following items: uppercase letters, lowercase letters, digits, and special characters. The following special characters are supported: `() ~ ! @ # $ % ^ & * - = + | { } [ ] : ; â€˜ < > , . ? /`

> We recommend that you use HTTPS to call the API operation to prevent password leakage.', example='123****', position='Query'),
  plugin?: string(name='Plugin', description='The mode configurations of the plug-in. This parameter takes effect only when the SchedulerType parameter is set to custom.

The value must be a JSON string. The parameter contains the following parameters: pluginMod, pluginLocalPath, and pluginOssPath.

*   pluginMod: the mode of the plug-in. The following modes are supported:

    *   oss: The plug-in is downloaded and decompressed from OSS to a local path. The local path is specified by the pluginLocalPath parameter.
    *   image: By default, the plug-in is stored in a pre-defined local path. The local path is specified by the pluginLocalPath parameter.

*   pluginLocalPath: the local path where the plug-in is stored. We recommend that you select a shared directory in oss mode and a non-shared directory in image mode.

*   pluginOssPath: the remote path where the plug-in is stored in OSS. This parameter takes effect only when the pluginMod parameter is set to oss.', example='{"pluginMod": "oss","pluginLocalPath": "/opt/plugin","pluginOssPath": "https://bucket.oss-cn-hangzhou.aliyuncs.com/plugin/plugin.tgz"}', position='Query'),
  postInstallScript?: [ 
    {
      args?: string(name='Args', description='The parameter that is used to run the script after the cluster is created.', example='bash file.sh'),
      url?: string(name='Url', description='The full path of the post-installation script.', example='/opt/job.sh'),
    }
  ](name='PostInstallScript', description='The list of post-installation script information.', position='Query'),
  remoteDirectory?: string(name='RemoteDirectory', description='The remote directory to which the file system is mounted.', example='/RemoteDirectory', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-acfmxazb4ph****', position='Query'),
  schedulerPreInstall?: boolean(name='SchedulerPreInstall', description='Specifies whether the scheduler is preinstalled for the image. Valid values:

*   true: The scheduler is preinstalled. When you create or add a node, you do not need to install the scheduler.
*   false: The scheduler is not preinstalled. When you create or add a cluster, you must install the scheduler.', example='true', position='Query'),
  securityGroupId?: string(name='SecurityGroupId', description='You can select an existing security group by its ID.

**

**If you specify this parameter, you cannot specify the **SecurityGroupName`  parameter. `', example='sg-bp13n61xsydodfyg****', position='Query'),
  securityGroupName?: string(name='SecurityGroupName', description='If you do not use an existing security group, set the parameter to the name of a new security group. A default policy is applied to the new security group.

> If you specify this parameter, you cannot specify the `SecurityGroupId` parameter.', example='ehpc-SecurityGroup', position='Query'),
  vSwitchId: string(name='VSwitchId', description='The ID of the vSwitch to which the instance connects to.', example='vsw-bp1lfcjbfb099rrjn****', position='Query'),
  volumeId?: string(name='VolumeId', description='The ID of the file system. NAS file systems cannot be automatically created.', example='008b64****', position='Query'),
  volumeMountpoint?: string(name='VolumeMountpoint', description='The mount target of the NAS file system. The mount target is of the VPC type. Mount targets cannot be automatically created for NAS file systems.', example='008b648bcb-s****.cn-hangzhou.nas.aliyuncs.com', position='Query'),
  volumeProtocol?: string(name='VolumeProtocol', description='The type of the protocol that is used by the NAS file system. Only NFS is supported.', example='NFS', position='Query'),
  volumeType?: string(name='VolumeType', description='The type of the file system. Only NAS file systems are supported.', example='NAS', position='Query'),
  vpcId: string(name='VpcId', description='The ID of the virtual private cloud (VPC) to which the E-HPC cluster belongs.', example='vpc-b3f3edefefeep0760yju****', position='Query'),
  winAdPar?: {
    adDc?: string(name='AdDc', description='The name of the AD domain.', example='ad-hybrid001.ehpcad.com'),
    adIp?: string(name='AdIp', description='The IP address of the AD domain.', example='192.168.1.2'),
    adUser?: string(name='AdUser', description='The AD user.', example='Administrator'),
    adUserPasswd?: string(name='AdUserPasswd', description='The password of the AD user.', example='xxxxxx'),
  }(name='WinAdPar', description='The parameter that is used to connect to the Windows AD server.', position='Query'),
  zoneId?: string(name='ZoneId', description='The ID of the zone.', example='cn-hangzhou-b', position='Query'),
}

model CreateHybridClusterResponseBody = {
  clusterId?: string(name='ClusterId', description='The ID of cluster.', example='ehpc-hz-FYUr32****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='F6757FA4-8FED-4602-B7F5-3550C0842122'),
  taskId?: string(name='TaskId', description='The ID of the task.', example='F6757FA4-8FED-4602-B7F5-3550C0842122'),
}

model CreateHybridClusterResponse = {
  headers: map[string]string(name='headers'),
  body: CreateHybridClusterResponseBody(name='body'),
}

async function createHybridCluster(request: CreateHybridClusterRequest): CreateHybridClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateHybridCluster', 'GET', '/', 'json', false, 'json', request);
}

model CreateJobFileRequest {
  async?: boolean(name='Async', example='false', position='Query'),
  clusterId: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-jeJki6****', position='Query'),
  content: string(name='Content', description='The content of the job file. The content is encoded in Base64.', example='c2xlZXAgMzA=', position='Query'),
  runasUser: string(name='RunasUser', description='The user to which the job belongs.

You can call the [ListUsers](~~188572~~) operation to query the users of the cluster.', example='testuser1', position='Query'),
  runasUserPassword?: string(name='RunasUserPassword', description='The password of the user.', example='!QAZ****', position='Query'),
  targetFile: string(name='TargetFile', description='The name of the job file.', example='lammps.pbs', position='Query'),
}

model CreateJobFileResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model CreateJobFileResponse = {
  headers: map[string]string(name='headers'),
  body: CreateJobFileResponseBody(name='body'),
}

async function createJobFile(request: CreateJobFileRequest): CreateJobFileResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateJobFile', 'GET', '/', 'json', false, 'json', request);
}

model CreateJobTemplateRequest {
  arrayRequest?: string(name='ArrayRequest', description='The job array.

Format: X-Y:Z. X is the minimum index value. Y is the maximum index value. Z is the step size. For example, 2-7:2 indicates that three jobs need to be run and their index values are 2, 4, and 6.', example='1-10:2', position='Query'),
  clockTime?: string(name='ClockTime', description='The maximum running time of the job. Valid formats:

*   hh:mm:ss
*   mm:ss
*   ss

We recommend that you use the hh:mm:ss format. If the maximum running time is 12 hours, set the value to 12:00:00.', example='12:00:00', position='Query'),
  commandLine: string(name='CommandLine', description='The command that is used to run the job.', example='./LammpsTest/lammps.pbs', position='Query'),
  gpu?: int32(name='Gpu', description='The maximum GPU usage required by a single compute node. Valid values: 1 to 8.

The parameter takes effect only when the cluster uses PBS and a compute node is a GPU-accelerated instance.', example='1', minimum=1, maximum=20000, position='Query'),
  inputFileUrl?: string(name='InputFileUrl', description='The URL of the job files that are uploaded to an Object Storage Service (OSS) bucket.', example='https://test.oss-cn-beijing.aliyuncs.com/test.py', position='Query'),
  mem?: string(name='Mem', description='The maximum memory usage required by a single compute node. Unit: GB, MB, or KB. The unit is case-insensitive.', example='1GB', position='Query'),
  name: string(name='Name', description='The name of the job template. The name must be 2 to 64 characters in length. It must start with a letter and can contain letters, digits, hyphens (-), and underscores (\\_).', example='jobtemplate1', position='Query'),
  node?: int32(name='Node', description='The number of compute nodes. Valid values: 1 to 500.

>  If the parameter is not specified, the Task, Thread, Mem, and Gpu parameters become invalid.', example='2', minimum=1, maximum=5000, position='Query'),
  packagePath?: string(name='PackagePath', description='The path that is used to run the job.', example='./jobfolder', position='Query'),
  priority?: int32(name='Priority', description='The priority of the job. Valid values: 0 to 9. A large value indicates a high priority.

Default value: 0', example='0', position='Query'),
  queue?: string(name='Queue', description='The name of the queue in which the job is run.

You can call the [ListQueues](~~92176~~) operation to query the queue name.', example='workq', position='Query'),
  reRunable?: boolean(name='ReRunable', description='Specifies whether the job can be rerun. Valid values:

*   true: The job can be rerun.
*   false: The job cannot be rerun.', example='false', position='Query'),
  runasUser?: string(name='RunasUser', description='The name of the user that runs the job.

You can call the [ListUsers](~~188572~~) operation to query the users of the cluster.', example='user1', position='Query'),
  stderrRedirectPath?: string(name='StderrRedirectPath', description='The output file path of stderr.', example='./LammpsTest', position='Query'),
  stdoutRedirectPath?: string(name='StdoutRedirectPath', description='The output file path of stdout.', example='./LammpsTest', position='Query'),
  task?: int32(name='Task', description='The number of tasks required by a single compute node. Valid values: 1 to 1000.', example='2', minimum=1, maximum=20000, position='Query'),
  thread?: int32(name='Thread', description='The number of threads required by a single compute node. Valid values: 1 to 1000.', example='1', minimum=1, maximum=20000, position='Query'),
  unzipCmd?: string(name='UnzipCmd', description='The command that is used to decompress the job files downloaded from an OSS bucket. The parameter takes effect only when WithUnzipCmd is set to true. Valid values:

*   tar xzf: decompresses GZIP files.
*   tar xf: decompresses TAR files.
*   unzip: decompresses ZIP files.', example='tar xzf', position='Query'),
  variables?: string(name='Variables', description='The runtime variables passed to the job. They can be accessed by using environment variables in the executable file.', example='[{Name:,Value:},{Name:,Value:}]', position='Query'),
  withUnzipCmd?: boolean(name='WithUnzipCmd', description='Specifies whether to decompress the job files downloaded from an OSS bucket. Valid values:

*   true: The job files are decompressed.
*   false: The job files are not decompressed.', example='true', position='Query'),
}

model CreateJobTemplateResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  templateId?: string(name='TemplateId', description='The ID of the job template.', example='ehpc-job-tmpl-6RxO5y****'),
}

model CreateJobTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: CreateJobTemplateResponseBody(name='body'),
}

async function createJobTemplate(request: CreateJobTemplateRequest): CreateJobTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateJobTemplate', 'GET', '/', 'json', false, 'json', request);
}

model DeleteClusterRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-QKKVqO****', position='Query'),
  releaseInstance?: string(name='ReleaseInstance', description='Specifies whether to release Elastic Compute Service (ECS) instances that are created by using Elastic High Performance Computing (E-HPC).

Default value: true', example='true', position='Query'),
}

model DeleteClusterResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F1AB6D8D-E185-4D94-859C-7CE7B8B7****'),
  taskId?: string(name='TaskId', description='The ID of the task.', example='F1AB6D8D-E185-4D94-859C-7CE7B8B7****'),
}

model DeleteClusterResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteClusterResponseBody(name='body'),
}

/**
  * After a cluster is released, the pay-as-you-go nodes and the subscription nodes that have expired are automatically released. The subscription nodes that have not expired are retained. If you need to release the subscription nodes that have not expired, change their billing method to pay-as-you-go. Before you release a cluster, make sure that you will no longer use the cluster.
  *
 */
async function deleteCluster(request: DeleteClusterRequest): DeleteClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteCluster', 'GET', '/', 'json', false, 'json', request);
}

model DeleteContainerAppsRequest {
  containerApp: [ 
    {
      id?: string(name='Id', description='The ID of the containerized application that you want to delete. Valid values of N: 1 to 100.

You can call the [ListContainerApps](~~87333~~) operation to query the ID of the containerized application.', example='ehpc-container-ABDUGSkjs****'),
    }
  ](name='ContainerApp', position='Query'),
}

model DeleteContainerAppsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model DeleteContainerAppsResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteContainerAppsResponseBody(name='body'),
}

async function deleteContainerApps(request: DeleteContainerAppsRequest): DeleteContainerAppsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteContainerApps', 'GET', '/', 'json', false, 'json', request);
}

model DeleteGWSClusterRequest {
  clusterId: string(name='ClusterId', description='The ID of the visualization service.', example='gws-rhz99q8rc****', position='Query'),
}

model DeleteGWSClusterResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='8442AF35-875B-4FC0-8B7AAFDC339335D5'),
}

model DeleteGWSClusterResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteGWSClusterResponseBody(name='body'),
}

async function deleteGWSCluster(request: DeleteGWSClusterRequest): DeleteGWSClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteGWSCluster', 'GET', '/', 'json', false, 'json', request);
}

model DeleteGWSInstanceRequest {
  instanceId: string(name='InstanceId', description='The ID of the visualization instance.', example='i-bp66guhybgtrftpa1****', position='Query'),
}

model DeleteGWSInstanceResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='2777461A-E45E-42F8-8E67-0EBF132E93E0'),
}

model DeleteGWSInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteGWSInstanceResponseBody(name='body'),
}

async function deleteGWSInstance(request: DeleteGWSInstanceRequest): DeleteGWSInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteGWSInstance', 'GET', '/', 'json', false, 'json', request);
}

model DeleteImageRequest {
  regionId?: string(name='RegionId', position='Host'),
  clusterId: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****', position='Query'),
  containerType?: string(name='ContainerType', description='The type of the container. Set the value to singularity.', example='singularity', position='Query'),
  imageTag?: string(name='ImageTag', description='The tags of the image.

Default value: latest', example='latest', position='Query'),
  repository: string(name='Repository', description='The name of the repository.

You can call the [ListContainerImages](~~87348~~) operation to query the name of the repository.', example='repo1', position='Query'),
}

model DeleteImageResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model DeleteImageResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteImageResponseBody(name='body'),
}

async function deleteImage(request: DeleteImageRequest): DeleteImageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteImage', 'GET', '/', 'json', false, 'json', request);
}

model DeleteJobTemplatesRequest {
  templates: string(name='Templates', description='The list of job templates. A maximum of 20 job templates can be deleted.

Format: `[{"Id": "0.sched****"},{"Id": "1.sched****"}]`. Separate multiple job templates with commas (,).

You can call the [ListJobTemplates](~~87248~~) operation to obtain the job template ID.', example='[{"Id":"ehpc-job-tmpl-6RVcMK****"},{"Id": "ehpc-job-tmpl-6RxO5y****"}]', position='Query'),
}

model DeleteJobTemplatesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model DeleteJobTemplatesResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteJobTemplatesResponseBody(name='body'),
}

async function deleteJobTemplates(request: DeleteJobTemplatesRequest): DeleteJobTemplatesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteJobTemplates', 'GET', '/', 'json', false, 'json', request);
}

model DeleteJobsRequest {
  async?: boolean(name='Async', description='Specifies whether to use an asynchronous link to delete the jobs.

Default value: false', example='false', position='Query'),
  clusterId: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****', position='Query'),
  jobs: string(name='Jobs', description='The list of jobs that you want to delete. Maximum number of jobs: 100. Minimum number of jobs: 1.

Format: `[{"Id": "0.sched****"},{"Id": "1.sched****"}]`. Separate multiple jobs with commas (,).

You can call the [ListJobs](~~87251~~) operation to query the job ID.', example='[{"Id": "0.sched****"},{"Id": "1.sched****"}]', position='Query'),
}

model DeleteJobsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model DeleteJobsResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteJobsResponseBody(name='body'),
}

async function deleteJobs(request: DeleteJobsRequest): DeleteJobsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteJobs', 'GET', '/', 'json', false, 'json', request);
}

model DeleteLocalImageRequest {
  regionId: string(name='RegionId', position='Host'),
  clusterId: string(name='ClusterId', example='ehpc-hz-ibug69****', position='Query'),
  containerType: string(name='ContainerType', example='singularity', position='Query'),
  imageName: string(name='ImageName', example='test.sif', position='Query'),
}

model DeleteLocalImageResponseBody = {
  requestId?: string(name='RequestId', example='896D338C-E4F4-41EC-A154-D605E5DE****'),
}

model DeleteLocalImageResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteLocalImageResponseBody(name='body'),
}

async function deleteLocalImage(request: DeleteLocalImageRequest): DeleteLocalImageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteLocalImage', 'GET', '/', 'json', false, 'json', request);
}

model DeleteNodesRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****', position='Query'),
  instance: [ 
    {
      id?: string(name='Id', description='The ID of the compute node that you want to delete. Valid values of N: 1 to 100.

You can call the [DescribeCluster](~~87126~~) operation to query the IDs of the nodes in the cluster.', example='i-bp13p7vlcb1uihfv****'),
    }
  ](name='Instance', position='Query'),
  releaseInstance?: boolean(name='ReleaseInstance', description='Specifies whether to release the instances that are created by using E-HPC.

Default value: true', example='true', position='Query'),
  sync?: boolean(name='Sync', description='Specifies whether to directly delete the node. Valid values:

*   true
*   false', example='false', position='Query'),
}

model DeleteNodesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  taskId?: string(name='TaskId', description='The ID of the task.

*   If you set the Sync parameter to true, the DeleteNodes operation is synchronous. Valid value: Not Available.
*   If you set the Sync parameter to false, the DeleteNodes operation is asynchronous. You can call the [ListTasks](~~268225~~) operation to query the result of the task.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model DeleteNodesResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteNodesResponseBody(name='body'),
}

/**
  * Before you delete a compute node, we recommend that you export all job data from the node to prevent data loss.
  *
 */
async function deleteNodes(request: DeleteNodesRequest): DeleteNodesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteNodes', 'GET', '/', 'json', false, 'json', request);
}

model DeleteQueueRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****', position='Query'),
  queueName: string(name='QueueName', description='The name of the queue that you want to delete.

You can call the [ListQueues](~~92176~~) operation to query the name of the queue.', example='workq', position='Query'),
}

model DeleteQueueResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='464E9919-D04F-4D1D-B375-15989492****'),
}

model DeleteQueueResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteQueueResponseBody(name='body'),
}

async function deleteQueue(request: DeleteQueueRequest): DeleteQueueResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteQueue', 'GET', '/', 'json', false, 'json', request);
}

model DeleteSecurityGroupRequest {
  clusterId: string(name='ClusterId', description='The ID of the security group.', example='ehpc-hz-FYUr32****', position='Query'),
  securityGroupId: string(name='SecurityGroupId', description='The ID of the request.', example='sg-bp13n61xsydodfyg****', position='Query'),
}

model DeleteSecurityGroupResponseBody = {
  requestId?: string(name='RequestId', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model DeleteSecurityGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSecurityGroupResponseBody(name='body'),
}

async function deleteSecurityGroup(request: DeleteSecurityGroupRequest): DeleteSecurityGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteSecurityGroup', 'GET', '/', 'json', false, 'json', request);
}

model DeleteUsersRequest {
  async?: boolean(name='Async', description='Specifies whether to enable the asynchronous mode for this request.

Default value: false.', example='false', position='Query'),
  clusterId: string(name='ClusterId', description='The cluster ID.

You can call the [ListClusters](~~87116~~) operation to obtain the cluster ID.', example='ehpc-hz-FYUr32****', position='Query'),
  user: [ 
    {
      name: string(name='Name', description='The name of the user N that you want to delete. Valid values of N: 1 to 100.

You can call the [ListUsers](~~188572~~) operation to query the users of the cluster.', example='user1'),
    }
  ](name='User', description='The information about the user.', position='Query'),
}

model DeleteUsersResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE****'),
}

model DeleteUsersResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteUsersResponseBody(name='body'),
}

/**
  * ## Description
  * If you delete a user, only its information is deleted. The files stored in the /home directory for the user are retained. For example, if you delete a user named user1, the files in the `/home/user1/` directory of the cluster are not deleted. However, a deleted user cannot be recovered. Even if you create another user that has the same name, the data retained for the deleted user is not reused.
  *
 */
async function deleteUsers(request: DeleteUsersRequest): DeleteUsersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteUsers', 'GET', '/', 'json', false, 'json', request);
}

model DescribeAutoScaleConfigRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-FYUr32****', position='Query'),
}

model DescribeAutoScaleConfigResponseBody = {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-FYUr32****'),
  clusterType?: string(name='ClusterType', description='The type of the scheduler. Valid values:

*   pbs
*   slurm
*   opengridscheduler
*   deadline', example='slurm'),
  enableAutoGrow?: boolean(name='EnableAutoGrow', description='Indicates whether auto scale-out is enabled.', example='true'),
  enableAutoShrink?: boolean(name='EnableAutoShrink', description='Indicates whether auto scale-in is enabled.', example='true'),
  excludeNodes?: string(name='ExcludeNodes', description='The list of nodes on which auto scaling is not enabled.', example='i-bp19lgqwxb4206t5****,i-bp1g4hvzs9pywrhb****'),
  extraNodesGrowRatio?: int32(name='ExtraNodesGrowRatio', description='The ratio of added nodes to the original ones. Valid values: 0 to 100.', example='0'),
  growIntervalInMinutes?: int32(name='GrowIntervalInMinutes', description='The scale-out interval. The interval at which the compute nodes were scaled out. Valid values: 2 to 10.', example='10'),
  growRatio?: int32(name='GrowRatio', description='The percentage of the added nodes. Valid values: 1 to 100.', example='1'),
  growTimeoutInMinutes?: int32(name='GrowTimeoutInMinutes', description='The timeout period before the node was started. Valid values: 10 to 60.', example='20'),
  maxNodesInCluster?: int32(name='MaxNodesInCluster', description='The maximum number of compute nodes in the cluster. This parameter indicates the largest number of nodes that can be added to the cluster.', example='100'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73'),
  shrinkIdleTimes?: int32(name='ShrinkIdleTimes', description='The number of consecutive idle times of a node during a scale-in check. Valid values: 2 to 5.', example='3'),
  shrinkIntervalInMinutes?: int32(name='ShrinkIntervalInMinutes', description='The scale-in interval. The interval at which the compute nodes were scaled in. Valid values: 2 to 10.', example='2'),
  spotPriceLimit?: string(name='SpotPriceLimit', description='The maximum hourly rate of the instance. The value is accurate to three decimal places. It takes effect only when SpotStrategy is set to SpotWithPriceLimit.', example='0.062'),
  spotStrategy?: string(name='SpotStrategy', description='The bidding policy for the compute nodes. Valid values:

*   NoSpot: The instance is created as a regular pay-as-you-go instance.
*   SpotWithPriceLimit: The instance is a preemptible one with a user-defined maximum hourly rate.
*   SpotAsPriceGo: The instance is created as a pay-as-you-go instance that is automatically priced based on the Alibaba Cloud Marketplace.', example='NoSpot'),
  uid?: string(name='Uid', description='The ID of the user.', example='testu****'),
}

model DescribeAutoScaleConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAutoScaleConfigResponseBody(name='body'),
}

async function describeAutoScaleConfig(request: DescribeAutoScaleConfigRequest): DescribeAutoScaleConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAutoScaleConfig', 'GET', '/', 'json', false, 'json', request);
}

model DescribeClusterRequest {
  clusterId: string(name='ClusterId', description='The type of the image. Valid values:

*   system: public image
*   self: custom image
*   others: shared image
*   marketplace: Alibaba Cloud Marketplace image', example='ehpc-hz-QKKVqO****', position='Query'),
}

model DescribeClusterResponseBody = {
  clusterInfo?: {
    accountType?: string(name='AccountType', description='The version of the E-HPC client.', example='nis'),
    addOnsInfo?: {
      addOnsInfo?: [ 
      {
        deployMode?: string(name='DeployMode'),
        port?: int32(name='Port'),
        softwareId?: string(name='SoftwareId'),
        status?: string(name='Status'),
        URL?: string(name='URL'),
      }
    ](name='AddOnsInfo')
    }(name='AddOnsInfo'),
    applications?: {
      applicationInfo?: [ 
      {
        name?: string(name='Name', description='The hostname of the on-premises management nodes.', example='openmpi'),
        tag?: string(name='Tag', description='The type of on-premises management nodes. Valid values:

- scheduler
- account
- account, scheduler', example='OpenMPI_1.8.7'),
        version?: string(name='Version', description='The IP address of the on-premises management nodes.', example='1.10'),
      }
    ](name='ApplicationInfo')
    }(name='Applications', description='The list of on-premises management nodes. 

This parameter is returned only when the cluster is deployed across hybrid environments and the hybrid-cloud proxy mode is enabled for the cluster.'),
    autoRenew?: string(name='AutoRenew'),
    autoRenewPeriod?: string(name='AutoRenewPeriod'),
    baseOsTag?: string(name='BaseOsTag', description='The list of scripts downloaded after the cluster was created.', example='CentOS_7.2_64'),
    clientVersion?: string(name='ClientVersion', description='The number of proxy nodes.', example='1.0.1'),
    clusterVersion?: string(name='ClusterVersion'),
    computeSpotPriceLimit?: string(name='ComputeSpotPriceLimit'),
    computeSpotStrategy?: string(name='ComputeSpotStrategy'),
    createTime?: string(name='CreateTime', description='The ID of the Elastic Compute Service (ECS) instance.', example='2020-12-24T03:18:23.000Z'),
    deployMode?: string(name='DeployMode', description='The list of management nodes.', example='Simple'),
    description?: string(name='Description', description='The tag of the software.', example='cluster'),
    domain?: string(name='Domain'),
    ecsChargeType?: string(name='EcsChargeType', description='The name of the image.', example='PostPaid'),
    ecsInfo?: {
      compute?: {
        count?: int32(name='Count', example='1'),
        instanceType?: string(name='InstanceType', example='ecs.n1.tiny'),
      }(name='Compute'),
      login?: {
        count?: int32(name='Count', example='1'),
        instanceType?: string(name='InstanceType', example='ecs.n1.tiny'),
      }(name='Login'),
      manager?: {
        count?: int32(name='Count', example='1'),
        instanceType?: string(name='InstanceType', example='ecs.n1.tiny'),
      }(name='Manager'),
      proxyMgr?: {
        count?: int32(name='Count', example='1'),
        instanceType?: string(name='InstanceType', example='ecs.n1.tiny'),
      }(name='ProxyMgr'),
    }(name='EcsInfo'),
    haEnable?: boolean(name='HaEnable', description='The version of the software.', example='false'),
    id?: string(name='Id', description='The instance type of the proxy node.', example='i-bp15de54eet1c43f****'),
    imageId?: string(name='ImageId', description='The runtime parameter of the script.', example='centos_7_02_64_20G_alibase_20170818****'),
    imageName?: string(name='ImageName', description='The instance type of the logon nodes.', example='test_for_Image'),
    imageOwnerAlias?: string(name='ImageOwnerAlias', description='The instance type of the management nodes.', example='system'),
    initialImage?: {
      imageId?: string(name='ImageId'),
      imageOwnerAlias?: string(name='ImageOwnerAlias'),
      osTag?: string(name='OsTag'),
    }(name='InitialImage'),
    keyPairName?: string(name='KeyPairName', description='The ID of the vSwitch. E-HPC can be deployed only in VPCs.', example='test'),
    location?: string(name='Location', description='The list of proxy nodes on the cloud. 

This parameter is returned only when the cluster is deployed across hybrid environments and the hybrid-cloud proxy mode is enabled for the cluster.', example='PublicCloud'),
    name?: string(name='Name', description='The URL that was used to download the script.', example='cluster'),
    nodes?: {
      nodesInfo?: [ 
      {
        accountType?: string(name='AccountType'),
        dir?: string(name='Dir'),
        hostName?: string(name='HostName'),
        ipAddress?: string(name='IpAddress'),
        role?: string(name='Role'),
        schedulerType?: string(name='SchedulerType'),
      }
    ](name='NodesInfo')
    }(name='Nodes'),
    onPremiseInfo?: {
      onPremiseInfo?: [ 
      {
        hostName?: string(name='HostName', example='testecs'),
        ip?: string(name='IP', example='192.168.*.*'),
        type?: string(name='Type', example='scheduler'),
      }
    ](name='OnPremiseInfo')
    }(name='OnPremiseInfo'),
    openldapPar?: string(name='OpenldapPar'),
    osTag?: string(name='OsTag', description='The number of management nodes.', example='CentOS_7.2_64'),
    period?: string(name='Period'),
    periodUnit?: string(name='PeriodUnit'),
    plugin?: string(name='Plugin'),
    postInstallScripts?: {
      postInstallScriptInfo?: [ 
      {
        args?: string(name='Args', example='bash file.sh'),
        url?: string(name='Url', example='example.com'),
      }
    ](name='PostInstallScriptInfo')
    }(name='PostInstallScripts'),
    ramNodeTypes?: string(name='RamNodeTypes'),
    ramRoleName?: string(name='RamRoleName'),
    regionId?: string(name='RegionId', description='The number of compute nodes.', example='cn-hangzhou'),
    remoteDirectory?: string(name='RemoteDirectory', description='The instance type of the compute nodes.', example='NasMountpoint:/RemoteDirectory'),
    resourceGroupId?: string(name='ResourceGroupId'),
    sccClusterId?: string(name='SccClusterId', description='The location where the cluster is deployed. Valid values:

*   OnPremise: The cluster is deployed on a hybrid cloud.
*   PublicCloud: The node is deployed on a public cloud.', example='00b648b****'),
    schedulerPreInstall?: int32(name='SchedulerPreInstall'),
    schedulerType?: string(name='SchedulerType', description='The list of ECS instance specifications and quantity.', example='pbs'),
    securityGroupId?: string(name='SecurityGroupId', description='The type of the network shared storage. Valid value: NAS.', example='sg-bp1asugr34gzn****'),
    status?: string(name='Status', description='The remote directory on which the file system is mounted.', example='creating'),
    vSwitchId?: string(name='VSwitchId', description='The list of logon nodes.', example='vsw-bp1e47optm9g58zcu****'),
    volumeId?: string(name='VolumeId', description='The name of the software.', example='008b64****'),
    volumeMountpoint?: string(name='VolumeMountpoint', description='The list of compute nodes.', example='008b648bcb-s****.cn-hangzhou.nas.aliyuncs.com'),
    volumeProtocol?: string(name='VolumeProtocol', description='The array of the software in the cluster. The array contains the name and version of the software.', example='nfs'),
    volumeType?: string(name='VolumeType', description='The number of logon nodes.', example='NAS'),
    vpcId?: string(name='VpcId', description='The region ID of the security group.', example='vpc-bp1pxkcvmmz53ki89****'),
    winAdPar?: string(name='WinAdPar'),
    withoutAgent?: int32(name='WithoutAgent'),
    zoneId?: string(name='ZoneId'),
  }(name='ClusterInfo', description='The mount target of the file system. Mount targets cannot be automatically created for NAS file systems.'),
  requestId?: string(name='RequestId', description='The image tag of the operating system.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model DescribeClusterResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeClusterResponseBody(name='body'),
}

async function describeCluster(request: DescribeClusterRequest): DescribeClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCluster', 'GET', '/', 'json', false, 'json', request);
}

model DescribeContainerAppRequest {
  containerId: string(name='ContainerId', description='The ID of the containerized application.

You can call the [ListContainerApps](~~87333~~) operation to query the ID of the containerized application.', example='ehpc-container-ABDUGSkjs****', position='Query'),
}

model DescribeContainerAppResponseBody = {
  containerAppInfo?: {
    createTime?: string(name='CreateTime', description='The time when the containerized application was created.', example='2018-07-18T17:46:47'),
    description?: string(name='Description', description='The description of the containerized application.', example='ExampleDescription'),
    id?: string(name='Id', description='The ID of the containerized application.', example='ehpc-container-ABDUGSkjs****'),
    imageTag?: string(name='ImageTag', description='The tags of the image.', example='latest'),
    name?: string(name='Name', description='The name of the containerized application.', example='ExampleName'),
    repository?: string(name='Repository', description='The name of the repository.', example='busybox'),
    type?: string(name='Type', description='The type of the container. Set the value to singularity.', example='singularity'),
  }(name='ContainerAppInfo', description='The information of the containerized application.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model DescribeContainerAppResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeContainerAppResponseBody(name='body'),
}

async function describeContainerApp(request: DescribeContainerAppRequest): DescribeContainerAppResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeContainerApp', 'GET', '/', 'json', false, 'json', request);
}

model DescribeEstackImageRequest {
  pageNumber?: int32(name='PageNumber', description='The number of the page to return.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.', example='10', maximum=50, position='Query'),
}

model DescribeEstackImageResponseBody = {
  imageList?: {
    imageListInfo?: [ 
    {
      imageName?: string(name='ImageName', description='The name of the image.', example='tensorflow-21.09-tf1-py3.sif'),
      imageSize?: int32(name='ImageSize', description='The size of the image.', example='65535'),
      imageType?: string(name='ImageType', description='The type of the image.', example='singularity'),
      imageUrl?: string(name='ImageUrl', description='The download URL of the image.', example='http://xxxx.oss-cn-hangzhou.aliyuncs.com/eStackPackage/singularity/tensorflow-21.09-tf1-py3.sif'),
      recentUpdateTime?: string(name='RecentUpdateTime', description='The time when the image was last modified.', example='2022-05-05T07:10:55.000Z'),
    }
  ](name='ImageListInfo')
  }(name='ImageList', description='The array of base images.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='2D69A58F-345C-4FDE-88E4-BF518948xxxx'),
  totalCount?: int32(name='TotalCount', description='The total number of images.', example='100'),
}

model DescribeEstackImageResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEstackImageResponseBody(name='body'),
}

async function describeEstackImage(request: DescribeEstackImageRequest): DescribeEstackImageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeEstackImage', 'GET', '/', 'json', false, 'json', request);
}

model DescribeGWSClusterPolicyRequest {
  asyncMode?: boolean(name='AsyncMode', example='true', position='Query'),
  clusterId: string(name='ClusterId', example='gws-rhz99q8rc****', position='Query'),
  taskId?: string(name='TaskId', example='t-****', position='Query'),
}

model DescribeGWSClusterPolicyResponseBody = {
  clipboard?: string(name='Clipboard', example='read'),
  localDrive?: string(name='LocalDrive', example='off'),
  requestId?: string(name='RequestId', example='7afc5a17-e60d-4a2a-85d6-7c9d4a81d65e'),
  usbRedirect?: string(name='UsbRedirect', example='on'),
  watermark?: string(name='Watermark', example='on'),
}

model DescribeGWSClusterPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeGWSClusterPolicyResponseBody(name='body'),
}

async function describeGWSClusterPolicy(request: DescribeGWSClusterPolicyRequest): DescribeGWSClusterPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeGWSClusterPolicy', 'POST', '/', 'json', false, 'json', request);
}

model DescribeGWSClustersRequest {
  clusterId?: string(name='ClusterId', description='The IDs of the visualization services.', example='gws-rhz99q8rc****', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number of the page to return.

Pages start from page 1.

Default value: 1.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 50.

Default value: 10.', example='10', maximum=50, position='Query'),
}

model DescribeGWSClustersResponseBody = {
  callerType?: string(name='CallerType', description='The type of the account. Valid values:

*   sub: a RAM user.
*   parent: an Alibaba Cloud account.', example='sub'),
  clusters?: {
    clusterInfo?: [ 
    {
      clusterId?: string(name='ClusterId', description='The ID of the visualization service.', example='gws-rhz99q8rc****'),
      createTime?: string(name='CreateTime', description='The time when the visualization service was created.', example='2019-05-15T06:05:40.000Z'),
      instanceCount?: int32(name='InstanceCount', description='The number of visualization instances.', example='3'),
      status?: string(name='Status', description='The status of the visualization services. Valid values:

*   creating: The service is being created.
*   starting: The service is being started.
*   running: The service is running.
*   deleted: The service is deleted.', example='running'),
      vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC).', example='vpc-bp1nq8oshqudln3hy****'),
    }
  ](name='ClusterInfo')
  }(name='Clusters', description='The information of the visualization services.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned on the current page.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='2777461A-E45E-42F8-8E67-0EBF132E93E0'),
  totalCount?: int32(name='TotalCount', description='The total number of returned entries.', example='1'),
}

model DescribeGWSClustersResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeGWSClustersResponseBody(name='body'),
}

async function describeGWSClusters(request: DescribeGWSClustersRequest): DescribeGWSClustersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeGWSClusters', 'GET', '/', 'json', false, 'json', request);
}

model DescribeGWSImagesRequest {
  pageNumber?: int32(name='PageNumber', example='1', position='Query'),
  pageSize?: int32(name='PageSize', example='10', maximum=50, position='Query'),
}

model DescribeGWSImagesResponseBody = {
  images?: {
    imageInfo?: [ 
    {
      createTime?: string(name='CreateTime', example='2019-05-15T06:05:40.000Z'),
      imageId?: string(name='ImageId', example='m-bp1by33e4h650m70lb****'),
      imageType?: string(name='ImageType', example='system'),
      name?: string(name='Name', example='Windows Server 2019'),
      progress?: string(name='Progress', example='100%'),
      size?: int32(name='Size', example='40'),
      status?: string(name='Status', example='Available'),
    }
  ](name='ImageInfo')
  }(name='Images'),
  pageNumber?: int32(name='PageNumber', example='1'),
  pageSize?: int32(name='PageSize', example='10'),
  requestId?: string(name='RequestId', example='2777461A-E45E-42F8-8E67-0EBF132E93E0'),
  totalCount?: int32(name='TotalCount', example='2'),
}

model DescribeGWSImagesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeGWSImagesResponseBody(name='body'),
}

async function describeGWSImages(request: DescribeGWSImagesRequest): DescribeGWSImagesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeGWSImages', 'GET', '/', 'json', false, 'json', request);
}

model DescribeGWSInstancesRequest {
  clusterId?: string(name='ClusterId', description='The ID of the visualization service.', example='gws-rhz99q8rc****', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the visualization instance.', example='i-bp1bzqq1ddeemuddn****', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number of the page to return.

Pages start from page 1.

Default value: 1.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 50.

Default value: 10.', example='10', maximum=50, position='Query'),
  userName?: string(name='UserName', description='The username of the entity whose instances you want to query.

>  If this parameter is not specified, instances of all users are queried.', example='testuser', position='Query'),
  userUid?: long(name='UserUid', description='The user ID of the entity whose instances you want to query.

>  If this parameter is not specified, instances of all users are queried.', example='1234567890', position='Query'),
}

model DescribeGWSInstancesResponseBody = {
  instances?: {
    instanceInfo?: [ 
    {
      appList?: {
        appInfo?: [ 
        {
          appArgs?: string(name='AppArgs', example='temp.txt'),
          appName?: string(name='AppName', description='The name of the application.', example='notepad'),
          appPath?: string(name='AppPath', description='The execution directory of the application.', example='/home/test/notepad.exe'),
        }
      ](name='AppInfo')
      }(name='AppList', description='The list of application information.

>  If the WorkMode parameter is set to Desktop, an empty value is returned in this parameter.'),
      clusterId?: string(name='ClusterId', description='The ID of the visualizatio service.', example='gws-rhz99q8rc****'),
      createTime?: string(name='CreateTime', description='The time when the visualization instance was created.', example='2020-02-03T14:03Z'),
      expireTime?: string(name='ExpireTime', description='The time when the visualization instance expires.', example='2099-12-31T15:59Z'),
      instanceId?: string(name='InstanceId', description='The ID of the visualization instance.', example='i-bp1bzqq1ddeemuddn****'),
      instanceType?: string(name='InstanceType', description='The type of the visualization instance.', example='ecs.g6.large'),
      name?: string(name='Name', description='The name of the visualization instance.', example='c0-i01-1-g6-2c8g'),
      status?: string(name='Status', description='The status of the visualization instance. Valid values:

*   Creating: The instance is being created.
*   Starting: The instance is being started.
*   Stopping: The instance is being stopped.
*   Stopped: The instance is stopped.
*   Initializing: The instance is being initialized.
*   Unregistered: The instance is not registered.
*   Registered: The instance is registered.
*   InUse: The instance is in use.
*   Missing: The instance cannot be found.
*   Cloning: An image is being generated based on the instance.', example='Creating'),
      userName?: string(name='UserName', description='The username of the entity to which the visualization instance is assigned.

>  If the instance is not assigned to a specified user, this parameter is empty.', example='user-****'),
      workMode?: string(name='WorkMode', description='The working mode of the visualization instance. Valid values:

*   Desktop
*   Application', example='Desktop'),
    }
  ](name='InstanceInfo')
  }(name='Instances', description='The list of visualization instances.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the current page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='2777461A-E45E-42F8-8E67-0EBF132E93E0'),
  totalCount?: int32(name='TotalCount', description='The total number of returned entries.', example='1'),
}

model DescribeGWSInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeGWSInstancesResponseBody(name='body'),
}

async function describeGWSInstances(request: DescribeGWSInstancesRequest): DescribeGWSInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeGWSInstances', 'GET', '/', 'json', false, 'json', request);
}

model DescribeImageRequest {
  regionId: string(name='RegionId', position='Host'),
  clusterId: string(name='ClusterId', description='The ID of the cluster that you want to manage.', example='ehpc-hz-FYUr32****', position='Query'),
  containerType?: string(name='ContainerType', description='The type of the container. Set the value to singularity.', example='singularity', position='Query'),
  imageTag?: string(name='ImageTag', description='The tag of the image. Default value: latest.', example='latest', position='Query'),
  repository: string(name='Repository', description='The name of the repository.', example='repo1', position='Query'),
}

model DescribeImageResponseBody = {
  imageInfo?: {
    imageId?: string(name='ImageId', description='The ID of the image.', example='353506****'),
    repository?: string(name='Repository', description='The name of the repository.', example='hello-world'),
    status?: string(name='Status', description='The status of the image.', example='READY'),
    system?: string(name='System', description='The container system.', example='mycluster'),
    tag?: string(name='Tag', description='The tag of the image.', example='latest'),
    type?: string(name='Type', description='The type of the image. Valid values:

*   shifter
*   docker', example='docker'),
    updateDateTime?: string(name='UpdateDateTime', description='The time when the image was last updated.', example='2018-08-02T20:11:36'),
  }(name='ImageInfo', description='The information of the image.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model DescribeImageResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeImageResponseBody(name='body'),
}

async function describeImage(request: DescribeImageRequest): DescribeImageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeImage', 'GET', '/', 'json', false, 'json', request);
}

model DescribeImageGatewayConfigRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-FYUr32****', position='Query'),
}

model DescribeImageGatewayConfigResponseBody = {
  imagegw?: {
    defaultImageLocation?: string(name='DefaultImageLocation', description='The default address of the image repository.', example='registry-1.docker.io'),
    imageExpirationTimeout?: string(name='ImageExpirationTimeout', description='The time when the image expires.', example='90:00:00'),
    locations?: {
      locationInfo?: [ 
      {
        authentication?: string(name='Authentication', description='The authentication method of the image repository. Valid values:

*   http
*   https', example='https'),
        location?: string(name='Location', description='The source address of the image repository.', example='regi****.docker.io'),
        remoteType?: string(name='RemoteType', description='The type of the image repository.', example='dockerv2'),
        URL?: string(name='URL', description='The URL of the image repository.', example='https://regi****.docker-cn.com'),
      }
    ](name='LocationInfo')
    }(name='Locations', description='An array of the image repository addresses.'),
    mongoDBURI?: string(name='MongoDBURI', description='The information about the image gateway database.', example='mongodb://localhost'),
    pullUpdateTimeout?: long(name='PullUpdateTimeout', description='The timeout period for pulling images.', example='300'),
    updateDateTime?: string(name='UpdateDateTime', description='The time when the file was updated.', example='2018-07-18T17:46:47'),
  }(name='Imagegw', description='The information about the image gateway configuration file.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model DescribeImageGatewayConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeImageGatewayConfigResponseBody(name='body'),
}

async function describeImageGatewayConfig(request: DescribeImageGatewayConfigRequest): DescribeImageGatewayConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeImageGatewayConfig', 'GET', '/', 'json', false, 'json', request);
}

model DescribeImagePriceRequest {
  amount: int32(name='Amount', description='The number of images that you want to purchase. Valid values: 1 to 1000.

Default value: 1', example='2', position='Query'),
  imageId: string(name='ImageId', description='The ID of the image.', example='m-bp198jigq7l1ga11****', position='Query'),
  orderType?: string(name='OrderType', description='The type of the order. The order can be set only as a purchase order. Valid value: INSTANCE-BUY.', example='INSTANCE-BUY', position='Query'),
  period: int32(name='Period', description='The subscription duration. Valid values:

*   If PriceUnit is set to Day, the valid values of the Period parameter are 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, and 30.
*   If PriceUnit is set to Month, the valid values of the Period parameter are 1, 2, 3, 4, 5, 6, 7, 8, and 9.
*   If PriceUnit is set to Year, the valid values of the Period parameter are 1, 2, and 3.

Default value: 1', example='1', position='Query'),
  priceUnit: string(name='PriceUnit', description='The unit of the subscription duration. Valid values:

*   Day
*   Month
*   Year

Default value: Day', example='Day', position='Query'),
  skuCode: string(name='SkuCode', description='The stock keeping unit (SKU) of the image. Valid value: package.', example='package', position='Query'),
}

model DescribeImagePriceResponseBody = {
  amount?: int32(name='Amount', description='The number of images that you want to purchase.', example='1'),
  discountPrice?: float(name='DiscountPrice', description='The discount that is applied.', example='0'),
  imageId?: string(name='ImageId', description='The ID of the image.', example='m-bp198jigq7l1ga11****'),
  originalPrice?: float(name='OriginalPrice', description='The original price of the image.', example='0.8'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='47ca3ac4-2a03-48f1-8bf2-ba6de0f3****'),
  tradePrice?: float(name='TradePrice', description='The final price of the image.', example='0.8'),
}

model DescribeImagePriceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeImagePriceResponseBody(name='body'),
}

async function describeImagePrice(request: DescribeImagePriceRequest): DescribeImagePriceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeImagePrice', 'GET', '/', 'json', false, 'json', request);
}

model DescribeJobRequest {
  async?: boolean(name='Async', example='false', position='Query'),
  clusterId: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-jeJki6****', position='Query'),
  jobId: string(name='JobId', description='The ID of the job.

You can call the [ListJobs](~~87251~~) operation to query the job ID.', example='1.scheduler****', position='Query'),
}

model DescribeJobResponseBody = {
  message?: {
    jobInfo?: string(name='JobInfo', description='The details of the job.', example='{"2.scheduler": {"egroup": "users","Stageout_status": 1,"Keep_Files": "n","server": "scheduler","queue": "workq"}}'),
  }(name='Message', description='The list of returned job information.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='9697AD8D-56FA-4C8E-B46C-00AC9***'),
}

model DescribeJobResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeJobResponseBody(name='body'),
}

async function describeJob(request: DescribeJobRequest): DescribeJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeJob', 'GET', '/', 'json', false, 'json', request);
}

model DescribeNFSClientStatusRequest {
  instanceId: string(name='InstanceId', description='The ID of the visualization instance.', example='i-bp1bzq4rj1emun****', position='Query'),
}

model DescribeNFSClientStatusResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='3EB7FCEE-D731-4948-85A3-4B2C341CA983'),
  result?: {
    exitCode?: int32(name='ExitCode', description='The Base64-decoded Output parameter value. A True in the last line indicates successful installation. Otherwise, the installation fails.', example='0'),
    invokeRecordStatus?: string(name='InvokeRecordStatus', description='The status of the invocation record, which is the same as the value of the Status parameter.', example='Running'),
    output?: string(name='Output', description='The execution result of the command.', example='TmV3LUlWtmOWc6XxpZW50Rm9yLi4uDQ****'),
  }(name='Result', description='The list of results.'),
  status?: string(name='Status', description='The deployment status of the NFS client. Valid values:

*   NotInstalled: The client is not installed.
*   Running: The client is being installed.
*   Finished: The client is installed on the instance.', example='Running'),
}

model DescribeNFSClientStatusResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeNFSClientStatusResponseBody(name='body'),
}

async function describeNFSClientStatus(request: DescribeNFSClientStatusRequest): DescribeNFSClientStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeNFSClientStatus', 'GET', '/', 'json', false, 'json', request);
}

model DescribePriceRequest {
  chargeType?: string(name='ChargeType', description='The billing method of the ECS instances. Valid values:

*   PostPaid: pay-as-you-go
*   PrePaid: subscription

Default value: PostPaid', example='PostPaid', position='Query'),
  commodities: [ 
    {
      amount: int32(name='Amount', description='The node quantity of the type. Valid values: 1 to 1000.

Default value: 1

Valid values of N: 1 to 10', example='2'),
      dataDisks?: [ 
        {
          category?: string(name='category', description='The type of the data disk. Valid values:

*   cloud_efficiency: ultra disk
*   cloud_ssd: SSD
*   cloud_essd: ESSD
*   cloud: basic disk

Default value: cloud_efficiency

Valid values of N: 0 to 4', example='cloud_efficiency'),
          deleteWithInstance?: boolean(name='deleteWithInstance', description='Specifies whether the data disk is released when the node is released. Valid values:

*   true
*   false

Default value: true

Valid values of N: 0 to 4', example='true'),
          encrypted?: boolean(name='encrypted', description='Specifies whether to encrypt the data disk. Valid values:

*   true
*   false

Default value: false

Valid values of N: 0 to 4', example='false'),
          performanceLevel?: string(name='performanceLevel', description='The performance level of the ESSD used as the data disk. This parameter takes effect only when the Commodities.N.DataDisks.N.category parameter is set to cloud_essd. Default value: PL1. Valid values:

*   PL0: A single ESSD can deliver up to 10,000 random read/write IOPS.
*   PL1: A single ESSD can deliver up to 50,000 random read/write IOPS.
*   PL2: A single ESSD can deliver up to 100,000 random read/write IOPS.
*   PL3: A single ESSD can deliver up to 1,000,000 random read/write IOPS.

Default value: PL1

Valid values of N: 0 to 4', example='PL1'),
          size?: int32(name='size', description='The size of the data disk. Unit: GB.

Valid values: 40 to 500

Default value: 40

Valid values of N: 0 to 4', example='40'),
        }
      ](name='DataDisks', description='The list of data disks created with the node.'),
      instanceType: string(name='InstanceType', description='The instance type of the node.

Valid values of N: 1 to 10', example='ecs.n1.tiny'),
      internetChargeType?: string(name='InternetChargeType', description='The EIP billing method of the node. Valid values:

*   PayByBandwidth: pay-by-bandwidth
*   PayByTraffic: pay-by-traffic

Valid values of N: 1 to 10', example='PayByBandwidth'),
      internetMaxBandWidthOut?: int32(name='InternetMaxBandWidthOut', description='The maximum outbound public bandwidth of the node. Unit: Mbit/s.

Valid values: 0 to 100

Default value: 0

Valid values of N: 1 to 10', example='100'),
      networkType?: string(name='NetworkType', description='The network type of the node. Valid value: VPC.

Valid values of N: 1 to 10', example='VPC'),
      nodeType: string(name='NodeType', description='The type of the node. Valid values:

*   Compute: compute node
*   Manager: management node
*   Login: logon node

Valid values of N: 1 to 10', example='Compute'),
      period: int32(name='Period', description='The subscription duration of the node. Valid values:

*   If PriceUnit is set to Year, the valid values of the Period parameter are 1, 2, and 3.
*   If PriceUnit is set to Month, the valid values of the Period parameter are 1, 2, 3, 4, 5, 6, 7, 8, and 9.
*   If PriceUnit is set to Hour, the valid value of the Period parameter is 1.

Default value: 1

Valid values of N: 1 to 10', example='1'),
      systemDiskCategory?: string(name='SystemDiskCategory', description='The system disk type of the node. Valid values:

*   cloud_efficiency: ultra disk
*   cloud_ssd: SSD
*   cloud_essd: ESSD
*   cloud: basic disk

Default value: cloud_efficiency

Valid values of N: 1 to 10', example='cloud_ssd'),
      systemDiskPerformanceLevel?: string(name='SystemDiskPerformanceLevel', description='The performance level of the ESSD used as the system disk. This parameter takes effect only when the Commodities.N.SystemDiskCategory parameter is set to cloud_essd. Default value: PL1. Valid values:

*   PL0: A single ESSD can deliver up to 10,000 random read/write IOPS.
*   PL1: A single ESSD can deliver up to 50,000 random read/write IOPS.
*   PL2: A single ESSD can deliver up to 100,000 random read/write IOPS.
*   PL3: A single ESSD can deliver up to 1,000,000 random read/write IOPS.

Default value: PL1

Valid values of N: 1 to 10', example='PL1'),
      systemDiskSize?: int32(name='SystemDiskSize', description='The system disk size of the node. Unit: GB.

Valid values: 40 to 500

Default value: 40

Valid values of N: 1 to 10', example='40'),
    }
  ](name='Commodities', description='Product List', position='Query'),
  orderType?: string(name='OrderType', description='The type of the order. The order can be set only as a purchase order. Valid value: INSTANCE-BUY.', example='INSTANCE-BUY', position='Query'),
  priceUnit: string(name='PriceUnit', description='The billing cycle of the Elastic Compute Service (ECS) instances. This parameter takes effect only when the ChargeType parameter is set to PrePaid. Valid values:

*   Month: pay-by-month
*   Year: pay-by-year
*   Hour: pay-by-hour

Default value: Hour', example='Hour', position='Query'),
}

model DescribePriceResponseBody = {
  prices?: {
    priceInfo?: [ 
    {
      currency?: string(name='Currency', description='The currency that is used to measure the price. Valid values:

USD', example='CNY'),
      nodeType?: string(name='NodeType', description='The type of the node. Valid values:

*   Manager: management node
*   Login: logon node
*   Compute: compute node', example='Compute'),
      originalPrice?: float(name='OriginalPrice', description='The original price of the image.

Unit: USD', example='1258'),
      tradePrice?: float(name='TradePrice', description='The final price.

Unit: USD', example='1258'),
    }
  ](name='PriceInfo')
  }(name='Prices', description='The array of cluster prices. If you query the prices of multiple nodes in the cluster, the sequence of the prices in the returned value of PriceInfo is the same as that of the nodes in the request parameters. For example, the first price in the value of PriceInfo is the price of the first node specified in the request parameters.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='54FF9025-2C2F-42EB-870D-0DF5B0ACF24E'),
  totalTradePrice?: float(name='TotalTradePrice', description='The total price.

Unit: USD', example='1258'),
}

model DescribePriceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePriceResponseBody(name='body'),
}

async function describePrice(request: DescribePriceRequest): DescribePriceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePrice', 'GET', '/', 'json', false, 'json', request);
}

model DescribeServerlessJobsRequest {
  clusterId: string(name='ClusterId', example='ehpc-hz-FYUr32****', position='Query'),
  jobIds: [ string ](name='JobIds', position='Query'),
}

model DescribeServerlessJobsResponseBody = {
  jobInfos?: [ 
    {
      arrayProperties?: {
        indexEnd?: long(name='IndexEnd', example='5'),
        indexStart?: long(name='IndexStart', example='1'),
        indexStep?: long(name='IndexStep', example='2'),
      }(name='ArrayProperties'),
      containerGroups?: [ 
        {
          containerGroupId?: string(name='ContainerGroupId', example='eci-bp1jrgfqqy54kg5hc****'),
          containerGroupName?: string(name='ContainerGroupName', example='test'),
          containers?: [ 
            {
              args?: [ string ](name='Args'),
              commands?: [ string ](name='Commands'),
              cpu?: float(name='Cpu', example='2.0'),
              currentState?: {
                detailStatus?: string(name='DetailStatus', example='working'),
                exitCode?: long(name='ExitCode', example='0'),
                finishTime?: string(name='FinishTime', example='2018-08-02T15:00:00Z'),
                message?: string(name='Message', example='Back-off 5m0s restarting failed container=test pod=test_eci-xxx(xxx)'),
                reason?: string(name='Reason', example='Started'),
                signal?: long(name='Signal', example='1'),
                startTime?: string(name='StartTime', example='2019-12-19T12:05:02Z'),
                state?: string(name='State', example='Terminated'),
              }(name='CurrentState'),
              environmentVars?: [ 
                {
                  key?: string(name='Key', example='PATH'),
                  value?: string(name='Value', example='/usr/bin/'),
                  valueFrom?: {
                    fieldRef?: {
                      fieldPath?: string(name='FieldPath', example='status.podIP'),
                    }(name='FieldRef'),
                  }(name='ValueFrom'),
                }
              ](name='EnvironmentVars'),
              gpu?: int32(name='Gpu', example='1'),
              image?: string(name='Image', example='HPL'),
              imagePullPolicy?: string(name='ImagePullPolicy', example='Always'),
              livenessProbe?: {
                execs?: [ string ](name='Execs'),
                failureThreshold?: long(name='FailureThreshold', example='3'),
                httpGet?: {
                  path?: string(name='Path', example='/usr/nginx/'),
                  port?: long(name='Port', example='80'),
                  scheme?: string(name='Scheme', example='HTTP'),
                }(name='HttpGet', description='HttpGetã€‚'),
                initialDelaySeconds?: long(name='InitialDelaySeconds', example='10'),
                periodSeconds?: long(name='PeriodSeconds', example='5'),
                successThreshold?: long(name='SuccessThreshold', example='1'),
                tcpSocket?: {
                  host?: string(name='Host', example='1.2.3.4'),
                  port?: long(name='Port', example='80'),
                }(name='TcpSocket', description='TcpSocketã€‚'),
                timeoutSeconds?: long(name='TimeoutSeconds', example='10'),
              }(name='LivenessProbe'),
              memory?: float(name='Memory', example='4.0'),
              name?: string(name='Name', example='HPL'),
              ports?: [ 
                {
                  port?: long(name='Port', example='8080'),
                  protocol?: string(name='Protocol', example='TCP'),
                }
              ](name='Ports'),
              previousState?: {
                detailStatus?: string(name='DetailStatus', example='working'),
                exitCode?: long(name='ExitCode', example='0'),
                finishTime?: string(name='FinishTime', example='2018-08-02T15:00:00Z'),
                message?: string(name='Message', example='Back-off 5m0s restarting failed container=test pod=test_eci-xxx(xxx)'),
                reason?: string(name='Reason', example='Completed'),
                signal?: long(name='Signal', example='1'),
                startTime?: string(name='StartTime', example='2018-08-02T15:00:00Z'),
                state?: string(name='State', example='Terminated'),
              }(name='PreviousState'),
              readinessProbe?: {
                execs?: [ string ](name='Execs'),
                failureThreshold?: long(name='FailureThreshold', example='3'),
                httpGet?: {
                  path?: string(name='Path', example='/usr/local'),
                  port?: long(name='Port', example='8080'),
                  scheme?: string(name='Scheme', description='HTTPï¼HTTPSã€‚', example='HTTP'),
                }(name='HttpGet'),
                initialDelaySeconds?: long(name='InitialDelaySeconds', example='10'),
                periodSeconds?: long(name='PeriodSeconds', example='5'),
                successThreshold?: long(name='SuccessThreshold', example='1'),
                tcpSocket?: {
                  host?: string(name='Host', description='Hostã€‚', example='1.2.3.4'),
                  port?: long(name='Port', example='8888'),
                }(name='TcpSocket'),
                timeoutSeconds?: long(name='TimeoutSeconds', example='1'),
              }(name='ReadinessProbe'),
              ready?: boolean(name='Ready', example='true'),
              restartCount?: int32(name='RestartCount', example='5'),
              securityContext?: {
                capability?: {
                  adds?: [ string ](name='Adds'),
                }(name='Capability'),
                readOnlyRootFilesystem?: boolean(name='ReadOnlyRootFilesystem', example='true'),
                runAsUser?: long(name='RunAsUser', example='1558'),
              }(name='SecurityContext'),
              stdin?: boolean(name='Stdin', example='true'),
              stdinOnce?: boolean(name='StdinOnce', example='true'),
              tty?: boolean(name='Tty', example='false'),
              volumeMounts?: [ 
                {
                  mountPath?: string(name='MountPath', example='/usr/share/'),
                  mountPropagation?: string(name='MountPropagation', example='None'),
                  name?: string(name='Name', example='test-empty'),
                  readOnly?: boolean(name='ReadOnly', example='false'),
                  subPath?: string(name='SubPath', example='/usr/sub'),
                }
              ](name='VolumeMounts'),
              workingDir?: string(name='WorkingDir', example='/usr/local/nginx'),
            }
          ](name='Containers'),
          cpu?: float(name='Cpu', example='2'),
          creationTime?: string(name='CreationTime', example='2018-08-02T15:00:00Z'),
          discount?: long(name='Discount', example='9'),
          dnsConfig?: {
            nameServers?: [ string ](name='NameServers'),
            options?: [ 
              {
                name?: string(name='Name', example='name'),
                value?: string(name='Value', example='value'),
              }
            ](name='Options'),
            searches?: [ string ](name='Searches'),
          }(name='DnsConfig'),
          eciSecurityContext?: {
            sysctls?: [ 
              {
                name?: string(name='Name', example='kernel.msgmax'),
                value?: string(name='Value', example='65536'),
              }
            ](name='Sysctls'),
          }(name='EciSecurityContext'),
          eniInstanceId?: string(name='EniInstanceId', example='eni-bp14rzqi6fd8satm****'),
          ephemeralStorage?: long(name='EphemeralStorage', example='20'),
          events?: [ 
            {
              count?: int32(name='Count', example='20'),
              firstTimestamp?: string(name='FirstTimestamp', example='2018-08-02T15:00:00Z'),
              lastTimestamp?: string(name='LastTimestamp', example='2018-08-02T15:00:00Z'),
              message?: string(name='Message', example='Started container'),
              name?: string(name='Name', example='test-xxx'),
              reason?: string(name='Reason', example='Created'),
              type?: string(name='Type', example='Normal'),
            }
          ](name='Events'),
          expiredTime?: string(name='ExpiredTime', example='2018-08-02T15:00:00Z'),
          failedTime?: string(name='FailedTime', example='2018-08-02T15:00:00Z'),
          hostAliases?: [ 
            {
              hostnames?: [ string ](name='Hostnames'),
              ip?: string(name='Ip', example='192.0.XX.XX'),
            }
          ](name='HostAliases'),
          initContainers?: [ 
            {
              args?: [ string ](name='Args'),
              command?: [ string ](name='Command'),
              cpu?: long(name='Cpu', example='1.0'),
              currentState?: {
                detailStatus?: string(name='DetailStatus', example='working'),
                exitCode?: long(name='ExitCode', example='0'),
                finishTime?: string(name='FinishTime', example='2018-08-02T15:00:00Z'),
                message?: string(name='Message', example='Created container'),
                reason?: string(name='Reason', example='Started'),
                signal?: long(name='Signal', example='1'),
                startTime?: string(name='StartTime', example='2018-08-02T15:00:00Z'),
                state?: string(name='State', example='Running'),
              }(name='CurrentState'),
              environmentVars?: [ 
                {
                  key?: string(name='Key', example='PATH'),
                  value?: string(name='Value', example='/usr/local/bin'),
                  valueFrom?: {
                    fieldRef?: {
                      fieldPath?: string(name='FieldPath', example='status.podIP'),
                    }(name='FieldRef'),
                  }(name='ValueFrom'),
                }
              ](name='EnvironmentVars'),
              gpu?: long(name='Gpu', example='1'),
              image?: string(name='Image', example='nginx'),
              imagePullPolicy?: string(name='ImagePullPolicy', example='Always'),
              memory?: long(name='Memory', example='2.0'),
              name?: string(name='Name', example='Init-xxx'),
              ports?: [ 
                {
                  port?: long(name='Port', example='8888'),
                  protocol?: string(name='Protocol', example='TCP'),
                }
              ](name='Ports'),
              previousState?: {
                detailStatus?: string(name='DetailStatus', example='working'),
                exitCode?: long(name='ExitCode', example='0'),
                finishTime?: string(name='FinishTime', example='2019-12-24T05:35:44Z'),
                message?: string(name='Message', example='Started container'),
                reason?: string(name='Reason', example='completed'),
                signal?: long(name='Signal', example='1'),
                startTime?: string(name='StartTime', example='2019-12-24T05:35:44Z'),
                state?: string(name='State', example='Terminated'),
              }(name='PreviousState'),
              ready?: boolean(name='Ready', example='true'),
              restartCount?: long(name='RestartCount', example='5'),
              securityContext?: {
                capability?: {
                  adds?: [ string ](name='Adds'),
                }(name='Capability'),
                readOnlyRootFilesystem?: boolean(name='ReadOnlyRootFilesystem', example='true'),
                runAsUser?: long(name='RunAsUser', example='1557'),
              }(name='SecurityContext'),
              volumeMounts?: [ 
                {
                  mountPath?: string(name='MountPath', example='/usr/share/'),
                  mountPropagation?: string(name='MountPropagation', example='None'),
                  name?: string(name='Name', example='test-empty'),
                  readOnly?: boolean(name='ReadOnly', example='false'),
                }
              ](name='VolumeMounts'),
              workingDir?: string(name='WorkingDir', example='/usr/test'),
            }
          ](name='InitContainers'),
          instanceType?: string(name='InstanceType', example='ecs.g5.large'),
          internetIp?: string(name='InternetIp', example='192.0.XX.XX'),
          intranetIp?: string(name='IntranetIp', example='172.16.XX.XX'),
          ipv6Address?: string(name='Ipv6Address', example='2001:XXXX:4:4:4:4:4:4'),
          memory?: float(name='Memory', example='4.0'),
          ramRoleName?: string(name='RamRoleName', example='ram:PassRole'),
          regionId?: string(name='RegionId', example='cn-hangzhou'),
          resourceGroupId?: string(name='ResourceGroupId', example='rg-aekzh43v*****'),
          restartPolicy?: string(name='RestartPolicy', example='Never'),
          securityGroupId?: string(name='SecurityGroupId', example='sg-bp12ujq5zpxuyjfo3o8r'),
          spotPriceLimit?: float(name='SpotPriceLimit', example='0.025'),
          spotStrategy?: string(name='SpotStrategy', example='NoSpot'),
          status?: string(name='Status', example='Running'),
          succeededTime?: string(name='SucceededTime', example='2019-12-11T04:33:42Z'),
          tags?: [ 
            {
              key?: string(name='Key', example='name'),
              value?: string(name='Value', example='test-xh'),
            }
          ](name='Tags'),
          tenantEniInstanceId?: string(name='TenantEniInstanceId', example='i-xxx'),
          tenantEniIp?: string(name='TenantEniIp', example='10.10.XX.XX'),
          tenantSecurityGroupId?: string(name='TenantSecurityGroupId', example='sg-xxx'),
          tenantVSwitchId?: string(name='TenantVSwitchId', example='vsw-xxx'),
          vSwitchId?: string(name='VSwitchId', example='vsw-bp1vzjjflab6wvjox****'),
          volumes?: [ 
            {
              configFileVolumeConfigFileToPaths?: [ 
                {
                  content?: string(name='Content', example='hello world'),
                  path?: string(name='Path', example='/usr/bin/'),
                }
              ](name='ConfigFileVolumeConfigFileToPaths'),
              diskVolumeDiskId?: string(name='DiskVolumeDiskId', example='d-xxxx'),
              diskVolumeFsType?: string(name='DiskVolumeFsType', example='xfs'),
              emptyDirVolumeMedium?: string(name='EmptyDirVolumeMedium', example='Memory'),
              emptyDirVolumeSizeLimit?: string(name='EmptyDirVolumeSizeLimit', example='256Mi'),
              flexVolumeDriver?: string(name='FlexVolumeDriver', example='flexvolume'),
              flexVolumeFsType?: string(name='FlexVolumeFsType', example='ntfs'),
              flexVolumeOptions?: string(name='FlexVolumeOptions', example='[nolock,tcp,noresvport]'),
              NFSVolumePath?: string(name='NFSVolumePath', example='/eci'),
              NFSVolumeReadOnly?: boolean(name='NFSVolumeReadOnly', example='false'),
              NFSVolumeServer?: string(name='NFSVolumeServer', example='0eafxxxxx-xxxxx.cn-hangzhou.nas.aliyuncs.com'),
              name?: string(name='Name', example='test-empty'),
              type?: string(name='Type', example='EmptyDirVolume'),
            }
          ](name='Volumes'),
          vpcId?: string(name='VpcId', example='vpc-1vzjjflab6wvjox****'),
          zoneId?: string(name='ZoneId', example='cn-hangzhou-h'),
        }
      ](name='ContainerGroups'),
      endTime?: long(name='EndTime', example='1662016121'),
      isArrayJob?: boolean(name='IsArrayJob', example='false'),
      jobId?: string(name='JobId'),
      jobName?: string(name='JobName'),
      lastModifyTime?: long(name='LastModifyTime', example='1663831441000'),
      priority?: long(name='Priority', example='9'),
      queue?: string(name='Queue', example='comp'),
      startTime?: long(name='StartTime', example='1647427667'),
      state?: string(name='State', example='Running'),
      submitTime?: long(name='SubmitTime', example='1647423718'),
      user?: string(name='User'),
    }
  ](name='JobInfos'),
  requestId?: string(name='RequestId', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
  totalCount?: int32(name='TotalCount', example='1'),
}

model DescribeServerlessJobsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeServerlessJobsResponseBody(name='body'),
}

async function describeServerlessJobs(request: DescribeServerlessJobsRequest): DescribeServerlessJobsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeServerlessJobs', 'POST', '/', 'json', false, 'json', request);
}

model EditJobTemplateRequest {
  arrayRequest?: string(name='ArrayRequest', description='The job array.

Format: X-Y:Z. X is the minimum index value. Y is the maximum index value. Z is the step size. For example, 2-7:2 indicates that three jobs need to be run and their index values are 2, 4, and 6.', example='1-10:2', position='Query'),
  clockTime?: string(name='ClockTime', description='The maximum running time of the job. Valid formats:

*   hh:mm:ss
*   mm:ss
*   ss

We recommend that you use the hh:mm:ss format. If the maximum running time is 12 hours, set the value to 12:00:00.', example='12:00:00', position='Query'),
  commandLine: string(name='CommandLine', description='The command that is used to run the job.', example='./LammpsTest/lammps.pbs', position='Query'),
  gpu?: int32(name='Gpu', description='The maximum GPU usage required by a single compute node. Valid values: 1 to 8.

The parameter takes effect only when the cluster uses PBS and a compute node is a GPU-accelerated instance.', example='1', minimum=1, maximum=20000, position='Query'),
  inputFileUrl?: string(name='InputFileUrl', description='The URL of the job files that are uploaded to an Object Storage Service (OSS) bucket.', example='https://test.oss-cn-beijing.aliyuncs.com/test.py', position='Query'),
  mem?: string(name='Mem', description='The maximum memory usage required by a single compute node. Unit: GB, MB, or KB. The unit is case-insensitive.', example='1GB', position='Query'),
  name: string(name='Name', description='The name of the job template.

You can call the [ListJobTemplates](~~87248~~) operation to obtain the job template name.', example='jobTemapleteName', position='Query'),
  node?: int32(name='Node', description='The number of the compute nodes. Valid values: 1 to 500.

>  If the parameter is not specified, the Task, Thread, Mem, and Gpu parameters become invalid.', example='2', minimum=1, maximum=5000, position='Query'),
  packagePath?: string(name='PackagePath', description='The path that is used to run the job.', example='./packageFolder', position='Query'),
  priority?: int32(name='Priority', description='The priority of the job. Valid values: 0 to 9. A large value indicates a high priority.

Default value: 0', example='0', position='Query'),
  queue?: string(name='Queue', description='The name of the queue.', example='workq', position='Query'),
  reRunable?: boolean(name='ReRunable', description='Specifies whether the job can be rerun. Valid values:

*   true: The job can be rerun.
*   false: The job cannot be rerun.', example='false', position='Query'),
  runasUser?: string(name='RunasUser', description='The name of the user that runs the job.

You can call the [ListUsers](~~188572~~) operation to query the users of the cluster.', example='user', position='Query'),
  stderrRedirectPath?: string(name='StderrRedirectPath', description='The output file path of stderr.', example='./Lammps', position='Query'),
  stdoutRedirectPath?: string(name='StdoutRedirectPath', description='The output file path of stdout.', example='./LammpsTest', position='Query'),
  task?: int32(name='Task', description='The number of tasks required by a single compute node. Valid values: 1 to 1000.', example='2', minimum=1, maximum=20000, position='Query'),
  templateId: string(name='TemplateId', description='The ID of the job template.

You can call the [ListJobTemplates](~~87248~~) operation to obtain the job template ID.', example='ehpc-job-tmpl-6RxO5y****', position='Query'),
  thread?: int32(name='Thread', description='The number of threads required by a single compute node. Valid values: 1 to 1000.', example='1', minimum=1, maximum=20000, position='Query'),
  unzipCmd?: string(name='UnzipCmd', description='The command that is used to decompress the job files downloaded from an OSS bucket. The parameter takes effect only when WithUnzipCmd is set to true. Valid values:

*   tar xzf: decompresses GZIP files.
*   tar xf: decompresses TAR files.
*   unzip: decompresses ZIP files.', example='tar xzf', position='Query'),
  variables?: string(name='Variables', description='The runtime variables passed to the job. They can be accessed by using environment variables in the executable file.', example='[{Name:,Value:},{Name:,Value:}]', position='Query'),
  withUnzipCmd?: boolean(name='WithUnzipCmd', description='Specifies whether to decompress the job files downloaded from an OSS bucket. Valid values:

*   true: The job files are decompressed.
*   false: The job files are not decompressed.', example='true', position='Query'),
}

model EditJobTemplateResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  templateId?: string(name='TemplateId', description='The ID of the job template.', example='ehpc-job-tmpl-6RxO5y****'),
}

model EditJobTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: EditJobTemplateResponseBody(name='body'),
}

async function editJobTemplate(request: EditJobTemplateRequest): EditJobTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EditJobTemplate', 'GET', '/', 'json', false, 'json', request);
}

model GetAccountingReportRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-FYUr32****', position='Query'),
  dim?: string(name='Dim', description='The layers at which you want to query the bandwidth and traffic data. Valid values:

*   user: Query by user.
*   queue: Query by queue.
*   instance: Query by instance.', example='user', position='Query'),
  endTime?: int32(name='EndTime', description='The end of the time range to query. This value is a UNIX timestamp representing the number of seconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.', example='1577441873', position='Query'),
  filterValue?: string(name='FilterValue', description='The actual name of the dimension to be queried. Valid values:

*   If you set the value of the parameter Dim to user, the value of FilterValue is the name of the specified user.
*   If you set the value of the parameter Dim to queue, the value of FilterValue is the name of the specified queue.
*   If you set the value of the parameter Dim to instance, the value of FilterValue is the instance name.', example='userNo1', position='Query'),
  jobId?: string(name='JobId', description='The ID of the job.', example='[{Id: 1.scheduler}]', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The number of entries to return on each page. Valid values: 1 to 50.

Default value: 10.', example='10', position='Query'),
  pageSize?: int32(name='PageSize', description='The page number of the returned page.

Pages start from page 1.

Default value: 1.', example='1', position='Query'),
  reportType: string(name='ReportType', description='The query type. Valid values:

*   total_report: Queries the number of CPU cores in different dimensions.
*   job_report: Collects the historical node data of a node.
*   number_report: Queries job information in different dimensions.', example='job_report', position='Query'),
  startTime?: int32(name='StartTime', description='The beginning of the time range to query. This value is a UNIX timestamp representing the number of seconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.', example='1576922873', position='Query'),
}

model GetAccountingReportResponseBody = {
  data?: {
    data?: [ string ](name='Data')
  }(name='Data', description='The list serialized in the JSON format. The list contains multiple records.'),
  metrics?: string(name='Metrics', description='The list serialized in the JSON format. The list contains the column names of each record in the Data.', example='[\\"user\\",\\"coreTime\\",\\"usedMem\\"]'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='B1DCB399-9333-4B38-A35A-0BDFABC71881'),
  totalCoreTime?: int32(name='TotalCoreTime', description='The total number of CPU cores in the queried cluster.', example='261300'),
  totalCount?: int32(name='TotalCount', description='The total number of entries.', example='10'),
}

model GetAccountingReportResponse = {
  headers: map[string]string(name='headers'),
  body: GetAccountingReportResponseBody(name='body'),
}

async function getAccountingReport(request: GetAccountingReportRequest): GetAccountingReportResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetAccountingReport', 'GET', '/', 'json', false, 'json', request);
}

model GetAutoScaleConfigRequest {
  clusterId: string(name='ClusterId', example='ehpc-hz-FYUr32****', position='Query'),
}

model GetAutoScaleConfigResponseBody = {
  clusterId?: string(name='ClusterId', example='ehpc-hz-FYUr32****'),
  clusterType?: string(name='ClusterType', example='pbs'),
  computeEnableHt?: boolean(name='ComputeEnableHt', example='true'),
  dnsConfig?: string(name='DnsConfig'),
  enableAutoGrow?: boolean(name='EnableAutoGrow', example='true'),
  enableAutoShrink?: boolean(name='EnableAutoShrink', example='true'),
  excludeNodes?: string(name='ExcludeNodes', example='i-bp19lgqwxb4206t5****,i-bp1g4hvzs9pywrhb****'),
  extraNodesGrowRatio?: int32(name='ExtraNodesGrowRatio', example='2'),
  growIntervalInMinutes?: int32(name='GrowIntervalInMinutes', example='2'),
  growRatio?: int32(name='GrowRatio', example='100'),
  growTimeoutInMinutes?: int32(name='GrowTimeoutInMinutes', example='20'),
  imageId?: string(name='ImageId', example='m-bp10txryr4mhrrt1****'),
  maxNodesInCluster?: int32(name='MaxNodesInCluster', example='300'),
  queues?: {
    queueInfo?: [ 
    {
      dataDisks?: {
        dataDisksInfo?: [ 
        {
          dataDiskCategory?: string(name='DataDiskCategory', example='cloud_efficiency'),
          dataDiskDeleteWithInstance?: boolean(name='DataDiskDeleteWithInstance', example='true'),
          dataDiskEncrypted?: boolean(name='DataDiskEncrypted', example='false'),
          dataDiskKMSKeyId?: string(name='DataDiskKMSKeyId', example='0e478b7a-4262-4802-b8cb-00d3fb40826X'),
          dataDiskPerformanceLevel?: string(name='DataDiskPerformanceLevel', example='PL1'),
          dataDiskSize?: int32(name='DataDiskSize', example='40'),
        }
      ](name='DataDisksInfo')
      }(name='DataDisks'),
      enableAutoGrow?: boolean(name='EnableAutoGrow', example='true'),
      enableAutoShrink?: boolean(name='EnableAutoShrink', example='true'),
      hostNamePrefix?: string(name='HostNamePrefix', example='compute'),
      hostNameSuffix?: string(name='HostNameSuffix', example='000'),
      instanceType?: string(name='InstanceType', example='ecs.sn1ne.large'),
      instanceTypes?: {
        instanceTypeInfo?: [ 
        {
          hostNamePrefix?: string(name='HostNamePrefix', example='compute'),
          instanceType?: string(name='InstanceType', example='ecs.sn1ne.large'),
          spotDuration?: int32(name='SpotDuration', example='0'),
          spotInterruptionBehavior?: string(name='SpotInterruptionBehavior', example='Terminate'),
          spotPriceLimit?: float(name='SpotPriceLimit', example='0.062'),
          spotStrategy?: string(name='SpotStrategy', example='NoSpot'),
          vSwitchId?: string(name='VSwitchId', example='vsw-bp1lfcjbfb099rrjn****'),
          zoneId?: string(name='ZoneId', example='cn-hangzhou-b'),
        }
      ](name='InstanceTypeInfo')
      }(name='InstanceTypes'),
      maxNodesInQueue?: int32(name='MaxNodesInQueue', example='100'),
      maxNodesPerCycle?: long(name='MaxNodesPerCycle', example='20'),
      minNodesInQueue?: int32(name='MinNodesInQueue', example='10'),
      minNodesPerCycle?: long(name='MinNodesPerCycle', example='5'),
      queueImageId?: string(name='QueueImageId', example='centos_7_06_64_20G_alibase_2019071****'),
      queueName?: string(name='QueueName', example='workq'),
      resourceGroupId?: string(name='ResourceGroupId', example='rg-acfmxp7uc24****'),
      sortedByInventory?: boolean(name='SortedByInventory', example='false'),
      spotPriceLimit?: float(name='SpotPriceLimit', example='0.062'),
      spotStrategy?: string(name='SpotStrategy', example='NoSpot'),
      systemDiskCategory?: string(name='SystemDiskCategory', example='cloud_efficiency'),
      systemDiskLevel?: string(name='SystemDiskLevel', example='PL1'),
      systemDiskSize?: int32(name='SystemDiskSize', example='40'),
    }
  ](name='QueueInfo')
  }(name='Queues'),
  requestId?: string(name='RequestId', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
  shrinkIdleTimes?: int32(name='ShrinkIdleTimes', example='3'),
  shrinkIntervalInMinutes?: int32(name='ShrinkIntervalInMinutes', example='2'),
  spotPriceLimit?: float(name='SpotPriceLimit', example='0.062'),
  spotStrategy?: string(name='SpotStrategy', example='SpotWithPriceLimit'),
  uid?: string(name='Uid', example='129845258050****'),
}

model GetAutoScaleConfigResponse = {
  headers: map[string]string(name='headers'),
  body: GetAutoScaleConfigResponseBody(name='body'),
}

async function getAutoScaleConfig(request: GetAutoScaleConfigRequest): GetAutoScaleConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetAutoScaleConfig', 'GET', '/', 'json', false, 'json', request);
}

model GetCloudMetricLogsRequest {
  aggregationInterval?: int32(name='AggregationInterval', description='The data aggregation interval. Unit: seconds.

Valid values: 1, 10, 60, 600, and 3600.

Default value: 1', example='10', position='Query'),
  aggregationType?: string(name='AggregationType', description='The data aggregation type. Valid values:

*   sum: the sum of the data
*   avg: the average value
*   max: the maximum value
*   min: the minimum value

Aggregation is disabled by default.', example='avg', position='Query'),
  clusterId: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-jeJki6****', position='Query'),
  filter?: string(name='Filter', description='The filter conditions. A JSON string consisting of one or more key:value pairs. Value range of key:

*   InstanceId: the ID of the node
*   Hostname: the hostname of the node
*   NetworkInterface: the name of the network interface
*   DiskDevice: the name of the disk', example='{"Hostname":"compute000"}', position='Query'),
  from: int32(name='From', description='The beginning of the time range to query. This value is a UNIX timestamp representing the number of seconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.', example='1583907780', position='Query'),
  metricCategories?: string(name='MetricCategories', description='The category of the output performance metrics. Separate multiple metrics with commas (,). Valid values:

*   cpu
*   memory', example='cpu', position='Query'),
  metricScope?: string(name='MetricScope', description='The dimensions of the performance metric. Valid values:

*   machine
*   process
*   network
*   disk', example='network', position='Query'),
  reverse?: boolean(name='Reverse', description='Logs are returned in reverse order of timestamps.

Default value: false', example='false', position='Query'),
  to: int32(name='To', description='The end of the time range to query. This value is a UNIX timestamp representing the number of seconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.', example='1583907790', position='Query'),
}

model GetCloudMetricLogsResponseBody = {
  metricLogs?: {
    metricLog?: [ 
    {
      diskDevice?: string(name='DiskDevice', description='The name of the disk.', example='vda1'),
      hostname?: string(name='Hostname', description='The hostname of the node.', example='compute000'),
      instanceId?: string(name='InstanceId', description='The ID of the node.', example='i-bp132g97g7zwnvta****'),
      metricData?: string(name='MetricData', description='A JSON-serialized string that contains values for multiple performance metrics.', example='{\\"process|cpusage\\":0,\\"process|cpuser\\":0,\\"process|cpusys\\":0,******}'),
      networkInterface?: string(name='NetworkInterface', description='The name of the network interface.', example='eth1'),
      time?: int32(name='Time', description='The timestamp of the log. This value is a UNIX timestamp representing the number of seconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.', example='1583907780'),
    }
  ](name='MetricLog')
  }(name='MetricLogs', description='The list of the performance data.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='015C2C4D-1884-4EB7-BCD3-C5BB8D7E56DB'),
}

model GetCloudMetricLogsResponse = {
  headers: map[string]string(name='headers'),
  body: GetCloudMetricLogsResponseBody(name='body'),
}

async function getCloudMetricLogs(request: GetCloudMetricLogsRequest): GetCloudMetricLogsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetCloudMetricLogs', 'GET', '/', 'json', false, 'json', request);
}

model GetCloudMetricProfilingRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-jeJki6****', position='Query'),
  profilingId: string(name='ProfilingId', description='The profiling ID. You can call the [ListCloudMetricProfilings](~~188711~~) operation to obtain the profiling ID.', example='ehpc-hz-i-bplukzqgl****_21687_2019-09-09-02-37-40', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou', position='Query'),
}

model GetCloudMetricProfilingResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0DD6F715-85EE-4EA6-BDC4-48A75B719068'),
  svgUrls?: {
    svgInfo?: [ 
    {
      name?: string(name='Name', description='The name of the SVG file that contains the profiling results.', example='ehpc-hz-faRavbPf6b_i-bdrftgyh890654****_21687_2019-09-09-02-37-40.bottomup.svg'),
      size?: int32(name='Size', description='The size of the SVG file. Unit: bytes.', example='648'),
      type?: string(name='Type', description='The type of the SVG file.', example='file'),
      url?: string(name='Url', description='The URL of the Object Storage Service (OSS) bucket where the scalable vector graphics (SVG) file is stored.', example='https://cloudmetrics-****-hz.oss-cn-hangzhou.aliyuncs.com/112****/ehpc-hz-faRavb****njuik%Oxlftyhujmi0Y****'),
    }
  ](name='SvgInfo')
  }(name='SvgUrls', description='The list of profiling results.'),
}

model GetCloudMetricProfilingResponse = {
  headers: map[string]string(name='headers'),
  body: GetCloudMetricProfilingResponseBody(name='body'),
}

async function getCloudMetricProfiling(request: GetCloudMetricProfilingRequest): GetCloudMetricProfilingResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetCloudMetricProfiling', 'GET', '/', 'json', false, 'json', request);
}

model GetClusterVolumesRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-gh5WKb****', position='Query'),
}

model GetClusterVolumesResponseBody = {
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='8BCFD52E-0336-4490-AE7D-F560F106****'),
  volumes?: {
    volumeInfo?: [ 
    {
      jobQueue?: string(name='JobQueue', description='The queue of the job.', example='workq'),
      localDirectory?: string(name='LocalDirectory', description='The local mount directory.', example='/ehpcdata'),
      location?: string(name='Location', description='The type of cluster. Valid values:

*   OnPremise: The cluster is deployed on a hybrid cloud.
*   PublicCloud: The cluster is deployed on a public cloud.', example='PublicCloud'),
      mustKeep?: boolean(name='MustKeep', description='Indicates whether the resource can be unmounted.', example='true'),
      remoteDirectory?: string(name='RemoteDirectory', description='The remote mount directory.', example='/test'),
      roles?: {
        roleInfo?: [ 
        {
          name?: string(name='Name', description='The type of the node on which the file system is mounted. Valid values:

*   Compute: compute node
*   Manager: management node
*   Login: logon node', example='Compute'),
        }
      ](name='RoleInfo')
      }(name='Roles', description='The array of the node on which the file system is mounted.'),
      volumeId?: string(name='VolumeId', description='The ID of the file system.', example='0e754****'),
      volumeMountpoint?: string(name='VolumeMountpoint', description='The address of the mount target.', example='0e754****-kal90.cn-hangzhou.nas.aliyuncs.com<'),
      volumeProtocol?: string(name='VolumeProtocol', description='The storage protocol type of the file system. Valid values:

*   NFS
*   SMB', example='NFS'),
      volumeType?: string(name='VolumeType', description='The type of the file system. Valid values:

*   NAS', example='NAS'),
    }
  ](name='VolumeInfo')
  }(name='Volumes', description='The array of the file system mounted to the E-HPC cluster.'),
}

model GetClusterVolumesResponse = {
  headers: map[string]string(name='headers'),
  body: GetClusterVolumesResponseBody(name='body'),
}

async function getClusterVolumes(request: GetClusterVolumesRequest): GetClusterVolumesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetClusterVolumes', 'GET', '/', 'json', false, 'json', request);
}

model GetCommonImageRequest {
  clusterId?: string(name='ClusterId', example='ehpc-hz-FYUr32****', position='Query'),
  containType?: string(name='ContainType', example='singularity', position='Query'),
  imageName?: string(name='ImageName', example='tensorflow-21.09-tf1-py3.sif', position='Query'),
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Query'),
}

model GetCommonImageResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request', example='1DB7684F-4F93-5314-8D3F-F28EE0788E9E'),
}

model GetCommonImageResponse = {
  headers: map[string]string(name='headers'),
  body: GetCommonImageResponseBody(name='body'),
}

async function getCommonImage(request: GetCommonImageRequest): GetCommonImageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetCommonImage', 'GET', '/', 'json', false, 'json', request);
}

model GetGWSConnectTicketRequest {
  appName?: string(name='AppName', example='app-****', position='Query'),
  instanceId: string(name='InstanceId', example='i-bp1ch35z696b6b26****', position='Query'),
}

model GetGWSConnectTicketResponseBody = {
  requestId?: string(name='RequestId', example='5198C3E8-85F5-4280-8547-687C1710FE08'),
  ticket?: string(name='Ticket', example='W0VuY29kaG9ydFJlY29ubmVjdEVuY****'),
}

model GetGWSConnectTicketResponse = {
  headers: map[string]string(name='headers'),
  body: GetGWSConnectTicketResponseBody(name='body'),
}

async function getGWSConnectTicket(request: GetGWSConnectTicketRequest): GetGWSConnectTicketResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetGWSConnectTicket', 'GET', '/', 'json', false, 'json', request);
}

model GetHybridClusterConfigRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-FYUr32****', position='Query'),
  node?: string(name='Node', description='The name of the on-premises compute node. You can call this operation to query the configurations of the on-premises compute node.

By default, the operation queries the configurations of a cluster.', example='testNode', position='Query'),
}

model GetHybridClusterConfigResponseBody = {
  clusterConfig?: string(name='ClusterConfig', description='The configurations returned.

*   If the parameter Node is null, you can obtain the configurations of the hybrid cloud cluster.
*   If the parameter Node is a specified on-premises compute node, you can obtain the configurations of the on-premises compute node.

This parameter is returned in the ini format. You can use this parameter to configure on-premises cluster nodes.', example='ClNjaGcyI6W119Cg****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model GetHybridClusterConfigResponse = {
  headers: map[string]string(name='headers'),
  body: GetHybridClusterConfigResponseBody(name='body'),
}

async function getHybridClusterConfig(request: GetHybridClusterConfigRequest): GetHybridClusterConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetHybridClusterConfig', 'GET', '/', 'json', false, 'json', request);
}

model GetIfEcsTypeSupportHtConfigRequest {
  instanceType: string(name='InstanceType', description='The instance type of the ECS instance.', example='ecs.g6.large', position='Query'),
}

model GetIfEcsTypeSupportHtConfigResponseBody = {
  defaultHtEnabled?: boolean(name='DefaultHtEnabled', description='Indicates whether Hyper-Threading is enabled by default. Valid values:

*   true: Hyper-Threading is enabled by default.

*   false: Hyper-Threading is disabled by default

> By default, Hyper-Threading is not enabled for the SCC specification family, while Hyper-Threading is enabled for other specification families by default.', example='true'),
  instanceType?: string(name='InstanceType', description='The instance type of the ECS instance.', example='ecs.g6.large'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='80CA7A93-7291-4402-B63D-86DF334E0A1F'),
  supportHtConfig?: boolean(name='SupportHtConfig', description='Indicates whether hyper-threading is supported. Valid values:

*   true: Hyper-Threading is supported.
*   false: Hyper-Threading is not supported.', example='true'),
}

model GetIfEcsTypeSupportHtConfigResponse = {
  headers: map[string]string(name='headers'),
  body: GetIfEcsTypeSupportHtConfigResponseBody(name='body'),
}

async function getIfEcsTypeSupportHtConfig(request: GetIfEcsTypeSupportHtConfigRequest): GetIfEcsTypeSupportHtConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetIfEcsTypeSupportHtConfig', 'GET', '/', 'json', false, 'json', request);
}

model GetJobLogRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-jeJki6****', position='Query'),
  execHost?: string(name='ExecHost', description='The node on which the job runs.

*   If the job is completed, you do not need to specify the parameter.
*   If the job is running, you must specify the parameter.', example='compute000', position='Query'),
  jobId: string(name='JobId', description='The ID of the job.', example='1.scheduler****', position='Query'),
  offset?: long(name='Offset', description='The position where logs start to be read.

Unit: bits

Default value: 0', example='0', position='Query'),
  size?: int32(name='Size', description='The maximum size of logs that you can read in a single request.

Unit: bits

Default value: 1024', example='1024', position='Query'),
}

model GetJobLogResponseBody = {
  errorLog?: string(name='ErrorLog', description='The content of the error logs. The content is encoded in Base64.', example='c2xlZXAgMzA='),
  jobId?: string(name='JobId', description='The ID of the job.', example='1.scheduler****'),
  outputLog?: string(name='OutputLog', description='The content of the output logs. The content is encoded in Base64.', example='c2xlZXAgMzA='),
  requestId?: string(name='RequestId', description='The ID of the task.', example='B745C159-3155-4B94-95D0-4B73D4D2****'),
}

model GetJobLogResponse = {
  headers: map[string]string(name='headers'),
  body: GetJobLogResponseBody(name='body'),
}

async function getJobLog(request: GetJobLogRequest): GetJobLogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetJobLog', 'GET', '/', 'json', false, 'json', request);
}

model GetPostScriptsRequest {
  clusterId: string(name='ClusterId', description='The URL that is used to download the Nth post-installation script. Valid values of N: 1 to 16.', example='ehpc-sh-EnjshUxn', position='Query'),
  regionId: string(name='RegionId', description='The parameter that is used to run the Nth post-installation script. Valid values of N: 1 to 16.', example='cn-shanghai', position='Query'),
}

model GetPostScriptsResponseBody = {
  postInstallScripts?: [ 
    {
      args?: string(name='Args', example='-h'),
      url?: string(name='Url', example='https://bucket.oss-cn-shanghai.aliyuncs.com/postscript_examples.sh'),
    }
  ](name='PostInstallScripts'),
  requestId?: string(name='RequestId', example='B745C159-3155-4B94-95D0-4B73D4D2****'),
}

model GetPostScriptsResponse = {
  headers: map[string]string(name='headers'),
  body: GetPostScriptsResponseBody(name='body'),
}

async function getPostScripts(request: GetPostScriptsRequest): GetPostScriptsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetPostScripts', 'GET', '/', 'json', false, 'json', request);
}

model GetSchedulerInfoRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-FYUr32****', position='Query'),
  regionId: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou', position='Query'),
  scheduler: [ 
    {
      schedName?: string(name='SchedName', description='The name of the scheduler. Valid values:

*   pbs
*   pbs19
*   slurm
*   slurm19
*   slurm20

Valid values of N: 0 to 100', example='pbs'),
    }
  ](name='Scheduler', position='Query'),
}

model GetSchedulerInfoResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='BBC2F93D-003A-49C4-850C-B826EECF****'),
  schedInfo?: [ 
    {
      configuration?: string(name='Configuration', description='The detailed settings of the scheduler.', example='{ 				"AclInfo": [ 					{ 						"AclEnable": false, 						"UntrackUser": [], 						"User": [], 						"QueueName": "workq" 					} 				], 				"JobHistory": "", 				"SchedIteration": "60", 				"QueueResource": [ 					{ 						"UntrackUser": [], 						"User": [], 						"QueueName": "workq" 					} 				] 			}'),
      schedName?: string(name='SchedName', description='The type of the scheduler.', example='pbs'),
    }
  ](name='SchedInfo', description='The settings of the scheduler.'),
}

model GetSchedulerInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetSchedulerInfoResponseBody(name='body'),
}

async function getSchedulerInfo(request: GetSchedulerInfoRequest): GetSchedulerInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetSchedulerInfo', 'GET', '/', 'json', false, 'json', request);
}

model GetUserImageRequest {
  regionId: string(name='RegionId', position='Host'),
  clusterId: string(name='ClusterId', description='The cluster ID.', example='ehpc-hz-ibug69*****', position='Query'),
  containerType: string(name='ContainerType', description='The type of the image. Set the value to singularity.', example='singularity', position='Query'),
  imageName: string(name='ImageName', description='The image name.', example='test.sif', position='Query'),
  imagePath: string(name='ImagePath', description='The path where the image is stored in the OSS bucket.', example='testUserImages', position='Query'),
  OSSBucket: string(name='OSSBucket', description='The OSS bucket.', example='XXXXXXX', position='Query'),
  OSSEndPoint: string(name='OSSEndPoint', description='The OSS endpoint.', example='vpc***-oss-cn-hangzhou.aliyuncs.com', position='Query'),
}

model GetUserImageResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='C84FB8EF-5580-4B82-9BDE-6657814C****'),
}

model GetUserImageResponse = {
  headers: map[string]string(name='headers'),
  body: GetUserImageResponseBody(name='body'),
}

async function getUserImage(request: GetUserImageRequest): GetUserImageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetUserImage', 'GET', '/', 'json', false, 'json', request);
}

model GetVisualServiceStatusRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-jeJki6****', position='Query'),
}

model GetVisualServiceStatusResponseBody = {
  message?: string(name='Message', description='The response message.', example='inactive (dead) , ws service is not running.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='896D338C-E4F4-41EC-A154-D605E5DE****'),
}

model GetVisualServiceStatusResponse = {
  headers: map[string]string(name='headers'),
  body: GetVisualServiceStatusResponseBody(name='body'),
}

async function getVisualServiceStatus(request: GetVisualServiceStatusRequest): GetVisualServiceStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetVisualServiceStatus', 'GET', '/', 'json', false, 'json', request);
}

model InitializeEHPCRequest {
  regionId?: string(name='RegionId', description='The ID of the region where the service-linked role is created.

You can call the [ListRegions](~~188593~~) operation to obtain the IDs of regions supported by E-HPC.', example='cn-hangzhou', position='Query'),
}

model InitializeEHPCResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model InitializeEHPCResponse = {
  headers: map[string]string(name='headers'),
  body: InitializeEHPCResponseBody(name='body'),
}

async function initializeEHPC(request: InitializeEHPCRequest): InitializeEHPCResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'InitializeEHPC', 'GET', '/', 'json', false, 'json', request);
}

model InspectImageRequest {
  regionId?: string(name='RegionId', position='Host'),
  clusterId?: string(name='ClusterId', description='The ID of the E-HPC cluster where the image whose Inspect information you want to view resides.', example='ehpc-hz-ibug699***', position='Query'),
  containerType?: string(name='ContainerType', description='The container type of the image. Set the value to singularity.', example='singularity', position='Query'),
  imageName?: string(name='ImageName', description='The name of the image whose Inspect information you want to view.', example='test.sif', position='Query'),
}

model InspectImageResponseBody = {
  imageStatus?: {
    imageInspectInfo?: {
      bootStrap?: string(name='BootStrap', description='The version of the bootstrapper used by the container image.', example='1.0'),
      buildArch?: string(name='BuildArch', description='The architecture used to build the image.', example='amd64'),
      buildDate?: string(name='BuildDate', description='The date on which the image was built.', example='Tuesday_9_November_2021_19'),
      containerVersion?: string(name='ContainerVersion', description='The container version of the image.', example='sccIntelMPI.sif'),
      defFrom?: string(name='DefFrom', description='The mode in which the image was built.', example='localimage'),
      schemaVersion?: string(name='SchemaVersion', description='The singularity version and kernel version of the image.', example='3.8.3-1.el7'),
    }(name='ImageInspectInfo', description='The list of Inspect information about the image.'),
  }(name='ImageStatus', description='The status of the image.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='896D338C-E4F4-41EC-A154-D605E5DE****'),
}

model InspectImageResponse = {
  headers: map[string]string(name='headers'),
  body: InspectImageResponseBody(name='body'),
}

async function inspectImage(request: InspectImageRequest): InspectImageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'InspectImage', 'GET', '/', 'json', false, 'json', request);
}

model InstallSoftwareRequest {
  application: string(name='Application', description='The name of the software that you want to install.

You can call the [ListSoftwares](~~87216~~) operation to query the software that can be installed.', example='ABYSS_2.1.5', position='Query'),
  clusterId: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-jeJki6****', position='Query'),
}

model InstallSoftwareResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='896D338C-E4F4-41EC-A154-D605E5DE****'),
}

model InstallSoftwareResponse = {
  headers: map[string]string(name='headers'),
  body: InstallSoftwareResponseBody(name='body'),
}

async function installSoftware(request: InstallSoftwareRequest): InstallSoftwareResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'InstallSoftware', 'GET', '/', 'json', false, 'json', request);
}

model InvokeShellCommandRequest {
  clusterId: string(name='ClusterId', description='The cluster ID.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****', position='Query'),
  command: string(name='Command', description='The content of the command. The content must be 2 to 2,048 characters in length.', example='echo "hello world"', position='Query'),
  instance?: [ 
    {
      id?: string(name='Id', description='The ID of the Nth node instance on which the command is run.

> This parameter specifies the node on which the command is run. If it is not specified, the command will be run on all nodes of the cluster.', example='i-bp1in9hmw3ur52x0****'),
    }
  ](name='Instance', description='The information of nodes on which the command is run.', position='Query'),
  timeout?: int32(name='Timeout', description='The timeout period. If a command times out, the command process will be terminated. Unit: seconds.

Default value: 60.', example='3600', position='Query'),
  workingDir?: string(name='WorkingDir', description='The working directory of the command. Default value: `/root`.', example='/home', position='Query'),
}

model InvokeShellCommandResponseBody = {
  commandId?: string(name='CommandId', description='The ID of the command. It is used to query the execution status of the command.', example='c-hz01v8vudql****'),
  instanceIds?: {
    instanceId?: [ string ](name='InstanceId')
  }(name='InstanceIds'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model InvokeShellCommandResponse = {
  headers: map[string]string(name='headers'),
  body: InvokeShellCommandResponseBody(name='body'),
}

async function invokeShellCommand(request: InvokeShellCommandRequest): InvokeShellCommandResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'InvokeShellCommand', 'GET', '/', 'json', false, 'json', request);
}

model ListAvailableEcsTypesRequest {
  instanceChargeType?: string(name='InstanceChargeType', description='The billing method of the ECS instances. Valid values:

*   PostPaid: pay-as-you-go
*   PrePaid: subscription', example='PostPaid', position='Query'),
  showSoldOut?: boolean(name='ShowSoldOut', description='Specifies whether the ECS instances are sold out. Valid values:

*   false: available
*   true: sold out

Default value: false.', example='false', position='Query'),
  spotStrategy?: string(name='SpotStrategy', description='The preemption policy of the ECS instances. Valid values:

*   NoSpot: The ECS instances are pay-as-you-go instances.
*   SpotWithPriceLimit: The ECS instances are preemptible instances that have a user-defined maximum hourly price.
*   SpotAsPriceGo: The compute nodes are preemptible instances for which the market price at the time of purchase is used as the bid price.', example='NoSpot', position='Query'),
  zoneId?: string(name='ZoneId', description='The zone ID.', example='cn-hangzhou-b', position='Query'),
}

model ListAvailableEcsTypesResponseBody = {
  instanceTypeFamilies?: {
    instanceTypeFamilyInfo?: [ 
    {
      generation?: string(name='Generation', description='The instance family.', example='ecs-3'),
      instanceTypeFamilyId?: string(name='InstanceTypeFamilyId', description='The ID of the instance family. For more information, see [Instance families](~~25378~~).', example='ecs.n4'),
      types?: {
        typesInfo?: [ 
        {
          cpuCoreCount?: int32(name='CpuCoreCount', description='The number of vCPUs.', example='4'),
          eniQuantity?: int32(name='EniQuantity', description='The maximum number of elastic network interfaces (ENIs) that can be bound to an ECS instance.', example='2'),
          GPUAmount?: int32(name='GPUAmount', description='The number of GPUs of an ECS instance.', example='2'),
          GPUSpec?: string(name='GPUSpec', description='The GPU type of the ECS instance.', example='NVIDIA V100'),
          instanceBandwidthRx?: int32(name='InstanceBandwidthRx', description='The maximum inbound internal bandwidth. Unit: Kbit/s.', example='10240000'),
          instanceBandwidthTx?: int32(name='InstanceBandwidthTx', description='The maximum outbound internal bandwidth. Unit: Kbit/s.', example='10240000'),
          instancePpsRx?: int32(name='InstancePpsRx', description='The inbound packet forwarding rate over the internal network. Unit: pps.', example='9000000'),
          instancePpsTx?: int32(name='InstancePpsTx', description='The outbound packet forwarding rate over the internal network. Unit: pps.', example='9000000'),
          instanceTypeId?: string(name='InstanceTypeId', description='The ID of the ECS instance type.', example='ecs.n4.xlarge'),
          memorySize?: int32(name='MemorySize', description='The memory size of the ECS instance. Unit: GiB.', example='8'),
          status?: string(name='Status', description='The status of the ECS instance. Valid values:

*   SoldOut
*   Available', example='Available'),
          zoneIds?: {
            zoneId?: [ string ](name='ZoneId')
          }(name='ZoneIds', description='The list of zone IDs.'),
        }
      ](name='TypesInfo')
      }(name='Types', description='The list of instance types.'),
    }
  ](name='InstanceTypeFamilyInfo')
  }(name='InstanceTypeFamilies', description='The instance family to which the instance type belongs.'),
  requestId?: string(name='RequestId', description='The request ID.', example='D9DD3AF8-1F91-4075-8669-55D10E45****'),
  supportSpotInstance?: boolean(name='SupportSpotInstance', description='Specifies whether preemptible instances are supported. Valid values:

*   false: not supported
*   true: supported', example='false'),
}

model ListAvailableEcsTypesResponse = {
  headers: map[string]string(name='headers'),
  body: ListAvailableEcsTypesResponseBody(name='body'),
}

async function listAvailableEcsTypes(request: ListAvailableEcsTypesRequest): ListAvailableEcsTypesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListAvailableEcsTypes', 'GET', '/', 'json', false, 'json', request);
}

model ListCloudMetricProfilingsRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-FYUr32****', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number of the page to return.

Pages start from page 1.

Default value: 1', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 50

Default value: 10', example='10', maximum=50, position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou', position='Query'),
}

model ListCloudMetricProfilingsResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries that are returned per page.', example='1'),
  profilings?: {
    profilingInfo?: [ 
    {
      duration?: int32(name='Duration', description='The duration of the profiling process. Unit: seconds

Valid values: 10 to 300', example='30'),
      freq?: int32(name='Freq', description='The frequency of the profiling process. Unit: Hz

Valid values: 1 to 2000', example='2000'),
      hostName?: string(name='HostName', description='The name of the host.', example='compute5'),
      instanceId?: string(name='InstanceId', description='The ID of the node.', example='i-bp1j76z8dlukzqgl0****'),
      pid?: int32(name='Pid', description='The ID of the profiling process.', example='21687'),
      profilingId?: string(name='ProfilingId', description='The ID of the profiling process.', example='ehpc-hz-i-bplukzqgl****_21687_2019-09-09-02-37-40'),
      triggerTime?: string(name='TriggerTime', description='The time when the profiling process is triggered.', example='2019-09-09 02:37:40'),
    }
  ](name='ProfilingInfo')
  }(name='Profilings', description='The profiling information of a specified cluster.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='9A05F620-ED46-4A57-95F1-C67D6D3C5DD2'),
  totalCount?: int32(name='TotalCount', description='The total number of entries.', example='1'),
}

model ListCloudMetricProfilingsResponse = {
  headers: map[string]string(name='headers'),
  body: ListCloudMetricProfilingsResponseBody(name='body'),
}

async function listCloudMetricProfilings(request: ListCloudMetricProfilingsRequest): ListCloudMetricProfilingsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListCloudMetricProfilings', 'GET', '/', 'json', false, 'json', request);
}

model ListClusterLogsRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-FYUr32****', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page 1.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 100

Default: 10', example='10', maximum=100, position='Query'),
}

model ListClusterLogsResponseBody = {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-FYUr32****'),
  logs?: {
    logInfo?: [ 
    {
      createTime?: string(name='CreateTime', description='The time when the log was created.', example='2019-09-18T13:24:13.000'),
      level?: string(name='Level', description='The severity level of the log entry.', example='info'),
      message?: string(name='Message', description='The content of the log entry.', example='Begin to create cluster'),
      operation?: string(name='Operation', description='The name of the operation.', example='CreateCluster'),
    }
  ](name='LogInfo')
  }(name='Logs', description='The details about operations logs.'),
  pageNumber?: int32(name='PageNumber', description='The number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries that are returned per page.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='BBC2F93D-003A-49C4-850C-B826EECF6667'),
  totalCount?: int32(name='TotalCount', description='The total number of entries.', example='2'),
}

model ListClusterLogsResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterLogsResponseBody(name='body'),
}

async function listClusterLogs(request: ListClusterLogsRequest): ListClusterLogsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListClusterLogs', 'GET', '/', 'json', false, 'json', request);
}

model ListClustersRequest {
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page 1.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 50.

Default value: 10', example='10', maximum=50, position='Query'),
}

model ListClustersResponseBody = {
  clusters?: {
    clusterInfoSimple?: [ 
    {
      accountType?: string(name='AccountType', description='The server type of the account. Valid values:

*   nis
*   ldap', example='nis'),
      baseOsTag?: string(name='BaseOsTag', description='The operating system tag of the base image. The tag was used only by the management node.', example='CentOS_7.2_64'),
      clientVersion?: string(name='ClientVersion', description='The version of the client.', example='1.0.64'),
      computeSpotPriceLimit?: float(name='ComputeSpotPriceLimit', description='The maximum hourly price for the ECS instance under the compute node. The return value can be accurate to three decimal places.', example='0.034'),
      computeSpotStrategy?: string(name='ComputeSpotStrategy', description='The bidding method of the compute nodes. Valid values:

*   NoSpot: The instances of the compute node are pay-as-you-go instances.
*   SpotWithPriceLimit: The instances of the compute node are preemptible instances. These types of instances have a specified maximum hourly price.
*   SpotAsPriceGo: The instances of the compute node are preemptible instances. The price of these instances is based on the current market price.', example='NoSpot'),
      computes?: {
        exceptionCount?: int32(name='ExceptionCount', description='The number of abnormal nodes.', example='0'),
        normalCount?: int32(name='NormalCount', description='The number of normal nodes.', example='1'),
        operatingCount?: int32(name='OperatingCount', description='The number of nodes that are being used in the queue. This includes those that are being initialized, installed, or released.', example='1'),
        stoppedCount?: int32(name='StoppedCount', description='The number of stopped nodes.', example='0'),
        total?: int32(name='Total', description='The total number of nodes.', example='2'),
      }(name='Computes', description='The information about compute nodes.'),
      count?: int32(name='Count', description='The number of compute nodes in the cluster.', example='3'),
      createTime?: string(name='CreateTime', description='The time when the instance was created.', example='2020-10-30T07:39:20.000Z'),
      deployMode?: string(name='DeployMode', description='The mode in which the cluster was deployed. Valid values:

*   Standard: An account node, a scheduling node, a logon node, and multiple compute nodes are separately deployed.
*   Advanced: Two high availability (HA) account nodes, two HA scheduler nodes, one logon node, and multiple compute nodes are separately deployed.
*   Simple: A management node, a logon node, and multiple compute nodes are deployed. The management node consists of an account node and a scheduling node. The logon node and compute nodes are separately deployed.
*   Tiny: A management node and multiple compute nodes are deployed. The management node consists of an account node, a scheduling node, and a logon node. The compute nodes are separately deployed.', example='Standard'),
      description?: string(name='Description', description='The description of the cluster.', example='clusterdescription'),
      ehpcVersion?: string(name='EhpcVersion', description='The version of E-HPC.', example='1.0.0'),
      hasPlugin?: boolean(name='HasPlugin', description='Indicates whether plug-ins were used in the cluster. Valid values:

*   true: Plug-ins are used.
*   false: Plug-ins are not used.

Default value: false', example='false'),
      id?: string(name='Id', description='The ID of the cluster.', example='ehpc-hz-jeJki6****'),
      imageId?: string(name='ImageId', description='The ID of the image.', example='wi_1607_x64_dtc_zh_40G_alibase****'),
      imageOwnerAlias?: string(name='ImageOwnerAlias', description='The type of the image. Valid values:

*   system: public image
*   self: custom image
*   others: shared image
*   marketplace: Alibaba Cloud Marketplace image', example='system'),
      instanceChargeType?: string(name='InstanceChargeType', description='The billing method of the nodes in the cluster. Valid values:

*   PostPaid: pay-as-you-go
*   PrePaid: subscription', example='PostPaid'),
      instanceType?: string(name='InstanceType', description='The instance type of the compute nodes.', example='ecs.n1.tiny'),
      isComputeEss?: boolean(name='IsComputeEss', description='Indicates whether a scaling group was enabled. Valid values:

*   true: A scaling group is enabled.
*   false: No scaling group is enabled.', example='false'),
      location?: string(name='Location', description='The location where the cluster was deployed. Valid values:

*   OnPremise: The cluster is deployed on a hybrid cloud.
*   PublicCloud: The cluster is deployed on a public cloud.', example='PublicCloud'),
      loginNodes?: string(name='LoginNodes', description='The list of logon nodes.', example='{"Id": "i-bp13x4is8pvdhws7e****"}'),
      managers?: {
        exceptionCount?: int32(name='ExceptionCount', description='The number of abnormal nodes.', example='0'),
        normalCount?: int32(name='NormalCount', description='The number of normal nodes.', example='1'),
        operatingCount?: int32(name='OperatingCount', description='The number of nodes that are being used in the queue. This includes those that are being initialized, installed, or released.', example='1'),
        stoppedCount?: int32(name='StoppedCount', description='The number of stopped nodes.', example='0'),
        total?: int32(name='Total', description='The total number of management nodes.', example='2'),
      }(name='Managers', description='The list of management nodes.'),
      name?: string(name='Name', description='The name of the cluster.', example='test'),
      nodePrefix?: string(name='NodePrefix', description='The prefix of the node.', example='test'),
      nodeSuffix?: string(name='NodeSuffix', description='The suffix of the node.', example='name'),
      osTag?: string(name='OsTag', description='The operating system tag of the image.', example='CentOS_7.2_64'),
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
      resourceGroupId?: string(name='ResourceGroupId', example='rg-acfmxazb4ph****'),
      schedulerType?: string(name='SchedulerType', description='The type of the scheduler. Valid values:

*   pbs
*   slurm
*   opengridscheduler
*   deadline', example='pbs'),
      status?: string(name='Status', description='The status of the cluster. Valid values:

*   uninit: The cluster is not initialized.
*   creating: The cluster is being created.
*   init: The cluster is being initialized.
*   running: The cluster is running.
*   exception: The cluster encounters an exception.
*   releasing: The cluster is being released.', example='running'),
      totalResources?: {
        cpu?: int32(name='Cpu', description='The number of CPU cores. Unit: cores.', example='1'),
        gpu?: int32(name='Gpu', description='The number of GPU cards. Unit: cards.', example='0'),
        memory?: int32(name='Memory', description='The memory size. Unit: MiB.', example='1024'),
      }(name='TotalResources', description='The statistics of all resources in the cluster.'),
      usedResources?: {
        cpu?: int32(name='Cpu', description='The number of CPU cores. Unit: cores.', example='1'),
        gpu?: int32(name='Gpu', description='The number of GPU cards. Unit: cards.', example='0'),
        memory?: int32(name='Memory', description='The memory size. Unit: MiB.', example='1024'),
      }(name='UsedResources', description='The number of consumed resources in the cluster.'),
      vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch.', example='vsw-bp1lfcjbfb099rrjn****'),
      vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC).', example='vpc-b3f3edefefeep0760yju****'),
      zoneId?: string(name='ZoneId', description='The ID of the zone.', example='cn-hangzhou-c'),
    }
  ](name='ClusterInfoSimple')
  }(name='Clusters', description='The list of clusters.'),
  pageNumber?: int32(name='PageNumber', description='The number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
  totalCount?: int32(name='TotalCount', description='The total number of returned entries.', example='1'),
}

model ListClustersResponse = {
  headers: map[string]string(name='headers'),
  body: ListClustersResponseBody(name='body'),
}

async function listClusters(request: ListClustersRequest): ListClustersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListClusters', 'GET', '/', 'json', false, 'json', request);
}

model ListClustersMetaRequest {
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page 1.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 50.

Default value: 10', example='10', maximum=100, position='Query'),
}

model ListClustersMetaResponseBody = {
  clusters?: {
    clusterInfoSimple?: [ 
    {
      accountType?: string(name='AccountType', description='The server type of the account. Valid values:

*   nis
*   ldap', example='nis'),
      clientVersion?: string(name='ClientVersion', description='The version of the client.', example='1.0.64'),
      deployMode?: string(name='DeployMode', description='The mode in which the cluster is deployed. Valid values:

*   Standard: An account node, a scheduling node, a logon node, and multiple compute nodes are separately deployed.
*   Advanced: Two high availability (HA) account nodes, two HA scheduler nodes, one logon node, and multiple compute nodes are separately deployed.
*   Simple: A management node, a logon node, and multiple compute nodes are deployed. The management node consists of an account node and a scheduling node. The logon node and compute nodes are separately deployed.
*   Tiny: A management node and multiple compute nodes are deployed. The management node consists of an account node, a scheduling node, and a logon node. The compute nodes are separately deployed.', example='Standard'),
      description?: string(name='Description', description='The description of the cluster.', example='clusterdescription'),
      hasPlugin?: boolean(name='HasPlugin', description='Indicates whether the cluster uses a plug-in. Valid values:

*   true
*   false

Default value: false', example='false'),
      id?: string(name='Id', description='The ID of the cluster.', example='ehpc-hz-jeJki6****'),
      isComputeEss?: boolean(name='IsComputeEss', description='Indicates whether a scaling group is enabled. Valid values:

*   true: A scaling group is enabled.
*   false: No scaling group is enabled.', example='false'),
      location?: string(name='Location', description='The location where the cluster is deployed. Valid values:

*   OnPremise: The cluster is deployed on a hybrid cloud.
*   PublicCloud: The cluster is deployed on a public cloud.', example='PublicCloud'),
      name?: string(name='Name', description='The name of the cluster.', example='cluster1'),
      osTag?: string(name='OsTag', description='The image tag of the operating system.', example='CentOS_7.2_64'),
      schedulerType?: string(name='SchedulerType', description='The type of the scheduler. Valid values:

*   pbs
*   slurm
*   opengridscheduler
*   deadline', example='pbs'),
      status?: string(name='Status', description='The status of the cluster. Valid values:

*   uninit: The cluster is not initialized.
*   creating: The cluster is being created.
*   init: The cluster is being initialized.
*   running: The cluster is running.
*   exception: The cluster encounters an exception.
*   releasing: The cluster is being released.', example='running'),
      vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC).', example='vpc-b3f3edefefeep0760yju****'),
    }
  ](name='ClusterInfoSimple')
  }(name='Clusters', description='The list of clusters.'),
  pageNumber?: int32(name='PageNumber', description='The number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page. Valid values: 1 to 50.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='DD517102-B314-4665-BDAC-A32DE7834D02'),
  totalCount?: int32(name='TotalCount', description='The total number of returned entries.', example='1'),
}

model ListClustersMetaResponse = {
  headers: map[string]string(name='headers'),
  body: ListClustersMetaResponseBody(name='body'),
}

async function listClustersMeta(request: ListClustersMetaRequest): ListClustersMetaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListClustersMeta', 'GET', '/', 'json', false, 'json', request);
}

model ListCommandsRequest {
  clusterId: string(name='ClusterId', description='The cluster ID.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****', position='Query'),
  commandId?: string(name='CommandId', description='The ID of the command.', example='c-hz01v8vudql****', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number of the page to return.

Page number starts from page 1.

Default value: 1.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.\\
Valid values: 1 to 50.\\
Default value: 10.', example='10', maximum=50, position='Query'),
}

model ListCommandsResponseBody = {
  commands?: {
    command?: [ 
    {
      commandContent?: string(name='CommandContent', description='The content of the command.', example='echo "hello world"'),
      commandId?: string(name='CommandId', description='The ID of the command.', example='c-hz01v8vudql****'),
      timeout?: string(name='Timeout', description='The timeout period. Unit: seconds.', example='60'),
      workingDir?: string(name='WorkingDir', description='The working directory of the command.', example='/home'),
    }
  ](name='Command')
  }(name='Commands', description='The list of commands.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  totalCount?: int32(name='TotalCount', description='The total number of returned entries.', example='1'),
}

model ListCommandsResponse = {
  headers: map[string]string(name='headers'),
  body: ListCommandsResponseBody(name='body'),
}

async function listCommands(request: ListCommandsRequest): ListCommandsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListCommands', 'GET', '/', 'json', false, 'json', request);
}

model ListCommunityImagesRequest {
  baseOsTag?: string(name='BaseOsTag', description='The tag of the base operating system (BOS).', example='CentOS_7.2_64', position='Query'),
  clusterId?: string(name='ClusterId', description='The ID of the cluster. If the cluster supports multiple operating systems, all community images in the region where the cluster resides are queried.

If you do not specify the cluster ID, the community images that are supported by all clusters are queried.', example='ehpc-hz-FYUr32****', position='Query'),
  instanceType?: string(name='InstanceType', description='The type of the Elastic Compute Service (ECS) instance. If you do not specify the instance type, the community images that are supported by all instance types are queried.', example='ecs.n1.tiny', position='Query'),
}

model ListCommunityImagesResponseBody = {
  images?: {
    imageInfo?: [ 
    {
      baseOsTag?: {
        architecture?: string(name='Architecture', description='The architecture of the operating system. Valid values:

*   i386
*   x86\\_64', example='x86_64'),
        osTag?: string(name='OsTag', description='The tag of the OS image.', example='CentOS_7.2_64'),
        platform?: string(name='Platform', description='The distribution of the operating system. Valid values:

*   CentOS
*   Ubuntu
*   SUSE
*   OpenSUSE
*   Debian
*   CoreOS
*   Aliyun
*   Windows Server 2003
*   Windows Server 2008
*   Windows Server 2012
*   Others Linux
*   Customized Linux', example='CentOS'),
        version?: string(name='Version', description='The version of the operating system.', example='7.2'),
      }(name='BaseOsTag', description='The tag of the BOS image.'),
      description?: string(name='Description', description='The description of the image.', example='ExampleDescription'),
      imageId?: string(name='ImageId', description='The ID of the image.', example='m-bp181x855551ww5yq****'),
      imageName?: string(name='ImageName', description='The name of the image.', example='linux_CentOS7.2_OceanBase_OBD_1ECS-3OB_3.0'),
      imageOwnerAlias?: string(name='ImageOwnerAlias', description='The type of the image. Valid values:

*   self: custom image
*   others: shared image', example='self'),
      osTag?: {
        architecture?: string(name='Architecture', description='The architecture of the operating system. Valid values:

*   i386
*   x86\\_64', example='x86_64'),
        baseOsTag?: string(name='BaseOsTag', description='The tag of the BOS image.', example='CentOS_7.2_64'),
        osTag?: string(name='OsTag', description='The tag of the OS image.', example='CentOS_7.2_64'),
        platform?: string(name='Platform', description='The operating system.', example='CentOS'),
        version?: string(name='Version', description='The version of the operating system.', example='7.2'),
      }(name='OsTag', description='An array of OS images that are supported by E-HPC.'),
      postInstallScript?: string(name='PostInstallScript', description='The script that is run after the image is installed.', example='example.sh'),
      pricingCycle?: string(name='PricingCycle', description='The billing unit of the image. Valid values:

*   Hour
*   Month
*   Year', example='Month'),
      productCode?: string(name='ProductCode', description='The Alibaba Cloud Marketplace product code of the image.', example='cmjj028279'),
      size?: int32(name='Size', description='The size of the image. Unit: GiB.', example='40'),
      skuCode?: string(name='SkuCode', description='The stock keeping unit (SKU) of the image. Valid values:

*   ECS: pay-as-you-go
*   package: subscription', example='ECS'),
      status?: string(name='Status', description='The status of the image. Valid values:

*   UnAvailable: The image is unavailable.
*   Available: The image is available.
*   Creating: The image is being created.
*   CreateFailed: The image failed to be created.', example='Available'),
      uid?: string(name='Uid', description='The owner of the image.', example='127****'),
    }
  ](name='ImageInfo')
  }(name='Images', description='The list of community images, including custom images and shared images.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model ListCommunityImagesResponse = {
  headers: map[string]string(name='headers'),
  body: ListCommunityImagesResponseBody(name='body'),
}

async function listCommunityImages(request: ListCommunityImagesRequest): ListCommunityImagesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListCommunityImages', 'GET', '/', 'json', false, 'json', request);
}

model ListContainerAppsRequest {
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.

Pages start from page 1.

Default value: 1.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 50.

Default value: 10.', example='10', maximum=50, position='Query'),
}

model ListContainerAppsResponseBody = {
  containerApps?: {
    containerApps?: [ 
    {
      createTime?: string(name='CreateTime', description='The time when the containerized application was created.', example='2018-07-18T17:46:47'),
      description?: string(name='Description', description='The description of the containerized application.', example='ExampleDescription'),
      id?: string(name='Id', description='The ID of the containerized application.', example='ehpc-container-ABDUGSkjs****'),
      imageTag?: string(name='ImageTag', description='The tags of the image.', example='latest'),
      name?: string(name='Name', description='The name of the containerized application.', example='ExampleName'),
      repository?: string(name='Repository', description='The name of the repository.', example='busybox'),
      type?: string(name='Type', description='The type of the container. Set the value to singularity.', example='singularity'),
    }
  ](name='ContainerApps')
  }(name='ContainerApps', description='The array of containerized applications.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  totalCount?: int32(name='TotalCount', description='The total number of containerized applications.', example='1'),
}

model ListContainerAppsResponse = {
  headers: map[string]string(name='headers'),
  body: ListContainerAppsResponseBody(name='body'),
}

async function listContainerApps(request: ListContainerAppsRequest): ListContainerAppsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListContainerApps', 'GET', '/', 'json', false, 'json', request);
}

model ListContainerImagesRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****', position='Query'),
  containerType?: string(name='ContainerType', description='The type of the container. Set the value to singularity.', example='singularity', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return.

Pages start from page 1.

Default value: 1', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 50.

Default value: 10', example='10', maximum=50, position='Query'),
}

model ListContainerImagesResponseBody = {
  DBInfo?: string(name='DBInfo', description='The information of the database.', example='mongodb://localhost/'),
  images?: {
    images?: [ 
    {
      imageId?: string(name='ImageId', description='The ID of the image.', example='centos_7_06_64_20G_alibase_2019071****'),
      repository?: string(name='Repository', description='The name of the repository.', example='busybox'),
      status?: string(name='Status', description='The status of the image.', example='READY'),
      system?: string(name='System', description='The container system of the image.', example='mycluster'),
      tag?: string(name='Tag', description='The tags of the image.', example='latest'),
      type?: string(name='Type', description='The type of the container. Set the value to singularity.', example='docker'),
      updateDateTime?: string(name='UpdateDateTime', description='The time when the image was updated.', example='2018-08-02T20:11:36'),
    }
  ](name='Images')
  }(name='Images', description='The array of local images.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  totalCount?: int32(name='TotalCount', description='The total number of returned entries.', example='1'),
}

model ListContainerImagesResponse = {
  headers: map[string]string(name='headers'),
  body: ListContainerImagesResponseBody(name='body'),
}

async function listContainerImages(request: ListContainerImagesRequest): ListContainerImagesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListContainerImages', 'GET', '/', 'json', false, 'json', request);
}

model ListCpfsFileSystemsRequest {
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

By default, the information about all CPFSs and their mount targets within your account are queried.', example='096751****', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number of the page to return.

Pages start from page 1.

Default value: 1.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 50.

Default value: 10.', example='10', maximum=50, position='Query'),
}

model ListCpfsFileSystemsResponseBody = {
  fileSystemList?: {
    fileSystems?: [ 
    {
      capacity?: string(name='Capacity', description='The capacity of the file system. Unit: GiB.', example='5120'),
      createTime?: string(name='CreateTime', description='The time when the file system was created.', example='2018-07-26 16:36:27'),
      destription?: string(name='Destription', description='The description of the file system.', example='FilsDestription'),
      fileSystemId?: string(name='FileSystemId', description='The ID of the file system.', example='096751****'),
      mountTargetList?: {
        mountTargets?: [ 
        {
          mountTargetDomain?: string(name='MountTargetDomain', description='The domain where the mount target resides.', example='c0967****.cn-hangzhou.cpfs.nas.aliyuncs.com'),
          networkType?: string(name='NetworkType', description='The network type.', example='VPC'),
          status?: string(name='Status', description='The status of the mount target. Valid values:

*   Active: The mount target is available.
*   Inactive: The mount target is unavailable.
*   Pending: The mount target is being mounted.
*   Deleting: The mount target is being deleted.', example='Active'),
          vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC).', example='vpc-8vbvb34rtyh6xb3zrehs1****'),
          vswId?: string(name='VswId', description='The vSwitch ID of the instance.', example='vsw-8vb34rtyh6xb3zrehs1****'),
        }
      ](name='MountTargets')
      }(name='MountTargetList', description='The mount targets.'),
      protocolType?: string(name='ProtocolType', description='The protocol type that is applied to the mounted file system. Valid values:

*   NFS
*   SMB', example='NFS'),
      regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
      zoneId?: string(name='ZoneId', description='The zone ID.', example='cn-hangzhou-b'),
    }
  ](name='FileSystems')
  }(name='FileSystemList', description='The list of file systems.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned on the current page.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='2B900AFE-C938-4551-86E9-97E231BBC876'),
  totalCount?: int32(name='TotalCount', description='The total number of returned entries.', example='10'),
}

model ListCpfsFileSystemsResponse = {
  headers: map[string]string(name='headers'),
  body: ListCpfsFileSystemsResponseBody(name='body'),
}

async function listCpfsFileSystems(request: ListCpfsFileSystemsRequest): ListCpfsFileSystemsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListCpfsFileSystems', 'GET', '/', 'json', false, 'json', request);
}

model ListCurrentClientVersionRequest {
}

model ListCurrentClientVersionResponseBody = {
  clientVersion?: string(name='ClientVersion', description='The latest version number of the E-HPC client.', example='1.1.1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model ListCurrentClientVersionResponse = {
  headers: map[string]string(name='headers'),
  body: ListCurrentClientVersionResponseBody(name='body'),
}

async function listCurrentClientVersion(request: ListCurrentClientVersionRequest): ListCurrentClientVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListCurrentClientVersion', 'GET', '/', 'json', false, 'json', request);
}

model ListCustomImagesRequest {
  baseOsTag?: string(name='BaseOsTag', description='The image tag of the base operating system. The tag is used only by the management node.', example='CentOS_7.2_64', position='Query'),
  clusterId?: string(name='ClusterId', description='The ID of the cluster where the application resides. If the cluster supports multiple operating systems, all the images in the region where the cluster resides are queried.

By default, if you do not specify the cluster ID, the images that are supported by all the clusters is queried.', example='ehpc-hz-FYUr32****', position='Query'),
  imageOwnerAlias?: string(name='ImageOwnerAlias', description='The source of the image. Valid values:

*   self: custom image
*   others: shared image', example='self', position='Query'),
  instanceType?: string(name='InstanceType', description='Specify the type of the instance. By default, if you do not specify the type of the instance, the list of images that are supported by all the instance types are queried.', example='ecs.n1.tiny', position='Query'),
}

model ListCustomImagesResponseBody = {
  images?: {
    imageInfo?: [ 
    {
      baseOsTag?: {
        architecture?: string(name='Architecture', description='The architecture of the operating system. Valid values:

*   i386
*   x86\\_64', example='i386'),
        osTag?: string(name='OsTag', description='The image tag of the operating system.', example='CentOS_7.2_64'),
        platform?: string(name='Platform', description='The release version of the operating system. Valid values:

*   CentOS
*   Ubuntu
*   SUSE
*   OpenSUSE
*   Debian
*   CoreOS
*   Aliyun
*   Windows Server 2003
*   Windows Server 2008
*   Windows Server 2012
*   Others Linux
*   Customized Linux', example='CentOS'),
        version?: string(name='Version', description='The version number of the operating system.', example='7.2'),
      }(name='BaseOsTag', description='The image tag of the base operating system.'),
      description?: string(name='Description', description='The description of the image.', example='ExampleDescription'),
      imageId?: string(name='ImageId', description='The ID of the image.', example='m-bp181x855551ww5yq****'),
      imageName?: string(name='ImageName', description='The name of the image.', example='CHESS5V5.0.27'),
      imageOwnerAlias?: string(name='ImageOwnerAlias', description='The type of image. Valid values:

*   self: custom image
*   others: shared image', example='self'),
      osTag?: {
        architecture?: string(name='Architecture', description='The architecture of the operating system. Valid values:

*   i386
*   x86\\_64', example='x86_64'),
        baseOsTag?: string(name='BaseOsTag', description='The image tag of the base operating system.', example='CentOS_7.2_64'),
        osTag?: string(name='OsTag', description='The image tag of the operating system.', example='CentOS_7.2_64'),
        platform?: string(name='Platform', description='The platform of the operating system.', example='CentOS'),
        version?: string(name='Version', description='The version of the operating system.', example='7.2'),
      }(name='OsTag', description='An array of system images that are supported by E-HPC.'),
      postInstallScript?: string(name='PostInstallScript', description='The script that is run after the image is installed.', example='example.sh'),
      pricingCycle?: string(name='PricingCycle', description='The billing unit of the image. Valid values:

*   Hour
*   Month
*   Year', example='Month'),
      productCode?: string(name='ProductCode', description='The product code on Alibaba Cloud Marketplace.', example='cmjj028279'),
      size?: int32(name='Size', description='The size of the image. Unit: GiB', example='40'),
      skuCode?: string(name='SkuCode', description='The stock keeping unit (SKU) of the image. Valid values:

\\-ECS: pay-as-you-go

\\-package: subscription', example='ECS'),
      status?: string(name='Status', description='The status of the image. Valid values:

*   UnAvailable: The image is unavailable.
*   Available: The image is available.
*   Creating: The image is being created.
*   CreateFailed: The image has failed to be created.', example='Available'),
      uid?: string(name='Uid', description='The owner of the image.', example='127****'),
    }
  ](name='ImageInfo')
  }(name='Images', description='The list of custom images and shared images that are supported by the E-HPC.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model ListCustomImagesResponse = {
  headers: map[string]string(name='headers'),
  body: ListCustomImagesResponseBody(name='body'),
}

async function listCustomImages(request: ListCustomImagesRequest): ListCustomImagesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListCustomImages', 'GET', '/', 'json', false, 'json', request);
}

model ListFileSystemWithMountTargetsRequest {
  pageNumber?: int32(name='PageNumber', description='The page number of the page to return.

Page numbers start from 1.

Default value: 1', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 50.

Default value: 10', example='10', maximum=50, position='Query'),
}

model ListFileSystemWithMountTargetsResponseBody = {
  fileSystemList?: {
    fileSystems?: [ 
    {
      bandWidth?: int32(name='BandWidth', description='The bandwidth of the file system. Unit: MB/s.', example='150'),
      capacity?: int32(name='Capacity', description='The capacity of the file system. Unit: GiB.', example='5120'),
      createTime?: string(name='CreateTime', description='The time when the file system was created.', example='2018-07-26 16:36:27'),
      destription?: string(name='Destription', description='The description of the file system.', example='FilesDescription'),
      encryptType?: int32(name='EncryptType', description='Indicates whether the file system is encrypted. Valid values:

*   0: The file system is not encrypted.
*   1: The file system is encrypted.', example='0'),
      fileSystemId?: string(name='FileSystemId', description='The ID of the file system.', example='088b****'),
      fileSystemType?: string(name='FileSystemType', description='The type of the file system. Valid values:

*   standard: General-purpose NAS file system
*   extreme: Extreme NAS file system', example='standard'),
      meteredSize?: int32(name='MeteredSize', description='The used capacity of the file system. Unit: bytes.', example='1216816455'),
      mountTargetList?: {
        mountTargets?: [ 
        {
          accessGroup?: string(name='AccessGroup', description='The name of the permission group that applied to the mount target.', example='DEFAULT_VPC_GROUP_NAME'),
          mountTargetDomain?: string(name='MountTargetDomain', description='The domain name of the mount target.', example='088b****-lj2.cn-hangzhou.nas.aliyuncs.com'),
          networkType?: string(name='NetworkType', description='The network type of the mount target. Valid values:

*   Vpc: virtual private cloud (VPC)
*   Classic: the classic network', example='vpc'),
          status?: string(name='Status', description='The status of the mount target. Valid values:

*   Active: The mount target is available.
*   Inactive: The mount target is inactive.
*   Pending: The mount target is being created or modified.
*   Deleting: The mount target is being deleted.', example='Active'),
          vpcId?: string(name='VpcId', description='The ID of the VPC.', example='vpc-8vbvb34rtyh6xb3zrehs1****'),
          vswId?: string(name='VswId', description='The ID of the vSwitch.', example='vsw-8vb34rtyh6xb3zrehs1****'),
        }
      ](name='MountTargets')
      }(name='MountTargetList', description='The list of mount targets.'),
      packageList?: {
        packages?: [ 
        {
          packageId?: string(name='PackageId', description='The ID of the storage plan.', example='naspackage-0be9c4b624-37****'),
        }
      ](name='Packages')
      }(name='PackageList', description='The list of storage plans.'),
      protocolType?: string(name='ProtocolType', description='The protocol type of the file system. Valid values:

- NFS
- SMB', example='NFS'),
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
      status?: string(name='Status', description='The status of the file system. Valid values:

- Pending: The file system is being created or modified.
- Running: The file system is available.
- Stopped: The file system is stopped.
- Extending: The file system is being scaled out.
- Stopping: The file system is being stopped.
- Deleting: The file system is being deleted.', example='Running'),
      storageType?: string(name='StorageType', description='The storage type of the file system. 

- If FileSystemType is set to standard, the StorageType parameter has the following valid values: Capacity and Performance.
- If FileSystemType is set to extreme, the StorageType parameter has the following valid values: standard and advance.', example='Performance'),
      vpcId?: string(name='VpcId', example='vpc-bp132kgui8n0targbn1cm'),
    }
  ](name='FileSystems')
  }(name='FileSystemList', description='The list of file systems.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='25638B77-2F19-5DC5-B578-7790CE92052B'),
  totalCount?: int32(name='TotalCount', description='The total number of entries.', example='1'),
}

model ListFileSystemWithMountTargetsResponse = {
  headers: map[string]string(name='headers'),
  body: ListFileSystemWithMountTargetsResponseBody(name='body'),
}

async function listFileSystemWithMountTargets(request: ListFileSystemWithMountTargetsRequest): ListFileSystemWithMountTargetsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListFileSystemWithMountTargets', 'GET', '/', 'json', false, 'json', request);
}

model ListImagesRequest {
  baseOsTag?: string(name='BaseOsTag', description='The image tag of the operating system. The tag is used only for management nodes.', example='CentOS_7.2_64', position='Query'),
  instanceType?: string(name='InstanceType', description='The instance type.

*   If a value is passed to the parameter, the list of images that are supported by the specified instance type is queried.
*   If no value is passed to the parameter, the list of images that are supported by all instance types is queried.', example='ecs.n1.medium', position='Query'),
}

model ListImagesResponseBody = {
  osTags?: {
    osInfo?: [ 
    {
      architecture?: string(name='Architecture', description='The architecture of the operating system. Valid values:

*   i386
*   x86\\_64', example='i386'),
      baseOsTag?: string(name='BaseOsTag', description='The image tag of the operating system. The tag is used only for management nodes.', example='CentOS_7.2_64'),
      imageId?: string(name='ImageId', description='The ID of the image.', example='m-bp1h8aoe73p71iow****'),
      OSName?: string(name='OSName', description='The name of the image.', example='CentOS_7.2_64'),
      OSNameEn?: string(name='OSNameEn', description='The name of the image in English.', example='CentOS_7.2_64'),
      osTag?: string(name='OsTag', description='The tag that is added to the image.', example='CentOS_7.2_64'),
      platform?: string(name='Platform', description='The operating system. Valid values:

*   CentOS
*   windows', example='CentOS'),
      version?: string(name='Version', description='The version of the operating system.', example='7.2'),
    }
  ](name='OsInfo')
  }(name='OsTags', description='The list of images that are supported by E-HPC.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model ListImagesResponse = {
  headers: map[string]string(name='headers'),
  body: ListImagesResponseBody(name='body'),
}

async function listImages(request: ListImagesRequest): ListImagesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListImages', 'GET', '/', 'json', false, 'json', request);
}

model ListInstalledSoftwareRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****', position='Query'),
}

model ListInstalledSoftwareResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='DDCA0E7B-03E7-430D-810C-0D508539****'),
  softwareList?: {
    softwareList?: [ 
    {
      softwareId?: string(name='SoftwareId', description='The ID of the software.', example='MPICH_3.2'),
      softwareName?: string(name='SoftwareName', description='The name of the software.', example='mpich'),
      softwareStatus?: string(name='SoftwareStatus', description='The status of the software. Valid values:

*   Installing: The software is being installed.
*   Installed: The software is installed.', example='Installing'),
      softwareVersion?: string(name='SoftwareVersion', description='The version of the software.', example='3.2'),
    }
  ](name='SoftwareList')
  }(name='SoftwareList', description='The list of installed software.'),
}

model ListInstalledSoftwareResponse = {
  headers: map[string]string(name='headers'),
  body: ListInstalledSoftwareResponseBody(name='body'),
}

async function listInstalledSoftware(request: ListInstalledSoftwareRequest): ListInstalledSoftwareResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListInstalledSoftware', 'GET', '/', 'json', false, 'json', request);
}

model ListInvocationResultsRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****', position='Query'),
  commandId: string(name='CommandId', description='The ID of the command.

You can call the [ListCommands](~~87388~~) operation to query the command ID.', example='c-hz01v8x80o3****', position='Query'),
  instance?: [ 
    {
      id?: string(name='Id', description='The ID of the node on which the command is run.

>  The Instance.N.Id parameter specifies the node on which the command is run. If it is not specified, the command is run on all nodes of the cluster.', example='i-uf65bh2113hlqvyr****'),
    }
  ](name='Instance', description='The information of nodes on which the command is run.', position='Query'),
  invokeRecordStatus?: string(name='InvokeRecordStatus', description='The status of the command that you want to query. Valid values:

*   Finished
*   Running
*   Failed
*   Stopped', example='Finished', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return.

Page numbers start from 1.

Default value: 1', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 50.

Default value: 10', example='10', maximum=50, position='Query'),
}

model ListInvocationResultsResponseBody = {
  invocationResults?: {
    invocationResult?: [ 
    {
      commandId?: string(name='CommandId', description='The ID of the command.', example='c-hz01v8x80o3****'),
      exitCode?: int32(name='ExitCode', description='The exit code.', example='0'),
      finishedTime?: string(name='FinishedTime', description='The time at which the command entered the Finished state.', example='2021-09-06T09:14:56Z'),
      instanceId?: string(name='InstanceId', description='The ID of the node on which the command was run.', example='i-uf65bh2113hlqvyr****'),
      invokeRecordStatus?: string(name='InvokeRecordStatus', description='The status of the command. Valid values:

*   Finished
*   Running
*   Failed
*   Stopped', example='Finished'),
      message?: string(name='Message', description='The output result.', example='hello world'),
      success?: boolean(name='Success', description='Indicates whether the command was run and its result was obtained.', example='true'),
    }
  ](name='InvocationResult')
  }(name='InvocationResults', description='The result of the command.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
  totalCount?: int32(name='TotalCount', description='The total number of returned entries.', example='1'),
}

model ListInvocationResultsResponse = {
  headers: map[string]string(name='headers'),
  body: ListInvocationResultsResponseBody(name='body'),
}

async function listInvocationResults(request: ListInvocationResultsRequest): ListInvocationResultsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListInvocationResults', 'GET', '/', 'json', false, 'json', request);
}

model ListInvocationStatusRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****', position='Query'),
  commandId: string(name='CommandId', description='The ID of the command.

You can call the [ListCommands](~~87388~~) operation to query the command ID.', example='c-hz01v8x80o3****', position='Query'),
}

model ListInvocationStatusResponseBody = {
  commandId?: string(name='CommandId', description='The ID of the command.', example='c-hz01v8x80o3****'),
  invokeInstances?: {
    invokeInstance?: [ 
    {
      instanceId?: string(name='InstanceId', description='The ID of the node.', example='i-uf6abz34m2714bp4****'),
      instanceInvokeStatus?: string(name='InstanceInvokeStatus', description='The status of the node. Valid values:

*   Finished
*   Running
*   Failed
*   Stopped', example='Finished'),
    }
  ](name='InvokeInstance')
  }(name='InvokeInstances', description='The list of statuses. A list is returned for each node.'),
  invokeStatus?: string(name='InvokeStatus', description='The overall status of all nodes in the cluster. Valid values:

- Finished
- Running
- Failed
- Stopped', example='Finished'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model ListInvocationStatusResponse = {
  headers: map[string]string(name='headers'),
  body: ListInvocationStatusResponseBody(name='body'),
}

async function listInvocationStatus(request: ListInvocationStatusRequest): ListInvocationStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListInvocationStatus', 'GET', '/', 'json', false, 'json', request);
}

model ListJobTemplatesRequest {
  name?: string(name='Name', description='The name of the job template.

You can call the [ListJobTemplates](~~87248~~) operation to obtain the job template name.', example='jobtemplateName', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Page numbers start from 1.

Default value: 1', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Maximum value: 50.

Default value: 10', example='10', maximum=50, position='Query'),
}

model ListJobTemplatesResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  templates?: {
    jobTemplates?: [ 
    {
      arrayRequest?: string(name='ArrayRequest', description='The job array.

Format: X-Y:Z. X is the minimum index value. Y is the maximum index value. Z is the step size. For example, 2-7:2 indicates that three jobs need to be run and their index values are 2, 4, and 6.', example='2-7:2'),
      clockTime?: string(name='ClockTime', description='The maximum running time of the job. Valid formats:

*   hh:mm:ss
*   mm:ss
*   ss', example='12:00:00'),
      commandLine?: string(name='CommandLine', description='The command that was used to run the job.', example='./LammpsTest/lammps.pbs'),
      gpu?: int32(name='Gpu', description='The maximum GPU usage required by a single compute node. Valid values: 1 to 8.

The parameter takes effect only when the cluster uses PBS and a compute node is a GPU-accelerated instance.', example='1'),
      id?: string(name='Id', description='The ID of the job template.', example='ehpc-job-tmpl-6RxO5y****'),
      inputFileUrl?: string(name='InputFileUrl', description='The URL of the job files that were uploaded to an Object Storage Service (OSS) bucket.', example='https://test.oss-cn-beijing.aliyuncs.com/test.py'),
      mem?: string(name='Mem', description='The maximum memory usage of a single compute node. The unit can be GB, MB, or KB, and is case-insensitive.', example='1GB'),
      name?: string(name='Name', description='The name of the job template.', example='job1'),
      node?: int32(name='Node', description='The number of the compute nodes. Valid values: 1 to 500.', example='2'),
      packagePath?: string(name='PackagePath', description='The path that was used to run the job.', example='./jobfolder'),
      priority?: int32(name='Priority', description='The priority of the job. Valid values: 0 to 9. A large value indicates a high priority.', example='0'),
      queue?: string(name='Queue', description='The queue of the job.', example='workq'),
      reRunable?: boolean(name='ReRunable', description='Indicates whether the job can be rerun. Valid values:

*   true: The job can be rerun.
*   false: The job cannot be rerun.', example='false'),
      runasUser?: string(name='RunasUser', description='The name of the user that ran the job.', example='user1'),
      stderrRedirectPath?: string(name='StderrRedirectPath', description='The output file path of stderr.', example='./LammpsTest'),
      stdoutRedirectPath?: string(name='StdoutRedirectPath', description='The output file path of stdout.', example='./Lammps'),
      task?: int32(name='Task', description='The number of tasks required by a single compute node. Valid values: 1 to 1000.', example='2'),
      thread?: int32(name='Thread', description='The number of threads required by a single compute node. Valid values: 1 to 1000.', example='1'),
      unzipCmd?: string(name='UnzipCmd', description='The command that was used to decompress the job files downloaded from an OSS bucket. The parameter takes effect only when WithUnzipCmd is set to true. Valid values:

*   tar xzf: decompresses GZIP files.
*   tar xf: decompresses TAR files.
*   unzip: decompresses ZIP files.', example='tar xzf'),
      variables?: string(name='Variables', description='The environment variables of the job.', example='[{Name:,Value:},{Name:,Value:}]'),
      withUnzipCmd?: boolean(name='WithUnzipCmd', description='Indicates whether to decompress the job files downloaded from an OSS bucket. Valid values:

*   true: The job files are decompressed.
*   false: The job files are not decompressed.', example='true'),
    }
  ](name='JobTemplates')
  }(name='Templates', description='The list of job templates.'),
  totalCount?: int32(name='TotalCount', description='The total number of returned entries.', example='1'),
}

model ListJobTemplatesResponse = {
  headers: map[string]string(name='headers'),
  body: ListJobTemplatesResponseBody(name='body'),
}

async function listJobTemplates(request: ListJobTemplatesRequest): ListJobTemplatesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListJobTemplates', 'GET', '/', 'json', false, 'json', request);
}

model ListJobsRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****', position='Query'),
  owner?: string(name='Owner', description='The name of the user that runs the job.

You can call the [ListUsers](~~188572~~) operation to query the users in the cluster.', example='user1', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return.

Pages start from page 1.

Default value: 1', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Maximum value: 50.

Default value: 10', example='10', maximum=50, position='Query'),
  rerunable?: string(name='Rerunable', description='Specifies whether the job can be rerun. Valid values:

*   true
*   false

Default value: false', example='false', position='Query'),
  state?: string(name='State', description='The status of the job. Valid values:

*   all
*   finished
*   notfinish', example='finished', position='Query'),
}

model ListJobsResponseBody = {
  jobs?: {
    jobInfo?: [ 
    {
      arrayRequest?: string(name='ArrayRequest', description='The job array. If the job is not in a queue, the output is empty.

Format: X-Y:Z. X is the minimum index value. Y is the maximum index value. Z is the step size. For example, 2-7:2 indicates that three jobs need to be run and their index values are 2, 4, and 6.', example='1-10:2'),
      comment?: string(name='Comment', description='The description of the job.', example='jobDescription'),
      id?: string(name='Id', description='The ID of the job.', example='0.manager'),
      lastModifyTime?: string(name='LastModifyTime', description='The time when the job was last modified.', example='2018-07-18T17:46:48'),
      name?: string(name='Name', description='The name of the job.', example='job1'),
      nodeList?: string(name='NodeList', description='The list of compute nodes that were used to run the job.', example='[\\"compute2\\", \\"compute3\\"]'),
      owner?: string(name='Owner', description='The name of the user that runs the job.', example='user1'),
      priority?: string(name='Priority', description='The priority of the job. Valid values: 0 to 9. A large value indicates a high priority.', example='0'),
      resources?: {
        cores?: int32(name='Cores', description='The number of CPUs that were used to run the job.', example='2'),
        nodes?: int32(name='Nodes', description='The number of nodes that were used to run the job.', example='0'),
      }(name='Resources', description='The resources that were used to run the job.'),
      shellPath?: string(name='ShellPath', description='The path that was used to run the job.', example='./Temp'),
      startTime?: string(name='StartTime', description='The time when the job started to run.', example='2018-07-18T17:46:48'),
      state?: string(name='State', description='The status of the job. Valid values: Valid values:

*   FINISHED: The job is completed
*   RUNNING: The job is running.
*   QUEUED: The job is pending in a queue.', example='FINISHED'),
      stderr?: string(name='Stderr', description='The output file path of stderr.', example='./Temp'),
      stdout?: string(name='Stdout', description='The output file path of stdout.', example='./Temp'),
      submitTime?: string(name='SubmitTime', description='The time when the job was submitted.', example='2018-07-18T17:46:47'),
    }
  ](name='JobInfo')
  }(name='Jobs', description='The list of jobs.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  totalCount?: int32(name='TotalCount', description='The total number of returned entries.', example='1'),
}

model ListJobsResponse = {
  headers: map[string]string(name='headers'),
  body: ListJobsResponseBody(name='body'),
}

async function listJobs(request: ListJobsRequest): ListJobsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListJobs', 'GET', '/', 'json', false, 'json', request);
}

model ListJobsWithFiltersRequest {
  async?: boolean(name='Async', description='Specifies whether to enable asynchronous query.', example='false', position='Query'),
  clusterId: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****', position='Query'),
  createTimeEnd?: string(name='CreateTimeEnd', description='The latest time when a job is submitted. The value is a UNIX timestamp, which represents the number of seconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.', example='1647428667', position='Query'),
  createTimeStart?: string(name='CreateTimeStart', description='The earliest time when a job is submitted. The value is a UNIX timestamp, which represents the number of seconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.', example='1647427667', position='Query'),
  executeOrder?: string(name='ExecuteOrder', description='The order in which jobs are sorted based on the execution time. Valid values:

*   asc: ascending order
*   desc: descending order', example='asc', position='Query'),
  jobName?: string(name='JobName', description='The name of the job. Fuzzy match is supported.', example='job1', position='Query'),
  jobStatus?: string(name='JobStatus', description='The status of the job. Valid values:

*   all
*   finished
*   notfinish

Default value: all', example='finished', position='Query'),
  nodes?: [ string ](name='Nodes', position='Query'),
  pageNumber?: long(name='PageNumber', description='The number of the page to return.

Pages start from page 1.

Default value: 1', example='1', position='Query'),
  pageSize?: long(name='PageSize', description='The number of entries to return on each page. Maximum value: 50.

Default value: 10', example='10', position='Query'),
  pendOrder?: string(name='PendOrder', description='The order in which jobs are sorted based on the time when they queue. Valid values:

*   asc: ascending order
*   desc: descending order', example='desc', position='Query'),
  queues?: [ string ](name='Queues', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region.

You can call the [ListRegions](~~188593~~) operation to query the list of regions where E-HPC is supported.', example='cn-hangzhou', position='Query'),
  submitOrder?: string(name='SubmitOrder', description='The order in which jobs are sorted based on the time when they are submitted. Valid values:

*   asc: ascending order
*   desc: descending order', example='asc', position='Query'),
  users?: [ string ](name='Users', position='Query'),
}

model ListJobsWithFiltersResponseBody = {
  jobs?: [ 
    {
      arrayRequest?: string(name='ArrayRequest', description='The job array. If the job is not in a queue, the output is empty.

Format: X-Y:Z. X is the minimum index value. Y is the maximum index value. Z is the step size. For example, 2-7:2 indicates that three jobs need to be run and their index values are 2, 4, and 6.', example='1-10:2'),
      comment?: string(name='Comment', description='The description of the job.', example='jobDescription'),
      id?: string(name='Id', description='The ID of the job.', example='8.scheduler'),
      lastModifyTime?: string(name='LastModifyTime', description='The time when the job was last modified.', example='1647428667'),
      name?: string(name='Name', description='The name of the job.', example='job1'),
      nodeList?: string(name='NodeList', description='The list of compute nodes that were used to run the job.', example='[\\"compute2\\", \\"compute3\\"]'),
      owner?: string(name='Owner', description='The name of the user that ran the job.', example='test2@scheduler'),
      priority?: string(name='Priority', description='The priority of the job. Valid values: 0 to 9. A large value indicates a high priority.', example='0'),
      queue?: string(name='Queue', description='The number of queues that ran the job.', example='2'),
      rerunable?: boolean(name='Rerunable', description='Indicates whether the job can be run again. Valid values:

*   true
*   false', example='true'),
      resources?: {
        cores?: long(name='Cores', description='The number of CPUs that were used to run the job.', example='2'),
        nodes?: long(name='Nodes', description='The number of nodes that were used to run the job.', example='0'),
      }(name='Resources', description='The resources that were used to run the job.'),
      shellPath?: string(name='ShellPath', description='The path that was used to run the job.', example='./Temp'),
      startTime?: string(name='StartTime', description='The time when the job started to run.', example='1647427667'),
      state?: string(name='State', description='The status of the job. Valid values:

*   FINISHED: The job is completed.
*   RUNNING: The job connector is running.
*   QUEUED: The job is pending in a queue.', example='FINISHED'),
      stderr?: string(name='Stderr', description='The output file path of stderr.', example='./Temp'),
      stdout?: string(name='Stdout', description='The output file path of stdout.', example='./Temp'),
      submitTime?: string(name='SubmitTime', description='The time when the job was submitted.', example='1647423718'),
      variableList?: string(name='VariableList', description='The list of variables of the job.', example='{"PBS_O_SHELL":"/bin/bash", 	"PBS_O_HOST":"manager", 	"PBS_O_SYSTEM":"Linux", 	"PBS_O_LANG":"en_US.UTF-8", 	"PBS_O_QUEUE":"workq"}'),
    }
  ](name='Jobs', description='The list of jobs.'),
  pageNumber?: long(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries returned per page.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true: The call was successful.
*   false: The request failed.', example='true'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='1'),
}

model ListJobsWithFiltersResponse = {
  headers: map[string]string(name='headers'),
  body: ListJobsWithFiltersResponseBody(name='body'),
}

async function listJobsWithFilters(request: ListJobsWithFiltersRequest): ListJobsWithFiltersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListJobsWithFilters', 'GET', '/', 'json', false, 'json', request);
}

model ListNodesRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****', position='Query'),
  filter?: string(name='Filter', description='The filter options of the node list.

Format: {"status":"node_status"}. Replace node_status with the node status. Valid values of node_status:

*   uninit: The node is being installed.
*   exception: An exception has occurred on the node.
*   running: The node is running.
*   initing: The node is being initialized.
*   releasing: The node is being released.
*   untracking: The node is not added to the cluster.
*   stopped: The node is stopped.', example='{"status":"running"}', position='Query'),
  hostName?: string(name='HostName', description='The name of the node. You can perform a fuzzy search. MySQL regular expressions are supported.', example='test-HostName', position='Query'),
  hostNamePrefix?: string(name='HostNamePrefix', description='The prefix of the hostname. You can query nodes that have a specified prefix.', example='compute', position='Query'),
  hostNameSuffix?: string(name='HostNameSuffix', description='The suffix of the hostname. You can query nodes that have a specified suffix.', example='01', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page 1.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 100.

Default value: 10', example='10', maximum=100, position='Query'),
  privateIpAddress?: string(name='PrivateIpAddress', description='The private IP address of the node.', example='172.16.**.**', position='Query'),
  role?: string(name='Role', description='The type of the node. Valid values:

*   Manager: management node
*   Login: logon node
*   Compute: compute node', example='Manager', position='Query'),
  sequence?: string(name='Sequence', description='The sorting method of the node list. Valid values:

*   Forward: sorts the nodes in chronological order.
*   Backward: sorts the nodes in reverse chronological order.

Default value: Forward

>  Sequence is used in combination with SortBy. If SortBy is set to AddedTime and Sequence is set to Forward, nodes are sorted by the time that they were added in chronological order.', example='Forward', position='Query'),
  sortBy?: string(name='SortBy', description='The sorting method of the node list. Valid values:

*   AddedTime: sorts the nodes by the time that they were added.
*   HostName: sorts the nodes by their host names.', example='AddedTime', position='Query'),
}

model ListNodesResponseBody = {
  nodes?: {
    nodeInfo?: [ 
    {
      addTime?: string(name='AddTime', description='The time when the node was added to the cluster.', example='2020-06-09T06:22:02.000Z'),
      createMode?: string(name='CreateMode', description='The mode in which the compute nodes are added. Valid values:

*   manual: The compute nodes are manually added.
*   autoscale: The compute nodes are automatically added.', example='manual'),
      createdByEhpc?: boolean(name='CreatedByEhpc', description='Indicates whether the node was created by using E-HPC.

*   true: The node is created by using E-HPC.
*   false: The node is not created by using E-HPC.', example='true'),
      expired?: boolean(name='Expired', description='Indicates whether the subscription node expired. For a pay-as-you-go node, false is returned.', example='false'),
      expiredTime?: string(name='ExpiredTime', description='The time when the subscription node expires. For a pay-as-you-go node, a null value is returned.', example='2020-06-09T06:22:02.000Z'),
      hostName?: string(name='HostName', description='The name of the node.', example='test-HostName'),
      htEnabled?: boolean(name='HtEnabled', description='Indicates whether hyper-threading is enabled.', example='true'),
      id?: string(name='Id', description='The ID of the node.', example='i-bp15707mys2rsy0j****'),
      imageId?: string(name='ImageId', description='The ID of the image.', example='centos_7_06_64_20G_alibase_20190711.vhd'),
      imageOwnerAlias?: string(name='ImageOwnerAlias', description='The type of the image. Valid values:

*   system: public image
*   self: custom image
*   others: shared image
*   marketplace: Alibaba Cloud Marketplace image', example='system'),
      instanceType?: string(name='InstanceType', description='The instance types of the node.', example='ecs.c5.large'),
      ipAddress?: string(name='IpAddress', description='The IP address of the node.', example='172.16.**.**'),
      location?: string(name='Location', description='The location where the node was deployed. Valid values:

*   OnPremise: The node is deployed on your data center.
*   PublicCloud: The node is deployed on the public cloud.', example='PublicCloud'),
      lockReason?: string(name='LockReason', description='The reason why the node was locked. Valid values:

*   financial: The node is locked due to overdue payments.
*   security: The node is locked for security reasons.
*   recycling: The preemptible node is locked and pending release.
*   dedicatedhostfinancial: The node is locked due to the overdue payments of the dedicated host.

By default, an empty string is returned.', example='financial'),
      publicIpAddress?: string(name='PublicIpAddress', description='The public IP address of the node.', example='172.16.**.**'),
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
      roles?: {
        role?: [ string ](name='Role')
      }(name='Roles', description='The type of the node. Valid values:

*   Scheduler: primary scheduling node
*   SchedulerBackup: secondary scheduling node
*   Account: primary domain server node
*   AccountBackup: secondary domain server node
*   Login: logon node
*   Compute: compute node

Scheduling nodes and domain server nodes are management nodes.'),
      spotStrategy?: string(name='SpotStrategy', description='The bidding method of the compute nodes.', example='NoSpot'),
      stateInSched?: string(name='StateInSched', description='The status of the node displayed on the scheduler. The status varies with the scheduler.', example='active'),
      status?: string(name='Status', description='The status of the node. Valid values:

*   uninit: The node is being installed.
*   exception: An exception has occurred on the node.
*   running: The node is running.
*   initing: The node is being initialized.
*   releasing: The node is being released.
*   untracking: The node is not added to the cluster.
*   stopped: The node is stopped.', example='running'),
      totalResources?: {
        cpu?: int32(name='Cpu', description='The number of vCPUs.', example='1'),
        gpu?: int32(name='Gpu', description='The number of GPUs.', example='0'),
        memory?: int32(name='Memory', description='The memory capacity. Unit: GB', example='1024'),
      }(name='TotalResources', description='The statistics of the resources used by the node.'),
      usedResources?: {
        cpu?: int32(name='Cpu', description='The number of vCPUs.', example='0'),
        gpu?: int32(name='Gpu', description='The number of GPUs.', example='0'),
        memory?: int32(name='Memory', description='The memory capacity. Unit: GB', example='0'),
      }(name='UsedResources', description='The usage of the compute nodes in the cluster. For other types of nodes, an empty value is returned.'),
      vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch.', example='vsw-bp1e47optm9g58zcu****'),
      version?: string(name='Version', description='The version of the client.', example='1.0.78'),
      vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC).', example='vpc-bp1gnu8br4ay7beb2w****'),
      zoneId?: string(name='ZoneId', description='The ID of the zone.', example='cn-hangzhou-b'),
    }
  ](name='NodeInfo')
  }(name='Nodes', description='The information about nodes.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='89A1AC0F-4A6C-4F3D-98F9-BEF9A823****'),
  totalCount?: int32(name='TotalCount', description='The total number of returned entries.', example='1'),
}

model ListNodesResponse = {
  headers: map[string]string(name='headers'),
  body: ListNodesResponseBody(name='body'),
}

async function listNodes(request: ListNodesRequest): ListNodesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListNodes', 'GET', '/', 'json', false, 'json', request);
}

model ListNodesByQueueRequest {
  async?: boolean(name='Async', example='false', position='Query'),
  clusterId: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-FYUr32****', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page 1.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 50.

Default value: 10', example='10', maximum=100, position='Query'),
  queueName: string(name='QueueName', description='The name of the queue.', example='workq', position='Query'),
}

model ListNodesByQueueResponseBody = {
  nodes?: {
    nodeInfo?: [ 
    {
      addTime?: string(name='AddTime', description='The time when the node was added to the cluster.', example='2019-09-18T13:24:29.000Z'),
      createMode?: string(name='CreateMode', description='The mode in which the node was added. Valid values:

*   manual: The node was manually added.
*   autoscale: The node is automatically added.', example='manual'),
      createdByEhpc?: boolean(name='CreatedByEhpc', description='Indicates whether the node was created by using E-HPC.', example='true'),
      expired?: boolean(name='Expired', description='Indicates whether the subscription node has expired. If the node is a pay-as-you-go node, false is returned.', example='false'),
      expiredTime?: string(name='ExpiredTime', description='The time when the subscription instance expires. If the node is a pay-as-you-go node, a null value is returned.', example='2020-09-18T13:24:29.000Z'),
      hostName?: string(name='HostName', description='The name of the node.', example='compute0'),
      htEnabled?: boolean(name='HtEnabled', description='Indicates whether Hyper-Threading (HT) is enabled.', example='true'),
      id?: string(name='Id', description='The ID of the ECS instance.', example='i-bp13p7vlcb1uihfv****'),
      imageId?: string(name='ImageId', description='The ID of the image.', example='centos_7_02_64_20G_alibase_20170818****'),
      imageOwnerAlias?: string(name='ImageOwnerAlias', description='The type of the image. Valid values:

*   system: public image
*   self: custom image
*   others: shared image
*   marketplace: Alibaba Cloud Marketplace image', example='system'),
      ipAddress?: string(name='IpAddress', description='The private IP address of the node.', example='172.168.**.**'),
      location?: string(name='Location', description='The location where the node is deployed. Valid values:

*   OnPremise: The node is deployed on a hybrid cloud.
*   PublicCloud: The node is deployed on a public cloud.', example='PublicCloud'),
      lockReason?: string(name='LockReason', description='The reason why the node is locked. Valid values:

*   financial: The node is locked due to overdue payments.
*   security: The node is locked due to security reasons.
*   recycling: The preemptible node is locked and pending release.
*   dedicatedhostfinancial: The node is locked due to the overdue payments of the dedicated host.

By default, an empty string is returned.', example='financial'),
      publicIpAddress?: string(name='PublicIpAddress', description='The public IP address of the node.', example='10.34.**.**'),
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
      spotStrategy?: string(name='SpotStrategy', description='The preemption policy for the Elastic Compute Service (ECS) instance. Valid values:

*   NoSpot: applies to regular pay-as-you-go instances.
*   SpotWithPriceLimit: The instances of the compute node are preemptible instances. These types of instances have a specified maximum hourly price.
*   SpotAsPriceGo: The instances of the compute node are preemptible instances. The price of these instances is based on the current market price.', example='NoSpot'),
      stateInSched?: string(name='StateInSched', description='The status of the node displayed on the scheduler. The status varies with the scheduler.', example='active'),
      status?: string(name='Status', description='The status of the node. Valid values:

*   uninit: The node is not initialized.
*   init: The node is being initialized.
*   ready: The node is ready.
*   running: The node is running.
*   exception: An exception has occurred on the node.
*   untracking: The node is not added to the cluster.', example='untracking'),
      totalResources?: {
        cpu?: int32(name='Cpu', description='The number of CPU cores. Unit: cores.', example='1'),
        gpu?: int32(name='Gpu', description='The total number of GPU cards. Unit: cards.', example='0'),
        memory?: int32(name='Memory', description='The memory capacity. Unit: GB.', example='1024'),
      }(name='TotalResources', description='The number of all resources in the cluster.'),
      usedResources?: {
        cpu?: int32(name='Cpu', description='The number of CPU cores. Unit: cores.', example='1'),
        gpu?: int32(name='Gpu', description='The total number of GPU cards. Unit: cards.', example='0'),
        memory?: int32(name='Memory', description='The memory capacity. Unit: GB.', example='1'),
      }(name='UsedResources', description='The usage of the compute nodes in the cluster. For other types of nodes, an empty value is returned.'),
      vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch.', example='vsw-bp1e47optm9g58zcu****'),
      version?: string(name='Version', description='The version of the E-HPC client.', example='1.0.64'),
      vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC).', example='vpc-bp1gnu8br4ay7beb2w****'),
      zoneId?: string(name='ZoneId', description='The ID of the zone.', example='cn-hangzhou-b'),
    }
  ](name='NodeInfo')
  }(name='Nodes', description='The list of nodes.'),
  pageNumber?: int32(name='PageNumber', description='The number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='B405FF19-2D5F-4489-A84C-BC15CC1B24BD'),
  totalCount?: int32(name='TotalCount', description='The total number of returned entries.', example='1'),
}

model ListNodesByQueueResponse = {
  headers: map[string]string(name='headers'),
  body: ListNodesByQueueResponseBody(name='body'),
}

async function listNodesByQueue(request: ListNodesByQueueRequest): ListNodesByQueueResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListNodesByQueue', 'GET', '/', 'json', false, 'json', request);
}

model ListNodesNoPagingRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****', position='Query'),
  hostName?: string(name='HostName', description='The name of the node. You can perform a fuzzy search. MySQL regular expressions are supported.', example='Compute0', position='Query'),
  role?: string(name='Role', description='The type of the node. Valid values:

*   Manager: management node
*   Login: logon node
*   Compute: compute node

Default value: Compute', example='Compute', position='Query'),
  sequence?: string(name='Sequence', description='The sorting method of the node list. Valid values:

*   Forward: sorts the nodes in chronological order.
*   Backward: sorts the nodes in reverse chronological order.

Default value: Forward', example='Forward', position='Query'),
}

model ListNodesNoPagingResponseBody = {
  nodes?: {
    nodeInfo?: [ 
    {
      hostName?: string(name='HostName', description='The name of the node.', example='compute0'),
      id?: string(name='Id', description='The ID of the node.', example='i-bp13p7vlcb1uihfv****'),
      imageId?: string(name='ImageId', description='The ID of the image.', example='centos_7_02_64_20G_alibase_20170818****'),
      instanceType?: string(name='InstanceType', description='The instance type of the node.', example='ecs.n1.tiny'),
      status?: string(name='Status', description='The status of the node. Valid values:

*   uninit: The node is being installed.
*   exception: An exception has occurred on the node.
*   running: The node is running.
*   initing: The node is being initialized.
*   releasing: The node is being released.
*   untracking: The node is not added to the cluster.
*   stopped: The node is stopped.', example='untracking'),
    }
  ](name='NodeInfo')
  }(name='Nodes', description='The information about nodes.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model ListNodesNoPagingResponse = {
  headers: map[string]string(name='headers'),
  body: ListNodesNoPagingResponseBody(name='body'),
}

async function listNodesNoPaging(request: ListNodesNoPagingRequest): ListNodesNoPagingResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListNodesNoPaging', 'GET', '/', 'json', false, 'json', request);
}

model ListPreferredEcsTypesRequest {
  instanceChargeType?: string(name='InstanceChargeType', description='The billing method of the ECS instances. Valid values:

*   PostPaid
*   PrePaid', example='PostPaid', position='Query'),
  spotStrategy?: string(name='SpotStrategy', description='The bidding policy of the ECS instance. Valid values:

*   NoSpot: The instance is created as a pay-as-you-go instance.
*   SpotWithPriceLimit: The instance is created as a preemptible instance with a user-defined maximum hourly price.
*   SpotAsPriceGo: The instance is created as a preemptible instance for which the market price at the time of purchase is automatically used as the bidding price.', example='NoSpot', position='Query'),
  zoneId: string(name='ZoneId', description='The zone ID.', example='cn-hangzhou-b', position='Query'),
}

model ListPreferredEcsTypesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
  series?: {
    seriesInfo?: [ 
    {
      roles?: {
        compute?: {
          instanceTypeId?: [ string ](name='InstanceTypeId')
        }(name='Compute', description='The list of recommended ECS instance types for compute nodes.'),
        login?: {
          instanceTypeId?: [ string ](name='InstanceTypeId')
        }(name='Login', description='The list of recommended ECS instance types for logon nodes.'),
        manager?: {
          instanceTypeId?: [ string ](name='InstanceTypeId')
        }(name='Manager', description='The list of recommended ECS instance types for management nodes.'),
      }(name='Roles', description='Recommended instance types for nodes in an E-HPC cluser.'),
      seriesId?: string(name='SeriesId', description='The ECS instance series ID. Valid values:

*   HighCompute: compute-optimized instance families
*   HighMem: memory-optimized instance families
*   GPU: GPU-accelerated instance families
*   All: all instance families', example='All'),
      seriesName?: string(name='SeriesName', description='The instance series name. Valid values:

*   SeriesHighCompute
*   SeriesHighMem
*   SeriesGPU
*   SeriesAll', example='SeriesAll'),
    }
  ](name='SeriesInfo')
  }(name='Series', description='The list of recommended ECS instances. Each series contains the recommended ECS instance types for various nodes of the E-HPC cluster.'),
  supportSpotInstance?: boolean(name='SupportSpotInstance', description='Indicates whether preemptible instances are supported.', example='true'),
}

model ListPreferredEcsTypesResponse = {
  headers: map[string]string(name='headers'),
  body: ListPreferredEcsTypesResponseBody(name='body'),
}

async function listPreferredEcsTypes(request: ListPreferredEcsTypesRequest): ListPreferredEcsTypesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListPreferredEcsTypes', 'GET', '/', 'json', false, 'json', request);
}

model ListQueuesRequest {
  async?: boolean(name='Async', description='Specifies whether to enable asynchronous query.', example='false', position='Query'),
  clusterId: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-FYUr32****', position='Query'),
}

model ListQueuesResponseBody = {
  queues?: {
    queueInfo?: [ 
    {
      computeInstanceType?: {
        instanceType?: [ string ](name='InstanceType')
      }(name='ComputeInstanceType', description='The instance type of the compute nodes.'),
      deploymentSetId?: string(name='DeploymentSetId'),
      enableAutoGrow?: boolean(name='EnableAutoGrow', description='Indicates whether the queue enabled auto scale-out. Valid values:

*   true
*   false', example='false'),
      hostNamePrefix?: string(name='HostNamePrefix', description='The orefix of the host name.', example='compute'),
      hostNameSuffix?: string(name='HostNameSuffix', description='The suffix of the host name.', example='01'),
      imageId?: string(name='ImageId', description='The ID of the custom image.', example='centos_7_06_64_20G_alibase_20****.vhd'),
      queueName?: string(name='QueueName', description='The name of the queue.', example='workq'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the queue belongs.', example='rg-acfmxp7uc24****'),
      spotInstanceTypes?: {
        instance?: [ 
        {
          instanceType?: string(name='InstanceType', description='The instance type of the preemptible instance.', example='ecs.n1.tiny'),
          spotPriceLimit?: float(name='SpotPriceLimit', description='The maximum hourly price of the preemptible instance. The value can be accurate to three decimal places. The parameter takes effect only when SpotStrategy is set to SpotWithPriceLimit.', example='0.062'),
        }
      ](name='Instance')
      }(name='SpotInstanceTypes', description='The information about the preemptible instance.'),
      spotStrategy?: string(name='SpotStrategy', description='The preemption policy of the compute nodes. Valid values:

*   NoSpot: The instance is a regular pay-as-you-go instance.
*   SpotWithPriceLimit: The instance is a preemptible instance with a user-defined maximum hourly price.
*   SpotAsPriceGo: The instance is a preemptible instance for which the market price at the time of purchase is automatically used as the bidding price.', example='NoSpot'),
      type?: string(name='Type', description='The type of the queue. Valid values:

*   Execution: Queues in which jobs can be executed.
*   Router: Queues in which jobs cannot be executed but are forwarded to the bounded Execution queue for processing.', example='Execution'),
    }
  ](name='QueueInfo')
  }(name='Queues', description='The details of the queue.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='C6E5005C-00B0-4F27-98BB-95AB88016C22'),
}

model ListQueuesResponse = {
  headers: map[string]string(name='headers'),
  body: ListQueuesResponseBody(name='body'),
}

async function listQueues(request: ListQueuesRequest): ListQueuesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListQueues', 'GET', '/', 'json', false, 'json', request);
}

model ListRegionsRequest {
}

model ListRegionsResponseBody = {
  regions?: {
    regionInfo?: [ 
    {
      localName?: string(name='LocalName', description='The region name.'),
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
    }
  ](name='RegionInfo')
  }(name='Regions', description='The array of regions.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model ListRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListRegionsResponseBody(name='body'),
}

async function listRegions(request: ListRegionsRequest): ListRegionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListRegions', 'GET', '/', 'json', false, 'json', request);
}

model ListSecurityGroupsRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-FYUr32****', position='Query'),
}

model ListSecurityGroupsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6D9A3378-61CA-4415-BEB0-1168C2A15975'),
  securityGroups?: {
    securityGroup?: [ string ](name='SecurityGroup')
  }(name='SecurityGroups', description='The ID of the security group.'),
  totalCount?: int32(name='TotalCount', description='The number of security groups.', example='1'),
}

model ListSecurityGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: ListSecurityGroupsResponseBody(name='body'),
}

async function listSecurityGroups(request: ListSecurityGroupsRequest): ListSecurityGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListSecurityGroups', 'GET', '/', 'json', false, 'json', request);
}

model ListServerlessJobsRequest {
  clusterId: string(name='ClusterId', example='ehpc-hz-FYUr32****', position='Query'),
  jobIds?: [ string ](name='JobIds', position='Query'),
  jobNames?: [ string ](name='JobNames', position='Query'),
  pageNumber?: long(name='PageNumber', example='1', position='Query'),
  pageSize?: long(name='PageSize', example='20', position='Query'),
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Query'),
  startOrder?: string(name='StartOrder', position='Query'),
  state?: string(name='State', position='Query'),
  submitOrder?: string(name='SubmitOrder', example='asc', position='Query'),
  submitTimeEnd?: string(name='SubmitTimeEnd', position='Query'),
  submitTimeStart?: string(name='SubmitTimeStart', position='Query'),
}

model ListServerlessJobsResponseBody = {
  jobs?: [ 
    {
      endTime?: string(name='EndTime', example='1682128871'),
      isArrayJob?: boolean(name='IsArrayJob', example='True'),
      jobId?: string(name='JobId'),
      jobName?: string(name='JobName'),
      priority?: string(name='Priority', example='9'),
      queue?: string(name='Queue', example='comp'),
      startTime?: string(name='StartTime', example='1647427667'),
      state?: string(name='State', example='Running'),
      submitTime?: string(name='SubmitTime', example='1647423718'),
      user?: string(name='User'),
    }
  ](name='Jobs'),
  pageNumber?: long(name='PageNumber', example='1'),
  pageSize?: long(name='PageSize', example='20'),
  requestId?: string(name='RequestId', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  totalCount?: int32(name='TotalCount', example='1'),
}

model ListServerlessJobsResponse = {
  headers: map[string]string(name='headers'),
  body: ListServerlessJobsResponseBody(name='body'),
}

async function listServerlessJobs(request: ListServerlessJobsRequest): ListServerlessJobsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListServerlessJobs', 'POST', '/', 'json', false, 'json', request);
}

model ListSoftwaresRequest {
  ehpcVersion?: string(name='EhpcVersion', description='The version of the E-HPC client.

You can call the [ListCurrentClientVersion](~~87223~~) operation to query the E-HPC client version.', example='1.0.0', position='Query'),
  osTag?: string(name='OsTag', description='The image tag of the cluster.

You can use the [ListImages](~~87213~~) to query the image tag of the cluster.', example='CentOS_7.2_64', position='Query'),
}

model ListSoftwaresResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  softwares?: {
    softwareInfo?: [ 
    {
      accountType?: string(name='AccountType', description='The service type of the domain account. Valid values:

*   nis
*   ldap', example='nis'),
      accountVersion?: string(name='AccountVersion', description='The version of the domain account service.', example='2.31'),
      applications?: {
        applicationInfo?: [ 
        {
          name?: string(name='Name', description='The name of the software.', example='cudnnt'),
          required?: boolean(name='Required', description='Indicates whether the software is required. Valid values:

*   false: optional
*   true: required', example='true'),
          tag?: string(name='Tag', description='The tag of the software.', example='CUDNN_9.0'),
          version?: string(name='Version', description='The version of the software.', example='9.0'),
        }
      ](name='ApplicationInfo')
      }(name='Applications', description='The list of the software in the cluster.'),
      ehpcVersion?: string(name='EhpcVersion', description='The version of the E-HPC client.', example='1.0.0'),
      osTag?: string(name='OsTag', description='The image tag of the cluster.', example='CentOS_7.2_64'),
      schedulerType?: string(name='SchedulerType', description='The type of the scheduler. Valid values:

*   pbs
*   pbs19
*   slurm
*   slurm19
*   slurm20
*   opengridscheduler
*   deadline
*   gridengine
*   cube
*   custom', example='pbs'),
      schedulerVersion?: string(name='SchedulerVersion', description='The version of the scheduler.', example='18.1.1'),
    }
  ](name='SoftwareInfo')
  }(name='Softwares', description='The list of the information about the software installed in the cluster.'),
}

model ListSoftwaresResponse = {
  headers: map[string]string(name='headers'),
  body: ListSoftwaresResponseBody(name='body'),
}

async function listSoftwares(request: ListSoftwaresRequest): ListSoftwaresResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListSoftwares', 'GET', '/', 'json', false, 'json', request);
}

model ListTagResourcesRequest {
  nextToken?: string(name='NextToken', description='The token used to start the next query.', example='caeba0bbb2be03f84eb48b699f0axxxx', position='Query'),
  regionId: string(name='RegionId', description='The region ID of the resource.', example='cn-hangzhou', position='Query'),
  resourceId?: [ string ](name='ResourceId', description='The resource IDs. You can specify up to 50 IDs.', position='Query'),
  resourceType: string(name='ResourceType', description='The resource type. Set the value to cluster, which indicates E-HPC clusters.', example='cluster', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key.', example='TestKey'),
      value?: string(name='Value', description='The tag value.', example='TestValue'),
    }
  ](name='Tag', description='The resource tags. You can specify up to 20 tags.', position='Query'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken', description='The token that is required for the next query. If the NextToken parameter is empty, no subsequent query is available.', example='caeba0bbb2be03f84eb48b699f0axxxx'),
  requestId?: string(name='RequestId', description='The request ID.', example='484256DA-D816-44D2-9D86-B6EE4D5BA78C'),
  tagResources?: {
    tagResource?: [ 
    {
      resourceId?: string(name='ResourceId', description='The resource ID. Set the value to the ID of the cluster.', example='ehpc-hz-xxxx'),
      resourceType?: string(name='ResourceType', description='The type of the resource whose tags are queried. Set the value to cluster, which indicates E-HPC clusters.', example='cluster'),
      tagKey?: string(name='TagKey', description='The tag key.', example='TestKey'),
      tagValue?: string(name='TagValue', description='The tag value.', example='TestValue'),
    }
  ](name='TagResource')
  }(name='TagResources', description='The tags.'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTagResources', 'POST', '/', 'json', false, 'json', request);
}

model ListTasksRequest {
  archived?: boolean(name='Archived', description='Specifies whether to display the response history of the asynchronous API operation. Valid values:

*   true: displays the current response and response history of the asynchronous API operation.
*   false: displays only the current response of the asynchronous API operation. If no tasks are running, `[]` is returned.

Default value: false

>  If you specify the TaskId parameter, the Archived parameter is invalid.', example='false', position='Query'),
  clusterId: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to obtain the cluster ID.', example='ehpc-hz-FYUr32****', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page 1. Valid values: 1 to 999.', example='1', minimum=1, maximum=999, position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 50.

Default value: 10', example='10', minimum=1, maximum=50, position='Query'),
  taskId?: string(name='TaskId', description='The ID of the task. You can call the following asynchronous API operations to obtain the task ID.

*   [CreateCluster](~~87100~~)
*   [StartCluster](~~200345~~)
*   [StopCluster](~~200346~~)
*   [DeleteCluster](~~87110~~)
*   [AddNodes](~~87147~~)
*   [StartNodes](~~87159~~)
*   [ResetNodes](~~87158~~)
*   [StopNodes](~~87160~~)
*   [DeleteNodes](~~87155~~)', example='B745C159-3155-4B94-95D0-4B73D4D2****', position='Query'),
}

model ListTasksResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='89A1AC0F-4A6C-4F3D-98F9-BEF9A823****'),
  tasks?: [ 
    {
      clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-FYUr32****'),
      currentStep?: int32(name='CurrentStep', description='The current step of the task.', example='16'),
      errors?: string(name='Errors', description='The list of error messages returned for the task.

For information about error messages and their solutions, visit the [API Error Center](https://error-center.alibabacloud.com/status/product/EHPC).', example='[]'),
      request?: string(name='Request', description='The request parameters of the task. The value is a JSON string.', example='{\\"requestId\\":\\"0A6CA33E-BFBF-4F92-BDAE-4E8860DA****\\",\\"uid\\":\\"160998252992****\\",\\"bid\\":\\"268**\\",\\"clusterId\\":\\"ehpc-hz-ysQtcZ****\\"}'),
      result?: string(name='Result', description='The result of the task. Valid values:

*   If TaskType is set to CreateCluster and AddComputes, the value is in the `{\\"Instances\\":[]}` format, which indicates the information of the nodes added to the cluster.
*   If TaskType is set to a value other than CreateCluster and AddComputes, the value is in the `{}` format.', example='{\\"Instances\\":[{\\"InstanceId\\":\\"i-bp1inb1j2xz8pnoi****\\",\\"Ip\\":\\"192.168.*.*\\",\\"Hostname\\":\\"login0\\",\\"role\\":\\"login\\"}]}'),
      status?: string(name='Status', description='The status of the task. Valid values:

*   Processing: The task is running.
*   Success: The task is completed.
*   Fail: The task failed.
*   PartialFail: The task partially failed.', example='Processing'),
      taskId?: string(name='TaskId', description='The ID of the task.', example='B745C159-3155-4B94-95D0-4B73D4D2****'),
      taskType?: string(name='TaskType', description='The type of the task. Valid values:

*   CreateCluster: creates a cluster by calling the [CreateCluster](~~87100~~) operation.
*   StartCluster: starts a cluster by calling the [StartCluster](~~200345~~) operation.
*   StopCluster: stops a cluster by calling the [StopCluster](~~200346~~) operation.
*   DeleteCluster: releases a cluster by calling the [DeleteCluster](~~87110~~) operation.
*   AddComputes: adds nodes to a cluster by calling the [AddNodes](~~87147~~) operation.
*   StartComputes: starts nodes by calling the [StartNodes](~~87159~~) operation.
*   ResetCompute: resets nodes by calling the [ResetNodes](~~87158~~) operation.
*   StopComputes: stops nodes by calling the [StopNodes](~~87160~~) operation.
*   DeleteComputes: deletes nodes by calling the [DeleteNodes](~~87155~~) operation.', example='StopCluster'),
      totalSteps?: int32(name='TotalSteps', description='The total number of steps of the task.', example='35'),
    }
  ](name='Tasks', description='The list of task information.'),
  totalCount?: int32(name='TotalCount', description='The total number of entries of the task.', example='10'),
}

model ListTasksResponse = {
  headers: map[string]string(name='headers'),
  body: ListTasksResponseBody(name='body'),
}

/**
  * If you succeed in calling an asynchronous API operation, a response is generated before a resulting task is completed. Therefore, to query the result of the task, you can use the TaskId parameter returned by the API operation.
  *
 */
async function listTasks(request: ListTasksRequest): ListTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTasks', 'GET', '/', 'json', false, 'json', request);
}

model ListUpgradeClientsRequest {
  clusterId: string(name='ClusterId', description='The upgrade records of the cluster.', example='ehpc-hz-FYUr32****', position='Query'),
  regionId: string(name='RegionId', description='The latest version of the E-HPC client.', example='cn-hangzhou', position='Query'),
}

model ListUpgradeClientsResponseBody = {
  clientRecords?: [ 
    {
      newVersion?: string(name='NewVersion', example='1.2.21'),
      oldVersion?: string(name='OldVersion', example='1.2.16'),
      subUid?: string(name='SubUid', example='129******84'),
      updateTime?: string(name='UpdateTime', example='2022-08-26T06:26:57.000Z'),
    }
  ](name='ClientRecords', description='The time when the operation was performed.'),
  currentVersion?: string(name='CurrentVersion', example='1.2.21'),
  latestVersion?: string(name='LatestVersion', description='The version of the E-HPC client after the upgrade.', example='1.2.22'),
  requestId?: string(name='RequestId', description='The version of the E-HPC client before the upgrade.', example='89A1AC0F-4A6C-4F3D-98F9-BEF9A823****'),
}

model ListUpgradeClientsResponse = {
  headers: map[string]string(name='headers'),
  body: ListUpgradeClientsResponseBody(name='body'),
}

async function listUpgradeClients(request: ListUpgradeClientsRequest): ListUpgradeClientsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListUpgradeClients', 'GET', '/', 'json', false, 'json', request);
}

model ListUsersRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return.

Pages start from page 1.

Default value: 1', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 50.

Default value: 10', example='10', maximum=50, position='Query'),
}

model ListUsersResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  totalCount?: int32(name='TotalCount', description='The total number of returned entries.', example='1'),
  users?: {
    userInfo?: [ 
    {
      addTime?: string(name='AddTime', description='The time when the user was created.', example='2018-07-18T17:46:47'),
      group?: string(name='Group', description='The name of the permission group. Valid values:

*   users: an ordinary permission group. It is applicable to ordinary users that need only to submit and debug jobs.
*   wheel: a sudo permission group. It is applicable to the administrator who needs to manage the cluster. In addition to submitting and debugging jobs, users who have sudo permissions can run sudo commands to install software and restart nodes.', example='wheel'),
      name?: string(name='Name', description='The username.', example='user1'),
    }
  ](name='UserInfo')
  }(name='Users', description='The list of users.'),
}

model ListUsersResponse = {
  headers: map[string]string(name='headers'),
  body: ListUsersResponseBody(name='body'),
}

async function listUsers(request: ListUsersRequest): ListUsersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListUsers', 'GET', '/', 'json', false, 'json', request);
}

model ListUsersAsyncRequest {
  asyncId?: string(name='AsyncId', example='t-hz02xltxaex1q80', position='Query'),
  clusterId: string(name='ClusterId', example='ehpc-hz-vu7c2WkVGx', position='Query'),
  pageNumber?: int32(name='PageNumber', example='1', position='Query'),
  pageSize?: int32(name='PageSize', example='10', maximum=50, position='Query'),
}

model ListUsersAsyncResponseBody = {
  asyncId?: string(name='AsyncId', example='t-sh03egi3mls****'),
  asyncStatus?: string(name='AsyncStatus', example='Success'),
  pageNumber?: int32(name='PageNumber', example='1'),
  pageSize?: int32(name='PageSize', example='10'),
  requestId?: string(name='RequestId', example='9A05F620-ED46-4A57-95F1-C67D6D3C5DD2'),
  totalCount?: int32(name='TotalCount', example='1'),
  users?: {
    userInfo?: [ 
    {
      addTime?: string(name='AddTime', example='2022-09-28T09:05:26.000Z'),
      group?: string(name='Group', example='wheel'),
      groupId?: string(name='GroupId', example='10'),
      name?: string(name='Name', example='testuser'),
      userId?: string(name='UserId', example='1000'),
    }
  ](name='UserInfo')
  }(name='Users'),
}

model ListUsersAsyncResponse = {
  headers: map[string]string(name='headers'),
  body: ListUsersAsyncResponseBody(name='body'),
}

async function listUsersAsync(request: ListUsersAsyncRequest): ListUsersAsyncResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListUsersAsync', 'GET', '/', 'json', false, 'json', request);
}

model ListVolumesRequest {
  pageNumber?: int32(name='PageNumber', description='The number of the page to return.

Pages start from page 1.

Default value: 1', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 50.

Default value: 10', example='10', maximum=50, position='Query'),
}

model ListVolumesResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
  totalCount?: int32(name='TotalCount', description='The total number of returned entries.', example='1'),
  volumes?: {
    volumeInfo?: [ 
    {
      additionalVolumes?: {
        volumeInfo?: [ 
        {
          jobQueue?: string(name='JobQueue', description='The queue to which the job belongs.', example='all.q'),
          localDirectory?: string(name='LocalDirectory', description='The local mount directory.', example='/testopt'),
          location?: string(name='Location', description='The location where the cluster was deployed. Valid values:

*   OnPremise: The cluster is deployed on a hybrid cloud.
*   PublicCloud: The cluster is deployed on a public cloud.', example='PublicCloud'),
          remoteDirectory?: string(name='RemoteDirectory', description='The remote directory on which the file system is mounted.', example='/test'),
          role?: string(name='Role', description='The type of the node on which the file system is mounted. Valid values:

*   Manager: management node
*   Login: logon node
*   Compute: compute node', example='Compute'),
          volumeId?: string(name='VolumeId', description='The ID of the file system.', example='86y3****'),
          volumeMountpoint?: string(name='VolumeMountpoint', description='The domain name of the mount target.', example='86y3****-rgd51.cn-hangzhou.nas.aliyuncs.com'),
          volumeProtocol?: string(name='VolumeProtocol', description='The type of the storage protocol. Valid values:

*   NFS
*   SMB', example='NFS'),
          volumeType?: string(name='VolumeType', description='The type of the additional file system. Only NAS is supported.', example='NAS'),
        }
      ](name='VolumeInfo')
      }(name='AdditionalVolumes', description='The information of additional file systems mounted on E-HPC clusters.'),
      clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-FYUr32****'),
      clusterName?: string(name='ClusterName', description='The name of the cluster.', example='cluster1'),
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
      remoteDirectory?: string(name='RemoteDirectory', description='The remote directory on which the file system is mounted.', example='/test1'),
      volumeId?: string(name='VolumeId', description='The ID of the file system.', example='bc8a****'),
      volumeMountpoint?: string(name='VolumeMountpoint', description='The domain name of the mount target.', example='bc8a****-rgd51.cn-hangzhou.nas.aliyuncs.com'),
      volumeProtocol?: string(name='VolumeProtocol', description='The type of the storage protocol. Valid values:

*   NFS
*   SMB', example='NFS'),
      volumeType?: string(name='VolumeType', description='The type of the file system that is mounted on the cluster. Only NAS is supported.', example='NAS'),
    }
  ](name='VolumeInfo')
  }(name='Volumes', description='The information of file systems that are mounted on E-HPC clusters.'),
}

model ListVolumesResponse = {
  headers: map[string]string(name='headers'),
  body: ListVolumesResponseBody(name='body'),
}

async function listVolumes(request: ListVolumesRequest): ListVolumesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListVolumes', 'GET', '/', 'json', false, 'json', request);
}

model ModifyClusterAttributesRequest {
  clusterId: string(name='ClusterId', description='The ID of the image.', example='ehpc-hz-FYUr32****', position='Query'),
  description?: string(name='Description', example='test-description', position='Query'),
  imageId?: string(name='ImageId', example='centos_7_06_64_20G_alibase_2019071****', position='Query'),
  imageOwnerAlias?: string(name='ImageOwnerAlias', example='self', position='Query'),
  name?: string(name='Name', description='The ID of the request.', example='cluster1', position='Query'),
  ramNodeTypes?: [ string ](name='RamNodeTypes', description='æŽˆæƒå®žä¾‹é…ç½®æ—¶ï¼Œè¦ç»‘å®šRAMè§’è‰²çš„èŠ‚ç‚¹ç±»åž‹ã€‚', position='Query'),
  ramRoleName?: string(name='RamRoleName', description='æŽˆæƒå®žä¾‹é…ç½®æ—¶ï¼Œå®žä¾‹RAMè§’è‰²çš„åç§°ã€‚', example='testRamRoleName', position='Query'),
  winAdPar?: {
    adDc?: string(name='AdDc'),
    adIp?: string(name='AdIp'),
    adUser?: string(name='AdUser'),
    adUserPasswd?: string(name='AdUserPasswd'),
    fallbackHomeDir?: string(name='FallbackHomeDir'),
  }(name='WinAdPar', position='Query'),
}

model ModifyClusterAttributesResponseBody = {
  requestId?: string(name='RequestId', example='04F0F334-1335-436C-A1D7-6C044FE7336'),
}

model ModifyClusterAttributesResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyClusterAttributesResponseBody(name='body'),
}

/**
  * The new cluster name.
  *
 */
async function modifyClusterAttributes(request: ModifyClusterAttributesRequest): ModifyClusterAttributesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyClusterAttributes', 'GET', '/', 'json', false, 'json', request);
}

model ModifyContainerAppAttributesRequest {
  containerId: string(name='ContainerId', description='The ID of the container.

You can call the [ListContainerApps](~~87333~~) operation to query the ID of the containerized application.', example='ehpc-container-ABDUGSkjs****', position='Query'),
  description?: string(name='Description', description='The new description of the containerized application.', example='ExampleDescription', position='Query'),
}

model ModifyContainerAppAttributesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model ModifyContainerAppAttributesResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyContainerAppAttributesResponseBody(name='body'),
}

async function modifyContainerAppAttributes(request: ModifyContainerAppAttributesRequest): ModifyContainerAppAttributesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyContainerAppAttributes', 'GET', '/', 'json', false, 'json', request);
}

model ModifyImageGatewayConfigRequest {
  regionId?: string(name='RegionId', position='Host'),
  clusterId: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-FYUr32****', position='Query'),
  DBPassword?: string(name='DBPassword', description='The password that is used to log on to the database instance.', example='13****', position='Query'),
  DBServerInfo?: string(name='DBServerInfo', description='The URI of the database.', example='dds-uf6628e4287716b433270.mongodb.rds.aliyuncs.com:3717/admin', position='Query'),
  DBType?: string(name='DBType', description='The type of the database. Set the value to mongodb.', example='mongodb', position='Query'),
  DBUsername?: string(name='DBUsername', description='The username of the account that is used to log on to the database.', example='root', position='Query'),
  defaultRepoLocation?: string(name='DefaultRepoLocation', description='The default repository service. Set the value to registry-1.docker.io.', example='registry-1.docker.io', position='Query'),
  imageExpirationTimeout?: string(name='ImageExpirationTimeout', description='The timeout period for deleting images.', example='12:00:00', position='Query'),
  pullUpdateTimeout?: int32(name='PullUpdateTimeout', description='The timeout period for pulling images.', example='300', position='Query'),
  repo?: [ 
    {
      auth?: string(name='Auth', description='The authentication method of the repository. Valid values:

*   http
*   https

Default value: http.', example='http'),
      location?: string(name='Location', description='The address of the repository N.', example='registry.docker-cn.com'),
      URL?: string(name='URL', description='The URL of the repository. The URL is required to add a repository address.', example='https://registry.docker-cn.com'),
    }
  ](name='Repo', description='The information about the repository.', position='Query'),
}

model ModifyImageGatewayConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model ModifyImageGatewayConfigResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyImageGatewayConfigResponseBody(name='body'),
}

async function modifyImageGatewayConfig(request: ModifyImageGatewayConfigRequest): ModifyImageGatewayConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyImageGatewayConfig', 'GET', '/', 'json', false, 'json', request);
}

model ModifyUserGroupsRequest {
  async?: boolean(name='Async', description='Specifies whether to enable the asynchronous mode for this request.

Default value: false.', example='false', position='Query'),
  clusterId: string(name='ClusterId', description='The cluster ID.

You can call the [ListClusters](~~87116~~) operation to obtain the cluster ID.', example='ehpc-hz-FYUr32****', position='Query'),
  user: [ 
    {
      group?: string(name='Group', description='The new permission group of the user N. Valid values:

*   users: an ordinary permission group. It is applicable to ordinary users that need only to submit and debug jobs.
*   wheel: a sudo permission group. It is applicable to the administrator who needs to manage the cluster. In addition to submitting and debugging jobs, users who have sudo permissions can run sudo commands to install software and restart nodes.', example='users'),
      name?: string(name='Name', description='The name of the user N whose permissions you want to modify. Valid values of N: 1 to 100.

You can call the [ListUsers](~~188572~~) operation to query the users of the cluster.', example='user11'),
    }
  ](name='User', description='The information about the user.', position='Query'),
}

model ModifyUserGroupsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model ModifyUserGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyUserGroupsResponseBody(name='body'),
}

async function modifyUserGroups(request: ModifyUserGroupsRequest): ModifyUserGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyUserGroups', 'GET', '/', 'json', false, 'json', request);
}

model ModifyUserPasswordsRequest {
  async?: boolean(name='Async', description='Specifies whether to enable the asynchronous mode for this request.

Default value: false.', example='false', position='Query'),
  clusterId: string(name='ClusterId', description='The cluster ID.

You can call the [ListClusters](~~87116~~) operation to obtain the cluster ID.', example='ehpc-hz-FYUr32****', position='Query'),
  user: [ 
    {
      name?: string(name='Name', description='The name of the user N whose password you want to modify. Valid values of N: 1 to 100.

You can call the [ListUsers](~~188572~~) operation to query the users of the cluster.', example='user1'),
      password?: string(name='Password', description='The password of the Nth user. The password must be 8 to 30 characters in length and contain three of the following items:

*   Uppercase letter
*   Lowercase letter
*   Digit
*   Special character: `()~!@#$%^&*-_+=|{}[]:;\\"/<>,.?/`

Valid values of N: 1 to 100.

>  We recommend that you use HTTPS to call API operations to avoid password leaks.', example='1@a****'),
    }
  ](name='User', description='The information about the user.', position='Query'),
}

model ModifyUserPasswordsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model ModifyUserPasswordsResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyUserPasswordsResponseBody(name='body'),
}

async function modifyUserPasswords(request: ModifyUserPasswordsRequest): ModifyUserPasswordsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyUserPasswords', 'GET', '/', 'json', false, 'json', request);
}

model ModifyVisualServicePasswdRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-jeJki6****', position='Query'),
  passwd: string(name='Passwd', description='The connection password of the VNC remote visualization service. The password must be 8 to 30 characters in length and include at least three of the following character types: uppercase letters, lowercase letters, digits, and special characters. Special characters include:

`()~! @#$%^&*-_+=|{}[]:;\\"/<>,.? /`

>  You must use HTTPS to call the API to ensure that the password remains confidential.', example='1254****', position='Query'),
  runasUser: string(name='RunasUser', description='The username of the cluster. Default value: root user. You can call the [ListUsers](~~188572~~) operation to query all users in a cluster.', example='root', position='Query'),
  runasUserPassword: string(name='RunasUserPassword', description='The user password of the cluster.', example='2145****', position='Query'),
}

model ModifyVisualServicePasswdResponseBody = {
  message?: string(name='Message', description='The status of the VNC Remote visualization service. Valid values:

*   Service started.: started
*   Service stopped.: stopped', example='Service started.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='896D338C-E4F4-41EC-A154-D605E5DE6880'),
}

model ModifyVisualServicePasswdResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyVisualServicePasswdResponseBody(name='body'),
}

async function modifyVisualServicePasswd(request: ModifyVisualServicePasswdRequest): ModifyVisualServicePasswdResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyVisualServicePasswd', 'GET', '/', 'json', false, 'json', request);
}

model MountNFSRequest {
  instanceId: string(name='InstanceId', description='The ID of the visualization instance.', example='i-bp1bzqq4rremun****', position='Query'),
  mountDir: string(name='MountDir', description='The local mount directory.', example='Z:', position='Query'),
  nfsDir: string(name='NfsDir', description='The address of the mount target.', example='\\\\0de-jup****.cn-hangzhou.nas.aliyuncs.com\\', position='Query'),
  protocolType?: string(name='ProtocolType', description='The type of the protocol. Valid values:

*   nfs
*   smb', example='nfs', position='Query'),
  remoteDir?: string(name='RemoteDir', description='The remote mount address.', example='/test', position='Query'),
}

model MountNFSResponseBody = {
  invokeId?: string(name='InvokeId', description='The ID of the execution.', example='t-hz0jdfwd9f****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='6FDDFC21-40CD-4DB2-9978-012AB7FC9BDW'),
}

model MountNFSResponse = {
  headers: map[string]string(name='headers'),
  body: MountNFSResponseBody(name='body'),
}

async function mountNFS(request: MountNFSRequest): MountNFSResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'MountNFS', 'GET', '/', 'json', false, 'json', request);
}

model PullImageRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-nkKsP3****', position='Query'),
  containerType?: string(name='ContainerType', description='The type of the image. Default value: shifter.', example='shifter', position='Query'),
  imageTag?: string(name='ImageTag', description='The tag of the image. Default value: latest.', example='latest', position='Query'),
  repository: string(name='Repository', description='The name of the repository.', example='centos', position='Query'),
}

model PullImageResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='29d3d9Ee-8eCB-5013-A1c2-1CeD19C6CfFe'),
}

model PullImageResponse = {
  headers: map[string]string(name='headers'),
  body: PullImageResponseBody(name='body'),
}

async function pullImage(request: PullImageRequest): PullImageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PullImage', 'GET', '/', 'json', false, 'json', request);
}

model QueryServicePackAndPriceRequest {
}

model QueryServicePackAndPriceResponseBody = {
  chargeAmount?: int32(name='ChargeAmount', example='167'),
  currency?: string(name='Currency', example='CNY'),
  discountPrice?: float(name='DiscountPrice', example='0.418'),
  originalAmount?: int32(name='OriginalAmount', example='3191'),
  originalPrice?: float(name='OriginalPrice', example='3.34'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  requestId?: string(name='RequestId', example='3B2E8108-7068-413E-BCA7-CAAB25D46408'),
  servicePack?: {
    servicePackInfo?: [ 
    {
      capacity?: int32(name='Capacity', example='2000'),
      endTime?: int32(name='EndTime', example='1612705988'),
      instanceName?: string(name='InstanceName', example='EHPCBAG-cn-78v12vbme0****'),
      startTime?: int32(name='StartTime', example='1610027588'),
    }
  ](name='ServicePackInfo')
  }(name='ServicePack'),
  tradePrice?: float(name='TradePrice', example='2.922'),
}

model QueryServicePackAndPriceResponse = {
  headers: map[string]string(name='headers'),
  body: QueryServicePackAndPriceResponseBody(name='body'),
}

async function queryServicePackAndPrice(request: QueryServicePackAndPriceRequest): QueryServicePackAndPriceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryServicePackAndPrice', 'GET', '/', 'json', false, 'json', request);
}

model RecoverClusterRequest {
  accountType?: string(name='AccountType', description='The service type of the domain account. Valid values:

*   nis
*   ldap

Default value: nis', example='nis', position='Query'),
  clientVersion?: string(name='ClientVersion', description='The version of the E-HPC client. The default value is the latest version of the client.

You can call the [ListCurrentClientVersion](~~87223~~) operation to query the current version of the E-HPC client.', example='1.0.76', position='Query'),
  clusterId: string(name='ClusterId', description='The ID of the cluster. The cluster must be in the Exception state.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID and status.', example='ehpc-hz-FYUr32****', position='Query'),
  imageId?: string(name='ImageId', description='The ID of the image.

You can call the [ListImages](~~87213~~) and [ListCustomImages](~~87215~~) operations to query the images that are supported by E-HPC.', example='m-bp18133n0335yq****', position='Query'),
  imageOwnerAlias?: string(name='ImageOwnerAlias', description='The type of the image. Valid values:

*   system: public image
*   self: custom image
*   others: shared image

Default value: system', example='system', position='Query'),
  osTag?: string(name='OsTag', description='The image tag of the operating system.

You can call the [ListImages](~~87213~~) and [ListCustomImages](~~87215~~) operations to query the image tags supported by Elastic High Performance Computing (E-HPC).', example='CentOS_7.2_64', position='Query'),
  schedulerType?: string(name='SchedulerType', description='The type of the scheduler. Valid values:

*   pbs
*   slurm
*   opengridscheduler
*   deadline

Default value: pbs', example='pbs', position='Query'),
}

model RecoverClusterResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='18FB21E3-F423-4B84-BB63-D8887A29****'),
  taskId?: string(name='TaskId', description='The ID of the task.', example='18FB21E3-F423-4B84-BB63-D8887A29****'),
}

model RecoverClusterResponse = {
  headers: map[string]string(name='headers'),
  body: RecoverClusterResponseBody(name='body'),
}

/**
  * You can call the operation to reset and restore a cluster only when the cluster is in the Exception state. You can call the [ListClusters](~~87116~~) operation to query the ID and status of a cluster.
  * We recommend that you export all job data before you restore a cluster. When you reset and restore a cluster, take note of the following impacts:
  * *   The system disks of all nodes are changed. By default, new system disks are configured based on the settings that you specified when the cluster was created.
  * *   The data on the system disks and data disks of all cluster nodes is lost. The data includes user information, job information, scheduler queue information, and configuration data of auto-scaling queues. However, the data on Apsara File Storage NAS file systems is retained.
  * *   The self-managed queues in the cluster are deleted. All nodes are retained and migrated to the default queue of the cluster.
  *
 */
async function recoverCluster(request: RecoverClusterRequest): RecoverClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RecoverCluster', 'GET', '/', 'json', false, 'json', request);
}

model RerunJobsRequest {
  async?: boolean(name='Async', description='Specifies whether to use an asynchronous link to rerun the job.

Default value: false', example='false', position='Query'),
  clusterId: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-sh-3VeFyR****', position='Query'),
  jobs: string(name='Jobs', description='The list of jobs that you want to run. Maximum number of jobs: 100. Minimum number of jobs: 1.

Format: `[{"Id": "0.sched****"},{"Id": "1.sched****"}]`. Separate multiple jobs with commas (,).

You can call the [ListJobs](~~87251~~) operation to query the job ID.

>  You can rerun only jobs that are in the RUNNING or QUEUED state.', example='[{"Id":"1.scheduler"}]', position='Query'),
}

model RerunJobsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model RerunJobsResponse = {
  headers: map[string]string(name='headers'),
  body: RerunJobsResponseBody(name='body'),
}

async function rerunJobs(request: RerunJobsRequest): RerunJobsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RerunJobs', 'GET', '/', 'json', false, 'json', request);
}

model ResetNodesRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****', position='Query'),
  instance: [ 
    {
      id?: string(name='Id', description='The ID of the compute node that you want to reset. Valid values of N: 1 to 100

You can call the [ListNodes](~~87161~~) operation to query the IDs of the compute nodes.', example='i-bp13p7vlcb1uihfv****'),
    }
  ](name='Instance', position='Query'),
}

model ResetNodesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  taskId?: string(name='TaskId', description='The ID of the task.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model ResetNodesResponse = {
  headers: map[string]string(name='headers'),
  body: ResetNodesResponseBody(name='body'),
}

/**
  * After a node is reset, the operating system and software return to their initial states. To ensure that jobs run as expected, we recommend that you do not reset running nodes unless you need to perform crash recovery.
  *
 */
async function resetNodes(request: ResetNodesRequest): ResetNodesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ResetNodes', 'GET', '/', 'json', false, 'json', request);
}

model RunCloudMetricProfilingRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-jeJki6****', position='Query'),
  duration?: int32(name='Duration', description='The duration of the profiling process. Unit: seconds.

Value values: 10 to 300

Default value: 30', example='300', position='Query'),
  freq?: int32(name='Freq', description='The sampling frequency. Unit: Hz

Valid values: 1 to 2000

Default value: 2000', example='2000', position='Query'),
  hostName: string(name='HostName', description='The name of the host.', example='compute0', position='Query'),
  processId: int32(name='ProcessId', description='The ID of the profiling process.', example='29075', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region where the cluster resides.', example='cn-hangzhou', position='Query'),
}

model RunCloudMetricProfilingResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='8442AF35-875B-4FC0-8B7AAFDC339335D5'),
}

model RunCloudMetricProfilingResponse = {
  headers: map[string]string(name='headers'),
  body: RunCloudMetricProfilingResponseBody(name='body'),
}

async function runCloudMetricProfiling(request: RunCloudMetricProfilingRequest): RunCloudMetricProfilingResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RunCloudMetricProfiling', 'GET', '/', 'json', false, 'json', request);
}

model SetAutoScaleConfigRequest {
  clusterId: string(name='ClusterId', description='## Usage notes

If the settings in the Queue Configuration section are different from the settings in the Global Configurations section, the former prevails.', example='ehpc-hz-FYUr32****', position='Query'),
  computeEnableHt?: boolean(name='ComputeEnableHt', description='The minimum number of compute nodes that can be added in each round of an auto scale-out task. Valid values: 1 to 99.

Default value: 1.

If the number of compute nodes that you want to add in a round is less than the value of this property, the system automatically changes the value of this property to the number of compute nodes that you want to add in a round. This helps ensure that compute nodes can be added as expected.

> The configuration takes effect only for the minimum compute nodes that can be added in the current round.', example='true', position='Query'),
  dnsConfig?: string(name='DnsConfig', position='Query'),
  enableAutoGrow?: boolean(name='EnableAutoGrow', description='The ID of the cluster.', example='false', position='Query'),
  enableAutoShrink?: boolean(name='EnableAutoShrink', description='Specifies whether to enable auto scale-out. Valid values:

*   true: enables auto scale-out.
*   false: disables auto scale-out.

Default value: false.', example='false', position='Query'),
  excludeNodes?: string(name='ExcludeNodes', description='The maximum number of compute nodes that can be added to the cluster. Valid values: 0 to 500.

Default value: 100.', example='i-bp19lgqwxb4206t5****,i-bp1g4hvzs9pywrhb****', position='Query'),
  extraNodesGrowRatio?: int32(name='ExtraNodesGrowRatio', description='The scale-out timeout period. Unit: minutes.

Valid values: 10 to 60.

Default value: 20.

If the scale-out timeout period has been reached but the scale-out nodes still do not reach the Running state, the system releases them.', example='0', position='Query'),
  growIntervalInMinutes?: int32(name='GrowIntervalInMinutes', description='Specifies whether to enable auto scale-in. Valid values:

*   true: enables auto scale-in.
*   false: disables auto scale-in.

Default value: false.', example='2', position='Query'),
  growRatio?: int32(name='GrowRatio', description='The percentage of extra compute nodes. Valid values: 0 to 100.

Default value: 0.

If you need to add 100 compute nodes and the value of the ExtraNodesGrowRatio parameter is 2, 102 compute nodes are added.', example='50', maximum=100, position='Query'),
  growTimeoutInMinutes?: int32(name='GrowTimeoutInMinutes', description='The number of consecutive times that a compute node is idle during the resource scale-in check.

Valid values: 2 to 5.

Default value: 3.

If the parameter is set to 3, a compute node is released if it is idle for more than three consecutive times. If a compute node is idle for more than 6 minutes in a row, it is released by default. This is because the default value of the ShrinkIntervalInMinutes parameter is 2.', example='20', position='Query'),
  imageId?: string(name='ImageId', description='The maximum hourly price of the compute nodes. The value can be accurate to three decimal places. The parameter takes effect only when `SpotStrategy` is set to `SpotWithPriceLimit`.', example='centos_7_03_64_20G_alibase_201708****', position='Query'),
  maxNodesInCluster: int32(name='MaxNodesInCluster', description='The percentage of each round of a scale-out task. Valid values: 1 to 100.

Default value: 100.

If you set GrowRatio to 50, the scale-out has two rounds. Each round completes half of the scale-out.', example='100', position='Query'),
  queues?: [ 
    {
      dataDisks?: [ 
        {
          dataDiskCategory?: string(name='DataDiskCategory', description='The size of the data disk. Unit: GB.

Valid values: 40 to 500.

Default value: 40.

Valid values of N: 0 to 16.', example='cloud_efficiency'),
          dataDiskDeleteWithInstance?: boolean(name='DataDiskDeleteWithInstance', description='The type of the data disk. Valid values:

*   cloud_efficiency: ultra disk
*   cloud_ssd: SSD
*   cloud_essd: ESSD
*   cloud: basic disk

Default value: cloud_efficiency.

Valid values of N: 0 to 16.', example='true'),
          dataDiskEncrypted?: boolean(name='DataDiskEncrypted', description='The performance level of the ESSD used as the data disk. The parameter takes effect only when the Queues.N.DataDisks.N.DataDiskCategory parameter is set to cloud_essd. Valid values:

*   PL0: A single ESSD can deliver up to 10,000 random read/write IOPS.
*   PL1: A single ESSD can deliver up to 50,000 random read/write IOPS.
*   PL2: A single ESSD can deliver up to 100,000 random read/write IOPS.
*   PL3: A single ESSD can deliver up to 1,000,000 random read/write IOPS.

Default value: PL1.

Valid values of N: 0 to 16.', example='false'),
          dataDiskKMSKeyId?: string(name='DataDiskKMSKeyId', description='Specifies whether to encrypt the data disk. Valid values:

*   true
*   false

Default value: false.

Valid values of N: 0 to 16.', example='0e478b7a-4262-4802-b8cb-00d3fb40826X'),
          dataDiskPerformanceLevel?: string(name='DataDiskPerformanceLevel', description='Specifies whether the data disk is released when the node is released. Valid values:

*   true
*   false

Default value: true.

Valid values of N: 0 to 16.', example='PL1'),
          dataDiskSize?: int32(name='DataDiskSize', description='The list of data disks.', example='40'),
        }
      ](name='DataDisks', description='The interruption mode of the preemptible instance. Default value: Terminate. Set the value to Terminate, which indicates that the instance is released.'),
      enableAutoGrow?: boolean(name='EnableAutoGrow', description='The name of the queue. The names of N queues can be set at the same time. Valid values of N: 1 to 8.', example='false'),
      enableAutoShrink?: boolean(name='EnableAutoShrink', description='The maximum number of the compute nodes that can be added in the queue. Valid values: 0 to 500.

Valid values of N: 1 to 8.

Default value: 100.', example='false'),
      hostNamePrefix?: string(name='HostNamePrefix', description='The bidding method of the compute nodes that are automatically added in the queue. Valid values of N: 1 to 8.

Valid values:

*   NoSpot: The compute nodes are pay-as-you-go instances.
*   SpotWithPriceLimit: The compute nodes are preemptible instances that have a user-defined maximum hourly price.
*   SpotAsPriceGo: The compute nodes are preemptible instances for which the market price at the time of purchase is used as the bid price.

Default value: NoSpot.', example='compute'),
      hostNameSuffix?: string(name='HostNameSuffix', description='The instance type of the compute nodes that are automatically added in the queues. Valid values of N: 1 to 8.', example='000'),
      instanceType?: string(name='InstanceType', description='The type of the system disk specified for the compute nodes that are added in the queue. Valid values:

*   cloud_efficiency: ultra disk
*   cloud_ssd: SSD
*   cloud_essd: ESSD
*   cloud: basic disk. Disks of this type are retired.

Valid values of N: 1 to 8.

Default value: cloud_efficiency.', example='ecs.n1.medium'),
      instanceTypes?: [ 
        {
          instanceType?: string(name='InstanceType', description='The maximum hourly price of the compute nodes that are automatically added in the queue. The value can be accurate to three decimal places. The parameter takes effect only when `Queues.N.InstanceTypes.N.SpotStrategy` is set to `SpotWithPriceLimit`.

The names of N queues can be set at the same time. Valid values of N: 1 to 8.

The maximum hourly prices of N compute nodes in the queue can be set at the same time when auto scaling is performed in the queue. Valid values of N: 0 to 500.', example='ecs.n1.tiny'),
          spotDuration?: int32(name='SpotDuration', description='The bidding method of the compute nodes that are automatically added in the queue. Valid values:

*   NoSpot: The compute nodes are pay-as-you-go instances.
*   SpotWithPriceLimit: The compute nodes are preemptible instances that have a user-defined maximum hourly price.
*   SpotAsPriceGo: The compute nodes are preemptible instances for which the market price at the time of purchase is used as the bid price.

Default value: NoSpot.

The names of N queues can be set at the same time. Valid values of N: 1 to 8.

The bidding methods of N compute nodes in the queue can be set at the same time when auto scaling is performed in the queue. Valid values of N: 0 to 500.', example='0'),
          spotInterruptionBehavior?: string(name='SpotInterruptionBehavior', description='The protection period of the preemptible instance. Unit: hours. Valid values: 0 to 1. A value of 0 means that no protection period is specified. Default value: 1.', example='Terminate'),
          spotPriceLimit?: float(name='SpotPriceLimit', description='The zone ID of the compute nodes that are automatically added to the queues.

The names of N queues can be set at the same time. Valid values of N: 1 to 8.

The zone IDs of N compute nodes in the queue can be set at the same time when auto scaling is performed in the queue. Valid values of N: 0 to 500.', example='0.660'),
          spotStrategy?: string(name='SpotStrategy', description='The instance type of the compute nodes that are automatically added in the queue.

The names of N queues can be set at the same time. Valid values of N: 1 to 8.

The instance types of N compute nodes in the queue can be set at the same time when auto scaling is performed in the queue. Valid values of N: 0 to 500.', example='SpotWithPriceLimit'),
          vSwitchId?: string(name='VSwitchId', description='The array of node information.', example='vsw-bp1lfcjbfb099rrjn****'),
          zoneId?: string(name='ZoneId', description='The vSwitch ID of the compute nodes that are automatically added to the queues.

The names of N queues can be set at the same time. Valid values of N: 1 to 8.

The vSwitch IDs of N compute nodes in the queue can be set at the same time when auto scaling is performed in the queue. Valid values of N: 0 to 500.', example='cn-hangzhou-b'),
        }
      ](name='InstanceTypes', description='The maximum hourly price of the compute nodes that are automatically added in the queue. The value can be accurate to three decimal places. The parameter takes effect only when `Queues.N.SpotStrategy` is set to `SpotWithPriceLimit`.

Valid values of N: 1 to 8.'),
      maxNodesInQueue?: int32(name='MaxNodesInQueue', description='The size of the system disk specified for the compute nodes that are added to the queue. Unit: GB.

Valid values: 40 to 500.

Valid values of N: 1 to 8.

Default value: 40.', example='30'),
      maxNodesPerCycle?: long(name='MaxNodesPerCycle', description='The KMS key ID of the data disk.

Valid values of N: 0 to 16.', example='20'),
      minNodesInQueue?: int32(name='MinNodesInQueue', description='The hostname prefix of the host that is used to perform scale-out for the queue. You can manage compute nodes that have a specified hostname prefix.

Valid values of N: 1 to 8.', example='0'),
      minNodesPerCycle?: long(name='MinNodesPerCycle', description='The maximum number of compute nodes that can be added in each round of an auto scale-out task. Valid values: 0 to 99.

Default value: 0.', example='5'),
      queueImageId?: string(name='QueueImageId', description='The array of information about queues.', example='centos_7_03_64_20G_alibase_201708****'),
      queueName?: string(name='QueueName', description='Specifies whether the queue enables auto scale-in. Valid values:

*   true: enables auto scale-in.
*   false: disables auto scale-in

Valid values of N: 1 to 8.

Default value: false.', example='cluster1'),
      sortedByInventory?: boolean(name='SortedByInventory'),
      spotPriceLimit?: float(name='SpotPriceLimit', description='The performance level of the system disk specified for the compute nodes that are added to the queue. Valid values:

*   PL0: A single ESSD can deliver up to 10,000 random read/write IOPS.
*   PL1: A single ESSD can deliver up to 50,000 random read/write IOPS.
*   PL2: A single ESSD can deliver up to 100,000 random read/write IOPS.
*   PL3: A single ESSD can deliver up to 1,000,000 random read/write IOPS.

Valid values of N: 1 to 8.

Default value: PL1.', example='0.662'),
      spotStrategy?: string(name='SpotStrategy', description='The hostname suffix of the host that is used to perform scale-out for the queue. You can manage nodes that have a specified hostname suffix.

Valid values of N: 1 to 8.', example='NoSpot'),
      systemDiskCategory?: string(name='SystemDiskCategory', description='The image ID of the queue where scale-out is performed. Valid values of N: 1 to 8.

> 

*   If both `Queues.N.QueueImageId` and `ImageId` are specified, `Queues.N.QueueImageId` prevails.

*   If you set `Queues.N.QueueImageId` or `ImageId`, the parameter that you set takes effect.
*   If you leave both `Queues.N.QueueImageId` and `ImageId` empty, the image that was specified when you created the cluster or the last time when you scaled out the cluster is used by default.', example='cloud_efficiency'),
      systemDiskLevel?: string(name='SystemDiskLevel', description='Specifies whether the queue enables auto scale-out. Valid values:

*   true: enables auto scale-out.
*   false: disables auto scale-out.

Valid values of N: 1 to 8.

Default value: false.', example='PL1'),
      systemDiskSize?: int32(name='SystemDiskSize', description='The minimum number of the compute nodes that can be removed in the queue. Valid values: 0 to 50.

Valid values of N: 1 to 8.

Default value: 0.', example='40'),
    }
  ](name='Queues', description='The IDs of the images.

> 

*   If both `Queues.N.QueueImageId` and `ImageId` are specified, `Queues.N.QueueImageId` prevails.

*   If you set `Queues.N.QueueImageId` or `ImageId`, the parameter that you set takes effect.
*   If you leave both `Queues.N.QueueImageId` and `ImageId` empty, the image that was specified when you created the cluster or the last time when you scaled out the cluster is used by default.', position='Query'),
  shrinkIdleTimes?: int32(name='ShrinkIdleTimes', description='The interval between two consecutive rounds of scale-in. Unit: minutes.

Valid values: 2 to 10.

Default value: 2.', example='3', position='Query'),
  shrinkIntervalInMinutes?: int32(name='ShrinkIntervalInMinutes', description='The interval between two consecutive rounds of scale-out. Unit: minutes.

Valid values: 2 to 10.

Default value: 2.

> An interval may exist during multiple rounds of a scale-out task or between two consecutive scale-out tasks.', example='2', position='Query'),
  spotPriceLimit?: float(name='SpotPriceLimit', description='The preemption policy of the compute nodes. Valid values:

*   NoSpot: The compute nodes are pay-as-you-go instances.
*   SpotWithPriceLimit: The compute nodes are preemptible instances that have a user-defined maximum hourly price.
*   SpotAsPriceGo: The compute nodes are preemptible instances for which the market price at the time of purchase is used as the bid price.

Default value: NoSpot.', example='0.062', position='Query'),
  spotStrategy?: string(name='SpotStrategy', description='The compute nodes that are excluded from auto scaling tasks. Separate multiple compute nodes with commas (,).

If you want to retain a compute node, you can specify the node as an additional node to retain the node when it is idle.', example='SpotWithPriceLimit', position='Query'),
}

model SetAutoScaleConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-13358736C-A1D7-6C044FE7****'),
}

model SetAutoScaleConfigResponse = {
  headers: map[string]string(name='headers'),
  body: SetAutoScaleConfigResponseBody(name='body'),
}

/**
  * Configures the auto scaling settings of a cluster.
  *
 */
async function setAutoScaleConfig(request: SetAutoScaleConfigRequest): SetAutoScaleConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetAutoScaleConfig', 'GET', '/', 'json', false, 'json', request);
}

model SetGWSClusterPolicyRequest {
  asyncMode?: boolean(name='AsyncMode', description='Specifies whether to support the asynchronous calls.

*   false: not supported. The result is returned after the request is completed.
*   true: supported. The result is immediately returned while the request is being processed.

Default value: false.', example='true', position='Query'),
  clipboard: string(name='Clipboard', description='The permissions on the clipboard. Valid values:

*   read: read-only. You can copy data from your local computer to the cloud desktop, but cannot copy data from the cloud desktop to your local computer.
*   readwrite: read and write. You can copy data between your local computer and the cloud desktop.
*   off: disabled. You cannot copy data between your local computer and the cloud desktop.

Default value: off.', example='readwrite', position='Query'),
  clusterId: string(name='ClusterId', description='The ID of the visualization service.', example='gws-rhz99q8rc****', position='Query'),
  localDrive: string(name='LocalDrive', description='The permissions on local disk mapping. Valid values:

*   read: read-only. The disks on your local computer are mapped to the cloud desktop. You can only read (copy) files on the local computer, but cannot modify the files.
*   readwrite: read and write. The disks on your local computer are mapped to the cloud desktop. You can read (copy) and modify files on your local computer.
*   off: disabled. The disks on your local computer are not mapped to the cloud desktop.

Default value: off.', example='read', position='Query'),
  udpPort?: string(name='UdpPort', description='The UDP port. Valid values:

*   on
*   off

Default value: on.', example='on', position='Query'),
  usbRedirect: string(name='UsbRedirect', description='The USB redirection feature. Valid values:

*   on
*   off

Default value: off.', example='on', position='Query'),
  watermark: string(name='Watermark', description='The watermarking feature. Valid values:

*   on
*   off

Default value: off.', example='on', position='Query'),
}

model SetGWSClusterPolicyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='142951B5-815A-4324-B598-6E1C11FBF6E4'),
}

model SetGWSClusterPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: SetGWSClusterPolicyResponseBody(name='body'),
}

async function setGWSClusterPolicy(request: SetGWSClusterPolicyRequest): SetGWSClusterPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetGWSClusterPolicy', 'POST', '/', 'json', false, 'json', request);
}

model SetGWSInstanceNameRequest {
  instanceId: string(name='InstanceId', example='i-bp1bzqq4rj1eemun****', position='Query'),
  name: string(name='Name', example='c0-i01-1-g6-2c8g', position='Query'),
}

model SetGWSInstanceNameResponseBody = {
  requestId?: string(name='RequestId', example='0505220-2409-4B78-B7B6-CD5F294518C9'),
}

model SetGWSInstanceNameResponse = {
  headers: map[string]string(name='headers'),
  body: SetGWSInstanceNameResponseBody(name='body'),
}

async function setGWSInstanceName(request: SetGWSInstanceNameRequest): SetGWSInstanceNameResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetGWSInstanceName', 'GET', '/', 'json', false, 'json', request);
}

model SetGWSInstanceUserRequest {
  instanceId: string(name='InstanceId', description='The ID of the visualization instance.', example='i-bp1bzqq4rj1eemun****', position='Query'),
  userName?: string(name='UserName', description='The name of the user.', example='test_****', position='Query'),
  userUid?: string(name='UserUid', description='The ID of the user.', example='217346586905362****', position='Query'),
}

model SetGWSInstanceUserResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CDC4FF2F-62DB-48D2-B342-A3B9E2684B99rrwr'),
}

model SetGWSInstanceUserResponse = {
  headers: map[string]string(name='headers'),
  body: SetGWSInstanceUserResponseBody(name='body'),
}

async function setGWSInstanceUser(request: SetGWSInstanceUserRequest): SetGWSInstanceUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetGWSInstanceUser', 'GET', '/', 'json', false, 'json', request);
}

model SetPostScriptsRequest {
  clusterId: string(name='ClusterId', description='The cluster ID.

You can call the [ListClusters](~~87116~~) operation to obtain the cluster ID.', example='ehpc-sh-EnjshUxn', position='Query'),
  postInstallScripts?: [ 
    {
      args?: string(name='Args', description='The parameter that is used to run the post-processing script.', example='-h'),
      url?: string(name='Url', description='The URL that is used to download the post-processing script.', example='https://bucket.oss-cn-shanghai.aliyuncs.com/postscript_examples.sh'),
    }
  ](name='PostInstallScripts', description='The post-processing scripts.', position='Query'),
  regionId: string(name='RegionId', description='The ID of the region where the cluster resides. You can call the [ListRegions](~~188593~~) operation to query the latest region list.', example='cn-shanghai', position='Query'),
}

model SetPostScriptsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='B745C159-3155-4B94-95D0-4B73D4D2****'),
}

model SetPostScriptsResponse = {
  headers: map[string]string(name='headers'),
  body: SetPostScriptsResponseBody(name='body'),
}

async function setPostScripts(request: SetPostScriptsRequest): SetPostScriptsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetPostScripts', 'GET', '/', 'json', false, 'json', request);
}

model SetQueueRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****', position='Query'),
  node: [ 
    {
      name?: string(name='Name', description='The name of the compute node that you want to move. Valid values of N: 1 to 100.

You can call the [ListNodes](~~87161~~) operation to query the names of the compute nodes.', example='compute1'),
    }
  ](name='Node', position='Query'),
  queueName: string(name='QueueName', description='The name of the destination queue.

You can call the [ListQueues](~~92176~~) operation to query the queue name.', example='work', position='Query'),
}

model SetQueueResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='DFC3EAA9-F11F-4ED0-836F-4FFCB279E700'),
}

model SetQueueResponse = {
  headers: map[string]string(name='headers'),
  body: SetQueueResponseBody(name='body'),
}

async function setQueue(request: SetQueueRequest): SetQueueResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetQueue', 'GET', '/', 'json', false, 'json', request);
}

model SetSchedulerInfoRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****', position='Query'),
  pbsInfo?: [ 
    {
      aclLimit?: [ 
        {
          aclUsers?: string(name='AclUsers', description='The user that can use the queue. Separate multiple users with commas (`,`).

If you specify users, you must specify the PbsInfo.N.AclLimit.N.Queue parameter.', example='user1,user2'),
          queue?: string(name='Queue', description='AclLimit specifies the queue that has limits when it is used. Valid values of N: 0 to 100.

If you set `PbsInfo.N.AclLimit.N.Queue` to `workq` and `PbsInfo.N.AclLimit.N.AclUsers` to `user1,user2`, workq can be used only by user1 and user2.', example='workq'),
        }
      ](name='AclLimit'),
      jobHistoryDuration?: int32(name='JobHistoryDuration', description='The retention period of jobs. After the retention period is exceeded, job data is deleted. Unit: days.

Valid values: 1 to 30

Default value: 14', example='14'),
      resourceLimit?: [ 
        {
          cpus?: int32(name='Cpus', description='The maximum number of vCPUs that can be used for nodes in a queue.', example='2'),
          maxJobs?: int32(name='MaxJobs', description='The maximum number of jobs that can be submitted to the cluster. If the total number of running jobs and queuing jobs exceeds the value, no more jobs can be submitted.', example='1000'),
          mem?: string(name='Mem', description='The maximum memory resources that can be used in a queue. Units:

*   gb
*   mb
*   kb', example='2gb'),
          nodes?: int32(name='Nodes', description='The maximum number of nodes that can be used in a queue.', example='2'),
          queue?: string(name='Queue', description='PbsInfo specifies the number of PBS schedulers that can be configured in the cluster. Valid values of N: 0 to 100.

ResourceLimit specifies the maximum number of queue resources that can be used. Valid values of N: 0 to 100.

Queue specifies the name of the queue that is used to run jobs.

If one of the User, Cpus, Nodes, and Mem parameters is set in ResourceLimit, you must specify the Queue parameter.', example='workq'),
          user?: string(name='User', description='The name of the user that runs jobs.', example='user1'),
        }
      ](name='ResourceLimit'),
      schedInterval?: int32(name='SchedInterval', description='PbsInfo specifies the number of PBS schedulers that can be configured in the cluster. Valid values of N: 0 to 100.

SchedInterval specifies the scheduling period. Unit: seconds.

A scheduling period is the interval between two consecutive running jobs. If you set SchedInterval to 60, another job can be run 60 seconds after a job starts running.

Default value: 60', example='60'),
      schedMaxJobs?: int32(name='SchedMaxJobs', description='The maximum number of jobs that can be scheduled in the cluster. If the total number of running jobs and queuing jobs exceeds the value, no more jobs can be submitted. Default value: 20000.', example='20000'),
      schedMaxQueuedJobs?: int32(name='SchedMaxQueuedJobs', description='The maximum number of queuing jobs that can be scheduled in the cluster. If the number of queuing jobs exceeds the value, no more jobs can be submitted. Default value: 10000.', example='10000'),
    }
  ](name='PbsInfo', position='Query'),
  regionId: string(name='RegionId', description='The ID of the region.

You can call the [ListRegions](~~188593~~) operation to obtain the IDs of regions supported by Elastic High Performance Computing (E-HPC).', example='cn-hangzhou', position='Query'),
  scheduler: [ 
    {
      schedName: string(name='SchedName', description='The name of the scheduler. Valid values:

*   pbs
*   pbs19
*   slurm
*   slurm19
*   slurm20

>  If you set Scheduler.N.SchedName to pbs or pbs19, you must specify at least one of the PbsInfo.N.SchedInterval, PbsInfo.N.JobHistoryDuration, and PbsInfo.N.AclLimit parameters. If you set Scheduler.N.SchedName to slurm, slurm19, or slurm20, you must specify at least one of the SlurmInfo.N.SchedInterval and SlurmInfo.N.BackfillInterval parameters.', example='pbs'),
    }
  ](name='Scheduler', position='Query'),
  slurmInfo?: [ 
    {
      backfillInterval?: int32(name='BackfillInterval', description='The backfill scheduling period. Unit: seconds.

Default value: 60', example='60'),
      schedInterval?: int32(name='SchedInterval', description='SlurmInfo specifies the number of Slurm schedulers that can be configured in the cluster. Valid values of N: 0 to 100.

SchedInterval specifies the scheduling period. Unit: seconds.

Default value: 60', example='60'),
    }
  ](name='SlurmInfo', position='Query'),
}

model SetSchedulerInfoResponseBody = {
  message?: string(name='Message', description='The response message.', example='pbs: scheduler setting successfully.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='BBC2F93D-003A-49C4-850C-B826EECF****'),
}

model SetSchedulerInfoResponse = {
  headers: map[string]string(name='headers'),
  body: SetSchedulerInfoResponseBody(name='body'),
}

async function setSchedulerInfo(request: SetSchedulerInfoRequest): SetSchedulerInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetSchedulerInfo', 'GET', '/', 'json', false, 'json', request);
}

model StartClusterRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster that you want to start.', example='ehpc-hz-FYUr32****', position='Query'),
}

model StartClusterResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='76E1ADE7-D15A-457F-AAFD-06C5A5F052D0'),
  taskId?: string(name='TaskId', description='The ID of the task.', example='76E1ADE7-D15A-457F-AAFD-06C5A5F052D0'),
}

model StartClusterResponse = {
  headers: map[string]string(name='headers'),
  body: StartClusterResponseBody(name='body'),
}

async function startCluster(request: StartClusterRequest): StartClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StartCluster', 'GET', '/', 'json', false, 'json', request);
}

model StartGWSInstanceRequest {
  instanceId: string(name='InstanceId', description='The ID of the visualization instance.', example='i-bp1bzqq4rj1eemun****', position='Query'),
}

model StartGWSInstanceResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model StartGWSInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: StartGWSInstanceResponseBody(name='body'),
}

async function startGWSInstance(request: StartGWSInstanceRequest): StartGWSInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StartGWSInstance', 'GET', '/', 'json', false, 'json', request);
}

model StartNodesRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****', position='Query'),
  instance: [ 
    {
      id?: string(name='Id', description='The ID of the Nth node. Valid values of N: 1 to 100.

Make sure that the node is in the Stopped state. You can call the [ListNodes](~~87161~~) operation to query the status of the node.', example='i-bp13p7vlcb1uihfv****'),
    }
  ](name='Instance', position='Query'),
  role?: string(name='Role', description='The role of the node. Valid values:

*   Manager: management node
*   Login: logon node
*   Compute: compute node

Default value: Compute', example='Compute', position='Query'),
}

model StartNodesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  taskId?: string(name='TaskId', description='The ID of the task.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model StartNodesResponse = {
  headers: map[string]string(name='headers'),
  body: StartNodesResponseBody(name='body'),
}

async function startNodes(request: StartNodesRequest): StartNodesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StartNodes', 'GET', '/', 'json', false, 'json', request);
}

model StartVisualServiceRequest {
  cidrIp: string(name='CidrIp', description='A public IP address of logon nodes in the cluster.', example='190.100.**.**', position='Query'),
  clusterId: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-jeJki6****', position='Query'),
  port: int32(name='Port', description='The fixed port. Set the value to 12016', example='12016', maximum=65535, position='Query'),
}

model StartVisualServiceResponseBody = {
  message?: string(name='Message', description='The status of the VNC Remote visualization service. Valid values:

*   Service started
*   Service stopped', example='StartVisualService'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='896D338C-E4F4-41EC-A154-D605E5DE6880'),
}

model StartVisualServiceResponse = {
  headers: map[string]string(name='headers'),
  body: StartVisualServiceResponseBody(name='body'),
}

async function startVisualService(request: StartVisualServiceRequest): StartVisualServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StartVisualService', 'GET', '/', 'json', false, 'json', request);
}

model StopClusterRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****', position='Query'),
}

model StopClusterResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  taskId?: string(name='TaskId', description='The ID of the task.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model StopClusterResponse = {
  headers: map[string]string(name='headers'),
  body: StopClusterResponseBody(name='body'),
}

/**
  * If you stop a subscription compute node, its billing is not affected. If you stop a pay-as-you-go compute node for which you have enabled the *economical mode*, you are no longer charged for its computing resources. For more information, see [Economical mode](~~63353~~).
  *
 */
async function stopCluster(request: StopClusterRequest): StopClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StopCluster', 'GET', '/', 'json', false, 'json', request);
}

model StopGWSInstanceRequest {
  instanceId: string(name='InstanceId', example='i-bp1bzqq4rj1eemun****', position='Query'),
}

model StopGWSInstanceResponseBody = {
  requestId?: string(name='RequestId', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model StopGWSInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: StopGWSInstanceResponseBody(name='body'),
}

async function stopGWSInstance(request: StopGWSInstanceRequest): StopGWSInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StopGWSInstance', 'GET', '/', 'json', false, 'json', request);
}

model StopJobsRequest {
  async?: boolean(name='Async', description='Specifies whether to use an asynchronous link to stop the job.

Default value: false', example='false', position='Query'),
  clusterId: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****', position='Query'),
  jobs: string(name='Jobs', description='The list of jobs that you want to stop. Maximum number of jobs: 100. Minimum number of jobs: 1.

Format: `[{"Id": "0.sched****"},{"Id": "1.sched****"}]`. Separate multiple jobs with commas (,).

You can call the [ListJobs](~~87251~~) operation to query the job ID.

>  You can stop only jobs that are in the RUNNING or QUEUED state.', example='[{"Id":"1.sched****"},{"Id":"0.sched****"}]', position='Query'),
}

model StopJobsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model StopJobsResponse = {
  headers: map[string]string(name='headers'),
  body: StopJobsResponseBody(name='body'),
}

async function stopJobs(request: StopJobsRequest): StopJobsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StopJobs', 'GET', '/', 'json', false, 'json', request);
}

model StopNodesRequest {
  clusterId: string(name='ClusterId', description='The ID of the E-HPC cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****', position='Query'),
  instance: [ 
    {
      id?: string(name='Id', description='The ID of the Nth node that you want to stop. Valid values of N: 1 to 100

You can call the [ListNodes](~~87161~~) operation to query the IDs of the compute nodes.', example='i-bp13p7vlcb1uihf****'),
    }
  ](name='Instance', position='Query'),
  role?: string(name='Role', description='The role of the node. Valid values:

*   Manager: management node
*   Login: logon node
*   Compute: compute node

Default value: Compute', example='Compute', position='Query'),
}

model StopNodesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  taskId?: string(name='TaskId', description='The ID of the task.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model StopNodesResponse = {
  headers: map[string]string(name='headers'),
  body: StopNodesResponseBody(name='body'),
}

async function stopNodes(request: StopNodesRequest): StopNodesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StopNodes', 'GET', '/', 'json', false, 'json', request);
}

model StopServerlessJobsRequest {
  clusterId: string(name='ClusterId', example='ehpc-hz-FYUr32****', position='Query'),
  jobIds: [ string ](name='JobIds', position='Query'),
}

model StopServerlessJobsResponseBody = {
  requestId?: string(name='RequestId', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model StopServerlessJobsResponse = {
  headers: map[string]string(name='headers'),
  body: StopServerlessJobsResponseBody(name='body'),
}

async function stopServerlessJobs(request: StopServerlessJobsRequest): StopServerlessJobsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StopServerlessJobs', 'POST', '/', 'json', false, 'json', request);
}

model StopVisualServiceRequest {
  cidrIp: string(name='CidrIp', description='A public IP address of login nodes in the cluster.', example='100.168.**.**', position='Query'),
  clusterId: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-jeJki6****', position='Query'),
  port: int32(name='Port', description='The fixed port. Set the value to 12016.', example='12016', maximum=65535, position='Query'),
}

model StopVisualServiceResponseBody = {
  message?: string(name='Message', description='The status of the VNC Remote Service. Valid values:

*   Service started
*   Service stopped', example='Service stopped'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='896D338C-E4F4-41EC-A154-D605E5DE6880'),
}

model StopVisualServiceResponse = {
  headers: map[string]string(name='headers'),
  body: StopVisualServiceResponseBody(name='body'),
}

async function stopVisualService(request: StopVisualServiceRequest): StopVisualServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StopVisualService', 'GET', '/', 'json', false, 'json', request);
}

model SubmitJobRequest {
  jobRetry?: {
    count?: int32(name='Count'),
    onExitCode?: int32(name='OnExitCode'),
    priority?: int32(name='Priority'),
  }(name='JobRetry', position='Query'),
  arrayRequest?: string(name='ArrayRequest', description='The job array.

Format: X-Y:Z. The minimum index value X is the first index. The maximum index value Y is the last index. Z is the step size. For example, 2-7:2 indicates that three jobs need to be run and their index values are 2, 4, and 6.', example='1-10:2', position='Query'),
  async?: boolean(name='Async', description='Specifies whether to use an asynchronous link to submit the job.

Default value: false.', example='false', position='Query'),
  clockTime?: string(name='ClockTime', description='The maximum running time of the job. Valid formats:

*   hh:mm:ss
*   mm:ss
*   ss

We recommend that you use the hh:mm:ss format. If the maximum running time is 12 hours, set the value to 12:00:00.', example='12:00:00', position='Query'),
  clusterId: string(name='ClusterId', description='The cluster ID.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****', position='Query'),
  commandLine: string(name='CommandLine', description='The command that is used to run the job.', example='./LammpsTest/lammps.pbs', position='Query'),
  containerId?: string(name='ContainerId', description='The ID of the containerized application. If you want to use a container application, you must specify its ID.

You can call the [ListContainerApps](~~87333~~) operation to query the container application ID.', example='ehpc-container-uerfrfffff****', position='Query'),
  cpu?: int32(name='Cpu', description='The number of CPU cores required by a single compute node.', example='2', position='Query'),
  gpu?: int32(name='Gpu', description='The maximum GPU usage required by a single compute node.

The parameter takes effect only when the cluster uses PBS and a compute node is a GPU-accelerated instance.', example='1', position='Query'),
  inputFileUrl?: string(name='InputFileUrl', description='The URL of the job file that is uploaded to an Object Storage Service (OSS) bucket.', example='https://ehpc-hangzhou.oss-cn-hangzhou.aliyuncs.com/test-u4****/testlist_ehpc.sh', position='Query'),
  jobQueue?: string(name='JobQueue', description='The name of the queue in which the job is run.

You can call the [ListQueues](~~92176~~) operation to query the name of the queue.', example='workq', position='Query'),
  mem?: string(name='Mem', description='The maximum memory usage required by a single compute node. Unit: GB, MB, or KB. The unit is case-insensitive.', example='1GB', position='Query'),
  name?: string(name='Name', description='The name of the job. The name must be 6 to 30 characters in length and start with a letter. It can contain letters, digits, and periods (.).', example='job1', position='Query'),
  node?: int32(name='Node', description='The number of compute nodes required to run the job.

> If the parameter is not specified, the Cpu, Task, Thread, Mem, and Gpu parameters become invalid.', example='2', position='Query'),
  packagePath?: string(name='PackagePath', description='The path that is used to run the job.', example='./Tem', position='Query'),
  postCmdLine?: string(name='PostCmdLine', description='The command to perform on the job after the job is submitted.', example='example.sh', position='Query'),
  priority?: int32(name='Priority', description='The priority of the job. Valid values: 0 to 9. A larger value indicates a higher priority.

Default value: 0.', example='0', position='Query'),
  reRunable?: boolean(name='ReRunable', description='Specifies whether the job can be rerun. Valid values:

*   true: The job can be rerun.
*   false: The job cannot be rerun.', example='false', position='Query'),
  runasUser: string(name='RunasUser', description='The name of the user that runs the job.

You can call the [ListUsers](~~188572~~) operation to query the users of the cluster.', example='testuser', position='Query'),
  runasUserPassword?: string(name='RunasUserPassword', description='The password that corresponds to the username.', example='12****', position='Query'),
  stderrRedirectPath?: string(name='StderrRedirectPath', description='The output file path of stderr.', example='./LammpsTest', position='Query'),
  stdoutRedirectPath?: string(name='StdoutRedirectPath', description='The output file path of stdout.', example='./LammpsTest', position='Query'),
  task?: int32(name='Task', description='The number of processes created for a single compute node.

The parameter is applicable to Message Passing Interface (MPI) jobs.', example='2', position='Query'),
  thread?: int32(name='Thread', description='The number of threads created for a single compute node.

The parameter is applicable to OpenMP jobs.', example='1', position='Query'),
  unzipCmd?: string(name='UnzipCmd', description='The command for file decompression. The command that is used to decompress the job files downloaded from an OSS bucket. Valid values:

*   tar xzf: Decompresses GZIP files.
*   tar xf: Decompresses TAR files.
*   unzip: Decompresses ZIP files.', example='tar xzf', position='Query'),
  variables?: string(name='Variables', description='The runtime variables passed to the job. They can be accessed by using environment variables in the executable file.', example='[{Name:test1,Value:value1},{Name:test2,Value:value2}]', position='Query'),
}

model SubmitJobResponseBody = {
  jobId?: string(name='JobId', description='The ID of the job.', example='1.manager'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model SubmitJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitJobResponseBody(name='body'),
}

/**
  * ## Description
  * Before you submit a job in a cluster, you must upload a job file to the cluster, for example, job.sh. For more information, see [CreateJobFile](~~159049~~).
  *
 */
async function submitJob(request: SubmitJobRequest): SubmitJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SubmitJob', 'GET', '/', 'json', false, 'json', request);
}

model SubmitServerlessJobRequest {
  arrayProperties?: {
    indexEnd?: long(name='IndexEnd', example='5'),
    indexStart?: long(name='IndexStart', example='1'),
    indexStep?: long(name='IndexStep', example='2'),
  }(name='ArrayProperties', shrink='json', position='Query'),
  clusterId: string(name='ClusterId', example='ehpc-hz-FYUr32****', position='Query'),
  container: {
    arg?: [ string ](name='Arg'),
    command?: [ string ](name='Command'),
    environmentVar?: [ 
      {
        key?: string(name='Key'),
        value?: string(name='Value', example='/usr/local/bin'),
      }
    ](name='EnvironmentVar'),
    gpu?: int32(name='Gpu', example='1'),
    image: string(name='Image', example='registry-vpc.cn-hangzhou.aliyuncs.com/ehpc/hpl:latest'),
    volumeMount?: [ 
      {
        flexVolumeDriver?: string(name='FlexVolumeDriver'),
        flexVolumeOptions?: string(name='FlexVolumeOptions'),
        mountPath?: string(name='MountPath', example='/data'),
      }
    ](name='VolumeMount'),
    workingDir?: string(name='WorkingDir', example='/usr/local/'),
  }(name='Container', shrink='json', position='Query'),
  cpu?: float(name='Cpu', example='2', position='Query'),
  dependsOn?: [ 
    {
      jobId?: string(name='JobId', example='10'),
      type?: string(name='Type', example='AfterAny'),
    }
  ](name='DependsOn', shrink='json', position='Query'),
  ephemeralStorage?: int32(name='EphemeralStorage', example='200', position='Query'),
  instanceType?: [ string ](name='InstanceType', shrink='simple', position='Query'),
  jobName: string(name='JobName', example='testjob', position='Query'),
  jobPriority?: long(name='JobPriority', example='10', position='Query'),
  memory?: float(name='Memory', example='4', position='Query'),
  ramRoleName?: string(name='RamRoleName', example='testRamRoleName', position='Query'),
  spotPriceLimit?: float(name='SpotPriceLimit', example='0.062', position='Query'),
  spotStrategy?: string(name='SpotStrategy', example='SpotPriceLimit', position='Query'),
  timeout?: long(name='Timeout', example='3600', position='Query'),
  vSwitchId?: [ string ](name='VSwitchId', shrink='simple', position='Query'),
}

model SubmitServerlessJobResponseBody = {
  jobId?: string(name='JobId', example='10'),
  requestId?: string(name='RequestId', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model SubmitServerlessJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitServerlessJobResponseBody(name='body'),
}

async function submitServerlessJob(request: SubmitServerlessJobRequest): SubmitServerlessJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SubmitServerlessJob', 'POST', '/', 'json', false, 'json', request);
}

model SummaryImagesRequest {
  regionId: string(name='RegionId', position='Host'),
  clusterId: string(name='ClusterId', description='The names of all images in the cluster.', example='ehpc-hz-jeJki6****', position='Query'),
  containerType: string(name='ContainerType', example='singularity', position='Query'),
}

model SummaryImagesResponseBody = {
  imagesName?: string(name='ImagesName', example='{"summaryImages":["gromacs.sif","linpack.sif","sccIntelMPI1.sif","test.sif","usergromac.sif.user"]}'),
  requestId?: string(name='RequestId', example='896D338C-E4F4-41EC-A154-D605E5DE****'),
}

model SummaryImagesResponse = {
  headers: map[string]string(name='headers'),
  body: SummaryImagesResponseBody(name='body'),
}

async function summaryImages(request: SummaryImagesRequest): SummaryImagesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SummaryImages', 'GET', '/', 'json', false, 'json', request);
}

model SummaryImagesInfoRequest {
  regionId?: string(name='RegionId', position='Host'),
  clusterId?: string(name='ClusterId', description='The ID of the request.', example='ehpc-hz-ibug699XXX', position='Query'),
  containerType?: string(name='ContainerType', description='The detailed information about the image.', example='singularity', position='Query'),
  imageName?: string(name='ImageName', example='test.sif', position='Query'),
}

model SummaryImagesInfoResponseBody = {
  imagesInfo?: string(name='ImagesInfo', example='{"summaryImagesInfo":[{"ImageName":"gromacs.sif","ImageSize":"4","CreateTime":"16:18","CreateDate":"Apr.1"},{"ImageName":"linpack.sif","ImageSize":"665847525","CreateTime":"14:45","CreateDate":"Apr.1"},{"ImageName":"sccIntelMPI1.sif","ImageSize":"665847525","CreateTime":"14:41","CreateDate":"Apr.1"},{"ImageName":"test.sif","ImageSize":"24","CreateTime":"12:25","CreateDate":"Apr.20"},{"ImageName":"usergromac.sif.user","ImageSize":"4","CreateTime":"15:16","CreateDate":"Apr.19"}]}'),
  requestId?: string(name='RequestId', example='896D338C-E4F4-41EC-A154-D605E5DE****'),
}

model SummaryImagesInfoResponse = {
  headers: map[string]string(name='headers'),
  body: SummaryImagesInfoResponseBody(name='body'),
}

async function summaryImagesInfo(request: SummaryImagesInfoRequest): SummaryImagesInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SummaryImagesInfo', 'GET', '/', 'json', false, 'json', request);
}

model SyncUsersRequest {
  clusterId: string(name='ClusterId', description='The cluster ID.

You can call the [ListClusters](~~87116~~) operation to query the list of E-HPC clusters.', example='ehpc-hz-gh5WKb****', position='Query'),
  regionId: string(name='RegionId', description='The region ID.

You can call the [ListRegions](~~188593~~) operation to query the list of regions where E-HPC is supported.', example='cn-hangzhou', position='Query'),
}

model SyncUsersResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model SyncUsersResponse = {
  headers: map[string]string(name='headers'),
  body: SyncUsersResponseBody(name='body'),
}

async function syncUsers(request: SyncUsersRequest): SyncUsersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SyncUsers', 'GET', '/', 'json', false, 'json', request);
}

model TagResourcesRequest {
  regionId: string(name='RegionId', description='The key of the tag. The tag key cannot be an empty string. It can be up to 128 characters in length and cannot contain `http://` or `https://`. It must not start with `acs:` or `aliyun`.', example='cn-hangzhou', position='Query'),
  resourceId: [ string ](name='ResourceId', description='The ID of the request.', position='Query'),
  resourceType: string(name='ResourceType', description='The value of the tag. The tag key cannot be an empty string. It can be up to 128 characters in length and cannot contain `http://` or `https://`. It must not start with `acs:` or `aliyun`.', example='cluster', position='Query'),
  tag: [ 
    {
      key?: string(name='Key', example='TestKey'),
      value?: string(name='Value', example='TestValue'),
    }
  ](name='Tag', position='Query'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'TagResources', 'POST', '/', 'json', false, 'json', request);
}

model UnTagResourcesRequest {
  all?: boolean(name='All', description='Specifies whether to remove all tags from the resource. This parameter is valid only when the TagKey.N parameter is not specified. Valid values:

*   true
*   false

Default value: false.', example='false', position='Query'),
  regionId?: string(name='RegionId', description='The region ID of the resource.', example='cn-hangzhou', position='Query'),
  resourceId: [ string ](name='ResourceId', description='The resource IDs. You can specify up to 50 resource IDs.', position='Query'),
  resourceType: string(name='ResourceType', description='The type of the resource from which you want to remove tags. Set the value to cluster, which indicates E-HPC clusters.', example='cluster', position='Query'),
  tagKey?: [ string ](name='TagKey', description='The tag key of the resource. You can specify up to 20 tag keys.', position='Query'),
}

model UnTagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model UnTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: UnTagResourcesResponseBody(name='body'),
}

async function unTagResources(request: UnTagResourcesRequest): UnTagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UnTagResources', 'POST', '/', 'json', false, 'json', request);
}

model UninstallSoftwareRequest {
  application: string(name='Application', description='The name of the software that you want to uninstall.

You can call the [ListInstalledSoftware](~~188591~~) operation to query the software that is installed in the cluster.', example='ABYSS_2.1.5', position='Query'),
  clusterId: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-jeJki6****', position='Query'),
}

model UninstallSoftwareResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='C84FB8EF-5580-4B82-9BDE-6657814C****'),
}

model UninstallSoftwareResponse = {
  headers: map[string]string(name='headers'),
  body: UninstallSoftwareResponseBody(name='body'),
}

async function uninstallSoftware(request: UninstallSoftwareRequest): UninstallSoftwareResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UninstallSoftware', 'GET', '/', 'json', false, 'json', request);
}

model UpdateClusterVolumesRequest {
  additionalVolumes?: [ 
    {
      jobQueue?: string(name='JobQueue', description='The ID of the cluster.', example='work'),
      localDirectory?: string(name='LocalDirectory', description='The on-premises mount directory for the nth additional mounted file system.', example='/ff'),
      location?: string(name='Location', description='The storage location of the nth attached mounted file system. Valid values:

*   OnPremise: hybrid cloud cluster
*   PublicCloud: public cloud cluster', example='PublicCloud'),
      remoteDirectory?: string(name='RemoteDirectory', description='The remote directory to be mounted by the nth additional mounted file system.', example='/test'),
      roles?: [ 
        {
          name?: string(name='Name', description='The node type on which the nth additional mounted file system is mounted. Valid values:

*   Manager: management node
*   Login: logon node
*   Compute: compute node', example='["Compute"]'),
        }
      ](name='Roles', description='The ID of the nth additional mounted file system.'),
      volumeId?: string(name='VolumeId', description='The queue name of the nth attached mounted filesystem.', example='extreme-00b88****'),
      volumeMountOption?: string(name='VolumeMountOption', example='-t nfs -o vers=3,nolock,noresvport'),
      volumeMountpoint?: string(name='VolumeMountpoint', description='The domain name of the mount target for the nth additional mounted file system.', example='0088****-sihc.cn-hangzhou.extreme.nas.aliyuncs.com'),
      volumeProtocol?: string(name='VolumeProtocol', description='The protocol type of the nth additional mounted file system. Valid values:

*   NFS
*   SMB', example='NFS'),
      volumeType?: string(name='VolumeType', description='The type of the nth additional mounted file system. Currently, only NAS is supported.

Valid values of N: 1 to 10.', example='NAS'),
    }
  ](name='AdditionalVolumes', description='The operation that you want to perform. Set the value to UpdateClusterVolumes', position='Query'),
  clusterId: string(name='ClusterId', description='The ID of the request.', example='ehpc-hz-FYUr32****', position='Query'),
}

model UpdateClusterVolumesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F6757FA4-8FED-4602-B7F5-3550C0842122'),
}

model UpdateClusterVolumesResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateClusterVolumesResponseBody(name='body'),
}

async function updateClusterVolumes(request: UpdateClusterVolumesRequest): UpdateClusterVolumesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateClusterVolumes', 'GET', '/', 'json', false, 'json', request);
}

model UpdateQueueConfigRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****', position='Query'),
  computeInstanceType?: string(name='ComputeInstanceType', description='The instance type of the node.

You can call the [ListPreferredEcsTypes](~~188592~~) operation to query the recommended instance types.', example='ecs.n1.tiny', position='Query'),
  deploymentSetId?: string(name='DeploymentSetId', position='Query'),
  queueName: string(name='QueueName', description='The name of the queue.', example='workq', position='Query'),
  resourceGroupId: string(name='ResourceGroupId', description='The ID of the resource group.

You can call the [ListResourceGroups](~~158855~~) operation to query the IDs of resource groups.', example='rg-acfmxazb4ph****', position='Query'),
}

model UpdateQueueConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5198C3E8-85F5-4280-8547-687C1710****'),
}

model UpdateQueueConfigResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateQueueConfigResponseBody(name='body'),
}

/**
  * After you update the instance types of a resource group, the nodes that you add by scaling out the cluster are automatically included in the resource group.
  *
 */
async function updateQueueConfig(request: UpdateQueueConfigRequest): UpdateQueueConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateQueueConfig', 'GET', '/', 'json', false, 'json', request);
}

model UpgradeClientRequest {
  clientVersion?: string(name='ClientVersion', description='The version to which the client will be upgraded. By default, the client is upgraded to the latest version. You can call the [ListCurrentClientVersion](~~87223~~) operation to query the latest version number of the Elastic High Performance Computing (E-HPC) client.', example='2.0.0', position='Query'),
  clusterId: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-FYUr32****', position='Query'),
}

model UpgradeClientResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='4994fbcd-2a09-4045-b2b2-2c3bee8e9296'),
}

model UpgradeClientResponse = {
  headers: map[string]string(name='headers'),
  body: UpgradeClientResponseBody(name='body'),
}

async function upgradeClient(request: UpgradeClientRequest): UpgradeClientResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpgradeClient', 'GET', '/', 'json', false, 'json', request);
}

