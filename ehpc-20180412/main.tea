/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('ehpc', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AddContainerAppRequest {
  containerType?: string(name='ContainerType', description='The type of the container. Set the value to singularity.', example='singularity'),
  description?: string(name='Description', description='The description of the container.', example='descriptionContainer'),
  imageTag?: string(name='ImageTag', description='The tags of the image.

The repository stores a type of images such as Ubuntu images. Tags are used to identify the images. Examples: 16.04, 17.04, and latest.

Default value: latest', example='latest'),
  name?: string(name='Name', description='The name of the container. The name must be 2 to 64 characters in length. It must start with a letter and can contain letters, digits, hyphens (-), and underscores (\\_).', example='container1'),
  repository?: string(name='Repository', description='The name of the repository. The image that has the same name as the repository is pulled.

For information about image names, visit [Docker Hub official website](https://hub.docker.com/search?q=\\&type=image).', example='repo1'),
}

model AddContainerAppResponseBody = {
  containerId?: {
    containerId?: [ string ](name='ContainerId')
  }(name='ContainerId', description='The ID of the container.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model AddContainerAppResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddContainerAppResponseBody(name='body'),
}

/**
  * If you select an image for a new containerized application, the image is pulled from Docker Hub by default. However, the version of the image may not be up to date. You can call the [PullImage](~~159052~~) operation to pull the latest image.
  *
  * @param request AddContainerAppRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return AddContainerAppResponse
 */
async function addContainerAppWithOptions(request: AddContainerAppRequest, runtime: Util.RuntimeOptions): AddContainerAppResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddContainerApp',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * If you select an image for a new containerized application, the image is pulled from Docker Hub by default. However, the version of the image may not be up to date. You can call the [PullImage](~~159052~~) operation to pull the latest image.
  *
  * @param request AddContainerAppRequest
  * @return AddContainerAppResponse
 */
async function addContainerApp(request: AddContainerAppRequest): AddContainerAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return addContainerAppWithOptions(request, runtime);
}

model AddExistedNodesRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****'),
  imageId?: string(name='ImageId', description='The ID of the image that is specified for the compute nodes. The image must meet the following requirements:

*   The operating system that is specified by the image must be the same as that of the existing cluster nodes. For example, if the operating system of the cluster nodes is CentOS, you can select only a CentOS image.

> If you add nodes to a hybrid cloud cluster that supports multiple operating systems, you can select a Windows Server image or a CentOS image when the operating system of the cluster nodes is Windows.

*   The major version of the image specified for the compute nodes that you want to add is the same as that of the image of the cluster. For example, if the version of the cluster image is CentOS 7.x, the version of the image specified for the compute nodes must be CentOS 7.x.

You can call the [ListImages](~~87213~~) and [ListCustomImages](~~87215~~) operations to query the image ID.', example='centos_7_06_64_20G_alibase_20190711.vhd'),
  imageOwnerAlias?: string(name='ImageOwnerAlias', description='The type of the image. Valid values:

*   system: public image
*   self: custom image
*   others: shared image
*   marketplace: Alibaba Cloud Marketplace image

Default value: system', example='system'),
  instance?: [ 
    {
      id?: string(name='Id', description='The Nth node ID. N starts from 1. Valid values: 1 to 100.', example='i-bp16mxn6mt3t7ftk****'),
    }
  ](name='Instance'),
  jobQueue?: string(name='JobQueue', description='The queue in the cluster to which the node is to be added.', example='workq'),
}

model AddExistedNodesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  taskId?: string(name='TaskId', description='The ID of the task.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model AddExistedNodesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddExistedNodesResponseBody(name='body'),
}

/**
  * *   The compute nodes to be added are in the Stopped state.
  * *   After the compute nodes are added to the cluster, the operating systems of the nodes are replaced with the operating system specified by the ImageId parameter.
  * *   The hosts of the compute nodes must be different from those of the existing compute nodes in the cluster. Otherwise, the add operation fails.
  *
  * @param request AddExistedNodesRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return AddExistedNodesResponse
 */
async function addExistedNodesWithOptions(request: AddExistedNodesRequest, runtime: Util.RuntimeOptions): AddExistedNodesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddExistedNodes',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   The compute nodes to be added are in the Stopped state.
  * *   After the compute nodes are added to the cluster, the operating systems of the nodes are replaced with the operating system specified by the ImageId parameter.
  * *   The hosts of the compute nodes must be different from those of the existing compute nodes in the cluster. Otherwise, the add operation fails.
  *
  * @param request AddExistedNodesRequest
  * @return AddExistedNodesResponse
 */
async function addExistedNodes(request: AddExistedNodesRequest): AddExistedNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return addExistedNodesWithOptions(request, runtime);
}

model AddLocalNodesRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-FYUr32****'),
  nodes?: string(name='Nodes', description='The information of the local node. A JSON string that contains the HostName, IpAddress, CpuCores, and Memory (Unit: MB) of the local node.', example='[{"HostName":"test-HostName","IpAddress":"192.168.**.**"},{"CpuCores":2,"Memory":1024}]'),
  queue?: string(name='Queue', description='The queue to which to add the local node.', example='test.q'),
}

model AddLocalNodesResponseBody = {
  instanceIds?: {
    instanceId?: [ string ](name='InstanceId')
  }(name='InstanceIds', description='The local nodes in the cluster.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model AddLocalNodesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddLocalNodesResponseBody(name='body'),
}

async function addLocalNodesWithOptions(request: AddLocalNodesRequest, runtime: Util.RuntimeOptions): AddLocalNodesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddLocalNodes',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addLocalNodes(request: AddLocalNodesRequest): AddLocalNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return addLocalNodesWithOptions(request, runtime);
}

model AddNodesRequest {
  allocatePublicAddress?: boolean(name='AllocatePublicAddress', description='Specifies whether to allocate a public IP address to the compute nodes. Valid values:

*   true: A public IP address is allocated to the compute nodes.
*   false: A public IP address is not allocated to the compute nodes.

Default value: false', example='false'),
  autoRenew?: string(name='AutoRenew', description='Specifies whether to enable auto-renewal. The parameter takes effect only when EcsChargeType is set to PrePaid. Valid values:

*   true: enables auto-renewal
*   false: disables auto-renewal

Default value: true', example='true'),
  autoRenewPeriod?: int32(name='AutoRenewPeriod', description='The auto-renewal period of the subscription compute nodes. The parameter takes effect when AutoRenew is set to true.

*   If PeriodUnit is set to Week, the valid values of the AutoRenewPeriod parameter are 1, 2, and 3.
*   If PeriodUnit is set to Month, the valid values of the AutoRenewPeriod parameter are 1, 2, 3, 6, and 12.

Default value: 1', example='1'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that the value is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence of a request?](~~25693~~)', example='123e4567-e89b-12d3-a456-426655440000'),
  clusterId?: string(name='ClusterId', description='The ID of the E-HPC cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****'),
  computeEnableHt?: boolean(name='ComputeEnableHt', description='Specifies whether the compute nodes support hyper-threading. Valid values:

*   true: Hyper-threading is supported.
*   false: Hyper-threading is not supported.

Default value: true', example='true'),
  computeSpotDuration?: int32(name='ComputeSpotDuration', description='The protection period of the preemptible instance. Unit: hours. Valid values: 0 and 1. A value of 0 indicates that the preemptible instance has no protection period.', example='1'),
  computeSpotInterruptionBehavior?: string(name='ComputeSpotInterruptionBehavior', description='The interruption mode of the preemptible instance. Default value: Terminate. Set the value to Terminate, which indicates that the instance is released.', example='Terminate'),
  computeSpotPriceLimit?: string(name='ComputeSpotPriceLimit', description='The maximum hourly price of the compute nodes. The value can be accurate to three decimal places. The parameter only takes effect when SpotStrategy is set to SpotWithPriceLimit.', example='0.68'),
  computeSpotStrategy?: string(name='ComputeSpotStrategy', description='The preemption policy of the compute nodes. The parameter only takes effect when EcsChargeType is set to PostPaid. Valid values:

*   NoSpot: The compute nodes are pay-as-you-go instances.
*   SpotWithPriceLimit: The instance is a preemptible instance that has a user-defined maximum hourly price.
*   SpotAsPriceGo: The compute nodes are preemptible instances for which the market price at the time of purchase is used as the bid price.

Default value: NoSpot', example='NoSpot'),
  count?: int32(name='Count', description='The number of compute nodes that you want to add. Valid values: 1 to 99. The value of this parameter is greater than that of the MinCount parameter.

*   If the number of available ECS instances is less than the value of the MinCount parameter, the compute nodes cannot be added.
*   If the number of available ECS instances is greater than the value of the MinCount parameter and less than that of the Count parameter, the compute nodes are added based on the value of the MinCount parameter.
*   If the number of available ECS instances is greater than the value of the Count parameter, the compute nodes are added based on the value of the Count parameter.', example='10'),
  createMode?: string(name='CreateMode', description='The mode in which the compute nodes are added. Valid values:

*   manual: The compute nodes are manually added.
*   autoscale: The compute nodes are automatically added.

Default value: manual', example='manual'),
  dataDisks?: [ 
    {
      dataDiskCategory?: string(name='DataDiskCategory', description='The type of the data disk. Valid values:

*   cloud_efficiency: ultra disk
*   cloud_ssd: SSD
*   cloud_essd: ESSD
*   cloud: basic disk

Default value: cloud_efficiency

Valid values of N: 0 to 16', example='cloud_efficiency'),
      dataDiskDeleteWithInstance?: boolean(name='DataDiskDeleteWithInstance', description='Specifies whether the data disk is released when the node is released. Valid values:

*   true
*   false

Default value: true

Valid values of N: 0 to 16', example='true'),
      dataDiskEncrypted?: boolean(name='DataDiskEncrypted', description='Specifies whether to encrypt the data disk. Valid values:

*   true
*   false

Default value: false

Valid values of N: 0 to 16', example='false'),
      dataDiskKMSKeyId?: string(name='DataDiskKMSKeyId', description='The KMS key ID of the data disk.

Valid values of N: 0 to 16', example='0e478b7a-4262-4802-b8cb-00d3fb40826X'),
      dataDiskPerformanceLevel?: string(name='DataDiskPerformanceLevel', description='The performance level of the ESSD used as the data disk. The parameter only takes effect only when the DataDisks.N.DataDiskCategory parameter is set to cloud_essd. Valid values:

*   PL0: A single ESSD can deliver up to 10,000 random read/write IOPS.
*   PL1: A single ESSD can deliver up to 50,000 random read/write IOPS.
*   PL2: A single ESSD can deliver up to 100,000 random read/write IOPS.
*   PL3: A single ESSD can deliver up to 1,000,000 random read/write IOPS.

Default value: PL1

Valid values of N: 0 to 16', example='PL1'),
      dataDiskSize?: int32(name='DataDiskSize', description='The size of the data disk. Unit: GB

Valid values: 40 to 500

Default value: 40

Valid values of N: 0 to 16', example='40'),
    }
  ](name='DataDisks'),
  ecsChargeType?: string(name='EcsChargeType', description='The billing method of the compute nodes. Valid values:

*   PostPaid: pay-as-you-go
*   PrePaid: subscription

Default value: PostPaid

If the parameter is set to PrePaid, auto-renewal is enabled by default. After the E-HPC cluster is released, auto-renewal is disabled.', example='PostPaid'),
  hostNamePrefix?: string(name='HostNamePrefix', description='The prefix of the hostname. You can specify the parameter to manage the compute nodes in an efficient manner.', example='compute'),
  hostNameSuffix?: string(name='HostNameSuffix', description='The suffix of the hostname. You can specify the parameter to manage the compute nodes in an efficient manner.', example='01'),
  imageId?: string(name='ImageId', description='The ID of the image that is specified for the compute nodes. The image must meet the following requirements:

*   The operating system that is specified by the image must be the same as that of the existing cluster nodes. For example, if the operating system of the cluster nodes is CentOS, you can select only a CentOS image.

> If you add nodes to a hybrid cloud cluster that supports multiple operating systems, you can select a Windows Server image or a CentOS image when the operating system of the cluster nodes is Windows.

*   The major version of the image specified for the compute nodes that you want to add is the same as that of the image of the cluster. For example, if the version of the cluster image is CentOS 7.x, the version of the image specified for the compute nodes must be CentOS 7.x.

You can call the [ListImages](~~87213~~) and [ListCustomImages](~~87215~~) operations to query the image ID.', example='centos_7_06_64_20G_alibase_20190711.vhd'),
  imageOwnerAlias?: string(name='ImageOwnerAlias', description='The type of the image. Valid values:

*   system: public image
*   self: custom image
*   others: shared image
*   marketplace: Alibaba Cloud Marketplace image

Default value: system', example='system'),
  instanceType?: string(name='InstanceType', description='The instance type of the compute nodes. The default value is the instance type that was specified when you created the E-HPC cluster or the last time when you added compute nodes.', example='ecs.n1.tiny'),
  internetChargeType?: string(name='InternetChargeType', description='The billing method of the elastic IP address (EIP). Valid values:

*   PayByBandwidth: pay-by-bandwidth
*   PayByTraffic: pay-by-traffic', example='PayByTraffic'),
  internetMaxBandWidthIn?: int32(name='InternetMaxBandWidthIn', description='The maximum inbound public bandwidth. Unit: Mbit/s. Valid values:

*   If the purchased outbound public bandwidth is less than or equal to 10 Mbit/s, the valid values of the parameter are 1 to 10 and the default value is 10.
*   If the purchased outbound public bandwidth is greater than 10 Mbit/s, the valid values of this parameter are 1 to the amount of the outbound bandwidth that is purchased.', example='10'),
  internetMaxBandWidthOut?: int32(name='InternetMaxBandWidthOut', description='The maximum outbound public bandwidth. Unit: Mbit/s. Valid values: 0 to 100.

Default value: 0', example='10'),
  jobQueue?: string(name='JobQueue', description='The queue to which the compute nodes are added.', example='workq'),
  minCount?: int32(name='MinCount', description='The minimum number of the compute nodes that you want to add. Valid values: 1 to 99. The value of the parameter is less than that of the Count parameter.

*   If the number of available ECS instances is less than the value of the MinCount parameter, the compute nodes cannot be added.
*   If the number of available ECS instances is greater than the value of the MinCount parameter and less than that of the Count parameter, the compute nodes are added based on the value of the MinCount parameter.
*   If the number of available ECS instances is greater than the value of the Count parameter, the compute nodes are added based on the value of the Count parameter.

Default value: 1', example='1'),
  networkInterfaceTrafficMode?: string(name='NetworkInterfaceTrafficMode', example='Standard'),
  period?: int32(name='Period', description='The duration of the subscription. The unit of the duration is specified by the PeriodUnit parameter. The parameter only takes effect when InstanceChargeType is set to PrePaid. Valid values:

*   If PeriodUnit is set to Week, the valid values of the Period parameter are 1, 2, 3, and 4.
*   Valid values when PeriodUnit is set to Month: 1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 24, 36, 48, and 60.

Default value: 1', example='1'),
  periodUnit?: string(name='PeriodUnit', description='The unit of the subscription period. Valid values:

*   Week
*   Month

Default value: Month', example='Month'),
  sync?: boolean(name='Sync', description='Specifies whether to set the API operation as a synchronous operation. Valid values:

*   true
*   false

Default value: false', example='false'),
  systemDiskLevel?: string(name='SystemDiskLevel', description='The performance level of the ESSD that is used as the system disk. Valid values:

*   PL0: A single ESSD can deliver up to 10,000 random read/write IOPS.
*   PL1: A single ESSD can deliver up to 50,000 random read/write IOPS.
*   PL2: A single ESSD can deliver up to 100,000 random read/write IOPS.
*   PL3: A single ESSD can deliver up to 1,000,000 random read/write IOPS.

Default value: PL1

For more information about ESSD performance parameters, see [ESSD](~~122389~~).', example='PL0'),
  systemDiskSize?: int32(name='SystemDiskSize', description='The size of the system disk. Unit: GiB

Valid values: 40 to 500

Default value: 40', example='40'),
  systemDiskType?: string(name='SystemDiskType', description='The type of the system disk. Valid values:

*   cloud_efficiency: ultra disk.
*   cloud_ssd: SSD.
*   cloud_essd: ESSD.
*   cloud: basic disk. Disks of this type are retired.

Default value: cloud_efficiency', example='cloud_ssd'),
  vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch.', example='vsw-bp1lfcjbfb099rrjn****'),
  zoneId?: string(name='ZoneId', description='The ID of the zone.', example='cn-hangzhou-b'),
}

model AddNodesResponseBody = {
  instanceIds?: {
    instanceId?: [ string ](name='InstanceId')
  }(name='InstanceIds', description='The ID of the instance.

>  AddNodes is an asynchronous API operation. If a request succeeds, a response is immediately generated before ECS instances are created. Therefore, the value of the parameter is null. You can call the [ListNodes](~~87161~~) operation to obtain the IDs of the ECS instances.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='B745C159-3155-4B94-95D0-4B73D4D2****'),
  taskId?: string(name='TaskId', description='The ID of the task.', example='B745C159-3155-4B94-95D0-4B73D4D2****'),
}

model AddNodesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddNodesResponseBody(name='body'),
}

async function addNodesWithOptions(request: AddNodesRequest, runtime: Util.RuntimeOptions): AddNodesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddNodes',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addNodes(request: AddNodesRequest): AddNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return addNodesWithOptions(request, runtime);
}

model AddQueueRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****'),
  queueName?: string(name='QueueName', description='The name of the queue. The name must be 1 to 63 characters in length and start with a letter. It can contain letters, digits, and underscores (\\_).', example='test1'),
}

model AddQueueResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='7ABFF29F-BD9C-4663-AD5D-E620FA48****'),
}

model AddQueueResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddQueueResponseBody(name='body'),
}

async function addQueueWithOptions(request: AddQueueRequest, runtime: Util.RuntimeOptions): AddQueueResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddQueue',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addQueue(request: AddQueueRequest): AddQueueResponse {
  var runtime = new Util.RuntimeOptions{};
  return addQueueWithOptions(request, runtime);
}

model AddSecurityGroupRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that the value is unique among different requests. The ClientToken value can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure the idempotence of a request](~~25693~~).', example='123e4567-e89b-12d3-a456-426655440000'),
  clusterId?: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****'),
  securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group.

You can call the [DescribeSecurityGroups](~~25556~~) operation to query available security groups in the current region.', example='sg-bp13n61xsydodfyg****'),
}

model AddSecurityGroupResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model AddSecurityGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddSecurityGroupResponseBody(name='body'),
}

async function addSecurityGroupWithOptions(request: AddSecurityGroupRequest, runtime: Util.RuntimeOptions): AddSecurityGroupResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddSecurityGroup',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addSecurityGroup(request: AddSecurityGroupRequest): AddSecurityGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return addSecurityGroupWithOptions(request, runtime);
}

model AddUsersRequest {
  async?: boolean(name='Async'),
  clusterId?: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****'),
  user?: [ 
    {
      group?: string(name='Group', description='The permission group to which the user belongs. Valid values:

*   users: an ordinary permission group. It is applicable to ordinary users that need only to submit and debug jobs.
*   wheel: a sudo permission group. It is applicable to the administrator who needs to manage the cluster. In addition to submitting and debugging jobs, users who have sudo permissions can run sudo commands to install software and restart nodes.

Valid values of N: 1 to 100', example='users'),
      name?: string(name='Name', description='The name of the user that you want to add. The name must be 6 to 30 characters in length and can contain letters, digits, and periods (.). It must start with a letter.

Valid values of N: 1 to 100', example='user1'),
      password?: string(name='Password', description='The password of the user. The password must be 8 to 30 characters in length and contain three of the following items:

*   Uppercase letter
*   Lowercase letter
*   Digit
*   Special character: `()~!@#$%^&*-_+=|{}[]:;\\"/<>,.?/`

Valid values of N: 1 to 100

>  We recommend that you use HTTPS to call the AddUsers operation to ensure that the password remains confidential.', example='1@a2****'),
    }
  ](name='User'),
}

model AddUsersResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model AddUsersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddUsersResponseBody(name='body'),
}

async function addUsersWithOptions(request: AddUsersRequest, runtime: Util.RuntimeOptions): AddUsersResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddUsers',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addUsers(request: AddUsersRequest): AddUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return addUsersWithOptions(request, runtime);
}

model ApplyNodesRequest {
  allocatePublicAddress?: boolean(name='AllocatePublicAddress', description='Specifies whether to allocate a public IP address to the compute nodes. Valid values:

*   true: A public IP address is allocated to the compute nodes.
*   false: A public IP address is not allocated to the compute nodes.

Default value: false', example='false'),
  clusterId?: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87126~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****'),
  computeSpotPriceLimit?: float(name='ComputeSpotPriceLimit', description='The maximum hourly price of the compute nodes. The value is a floating-point number that supports up to three decimal places. The parameter takes effect only when ComputeSpotStrategy is set to SpotWithPriceLimit.

If ComputeSpotPriceLimit and InstanceTypeModel.N.MaxPrice are specified at the same time, compute nodes are created based on the smaller value of these parameters.', example='0.68'),
  computeSpotStrategy?: string(name='ComputeSpotStrategy', description='The preemption policy of the compute nodes. Valid values:

*   NoSpot: The compute nodes use the pay-as-you-go billing method.
*   SpotWithPriceLimit: The compute nodes are preemptible instances that have a user-defined maximum hourly price.
*   SpotAsPriceGo: The compute nodes are preemptible instances for which the market price at the time of purchase is used as the bid price.

Default value: NoSpot', example='NoSpot'),
  cores?: int32(name='Cores', description='The number of vCPUs. The parameter is required when the ResourceAmountType parameter is set to Cores.

You can set Cores, vCPU, and Memory to query node specifications. For example, you can query the available compute nodes that have 2 vCPUs and 16 GB of memory by setting vCPU to 2 and Memory to 16. You can also query compute nodes by zone. Query results are sorted by price.', example='2'),
  hostNamePrefix?: string(name='HostNamePrefix', description='The prefix of the hostname. You can specify the parameter to manage the compute nodes in an efficient manner.', example='compute'),
  hostNameSuffix?: string(name='HostNameSuffix', description='The suffix of the hostname. You can specify the parameter to manage the compute nodes in an efficient manner.', example='01'),
  imageId?: string(name='ImageId', description='The image ID of the compute nodes to be added. The parameter takes effect only when the TargetImageId parameter is not specified.

You can call the [ListImages](~~87213~~) and [ListCustomImages](~~87215~~) operations to query the image ID.

>  If you add multiple compute nodes, the TargetImageId parameter takes effect only on the nodes for which the TargetImageId parameter is specified.', example='centos_7_06_64_20G_alibase_20190711.vhd'),
  instanceFamilyLevel?: string(name='InstanceFamilyLevel', description='The level of the instance family. The parameter takes effect only when Cores and Memory are specified. Valid values:

*   EntryLevel.
*   EnterpriseLevel.
*   CreditEntryLevel. For more information, see [What are burstable instances?](~~59977~~)

Default value: EnterpriseLevel', example='EntryLevel'),
  instanceTypeModel?: [ 
    {
      instanceType?: string(name='InstanceType', description='The instance type of the compute node. The default value is the instance type that was specified when you created the cluster or the last time when you added compute nodes.

Valid values of N: 1 to 10', example='ecs.n1.tiny'),
      maxPrice?: float(name='MaxPrice', description='The maximum hourly price that you can pay for the preemptible node. The value is a floating-point number that supports up to three decimal places.

The parameter takes effect only when ComputeSpotStrategy is set to SpotWithPriceLimit.

Valid values of N: 1 to 10', example='0.034'),
      targetImageId?: string(name='TargetImageId', description='The image ID of the compute node. You must select a Windows image.

Valid values of N: 1 to 10', example='win2016_1607_x64_dtc_zh-cn_40G_alibase_20210516.vhd'),
    }
  ](name='InstanceTypeModel'),
  internetChargeType?: string(name='InternetChargeType', description='The billing method of the elastic IP address (EIP). Valid values:

*   PayByBandwidth: pay-by-bandwidth
*   PayByTraffic: pay-by-traffic', example='PayByTraffic'),
  internetMaxBandWidthIn?: int32(name='InternetMaxBandWidthIn', description='The maximum inbound public bandwidth. Unit: Mbit/s. Valid values:

*   If the purchased outbound public bandwidth is less than or equal to 10 Mbit/s, the valid values of the parameter are 1 to 10 and the default value is 10.
*   If the purchased outbound public bandwidth is greater than 10 Mbit/s, the valid values of this parameter are 1 to the amount of the outbound bandwidth that is purchased.', example='10'),
  internetMaxBandWidthOut?: int32(name='InternetMaxBandWidthOut', description='The maximum outbound public bandwidth. Unit: Mbit/s. Valid values: 0 to 100.

Default value: 0', example='10'),
  interval?: int32(name='Interval', description='The interval between two consecutive batches. Valid values: 60 to 600. Unit: seconds.

Default value: 60', example='60'),
  jobQueue?: string(name='JobQueue', description='The queue to which the compute nodes are added.

You can call the [ListQueues](~~92176~~) operation to query the queue name.', example='workq'),
  memory?: int32(name='Memory', description='The memory capacity. The parameter is required when the ResourceAmountType parameter is set to Cores. Unit: GB.

You can set Cores, vCPU, and Memory to query node specifications. For example, you can query the available compute nodes that have 2 vCPUs and 16 GB of memory by setting vCPU to 2 and Memory to 16. You can also query compute nodes by zone. Query results are sorted by price.', example='16'),
  priorityStrategy?: string(name='PriorityStrategy', description='The application policy of the preemptible nodes. Valid values:

*   LowPriceResourcePlanning: Preemptible nodes are created based on the unit prices of vCPUs in ascending order. Preemptible nodes are created first when preemptible instance types are specified.
*   CapacityOptResourcePlanning: Preemptible nodes are created based on the prices and release rates in ascending order.
*   CustomizedResourcePlanning: Nodes are added based on the predefined value of the ZoneIds.N parameter. Instances of a zone that has a higher priority are used first.', example='LowPriceResourcePlanning'),
  resourceAmountType?: string(name='ResourceAmountType', description='The type of the resource to be added. Valid values:

*   Instances: compute node
*   Cores: vCPU and memory

Default value: Instances', example='Instances'),
  round?: int32(name='Round', description='The total number of batches to create nodes. Valid values: 1 to 10.

Default value: 1', example='1'),
  strictResourceProvision?: boolean(name='StrictResourceProvision', description='Specifies whether to strictly meet the requirements of the TargetCapacity parameter. The parameter takes effect only when StrictSatisfiedTargetCapacity is set to true. Valid values:

*   true: Check the inventory of the resources. Compute nodes are created based on the value of the TargetCapacity parameter only when the available resources are sufficient. Otherwise, no compute nodes are created.
*   false: Check the inventory of the resources. Compute nodes are created only when the available resources are sufficient. However, some compute nodes may fail to be created because resources become insufficient after the inventory is checked.

Default value: false', example='false'),
  strictSatisfiedTargetCapacity?: boolean(name='StrictSatisfiedTargetCapacity', description='Specifies whether to meet the requirements of the TargetCapacity parameter. Valid values:

*   true: If the available resources are fewer than the resources that you want to add, no compute nodes are created and an error is returned. If the available resources are more than the resources that you want to add, the following cases may occur:

    *   If StrictResourceProvision is set to true, check the inventory of the resources. Compute nodes are created based on the value of the TargetCapacity parameter only when the available resources are sufficient. Otherwise, no compute nodes are created.
    *   If StrictResourceProvision is set to false, check the inventory of the resources. Compute nodes are created only when the available resources are sufficient. However, some compute nodes may fail to be created because resources become insufficient after the inventory is checked.

*   false: If the available resources are insufficient, compute nodes are created based on the inventory of the resources.

Default value: true', example='true'),
  systemDiskLevel?: string(name='SystemDiskLevel', description='The performance level of the ESSD used as the system disk. Valid values:

*   PL0: A single ESSD can deliver up to 10,000 random read/write IOPS.
*   PL1: A single ESSD can deliver up to 50,000 random read/write IOPS.
*   PL2: A single ESSD can deliver up to 100,000 random read/write IOPS.
*   PL3: A single ESSD can deliver up to 1,000,000 random read/write IOPS.

Default value: PL0

For more information, see [ESSDs](~~122389~~).', example='PL0'),
  systemDiskSize?: int32(name='SystemDiskSize', description='The size of the system disk. Unit: GB.

Valid values: 40 to 500

Default value: 40', example='40'),
  systemDiskType?: string(name='SystemDiskType', description='The type of the system disk. Valid values:

*   cloud_efficiency: ultra disk.
*   cloud_ssd: SSD.
*   cloud_essd: ESSD.
*   cloud: basic disk. Disks of this type are retired.', example='cloud_ssd'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key of the compute node that you want to attach. Valid values of N: 1 to 20. The tag key cannot be an empty string. It can be up to 128 characters in length and cannot start with acs: or aliyun. It cannot contain http:// or https://.

Valid values of N: 1 to 10', example='TestKey'),
      value?: string(name='Value', description='The tag value of the compute node that you want to add. Valid values of N: 1 to 20. The tag value can be an empty string. It can be up to 128 characters in length and cannot start with acs: or contain http:// or https://.

Valid values of N: 1 to 10', example='TestValue'),
    }
  ](name='Tag'),
  targetCapacity?: int32(name='TargetCapacity', description='The number of the resource that you want to add. The specific number depends on the value of the ResourceAmountType parameter:

*   If ResourceAmountType is set to Instance, the value range of TargetCapacity is 1 to 200.
*   If ResourceAmountType is set to Cores, the value range of TargetCapacity is 1 to 1,000.', example='20'),
  zoneInfos?: [ 
    {
      vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch. Valid values of N: 1 to 10.', example='vsw-bp1e47optm9g58zcu****'),
      zoneId?: string(name='ZoneId', description='The ID of the zone to which the cluster belongs. Valid values of N: 1 to 10.

>  Each zone ID must be unique.', example='cn-hangzhou-b'),
    }
  ](name='ZoneInfos'),
}

model ApplyNodesResponseBody = {
  detail?: string(name='Detail', description='The detailed result of the request.', example='Resources Application is satisfied. Creating...'),
  instanceIds?: {
    instanceId?: [ string ](name='InstanceId')
  }(name='InstanceIds', description='The ID of the Elastic Compute Service (ECS) instance.

>  AddNodes is an asynchronous API operation. If a request succeeds, a response is immediately generated before ECS instances are created. Therefore, the value of the parameter is null. You can call the [ListNodes](~~87161~~) operation to query the ID of the ECS instance.'),
  requestId?: string(name='RequestId', description='The ID of the task.', example='B745C159-3155-4B94-95D0-4B73D4D2****'),
  satisfiedAmount?: int32(name='SatisfiedAmount', description='The number of the compute nodes that were created.', example='10'),
  taskId?: string(name='TaskId', description='The ID of the request.', example='B745C159-3155-4B94-95D0-4B73D4D2****'),
}

model ApplyNodesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ApplyNodesResponseBody(name='body'),
}

/**
  * You can call the ApplyNodes operation to specify the number of compute nodes, the number of vCPUs, and the memory size when you add nodes to a cluster.
  *
  * @param request ApplyNodesRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ApplyNodesResponse
 */
async function applyNodesWithOptions(request: ApplyNodesRequest, runtime: Util.RuntimeOptions): ApplyNodesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ApplyNodes',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call the ApplyNodes operation to specify the number of compute nodes, the number of vCPUs, and the memory size when you add nodes to a cluster.
  *
  * @param request ApplyNodesRequest
  * @return ApplyNodesResponse
 */
async function applyNodes(request: ApplyNodesRequest): ApplyNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return applyNodesWithOptions(request, runtime);
}

model CreateClusterRequest {
  ecsOrder?: {
    compute?: {
        count?: int32(name='Count', description='The number of the compute nodes. Valid values: 1 to 99.', example='1'),
        instanceType?: string(name='InstanceType', description='The instance type of the compute nodes.

You can call the [ListPreferredEcsTypes](~~188592~~) operation to query the recommended instance types.', example='ecs.n1.tiny'),
    }(name='Compute'),
    login?: {
        count?: int32(name='Count', description='The number of the logon nodes. Valid value: 1.', example='1'),
        instanceType?: string(name='InstanceType', description='The instance type of the logon nodes.

You can call the [ListPreferredEcsTypes](~~188592~~) operation to query the recommended instance types.', example='ecs.n1.tiny'),
    }(name='Login'),
    manager?: {
        count?: int32(name='Count', description='The number of the management nodes. Valid values: 1 and 2.', example='1'),
        instanceType?: string(name='InstanceType', description='The instance type of the management nodes.

You can call the [ListPreferredEcsTypes](~~188592~~) operation to query the recommended instance types.', example='ecs.n1.tiny'),
    }(name='Manager'),
  }(name='EcsOrder'),
  accountType?: string(name='AccountType', description='The type of the domain account service. Valid values:

*   nis
*   ldap

Default value: nis', example='nis'),
  additionalVolumes?: [ 
    {
      jobQueue?: string(name='JobQueue', description='The queue of the nodes to which the additional file system is attached.

Valid values of N: 1 to 10', example='high'),
      localDirectory?: string(name='LocalDirectory', description='The local directory on which the additional file system is mounted.

Valid values of N: 1 to 10', example='/ff'),
      location?: string(name='Location', description='The type of the E-HPC cluster. Set the value to PublicCloud.

Valid values of N: 1 to 10', example='PublicCloud'),
      remoteDirectory?: string(name='RemoteDirectory', description='The remote directory on which the additional file system is mounted.

Valid values of N: 1 to 10', example='/test'),
      roles?: [ 
        {
          name?: string(name='Name', description='The type of the nodes to which the additional file system is attached.

Valid values of N in AdditionalVolumes.N.Roles: 1 to 10

Valid values of N in Roles.N.Name: 0 to 8', example='["Compute"]'),
        }
      ](name='Roles'),
      volumeId?: string(name='VolumeId', description='The ID of the additional file system.

Valid values of N: 1 to 10', example='extreme-00b88****'),
      volumeMountOption?: string(name='VolumeMountOption', description='The mount options of the additional file system.

Valid values of N: 1 to 10', example='-t nfs -o vers=4.0'),
      volumeMountpoint?: string(name='VolumeMountpoint', description='The mount target of the additional file system.

Valid values of N: 1 to 10', example='0088****-sihc.cn-hangzhou.extreme.nas.aliyuncs.com'),
      volumeProtocol?: string(name='VolumeProtocol', description='The type of the protocol that is used by the additional file system. Valid values:

*   NFS
*   SMB

Valid values of N: 1 to 10

Default value: NFS', example='NFS'),
      volumeType?: string(name='VolumeType', description='The type of the additional shared storage. Only NAS file systems are supported.

Valid values of N: 1 to 10', example='nas'),
    }
  ](name='AdditionalVolumes'),
  application?: [ 
    {
      tag?: string(name='Tag', description='The tag of the software.

Valid values of N: 0 to 100

You can call the [ListSoftwares](~~87216~~) operation to query the tag of the software.', example='OpenMPI_11.1'),
    }
  ](name='Application'),
  autoRenew?: string(name='AutoRenew', description='Specifies whether to enable auto-renewal for the subscription. Valid values:

*   true
*   false

Default value: false', example='false'),
  autoRenewPeriod?: int32(name='AutoRenewPeriod', description='The auto-renewal period of the subscription compute nodes. The parameter takes effect when AutoRenew is set to true.', example='1'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that the value is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence of a request?](~~25693~~)', example='123e4567-e89b-12d3-a456-426655440000'),
  clientVersion?: string(name='ClientVersion', description='The version of the E-HPC client. By default, the parameter is set to the latest version number.

You can call the [ListCurrentClientVersion](~~87223~~) operation to query the latest version of the E-HPC client.', example='1.0.64'),
  clusterVersion?: string(name='ClusterVersion', description='The version of the E-HPC cluster.

Default value: 1.0', example='1.0'),
  computeEnableHt?: boolean(name='ComputeEnableHt', description='Specifies whether the compute nodes support hyper-threading. Valid values:

*   true
*   false

Default value: true', example='true'),
  computeSpotPriceLimit?: string(name='ComputeSpotPriceLimit', description='The maximum hourly price of the compute nodes. A maximum of three decimal places can be used in the value of the parameter. The parameter is valid only when the ComputeSpotStrategy parameter is set to SpotWithPriceLimit.', example='0.034'),
  computeSpotStrategy?: string(name='ComputeSpotStrategy', description='The bidding method of the compute nodes. Valid values:

*   NoSpot: The compute nodes are pay-as-you-go instances.
*   SpotWithPriceLimit: The compute nodes are preemptible instances that have a user-defined maximum hourly price.
*   SpotAsPriceGo: The compute nodes are preemptible instances for which the market price at the time of purchase is used as the bid price.

Default value: NoSpot', example='NoSpot'),
  deployMode?: string(name='DeployMode', description='The mode in which the E-HPC cluster is deployed. Valid values:

*   Standard: An account node, a scheduling node, a logon node, and multiple compute nodes are separately deployed.
*   Simple: A management node, a logon node, and multiple compute nodes are deployed. The management node consists of an account node and a scheduling node. The logon node and compute nodes are separately deployed.
*   Tiny: A management node and multiple compute nodes are deployed. The management node consists of an account node, a scheduling node, and a logon node. The compute nodes are separately deployed.

Default value: Standard', example='Simple'),
  description?: string(name='Description', description='The description of the E-HPC cluster. The description must be 2 to 256 characters in length. It cannot start with http:// or https://.', example='TestDescription'),
  domain?: string(name='Domain', description='The domain name of the on-premises E-HPC cluster.

This parameter takes effect only when the AccoutType parameter is set to Idap.', example='ldap'),
  ecsChargeType?: string(name='EcsChargeType', description='The billing method of the nodes. Valid values:

*   PostPaid: pay-as-you-go
*   PrePaid: subscription

If you set the parameter to PrePaid, auto-renewal is enabled by default.', example='PostPaid'),
  ehpcVersion?: string(name='EhpcVersion', description='The version of E-HPC. By default, the parameter is set to the latest version number.', example='1.0.0'),
  haEnable?: boolean(name='HaEnable', description='Specifies whether to enable the high availability feature. Valid values:

*   true
*   false

Default value: false

>  If high availability is enabled, a primary management node and a secondary management node are used.', example='true'),
  imageId?: string(name='ImageId', description='The ID of the image.

You can call the [ListImages](~~87213~~) and [ListCustomImages](~~87215~~) operations to query the images that are supported by E-HPC.', example='centos_7_02_64_20G_alibase_20170818****'),
  imageOwnerAlias?: string(name='ImageOwnerAlias', description='The type of the image. Valid values:

*   system: public image
*   self: custom image
*   others: shared image

Default value: system', example='self'),
  inputFileUrl?: string(name='InputFileUrl', description='The URL of the job files that are uploaded to an Object Storage Service (OSS) bucket.', example='https://ehpc-tianshui.oss-cn-beijing.aliyuncs.com/test-u****/testlist_ehpc.sh'),
  isComputeEss?: boolean(name='IsComputeEss', description='Specifies whether to enable auto scaling. Valid values:

*   true
*   false

Default value: false', example='false'),
  jobQueue?: string(name='JobQueue', description='The queue to which the compute nodes are added.', example='workq'),
  keyPairName?: string(name='KeyPairName', description='The name of the AccessKey pair.

>  For more information, see [Create an SSH key pair](~~51793~~).', example='test'),
  name?: string(name='Name', description='The name of the E-HPC cluster. The name must be 2 to 64 characters in length.', example='test'),
  networkInterfaceTrafficMode?: string(name='NetworkInterfaceTrafficMode', example='Standard'),
  osTag?: string(name='OsTag', description='The operating system tag of the image.', example='CentOS_7.2_64'),
  password?: string(name='Password', description='The root password of the logon node. The password must be 8 to 30 characters in length and contain at least three of the following items: uppercase letters, lowercase letters, digits, and special characters. The password can contain the following special characters:

`( ) ~ ! @ # $ % ^ & * - + = | { } [ ] : ;  < > , . ? /`

You must specify either Password or KeyPairName. If both are specified, the Password parameter prevails.

>  We recommend that you use HTTPS to call the API operation to prevent password leakages.', example='123****'),
  period?: int32(name='Period', description='The duration of the subscription. The unit of the duration is specified by the `PeriodUnit` parameter.

*   If you set PriceUnit to Year, the valid values of the Period parameter are 1, 2, and 3.
*   If you set PriceUnit to Month, the valid values of the Period parameter are 1, 2, 3, 4, 5, 6, 7, 8, and 9.
*   If you set PriceUnit to Hour, the valid value of the Period parameter is 1.

Default value: 1', example='1'),
  periodUnit?: string(name='PeriodUnit', description='The unit of the subscription duration. Valid values:

*   Year
*   Month
*   Hour

Default value: Month', example='Year'),
  plugin?: string(name='Plugin', description='The mode configurations of the plug-in. This parameter takes effect only when the SchedulerType parameter is set to custom.

The value must be a JSON string. The parameter contains the following parameters: pluginMod, pluginLocalPath, and pluginOssPath.

*   pluginMod: the mode of the plug-in. The following modes are supported:

    *   oss: The plug-in is downloaded and decompressed from OSS to a local path. The local path is specified by the pluginLocalPath parameter.
    *   image: By default, the plug-in is stored in a pre-defined local path. The local path is specified by the pluginLocalPath parameter.

*   pluginLocalPath: the local path where the plug-in is stored. We recommend that you select a shared directory in oss mode and a non-shared directory in image mode.

*   pluginOssPath: the remote path where the plug-in is stored in OSS. This parameter takes effect only when the pluginMod parameter is set to oss.', example='{"pluginMod": "oss","pluginLocalPath": "/opt/plugin","pluginOssPath": "https://bucket.oss-cn-hangzhou.aliyuncs.com/plugin/plugin.tgz"}'),
  postInstallScript?: [ 
    {
      args?: string(name='Args', description='The parameter that is used to run the script after the E-HPC cluster is created.

Valid values of N: 0 to 16', example='bashfile.sh'),
      url?: string(name='Url', description='The URL that is used to download the script after the E-HPC cluster is created.

Valid values of N: 0 to 16', example='/opt/job.sh'),
    }
  ](name='PostInstallScript'),
  ramNodeTypes?: [ string ](name='RamNodeTypes'),
  ramRoleName?: string(name='RamRoleName', description='The name of the Resource Access Management (RAM) role.

You can call the [ListRoles](~~28713~~) operation provided by RAM to query the created RAM roles.', example='testRamRoleName'),
  remoteDirectory?: string(name='RemoteDirectory', description='The remote directory on which the file system is mounted.', example='NasMountpoint:/RemoteDirectory'),
  remoteVisEnable?: string(name='RemoteVisEnable', description='Specifies whether to enable Virtual Network Computing (VNC). Valid values:

*   true
*   false

Default value: false', example='false'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.

You can call the [ListResourceGroups](~~158855~~) operation to obtain the ID of the resource group.', example='rg-acfmxazb4ph****'),
  sccClusterId?: string(name='SccClusterId', description='The ID of the Super Computing Cluster (SCC) instance.

If you specify the parameter, the SCC instance is moved to a new SCC cluster.', example='00b648b****'),
  schedulerType?: string(name='SchedulerType', description='The type of the scheduler. Valid values:

*   pbs
*   slurm
*   opengridscheduler
*   deadline

Default value: pbs', example='pbs'),
  securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group to which the E-HPC cluster belongs.

You can call the [DescribeSecurityGroups](~~25556~~) operation to query available security groups in the current region.', example='sg-bp13n61xsydodfyg****'),
  securityGroupName?: string(name='SecurityGroupName', description='If you do not use an existing security group, set the parameter to the name of a new security group. A default policy is applied to the new security group.', example='ehpc-SecurityGroup'),
  systemDiskLevel?: string(name='SystemDiskLevel', description='The performance level of the ESSD that is used as the system disk. Valid values:

*   PL0: An ESSD can deliver up to 10,000 random read/write IOPS.
*   PL1: A single ESSD can deliver up to 50,000 random read/write IOPS.
*   PL2: A single ESSD can deliver up to 100,000 random read/write IOPS.
*   PL3: An ESSD delivers up to 1,000,000 random read/write IOPS.

Default value: PL1

For more information, see [ESSDs](~~122389~~).', example='PL0'),
  systemDiskSize?: int32(name='SystemDiskSize', description='The size of the system disk. Unit: GB.

Valid values: 40 to 500

Default value: 40', example='40'),
  systemDiskType?: string(name='SystemDiskType', description='The type of the system disk. Valid values:

*   cloud_efficiency: ultra disk.
*   cloud_ssd: standard SSD.
*   cloud_essd: enhanced SSD (ESSD).
*   cloud: basic disk. Disks of this type are retired.

Default value: cloud_ssd', example='cloud_ssd'),
  tag?: [ 
    {
      key?: string(name='Key', description='The key of the tag.', example='TestKey'),
      value?: string(name='Value', description='The value of the tag.', example='TestValue'),
    }
  ](name='Tag'),
  vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch. E-HPC supports only VPC networks.

You can call the [DescribeVSwitches](~~35748~~) operation to query available vSwitches.', example='vsw-bp1lfcjbfb099rrjn****'),
  volumeId?: string(name='VolumeId', description='The ID of the file system. If you leave the parameter empty, a Performance NAS file system is created by default.

You can call the [ListFileSystemWithMountTargets](~~204364~~) operation to query available mount targets.', example='008b64****'),
  volumeMountOption?: string(name='VolumeMountOption', description='The mount options of the NFS file system that you want to mount by running the mount command.

For more information, see [Mount an NFS file system on a Linux ECS instance](https://www.alibabacloud.com/help/en/nas/latest/mount-an-nfs-file-system-on-a-linux-ecs-instance#section-jyi-hyd-hbr).', example='-t nfs -o vers=4'),
  volumeMountpoint?: string(name='VolumeMountpoint', description='The mount target of the file system. Take note of the following information:

*   If you do not specify the VolumeId parameter, you can leave the VolumeMountpoint parameter empty. A mount target is created by default.
*   If you specify the VolumeId parameter, the VolumeMountpoint parameter is required. You can call the [ListFileSystemWithMountTargets](~~204364~~) operation to query available mount targets.', example='008b648bcb-s****.cn-hangzhou.nas.aliyuncs.com'),
  volumeProtocol?: string(name='VolumeProtocol', description='The type of the protocol that is used by the file system. Valid values:

*   NFS
*   SMB

Default value: NFS', example='NFS'),
  volumeType?: string(name='VolumeType', description='The type of the shared storage. Set the value to `nas`, which indicates a NAS file system.', example='nas'),
  vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC) to which the E-HPC cluster belongs.

You can call the [DescribeVpcs](~~35739~~) operation to query available VPCs.', example='vpc-b3f3edefefeep0760yju****'),
  withoutAgent?: boolean(name='WithoutAgent', description='Specifies whether not to install the agent.

*   true: The agent is not installed.
*   false: The agent is installed.

Default value: false', example='false'),
  withoutElasticIp?: boolean(name='WithoutElasticIp', description='Specifies whether the logon node uses an elastic IP address (EIP). Default value: false', example='true'),
  zoneId?: string(name='ZoneId', description='The ID of the zone.

You can call the [ListRegions](~~188593~~) and [DescribeZones](~~25610~~) operations to query IDs of the zones where E-HPC is supported.', example='cn-hangzhou-b'),
}

model CreateClusterResponseBody = {
  clusterId?: string(name='ClusterId', description='The ID of the E-HPC cluster.', example='ehpc-hz-FYUr32****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='F6757FA4-8FED-4602-B7F5-3550C084****'),
  taskId?: string(name='TaskId', description='The ID of the task.

>  CreateCluster is an asynchronous API operation. If a request succeeds, a response is immediately generated before nodes are created. You can call the [ListTasks](~~268225~~) operation to query the result of the task.', example='F6757FA4-8FED-4602-B7F5-3550C084****'),
}

model CreateClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateClusterResponseBody(name='body'),
}

/**
  * After you create an Elastic High Performance Computing (E-HPC) cluster, you are charged for the cluster resources that you use. We recommend that you learn about the billing methods of E-HPC in advance. For more information, see [Billing overview](~~57844~~).
  *
  * @param request CreateClusterRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateClusterResponse
 */
async function createClusterWithOptions(request: CreateClusterRequest, runtime: Util.RuntimeOptions): CreateClusterResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateCluster',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * After you create an Elastic High Performance Computing (E-HPC) cluster, you are charged for the cluster resources that you use. We recommend that you learn about the billing methods of E-HPC in advance. For more information, see [Billing overview](~~57844~~).
  *
  * @param request CreateClusterRequest
  * @return CreateClusterResponse
 */
async function createCluster(request: CreateClusterRequest): CreateClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return createClusterWithOptions(request, runtime);
}

model CreateGWSClusterRequest {
  clusterType?: string(name='ClusterType', example='gws.s1.standard'),
  name?: string(name='Name', example='TestGWS'),
  vSwitchId?: string(name='VSwitchId', example='vsw-bp1lfcjbfb099rrjn****'),
  vpcId?: string(name='VpcId', description='VPC ID', example='vpc-bp1se4wjbp0760yju****'),
}

model CreateGWSClusterResponseBody = {
  clusterId?: string(name='ClusterId', example='gws-rhz397kdngua****'),
  requestId?: string(name='RequestId', example='5198C3E8-85F5-4280-8547-687C1710FE08'),
}

model CreateGWSClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateGWSClusterResponseBody(name='body'),
}

async function createGWSClusterWithOptions(request: CreateGWSClusterRequest, runtime: Util.RuntimeOptions): CreateGWSClusterResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateGWSCluster',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createGWSCluster(request: CreateGWSClusterRequest): CreateGWSClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return createGWSClusterWithOptions(request, runtime);
}

model CreateGWSImageRequest {
  instanceId?: string(name='InstanceId', description='The ID of the visualization instance.', example='i-bp66guhybgtrftpa1****'),
  name?: string(name='Name', description='The image name of the visualization instance.', example='EHPC-TEST'),
}

model CreateGWSImageResponseBody = {
  imageId?: string(name='ImageId', description='The image ID of the visualization instance.', example='ehs-fakeid-****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='5198C3E8-85F5-4280-8547-687C1710FE08'),
}

model CreateGWSImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateGWSImageResponseBody(name='body'),
}

async function createGWSImageWithOptions(request: CreateGWSImageRequest, runtime: Util.RuntimeOptions): CreateGWSImageResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateGWSImage',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createGWSImage(request: CreateGWSImageRequest): CreateGWSImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return createGWSImageWithOptions(request, runtime);
}

model CreateGWSInstanceRequest {
  allocatePublicAddress?: boolean(name='AllocatePublicAddress', example='false'),
  appList?: string(name='AppList', example='[{AppName: notepad},{AppArgs:c:/temp.txt}]'),
  autoRenew?: boolean(name='AutoRenew', example='false'),
  clusterId?: string(name='ClusterId', example='gws-rhzxpazwebua****'),
  imageId?: string(name='ImageId', example='ehs-faeid-****'),
  instanceChargeType?: string(name='InstanceChargeType', example='Postpaid'),
  instanceType?: string(name='InstanceType', example='ecs.g6.large'),
  internetChargeType?: string(name='InternetChargeType', example='PayByTraffic'),
  internetMaxBandwidthIn?: int32(name='InternetMaxBandwidthIn', example='122'),
  internetMaxBandwidthOut?: int32(name='InternetMaxBandwidthOut', example='122'),
  name?: string(name='Name', example='Test-ehpc'),
  period?: string(name='Period', example='1'),
  periodUnit?: string(name='PeriodUnit', example='Month'),
  systemDiskCategory?: string(name='SystemDiskCategory', example='cloud'),
  systemDiskSize?: int32(name='SystemDiskSize', example='20'),
  vSwitchId?: string(name='VSwitchId', example='vsw-bp1gb5gf5546rn****'),
  workMode?: string(name='WorkMode', example='Desktop'),
}

model CreateGWSInstanceResponseBody = {
  instanceId?: string(name='InstanceId', example='i-bp1bzqddeemudsdsdsdsdn****'),
  requestId?: string(name='RequestId', example='5198C3E8-85F5-4280-8547-687C1710FE08'),
}

model CreateGWSInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateGWSInstanceResponseBody(name='body'),
}

async function createGWSInstanceWithOptions(request: CreateGWSInstanceRequest, runtime: Util.RuntimeOptions): CreateGWSInstanceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateGWSInstance',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createGWSInstance(request: CreateGWSInstanceRequest): CreateGWSInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createGWSInstanceWithOptions(request, runtime);
}

model CreateHybridClusterRequest {
  ecsOrder?: {
    compute?: {
        instanceType?: string(name='InstanceType', description='The instance type of the compute nodes.', example='ecs.n1.tiny'),
    }(name='Compute'),
    manager?: {
        instanceType?: string(name='InstanceType', description='The instance type of the management node on the cloud. Only Proxy Mode is supported.', example='ecs.n1.tiny'),
    }(name='Manager'),
  }(name='EcsOrder'),
  application?: [ 
    {
      tag?: string(name='Tag', description='The tag of the application. Valid values of N: 1 to 5.', example='OpenMPI_11.1'),
    }
  ](name='Application'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that the value is unique among different requests. The ClientToken value can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure the idempotence of a request](~~25693~~).', example='123e4567-e89b-12d3-a456-426655440000'),
  clientVersion?: string(name='ClientVersion', description='The version of the client. By default, the latest version is used.', example='1.0.64'),
  computeSpotPriceLimit?: float(name='ComputeSpotPriceLimit', description='The maximum hourly price for the ECS instance under the compute node. A maximum of three decimal places can be used in the value of the parameter. The parameter is valid only when the ComputeSpotStrategy parameter is set to SpotWithPriceLimit.', example='0.034'),
  computeSpotStrategy?: string(name='ComputeSpotStrategy', description='The preemption policy of the compute nodes. Valid values:

*   NoSpot: The compute nodes are pay-as-you-go instances.
*   SpotWithPriceLimit: The instances of the compute node are preemptible instances. These types of instances have a specified maximum hourly price.
*   SpotAsPriceGo: The instances of the compute node are preemptible instances. The price of these instances is based on the current market price.

Default value: NoSpot', example='NoSpot'),
  description?: string(name='Description', description='The description of the cluster. The description must be 2 to 256 characters in length. It cannot start with http:// or https://.

Default value: null', example='TestDescription'),
  domain?: string(name='Domain', description='The type of the domain account service. Valid values:

*   nis
*   ldap

Default value: nis', example='nis'),
  ehpcVersion?: string(name='EhpcVersion', description='The version of E-HPC. By default, the latest version is used.', example='1.0.0'),
  imageId?: string(name='ImageId', description='The ID of the image.', example='wi_1607_x64_dtc_zh_40G_alibase****'),
  imageOwnerAlias?: string(name='ImageOwnerAlias', description='The type of the image. Valid values:

*   system: public image
*   self: custom image
*   others: shared image
*   marketplace: Alibaba Cloud Marketplace image', example='system'),
  jobQueue?: string(name='JobQueue', description='The default queue of the scale-out nodes.', example='workq'),
  keyPairName?: string(name='KeyPairName', description='The name of the AccessKey pair. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with http:// or https://. It can contain letters, digits, colons (:), underscores (\\_), and hyphens (-).

>  For more information, see [Create an SSH key pair](~~51793~~).', example='test'),
  location?: string(name='Location', description='The location where the cluster resides. Set the value to OnPremise.', example='OnPremise'),
  multiOs?: boolean(name='MultiOs', description='Specifies whether the cluster supports multiple operating systems. Valid values:

*   true
*   false

Default value: false', example='false'),
  name?: string(name='Name', description='The name of the cluster. The name must be 2 to 64 characters in length, and can contain only letters, digits, hyphens (-), and underscores (\\_). It must start with a letter.', example='hybridcluster'),
  nodes?: [ 
    {
      accountType?: string(name='AccountType', description='The service type of the domain account to which the on-premises node in the cluster belongs. Valid values:

*   nis
*   ldap

Default value: nis', example='nis'),
      dir?: string(name='Dir', description='The directory of the on-premises node in the cluster.', example='/opt/sge/default/'),
      hostName?: string(name='HostName', description='The hostname of the on-premises node in the cluster.', example='test1'),
      ipAddress?: string(name='IpAddress', description='The IP address of the on-premises node in the cluster.', example='00b648b****'),
      role?: string(name='Role', description='The role of the on-premises node in the cluster. Valid values:

*   Manager: management node
*   Login: logon node
*   Compute: compute node', example='Compute'),
      schedulerType?: string(name='SchedulerType', description='The scheduler type of the on-premises node in the cluster. Valid values:

*   pbs
*   slurm
*   opengridscheduler
*   deadline

Default value: pbs', example='pbs'),
    }
  ](name='Nodes'),
  onPremiseVolumeLocalPath?: string(name='OnPremiseVolumeLocalPath', description='The path in which the on-premises file system is mounted on the nodes on the cloud.', example='/OnCloudDirectory'),
  onPremiseVolumeMountPoint?: string(name='OnPremiseVolumeMountPoint', description='The mount target of the on-premises file system.', example='RemoteNasDomain.com'),
  onPremiseVolumeProtocol?: string(name='OnPremiseVolumeProtocol', description='The type of the protocol that is used by the on-premises file system. Only NFS is supported.', example='NFS'),
  onPremiseVolumeRemotePath?: string(name='OnPremiseVolumeRemotePath', description='The mount path of the on-premises file system.', example='/RemoteDirectory'),
  openldapPar?: {
    baseDn?: string(name='BaseDn', example='ehpctest'),
    ldapServerIp?: string(name='LdapServerIp', example='192.168.1.2'),
  }(name='OpenldapPar'),
  osTag?: string(name='OsTag', description='The image tag of the operating system. You can call the [ListImages](~~87213~~) operation to query the image tag.', example='CentOS_7.2_64'),
  password?: string(name='Password', description='The root password of the logon node. The password must be 8 to 30 characters in length and contain at least three of the following items: uppercase letters, lowercase letters, digits, and special characters. The password can contain the following special characters:

`() ~ ! @ # $ % ^ & * - = + | { } [ ] : ;  < > , . ? /`

>  We recommend that you use HTTPS to call the API operation to prevent password leakage.', example='123****'),
  plugin?: string(name='Plugin', example='{"pluginMod": "oss","pluginLocalPath": "/opt/plugin","pluginOssPath": "https://bucket.oss-cn-hangzhou.aliyuncs.com/plugin/plugin.tgz"}'),
  postInstallScript?: [ 
    {
      args?: string(name='Args', description='The parameters that are used to run the post-installation script. Valid values of N: 1 to 16.', example='bash file.sh'),
      url?: string(name='Url', description='The full path of the post-installation script. Valid values of N: 1 to 16.', example='/opt/job.sh'),
    }
  ](name='PostInstallScript'),
  remoteDirectory?: string(name='RemoteDirectory', description='The remote directory to which the file system is mounted.', example='/RemoteDirectory'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-acfmxazb4ph****'),
  schedulerPreInstall?: boolean(name='SchedulerPreInstall', description='Specifies whether the scheduler is preinstalled for the image. Valid values:

*   true: The scheduler is preinstalled. When you create or add a node, you do not need to install the scheduler.
*   false: The scheduler is not preinstalled. When you create or add a cluster, you must install the scheduler.', example='true'),
  securityGroupId?: string(name='SecurityGroupId', description='You can select an existing security group.

>  If you specify this parameter, you cannot specify the `SecurityGroupName` parameter at the same time.', example='sg-bp13n61xsydodfyg****'),
  securityGroupName?: string(name='SecurityGroupName', description='If you do not use an existing security group, set the parameter to the name of a new security group. A default policy is applied to the new security group.

>  If you specify this parameter, you cannot specify the `SecurityGroupId` parameter at the same time.', example='ehpc-SecurityGroup'),
  vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch.', example='vsw-bp1lfcjbfb099rrjn****'),
  volumeId?: string(name='VolumeId', description='The ID of the file system. NAS file systems cannot be automatically created.', example='008b64****'),
  volumeMountpoint?: string(name='VolumeMountpoint', description='The mount target of the file system. Mount targets cannot be automatically created for NAS file systems.', example='008b648bcb-s****.cn-hangzhou.nas.aliyuncs.com'),
  volumeProtocol?: string(name='VolumeProtocol', description='The type of the protocol that is used by the file system. Only NFS is supported.', example='NFS'),
  volumeType?: string(name='VolumeType', description='The type of the file system. Only NAS file systems are supported.', example='NAS'),
  vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC) to which the cluster belongs.', example='vpc-b3f3edefefeep0760yju****'),
  winAdPar?: {
    adDc?: string(name='AdDc', example='ad-hybrid001.ehpcad.com'),
    adIp?: string(name='AdIp', example='192.168.1.2'),
    adUser?: string(name='AdUser', example='Administrator'),
    adUserPasswd?: string(name='AdUserPasswd', example='xxxxxx'),
  }(name='WinAdPar'),
  zoneId?: string(name='ZoneId', description='The ID of the zone.', example='cn-hangzhou-b'),
}

model CreateHybridClusterResponseBody = {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-FYUr32****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='F6757FA4-8FED-4602-B7F5-3550C0842122'),
  taskId?: string(name='TaskId', description='The ID of the task.', example='F6757FA4-8FED-4602-B7F5-3550C0842122'),
}

model CreateHybridClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateHybridClusterResponseBody(name='body'),
}

async function createHybridClusterWithOptions(request: CreateHybridClusterRequest, runtime: Util.RuntimeOptions): CreateHybridClusterResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateHybridCluster',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createHybridCluster(request: CreateHybridClusterRequest): CreateHybridClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return createHybridClusterWithOptions(request, runtime);
}

model CreateJobFileRequest {
  async?: boolean(name='Async', example='false'),
  clusterId?: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-jeJki6****'),
  content?: string(name='Content', description='The content of the job file. The content is encoded in Base64.', example='c2xlZXAgMzA='),
  runasUser?: string(name='RunasUser', description='The user to which the job belongs.

You can call the [ListUsers](~~188572~~) operation to query the users of the cluster.', example='testuser1'),
  runasUserPassword?: string(name='RunasUserPassword', description='The password of the user.', example='!QAZ****'),
  targetFile?: string(name='TargetFile', description='The name of the job file.', example='lammps.pbs'),
}

model CreateJobFileResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model CreateJobFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateJobFileResponseBody(name='body'),
}

async function createJobFileWithOptions(request: CreateJobFileRequest, runtime: Util.RuntimeOptions): CreateJobFileResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateJobFile',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createJobFile(request: CreateJobFileRequest): CreateJobFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return createJobFileWithOptions(request, runtime);
}

model CreateJobTemplateRequest {
  arrayRequest?: string(name='ArrayRequest', description='The job array.

Format: X-Y:Z. X is the minimum index value. Y is the maximum index value. Z is the step size. For example, 2-7:2 indicates that three jobs need to be run and their index values are 2, 4, and 6.', example='1-10:2'),
  clockTime?: string(name='ClockTime', description='The maximum running time of the job. Valid formats:

*   hh:mm:ss
*   mm:ss
*   ss

We recommend that you use the hh:mm:ss format. If the maximum running time is 12 hours, set the value to 12:00:00.', example='12:00:00'),
  commandLine?: string(name='CommandLine', description='The command that is used to run the job.', example='./LammpsTest/lammps.pbs'),
  gpu?: int32(name='Gpu', description='The maximum GPU usage required by a single compute node. Valid values: 1 to 8.

The parameter takes effect only when the cluster uses PBS and a compute node is a GPU-accelerated instance.', example='1'),
  inputFileUrl?: string(name='InputFileUrl', description='The URL of the job files that are uploaded to an Object Storage Service (OSS) bucket.', example='https://test.oss-cn-beijing.aliyuncs.com/test.py'),
  mem?: string(name='Mem', description='The maximum memory usage required by a single compute node. Unit: GB, MB, or KB. The unit is case-insensitive.', example='1GB'),
  name?: string(name='Name', description='The name of the job template. The name must be 2 to 64 characters in length. It must start with a letter and can contain letters, digits, hyphens (-), and underscores (\\_).', example='jobtemplate1'),
  node?: int32(name='Node', description='The number of compute nodes. Valid values: 1 to 500.

>  If the parameter is not specified, the Task, Thread, Mem, and Gpu parameters become invalid.', example='2'),
  packagePath?: string(name='PackagePath', description='The path that is used to run the job.', example='./jobfolder'),
  priority?: int32(name='Priority', description='The priority of the job. Valid values: 0 to 9. A large value indicates a high priority.

Default value: 0', example='0'),
  queue?: string(name='Queue', description='The name of the queue in which the job is run.

You can call the [ListQueues](~~92176~~) operation to query the queue name.', example='workq'),
  reRunable?: boolean(name='ReRunable', description='Specifies whether the job can be rerun. Valid values:

*   true: The job can be rerun.
*   false: The job cannot be rerun.', example='false'),
  runasUser?: string(name='RunasUser', description='The name of the user that runs the job.

You can call the [ListUsers](~~188572~~) operation to query the users of the cluster.', example='user1'),
  stderrRedirectPath?: string(name='StderrRedirectPath', description='The output file path of stderr.', example='./LammpsTest'),
  stdoutRedirectPath?: string(name='StdoutRedirectPath', description='The output file path of stdout.', example='./LammpsTest'),
  task?: int32(name='Task', description='The number of tasks required by a single compute node. Valid values: 1 to 1000.', example='2'),
  thread?: int32(name='Thread', description='The number of threads required by a single compute node. Valid values: 1 to 1000.', example='1'),
  unzipCmd?: string(name='UnzipCmd', description='The command that is used to decompress the job files downloaded from an OSS bucket. The parameter takes effect only when WithUnzipCmd is set to true. Valid values:

*   tar xzf: decompresses GZIP files.
*   tar xf: decompresses TAR files.
*   unzip: decompresses ZIP files.', example='tar xzf'),
  variables?: string(name='Variables', description='The runtime variables passed to the job. They can be accessed by using environment variables in the executable file.', example='[{Name:,Value:},{Name:,Value:}]'),
  withUnzipCmd?: boolean(name='WithUnzipCmd', description='Specifies whether to decompress the job files downloaded from an OSS bucket. Valid values:

*   true: The job files are decompressed.
*   false: The job files are not decompressed.', example='true'),
}

model CreateJobTemplateResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  templateId?: string(name='TemplateId', description='The ID of the job template.', example='ehpc-job-tmpl-6RxO5y****'),
}

model CreateJobTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateJobTemplateResponseBody(name='body'),
}

async function createJobTemplateWithOptions(request: CreateJobTemplateRequest, runtime: Util.RuntimeOptions): CreateJobTemplateResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateJobTemplate',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createJobTemplate(request: CreateJobTemplateRequest): CreateJobTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return createJobTemplateWithOptions(request, runtime);
}

model DeleteClusterRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-QKKVqO****'),
  releaseInstance?: string(name='ReleaseInstance', description='Specifies whether to release Elastic Compute Service (ECS) instances that are created by using Elastic High Performance Computing (E-HPC).

Default value: true', example='true'),
}

model DeleteClusterResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F1AB6D8D-E185-4D94-859C-7CE7B8B7****'),
  taskId?: string(name='TaskId', description='The ID of the task.', example='F1AB6D8D-E185-4D94-859C-7CE7B8B7****'),
}

model DeleteClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteClusterResponseBody(name='body'),
}

/**
  * After a cluster is released, the pay-as-you-go nodes and the subscription nodes that have expired are automatically released. The subscription nodes that have not expired are retained. If you need to release the subscription nodes that have not expired, change their billing method to pay-as-you-go. Before you release a cluster, make sure that you will no longer use the cluster.
  *
  * @param request DeleteClusterRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteClusterResponse
 */
async function deleteClusterWithOptions(request: DeleteClusterRequest, runtime: Util.RuntimeOptions): DeleteClusterResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCluster',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * After a cluster is released, the pay-as-you-go nodes and the subscription nodes that have expired are automatically released. The subscription nodes that have not expired are retained. If you need to release the subscription nodes that have not expired, change their billing method to pay-as-you-go. Before you release a cluster, make sure that you will no longer use the cluster.
  *
  * @param request DeleteClusterRequest
  * @return DeleteClusterResponse
 */
async function deleteCluster(request: DeleteClusterRequest): DeleteClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteClusterWithOptions(request, runtime);
}

model DeleteContainerAppsRequest {
  containerApp?: [ 
    {
      id?: string(name='Id', description='The ID of the containerized application that you want to delete. Valid values of N: 1 to 100.

You can call the [ListContainerApps](~~87333~~) operation to query the ID of the containerized application.', example='ehpc-container-ABDUGSkjs****'),
    }
  ](name='ContainerApp'),
}

model DeleteContainerAppsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model DeleteContainerAppsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteContainerAppsResponseBody(name='body'),
}

async function deleteContainerAppsWithOptions(request: DeleteContainerAppsRequest, runtime: Util.RuntimeOptions): DeleteContainerAppsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteContainerApps',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteContainerApps(request: DeleteContainerAppsRequest): DeleteContainerAppsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteContainerAppsWithOptions(request, runtime);
}

model DeleteGWSClusterRequest {
  clusterId?: string(name='ClusterId', description='The ID of the visualization service.', example='gws-rhz99q8rc****'),
}

model DeleteGWSClusterResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='8442AF35-875B-4FC0-8B7AAFDC339335D5'),
}

model DeleteGWSClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteGWSClusterResponseBody(name='body'),
}

async function deleteGWSClusterWithOptions(request: DeleteGWSClusterRequest, runtime: Util.RuntimeOptions): DeleteGWSClusterResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGWSCluster',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteGWSCluster(request: DeleteGWSClusterRequest): DeleteGWSClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGWSClusterWithOptions(request, runtime);
}

model DeleteGWSInstanceRequest {
  instanceId?: string(name='InstanceId', description='The ID of the visualization instance.', example='i-bp66guhybgtrftpa1****'),
}

model DeleteGWSInstanceResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='2777461A-E45E-42F8-8E67-0EBF132E93E0'),
}

model DeleteGWSInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteGWSInstanceResponseBody(name='body'),
}

async function deleteGWSInstanceWithOptions(request: DeleteGWSInstanceRequest, runtime: Util.RuntimeOptions): DeleteGWSInstanceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGWSInstance',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteGWSInstance(request: DeleteGWSInstanceRequest): DeleteGWSInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGWSInstanceWithOptions(request, runtime);
}

model DeleteImageRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****'),
  containerType?: string(name='ContainerType', description='The type of the container. Set the value to singularity.', example='singularity'),
  imageTag?: string(name='ImageTag', description='The tags of the image.

Default value: latest', example='latest'),
  repository?: string(name='Repository', description='The name of the repository.

You can call the [ListContainerImages](~~87348~~) operation to query the name of the repository.', example='repo1'),
}

model DeleteImageResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model DeleteImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteImageResponseBody(name='body'),
}

async function deleteImageWithOptions(request: DeleteImageRequest, runtime: Util.RuntimeOptions): DeleteImageResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteImage',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteImage(request: DeleteImageRequest): DeleteImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteImageWithOptions(request, runtime);
}

model DeleteJobTemplatesRequest {
  templates?: string(name='Templates', description='The list of job templates. A maximum of 20 job templates can be deleted.

Format: `[{"Id": "0.sched****"},{"Id": "1.sched****"}]`. Separate multiple job templates with commas (,).

You can call the [ListJobTemplates](~~87248~~) operation to obtain the job template ID.', example='[{"Id":"ehpc-job-tmpl-6RVcMK****"},{"Id": "ehpc-job-tmpl-6RxO5y****"}]'),
}

model DeleteJobTemplatesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model DeleteJobTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteJobTemplatesResponseBody(name='body'),
}

async function deleteJobTemplatesWithOptions(request: DeleteJobTemplatesRequest, runtime: Util.RuntimeOptions): DeleteJobTemplatesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteJobTemplates',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteJobTemplates(request: DeleteJobTemplatesRequest): DeleteJobTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteJobTemplatesWithOptions(request, runtime);
}

model DeleteJobsRequest {
  async?: boolean(name='Async', description='Specifies whether to use an asynchronous link to delete the jobs.

Default value: false', example='false'),
  clusterId?: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****'),
  jobs?: string(name='Jobs', description='The list of jobs that you want to delete. Maximum number of jobs: 100. Minimum number of jobs: 1.

Format: `[{"Id": "0.sched****"},{"Id": "1.sched****"}]`. Separate multiple jobs with commas (,).

You can call the [ListJobs](~~87251~~) operation to query the job ID.', example='[{"Id": "0.sched****"},{"Id": "1.sched****"}]'),
}

model DeleteJobsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model DeleteJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteJobsResponseBody(name='body'),
}

async function deleteJobsWithOptions(request: DeleteJobsRequest, runtime: Util.RuntimeOptions): DeleteJobsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteJobs',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteJobs(request: DeleteJobsRequest): DeleteJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteJobsWithOptions(request, runtime);
}

model DeleteLocalImageRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster from which that you want to delete the image.', example='ehpc-hz-ibug69****'),
  containerType?: string(name='ContainerType', description='The type of the image. Set the value to singularity.', example='singularity'),
  imageName?: string(name='ImageName', description='The name of the image that you want to delete.', example='test.sif'),
}

model DeleteLocalImageResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='896D338C-E4F4-41EC-A154-D605E5DE****'),
}

model DeleteLocalImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteLocalImageResponseBody(name='body'),
}

async function deleteLocalImageWithOptions(request: DeleteLocalImageRequest, runtime: Util.RuntimeOptions): DeleteLocalImageResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteLocalImage',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteLocalImage(request: DeleteLocalImageRequest): DeleteLocalImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteLocalImageWithOptions(request, runtime);
}

model DeleteNodesRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****'),
  instance?: [ 
    {
      id?: string(name='Id', description='The ID of the compute node that you want to delete. Valid values of N: 1 to 100.

You can call the [DescribeCluster](~~87126~~) operation to query the IDs of the nodes in the cluster.', example='i-bp13p7vlcb1uihfv****'),
    }
  ](name='Instance'),
  releaseInstance?: boolean(name='ReleaseInstance', description='Specifies whether to release the instances that are created by using E-HPC.

Default value: true', example='true'),
  sync?: boolean(name='Sync', description='Specifies whether to directly delete the node. Valid values:

*   true
*   false', example='false'),
}

model DeleteNodesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  taskId?: string(name='TaskId', description='The ID of the task.

*   If you set the Sync parameter to true, the DeleteNodes operation is synchronous. Valid value: Not Available.
*   If you set the Sync parameter to false, the DeleteNodes operation is asynchronous. You can call the [ListTasks](~~268225~~) operation to query the result of the task.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model DeleteNodesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteNodesResponseBody(name='body'),
}

/**
  * Before you delete a compute node, we recommend that you export all job data from the node to prevent data loss.
  *
  * @param request DeleteNodesRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteNodesResponse
 */
async function deleteNodesWithOptions(request: DeleteNodesRequest, runtime: Util.RuntimeOptions): DeleteNodesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteNodes',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Before you delete a compute node, we recommend that you export all job data from the node to prevent data loss.
  *
  * @param request DeleteNodesRequest
  * @return DeleteNodesResponse
 */
async function deleteNodes(request: DeleteNodesRequest): DeleteNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteNodesWithOptions(request, runtime);
}

model DeleteQueueRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****'),
  queueName?: string(name='QueueName', description='The name of the queue that you want to delete.

You can call the [ListQueues](~~92176~~) operation to query the name of the queue.', example='workq'),
}

model DeleteQueueResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='464E9919-D04F-4D1D-B375-15989492****'),
}

model DeleteQueueResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteQueueResponseBody(name='body'),
}

async function deleteQueueWithOptions(request: DeleteQueueRequest, runtime: Util.RuntimeOptions): DeleteQueueResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteQueue',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteQueue(request: DeleteQueueRequest): DeleteQueueResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteQueueWithOptions(request, runtime);
}

model DeleteSecurityGroupRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-FYUr32****'),
  securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group.', example='sg-bp13n61xsydodfyg****'),
}

model DeleteSecurityGroupResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model DeleteSecurityGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSecurityGroupResponseBody(name='body'),
}

async function deleteSecurityGroupWithOptions(request: DeleteSecurityGroupRequest, runtime: Util.RuntimeOptions): DeleteSecurityGroupResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSecurityGroup',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSecurityGroup(request: DeleteSecurityGroupRequest): DeleteSecurityGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSecurityGroupWithOptions(request, runtime);
}

model DeleteUsersRequest {
  async?: boolean(name='Async'),
  clusterId?: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****'),
  user?: [ 
    {
      name?: string(name='Name', description='The name of the user that you want to delete. Valid values of N: 1 to 100.

You can call the [ListUsers](~~188572~~) operation to query the users of the cluster.', example='user1'),
    }
  ](name='User'),
}

model DeleteUsersResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE****'),
}

model DeleteUsersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteUsersResponseBody(name='body'),
}

/**
  * If you delete a user, only its information is deleted. The files stored in the /home directory for the user are still retained. For example, if you delete a user named user1, the files in the `/home/user1/` directory of the cluster are not deleted. However, a deleted user cannot be recovered. Even if you create another user that has the same name, the data that was retained for the deleted user is not reused.
  *
  * @param request DeleteUsersRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteUsersResponse
 */
async function deleteUsersWithOptions(request: DeleteUsersRequest, runtime: Util.RuntimeOptions): DeleteUsersResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteUsers',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * If you delete a user, only its information is deleted. The files stored in the /home directory for the user are still retained. For example, if you delete a user named user1, the files in the `/home/user1/` directory of the cluster are not deleted. However, a deleted user cannot be recovered. Even if you create another user that has the same name, the data that was retained for the deleted user is not reused.
  *
  * @param request DeleteUsersRequest
  * @return DeleteUsersResponse
 */
async function deleteUsers(request: DeleteUsersRequest): DeleteUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteUsersWithOptions(request, runtime);
}

model DescribeAutoScaleConfigRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-FYUr32****'),
}

model DescribeAutoScaleConfigResponseBody = {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-FYUr32****'),
  clusterType?: string(name='ClusterType', description='The type of the scheduler. Valid values:

*   pbs
*   slurm
*   opengridscheduler
*   deadline', example='slurm'),
  enableAutoGrow?: boolean(name='EnableAutoGrow', description='Indicates whether auto scale-out is enabled.', example='true'),
  enableAutoShrink?: boolean(name='EnableAutoShrink', description='Indicates whether auto scale-in is enabled.', example='true'),
  excludeNodes?: string(name='ExcludeNodes', description='The list of nodes on which auto scaling is not enabled.', example='i-bp19lgqwxb4206t5****,i-bp1g4hvzs9pywrhb****'),
  extraNodesGrowRatio?: int32(name='ExtraNodesGrowRatio', description='The ratio of added nodes to the original ones. Valid values: 0 to 100.', example='0'),
  growIntervalInMinutes?: int32(name='GrowIntervalInMinutes', description='The scale-out interval. The interval at which the compute nodes were scaled out. Valid values: 2 to 10.', example='10'),
  growRatio?: int32(name='GrowRatio', description='The percentage of the added nodes. Valid values: 1 to 100.', example='1'),
  growTimeoutInMinutes?: int32(name='GrowTimeoutInMinutes', description='The timeout period before the node was started. Valid values: 10 to 60.', example='20'),
  maxNodesInCluster?: int32(name='MaxNodesInCluster', description='The maximum number of compute nodes in the cluster. This parameter indicates the largest number of nodes that can be added to the cluster.', example='100'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73'),
  shrinkIdleTimes?: int32(name='ShrinkIdleTimes', description='The number of consecutive idle times of a node during a scale-in check. Valid values: 2 to 5.', example='3'),
  shrinkIntervalInMinutes?: int32(name='ShrinkIntervalInMinutes', description='The scale-in interval. The interval at which the compute nodes were scaled in. Valid values: 2 to 10.', example='2'),
  spotPriceLimit?: string(name='SpotPriceLimit', description='The maximum hourly rate of the instance. The value is accurate to three decimal places. It takes effect only when SpotStrategy is set to SpotWithPriceLimit.', example='0.062'),
  spotStrategy?: string(name='SpotStrategy', description='The bidding policy for the compute nodes. Valid values:

*   NoSpot: The instance is created as a regular pay-as-you-go instance.
*   SpotWithPriceLimit: The instance is a preemptible one with a user-defined maximum hourly rate.
*   SpotAsPriceGo: The instance is created as a pay-as-you-go instance that is automatically priced based on the Alibaba Cloud Marketplace.', example='NoSpot'),
  uid?: string(name='Uid', description='The ID of the user.', example='testu****'),
}

model DescribeAutoScaleConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAutoScaleConfigResponseBody(name='body'),
}

async function describeAutoScaleConfigWithOptions(request: DescribeAutoScaleConfigRequest, runtime: Util.RuntimeOptions): DescribeAutoScaleConfigResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAutoScaleConfig',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAutoScaleConfig(request: DescribeAutoScaleConfigRequest): DescribeAutoScaleConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAutoScaleConfigWithOptions(request, runtime);
}

model DescribeClusterRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster. You can call the [ListClusters](~~87116~~) operation to query the list of clusters in a region.', example='ehpc-hz-QKKVqO****'),
}

model DescribeClusterResponseBody = {
  clusterInfo?: {
    accountType?: string(name='AccountType', description='The service type of the domain account. Valid values:

*   nis
*   ldap', example='nis'),
    applications?: {
      applicationInfo?: [ 
      {
        name?: string(name='Name', description='The name of the software.', example='openmpi'),
        tag?: string(name='Tag', description='The tag of the software.', example='OpenMPI_1.8.7'),
        version?: string(name='Version', description='The version of the software.', example='1.10'),
      }
    ](name='ApplicationInfo')
    }(name='Applications', description='The array of the software in the cluster. The array contains the name and version of the software.'),
    baseOsTag?: string(name='BaseOsTag', description='The image of the cluster.', example='CentOS_7.2_64'),
    clientVersion?: string(name='ClientVersion', description='The version of the E-HPC client.', example='1.0.1'),
    createTime?: string(name='CreateTime', description='The time when the cluster was created.', example='2020-12-24T03:18:23.000Z'),
    deployMode?: string(name='DeployMode', description='The mode in which the cluster is deployed. Valid values:

*   Standard: An account node, a scheduling node, a logon node, and multiple compute nodes are separately deployed.
*   Advanced: Two high availability (HA) account nodes, two HA scheduler nodes, one logon node, and multiple compute nodes are separately deployed.
*   Simple: A management node, a logon node, and multiple compute nodes are deployed. The management node consists of an account node and a scheduling node. The logon node and compute nodes are separately deployed.
*   Tiny: A management node and multiple compute nodes are deployed. The management node consists of an account node, a scheduling node, and a logon node. The compute nodes are separately deployed.', example='Simple'),
    description?: string(name='Description', description='The description of the cluster.', example='cluster'),
    ecsChargeType?: string(name='EcsChargeType', description='The billing method of the nodes in the cluster. Valid values:

*   PostPaid: pay-as-you-go
*   PrePaid: subscription', example='PostPaid'),
    ecsInfo?: {
      compute?: {
        count?: int32(name='Count', description='The number of compute nodes.', example='1'),
        instanceType?: string(name='InstanceType', description='The instance type of the compute nodes.', example='ecs.n1.tiny'),
      }(name='Compute', description='The list of compute nodes.'),
      login?: {
        count?: int32(name='Count', description='The number of logon nodes.', example='1'),
        instanceType?: string(name='InstanceType', description='The instance type of the logon nodes.', example='ecs.n1.tiny'),
      }(name='Login', description='The list of logon nodes.'),
      manager?: {
        count?: int32(name='Count', description='The number of management nodes.', example='1'),
        instanceType?: string(name='InstanceType', description='The instance type of the management nodes.', example='ecs.n1.tiny'),
      }(name='Manager', description='The list of management nodes.'),
      proxyMgr?: {
        count?: int32(name='Count', description='The number of proxy nodes.', example='1'),
        instanceType?: string(name='InstanceType', description='The instance type of the proxy node.', example='ecs.n1.tiny'),
      }(name='ProxyMgr', description='The list of proxy nodes on the cloud. 

This parameter is returned only when the cluster is deployed across hybrid environments and the hybrid-cloud proxy mode is enabled for the cluster.'),
    }(name='EcsInfo', description='The list of ECS instance specifications and quantity.'),
    haEnable?: boolean(name='HaEnable', description='Indicates whether the high availability feature is enabled.

>  If high availability is enabled, a primary management node and a secondary management node are used.', example='false'),
    id?: string(name='Id', description='The ID of the Elastic Compute Service (ECS) instance.', example='i-bp15de54eet1c43f****'),
    imageId?: string(name='ImageId', description='The ID of the image.', example='centos_7_02_64_20G_alibase_20170818****'),
    imageName?: string(name='ImageName', description='The name of the image.', example='test_for_Image'),
    imageOwnerAlias?: string(name='ImageOwnerAlias', description='The type of the image. Valid values:

*   system: public image
*   self: custom image
*   others: shared image
*   marketplace: Alibaba Cloud Marketplace image', example='system'),
    keyPairName?: string(name='KeyPairName', description='The name of the AccessKey pair.', example='test'),
    location?: string(name='Location', description='The location where the cluster is deployed. Valid values:

*   OnPremise: The cluster is deployed on a hybrid cloud.
*   PublicCloud: The node is deployed on a public cloud.', example='PublicCloud'),
    name?: string(name='Name', description='The name of the cluster.', example='cluster'),
    onPremiseInfo?: {
      onPremiseInfo?: [ 
      {
        hostName?: string(name='HostName', description='The hostname of the on-premises management nodes.', example='testecs'),
        IP?: string(name='IP', description='The IP address of the on-premises management nodes.', example='192.168.*.*'),
        type?: string(name='Type', description='The type of on-premises management nodes. Valid values:

- scheduler
- account
- account, scheduler', example='scheduler'),
      }
    ](name='OnPremiseInfo')
    }(name='OnPremiseInfo', description='The list of on-premises management nodes. 

This parameter is returned only when the cluster is deployed across hybrid environments and the hybrid-cloud proxy mode is enabled for the cluster.'),
    osTag?: string(name='OsTag', description='The image tag of the operating system.', example='CentOS_7.2_64'),
    postInstallScripts?: {
      postInstallScriptInfo?: [ 
      {
        args?: string(name='Args', description='The runtime parameter of the script.', example='bash file.sh'),
        url?: string(name='Url', description='The URL that was used to download the script.', example='example.com'),
      }
    ](name='PostInstallScriptInfo')
    }(name='PostInstallScripts', description='The list of scripts downloaded after the cluster was created.'),
    ramNodeTypes?: string(name='RamNodeTypes'),
    ramRoleName?: string(name='RamRoleName'),
    regionId?: string(name='RegionId', description='The region ID of the security group.', example='cn-hangzhou'),
    remoteDirectory?: string(name='RemoteDirectory', description='The remote directory on which the file system is mounted.', example='NasMountpoint:/RemoteDirectory'),
    sccClusterId?: string(name='SccClusterId', description='The ID of the Super Computing Cluster (SCC) instance. If the cluster is not an SCC instance, a null string is returned.', example='00b648b****'),
    schedulerType?: string(name='SchedulerType', description='The type of the scheduler. Valid values:

*   pbs
*   slurm
*   opengridscheduler
*   deadline', example='pbs'),
    securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group.', example='sg-bp1asugr34gzn****'),
    status?: string(name='Status', description='The status of the cluster. Valid values:

*   uninit: The cluster is not initialized.
*   creating: The cluster is being created.
*   init: The cluster is being initialized.
*   running: The cluster is running.
*   exception: The cluster encounters an exception.
*   releasing: The cluster is being released.', example='creating'),
    vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch. E-HPC can be deployed only in VPCs.', example='vsw-bp1e47optm9g58zcu****'),
    volumeId?: string(name='VolumeId', description='The ID of the Apsara File Storage NAS file system. NAS file systems cannot be automatically created.', example='008b64****'),
    volumeMountpoint?: string(name='VolumeMountpoint', description='The mount target of the file system. Mount targets cannot be automatically created for NAS file systems.', example='008b648bcb-s****.cn-hangzhou.nas.aliyuncs.com'),
    volumeProtocol?: string(name='VolumeProtocol', description='The type of the protocol that is used by the file system. Valid values:

*   nfs
*   smb', example='nfs'),
    volumeType?: string(name='VolumeType', description='The type of the network shared storage. Valid value: NAS.', example='NAS'),
    vpcId?: string(name='VpcId', description='The ID of the VPC.', example='vpc-bp1pxkcvmmz53ki89****'),
  }(name='ClusterInfo', description='The information about the cluster.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model DescribeClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeClusterResponseBody(name='body'),
}

async function describeClusterWithOptions(request: DescribeClusterRequest, runtime: Util.RuntimeOptions): DescribeClusterResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCluster',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCluster(request: DescribeClusterRequest): DescribeClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterWithOptions(request, runtime);
}

model DescribeContainerAppRequest {
  containerId?: string(name='ContainerId', description='The ID of the containerized application.

You can call the [ListContainerApps](~~87333~~) operation to query the ID of the containerized application.', example='ehpc-container-ABDUGSkjs****'),
}

model DescribeContainerAppResponseBody = {
  containerAppInfo?: {
    createTime?: string(name='CreateTime', description='The time when the containerized application was created.', example='2018-07-18T17:46:47'),
    description?: string(name='Description', description='The description of the containerized application.', example='ExampleDescription'),
    id?: string(name='Id', description='The ID of the containerized application.', example='ehpc-container-ABDUGSkjs****'),
    imageTag?: string(name='ImageTag', description='The tags of the image.', example='latest'),
    name?: string(name='Name', description='The name of the containerized application.', example='ExampleName'),
    repository?: string(name='Repository', description='The name of the repository.', example='busybox'),
    type?: string(name='Type', description='The type of the container. Set the value to singularity.', example='singularity'),
  }(name='ContainerAppInfo', description='The information of the containerized application.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model DescribeContainerAppResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeContainerAppResponseBody(name='body'),
}

async function describeContainerAppWithOptions(request: DescribeContainerAppRequest, runtime: Util.RuntimeOptions): DescribeContainerAppResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeContainerApp',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeContainerApp(request: DescribeContainerAppRequest): DescribeContainerAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeContainerAppWithOptions(request, runtime);
}

model DescribeEstackImageRequest {
  pageNumber?: int32(name='PageNumber', description='The number of the page to return.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.', example='10'),
}

model DescribeEstackImageResponseBody = {
  imageList?: {
    imageListInfo?: [ 
    {
      imageName?: string(name='ImageName', description='The name of the image.', example='tensorflow-21.09-tf1-py3.sif'),
      imageSize?: int32(name='ImageSize', description='The size of the image.', example='65535'),
      imageType?: string(name='ImageType', description='The type of the image.', example='singularity'),
      imageUrl?: string(name='ImageUrl', description='The download URL of the image.', example='http://xxxx.oss-cn-hangzhou.aliyuncs.com/eStackPackage/singularity/tensorflow-21.09-tf1-py3.sif'),
      recentUpdateTime?: string(name='RecentUpdateTime', description='The time when the image was last modified.', example='2022-05-05T07:10:55.000Z'),
    }
  ](name='ImageListInfo')
  }(name='ImageList', description='The array of base images.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='2D69A58F-345C-4FDE-88E4-BF518948xxxx'),
  totalCount?: int32(name='TotalCount', description='The total number of images.', example='100'),
}

model DescribeEstackImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeEstackImageResponseBody(name='body'),
}

async function describeEstackImageWithOptions(request: DescribeEstackImageRequest, runtime: Util.RuntimeOptions): DescribeEstackImageResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeEstackImage',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeEstackImage(request: DescribeEstackImageRequest): DescribeEstackImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEstackImageWithOptions(request, runtime);
}

model DescribeGWSClusterPolicyRequest {
  asyncMode?: boolean(name='AsyncMode', example='true'),
  clusterId?: string(name='ClusterId', example='gws-rhz99q8rc****'),
  taskId?: string(name='TaskId', example='t-****'),
}

model DescribeGWSClusterPolicyResponseBody = {
  clipboard?: string(name='Clipboard', example='read'),
  localDrive?: string(name='LocalDrive', example='off'),
  requestId?: string(name='RequestId', example='7afc5a17-e60d-4a2a-85d6-7c9d4a81d65e'),
  usbRedirect?: string(name='UsbRedirect', example='on'),
  watermark?: string(name='Watermark', example='on'),
}

model DescribeGWSClusterPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGWSClusterPolicyResponseBody(name='body'),
}

async function describeGWSClusterPolicyWithOptions(request: DescribeGWSClusterPolicyRequest, runtime: Util.RuntimeOptions): DescribeGWSClusterPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.asyncMode)) {
    query['AsyncMode'] = request.asyncMode;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGWSClusterPolicy',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGWSClusterPolicy(request: DescribeGWSClusterPolicyRequest): DescribeGWSClusterPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGWSClusterPolicyWithOptions(request, runtime);
}

model DescribeGWSClustersRequest {
  clusterId?: string(name='ClusterId', description='The IDs of the visualization services.', example='gws-rhz99q8rc****'),
  pageNumber?: int32(name='PageNumber', description='The page number of the page to return.

Pages start from page 1.

Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 50.

Default value: 10.', example='10'),
}

model DescribeGWSClustersResponseBody = {
  callerType?: string(name='CallerType', description='The type of the account. Valid values:

*   sub: a RAM user.
*   parent: an Alibaba Cloud account.', example='sub'),
  clusters?: {
    clusterInfo?: [ 
    {
      clusterId?: string(name='ClusterId', description='The ID of the visualization service.', example='gws-rhz99q8rc****'),
      createTime?: string(name='CreateTime', description='The time when the visualization service was created.', example='2019-05-15T06:05:40.000Z'),
      instanceCount?: int32(name='InstanceCount', description='The number of visualization instances.', example='3'),
      status?: string(name='Status', description='The status of the visualization services. Valid values:

*   creating: The service is being created.
*   starting: The service is being started.
*   running: The service is running.
*   deleted: The service is deleted.', example='running'),
      vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC).', example='vpc-bp1nq8oshqudln3hy****'),
    }
  ](name='ClusterInfo')
  }(name='Clusters', description='The information of the visualization services.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned on the current page.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='2777461A-E45E-42F8-8E67-0EBF132E93E0'),
  totalCount?: int32(name='TotalCount', description='The total number of returned entries.', example='1'),
}

model DescribeGWSClustersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGWSClustersResponseBody(name='body'),
}

async function describeGWSClustersWithOptions(request: DescribeGWSClustersRequest, runtime: Util.RuntimeOptions): DescribeGWSClustersResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGWSClusters',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGWSClusters(request: DescribeGWSClustersRequest): DescribeGWSClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGWSClustersWithOptions(request, runtime);
}

model DescribeGWSImagesRequest {
  pageNumber?: int32(name='PageNumber', example='1'),
  pageSize?: int32(name='PageSize', example='10'),
}

model DescribeGWSImagesResponseBody = {
  images?: {
    imageInfo?: [ 
    {
      createTime?: string(name='CreateTime', example='2019-05-15T06:05:40.000Z'),
      imageId?: string(name='ImageId', example='m-bp1by33e4h650m70lb****'),
      imageType?: string(name='ImageType', example='system'),
      name?: string(name='Name', example='Windows Server 2019'),
      progress?: string(name='Progress', example='100%'),
      size?: int32(name='Size', example='40'),
      status?: string(name='Status', example='Available'),
    }
  ](name='ImageInfo')
  }(name='Images'),
  pageNumber?: int32(name='PageNumber', example='1'),
  pageSize?: int32(name='PageSize', example='10'),
  requestId?: string(name='RequestId', example='2777461A-E45E-42F8-8E67-0EBF132E93E0'),
  totalCount?: int32(name='TotalCount', example='2'),
}

model DescribeGWSImagesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGWSImagesResponseBody(name='body'),
}

async function describeGWSImagesWithOptions(request: DescribeGWSImagesRequest, runtime: Util.RuntimeOptions): DescribeGWSImagesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGWSImages',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGWSImages(request: DescribeGWSImagesRequest): DescribeGWSImagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGWSImagesWithOptions(request, runtime);
}

model DescribeGWSInstancesRequest {
  clusterId?: string(name='ClusterId', description='The ID of the visualization service.', example='gws-rhz99q8rc****'),
  instanceId?: string(name='InstanceId', description='The ID of the visualization instance.', example='i-bp1bzqq1ddeemuddn****'),
  pageNumber?: int32(name='PageNumber', description='The page number of the page to return.

Pages start from page 1.

Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 50.

Default value: 10.', example='10'),
  userName?: string(name='UserName', description='The username of the entity whose instances you want to query.

>  If this parameter is not specified, instances of all users are queried.', example='testuser'),
  userUid?: long(name='UserUid', description='The user ID of the entity whose instances you want to query.

>  If this parameter is not specified, instances of all users are queried.', example='1234567890'),
}

model DescribeGWSInstancesResponseBody = {
  instances?: {
    instanceInfo?: [ 
    {
      appList?: {
        appInfo?: [ 
        {
          appArgs?: string(name='AppArgs', example='temp.txt'),
          appName?: string(name='AppName', description='The name of the application.', example='notepad'),
          appPath?: string(name='AppPath', description='The execution directory of the application.', example='/home/test/notepad.exe'),
        }
      ](name='AppInfo')
      }(name='AppList', description='The list of application information.

>  If the WorkMode parameter is set to Desktop, an empty value is returned in this parameter.'),
      clusterId?: string(name='ClusterId', description='The ID of the visualizatio service.', example='gws-rhz99q8rc****'),
      createTime?: string(name='CreateTime', description='The time when the visualization instance was created.', example='2020-02-03T14:03Z'),
      expireTime?: string(name='ExpireTime', description='The time when the visualization instance expires.', example='2099-12-31T15:59Z'),
      instanceId?: string(name='InstanceId', description='The ID of the visualization instance.', example='i-bp1bzqq1ddeemuddn****'),
      instanceType?: string(name='InstanceType', description='The type of the visualization instance.', example='ecs.g6.large'),
      name?: string(name='Name', description='The name of the visualization instance.', example='c0-i01-1-g6-2c8g'),
      status?: string(name='Status', description='The status of the visualization instance. Valid values:

*   Creating: The instance is being created.
*   Starting: The instance is being started.
*   Stopping: The instance is being stopped.
*   Stopped: The instance is stopped.
*   Initializing: The instance is being initialized.
*   Unregistered: The instance is not registered.
*   Registered: The instance is registered.
*   InUse: The instance is in use.
*   Missing: The instance cannot be found.
*   Cloning: An image is being generated based on the instance.', example='Creating'),
      userName?: string(name='UserName', description='The username of the entity to which the visualization instance is assigned.

>  If the instance is not assigned to a specified user, this parameter is empty.', example='user-****'),
      workMode?: string(name='WorkMode', description='The working mode of the visualization instance. Valid values:

*   Desktop
*   Application', example='Desktop'),
    }
  ](name='InstanceInfo')
  }(name='Instances', description='The list of visualization instances.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the current page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='2777461A-E45E-42F8-8E67-0EBF132E93E0'),
  totalCount?: int32(name='TotalCount', description='The total number of returned entries.', example='1'),
}

model DescribeGWSInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGWSInstancesResponseBody(name='body'),
}

async function describeGWSInstancesWithOptions(request: DescribeGWSInstancesRequest, runtime: Util.RuntimeOptions): DescribeGWSInstancesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGWSInstances',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGWSInstances(request: DescribeGWSInstancesRequest): DescribeGWSInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGWSInstancesWithOptions(request, runtime);
}

model DescribeImageRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster that you want to manage.', example='ehpc-hz-FYUr32****'),
  containerType?: string(name='ContainerType', description='The type of the container. Set the value to singularity.', example='singularity'),
  imageTag?: string(name='ImageTag', description='The tag of the image. Default value: latest.', example='latest'),
  repository?: string(name='Repository', description='The name of the repository.', example='repo1'),
}

model DescribeImageResponseBody = {
  imageInfo?: {
    imageId?: string(name='ImageId', description='The ID of the image.', example='353506****'),
    repository?: string(name='Repository', description='The name of the repository.', example='hello-world'),
    status?: string(name='Status', description='The status of the image.', example='READY'),
    system?: string(name='System', description='The container system.', example='mycluster'),
    tag?: string(name='Tag', description='The tag of the image.', example='latest'),
    type?: string(name='Type', description='The type of the image. Valid values:

*   shifter
*   docker', example='docker'),
    updateDateTime?: string(name='UpdateDateTime', description='The time when the image was last updated.', example='2018-08-02T20:11:36'),
  }(name='ImageInfo', description='The information of the image.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model DescribeImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeImageResponseBody(name='body'),
}

async function describeImageWithOptions(request: DescribeImageRequest, runtime: Util.RuntimeOptions): DescribeImageResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImage',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeImage(request: DescribeImageRequest): DescribeImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageWithOptions(request, runtime);
}

model DescribeImageGatewayConfigRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-FYUr32****'),
}

model DescribeImageGatewayConfigResponseBody = {
  imagegw?: {
    defaultImageLocation?: string(name='DefaultImageLocation', description='The default address of the image repository.', example='registry-1.docker.io'),
    imageExpirationTimeout?: string(name='ImageExpirationTimeout', description='The time when the image expires.', example='90:00:00'),
    locations?: {
      locationInfo?: [ 
      {
        authentication?: string(name='Authentication', description='The authentication method of the image repository. Valid values:

*   http
*   https', example='https'),
        location?: string(name='Location', description='The source address of the image repository.', example='regi****.docker.io'),
        remoteType?: string(name='RemoteType', description='The type of the image repository.', example='dockerv2'),
        URL?: string(name='URL', description='The URL of the image repository.', example='https://regi****.docker-cn.com'),
      }
    ](name='LocationInfo')
    }(name='Locations', description='An array of the image repository addresses.'),
    mongoDBURI?: string(name='MongoDBURI', description='The information about the image gateway database.', example='mongodb://localhost'),
    pullUpdateTimeout?: long(name='PullUpdateTimeout', description='The timeout period for pulling images.', example='300'),
    updateDateTime?: string(name='UpdateDateTime', description='The time when the file was updated.', example='2018-07-18T17:46:47'),
  }(name='Imagegw', description='The information about the image gateway configuration file.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model DescribeImageGatewayConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeImageGatewayConfigResponseBody(name='body'),
}

async function describeImageGatewayConfigWithOptions(request: DescribeImageGatewayConfigRequest, runtime: Util.RuntimeOptions): DescribeImageGatewayConfigResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageGatewayConfig',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeImageGatewayConfig(request: DescribeImageGatewayConfigRequest): DescribeImageGatewayConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageGatewayConfigWithOptions(request, runtime);
}

model DescribeImagePriceRequest {
  amount?: int32(name='Amount', description='The number of images that you want to purchase. Valid values: 1 to 1000.

Default value: 1', example='2'),
  imageId?: string(name='ImageId', description='The ID of the image.', example='m-bp198jigq7l1ga11****'),
  orderType?: string(name='OrderType', description='The type of the order. The order can be set only as a purchase order. Valid value: INSTANCE-BUY.', example='INSTANCE-BUY'),
  period?: int32(name='Period', description='The subscription duration. Valid values:

*   If PriceUnit is set to Day, the valid values of the Period parameter are 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, and 30.
*   If PriceUnit is set to Month, the valid values of the Period parameter are 1, 2, 3, 4, 5, 6, 7, 8, and 9.
*   If PriceUnit is set to Year, the valid values of the Period parameter are 1, 2, and 3.

Default value: 1', example='1'),
  priceUnit?: string(name='PriceUnit', description='The unit of the subscription duration. Valid values:

*   Day
*   Month
*   Year

Default value: Day', example='Day'),
  skuCode?: string(name='SkuCode', description='The stock keeping unit (SKU) of the image. Valid value: package.', example='package'),
}

model DescribeImagePriceResponseBody = {
  amount?: int32(name='Amount', description='The number of images that you want to purchase.', example='1'),
  discountPrice?: float(name='DiscountPrice', description='The discount that is applied.', example='0'),
  imageId?: string(name='ImageId', description='The ID of the image.', example='m-bp198jigq7l1ga11****'),
  originalPrice?: float(name='OriginalPrice', description='The original price of the image.', example='0.8'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='47ca3ac4-2a03-48f1-8bf2-ba6de0f3****'),
  tradePrice?: float(name='TradePrice', description='The final price of the image.', example='0.8'),
}

model DescribeImagePriceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeImagePriceResponseBody(name='body'),
}

async function describeImagePriceWithOptions(request: DescribeImagePriceRequest, runtime: Util.RuntimeOptions): DescribeImagePriceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImagePrice',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeImagePrice(request: DescribeImagePriceRequest): DescribeImagePriceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImagePriceWithOptions(request, runtime);
}

model DescribeJobRequest {
  async?: boolean(name='Async', example='false'),
  clusterId?: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-jeJki6****'),
  jobId?: string(name='JobId', description='The ID of the job.

You can call the [ListJobs](~~87251~~) operation to query the job ID.', example='1.scheduler****'),
}

model DescribeJobResponseBody = {
  message?: {
    jobInfo?: string(name='JobInfo', description='The details of the job.', example='{"2.scheduler": {"egroup": "users","Stageout_status": 1,"Keep_Files": "n","server": "scheduler","queue": "workq"}}'),
  }(name='Message', description='The list of returned job information.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='9697AD8D-56FA-4C8E-B46C-00AC9***'),
}

model DescribeJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeJobResponseBody(name='body'),
}

async function describeJobWithOptions(request: DescribeJobRequest, runtime: Util.RuntimeOptions): DescribeJobResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeJob',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeJob(request: DescribeJobRequest): DescribeJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeJobWithOptions(request, runtime);
}

model DescribeNFSClientStatusRequest {
  instanceId?: string(name='InstanceId', description='The ID of the visualization instance.', example='i-bp1bzq4rj1emun****'),
}

model DescribeNFSClientStatusResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='3EB7FCEE-D731-4948-85A3-4B2C341CA983'),
  result?: {
    exitCode?: int32(name='ExitCode', description='The Base64-decoded Output parameter value. A True in the last line indicates successful installation. Otherwise, the installation fails.', example='0'),
    invokeRecordStatus?: string(name='InvokeRecordStatus', description='The status of the invocation record, which is the same as the value of the Status parameter.', example='Running'),
    output?: string(name='Output', description='The execution result of the command.', example='TmV3LUlWtmOWc6XxpZW50Rm9yLi4uDQ****'),
  }(name='Result', description='The list of results.'),
  status?: string(name='Status', description='The deployment status of the NFS client. Valid values:

*   NotInstalled: The client is not installed.
*   Running: The client is being installed.
*   Finished: The client is installed on the instance.', example='Running'),
}

model DescribeNFSClientStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeNFSClientStatusResponseBody(name='body'),
}

async function describeNFSClientStatusWithOptions(request: DescribeNFSClientStatusRequest, runtime: Util.RuntimeOptions): DescribeNFSClientStatusResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeNFSClientStatus',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeNFSClientStatus(request: DescribeNFSClientStatusRequest): DescribeNFSClientStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeNFSClientStatusWithOptions(request, runtime);
}

model DescribePriceRequest {
  chargeType?: string(name='ChargeType', description='The billing method of the ECS instances. Valid values:

*   PostPaid: pay-as-you-go
*   PrePaid: subscription

Default value: PostPaid', example='PostPaid'),
  commodities?: [ 
    {
      amount?: int32(name='Amount', description='The node quantity of the type. Valid values: 1 to 1000.

Default value: 1

Valid values of N: 1 to 10', example='2'),
      dataDisks?: [ 
        {
          category?: string(name='category', description='The type of the data disk. Valid values:

*   cloud_efficiency: ultra disk
*   cloud_ssd: SSD
*   cloud_essd: ESSD
*   cloud: basic disk

Default value: cloud_efficiency

Valid values of N: 0 to 4', example='cloud_efficiency'),
          deleteWithInstance?: boolean(name='deleteWithInstance', description='Specifies whether the data disk is released when the node is released. Valid values:

*   true
*   false

Default value: true

Valid values of N: 0 to 4', example='true'),
          encrypted?: boolean(name='encrypted', description='Specifies whether to encrypt the data disk. Valid values:

*   true
*   false

Default value: false

Valid values of N: 0 to 4', example='false'),
          performanceLevel?: string(name='performanceLevel', description='The performance level of the ESSD used as the data disk. This parameter takes effect only when the Commodities.N.DataDisks.N.category parameter is set to cloud_essd. Default value: PL1. Valid values:

*   PL0: A single ESSD can deliver up to 10,000 random read/write IOPS.
*   PL1: A single ESSD can deliver up to 50,000 random read/write IOPS.
*   PL2: A single ESSD can deliver up to 100,000 random read/write IOPS.
*   PL3: A single ESSD can deliver up to 1,000,000 random read/write IOPS.

Default value: PL1

Valid values of N: 0 to 4', example='PL1'),
          size?: int32(name='size', description='The size of the data disk. Unit: GB.

Valid values: 40 to 500

Default value: 40

Valid values of N: 0 to 4', example='40'),
        }
      ](name='DataDisks'),
      instanceType?: string(name='InstanceType', description='The instance type of the node.

Valid values of N: 1 to 10', example='ecs.n1.tiny'),
      internetChargeType?: string(name='InternetChargeType', description='The EIP billing method of the node. Valid values:

*   PayByBandwidth: pay-by-bandwidth
*   PayByTraffic: pay-by-traffic

Valid values of N: 1 to 10', example='PayByBandwidth'),
      internetMaxBandWidthOut?: int32(name='InternetMaxBandWidthOut', description='The maximum outbound public bandwidth of the node. Unit: Mbit/s.

Valid values: 0 to 100

Default value: 0

Valid values of N: 1 to 10', example='100'),
      networkType?: string(name='NetworkType', description='The network type of the node. Valid value: VPC.

Valid values of N: 1 to 10', example='VPC'),
      nodeType?: string(name='NodeType', description='The type of the node. Valid values:

*   Compute: compute node
*   Manager: management node
*   Login: logon node

Valid values of N: 1 to 10', example='Compute'),
      period?: int32(name='Period', description='The subscription duration of the node. Valid values:

*   If PriceUnit is set to Year, the valid values of the Period parameter are 1, 2, and 3.
*   If PriceUnit is set to Month, the valid values of the Period parameter are 1, 2, 3, 4, 5, 6, 7, 8, and 9.
*   If PriceUnit is set to Hour, the valid value of the Period parameter is 1.

Default value: 1

Valid values of N: 1 to 10', example='1'),
      systemDiskCategory?: string(name='SystemDiskCategory', description='The system disk type of the node. Valid values:

*   cloud_efficiency: ultra disk
*   cloud_ssd: SSD
*   cloud_essd: ESSD
*   cloud: basic disk

Default value: cloud_efficiency

Valid values of N: 1 to 10', example='cloud_ssd'),
      systemDiskPerformanceLevel?: string(name='SystemDiskPerformanceLevel', description='The performance level of the ESSD used as the system disk. This parameter takes effect only when the Commodities.N.SystemDiskCategory parameter is set to cloud_essd. Default value: PL1. Valid values:

*   PL0: A single ESSD can deliver up to 10,000 random read/write IOPS.
*   PL1: A single ESSD can deliver up to 50,000 random read/write IOPS.
*   PL2: A single ESSD can deliver up to 100,000 random read/write IOPS.
*   PL3: A single ESSD can deliver up to 1,000,000 random read/write IOPS.

Default value: PL1

Valid values of N: 1 to 10', example='PL1'),
      systemDiskSize?: int32(name='SystemDiskSize', description='The system disk size of the node. Unit: GB.

Valid values: 40 to 500

Default value: 40

Valid values of N: 1 to 10', example='40'),
    }
  ](name='Commodities'),
  orderType?: string(name='OrderType', description='The type of the order. The order can be set only as a purchase order. Valid value: INSTANCE-BUY.', example='INSTANCE-BUY'),
  priceUnit?: string(name='PriceUnit', description='The billing cycle of the Elastic Compute Service (ECS) instances. This parameter takes effect only when the ChargeType parameter is set to PrePaid. Valid values:

*   Month: pay-by-month
*   Year: pay-by-year
*   Hour: pay-by-hour

Default value: Hour', example='Hour'),
}

model DescribePriceResponseBody = {
  prices?: {
    priceInfo?: [ 
    {
      currency?: string(name='Currency', description='The currency that is used to measure the price. Valid values:

USD', example='CNY'),
      nodeType?: string(name='NodeType', description='The type of the node. Valid values:

*   Manager: management node
*   Login: logon node
*   Compute: compute node', example='Compute'),
      originalPrice?: float(name='OriginalPrice', description='The original price of the image.

Unit: USD', example='1258'),
      tradePrice?: float(name='TradePrice', description='The final price.

Unit: USD', example='1258'),
    }
  ](name='PriceInfo')
  }(name='Prices', description='The array of cluster prices. If you query the prices of multiple nodes in the cluster, the sequence of the prices in the returned value of PriceInfo is the same as that of the nodes in the request parameters. For example, the first price in the value of PriceInfo is the price of the first node specified in the request parameters.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='54FF9025-2C2F-42EB-870D-0DF5B0ACF24E'),
  totalTradePrice?: float(name='TotalTradePrice', description='The total price.

Unit: USD', example='1258'),
}

model DescribePriceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePriceResponseBody(name='body'),
}

/**
  * ****
  *
  * @param request DescribePriceRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribePriceResponse
 */
async function describePriceWithOptions(request: DescribePriceRequest, runtime: Util.RuntimeOptions): DescribePriceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePrice',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * ****
  *
  * @param request DescribePriceRequest
  * @return DescribePriceResponse
 */
async function describePrice(request: DescribePriceRequest): DescribePriceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePriceWithOptions(request, runtime);
}

model EditJobTemplateRequest {
  arrayRequest?: string(name='ArrayRequest', description='The job array.

Format: X-Y:Z. X is the minimum index value. Y is the maximum index value. Z is the step size. For example, 2-7:2 indicates that three jobs need to be run and their index values are 2, 4, and 6.', example='1-10:2'),
  clockTime?: string(name='ClockTime', description='The maximum running time of the job. Valid formats:

*   hh:mm:ss
*   mm:ss
*   ss

We recommend that you use the hh:mm:ss format. If the maximum running time is 12 hours, set the value to 12:00:00.', example='12:00:00'),
  commandLine?: string(name='CommandLine', description='The command that is used to run the job.', example='./LammpsTest/lammps.pbs'),
  gpu?: int32(name='Gpu', description='The maximum GPU usage required by a single compute node. Valid values: 1 to 8.

The parameter takes effect only when the cluster uses PBS and a compute node is a GPU-accelerated instance.', example='1'),
  inputFileUrl?: string(name='InputFileUrl', description='The URL of the job files that are uploaded to an Object Storage Service (OSS) bucket.', example='https://test.oss-cn-beijing.aliyuncs.com/test.py'),
  mem?: string(name='Mem', description='The maximum memory usage required by a single compute node. Unit: GB, MB, or KB. The unit is case-insensitive.', example='1GB'),
  name?: string(name='Name', description='The name of the job template.

You can call the [ListJobTemplates](~~87248~~) operation to obtain the job template name.', example='jobTemapleteName'),
  node?: int32(name='Node', description='The number of the compute nodes. Valid values: 1 to 500.

>  If the parameter is not specified, the Task, Thread, Mem, and Gpu parameters become invalid.', example='2'),
  packagePath?: string(name='PackagePath', description='The path that is used to run the job.', example='./packageFolder'),
  priority?: int32(name='Priority', description='The priority of the job. Valid values: 0 to 9. A large value indicates a high priority.

Default value: 0', example='0'),
  queue?: string(name='Queue', description='The name of the queue.', example='workq'),
  reRunable?: boolean(name='ReRunable', description='Specifies whether the job can be rerun. Valid values:

*   true: The job can be rerun.
*   false: The job cannot be rerun.', example='false'),
  runasUser?: string(name='RunasUser', description='The name of the user that runs the job.

You can call the [ListUsers](~~188572~~) operation to query the users of the cluster.', example='user'),
  stderrRedirectPath?: string(name='StderrRedirectPath', description='The output file path of stderr.', example='./Lammps'),
  stdoutRedirectPath?: string(name='StdoutRedirectPath', description='The output file path of stdout.', example='./LammpsTest'),
  task?: int32(name='Task', description='The number of tasks required by a single compute node. Valid values: 1 to 1000.', example='2'),
  templateId?: string(name='TemplateId', description='The ID of the job template.

You can call the [ListJobTemplates](~~87248~~) operation to obtain the job template ID.', example='ehpc-job-tmpl-6RxO5y****'),
  thread?: int32(name='Thread', description='The number of threads required by a single compute node. Valid values: 1 to 1000.', example='1'),
  unzipCmd?: string(name='UnzipCmd', description='The command that is used to decompress the job files downloaded from an OSS bucket. The parameter takes effect only when WithUnzipCmd is set to true. Valid values:

*   tar xzf: decompresses GZIP files.
*   tar xf: decompresses TAR files.
*   unzip: decompresses ZIP files.', example='tar xzf'),
  variables?: string(name='Variables', description='The runtime variables passed to the job. They can be accessed by using environment variables in the executable file.', example='[{Name:,Value:},{Name:,Value:}]'),
  withUnzipCmd?: boolean(name='WithUnzipCmd', description='Specifies whether to decompress the job files downloaded from an OSS bucket. Valid values:

*   true: The job files are decompressed.
*   false: The job files are not decompressed.', example='true'),
}

model EditJobTemplateResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  templateId?: string(name='TemplateId', description='The ID of the job template.', example='ehpc-job-tmpl-6RxO5y****'),
}

model EditJobTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EditJobTemplateResponseBody(name='body'),
}

async function editJobTemplateWithOptions(request: EditJobTemplateRequest, runtime: Util.RuntimeOptions): EditJobTemplateResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EditJobTemplate',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function editJobTemplate(request: EditJobTemplateRequest): EditJobTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return editJobTemplateWithOptions(request, runtime);
}

model GetAccountingReportRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-FYUr32****'),
  dim?: string(name='Dim', description='The layers at which you want to query the bandwidth and traffic data. Valid values:

*   user: Query by user.
*   queue: Query by queue.
*   instance: Query by instance.', example='user'),
  endTime?: int32(name='EndTime', description='The end of the time range to query. This value is a UNIX timestamp representing the number of seconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.', example='1577441873'),
  filterValue?: string(name='FilterValue', description='The actual name of the dimension to be queried. Valid values:

*   If you set the value of the parameter Dim to user, the value of FilterValue is the name of the specified user.
*   If you set the value of the parameter Dim to queue, the value of FilterValue is the name of the specified queue.
*   If you set the value of the parameter Dim to instance, the value of FilterValue is the instance name.', example='userNo1'),
  jobId?: string(name='JobId', description='The ID of the job.', example='[{Id: 1.scheduler}]'),
  pageNumber?: int32(name='PageNumber', description='The number of entries to return on each page. Valid values: 1 to 50.

Default value: 10.', example='10'),
  pageSize?: int32(name='PageSize', description='The page number of the returned page.

Pages start from page 1.

Default value: 1.', example='1'),
  reportType?: string(name='ReportType', description='The query type. Valid values:

*   total_report: Queries the number of CPU cores in different dimensions.
*   job_report: Collects the historical node data of a node.
*   number_report: Queries job information in different dimensions.', example='job_report'),
  startTime?: int32(name='StartTime', description='The beginning of the time range to query. This value is a UNIX timestamp representing the number of seconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.', example='1576922873'),
}

model GetAccountingReportResponseBody = {
  data?: {
    data?: [ string ](name='Data')
  }(name='Data', description='The list serialized in the JSON format. The list contains multiple records.'),
  metrics?: string(name='Metrics', description='The list serialized in the JSON format. The list contains the column names of each record in the Data.', example='[\\"user\\",\\"coreTime\\",\\"usedMem\\"]'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='B1DCB399-9333-4B38-A35A-0BDFABC71881'),
  totalCoreTime?: int32(name='TotalCoreTime', description='The total number of CPU cores in the queried cluster.', example='261300'),
  totalCount?: int32(name='TotalCount', description='The total number of entries.', example='10'),
}

model GetAccountingReportResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAccountingReportResponseBody(name='body'),
}

async function getAccountingReportWithOptions(request: GetAccountingReportRequest, runtime: Util.RuntimeOptions): GetAccountingReportResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAccountingReport',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAccountingReport(request: GetAccountingReportRequest): GetAccountingReportResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAccountingReportWithOptions(request, runtime);
}

model GetAutoScaleConfigRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-FYUr32****'),
}

model GetAutoScaleConfigResponseBody = {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-FYUr32****'),
  clusterType?: string(name='ClusterType', description='The type of the scheduler. Valid values:

*   slurm
*   pbs
*   opengridscheduler
*   deadline', example='pbs'),
  computeEnableHt?: boolean(name='ComputeEnableHt'),
  enableAutoGrow?: boolean(name='EnableAutoGrow', description='Indicates whether the cluster enabled auto scale-out. Valid values:

*   true
*   false', example='true'),
  enableAutoShrink?: boolean(name='EnableAutoShrink', description='Indicates whether the cluster enabled auto scale-in. Valid values:

*   true
*   false', example='true'),
  excludeNodes?: string(name='ExcludeNodes', description='The compute nodes that were excluded from the list of auto scaling nodes. Multiple compute nodes were separated with commas (,).', example='i-bp19lgqwxb4206t5****,i-bp1g4hvzs9pywrhb****'),
  extraNodesGrowRatio?: int32(name='ExtraNodesGrowRatio', description='The percentage of extra compute nodes. Valid values: 0 to 100.

If you need to add 100 compute nodes and the value of the ExtraNodesGrowRatio parameter is 2, 102 compute nodes are added.', example='2'),
  growIntervalInMinutes?: int32(name='GrowIntervalInMinutes', description='The interval between two consecutive rounds of scale-in. Unit: minutes. Valid values: 2 to 10.

>  An interval may exist during multiple rounds of a scale-out task or between two consecutive scale-out tasks.', example='2'),
  growRatio?: int32(name='GrowRatio', description='The percentage of each round of scale-out. Valid values: 1 to 100.

If you set GrowRatio to 50, the scale-out has two rounds. Each round completes half of the scale-out.', example='100'),
  growTimeoutInMinutes?: int32(name='GrowTimeoutInMinutes', description='The timeout period before the scale-out nodes were started. Unit: minutes. Valid values: 10 to 60.

If the scale-out timeout period has been reached but the scale-out nodes still do not reach the Running state, the system resets them.', example='20'),
  imageId?: string(name='ImageId', description='The image ID of the compute nodes in the queue.', example='m-bp10txryr4mhrrt1****'),
  maxNodesInCluster?: int32(name='MaxNodesInCluster', description='The maximum number of compute nodes that can be added in the cluster. Valid values: 0 to 500.', example='300'),
  queues?: {
    queueInfo?: [ 
    {
      dataDisks?: {
        dataDisksInfo?: [ 
        {
          dataDiskCategory?: string(name='DataDiskCategory', description='The type of the data disk. Valid values:

- cloud_efficiency: ultra disk
- cloud_ssd: SSD
- cloud_essd: ESSD
- cloud: basic disk', example='cloud_efficiency'),
          dataDiskDeleteWithInstance?: boolean(name='DataDiskDeleteWithInstance', description='Indicates whether the data disk is released when the node is released. Valid values:

- true
- false', example='true'),
          dataDiskEncrypted?: boolean(name='DataDiskEncrypted', description='Indicates whether the data disk is encrypted. Valid values:

- true
- false', example='false'),
          dataDiskKMSKeyId?: string(name='DataDiskKMSKeyId', description='The KMS key ID of the data disk.', example='0e478b7a-4262-4802-b8cb-00d3fb40826X'),
          dataDiskPerformanceLevel?: string(name='DataDiskPerformanceLevel', description='The performance level of the ESSD used as the data disk. The parameter takes effect only when the DataDisks.N.DataDiskCategory parameter is set to cloud_essd. Valid values: 

- PL0: A single ESSD can deliver up to 10,000 random read/write IOPS.
- PL1: A single ESSD can deliver up to 50,000 random read/write IOPS.
- PL2: A single ESSD can deliver up to 100,000 random read/write IOPS.
- PL3: A single ESSD can deliver up to 1,000,000 random read/write IOPS.', example='PL1'),
          dataDiskSize?: int32(name='DataDiskSize', description='The capacity of the data disk. Unit: GB.

Valid values: 40 to 500', example='40'),
        }
      ](name='DataDisksInfo')
      }(name='DataDisks', description='The list of data disks.'),
      enableAutoGrow?: boolean(name='EnableAutoGrow', description='Indicates whether the queue enabled auto scale-out. Valid values:

*   true
*   false', example='true'),
      enableAutoShrink?: boolean(name='EnableAutoShrink', description='Indicates whether the queue enabled auto scale-in. Valid values:

*   true
*   false', example='true'),
      hostNamePrefix?: string(name='HostNamePrefix', description='The prefix of the queue name. You can query queues that have a specified prefix.', example='compute'),
      hostNameSuffix?: string(name='HostNameSuffix', description='The suffix of the queue name. You can query queues that have a specified suffix.', example='000'),
      instanceType?: string(name='InstanceType', description='The instance type of the compute nodes that were automatically added in the queue.', example='ecs.sn1ne.large'),
      instanceTypes?: {
        instanceTypeInfo?: [ 
        {
          hostNamePrefix?: string(name='HostNamePrefix', description='The prefix of the hostname. You can query compute nodes that have a specified prefix.', example='compute'),
          instanceType?: string(name='InstanceType', description='The instance type of the node.', example='ecs.sn1ne.large'),
          spotDuration?: int32(name='SpotDuration', example='0'),
          spotInterruptionBehavior?: string(name='SpotInterruptionBehavior', example='Terminate'),
          spotPriceLimit?: float(name='SpotPriceLimit', description='The maximum hourly price of the compute nodes. The value can be accurate to three decimal places. The parameter takes effect only when SpotStrategy is set to SpotWithPriceLimit.', example='0.062'),
          spotStrategy?: string(name='SpotStrategy', description='The bidding method of the compute nodes. Valid values:

*   NoSpot: The compute nodes are pay-as-you-go instances.
*   SpotWithPriceLimit: The compute nodes are preemptible instances that have a user-defined maximum hourly price.
*   SpotAsPriceGo: The compute nodes are preemptible instances for which the market price at the time of purchase is used as the bid price.', example='NoSpot'),
          vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch.', example='vsw-bp1lfcjbfb099rrjn****'),
          zoneId?: string(name='ZoneId', description='The ID of the zone.', example='cn-hangzhou-b'),
        }
      ](name='InstanceTypeInfo')
      }(name='InstanceTypes', description='The specification information of the compute nodes.'),
      maxNodesInQueue?: int32(name='MaxNodesInQueue', description='The maximum number of compute nodes that can be added in a queue. Valid values: 0 to 500.', example='100'),
      maxNodesPerCycle?: long(name='MaxNodesPerCycle', description='The maximum number of compute nodes that can be added in each round of scale-out. Valid values: 0 to 99.  

Default value: 0.', example='20'),
      minNodesInQueue?: int32(name='MinNodesInQueue', description='The minimum number of compute nodes that can be retained in a queue. Valid values: 0 to 50.', example='10'),
      minNodesPerCycle?: long(name='MinNodesPerCycle', description='The minimum number of compute nodes that can be added in each round of scale-out. Valid values: 1 to 99.  

Default value: 1. 

If the compute nodes that you want to add in a round is less than the minimum compute nodes that can be added, the value of this parameter is automatically changed to the number of compute nodes that you want to add. This ensures that compute nodes can be added as expected.  

>  The configuration takes effect only for the minimum compute nodes that can be added in the current round.', example='5'),
      queueImageId?: string(name='QueueImageId', description='The image ID of the compute nodes in the queue.', example='centos_7_06_64_20G_alibase_2019071****'),
      queueName?: string(name='QueueName', description='The name of the queue.', example='workq'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the compute nodes belong.', example='rg-acfmxp7uc24****'),
      spotPriceLimit?: float(name='SpotPriceLimit', description='The maximum hourly price of the compute nodes. The value can be accurate to three decimal places. The parameter takes effect only when SpotStrategy is set to SpotWithPriceLimit.', example='0.062'),
      spotStrategy?: string(name='SpotStrategy', description='The preemption policy of the compute nodes. Valid values:

*   NoSpot: The compute nodes are pay-as-you-go instances.
*   SpotWithPriceLimit: The compute nodes are preemptible instances that have a user-defined maximum hourly price.
*   SpotAsPriceGo: The compute nodes are preemptible instances for which the market price at the time of purchase is used as the bid price.', example='NoSpot'),
      systemDiskCategory?: string(name='SystemDiskCategory', description='The type of the system disk. Valid values:

*   cloud_efficiency: ultra disk
*   cloud_ssd: SSD
*   cloud_essd: ESSD
*   cloud: basic disk', example='cloud_efficiency'),
      systemDiskLevel?: string(name='SystemDiskLevel', description='The performance level of the system disk. Valid values:

*   PL0: A single ESSD can deliver up to 10,000 random read/write IOPS.
*   PL1: A single ESSD can deliver up to 50,000 random read/write IOPS.
*   PL2: A single ESSD can deliver up to 100,000 random read/write IOPS.
*   PL3: A single ESSD can deliver up to 1,000,000 random read/write IOPS.', example='PL1'),
      systemDiskSize?: int32(name='SystemDiskSize', description='The size of the system disk. Unit: GB. Valid values: 40 to 500.', example='40'),
    }
  ](name='QueueInfo')
  }(name='Queues', description='The auto scaling configuration of the queue.

>  If auto scaling is enabled for the cluster and queue at the same time, the queue settings prevail.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
  shrinkIdleTimes?: int32(name='ShrinkIdleTimes', description='The number of consecutive times that a compute node is idle during the resource scale-in check. Valid values: 2 to 5.

If the parameter is set to 3, a compute node is idle for more than three consecutive times. In this case, the node is released.', example='3'),
  shrinkIntervalInMinutes?: int32(name='ShrinkIntervalInMinutes', description='The interval between two consecutive rounds of scale-out. Unit: minutes. Valid values: 2 to 10.', example='2'),
  spotPriceLimit?: float(name='SpotPriceLimit', description='The maximum hourly price of the compute nodes. The value can be accurate to three decimal places. The parameter takes effect only when SpotStrategy is set to SpotWithPriceLimit.', example='0.062'),
  spotStrategy?: string(name='SpotStrategy', description='The preemption policy of the compute nodes. Valid values:

*   NoSpot: The compute nodes are pay-as-you-go instances.
*   SpotWithPriceLimit: The compute nodes are preemptible instances that have a user-defined maximum hourly price.
*   SpotAsPriceGo: The compute nodes are preemptible instances for which the market price at the time of purchase is used as the bid price.', example='SpotWithPriceLimit'),
  uid?: string(name='Uid', description='The ID of the Alibaba Cloud account.', example='129845258050****'),
}

model GetAutoScaleConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAutoScaleConfigResponseBody(name='body'),
}

async function getAutoScaleConfigWithOptions(request: GetAutoScaleConfigRequest, runtime: Util.RuntimeOptions): GetAutoScaleConfigResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAutoScaleConfig',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAutoScaleConfig(request: GetAutoScaleConfigRequest): GetAutoScaleConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAutoScaleConfigWithOptions(request, runtime);
}

model GetCloudMetricLogsRequest {
  aggregationInterval?: int32(name='AggregationInterval', description='The data aggregation interval. Unit: seconds.

Valid values: 1, 10, 60, 600, and 3600.

Default value: 1', example='10'),
  aggregationType?: string(name='AggregationType', description='The data aggregation type. Valid values:

*   sum: the sum of the data
*   avg: the average value
*   max: the maximum value
*   min: the minimum value

Aggregation is disabled by default.', example='avg'),
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-jeJki6****'),
  filter?: string(name='Filter', description='The filter conditions. A JSON string consisting of one or more key:value pairs. Value range of key:

*   InstanceId: the ID of the node
*   Hostname: the hostname of the node
*   NetworkInterface: the name of the network interface
*   DiskDevice: the name of the disk', example='{"Hostname":"compute000"}'),
  from?: int32(name='From', description='The beginning of the time range to query. This value is a UNIX timestamp representing the number of seconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.', example='1583907780'),
  metricCategories?: string(name='MetricCategories', description='The category of the output performance metrics. Separate multiple metrics with commas (,). Valid values:

*   cpu
*   memory', example='cpu'),
  metricScope?: string(name='MetricScope', description='The dimensions of the performance metric. Valid values:

*   machine
*   process
*   network
*   disk', example='network'),
  reverse?: boolean(name='Reverse', description='Logs are returned in reverse order of timestamps.

Default value: false', example='false'),
  to?: int32(name='To', description='The end of the time range to query. This value is a UNIX timestamp representing the number of seconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.', example='1583907790'),
}

model GetCloudMetricLogsResponseBody = {
  metricLogs?: {
    metricLog?: [ 
    {
      diskDevice?: string(name='DiskDevice', description='The name of the disk.', example='vda1'),
      hostname?: string(name='Hostname', description='The hostname of the node.', example='compute000'),
      instanceId?: string(name='InstanceId', description='The ID of the node.', example='i-bp132g97g7zwnvta****'),
      metricData?: string(name='MetricData', description='A JSON-serialized string that contains values for multiple performance metrics.', example='{\\"process|cpusage\\":0,\\"process|cpuser\\":0,\\"process|cpusys\\":0,******}'),
      networkInterface?: string(name='NetworkInterface', description='The name of the network interface.', example='eth1'),
      time?: int32(name='Time', description='The timestamp of the log. This value is a UNIX timestamp representing the number of seconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.', example='1583907780'),
    }
  ](name='MetricLog')
  }(name='MetricLogs', description='The list of the performance data.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='015C2C4D-1884-4EB7-BCD3-C5BB8D7E56DB'),
}

model GetCloudMetricLogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetCloudMetricLogsResponseBody(name='body'),
}

async function getCloudMetricLogsWithOptions(request: GetCloudMetricLogsRequest, runtime: Util.RuntimeOptions): GetCloudMetricLogsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCloudMetricLogs',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getCloudMetricLogs(request: GetCloudMetricLogsRequest): GetCloudMetricLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCloudMetricLogsWithOptions(request, runtime);
}

model GetCloudMetricProfilingRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-jeJki6****'),
  profilingId?: string(name='ProfilingId', description='The profiling ID. You can call the [ListCloudMetricProfilings](~~188711~~) operation to obtain the profiling ID.', example='ehpc-hz-i-bplukzqgl****_21687_2019-09-09-02-37-40'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
}

model GetCloudMetricProfilingResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0DD6F715-85EE-4EA6-BDC4-48A75B719068'),
  svgUrls?: {
    svgInfo?: [ 
    {
      name?: string(name='Name', description='The name of the SVG file that contains the profiling results.', example='ehpc-hz-faRavbPf6b_i-bdrftgyh890654****_21687_2019-09-09-02-37-40.bottomup.svg'),
      size?: int32(name='Size', description='The size of the SVG file. Unit: bytes.', example='648'),
      type?: string(name='Type', description='The type of the SVG file.', example='file'),
      url?: string(name='Url', description='The URL of the Object Storage Service (OSS) bucket where the scalable vector graphics (SVG) file is stored.', example='https://cloudmetrics-****-hz.oss-cn-hangzhou.aliyuncs.com/112****/ehpc-hz-faRavb****njuik%Oxlftyhujmi0Y****'),
    }
  ](name='SvgInfo')
  }(name='SvgUrls', description='The list of profiling results.'),
}

model GetCloudMetricProfilingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetCloudMetricProfilingResponseBody(name='body'),
}

async function getCloudMetricProfilingWithOptions(request: GetCloudMetricProfilingRequest, runtime: Util.RuntimeOptions): GetCloudMetricProfilingResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCloudMetricProfiling',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getCloudMetricProfiling(request: GetCloudMetricProfilingRequest): GetCloudMetricProfilingResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCloudMetricProfilingWithOptions(request, runtime);
}

model GetClusterVolumesRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-gh5WKb****'),
}

model GetClusterVolumesResponseBody = {
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='8BCFD52E-0336-4490-AE7D-F560F106****'),
  volumes?: {
    volumeInfo?: [ 
    {
      jobQueue?: string(name='JobQueue', description='The queue of the job.', example='workq'),
      localDirectory?: string(name='LocalDirectory', description='The local mount directory.', example='/ehpcdata'),
      location?: string(name='Location', description='The type of cluster. Valid values:

*   OnPremise: The cluster is deployed on a hybrid cloud.
*   PublicCloud: The cluster is deployed on a public cloud.', example='PublicCloud'),
      mustKeep?: boolean(name='MustKeep', description='Indicates whether the resource can be unmounted.', example='true'),
      remoteDirectory?: string(name='RemoteDirectory', description='The remote mount directory.', example='/test'),
      roles?: {
        roleInfo?: [ 
        {
          name?: string(name='Name', description='The type of the node on which the file system is mounted. Valid values:

*   Compute: compute node
*   Manager: management node
*   Login: logon node', example='Compute'),
        }
      ](name='RoleInfo')
      }(name='Roles', description='The array of the node on which the file system is mounted.'),
      volumeId?: string(name='VolumeId', description='The ID of the file system.', example='0e754****'),
      volumeMountpoint?: string(name='VolumeMountpoint', description='The address of the mount target.', example='0e754****-kal90.cn-hangzhou.nas.aliyuncs.com<'),
      volumeProtocol?: string(name='VolumeProtocol', description='The storage protocol type of the file system. Valid values:

*   NFS
*   SMB', example='NFS'),
      volumeType?: string(name='VolumeType', description='The type of the file system. Valid values:

*   NAS', example='NAS'),
    }
  ](name='VolumeInfo')
  }(name='Volumes', description='The array of the file system mounted to the E-HPC cluster.'),
}

model GetClusterVolumesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetClusterVolumesResponseBody(name='body'),
}

async function getClusterVolumesWithOptions(request: GetClusterVolumesRequest, runtime: Util.RuntimeOptions): GetClusterVolumesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetClusterVolumes',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getClusterVolumes(request: GetClusterVolumesRequest): GetClusterVolumesResponse {
  var runtime = new Util.RuntimeOptions{};
  return getClusterVolumesWithOptions(request, runtime);
}

model GetCommonImageRequest {
  clusterId?: string(name='ClusterId', example='ehpc-hz-FYUr32****'),
  containType?: string(name='ContainType', example='singularity'),
  imageName?: string(name='ImageName', example='tensorflow-21.09-tf1-py3.sif'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
}

model GetCommonImageResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request', example='1DB7684F-4F93-5314-8D3F-F28EE0788E9E'),
}

model GetCommonImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetCommonImageResponseBody(name='body'),
}

async function getCommonImageWithOptions(request: GetCommonImageRequest, runtime: Util.RuntimeOptions): GetCommonImageResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCommonImage',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getCommonImage(request: GetCommonImageRequest): GetCommonImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCommonImageWithOptions(request, runtime);
}

model GetGWSConnectTicketRequest {
  appName?: string(name='AppName', example='app-****'),
  instanceId?: string(name='InstanceId', example='i-bp1ch35z696b6b26****'),
}

model GetGWSConnectTicketResponseBody = {
  requestId?: string(name='RequestId', example='5198C3E8-85F5-4280-8547-687C1710FE08'),
  ticket?: string(name='Ticket', example='W0VuY29kaG9ydFJlY29ubmVjdEVuY****'),
}

model GetGWSConnectTicketResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetGWSConnectTicketResponseBody(name='body'),
}

async function getGWSConnectTicketWithOptions(request: GetGWSConnectTicketRequest, runtime: Util.RuntimeOptions): GetGWSConnectTicketResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetGWSConnectTicket',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getGWSConnectTicket(request: GetGWSConnectTicketRequest): GetGWSConnectTicketResponse {
  var runtime = new Util.RuntimeOptions{};
  return getGWSConnectTicketWithOptions(request, runtime);
}

model GetHybridClusterConfigRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-FYUr32****'),
  node?: string(name='Node', description='The name of the on-premises compute node. You can call this operation to query the configurations of the on-premises compute node.

By default, the operation queries the configurations of a cluster.', example='testNode'),
}

model GetHybridClusterConfigResponseBody = {
  clusterConfig?: string(name='ClusterConfig', description='The configurations returned.

*   If the parameter Node is null, you can obtain the configurations of the hybrid cloud cluster.
*   If the parameter Node is a specified on-premises compute node, you can obtain the configurations of the on-premises compute node.

This parameter is returned in the ini format. You can use this parameter to configure on-premises cluster nodes.', example='ClNjaGcyI6W119Cg****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model GetHybridClusterConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetHybridClusterConfigResponseBody(name='body'),
}

async function getHybridClusterConfigWithOptions(request: GetHybridClusterConfigRequest, runtime: Util.RuntimeOptions): GetHybridClusterConfigResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetHybridClusterConfig',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getHybridClusterConfig(request: GetHybridClusterConfigRequest): GetHybridClusterConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return getHybridClusterConfigWithOptions(request, runtime);
}

model GetIfEcsTypeSupportHtConfigRequest {
  instanceType?: string(name='InstanceType', description='The instance type of the ECS instance.', example='ecs.g6.large'),
}

model GetIfEcsTypeSupportHtConfigResponseBody = {
  defaultHtEnabled?: boolean(name='DefaultHtEnabled', description='Indicates whether Hyper-Threading is enabled by default. Valid values:

*   true: Hyper-Threading is enabled by default.

*   false: Hyper-Threading is disabled by default

> By default, Hyper-Threading is not enabled for the SCC specification family, while Hyper-Threading is enabled for other specification families by default.', example='true'),
  instanceType?: string(name='InstanceType', description='The instance type of the ECS instance.', example='ecs.g6.large'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='80CA7A93-7291-4402-B63D-86DF334E0A1F'),
  supportHtConfig?: boolean(name='SupportHtConfig', description='Indicates whether hyper-threading is supported. Valid values:

*   true: Hyper-Threading is supported.
*   false: Hyper-Threading is not supported.', example='true'),
}

model GetIfEcsTypeSupportHtConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetIfEcsTypeSupportHtConfigResponseBody(name='body'),
}

async function getIfEcsTypeSupportHtConfigWithOptions(request: GetIfEcsTypeSupportHtConfigRequest, runtime: Util.RuntimeOptions): GetIfEcsTypeSupportHtConfigResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetIfEcsTypeSupportHtConfig',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getIfEcsTypeSupportHtConfig(request: GetIfEcsTypeSupportHtConfigRequest): GetIfEcsTypeSupportHtConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return getIfEcsTypeSupportHtConfigWithOptions(request, runtime);
}

model GetJobLogRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-jeJki6****'),
  execHost?: string(name='ExecHost', description='The node on which the job runs.

*   If the job is completed, you do not need to specify the parameter.
*   If the job is running, you must specify the parameter.', example='compute000'),
  jobId?: string(name='JobId', description='The ID of the job.', example='1.scheduler****'),
  offset?: long(name='Offset', description='The position where logs start to be read.

Unit: bits

Default value: 0', example='0'),
  size?: int32(name='Size', description='The maximum size of logs that you can read in a single request.

Unit: bits

Default value: 1024', example='1024'),
}

model GetJobLogResponseBody = {
  errorLog?: string(name='ErrorLog', description='The content of the error logs. The content is encoded in Base64.', example='c2xlZXAgMzA='),
  jobId?: string(name='JobId', description='The ID of the job.', example='1.scheduler****'),
  outputLog?: string(name='OutputLog', description='The content of the output logs. The content is encoded in Base64.', example='c2xlZXAgMzA='),
  requestId?: string(name='RequestId', description='The ID of the task.', example='B745C159-3155-4B94-95D0-4B73D4D2****'),
}

model GetJobLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetJobLogResponseBody(name='body'),
}

async function getJobLogWithOptions(request: GetJobLogRequest, runtime: Util.RuntimeOptions): GetJobLogResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetJobLog',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getJobLog(request: GetJobLogRequest): GetJobLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return getJobLogWithOptions(request, runtime);
}

model GetPostScriptsRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-sh-EnjshUxn'),
  regionId?: string(name='RegionId', description='The ID of the region.

You can call the [ListRegions](~~188593~~) operation to query the latest region list.', example='cn-shanghai'),
}

model GetPostScriptsResponseBody = {
  postInstallScripts?: [ 
    {
      args?: string(name='Args', description='The parameter that is used to run the Nth post-installation script. Valid values of N: 1 to 16.', example='-h'),
      url?: string(name='Url', description='The URL that is used to download the Nth post-installation script. Valid values of N: 1 to 16.', example='https://bucket.oss-cn-shanghai.aliyuncs.com/postscript_examples.sh'),
    }
  ](name='PostInstallScripts', description='The post-installation scripts.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='B745C159-3155-4B94-95D0-4B73D4D2****'),
}

model GetPostScriptsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPostScriptsResponseBody(name='body'),
}

async function getPostScriptsWithOptions(request: GetPostScriptsRequest, runtime: Util.RuntimeOptions): GetPostScriptsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetPostScripts',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPostScripts(request: GetPostScriptsRequest): GetPostScriptsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPostScriptsWithOptions(request, runtime);
}

model GetSchedulerInfoRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-FYUr32****'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
  scheduler?: [ 
    {
      schedName?: string(name='SchedName', description='The name of the scheduler. Valid values:

*   pbs
*   pbs19
*   slurm
*   slurm19
*   slurm20

Valid values of N: 0 to 100', example='pbs'),
    }
  ](name='Scheduler'),
}

model GetSchedulerInfoResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='BBC2F93D-003A-49C4-850C-B826EECF****'),
  schedInfo?: [ 
    {
      configuration?: string(name='Configuration', description='The detailed settings of the scheduler.', example='{ 				"AclInfo": [ 					{ 						"AclEnable": false, 						"UntrackUser": [], 						"User": [], 						"QueueName": "workq" 					} 				], 				"JobHistory": "", 				"SchedIteration": "60", 				"QueueResource": [ 					{ 						"UntrackUser": [], 						"User": [], 						"QueueName": "workq" 					} 				] 			}'),
      schedName?: string(name='SchedName', description='The type of the scheduler.', example='pbs'),
    }
  ](name='SchedInfo', description='The settings of the scheduler.'),
}

model GetSchedulerInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSchedulerInfoResponseBody(name='body'),
}

async function getSchedulerInfoWithOptions(request: GetSchedulerInfoRequest, runtime: Util.RuntimeOptions): GetSchedulerInfoResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSchedulerInfo',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSchedulerInfo(request: GetSchedulerInfoRequest): GetSchedulerInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSchedulerInfoWithOptions(request, runtime);
}

model GetUserImageRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-ibug69*****'),
  containerType?: string(name='ContainerType', description='The type of the image. Set the value to singularity.', example='singularity'),
  imageName?: string(name='ImageName', description='The name of the image.', example='test.sif'),
  imagePath?: string(name='ImagePath', description='The path where the image is stored in the OSS bucket.', example='testUserImages'),
  OSSBucket?: string(name='OSSBucket', description='The OSS bucket.', example='XXXXXXX'),
  OSSEndPoint?: string(name='OSSEndPoint', description='The endpoint of OSS.', example='vpc***-oss-cn-hangzhou.aliyuncs.com'),
}

model GetUserImageResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='C84FB8EF-5580-4B82-9BDE-6657814C****'),
}

model GetUserImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetUserImageResponseBody(name='body'),
}

async function getUserImageWithOptions(request: GetUserImageRequest, runtime: Util.RuntimeOptions): GetUserImageResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetUserImage',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getUserImage(request: GetUserImageRequest): GetUserImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return getUserImageWithOptions(request, runtime);
}

model GetVisualServiceStatusRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-jeJki6****'),
}

model GetVisualServiceStatusResponseBody = {
  message?: string(name='Message', description='The response message.', example='inactive (dead) , ws service is not running.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='896D338C-E4F4-41EC-A154-D605E5DE****'),
}

model GetVisualServiceStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetVisualServiceStatusResponseBody(name='body'),
}

async function getVisualServiceStatusWithOptions(request: GetVisualServiceStatusRequest, runtime: Util.RuntimeOptions): GetVisualServiceStatusResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetVisualServiceStatus',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getVisualServiceStatus(request: GetVisualServiceStatusRequest): GetVisualServiceStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVisualServiceStatusWithOptions(request, runtime);
}

model InitializeEHPCRequest {
  regionId?: string(name='RegionId', description='The ID of the region where the service-linked role is created.

You can call the [ListRegions](~~188593~~) operation to obtain the IDs of regions supported by E-HPC.', example='cn-hangzhou'),
}

model InitializeEHPCResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model InitializeEHPCResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InitializeEHPCResponseBody(name='body'),
}

async function initializeEHPCWithOptions(request: InitializeEHPCRequest, runtime: Util.RuntimeOptions): InitializeEHPCResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InitializeEHPC',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function initializeEHPC(request: InitializeEHPCRequest): InitializeEHPCResponse {
  var runtime = new Util.RuntimeOptions{};
  return initializeEHPCWithOptions(request, runtime);
}

model InspectImageRequest {
  clusterId?: string(name='ClusterId', description='The ID of the E-HPC cluster where the image whose Inspect information you want to view resides.', example='ehpc-hz-ibug699***'),
  containerType?: string(name='ContainerType', description='The container type of the image. Set the value to singularity.', example='singularity'),
  imageName?: string(name='ImageName', description='The name of the image whose Inspect information you want to view.', example='test.sif'),
}

model InspectImageResponseBody = {
  imageStatus?: {
    imageInspectInfo?: {
      bootStrap?: string(name='BootStrap', description='The version of the bootstrapper used by the container image.', example='1.0'),
      buildArch?: string(name='BuildArch', description='The architecture used to build the image.', example='amd64'),
      buildDate?: string(name='BuildDate', description='The date on which the image was built.', example='Tuesday_9_November_2021_19'),
      containerVersion?: string(name='ContainerVersion', description='The container version of the image.', example='sccIntelMPI.sif'),
      defFrom?: string(name='DefFrom', description='The mode in which the image was built.', example='localimage'),
      schemaVersion?: string(name='SchemaVersion', description='The singularity version and kernel version of the image.', example='3.8.3-1.el7'),
    }(name='ImageInspectInfo', description='The list of Inspect information about the image.'),
  }(name='ImageStatus', description='The status of the image.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='896D338C-E4F4-41EC-A154-D605E5DE****'),
}

model InspectImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InspectImageResponseBody(name='body'),
}

async function inspectImageWithOptions(request: InspectImageRequest, runtime: Util.RuntimeOptions): InspectImageResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InspectImage',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function inspectImage(request: InspectImageRequest): InspectImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return inspectImageWithOptions(request, runtime);
}

model InstallSoftwareRequest {
  application?: string(name='Application', description='The name of the software that you want to install.

You can call the [ListSoftwares](~~87216~~) operation to query the software that can be installed.', example='ABYSS_2.1.5'),
  clusterId?: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-jeJki6****'),
}

model InstallSoftwareResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='896D338C-E4F4-41EC-A154-D605E5DE****'),
}

model InstallSoftwareResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InstallSoftwareResponseBody(name='body'),
}

async function installSoftwareWithOptions(request: InstallSoftwareRequest, runtime: Util.RuntimeOptions): InstallSoftwareResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InstallSoftware',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function installSoftware(request: InstallSoftwareRequest): InstallSoftwareResponse {
  var runtime = new Util.RuntimeOptions{};
  return installSoftwareWithOptions(request, runtime);
}

model InvokeShellCommandRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****'),
  command?: string(name='Command', description='The content of the command. The value must be 2 to 2,048 characters in length.', example='echo "hello world"'),
  instance?: [ 
    {
      id?: string(name='Id', description='The ID of the node on which the command is run.

>  The Instance.N.Id parameter specifies the node on which the command is run. If it is not specified, the command is run on all nodes of the cluster.', example='i-bp1in9hmw3ur52x0****'),
    }
  ](name='Instance'),
  timeout?: int32(name='Timeout', description='The timeout period. If a command times out, the command process is terminated. Unit: seconds.

Default value: 60', example='3600'),
  workingDir?: string(name='WorkingDir', description='The working directory of the command. Default value: /root.', example='/root'),
}

model InvokeShellCommandResponseBody = {
  commandId?: string(name='CommandId', description='The ID of the command. It is used to query the running status of the command.', example='c-hz01v8vudql****'),
  instanceIds?: {
    instanceId?: [ string ](name='InstanceId')
  }(name='InstanceIds', description='The list of IDs of the instances on which you want to run the command.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model InvokeShellCommandResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InvokeShellCommandResponseBody(name='body'),
}

async function invokeShellCommandWithOptions(request: InvokeShellCommandRequest, runtime: Util.RuntimeOptions): InvokeShellCommandResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InvokeShellCommand',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function invokeShellCommand(request: InvokeShellCommandRequest): InvokeShellCommandResponse {
  var runtime = new Util.RuntimeOptions{};
  return invokeShellCommandWithOptions(request, runtime);
}

model ListAvailableEcsTypesRequest {
  instanceChargeType?: string(name='InstanceChargeType', description='The billing method of the ECS instances. Valid values:

*   PostPaid: pay-as-you-go
*   PrePaid: subscription', example='PostPaid'),
  showSoldOut?: boolean(name='ShowSoldOut', description='Specifies whether the ECS instances are sold out. Valid values:

*   false: available
*   true: sold out

Default value: false', example='false'),
  spotStrategy?: string(name='SpotStrategy', description='The preemption policy of the ECS instances. Valid values:

*   NoSpot: The ECS instances are pay-as-you-go instances.
*   SpotWithPriceLimit: The ECS instances are preemptible instances that have a user-defined maximum hourly price.
*   SpotAsPriceGo: The ECS instances are preemptible instances for which the market price at the time of purchase is used as the bid price.', example='NoSpot'),
  zoneId?: string(name='ZoneId', description='The zone ID.', example='cn-hangzhou-b'),
}

model ListAvailableEcsTypesResponseBody = {
  instanceTypeFamilies?: {
    instanceTypeFamilyInfo?: [ 
    {
      generation?: string(name='Generation', description='The instance family.', example='ecs-3'),
      instanceTypeFamilyId?: string(name='InstanceTypeFamilyId', description='The ID of the instance family. For more information, see [Instance families](~~25378~~).', example='ecs.n4'),
      types?: {
        typesInfo?: [ 
        {
          cpuCoreCount?: int32(name='CpuCoreCount', description='The number of vCPUs.', example='4'),
          eniQuantity?: int32(name='EniQuantity', description='The maximum number of elastic network interfaces (ENIs) that can be bound to an ECS instance.', example='2'),
          GPUAmount?: int32(name='GPUAmount', description='The number of GPUs of an ECS instance.', example='2'),
          GPUSpec?: string(name='GPUSpec', description='The GPU type of the ECS instance.', example='NVIDIA V100'),
          instanceBandwidthRx?: int32(name='InstanceBandwidthRx', description='The maximum inbound internal bandwidth. Unit: Kbit/s.', example='10240000'),
          instanceBandwidthTx?: int32(name='InstanceBandwidthTx', description='The maximum outbound internal bandwidth. Unit: Kbit/s.', example='10240000'),
          instancePpsRx?: int32(name='InstancePpsRx', description='The inbound packet forwarding rate over the internal network. Unit: pps', example='9000000'),
          instancePpsTx?: int32(name='InstancePpsTx', description='The outbound packet forwarding rate over the internal network. Unit: pps', example='9000000'),
          instanceTypeId?: string(name='InstanceTypeId', description='The ID of the ECS instance type.', example='ecs.n4.xlarge'),
          memorySize?: int32(name='MemorySize', description='The memory size of the ECS instance. Unit: GiB', example='8'),
          status?: string(name='Status', description='The status of the ECS instance. Valid values:

*   SoldOut
*   Available', example='Available'),
          zoneIds?: {
            zoneId?: [ string ](name='ZoneId')
          }(name='ZoneIds', description='The list of zone IDs.'),
        }
      ](name='TypesInfo')
      }(name='Types', description='The list of instance types.'),
    }
  ](name='InstanceTypeFamilyInfo')
  }(name='InstanceTypeFamilies', description='The instance family to which the instance type belongs.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='D9DD3AF8-1F91-4075-8669-55D10E45****'),
  supportSpotInstance?: boolean(name='SupportSpotInstance', description='Specifies whether preemptible instances are supported. Valid values:

*   false: not supported
*   true: supported', example='false'),
}

model ListAvailableEcsTypesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAvailableEcsTypesResponseBody(name='body'),
}

async function listAvailableEcsTypesWithOptions(request: ListAvailableEcsTypesRequest, runtime: Util.RuntimeOptions): ListAvailableEcsTypesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAvailableEcsTypes',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAvailableEcsTypes(request: ListAvailableEcsTypesRequest): ListAvailableEcsTypesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAvailableEcsTypesWithOptions(request, runtime);
}

model ListCloudMetricProfilingsRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-FYUr32****'),
  pageNumber?: int32(name='PageNumber', description='The page number of the page to return.

Pages start from page 1.

Default value: 1', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 50

Default value: 10', example='10'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
}

model ListCloudMetricProfilingsResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries that are returned per page.', example='1'),
  profilings?: {
    profilingInfo?: [ 
    {
      duration?: int32(name='Duration', description='The duration of the profiling process. Unit: seconds

Valid values: 10 to 300', example='30'),
      freq?: int32(name='Freq', description='The frequency of the profiling process. Unit: Hz

Valid values: 1 to 2000', example='2000'),
      hostName?: string(name='HostName', description='The name of the host.', example='compute5'),
      instanceId?: string(name='InstanceId', description='The ID of the node.', example='i-bp1j76z8dlukzqgl0****'),
      pid?: int32(name='Pid', description='The ID of the profiling process.', example='21687'),
      profilingId?: string(name='ProfilingId', description='The ID of the profiling process.', example='ehpc-hz-i-bplukzqgl****_21687_2019-09-09-02-37-40'),
      triggerTime?: string(name='TriggerTime', description='The time when the profiling process is triggered.', example='2019-09-09 02:37:40'),
    }
  ](name='ProfilingInfo')
  }(name='Profilings', description='The profiling information of a specified cluster.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='9A05F620-ED46-4A57-95F1-C67D6D3C5DD2'),
  totalCount?: int32(name='TotalCount', description='The total number of entries.', example='1'),
}

model ListCloudMetricProfilingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListCloudMetricProfilingsResponseBody(name='body'),
}

async function listCloudMetricProfilingsWithOptions(request: ListCloudMetricProfilingsRequest, runtime: Util.RuntimeOptions): ListCloudMetricProfilingsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCloudMetricProfilings',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listCloudMetricProfilings(request: ListCloudMetricProfilingsRequest): ListCloudMetricProfilingsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCloudMetricProfilingsWithOptions(request, runtime);
}

model ListClusterLogsRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-FYUr32****'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 100

Default: 10', example='10'),
}

model ListClusterLogsResponseBody = {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-FYUr32****'),
  logs?: {
    logInfo?: [ 
    {
      createTime?: string(name='CreateTime', description='The time when the log was created.', example='2019-09-18T13:24:13.000'),
      level?: string(name='Level', description='The severity level of the log entry.', example='info'),
      message?: string(name='Message', description='The content of the log entry.', example='Begin to create cluster'),
      operation?: string(name='Operation', description='The name of the operation.', example='CreateCluster'),
    }
  ](name='LogInfo')
  }(name='Logs', description='The details about operations logs.'),
  pageNumber?: int32(name='PageNumber', description='The number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries that are returned per page.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='BBC2F93D-003A-49C4-850C-B826EECF6667'),
  totalCount?: int32(name='TotalCount', description='The total number of entries.', example='2'),
}

model ListClusterLogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListClusterLogsResponseBody(name='body'),
}

async function listClusterLogsWithOptions(request: ListClusterLogsRequest, runtime: Util.RuntimeOptions): ListClusterLogsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListClusterLogs',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listClusterLogs(request: ListClusterLogsRequest): ListClusterLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClusterLogsWithOptions(request, runtime);
}

model ListClustersRequest {
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 50.

Default value: 10', example='10'),
}

model ListClustersResponseBody = {
  clusters?: {
    clusterInfoSimple?: [ 
    {
      accountType?: string(name='AccountType', description='The server type of the account. Valid values:

*   nis
*   ldap', example='nis'),
      baseOsTag?: string(name='BaseOsTag', description='The operating system tag of the base image. The tag was used only by the management node.', example='CentOS_7.2_64'),
      clientVersion?: string(name='ClientVersion', description='The version of the client.', example='1.0.64'),
      computeSpotPriceLimit?: float(name='ComputeSpotPriceLimit', description='The maximum hourly price for the ECS instance under the compute node. The return value can be accurate to three decimal places.', example='0.034'),
      computeSpotStrategy?: string(name='ComputeSpotStrategy', description='The bidding method of the compute nodes. Valid values:

*   NoSpot: The instances of the compute node are pay-as-you-go instances.
*   SpotWithPriceLimit: The instances of the compute node are preemptible instances. These types of instances have a specified maximum hourly price.
*   SpotAsPriceGo: The instances of the compute node are preemptible instances. The price of these instances is based on the current market price.', example='NoSpot'),
      computes?: {
        exceptionCount?: int32(name='ExceptionCount', description='The number of abnormal nodes.', example='0'),
        normalCount?: int32(name='NormalCount', description='The number of normal nodes.', example='1'),
        operatingCount?: int32(name='OperatingCount', description='The number of nodes that are being used in the queue. This includes those that are being initialized, installed, or released.', example='1'),
        stoppedCount?: int32(name='StoppedCount', description='The number of stopped nodes.', example='0'),
        total?: int32(name='Total', description='The total number of nodes.', example='2'),
      }(name='Computes', description='The information about compute nodes.'),
      count?: int32(name='Count', description='The number of compute nodes in the cluster.', example='3'),
      createTime?: string(name='CreateTime', description='The time when the instance was created.', example='2020-10-30T07:39:20.000Z'),
      deployMode?: string(name='DeployMode', description='The mode in which the cluster was deployed. Valid values:

*   Standard: An account node, a scheduling node, a logon node, and multiple compute nodes are separately deployed.
*   Advanced: Two high availability (HA) account nodes, two HA scheduler nodes, one logon node, and multiple compute nodes are separately deployed.
*   Simple: A management node, a logon node, and multiple compute nodes are deployed. The management node consists of an account node and a scheduling node. The logon node and compute nodes are separately deployed.
*   Tiny: A management node and multiple compute nodes are deployed. The management node consists of an account node, a scheduling node, and a logon node. The compute nodes are separately deployed.', example='Standard'),
      description?: string(name='Description', description='The description of the cluster.', example='clusterdescription'),
      ehpcVersion?: string(name='EhpcVersion', description='The version of E-HPC.', example='1.0.0'),
      hasPlugin?: boolean(name='HasPlugin', description='Indicates whether plug-ins were used in the cluster. Valid values:

*   true: Plug-ins are used.
*   false: Plug-ins are not used.

Default value: false', example='false'),
      id?: string(name='Id', description='The ID of the cluster.', example='ehpc-hz-jeJki6****'),
      imageId?: string(name='ImageId', description='The ID of the image.', example='wi_1607_x64_dtc_zh_40G_alibase****'),
      imageOwnerAlias?: string(name='ImageOwnerAlias', description='The type of the image. Valid values:

*   system: public image
*   self: custom image
*   others: shared image
*   marketplace: Alibaba Cloud Marketplace image', example='system'),
      instanceChargeType?: string(name='InstanceChargeType', description='The billing method of the nodes in the cluster. Valid values:

*   PostPaid: pay-as-you-go
*   PrePaid: subscription', example='PostPaid'),
      instanceType?: string(name='InstanceType', description='The instance type of the compute nodes.', example='ecs.n1.tiny'),
      isComputeEss?: boolean(name='IsComputeEss', description='Indicates whether a scaling group was enabled. Valid values:

*   true: A scaling group is enabled.
*   false: No scaling group is enabled.', example='false'),
      location?: string(name='Location', description='The location where the cluster was deployed. Valid values:

*   OnPremise: The cluster is deployed on a hybrid cloud.
*   PublicCloud: The cluster is deployed on a public cloud.', example='PublicCloud'),
      loginNodes?: string(name='LoginNodes', description='The list of logon nodes.', example='{"Id": "i-bp13x4is8pvdhws7e****"}'),
      managers?: {
        exceptionCount?: int32(name='ExceptionCount', description='The number of abnormal nodes.', example='0'),
        normalCount?: int32(name='NormalCount', description='The number of normal nodes.', example='1'),
        operatingCount?: int32(name='OperatingCount', description='The number of nodes that are being used in the queue. This includes those that are being initialized, installed, or released.', example='1'),
        stoppedCount?: int32(name='StoppedCount', description='The number of stopped nodes.', example='0'),
        total?: int32(name='Total', description='The total number of management nodes.', example='2'),
      }(name='Managers', description='The list of management nodes.'),
      name?: string(name='Name', description='The name of the cluster.', example='test'),
      nodePrefix?: string(name='NodePrefix', description='The prefix of the node.', example='test'),
      nodeSuffix?: string(name='NodeSuffix', description='The suffix of the node.', example='name'),
      osTag?: string(name='OsTag', description='The operating system tag of the image.', example='CentOS_7.2_64'),
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
      schedulerType?: string(name='SchedulerType', description='The type of the scheduler. Valid values:

*   pbs
*   slurm
*   opengridscheduler
*   deadline', example='pbs'),
      status?: string(name='Status', description='The status of the cluster. Valid values:

*   uninit: The cluster is not initialized.
*   creating: The cluster is being created.
*   init: The cluster is being initialized.
*   running: The cluster is running.
*   exception: The cluster encounters an exception.
*   releasing: The cluster is being released.', example='running'),
      totalResources?: {
        cpu?: int32(name='Cpu', description='The number of CPU cores. Unit: cores.', example='1'),
        gpu?: int32(name='Gpu', description='The number of GPU cards. Unit: cards.', example='0'),
        memory?: int32(name='Memory', description='The memory size. Unit: MiB.', example='1024'),
      }(name='TotalResources', description='The statistics of all resources in the cluster.'),
      usedResources?: {
        cpu?: int32(name='Cpu', description='The number of CPU cores. Unit: cores.', example='1'),
        gpu?: int32(name='Gpu', description='The number of GPU cards. Unit: cards.', example='0'),
        memory?: int32(name='Memory', description='The memory size. Unit: MiB.', example='1024'),
      }(name='UsedResources', description='The number of consumed resources in the cluster.'),
      vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch.', example='vsw-bp1lfcjbfb099rrjn****'),
      vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC).', example='vpc-b3f3edefefeep0760yju****'),
      zoneId?: string(name='ZoneId', description='The ID of the zone.', example='cn-hangzhou-c'),
    }
  ](name='ClusterInfoSimple')
  }(name='Clusters', description='The list of clusters.'),
  pageNumber?: int32(name='PageNumber', description='The number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
  totalCount?: int32(name='TotalCount', description='The total number of returned entries.', example='1'),
}

model ListClustersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListClustersResponseBody(name='body'),
}

async function listClustersWithOptions(request: ListClustersRequest, runtime: Util.RuntimeOptions): ListClustersResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListClusters',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listClusters(request: ListClustersRequest): ListClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClustersWithOptions(request, runtime);
}

model ListClustersMetaRequest {
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 50.

Default value: 10', example='10'),
}

model ListClustersMetaResponseBody = {
  clusters?: {
    clusterInfoSimple?: [ 
    {
      accountType?: string(name='AccountType', description='The server type of the account. Valid values:

*   nis
*   ldap', example='nis'),
      clientVersion?: string(name='ClientVersion', description='The version of the client.', example='1.0.64'),
      deployMode?: string(name='DeployMode', description='The mode in which the cluster is deployed. Valid values:

*   Standard: An account node, a scheduling node, a logon node, and multiple compute nodes are separately deployed.
*   Advanced: Two high availability (HA) account nodes, two HA scheduler nodes, one logon node, and multiple compute nodes are separately deployed.
*   Simple: A management node, a logon node, and multiple compute nodes are deployed. The management node consists of an account node and a scheduling node. The logon node and compute nodes are separately deployed.
*   Tiny: A management node and multiple compute nodes are deployed. The management node consists of an account node, a scheduling node, and a logon node. The compute nodes are separately deployed.', example='Standard'),
      description?: string(name='Description', description='The description of the cluster.', example='clusterdescription'),
      hasPlugin?: boolean(name='HasPlugin', description='Indicates whether the cluster uses a plug-in. Valid values:

*   true
*   false

Default value: false', example='false'),
      id?: string(name='Id', description='The ID of the cluster.', example='ehpc-hz-jeJki6****'),
      isComputeEss?: boolean(name='IsComputeEss', description='Indicates whether a scaling group is enabled. Valid values:

*   true: A scaling group is enabled.
*   false: No scaling group is enabled.', example='false'),
      location?: string(name='Location', description='The location where the cluster is deployed. Valid values:

*   OnPremise: The cluster is deployed on a hybrid cloud.
*   PublicCloud: The cluster is deployed on a public cloud.', example='PublicCloud'),
      name?: string(name='Name', description='The name of the cluster.', example='cluster1'),
      osTag?: string(name='OsTag', description='The image tag of the operating system.', example='CentOS_7.2_64'),
      schedulerType?: string(name='SchedulerType', description='The type of the scheduler. Valid values:

*   pbs
*   slurm
*   opengridscheduler
*   deadline', example='pbs'),
      status?: string(name='Status', description='The status of the cluster. Valid values:

*   uninit: The cluster is not initialized.
*   creating: The cluster is being created.
*   init: The cluster is being initialized.
*   running: The cluster is running.
*   exception: The cluster encounters an exception.
*   releasing: The cluster is being released.', example='running'),
      vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC).', example='vpc-b3f3edefefeep0760yju****'),
    }
  ](name='ClusterInfoSimple')
  }(name='Clusters', description='The list of clusters.'),
  pageNumber?: int32(name='PageNumber', description='The number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page. Valid values: 1 to 50.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='DD517102-B314-4665-BDAC-A32DE7834D02'),
  totalCount?: int32(name='TotalCount', description='The total number of returned entries.', example='1'),
}

model ListClustersMetaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListClustersMetaResponseBody(name='body'),
}

async function listClustersMetaWithOptions(request: ListClustersMetaRequest, runtime: Util.RuntimeOptions): ListClustersMetaResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListClustersMeta',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listClustersMeta(request: ListClustersMetaRequest): ListClustersMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClustersMetaWithOptions(request, runtime);
}

model ListCommandsRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****'),
  commandId?: string(name='CommandId', description='The ID of the command.', example='c-hz01v8vudql****'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.

Page number starts from page 1.

Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.

Valid values: 1 to 50.

Default value: 10.', example='10'),
}

model ListCommandsResponseBody = {
  commands?: {
    command?: [ 
    {
      commandContent?: string(name='CommandContent', description='The content of the command.', example='echo "hello world"'),
      commandId?: string(name='CommandId', description='The ID of the command.', example='c-hz01v8vudql****'),
      timeout?: string(name='Timeout', description='The timeout period. Unit: seconds.', example='60'),
      workingDir?: string(name='WorkingDir', description='The working directory of the command.', example='/root'),
    }
  ](name='Command')
  }(name='Commands', description='The list of commands.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned on the current page.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  totalCount?: int32(name='TotalCount', description='The total number of returned entries.', example='1'),
}

model ListCommandsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListCommandsResponseBody(name='body'),
}

async function listCommandsWithOptions(request: ListCommandsRequest, runtime: Util.RuntimeOptions): ListCommandsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCommands',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listCommands(request: ListCommandsRequest): ListCommandsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCommandsWithOptions(request, runtime);
}

model ListCommunityImagesRequest {
  baseOsTag?: string(name='BaseOsTag', description='The tag of the base operating system (BOS).', example='CentOS_7.2_64'),
  clusterId?: string(name='ClusterId', description='The ID of the cluster. If the cluster supports multiple operating systems, all community images in the region where the cluster resides are queried.

If you do not specify the cluster ID, the community images that are supported by all clusters are queried.', example='ehpc-hz-FYUr32****'),
  instanceType?: string(name='InstanceType', description='The type of the Elastic Compute Service (ECS) instance. If you do not specify the instance type, the community images that are supported by all instance types are queried.', example='ecs.n1.tiny'),
}

model ListCommunityImagesResponseBody = {
  images?: {
    imageInfo?: [ 
    {
      baseOsTag?: {
        architecture?: string(name='Architecture', description='The architecture of the operating system. Valid values:

*   i386
*   x86\\_64', example='x86_64'),
        osTag?: string(name='OsTag', description='The tag of the OS image.', example='CentOS_7.2_64'),
        platform?: string(name='Platform', description='The distribution of the operating system. Valid values:

*   CentOS
*   Ubuntu
*   SUSE
*   OpenSUSE
*   Debian
*   CoreOS
*   Aliyun
*   Windows Server 2003
*   Windows Server 2008
*   Windows Server 2012
*   Others Linux
*   Customized Linux', example='CentOS'),
        version?: string(name='Version', description='The version of the operating system.', example='7.2'),
      }(name='BaseOsTag', description='The tag of the BOS image.'),
      description?: string(name='Description', description='The description of the image.', example='ExampleDescription'),
      imageId?: string(name='ImageId', description='The ID of the image.', example='m-bp181x855551ww5yq****'),
      imageName?: string(name='ImageName', description='The name of the image.', example='linux_CentOS7.2_OceanBase_OBD_1ECS-3OB_3.0'),
      imageOwnerAlias?: string(name='ImageOwnerAlias', description='The type of the image. Valid values:

*   self: custom image
*   others: shared image', example='self'),
      osTag?: {
        architecture?: string(name='Architecture', description='The architecture of the operating system. Valid values:

*   i386
*   x86\\_64', example='x86_64'),
        baseOsTag?: string(name='BaseOsTag', description='The tag of the BOS image.', example='CentOS_7.2_64'),
        osTag?: string(name='OsTag', description='The tag of the OS image.', example='CentOS_7.2_64'),
        platform?: string(name='Platform', description='The operating system.', example='CentOS'),
        version?: string(name='Version', description='The version of the operating system.', example='7.2'),
      }(name='OsTag', description='An array of OS images that are supported by E-HPC.'),
      postInstallScript?: string(name='PostInstallScript', description='The script that is run after the image is installed.', example='example.sh'),
      pricingCycle?: string(name='PricingCycle', description='The billing unit of the image. Valid values:

*   Hour
*   Month
*   Year', example='Month'),
      productCode?: string(name='ProductCode', description='The Alibaba Cloud Marketplace product code of the image.', example='cmjj028279'),
      size?: int32(name='Size', description='The size of the image. Unit: GiB.', example='40'),
      skuCode?: string(name='SkuCode', description='The stock keeping unit (SKU) of the image. Valid values:

*   ECS: pay-as-you-go
*   package: subscription', example='ECS'),
      status?: string(name='Status', description='The status of the image. Valid values:

*   UnAvailable: The image is unavailable.
*   Available: The image is available.
*   Creating: The image is being created.
*   CreateFailed: The image failed to be created.', example='Available'),
      uid?: string(name='Uid', description='The owner of the image.', example='127****'),
    }
  ](name='ImageInfo')
  }(name='Images', description='The list of community images, including custom images and shared images.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model ListCommunityImagesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListCommunityImagesResponseBody(name='body'),
}

async function listCommunityImagesWithOptions(request: ListCommunityImagesRequest, runtime: Util.RuntimeOptions): ListCommunityImagesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCommunityImages',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listCommunityImages(request: ListCommunityImagesRequest): ListCommunityImagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCommunityImagesWithOptions(request, runtime);
}

model ListContainerAppsRequest {
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.

Pages start from page 1.

Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 50.

Default value: 10.', example='10'),
}

model ListContainerAppsResponseBody = {
  containerApps?: {
    containerApps?: [ 
    {
      createTime?: string(name='CreateTime', description='The time when the containerized application was created.', example='2018-07-18T17:46:47'),
      description?: string(name='Description', description='The description of the containerized application.', example='ExampleDescription'),
      id?: string(name='Id', description='The ID of the containerized application.', example='ehpc-container-ABDUGSkjs****'),
      imageTag?: string(name='ImageTag', description='The tags of the image.', example='latest'),
      name?: string(name='Name', description='The name of the containerized application.', example='ExampleName'),
      repository?: string(name='Repository', description='The name of the repository.', example='busybox'),
      type?: string(name='Type', description='The type of the container. Set the value to singularity.', example='singularity'),
    }
  ](name='ContainerApps')
  }(name='ContainerApps', description='The array of containerized applications.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  totalCount?: int32(name='TotalCount', description='The total number of containerized applications.', example='1'),
}

model ListContainerAppsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListContainerAppsResponseBody(name='body'),
}

async function listContainerAppsWithOptions(request: ListContainerAppsRequest, runtime: Util.RuntimeOptions): ListContainerAppsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListContainerApps',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listContainerApps(request: ListContainerAppsRequest): ListContainerAppsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listContainerAppsWithOptions(request, runtime);
}

model ListContainerImagesRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****'),
  containerType?: string(name='ContainerType', description='The type of the container. Set the value to singularity.', example='singularity'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return.

Pages start from page 1.

Default value: 1', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 50.

Default value: 10', example='10'),
}

model ListContainerImagesResponseBody = {
  DBInfo?: string(name='DBInfo', description='The information of the database.', example='mongodb://localhost/'),
  images?: {
    images?: [ 
    {
      imageId?: string(name='ImageId', description='The ID of the image.', example='centos_7_06_64_20G_alibase_2019071****'),
      repository?: string(name='Repository', description='The name of the repository.', example='busybox'),
      status?: string(name='Status', description='The status of the image.', example='READY'),
      system?: string(name='System', description='The container system of the image.', example='mycluster'),
      tag?: string(name='Tag', description='The tags of the image.', example='latest'),
      type?: string(name='Type', description='The type of the container. Set the value to singularity.', example='docker'),
      updateDateTime?: string(name='UpdateDateTime', description='The time when the image was updated.', example='2018-08-02T20:11:36'),
    }
  ](name='Images')
  }(name='Images', description='The array of local images.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  totalCount?: int32(name='TotalCount', description='The total number of returned entries.', example='1'),
}

model ListContainerImagesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListContainerImagesResponseBody(name='body'),
}

async function listContainerImagesWithOptions(request: ListContainerImagesRequest, runtime: Util.RuntimeOptions): ListContainerImagesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListContainerImages',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listContainerImages(request: ListContainerImagesRequest): ListContainerImagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listContainerImagesWithOptions(request, runtime);
}

model ListCpfsFileSystemsRequest {
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

By default, the information about all CPFSs and their mount targets within your account are queried.', example='096751****'),
  pageNumber?: int32(name='PageNumber', description='The page number of the page to return.

Pages start from page 1.

Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 50.

Default value: 10.', example='10'),
}

model ListCpfsFileSystemsResponseBody = {
  fileSystemList?: {
    fileSystems?: [ 
    {
      capacity?: string(name='Capacity', description='The capacity of the file system. Unit: GiB.', example='5120'),
      createTime?: string(name='CreateTime', description='The time when the file system was created.', example='2018-07-26 16:36:27'),
      destription?: string(name='Destription', description='The description of the file system.', example='FilsDestription'),
      fileSystemId?: string(name='FileSystemId', description='The ID of the file system.', example='096751****'),
      mountTargetList?: {
        mountTargets?: [ 
        {
          mountTargetDomain?: string(name='MountTargetDomain', description='The domain where the mount target resides.', example='c0967****.cn-hangzhou.cpfs.nas.aliyuncs.com'),
          networkType?: string(name='NetworkType', description='The network type.', example='VPC'),
          status?: string(name='Status', description='The status of the mount target. Valid values:

*   Active: The mount target is available.
*   Inactive: The mount target is unavailable.
*   Pending: The mount target is being mounted.
*   Deleting: The mount target is being deleted.', example='Active'),
          vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC).', example='vpc-8vbvb34rtyh6xb3zrehs1****'),
          vswId?: string(name='VswId', description='The vSwitch ID of the instance.', example='vsw-8vb34rtyh6xb3zrehs1****'),
        }
      ](name='MountTargets')
      }(name='MountTargetList', description='The mount targets.'),
      protocolType?: string(name='ProtocolType', description='The protocol type that is applied to the mounted file system. Valid values:

*   NFS
*   SMB', example='NFS'),
      regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
      zoneId?: string(name='ZoneId', description='The zone ID.', example='cn-hangzhou-b'),
    }
  ](name='FileSystems')
  }(name='FileSystemList', description='The list of file systems.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned on the current page.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='2B900AFE-C938-4551-86E9-97E231BBC876'),
  totalCount?: int32(name='TotalCount', description='The total number of returned entries.', example='10'),
}

model ListCpfsFileSystemsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListCpfsFileSystemsResponseBody(name='body'),
}

async function listCpfsFileSystemsWithOptions(request: ListCpfsFileSystemsRequest, runtime: Util.RuntimeOptions): ListCpfsFileSystemsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCpfsFileSystems',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listCpfsFileSystems(request: ListCpfsFileSystemsRequest): ListCpfsFileSystemsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCpfsFileSystemsWithOptions(request, runtime);
}

model ListCurrentClientVersionResponseBody = {
  clientVersion?: string(name='ClientVersion', description='The latest version number of the E-HPC client.', example='1.1.1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model ListCurrentClientVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListCurrentClientVersionResponseBody(name='body'),
}

async function listCurrentClientVersionWithOptions(runtime: Util.RuntimeOptions): ListCurrentClientVersionResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'ListCurrentClientVersion',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listCurrentClientVersion(): ListCurrentClientVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCurrentClientVersionWithOptions(runtime);
}

model ListCustomImagesRequest {
  baseOsTag?: string(name='BaseOsTag', description='The image tag of the base operating system. The tag is used only by the management node.', example='CentOS_7.2_64'),
  clusterId?: string(name='ClusterId', description='The ID of the cluster where the application resides. If the cluster supports multiple operating systems, all the images in the region where the cluster resides are queried.

By default, if you do not specify the cluster ID, the images that are supported by all the clusters is queried.', example='ehpc-hz-FYUr32****'),
  imageOwnerAlias?: string(name='ImageOwnerAlias', description='The source of the image. Valid values:

*   self: custom image
*   others: shared image', example='self'),
  instanceType?: string(name='InstanceType', description='Specify the type of the instance. By default, if you do not specify the type of the instance, the list of images that are supported by all the instance types are queried.', example='ecs.n1.tiny'),
}

model ListCustomImagesResponseBody = {
  images?: {
    imageInfo?: [ 
    {
      baseOsTag?: {
        architecture?: string(name='Architecture', description='The architecture of the operating system. Valid values:

*   i386
*   x86\\_64', example='i386'),
        osTag?: string(name='OsTag', description='The image tag of the operating system.', example='CentOS_7.2_64'),
        platform?: string(name='Platform', description='The release version of the operating system. Valid values:

*   CentOS
*   Ubuntu
*   SUSE
*   OpenSUSE
*   Debian
*   CoreOS
*   Aliyun
*   Windows Server 2003
*   Windows Server 2008
*   Windows Server 2012
*   Others Linux
*   Customized Linux', example='CentOS'),
        version?: string(name='Version', description='The version number of the operating system.', example='7.2'),
      }(name='BaseOsTag', description='The image tag of the base operating system.'),
      description?: string(name='Description', description='The description of the image.', example='ExampleDescription'),
      imageId?: string(name='ImageId', description='The ID of the image.', example='m-bp181x855551ww5yq****'),
      imageName?: string(name='ImageName', description='The name of the image.', example='CHESS5V5.0.27'),
      imageOwnerAlias?: string(name='ImageOwnerAlias', description='The type of image. Valid values:

*   self: custom image
*   others: shared image', example='self'),
      osTag?: {
        architecture?: string(name='Architecture', description='The architecture of the operating system. Valid values:

*   i386
*   x86\\_64', example='x86_64'),
        baseOsTag?: string(name='BaseOsTag', description='The image tag of the base operating system.', example='CentOS_7.2_64'),
        osTag?: string(name='OsTag', description='The image tag of the operating system.', example='CentOS_7.2_64'),
        platform?: string(name='Platform', description='The platform of the operating system.', example='CentOS'),
        version?: string(name='Version', description='The version of the operating system.', example='7.2'),
      }(name='OsTag', description='An array of system images that are supported by E-HPC.'),
      postInstallScript?: string(name='PostInstallScript', description='The script that is run after the image is installed.', example='example.sh'),
      pricingCycle?: string(name='PricingCycle', description='The billing unit of the image. Valid values:

*   Hour
*   Month
*   Year', example='Month'),
      productCode?: string(name='ProductCode', description='The product code on Alibaba Cloud Marketplace.', example='cmjj028279'),
      size?: int32(name='Size', description='The size of the image. Unit: GiB', example='40'),
      skuCode?: string(name='SkuCode', description='The stock keeping unit (SKU) of the image. Valid values:

\\-ECS: pay-as-you-go

\\-package: subscription', example='ECS'),
      status?: string(name='Status', description='The status of the image. Valid values:

*   UnAvailable: The image is unavailable.
*   Available: The image is available.
*   Creating: The image is being created.
*   CreateFailed: The image has failed to be created.', example='Available'),
      uid?: string(name='Uid', description='The owner of the image.', example='127****'),
    }
  ](name='ImageInfo')
  }(name='Images', description='The list of custom images and shared images that are supported by the E-HPC.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model ListCustomImagesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListCustomImagesResponseBody(name='body'),
}

async function listCustomImagesWithOptions(request: ListCustomImagesRequest, runtime: Util.RuntimeOptions): ListCustomImagesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCustomImages',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listCustomImages(request: ListCustomImagesRequest): ListCustomImagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCustomImagesWithOptions(request, runtime);
}

model ListFileSystemWithMountTargetsRequest {
  pageNumber?: int32(name='PageNumber', description='The page number of the page to return.

Page numbers start from 1.

Default value: 1', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 50.

Default value: 10', example='10'),
}

model ListFileSystemWithMountTargetsResponseBody = {
  fileSystemList?: {
    fileSystems?: [ 
    {
      bandWidth?: int32(name='BandWidth', description='The bandwidth of the file system. Unit: MB/s.', example='150'),
      capacity?: int32(name='Capacity', description='The capacity of the file system. Unit: GiB.', example='5120'),
      createTime?: string(name='CreateTime', description='The time when the file system was created.', example='2018-07-26 16:36:27'),
      destription?: string(name='Destription', description='The description of the file system.', example='FilesDescription'),
      encryptType?: int32(name='EncryptType', description='Indicates whether the file system is encrypted. Valid values:

*   0: The file system is not encrypted.
*   1: The file system is encrypted.', example='0'),
      fileSystemId?: string(name='FileSystemId', description='The ID of the file system.', example='088b****'),
      fileSystemType?: string(name='FileSystemType', description='The type of the file system. Valid values:

*   standard: General-purpose NAS file system
*   extreme: Extreme NAS file system', example='standard'),
      meteredSize?: int32(name='MeteredSize', description='The used capacity of the file system. Unit: bytes.', example='1216816455'),
      mountTargetList?: {
        mountTargets?: [ 
        {
          accessGroup?: string(name='AccessGroup', description='The name of the permission group that applied to the mount target.', example='DEFAULT_VPC_GROUP_NAME'),
          mountTargetDomain?: string(name='MountTargetDomain', description='The domain name of the mount target.', example='088b****-lj2.cn-hangzhou.nas.aliyuncs.com'),
          networkType?: string(name='NetworkType', description='The network type of the mount target. Valid values:

*   Vpc: virtual private cloud (VPC)
*   Classic: the classic network', example='vpc'),
          status?: string(name='Status', description='The status of the mount target. Valid values:

*   Active: The mount target is available.
*   Inactive: The mount target is inactive.
*   Pending: The mount target is being created or modified.
*   Deleting: The mount target is being deleted.', example='Active'),
          vpcId?: string(name='VpcId', description='The ID of the VPC.', example='vpc-8vbvb34rtyh6xb3zrehs1****'),
          vswId?: string(name='VswId', description='The ID of the vSwitch.', example='vsw-8vb34rtyh6xb3zrehs1****'),
        }
      ](name='MountTargets')
      }(name='MountTargetList', description='The list of mount targets.'),
      packageList?: {
        packages?: [ 
        {
          packageId?: string(name='PackageId', description='The ID of the storage plan.', example='naspackage-0be9c4b624-37****'),
        }
      ](name='Packages')
      }(name='PackageList', description='The list of storage plans.'),
      protocolType?: string(name='ProtocolType', description='The protocol type of the file system. Valid values:

- NFS
- SMB', example='NFS'),
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
      status?: string(name='Status', description='The status of the file system. Valid values:

- Pending: The file system is being created or modified.
- Running: The file system is available.
- Stopped: The file system is stopped.
- Extending: The file system is being scaled out.
- Stopping: The file system is being stopped.
- Deleting: The file system is being deleted.', example='Running'),
      storageType?: string(name='StorageType', description='The storage type of the file system. 

- If FileSystemType is set to standard, the StorageType parameter has the following valid values: Capacity and Performance.
- If FileSystemType is set to extreme, the StorageType parameter has the following valid values: standard and advance.', example='Performance'),
      vpcId?: string(name='VpcId', example='vpc-bp132kgui8n0targbn1cm'),
    }
  ](name='FileSystems')
  }(name='FileSystemList', description='The list of file systems.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='25638B77-2F19-5DC5-B578-7790CE92052B'),
  totalCount?: int32(name='TotalCount', description='The total number of entries.', example='1'),
}

model ListFileSystemWithMountTargetsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListFileSystemWithMountTargetsResponseBody(name='body'),
}

async function listFileSystemWithMountTargetsWithOptions(request: ListFileSystemWithMountTargetsRequest, runtime: Util.RuntimeOptions): ListFileSystemWithMountTargetsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFileSystemWithMountTargets',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFileSystemWithMountTargets(request: ListFileSystemWithMountTargetsRequest): ListFileSystemWithMountTargetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFileSystemWithMountTargetsWithOptions(request, runtime);
}

model ListImagesRequest {
  baseOsTag?: string(name='BaseOsTag', description='The image tag of the operating system. The tag is used only for management nodes.', example='CentOS_7.2_64'),
  instanceType?: string(name='InstanceType', description='The instance type of the node.

*   If a value is passed to the parameter, the list of images that are supported by the specified instance type is queried.
*   If no value is passed to the parameter, the list of images that are supported by all instance types is queried.', example='ecs.n1.medium'),
}

model ListImagesResponseBody = {
  osTags?: {
    osInfo?: [ 
    {
      architecture?: string(name='Architecture', description='The architecture of the operating system. Valid values:

*   i386
*   x86\\_64', example='i386'),
      baseOsTag?: string(name='BaseOsTag', description='The image tag of the operating system. The tag is used only for management nodes.', example='CentOS_7.2_64'),
      imageId?: string(name='ImageId', description='The ID of the image.', example='m-bp1h8aoe73p71iow****'),
      OSName?: string(name='OSName'),
      OSNameEn?: string(name='OSNameEn'),
      osTag?: string(name='OsTag', description='The image tag of the cluster.', example='CentOS_7.2_64'),
      platform?: string(name='Platform', description='The operating system. Valid values:

*   CentOS
*   windows', example='CentOS'),
      version?: string(name='Version', description='The version of the operating system.', example='7.2'),
    }
  ](name='OsInfo')
  }(name='OsTags', description='The list of images that are supported by E-HPC.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model ListImagesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListImagesResponseBody(name='body'),
}

async function listImagesWithOptions(request: ListImagesRequest, runtime: Util.RuntimeOptions): ListImagesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListImages',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listImages(request: ListImagesRequest): ListImagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listImagesWithOptions(request, runtime);
}

model ListInstalledSoftwareRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****'),
}

model ListInstalledSoftwareResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='DDCA0E7B-03E7-430D-810C-0D508539****'),
  softwareList?: {
    softwareList?: [ 
    {
      softwareId?: string(name='SoftwareId', description='The ID of the software.', example='MPICH_3.2'),
      softwareName?: string(name='SoftwareName', description='The name of the software.', example='mpich'),
      softwareStatus?: string(name='SoftwareStatus', description='The status of the software. Valid values:

*   Installing: The software is being installed.
*   Installed: The software is installed.', example='Installing'),
      softwareVersion?: string(name='SoftwareVersion', description='The version of the software.', example='3.2'),
    }
  ](name='SoftwareList')
  }(name='SoftwareList', description='The list of installed software.'),
}

model ListInstalledSoftwareResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInstalledSoftwareResponseBody(name='body'),
}

async function listInstalledSoftwareWithOptions(request: ListInstalledSoftwareRequest, runtime: Util.RuntimeOptions): ListInstalledSoftwareResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInstalledSoftware',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listInstalledSoftware(request: ListInstalledSoftwareRequest): ListInstalledSoftwareResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInstalledSoftwareWithOptions(request, runtime);
}

model ListInvocationResultsRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****'),
  commandId?: string(name='CommandId', description='The ID of the command.

You can call the [ListCommands](~~87388~~) operation to query the command ID.', example='c-hz01v8x80o3****'),
  instance?: [ 
    {
      id?: string(name='Id', description='The ID of the node on which the command is run.

>  The Instance.N.Id parameter specifies the node on which the command is run. If it is not specified, the command is run on all nodes of the cluster.', example='i-uf65bh2113hlqvyr****'),
    }
  ](name='Instance'),
  invokeRecordStatus?: string(name='InvokeRecordStatus', description='The status of the command that you want to query. Valid values:

*   Finished
*   Running
*   Failed
*   Stopped', example='Finished'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return.

Page numbers start from 1.

Default value: 1', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 50.

Default value: 10', example='10'),
}

model ListInvocationResultsResponseBody = {
  invocationResults?: {
    invocationResult?: [ 
    {
      commandId?: string(name='CommandId', description='The ID of the command.', example='c-hz01v8x80o3****'),
      exitCode?: int32(name='ExitCode', description='The exit code.', example='0'),
      finishedTime?: string(name='FinishedTime', description='The time at which the command entered the Finished state.', example='2021-09-06T09:14:56Z'),
      instanceId?: string(name='InstanceId', description='The ID of the node on which the command was run.', example='i-uf65bh2113hlqvyr****'),
      invokeRecordStatus?: string(name='InvokeRecordStatus', description='The status of the command. Valid values:

*   Finished
*   Running
*   Failed
*   Stopped', example='Finished'),
      message?: string(name='Message', description='The output result.', example='hello world'),
      success?: boolean(name='Success', description='Indicates whether the command was run and its result was obtained.', example='true'),
    }
  ](name='InvocationResult')
  }(name='InvocationResults', description='The result of the command.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
  totalCount?: int32(name='TotalCount', description='The total number of returned entries.', example='1'),
}

model ListInvocationResultsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInvocationResultsResponseBody(name='body'),
}

async function listInvocationResultsWithOptions(request: ListInvocationResultsRequest, runtime: Util.RuntimeOptions): ListInvocationResultsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInvocationResults',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listInvocationResults(request: ListInvocationResultsRequest): ListInvocationResultsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInvocationResultsWithOptions(request, runtime);
}

model ListInvocationStatusRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****'),
  commandId?: string(name='CommandId', description='The ID of the command.

You can call the [ListCommands](~~87388~~) operation to query the command ID.', example='c-hz01v8x80o3****'),
}

model ListInvocationStatusResponseBody = {
  commandId?: string(name='CommandId', description='The ID of the command.', example='c-hz01v8x80o3****'),
  invokeInstances?: {
    invokeInstance?: [ 
    {
      instanceId?: string(name='InstanceId', description='The ID of the node.', example='i-uf6abz34m2714bp4****'),
      instanceInvokeStatus?: string(name='InstanceInvokeStatus', description='The status of the node. Valid values:

*   Finished
*   Running
*   Failed
*   Stopped', example='Finished'),
    }
  ](name='InvokeInstance')
  }(name='InvokeInstances', description='The list of statuses. A list is returned for each node.'),
  invokeStatus?: string(name='InvokeStatus', description='The overall status of all nodes in the cluster. Valid values:

- Finished
- Running
- Failed
- Stopped', example='Finished'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model ListInvocationStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInvocationStatusResponseBody(name='body'),
}

async function listInvocationStatusWithOptions(request: ListInvocationStatusRequest, runtime: Util.RuntimeOptions): ListInvocationStatusResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInvocationStatus',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listInvocationStatus(request: ListInvocationStatusRequest): ListInvocationStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInvocationStatusWithOptions(request, runtime);
}

model ListJobTemplatesRequest {
  name?: string(name='Name', description='The name of the job template.

You can call the [ListJobTemplates](~~87248~~) operation to obtain the job template name.', example='jobtemplateName'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Page numbers start from 1.

Default value: 1', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Maximum value: 50.

Default value: 10', example='10'),
}

model ListJobTemplatesResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  templates?: {
    jobTemplates?: [ 
    {
      arrayRequest?: string(name='ArrayRequest', description='The job array.

Format: X-Y:Z. X is the minimum index value. Y is the maximum index value. Z is the step size. For example, 2-7:2 indicates that three jobs need to be run and their index values are 2, 4, and 6.', example='2-7:2'),
      clockTime?: string(name='ClockTime', description='The maximum running time of the job. Valid formats:

*   hh:mm:ss
*   mm:ss
*   ss', example='12:00:00'),
      commandLine?: string(name='CommandLine', description='The command that was used to run the job.', example='./LammpsTest/lammps.pbs'),
      gpu?: int32(name='Gpu', description='The maximum GPU usage required by a single compute node. Valid values: 1 to 8.

The parameter takes effect only when the cluster uses PBS and a compute node is a GPU-accelerated instance.', example='1'),
      id?: string(name='Id', description='The ID of the job template.', example='ehpc-job-tmpl-6RxO5y****'),
      inputFileUrl?: string(name='InputFileUrl', description='The URL of the job files that were uploaded to an Object Storage Service (OSS) bucket.', example='https://test.oss-cn-beijing.aliyuncs.com/test.py'),
      mem?: string(name='Mem', description='The maximum memory usage of a single compute node. The unit can be GB, MB, or KB, and is case-insensitive.', example='1GB'),
      name?: string(name='Name', description='The name of the job template.', example='job1'),
      node?: int32(name='Node', description='The number of the compute nodes. Valid values: 1 to 500.', example='2'),
      packagePath?: string(name='PackagePath', description='The path that was used to run the job.', example='./jobfolder'),
      priority?: int32(name='Priority', description='The priority of the job. Valid values: 0 to 9. A large value indicates a high priority.', example='0'),
      queue?: string(name='Queue', description='The queue of the job.', example='workq'),
      reRunable?: boolean(name='ReRunable', description='Indicates whether the job can be rerun. Valid values:

*   true: The job can be rerun.
*   false: The job cannot be rerun.', example='false'),
      runasUser?: string(name='RunasUser', description='The name of the user that ran the job.', example='user1'),
      stderrRedirectPath?: string(name='StderrRedirectPath', description='The output file path of stderr.', example='./LammpsTest'),
      stdoutRedirectPath?: string(name='StdoutRedirectPath', description='The output file path of stdout.', example='./Lammps'),
      task?: int32(name='Task', description='The number of tasks required by a single compute node. Valid values: 1 to 1000.', example='2'),
      thread?: int32(name='Thread', description='The number of threads required by a single compute node. Valid values: 1 to 1000.', example='1'),
      unzipCmd?: string(name='UnzipCmd', description='The command that was used to decompress the job files downloaded from an OSS bucket. The parameter takes effect only when WithUnzipCmd is set to true. Valid values:

*   tar xzf: decompresses GZIP files.
*   tar xf: decompresses TAR files.
*   unzip: decompresses ZIP files.', example='tar xzf'),
      variables?: string(name='Variables', description='The environment variables of the job.', example='[{Name:,Value:},{Name:,Value:}]'),
      withUnzipCmd?: boolean(name='WithUnzipCmd', description='Indicates whether to decompress the job files downloaded from an OSS bucket. Valid values:

*   true: The job files are decompressed.
*   false: The job files are not decompressed.', example='true'),
    }
  ](name='JobTemplates')
  }(name='Templates', description='The list of job templates.'),
  totalCount?: int32(name='TotalCount', description='The total number of returned entries.', example='1'),
}

model ListJobTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListJobTemplatesResponseBody(name='body'),
}

async function listJobTemplatesWithOptions(request: ListJobTemplatesRequest, runtime: Util.RuntimeOptions): ListJobTemplatesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListJobTemplates',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listJobTemplates(request: ListJobTemplatesRequest): ListJobTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listJobTemplatesWithOptions(request, runtime);
}

model ListJobsRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****'),
  owner?: string(name='Owner', description='The name of the user that runs the job.

You can call the [ListUsers](~~188572~~) operation to query the users in the cluster.', example='user1'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return.

Pages start from page 1.

Default value: 1', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Maximum value: 50.

Default value: 10', example='10'),
  rerunable?: string(name='Rerunable', description='Specifies whether the job can be rerun. Valid values:

*   true
*   false

Default value: false', example='false'),
  state?: string(name='State', description='The status of the job. Valid values:

*   all
*   finished
*   notfinish', example='finished'),
}

model ListJobsResponseBody = {
  jobs?: {
    jobInfo?: [ 
    {
      arrayRequest?: string(name='ArrayRequest', description='The job array. If the job is not in a queue, the output is empty.

Format: X-Y:Z. X is the minimum index value. Y is the maximum index value. Z is the step size. For example, 2-7:2 indicates that three jobs need to be run and their index values are 2, 4, and 6.', example='1-10:2'),
      comment?: string(name='Comment', description='The description of the job.', example='jobDescription'),
      id?: string(name='Id', description='The ID of the job.', example='0.manager'),
      lastModifyTime?: string(name='LastModifyTime', description='The time when the job was last modified.', example='2018-07-18T17:46:48'),
      name?: string(name='Name', description='The name of the job.', example='job1'),
      nodeList?: string(name='NodeList', description='The list of compute nodes that were used to run the job.', example='[\\"compute2\\", \\"compute3\\"]'),
      owner?: string(name='Owner', description='The name of the user that runs the job.', example='user1'),
      priority?: string(name='Priority', description='The priority of the job. Valid values: 0 to 9. A large value indicates a high priority.', example='0'),
      resources?: {
        cores?: int32(name='Cores', description='The number of CPUs that were used to run the job.', example='2'),
        nodes?: int32(name='Nodes', description='The number of nodes that were used to run the job.', example='0'),
      }(name='Resources', description='The resources that were used to run the job.'),
      shellPath?: string(name='ShellPath', description='The path that was used to run the job.', example='./Temp'),
      startTime?: string(name='StartTime', description='The time when the job started to run.', example='2018-07-18T17:46:48'),
      state?: string(name='State', description='The status of the job. Valid values: Valid values:

*   FINISHED: The job is completed
*   RUNNING: The job is running.
*   QUEUED: The job is pending in a queue.', example='FINISHED'),
      stderr?: string(name='Stderr', description='The output file path of stderr.', example='./Temp'),
      stdout?: string(name='Stdout', description='The output file path of stdout.', example='./Temp'),
      submitTime?: string(name='SubmitTime', description='The time when the job was submitted.', example='2018-07-18T17:46:47'),
    }
  ](name='JobInfo')
  }(name='Jobs', description='The list of jobs.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  totalCount?: int32(name='TotalCount', description='The total number of returned entries.', example='1'),
}

model ListJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListJobsResponseBody(name='body'),
}

async function listJobsWithOptions(request: ListJobsRequest, runtime: Util.RuntimeOptions): ListJobsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListJobs',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listJobs(request: ListJobsRequest): ListJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listJobsWithOptions(request, runtime);
}

model ListJobsWithFiltersRequest {
  async?: boolean(name='Async', description='Specifies whether to enable asynchronous query.', example='false'),
  clusterId?: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****'),
  createTimeEnd?: string(name='CreateTimeEnd', description='The latest time when a job is submitted. The value is a UNIX timestamp, which represents the number of seconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.', example='1647428667'),
  createTimeStart?: string(name='CreateTimeStart', description='The earliest time when a job is submitted. The value is a UNIX timestamp, which represents the number of seconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.', example='1647427667'),
  executeOrder?: string(name='ExecuteOrder', description='The order in which jobs are sorted based on the execution time. Valid values:

*   asc: ascending order
*   desc: descending order', example='asc'),
  jobName?: string(name='JobName', description='The name of the job. Fuzzy match is supported.', example='job1'),
  jobStatus?: string(name='JobStatus', description='The status of the job. Valid values:

*   all
*   finished
*   notfinish

Default value: all', example='finished'),
  nodes?: [ string ](name='Nodes'),
  pageNumber?: long(name='PageNumber', description='The number of the page to return.

Pages start from page 1.

Default value: 1', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries to return on each page. Maximum value: 50.

Default value: 10', example='10'),
  pendOrder?: string(name='PendOrder', description='The order in which jobs are sorted based on the time when they queue. Valid values:

*   asc: ascending order
*   desc: descending order', example='desc'),
  queues?: [ string ](name='Queues'),
  regionId?: string(name='RegionId', description='The ID of the region.

You can call the [ListRegions](~~188593~~) operation to query the list of regions where E-HPC is supported.', example='cn-hangzhou'),
  submitOrder?: string(name='SubmitOrder', description='The order in which jobs are sorted based on the time when they are submitted. Valid values:

*   asc: ascending order
*   desc: descending order', example='asc'),
  users?: [ string ](name='Users'),
}

model ListJobsWithFiltersResponseBody = {
  jobs?: [ 
    {
      arrayRequest?: string(name='ArrayRequest', description='The job array. If the job is not in a queue, the output is empty.

Format: X-Y:Z. X is the minimum index value. Y is the maximum index value. Z is the step size. For example, 2-7:2 indicates that three jobs need to be run and their index values are 2, 4, and 6.', example='1-10:2'),
      comment?: string(name='Comment', description='The description of the job.', example='jobDescription'),
      id?: string(name='Id', description='The ID of the job.', example='8.scheduler'),
      lastModifyTime?: string(name='LastModifyTime', description='The time when the job was last modified.', example='1647428667'),
      name?: string(name='Name', description='The name of the job.', example='job1'),
      nodeList?: string(name='NodeList', description='The list of compute nodes that were used to run the job.', example='[\\"compute2\\", \\"compute3\\"]'),
      owner?: string(name='Owner', description='The name of the user that ran the job.', example='test2@scheduler'),
      priority?: string(name='Priority', description='The priority of the job. Valid values: 0 to 9. A large value indicates a high priority.', example='0'),
      queue?: string(name='Queue', description='The number of queues that ran the job.', example='2'),
      rerunable?: boolean(name='Rerunable', description='Indicates whether the job can be run again. Valid values:

*   true
*   false', example='true'),
      resources?: {
        cores?: long(name='Cores', description='The number of CPUs that were used to run the job.', example='2'),
        nodes?: long(name='Nodes', description='The number of nodes that were used to run the job.', example='0'),
      }(name='Resources', description='The resources that were used to run the job.'),
      shellPath?: string(name='ShellPath', description='The path that was used to run the job.', example='./Temp'),
      startTime?: string(name='StartTime', description='The time when the job started to run.', example='1647427667'),
      state?: string(name='State', description='The status of the job. Valid values:

*   FINISHED: The job is completed.
*   RUNNING: The job connector is running.
*   QUEUED: The job is pending in a queue.', example='FINISHED'),
      stderr?: string(name='Stderr', description='The output file path of stderr.', example='./Temp'),
      stdout?: string(name='Stdout', description='The output file path of stdout.', example='./Temp'),
      submitTime?: string(name='SubmitTime', description='The time when the job was submitted.', example='1647423718'),
      variableList?: string(name='VariableList', description='The list of variables of the job.', example='{"PBS_O_SHELL":"/bin/bash", 	"PBS_O_HOST":"manager", 	"PBS_O_SYSTEM":"Linux", 	"PBS_O_LANG":"en_US.UTF-8", 	"PBS_O_QUEUE":"workq"}'),
    }
  ](name='Jobs', description='The list of jobs.'),
  pageNumber?: long(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries returned per page.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true: The call was successful.
*   false: The request failed.', example='true'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='1'),
}

model ListJobsWithFiltersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListJobsWithFiltersResponseBody(name='body'),
}

async function listJobsWithFiltersWithOptions(request: ListJobsWithFiltersRequest, runtime: Util.RuntimeOptions): ListJobsWithFiltersResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListJobsWithFilters',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listJobsWithFilters(request: ListJobsWithFiltersRequest): ListJobsWithFiltersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listJobsWithFiltersWithOptions(request, runtime);
}

model ListNodesRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****'),
  filter?: string(name='Filter', description='The filter options of the node list.

Format: {"status":"node_status"}. Replace node_status with the node status. Valid values of node_status:

*   uninit: The node is being installed.
*   exception: An exception has occurred on the node.
*   running: The node is running.
*   initing: The node is being initialized.
*   releasing: The node is being released.
*   untracking: The node is not added to the cluster.
*   stopped: The node is stopped.', example='{"status":"running"}'),
  hostName?: string(name='HostName', description='The name of the node. You can perform a fuzzy search. MySQL regular expressions are supported.', example='test-HostName'),
  hostNamePrefix?: string(name='HostNamePrefix', description='The prefix of the hostname. You can query nodes that have a specified prefix.', example='compute'),
  hostNameSuffix?: string(name='HostNameSuffix', description='The suffix of the hostname. You can query nodes that have a specified suffix.', example='01'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 100.

Default value: 10', example='10'),
  privateIpAddress?: string(name='PrivateIpAddress', description='The private IP address of the node.', example='172.16.**.**'),
  role?: string(name='Role', description='The type of the node. Valid values:

*   Manager: management node
*   Login: logon node
*   Compute: compute node', example='Manager'),
  sequence?: string(name='Sequence', description='The sorting method of the node list. Valid values:

*   Forward: sorts the nodes in chronological order.
*   Backward: sorts the nodes in reverse chronological order.

Default value: Forward

>  Sequence is used in combination with SortBy. If SortBy is set to AddedTime and Sequence is set to Forward, nodes are sorted by the time that they were added in chronological order.', example='Forward'),
  sortBy?: string(name='SortBy', description='The sorting method of the node list. Valid values:

*   AddedTime: sorts the nodes by the time that they were added.
*   HostName: sorts the nodes by their host names.', example='AddedTime'),
}

model ListNodesResponseBody = {
  nodes?: {
    nodeInfo?: [ 
    {
      addTime?: string(name='AddTime', description='The time when the node was added to the cluster.', example='2020-06-09T06:22:02.000Z'),
      createMode?: string(name='CreateMode', description='The mode in which the compute nodes are added. Valid values:

*   manual: The compute nodes are manually added.
*   autoscale: The compute nodes are automatically added.', example='manual'),
      createdByEhpc?: boolean(name='CreatedByEhpc', description='Indicates whether the node was created by using E-HPC.

*   true: The node is created by using E-HPC.
*   false: The node is not created by using E-HPC.', example='true'),
      expired?: boolean(name='Expired', description='Indicates whether the subscription node expired. For a pay-as-you-go node, false is returned.', example='false'),
      expiredTime?: string(name='ExpiredTime', description='The time when the subscription node expires. For a pay-as-you-go node, a null value is returned.', example='2020-06-09T06:22:02.000Z'),
      hostName?: string(name='HostName', description='The name of the node.', example='test-HostName'),
      htEnabled?: boolean(name='HtEnabled', description='Indicates whether hyper-threading is enabled.', example='true'),
      id?: string(name='Id', description='The ID of the node.', example='i-bp15707mys2rsy0j****'),
      imageId?: string(name='ImageId', description='The ID of the image.', example='centos_7_06_64_20G_alibase_20190711.vhd'),
      imageOwnerAlias?: string(name='ImageOwnerAlias', description='The type of the image. Valid values:

*   system: public image
*   self: custom image
*   others: shared image
*   marketplace: Alibaba Cloud Marketplace image', example='system'),
      instanceType?: string(name='InstanceType', description='The instance types of the node.', example='ecs.c5.large'),
      ipAddress?: string(name='IpAddress', description='The IP address of the node.', example='172.16.**.**'),
      location?: string(name='Location', description='The location where the node was deployed. Valid values:

*   OnPremise: The node is deployed on your data center.
*   PublicCloud: The node is deployed on the public cloud.', example='PublicCloud'),
      lockReason?: string(name='LockReason', description='The reason why the node was locked. Valid values:

*   financial: The node is locked due to overdue payments.
*   security: The node is locked for security reasons.
*   recycling: The preemptible node is locked and pending release.
*   dedicatedhostfinancial: The node is locked due to the overdue payments of the dedicated host.

By default, an empty string is returned.', example='financial'),
      publicIpAddress?: string(name='PublicIpAddress', description='The public IP address of the node.', example='172.16.**.**'),
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
      roles?: {
        role?: [ string ](name='Role')
      }(name='Roles', description='The type of the node. Valid values:

*   Scheduler: primary scheduling node
*   SchedulerBackup: secondary scheduling node
*   Account: primary domain server node
*   AccountBackup: secondary domain server node
*   Login: logon node
*   Compute: compute node

Scheduling nodes and domain server nodes are management nodes.'),
      spotStrategy?: string(name='SpotStrategy', description='The bidding method of the compute nodes.', example='NoSpot'),
      stateInSched?: string(name='StateInSched', description='The status of the node displayed on the scheduler. The status varies with the scheduler.', example='active'),
      status?: string(name='Status', description='The status of the node. Valid values:

*   uninit: The node is being installed.
*   exception: An exception has occurred on the node.
*   running: The node is running.
*   initing: The node is being initialized.
*   releasing: The node is being released.
*   untracking: The node is not added to the cluster.
*   stopped: The node is stopped.', example='running'),
      totalResources?: {
        cpu?: int32(name='Cpu', description='The number of vCPUs.', example='1'),
        gpu?: int32(name='Gpu', description='The number of GPUs.', example='0'),
        memory?: int32(name='Memory', description='The memory capacity. Unit: GB', example='1024'),
      }(name='TotalResources', description='The statistics of the resources used by the node.'),
      usedResources?: {
        cpu?: int32(name='Cpu', description='The number of vCPUs.', example='0'),
        gpu?: int32(name='Gpu', description='The number of GPUs.', example='0'),
        memory?: int32(name='Memory', description='The memory capacity. Unit: GB', example='0'),
      }(name='UsedResources', description='The usage of the compute nodes in the cluster. For other types of nodes, an empty value is returned.'),
      vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch.', example='vsw-bp1e47optm9g58zcu****'),
      version?: string(name='Version', description='The version of the client.', example='1.0.78'),
      vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC).', example='vpc-bp1gnu8br4ay7beb2w****'),
      zoneId?: string(name='ZoneId', description='The ID of the zone.', example='cn-hangzhou-b'),
    }
  ](name='NodeInfo')
  }(name='Nodes', description='The information about nodes.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='89A1AC0F-4A6C-4F3D-98F9-BEF9A823****'),
  totalCount?: int32(name='TotalCount', description='The total number of returned entries.', example='1'),
}

model ListNodesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListNodesResponseBody(name='body'),
}

async function listNodesWithOptions(request: ListNodesRequest, runtime: Util.RuntimeOptions): ListNodesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListNodes',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listNodes(request: ListNodesRequest): ListNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNodesWithOptions(request, runtime);
}

model ListNodesByQueueRequest {
  async?: boolean(name='Async', example='false'),
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-FYUr32****'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 50.

Default value: 10', example='10'),
  queueName?: string(name='QueueName', description='The name of the queue.', example='workq'),
}

model ListNodesByQueueResponseBody = {
  nodes?: {
    nodeInfo?: [ 
    {
      addTime?: string(name='AddTime', description='The time when the node was added to the cluster.', example='2019-09-18T13:24:29.000Z'),
      createMode?: string(name='CreateMode', description='The mode in which the node was added. Valid values:

*   manual: The node was manually added.
*   autoscale: The node is automatically added.', example='manual'),
      createdByEhpc?: boolean(name='CreatedByEhpc', description='Indicates whether the node was created by using E-HPC.', example='true'),
      expired?: boolean(name='Expired', description='Indicates whether the subscription node has expired. If the node is a pay-as-you-go node, false is returned.', example='false'),
      expiredTime?: string(name='ExpiredTime', description='The time when the subscription instance expires. If the node is a pay-as-you-go node, a null value is returned.', example='2020-09-18T13:24:29.000Z'),
      hostName?: string(name='HostName', description='The name of the node.', example='compute0'),
      htEnabled?: boolean(name='HtEnabled', description='Indicates whether Hyper-Threading (HT) is enabled.', example='true'),
      id?: string(name='Id', description='The ID of the ECS instance.', example='i-bp13p7vlcb1uihfv****'),
      imageId?: string(name='ImageId', description='The ID of the image.', example='centos_7_02_64_20G_alibase_20170818****'),
      imageOwnerAlias?: string(name='ImageOwnerAlias', description='The type of the image. Valid values:

*   system: public image
*   self: custom image
*   others: shared image
*   marketplace: Alibaba Cloud Marketplace image', example='system'),
      ipAddress?: string(name='IpAddress', description='The private IP address of the node.', example='172.168.**.**'),
      location?: string(name='Location', description='The location where the node is deployed. Valid values:

*   OnPremise: The node is deployed on a hybrid cloud.
*   PublicCloud: The node is deployed on a public cloud.', example='PublicCloud'),
      lockReason?: string(name='LockReason', description='The reason why the node is locked. Valid values:

*   financial: The node is locked due to overdue payments.
*   security: The node is locked due to security reasons.
*   recycling: The preemptible node is locked and pending release.
*   dedicatedhostfinancial: The node is locked due to the overdue payments of the dedicated host.

By default, an empty string is returned.', example='financial'),
      publicIpAddress?: string(name='PublicIpAddress', description='The public IP address of the node.', example='10.34.**.**'),
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
      spotStrategy?: string(name='SpotStrategy', description='The preemption policy for the Elastic Compute Service (ECS) instance. Valid values:

*   NoSpot: applies to regular pay-as-you-go instances.
*   SpotWithPriceLimit: The instances of the compute node are preemptible instances. These types of instances have a specified maximum hourly price.
*   SpotAsPriceGo: The instances of the compute node are preemptible instances. The price of these instances is based on the current market price.', example='NoSpot'),
      stateInSched?: string(name='StateInSched', description='The status of the node displayed on the scheduler. The status varies with the scheduler.', example='active'),
      status?: string(name='Status', description='The status of the node. Valid values:

*   uninit: The node is not initialized.
*   init: The node is being initialized.
*   ready: The node is ready.
*   running: The node is running.
*   exception: An exception has occurred on the node.
*   untracking: The node is not added to the cluster.', example='untracking'),
      totalResources?: {
        cpu?: int32(name='Cpu', description='The number of CPU cores. Unit: cores.', example='1'),
        gpu?: int32(name='Gpu', description='The total number of GPU cards. Unit: cards.', example='0'),
        memory?: int32(name='Memory', description='The memory capacity. Unit: GB.', example='1024'),
      }(name='TotalResources', description='The number of all resources in the cluster.'),
      usedResources?: {
        cpu?: int32(name='Cpu', description='The number of CPU cores. Unit: cores.', example='1'),
        gpu?: int32(name='Gpu', description='The total number of GPU cards. Unit: cards.', example='0'),
        memory?: int32(name='Memory', description='The memory capacity. Unit: GB.', example='1'),
      }(name='UsedResources', description='The usage of the compute nodes in the cluster. For other types of nodes, an empty value is returned.'),
      vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch.', example='vsw-bp1e47optm9g58zcu****'),
      version?: string(name='Version', description='The version of the E-HPC client.', example='1.0.64'),
      vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC).', example='vpc-bp1gnu8br4ay7beb2w****'),
      zoneId?: string(name='ZoneId', description='The ID of the zone.', example='cn-hangzhou-b'),
    }
  ](name='NodeInfo')
  }(name='Nodes', description='The list of nodes.'),
  pageNumber?: int32(name='PageNumber', description='The number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='B405FF19-2D5F-4489-A84C-BC15CC1B24BD'),
  totalCount?: int32(name='TotalCount', description='The total number of returned entries.', example='1'),
}

model ListNodesByQueueResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListNodesByQueueResponseBody(name='body'),
}

async function listNodesByQueueWithOptions(request: ListNodesByQueueRequest, runtime: Util.RuntimeOptions): ListNodesByQueueResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListNodesByQueue',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listNodesByQueue(request: ListNodesByQueueRequest): ListNodesByQueueResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNodesByQueueWithOptions(request, runtime);
}

model ListNodesNoPagingRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****'),
  hostName?: string(name='HostName', description='The name of the node. You can perform a fuzzy search. MySQL regular expressions are supported.', example='Compute0'),
  role?: string(name='Role', description='The type of the node. Valid values:

*   Manager: management node
*   Login: logon node
*   Compute: compute node

Default value: Compute', example='Compute'),
  sequence?: string(name='Sequence', description='The sorting method of the node list. Valid values:

*   Forward: sorts the nodes in chronological order.
*   Backward: sorts the nodes in reverse chronological order.

Default value: Forward', example='Forward'),
}

model ListNodesNoPagingResponseBody = {
  nodes?: {
    nodeInfo?: [ 
    {
      hostName?: string(name='HostName', description='The name of the node.', example='compute0'),
      id?: string(name='Id', description='The ID of the node.', example='i-bp13p7vlcb1uihfv****'),
      imageId?: string(name='ImageId', description='The ID of the image.', example='centos_7_02_64_20G_alibase_20170818****'),
      instanceType?: string(name='InstanceType', description='The instance type of the node.', example='ecs.n1.tiny'),
      status?: string(name='Status', description='The status of the node. Valid values:

*   uninit: The node is being installed.
*   exception: An exception has occurred on the node.
*   running: The node is running.
*   initing: The node is being initialized.
*   releasing: The node is being released.
*   untracking: The node is not added to the cluster.
*   stopped: The node is stopped.', example='untracking'),
    }
  ](name='NodeInfo')
  }(name='Nodes', description='The information about nodes.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model ListNodesNoPagingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListNodesNoPagingResponseBody(name='body'),
}

async function listNodesNoPagingWithOptions(request: ListNodesNoPagingRequest, runtime: Util.RuntimeOptions): ListNodesNoPagingResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListNodesNoPaging',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listNodesNoPaging(request: ListNodesNoPagingRequest): ListNodesNoPagingResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNodesNoPagingWithOptions(request, runtime);
}

model ListPreferredEcsTypesRequest {
  instanceChargeType?: string(name='InstanceChargeType', description='The billing method of the ECS instance. Valid values:

*   PostPaid: pay-as-you-go
*   PrePaid: subscription', example='PostPaid'),
  spotStrategy?: string(name='SpotStrategy', description='The bidding policy of the ECS instance. Valid values:

*   NoSpot: The instance is created as a regular pay-as-you-go instance.
*   SpotWithPriceLimit: The instance to be created is a preemptible instance with a user-defined maximum hourly price.
*   SpotAsPriceGo: The instance is a preemptible instance whose price is based on the current market price.', example='NoSpot'),
  zoneId?: string(name='ZoneId', description='The ID of the zone.', example='cn-hangzhou-b'),
}

model ListPreferredEcsTypesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
  series?: {
    seriesInfo?: [ 
    {
      roles?: {
        compute?: {
          instanceTypeId?: [ string ](name='InstanceTypeId')
        }(name='Compute', description='The list of recommended ECS instance types for compute nodes.'),
        login?: {
          instanceTypeId?: [ string ](name='InstanceTypeId')
        }(name='Login', description='The list of recommended ECS instance types for logon nodes.'),
        manager?: {
          instanceTypeId?: [ string ](name='InstanceTypeId')
        }(name='Manager', description='The list of recommended ECS instance types for management nodes.'),
      }(name='Roles', description='The recommended ECS instance types for various nodes of the E-HPC cluster.'),
      seriesId?: string(name='SeriesId', description='The ID of the ECS instance series. Valid values:

*   HighCompute: high computing
*   HighMem: high storage
*   GPU
*   All: all options.', example='All'),
      seriesName?: string(name='SeriesName', description='The name of the instance series. Valid values:

*   SeriesHighCompute
*   SeriesHighMem
*   SeriesGPU
*   SeriesAll', example='SeriesAll'),
    }
  ](name='SeriesInfo')
  }(name='Series', description='The list of recommended ECS instances. Each SeriesInfo element contains the recommended ECS instance types for various nodes of the E-HPC cluster.'),
  supportSpotInstance?: boolean(name='SupportSpotInstance', description='Indicates whether spot instances are supported.', example='true'),
}

model ListPreferredEcsTypesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPreferredEcsTypesResponseBody(name='body'),
}

async function listPreferredEcsTypesWithOptions(request: ListPreferredEcsTypesRequest, runtime: Util.RuntimeOptions): ListPreferredEcsTypesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPreferredEcsTypes',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPreferredEcsTypes(request: ListPreferredEcsTypesRequest): ListPreferredEcsTypesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPreferredEcsTypesWithOptions(request, runtime);
}

model ListQueuesRequest {
  async?: boolean(name='Async', description='Specifies whether to enable asynchronous query.', example='false'),
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-FYUr32****'),
}

model ListQueuesResponseBody = {
  queues?: {
    queueInfo?: [ 
    {
      computeInstanceType?: {
        instanceType?: [ string ](name='InstanceType')
      }(name='ComputeInstanceType', description='The instance type of the compute nodes.'),
      enableAutoGrow?: boolean(name='EnableAutoGrow', description='Indicates whether the queue enabled auto scale-out. Valid values:

true: The queue enabled auto scale-out.

false: The queue disabled auto scale-out.', example='false'),
      hostNamePrefix?: string(name='HostNamePrefix', description='The prefix of the host name.', example='compute'),
      hostNameSuffix?: string(name='HostNameSuffix', description='The suffix of the host name.', example='01'),
      imageId?: string(name='ImageId', description='The ID of the image.', example='centos_7_06_64_20G_alibase_20****.vhd'),
      queueName?: string(name='QueueName', description='The name of the queue.', example='workq'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the queue belongs.', example='rg-acfmxp7uc24****'),
      spotInstanceTypes?: {
        instance?: [ 
        {
          instanceType?: string(name='InstanceType', description='The specifications of the ECS instance.', example='ecs.n1.tiny'),
          spotPriceLimit?: float(name='SpotPriceLimit', description='The maximum hourly price of the preemptible instance. The value can be accurate to three decimal places. The parameter takes effect only when SpotStrategy is set to SpotWithPriceLimit.', example='0.062'),
        }
      ](name='Instance')
      }(name='SpotInstanceTypes'),
      spotStrategy?: string(name='SpotStrategy', description='The preemption policy of the compute nodes. Valid values:

NoSpot: The instances of the compute node are pay-as-you-go instances.

SpotWithPriceLimit: The instances of the compute node are preemptible instances. These types of instances have a specified maximum hourly price.

SpotAsPriceGo: The instances of the compute node are preemptible instances. The price of these instances is based on the current market price.', example='SpotWithPriceLimit'),
      type?: string(name='Type', description='The type of the queue. Valid values:

Execution: Queues in which jobs can be executed.

Router: Queues in which jobs cannot be executed but are forwarded to the bounded Execution queue for processing.', example='Execution'),
    }
  ](name='QueueInfo')
  }(name='Queues'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='C6E5005C-00B0-4F27-98BB-95AB88016C22'),
}

model ListQueuesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListQueuesResponseBody(name='body'),
}

async function listQueuesWithOptions(request: ListQueuesRequest, runtime: Util.RuntimeOptions): ListQueuesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListQueues',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listQueues(request: ListQueuesRequest): ListQueuesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listQueuesWithOptions(request, runtime);
}

model ListRegionsResponseBody = {
  regions?: {
    regionInfo?: [ 
    {
      localName?: string(name='LocalName', description='The region name.'),
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
    }
  ](name='RegionInfo')
  }(name='Regions', description='The array of regions.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model ListRegionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRegionsResponseBody(name='body'),
}

async function listRegionsWithOptions(runtime: Util.RuntimeOptions): ListRegionsResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'ListRegions',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listRegions(): ListRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRegionsWithOptions(runtime);
}

model ListSecurityGroupsRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-FYUr32****'),
}

model ListSecurityGroupsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6D9A3378-61CA-4415-BEB0-1168C2A15975'),
  securityGroups?: {
    securityGroup?: [ string ](name='SecurityGroup')
  }(name='SecurityGroups', description='The ID of the security group.'),
  totalCount?: int32(name='TotalCount', description='The number of security groups.', example='1'),
}

model ListSecurityGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSecurityGroupsResponseBody(name='body'),
}

async function listSecurityGroupsWithOptions(request: ListSecurityGroupsRequest, runtime: Util.RuntimeOptions): ListSecurityGroupsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSecurityGroups',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSecurityGroups(request: ListSecurityGroupsRequest): ListSecurityGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSecurityGroupsWithOptions(request, runtime);
}

model ListSoftwaresRequest {
  ehpcVersion?: string(name='EhpcVersion', description='The version of the E-HPC client.

You can call the [ListCurrentClientVersion](~~87223~~) operation to query the E-HPC client version.', example='1.0.0'),
  osTag?: string(name='OsTag', description='The image tag of the cluster.

You can use the [ListImages](~~87213~~) to query the image tag of the cluster.', example='CentOS_7.2_64'),
}

model ListSoftwaresResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  softwares?: {
    softwareInfo?: [ 
    {
      accountType?: string(name='AccountType', description='The service type of the domain account. Valid values:

*   nis
*   ldap', example='nis'),
      accountVersion?: string(name='AccountVersion', description='The version of the domain account service.', example='2.31'),
      applications?: {
        applicationInfo?: [ 
        {
          name?: string(name='Name', description='The name of the software.', example='cudnnt'),
          required?: boolean(name='Required', description='Indicates whether the software is required. Valid values:

*   false: optional
*   true: required', example='true'),
          tag?: string(name='Tag', description='The tag of the software.', example='CUDNN_9.0'),
          version?: string(name='Version', description='The version of the software.', example='9.0'),
        }
      ](name='ApplicationInfo')
      }(name='Applications', description='The list of the software in the cluster.'),
      ehpcVersion?: string(name='EhpcVersion', description='The version of the E-HPC client.', example='1.0.0'),
      osTag?: string(name='OsTag', description='The image tag of the cluster.', example='CentOS_7.2_64'),
      schedulerType?: string(name='SchedulerType', description='The type of the scheduler. Valid values:

*   pbs
*   pbs19
*   slurm
*   slurm19
*   slurm20
*   opengridscheduler
*   deadline
*   gridengine
*   cube
*   custom', example='pbs'),
      schedulerVersion?: string(name='SchedulerVersion', description='The version of the scheduler.', example='18.1.1'),
    }
  ](name='SoftwareInfo')
  }(name='Softwares', description='The list of the information about the software installed in the cluster.'),
}

model ListSoftwaresResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSoftwaresResponseBody(name='body'),
}

async function listSoftwaresWithOptions(request: ListSoftwaresRequest, runtime: Util.RuntimeOptions): ListSoftwaresResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSoftwares',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSoftwares(request: ListSoftwaresRequest): ListSoftwaresResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSoftwaresWithOptions(request, runtime);
}

model ListTagResourcesRequest {
  nextToken?: string(name='NextToken', description='The token used to start the next query.', example='caeba0bbb2be03f84eb48b699f0axxxx'),
  regionId?: string(name='RegionId', description='The ID of the region to which the resource belongs.', example='cn-hangzhou'),
  resourceId?: [ string ](name='ResourceId'),
  resourceType?: string(name='ResourceType', description='The type of the resource. Set the value to cluster, which indicates E-HPC clusters.', example='cluster'),
  tag?: [ 
    {
      key?: string(name='Key', description='The key of the tag.', example='TestKey'),
      value?: string(name='Value', description='The value of the tag.', example='TestValue'),
    }
  ](name='Tag'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken', description='The token that is required for the next query. If the NextToken parameter is empty, no subsequent query will be sent.', example='caeba0bbb2be03f84eb48b699f0axxxx'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='484256DA-D816-44D2-9D86-B6EE4D5BA78C'),
  tagResources?: {
    tagResource?: [ 
    {
      resourceId?: string(name='ResourceId', description='The ID of the resource. Set the value to the ID of the cluster.', example='ehpc-hz-xxxx'),
      resourceType?: string(name='ResourceType', description='The type of the resource. Set the value to cluster, which indicates E-HPC clusters.', example='cluster'),
      tagKey?: string(name='TagKey', description='The key of the tag.', example='TestKey'),
      tagValue?: string(name='TagValue', description='The value of the tag.', example='TestValue'),
    }
  ](name='TagResource')
  }(name='TagResources', description='The list of tags.'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagResources',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagResourcesWithOptions(request, runtime);
}

model ListTasksRequest {
  archived?: boolean(name='Archived', description='Specifies whether to display the response history of the asynchronous API operation. Valid values:

*   true: displays the current response and response history of the asynchronous API operation.
*   false: displays only the current response of the asynchronous API operation. If no tasks are running, `[]` is returned.

Default value: false

>  If you specify the TaskId parameter, the Archived parameter is invalid.', example='false'),
  clusterId?: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to obtain the cluster ID.', example='ehpc-hz-FYUr32****'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page 1. Valid values: 1 to 999.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 50.

Default value: 10', example='10'),
  taskId?: string(name='TaskId', description='The ID of the task. You can call the following asynchronous API operations to obtain the task ID.

*   [CreateCluster](~~87100~~)
*   [StartCluster](~~200345~~)
*   [StopCluster](~~200346~~)
*   [DeleteCluster](~~87110~~)
*   [AddNodes](~~87147~~)
*   [StartNodes](~~87159~~)
*   [ResetNodes](~~87158~~)
*   [StopNodes](~~87160~~)
*   [DeleteNodes](~~87155~~)', example='B745C159-3155-4B94-95D0-4B73D4D2****'),
}

model ListTasksResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='89A1AC0F-4A6C-4F3D-98F9-BEF9A823****'),
  tasks?: [ 
    {
      clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-FYUr32****'),
      currentStep?: int32(name='CurrentStep', description='The current step of the task.', example='16'),
      errors?: string(name='Errors', description='The list of error messages returned for the task.

For information about error messages and their solutions, visit the [API Error Center](https://error-center.alibabacloud.com/status/product/EHPC).', example='[]'),
      request?: string(name='Request', description='The request parameters of the task. The value is a JSON string.', example='{\\"requestId\\":\\"0A6CA33E-BFBF-4F92-BDAE-4E8860DA****\\",\\"uid\\":\\"160998252992****\\",\\"bid\\":\\"268**\\",\\"clusterId\\":\\"ehpc-hz-ysQtcZ****\\"}'),
      result?: string(name='Result', description='The result of the task. Valid values:

*   If TaskType is set to CreateCluster and AddComputes, the value is in the `{\\"Instances\\":[]}` format, which indicates the information of the nodes added to the cluster.
*   If TaskType is set to a value other than CreateCluster and AddComputes, the value is in the `{}` format.', example='{\\"Instances\\":[{\\"InstanceId\\":\\"i-bp1inb1j2xz8pnoi****\\",\\"Ip\\":\\"192.168.*.*\\",\\"Hostname\\":\\"login0\\",\\"role\\":\\"login\\"}]}'),
      status?: string(name='Status', description='The status of the task. Valid values:

*   Processing: The task is running.
*   Success: The task is completed.
*   Fail: The task failed.
*   PartialFail: The task partially failed.', example='Processing'),
      taskId?: string(name='TaskId', description='The ID of the task.', example='B745C159-3155-4B94-95D0-4B73D4D2****'),
      taskType?: string(name='TaskType', description='The type of the task. Valid values:

*   CreateCluster: creates a cluster by calling the [CreateCluster](~~87100~~) operation.
*   StartCluster: starts a cluster by calling the [StartCluster](~~200345~~) operation.
*   StopCluster: stops a cluster by calling the [StopCluster](~~200346~~) operation.
*   DeleteCluster: releases a cluster by calling the [DeleteCluster](~~87110~~) operation.
*   AddComputes: adds nodes to a cluster by calling the [AddNodes](~~87147~~) operation.
*   StartComputes: starts nodes by calling the [StartNodes](~~87159~~) operation.
*   ResetCompute: resets nodes by calling the [ResetNodes](~~87158~~) operation.
*   StopComputes: stops nodes by calling the [StopNodes](~~87160~~) operation.
*   DeleteComputes: deletes nodes by calling the [DeleteNodes](~~87155~~) operation.', example='StopCluster'),
      totalSteps?: int32(name='TotalSteps', description='The total number of steps of the task.', example='35'),
    }
  ](name='Tasks', description='The list of task information.'),
  totalCount?: int32(name='TotalCount', description='The total number of entries of the task.', example='10'),
}

model ListTasksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTasksResponseBody(name='body'),
}

/**
  * If you succeed in calling an asynchronous API operation, a response is generated before a resulting task is completed. Therefore, to query the result of the task, you can use the TaskId parameter returned by the API operation.
  *
  * @param request ListTasksRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListTasksResponse
 */
async function listTasksWithOptions(request: ListTasksRequest, runtime: Util.RuntimeOptions): ListTasksResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTasks',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * If you succeed in calling an asynchronous API operation, a response is generated before a resulting task is completed. Therefore, to query the result of the task, you can use the TaskId parameter returned by the API operation.
  *
  * @param request ListTasksRequest
  * @return ListTasksResponse
 */
async function listTasks(request: ListTasksRequest): ListTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTasksWithOptions(request, runtime);
}

model ListUpgradeClientsRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-FYUr32****'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
}

model ListUpgradeClientsResponseBody = {
  clientRecords?: [ 
    {
      newVersion?: string(name='NewVersion', description='The version of the E-HPC client after the upgrade.', example='1.2.21'),
      oldVersion?: string(name='OldVersion', description='The version of the E-HPC client before the upgrade.', example='1.2.16'),
      subUid?: string(name='SubUid', description='The ID of the user that upgraded the E-HPC client.', example='129******84'),
      updateTime?: string(name='UpdateTime', description='The time when the operation was performed.', example='2022-08-26T06:26:57.000Z'),
    }
  ](name='ClientRecords', description='The upgrade records of the cluster.'),
  currentVersion?: string(name='CurrentVersion', description='The current version of the E-HPC client.', example='1.2.21'),
  latestVersion?: string(name='LatestVersion', description='The latest version of the E-HPC client.', example='1.2.22'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='89A1AC0F-4A6C-4F3D-98F9-BEF9A823****'),
}

model ListUpgradeClientsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListUpgradeClientsResponseBody(name='body'),
}

async function listUpgradeClientsWithOptions(request: ListUpgradeClientsRequest, runtime: Util.RuntimeOptions): ListUpgradeClientsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUpgradeClients',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listUpgradeClients(request: ListUpgradeClientsRequest): ListUpgradeClientsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUpgradeClientsWithOptions(request, runtime);
}

model ListUsersRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return.

Pages start from page 1.

Default value: 1', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 50.

Default value: 10', example='10'),
}

model ListUsersResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  totalCount?: int32(name='TotalCount', description='The total number of returned entries.', example='1'),
  users?: {
    userInfo?: [ 
    {
      addTime?: string(name='AddTime', description='The time when the user was created.', example='2018-07-18T17:46:47'),
      group?: string(name='Group', description='The name of the permission group. Valid values:

*   users: an ordinary permission group. It is applicable to ordinary users that need only to submit and debug jobs.
*   wheel: a sudo permission group. It is applicable to the administrator who needs to manage the cluster. In addition to submitting and debugging jobs, users who have sudo permissions can run sudo commands to install software and restart nodes.', example='wheel'),
      name?: string(name='Name', description='The username.', example='user1'),
    }
  ](name='UserInfo')
  }(name='Users', description='The list of users.'),
}

model ListUsersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListUsersResponseBody(name='body'),
}

async function listUsersWithOptions(request: ListUsersRequest, runtime: Util.RuntimeOptions): ListUsersResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUsers',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listUsers(request: ListUsersRequest): ListUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUsersWithOptions(request, runtime);
}

model ListUsersAsyncRequest {
  asyncId?: string(name='AsyncId'),
  clusterId?: string(name='ClusterId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListUsersAsyncResponseBody = {
  asyncId?: string(name='AsyncId'),
  asyncStatus?: string(name='AsyncStatus'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  users?: {
    userInfo?: [ 
    {
      addTime?: string(name='AddTime'),
      group?: string(name='Group'),
      groupId?: string(name='GroupId'),
      name?: string(name='Name'),
      userId?: string(name='UserId'),
    }
  ](name='UserInfo')
  }(name='Users'),
}

model ListUsersAsyncResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListUsersAsyncResponseBody(name='body'),
}

async function listUsersAsyncWithOptions(request: ListUsersAsyncRequest, runtime: Util.RuntimeOptions): ListUsersAsyncResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUsersAsync',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listUsersAsync(request: ListUsersAsyncRequest): ListUsersAsyncResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUsersAsyncWithOptions(request, runtime);
}

model ListVolumesRequest {
  pageNumber?: int32(name='PageNumber', description='The number of the page to return.

Pages start from page 1.

Default value: 1', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 50.

Default value: 10', example='10'),
}

model ListVolumesResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
  totalCount?: int32(name='TotalCount', description='The total number of returned entries.', example='1'),
  volumes?: {
    volumeInfo?: [ 
    {
      additionalVolumes?: {
        volumeInfo?: [ 
        {
          jobQueue?: string(name='JobQueue', description='The queue to which the job belongs.', example='all.q'),
          localDirectory?: string(name='LocalDirectory', description='The local mount directory.', example='/testopt'),
          location?: string(name='Location', description='The location where the cluster was deployed. Valid values:

*   OnPremise: The cluster is deployed on a hybrid cloud.
*   PublicCloud: The cluster is deployed on a public cloud.', example='PublicCloud'),
          remoteDirectory?: string(name='RemoteDirectory', description='The remote directory on which the file system is mounted.', example='/test'),
          role?: string(name='Role', description='The type of the node on which the file system is mounted. Valid values:

*   Manager: management node
*   Login: logon node
*   Compute: compute node', example='Compute'),
          volumeId?: string(name='VolumeId', description='The ID of the file system.', example='86y3****'),
          volumeMountpoint?: string(name='VolumeMountpoint', description='The domain name of the mount target.', example='86y3****-rgd51.cn-hangzhou.nas.aliyuncs.com'),
          volumeProtocol?: string(name='VolumeProtocol', description='The type of the storage protocol. Valid values:

*   NFS
*   SMB', example='NFS'),
          volumeType?: string(name='VolumeType', description='The type of the additional file system. Only NAS is supported.', example='NAS'),
        }
      ](name='VolumeInfo')
      }(name='AdditionalVolumes', description='The information of additional file systems mounted on E-HPC clusters.'),
      clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-FYUr32****'),
      clusterName?: string(name='ClusterName', description='The name of the cluster.', example='cluster1'),
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
      remoteDirectory?: string(name='RemoteDirectory', description='The remote directory on which the file system is mounted.', example='/test1'),
      volumeId?: string(name='VolumeId', description='The ID of the file system.', example='bc8a****'),
      volumeMountpoint?: string(name='VolumeMountpoint', description='The domain name of the mount target.', example='bc8a****-rgd51.cn-hangzhou.nas.aliyuncs.com'),
      volumeProtocol?: string(name='VolumeProtocol', description='The type of the storage protocol. Valid values:

*   NFS
*   SMB', example='NFS'),
      volumeType?: string(name='VolumeType', description='The type of the file system that is mounted on the cluster. Only NAS is supported.', example='NAS'),
    }
  ](name='VolumeInfo')
  }(name='Volumes', description='The information of file systems that are mounted on E-HPC clusters.'),
}

model ListVolumesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListVolumesResponseBody(name='body'),
}

async function listVolumesWithOptions(request: ListVolumesRequest, runtime: Util.RuntimeOptions): ListVolumesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListVolumes',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listVolumes(request: ListVolumesRequest): ListVolumesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVolumesWithOptions(request, runtime);
}

model ModifyClusterAttributesRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster that you want to modify.', example='ehpc-hz-FYUr32****'),
  description?: string(name='Description', description='The new cluster description.', example='test-description'),
  imageId?: string(name='ImageId', description='The ID of the image.', example='centos_7_06_64_20G_alibase_2019071****'),
  imageOwnerAlias?: string(name='ImageOwnerAlias', description='The new image type of the cluster. Valid values:

*   system: public image
*   self: custom image
*   others: shared image
*   marketplace: Alibaba Cloud Marketplace image', example='self'),
  name?: string(name='Name', description='The new cluster name.', example='cluster1'),
  ramNodeTypes?: [ string ](name='RamNodeTypes'),
  ramRoleName?: string(name='RamRoleName', example='AliyunEHPCFullAccess'),
}

model ModifyClusterAttributesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7336'),
}

model ModifyClusterAttributesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyClusterAttributesResponseBody(name='body'),
}

/**
  * Before you modify the basic information of a cluster, you can call the [DescribeCluster](~~87126~~) operation to query details of the selected cluster.
  *
  * @param request ModifyClusterAttributesRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ModifyClusterAttributesResponse
 */
async function modifyClusterAttributesWithOptions(request: ModifyClusterAttributesRequest, runtime: Util.RuntimeOptions): ModifyClusterAttributesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyClusterAttributes',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Before you modify the basic information of a cluster, you can call the [DescribeCluster](~~87126~~) operation to query details of the selected cluster.
  *
  * @param request ModifyClusterAttributesRequest
  * @return ModifyClusterAttributesResponse
 */
async function modifyClusterAttributes(request: ModifyClusterAttributesRequest): ModifyClusterAttributesResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyClusterAttributesWithOptions(request, runtime);
}

model ModifyContainerAppAttributesRequest {
  containerId?: string(name='ContainerId', description='The ID of the container.

You can call the [ListContainerApps](~~87333~~) operation to query the ID of the containerized application.', example='ehpc-container-ABDUGSkjs****'),
  description?: string(name='Description', description='The new description of the containerized application.', example='ExampleDescription'),
}

model ModifyContainerAppAttributesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model ModifyContainerAppAttributesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyContainerAppAttributesResponseBody(name='body'),
}

async function modifyContainerAppAttributesWithOptions(request: ModifyContainerAppAttributesRequest, runtime: Util.RuntimeOptions): ModifyContainerAppAttributesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyContainerAppAttributes',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyContainerAppAttributes(request: ModifyContainerAppAttributesRequest): ModifyContainerAppAttributesResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyContainerAppAttributesWithOptions(request, runtime);
}

model ModifyImageGatewayConfigRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-FYUr32****'),
  DBPassword?: string(name='DBPassword', description='The password that is used to log on to the database instance.', example='13****'),
  DBServerInfo?: string(name='DBServerInfo', description='The URI of the database.', example='dds-uf6628e4287716b433270.mongodb.rds.aliyuncs.com:3717/admin'),
  DBType?: string(name='DBType', description='The type of the database. Set the value to mongodb.', example='mongodb'),
  DBUsername?: string(name='DBUsername', description='The username of the account that is used to log on to the database.', example='root'),
  defaultRepoLocation?: string(name='DefaultRepoLocation', description='The default repository service. Set the value to registry-1.docker.io.', example='registry-1.docker.io'),
  imageExpirationTimeout?: string(name='ImageExpirationTimeout', description='The timeout period for deleting images.', example='12:00:00'),
  pullUpdateTimeout?: int32(name='PullUpdateTimeout', description='The timeout period for pulling images.', example='300'),
  repo?: [ 
    {
      auth?: string(name='Auth', description='The authentication method of the repository. Valid values:

*   http
*   https

Default value: http.', example='http'),
      location?: string(name='Location', description='The address of the repository N.', example='registry.docker-cn.com'),
      URL?: string(name='URL', description='The URL of the repository. The URL is required to add a repository address.', example='https://registry.docker-cn.com'),
    }
  ](name='Repo', description='The information about the repository.'),
}

model ModifyImageGatewayConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model ModifyImageGatewayConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyImageGatewayConfigResponseBody(name='body'),
}

async function modifyImageGatewayConfigWithOptions(request: ModifyImageGatewayConfigRequest, runtime: Util.RuntimeOptions): ModifyImageGatewayConfigResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyImageGatewayConfig',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyImageGatewayConfig(request: ModifyImageGatewayConfigRequest): ModifyImageGatewayConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyImageGatewayConfigWithOptions(request, runtime);
}

model ModifyUserGroupsRequest {
  async?: boolean(name='Async'),
  clusterId?: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****'),
  user?: [ 
    {
      group?: string(name='Group', description='The new permission group of the user. Valid values:

*   users: an ordinary permission group. It is applicable to ordinary users that need only to submit and debug jobs.
*   wheel: a sudo permission group. It is applicable to the administrator who needs to manage the cluster. In addition to submitting and debugging jobs, users who have sudo permissions can run sudo commands to install software and restart nodes.', example='users'),
      name?: string(name='Name', description='The name of the user whose permissions you want to modify. Valid values of N: 1 to 100.

You can call the [ListUsers](~~188572~~) operation to query the users of the cluster.', example='user11'),
    }
  ](name='User'),
}

model ModifyUserGroupsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model ModifyUserGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyUserGroupsResponseBody(name='body'),
}

async function modifyUserGroupsWithOptions(request: ModifyUserGroupsRequest, runtime: Util.RuntimeOptions): ModifyUserGroupsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyUserGroups',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyUserGroups(request: ModifyUserGroupsRequest): ModifyUserGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyUserGroupsWithOptions(request, runtime);
}

model ModifyUserPasswordsRequest {
  async?: boolean(name='Async'),
  clusterId?: string(name='ClusterId', description='The ID of the E-HPC cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****'),
  user?: [ 
    {
      name?: string(name='Name', description='The name of the Nth user whose password you want to modify. Valid values of N: 1 to 100.

You can call the [ListUsers](~~188572~~) operation to query the users of the cluster.', example='user1'),
      password?: string(name='Password', description='The password of the Nth user. The password must be 8 to 30 characters in length and contain three of the following items:

*   Uppercase letter
*   Lowercase letter
*   Digit
*   Special character: `()~!@#$%^&*-_+=|{}[]:;\\"/<>,.?/`

Valid values of N: 1 to 100

>  We recommend that you use HTTPS to call the AddUsers operation to ensure that the password remains confidential.', example='1@a****'),
    }
  ](name='User'),
}

model ModifyUserPasswordsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model ModifyUserPasswordsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyUserPasswordsResponseBody(name='body'),
}

async function modifyUserPasswordsWithOptions(request: ModifyUserPasswordsRequest, runtime: Util.RuntimeOptions): ModifyUserPasswordsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyUserPasswords',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyUserPasswords(request: ModifyUserPasswordsRequest): ModifyUserPasswordsResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyUserPasswordsWithOptions(request, runtime);
}

model ModifyVisualServicePasswdRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-jeJki6****'),
  passwd?: string(name='Passwd', description='The connection password of the VNC remote visualization service. The password must be 8 to 30 characters in length and include at least three of the following character types: uppercase letters, lowercase letters, digits, and special characters. Special characters include:

`()~! @#$%^&*-_+=|{}[]:;\\"/<>,.? /`

>  You must use HTTPS to call the API to ensure that the password remains confidential.', example='1254****'),
  runasUser?: string(name='RunasUser', description='The username of the cluster. Default value: root user. You can call the [ListUsers](~~188572~~) operation to query all users in a cluster.', example='root'),
  runasUserPassword?: string(name='RunasUserPassword', description='The user password of the cluster.', example='2145****'),
}

model ModifyVisualServicePasswdResponseBody = {
  message?: string(name='Message', description='The status of the VNC Remote visualization service. Valid values:

*   Service started.: started
*   Service stopped.: stopped', example='Service started.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='896D338C-E4F4-41EC-A154-D605E5DE6880'),
}

model ModifyVisualServicePasswdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyVisualServicePasswdResponseBody(name='body'),
}

async function modifyVisualServicePasswdWithOptions(request: ModifyVisualServicePasswdRequest, runtime: Util.RuntimeOptions): ModifyVisualServicePasswdResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyVisualServicePasswd',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyVisualServicePasswd(request: ModifyVisualServicePasswdRequest): ModifyVisualServicePasswdResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyVisualServicePasswdWithOptions(request, runtime);
}

model MountNFSRequest {
  instanceId?: string(name='InstanceId', description='The ID of the visualization instance.', example='i-bp1bzqq4rremun****'),
  mountDir?: string(name='MountDir', description='The local mount directory.', example='Z:'),
  nfsDir?: string(name='NfsDir', description='The address of the mount target.', example='\\\\0de-jup****.cn-hangzhou.nas.aliyuncs.com\\'),
  protocolType?: string(name='ProtocolType', description='The type of the protocol. Valid values:

*   nfs
*   smb', example='nfs'),
  remoteDir?: string(name='RemoteDir', description='The remote mount address.', example='/test'),
}

model MountNFSResponseBody = {
  invokeId?: string(name='InvokeId', description='The ID of the execution.', example='t-hz0jdfwd9f****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='6FDDFC21-40CD-4DB2-9978-012AB7FC9BDW'),
}

model MountNFSResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MountNFSResponseBody(name='body'),
}

async function mountNFSWithOptions(request: MountNFSRequest, runtime: Util.RuntimeOptions): MountNFSResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'MountNFS',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function mountNFS(request: MountNFSRequest): MountNFSResponse {
  var runtime = new Util.RuntimeOptions{};
  return mountNFSWithOptions(request, runtime);
}

model PullImageRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-nkKsP3****'),
  containerType?: string(name='ContainerType', description='The type of the image. Default value: shifter.', example='shifter'),
  imageTag?: string(name='ImageTag', description='The tag of the image. Default value: latest.', example='latest'),
  repository?: string(name='Repository', description='The name of the repository.', example='centos'),
}

model PullImageResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='29d3d9Ee-8eCB-5013-A1c2-1CeD19C6CfFe'),
}

model PullImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PullImageResponseBody(name='body'),
}

async function pullImageWithOptions(request: PullImageRequest, runtime: Util.RuntimeOptions): PullImageResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PullImage',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function pullImage(request: PullImageRequest): PullImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return pullImageWithOptions(request, runtime);
}

model QueryServicePackAndPriceResponseBody = {
  chargeAmount?: int32(name='ChargeAmount', example='167'),
  currency?: string(name='Currency', example='CNY'),
  discountPrice?: float(name='DiscountPrice', example='0.418'),
  originalAmount?: int32(name='OriginalAmount', example='3191'),
  originalPrice?: float(name='OriginalPrice', example='3.34'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  requestId?: string(name='RequestId', example='3B2E8108-7068-413E-BCA7-CAAB25D46408'),
  servicePack?: {
    servicePackInfo?: [ 
    {
      capacity?: int32(name='Capacity', example='2000'),
      endTime?: int32(name='EndTime', example='1612705988'),
      instanceName?: string(name='InstanceName', example='EHPCBAG-cn-78v12vbme0****'),
      startTime?: int32(name='StartTime', example='1610027588'),
    }
  ](name='ServicePackInfo')
  }(name='ServicePack'),
  tradePrice?: float(name='TradePrice', example='2.922'),
}

model QueryServicePackAndPriceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryServicePackAndPriceResponseBody(name='body'),
}

async function queryServicePackAndPriceWithOptions(runtime: Util.RuntimeOptions): QueryServicePackAndPriceResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'QueryServicePackAndPrice',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryServicePackAndPrice(): QueryServicePackAndPriceResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryServicePackAndPriceWithOptions(runtime);
}

model RecoverClusterRequest {
  accountType?: string(name='AccountType', description='The service type of the domain account. Valid values:

*   nis
*   ldap

Default value: nis', example='nis'),
  clientVersion?: string(name='ClientVersion', description='The version of the E-HPC client. The default value is the latest version of the client.

You can call the [ListCurrentClientVersion](~~87223~~) operation to query the current version of the E-HPC client.', example='1.0.76'),
  clusterId?: string(name='ClusterId', description='The ID of the cluster. The cluster must be in the Exception state.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID and status.', example='ehpc-hz-FYUr32****'),
  imageId?: string(name='ImageId', description='The ID of the image.

You can call the [ListImages](~~87213~~) and [ListCustomImages](~~87215~~) operations to query the images that are supported by E-HPC.', example='m-bp18133n0335yq****'),
  imageOwnerAlias?: string(name='ImageOwnerAlias', description='The type of the image. Valid values:

*   system: public image
*   self: custom image
*   others: shared image

Default value: system', example='system'),
  osTag?: string(name='OsTag', description='The image tag of the operating system.

You can call the [ListImages](~~87213~~) and [ListCustomImages](~~87215~~) operations to query the image tags supported by Elastic High Performance Computing (E-HPC).', example='CentOS_7.2_64'),
  schedulerType?: string(name='SchedulerType', description='The type of the scheduler. Valid values:

*   pbs
*   slurm
*   opengridscheduler
*   deadline

Default value: pbs', example='pbs'),
}

model RecoverClusterResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='18FB21E3-F423-4B84-BB63-D8887A29****'),
  taskId?: string(name='TaskId', description='The ID of the task.', example='18FB21E3-F423-4B84-BB63-D8887A29****'),
}

model RecoverClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RecoverClusterResponseBody(name='body'),
}

/**
  * You can call the operation to reset and restore a cluster only when the cluster is in the Exception state. You can call the [ListClusters](~~87116~~) operation to query the ID and status of a cluster.
  * We recommend that you export all job data before you restore a cluster. When you reset and restore a cluster, take note of the following impacts:
  * *   The system disks of all nodes are changed. By default, new system disks are configured based on the settings that you specified when the cluster was created.
  * *   The data on the system disks and data disks of all cluster nodes is lost. The data includes user information, job information, scheduler queue information, and configuration data of auto-scaling queues. However, the data on Apsara File Storage NAS file systems is retained.
  * *   The self-managed queues in the cluster are deleted. All nodes are retained and migrated to the default queue of the cluster.
  *
  * @param request RecoverClusterRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return RecoverClusterResponse
 */
async function recoverClusterWithOptions(request: RecoverClusterRequest, runtime: Util.RuntimeOptions): RecoverClusterResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RecoverCluster',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call the operation to reset and restore a cluster only when the cluster is in the Exception state. You can call the [ListClusters](~~87116~~) operation to query the ID and status of a cluster.
  * We recommend that you export all job data before you restore a cluster. When you reset and restore a cluster, take note of the following impacts:
  * *   The system disks of all nodes are changed. By default, new system disks are configured based on the settings that you specified when the cluster was created.
  * *   The data on the system disks and data disks of all cluster nodes is lost. The data includes user information, job information, scheduler queue information, and configuration data of auto-scaling queues. However, the data on Apsara File Storage NAS file systems is retained.
  * *   The self-managed queues in the cluster are deleted. All nodes are retained and migrated to the default queue of the cluster.
  *
  * @param request RecoverClusterRequest
  * @return RecoverClusterResponse
 */
async function recoverCluster(request: RecoverClusterRequest): RecoverClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return recoverClusterWithOptions(request, runtime);
}

model RerunJobsRequest {
  async?: boolean(name='Async', description='Specifies whether to use an asynchronous link to rerun the job.

Default value: false', example='false'),
  clusterId?: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-sh-3VeFyR****'),
  jobs?: string(name='Jobs', description='The list of jobs that you want to run. Maximum number of jobs: 100. Minimum number of jobs: 1.

Format: `[{"Id": "0.sched****"},{"Id": "1.sched****"}]`. Separate multiple jobs with commas (,).

You can call the [ListJobs](~~87251~~) operation to query the job ID.

>  You can rerun only jobs that are in the RUNNING or QUEUED state.', example='[{"Id":"1.scheduler"}]'),
}

model RerunJobsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model RerunJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RerunJobsResponseBody(name='body'),
}

async function rerunJobsWithOptions(request: RerunJobsRequest, runtime: Util.RuntimeOptions): RerunJobsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RerunJobs',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function rerunJobs(request: RerunJobsRequest): RerunJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return rerunJobsWithOptions(request, runtime);
}

model ResetNodesRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****'),
  instance?: [ 
    {
      id?: string(name='Id', description='The ID of the compute node that you want to reset. Valid values of N: 1 to 100

You can call the [ListNodes](~~87161~~) operation to query the IDs of the compute nodes.', example='i-bp13p7vlcb1uihfv****'),
    }
  ](name='Instance'),
}

model ResetNodesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  taskId?: string(name='TaskId', description='The ID of the task.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model ResetNodesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ResetNodesResponseBody(name='body'),
}

/**
  * After a node is reset, the operating system and software return to their initial states. To ensure that jobs run as expected, we recommend that you do not reset running nodes unless you need to perform crash recovery.
  *
  * @param request ResetNodesRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ResetNodesResponse
 */
async function resetNodesWithOptions(request: ResetNodesRequest, runtime: Util.RuntimeOptions): ResetNodesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResetNodes',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * After a node is reset, the operating system and software return to their initial states. To ensure that jobs run as expected, we recommend that you do not reset running nodes unless you need to perform crash recovery.
  *
  * @param request ResetNodesRequest
  * @return ResetNodesResponse
 */
async function resetNodes(request: ResetNodesRequest): ResetNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return resetNodesWithOptions(request, runtime);
}

model RunCloudMetricProfilingRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-jeJki6****'),
  duration?: int32(name='Duration', description='The duration of the profiling process. Unit: seconds.

Value values: 10 to 300

Default value: 30', example='300'),
  freq?: int32(name='Freq', description='The sampling frequency. Unit: Hz

Valid values: 1 to 2000

Default value: 2000', example='2000'),
  hostName?: string(name='HostName', description='The name of the host.', example='compute0'),
  processId?: int32(name='ProcessId', description='The ID of the profiling process.', example='29075'),
  regionId?: string(name='RegionId', description='The ID of the region where the cluster resides.', example='cn-hangzhou'),
}

model RunCloudMetricProfilingResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='8442AF35-875B-4FC0-8B7AAFDC339335D5'),
}

model RunCloudMetricProfilingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RunCloudMetricProfilingResponseBody(name='body'),
}

async function runCloudMetricProfilingWithOptions(request: RunCloudMetricProfilingRequest, runtime: Util.RuntimeOptions): RunCloudMetricProfilingResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RunCloudMetricProfiling',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function runCloudMetricProfiling(request: RunCloudMetricProfilingRequest): RunCloudMetricProfilingResponse {
  var runtime = new Util.RuntimeOptions{};
  return runCloudMetricProfilingWithOptions(request, runtime);
}

model SetAutoScaleConfigRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-FYUr32****'),
  computeEnableHt?: boolean(name='ComputeEnableHt'),
  enableAutoGrow?: boolean(name='EnableAutoGrow', description='Specifies whether to enable auto scale-out. Valid values:

*   true: enables auto scale-out.
*   false: disables auto scale-out

Default value: false', example='false'),
  enableAutoShrink?: boolean(name='EnableAutoShrink', description='Specifies whether to enable auto scale-in. Valid values:

*   true: enables auto scale-in.
*   false: disables auto scale-in

Default value: false', example='false'),
  excludeNodes?: string(name='ExcludeNodes', description='The compute nodes that are excluded from the list of auto scaling nodes. Separate multiple compute nodes with commas (,).

If you want to retain a compute node, you can set the node as an exceptional node. Then, the node is not released if it is idle.', example='i-bp19lgqwxb4206t5****,i-bp1g4hvzs9pywrhb****'),
  extraNodesGrowRatio?: int32(name='ExtraNodesGrowRatio', description='The percentage of extra compute nodes. Valid values: 0 to 100

Default value: 0

If you need to add 100 compute nodes and the value of the ExtraNodesGrowRatio parameter is 2, 102 compute nodes are added.', example='0'),
  growIntervalInMinutes?: int32(name='GrowIntervalInMinutes', description='The interval between two consecutive rounds of scale-out. Unit: minutes.

Valid values: 2 to 10

Default value: 2

>  An interval may exist during multiple rounds of a scale-out task or between two consecutive scale-out tasks.', example='2'),
  growRatio?: int32(name='GrowRatio', description='The percentage of each round of scale-out. Valid values: 1 to 100.

Default value: 100

If you set GrowRatio to 50, the scale-out has two rounds. Each round completes half of the scale-out.', example='50'),
  growTimeoutInMinutes?: int32(name='GrowTimeoutInMinutes', description='The scale-out timeout period. Unit: minutes.

Valid values: 10 to 60

Default value: 20

If the scale-out timeout period has been reached but the scale-out nodes still do not reach the Running state, the system resets them.', example='20'),
  imageId?: string(name='ImageId', description='The ID of the image.

> 
*   If you set both `Queues.N.QueueImageId` and `ImageId`, `Queues.N.QueueImageId` prevails.
*   If you set `Queues.N.QueueImageId` or `ImageId`, the parameter that you set takes effect.
*   If you leave both `Queues.N.QueueImageId` and `ImageId` empty, the image that was specified when you created the cluster or the last time when you scaled out the cluster is used by default.', example='centos_7_03_64_20G_alibase_201708****'),
  maxNodesInCluster?: int32(name='MaxNodesInCluster', description='The maximum number of compute nodes that can be added in the cluster. Valid values: 0 to 500.

Default value: 100', example='100'),
  queues?: [ 
    {
      dataDisks?: [ 
        {
          dataDiskCategory?: string(name='DataDiskCategory', description='The type of the data disk. Valid values:

*   cloud_efficiency: ultra disk
*   cloud_ssd: SSD
*   cloud_essd: ESSD
*   cloud: basic disk

Default value: cloud_efficiency

Valid values of N: 0 to 16', example='cloud_efficiency'),
          dataDiskDeleteWithInstance?: boolean(name='DataDiskDeleteWithInstance', description='Specifies whether the data disk is released when the node is released. Valid values:

*   true
*   false

Default value: true

Valid values of N: 0 to 16', example='true'),
          dataDiskEncrypted?: boolean(name='DataDiskEncrypted', description='Specifies whether to encrypt the data disk. Valid values:

*   true
*   false

Default value: false

Valid values of N: 0 to 16', example='false'),
          dataDiskKMSKeyId?: string(name='DataDiskKMSKeyId', description='The KMS key ID of the data disk.

Valid values of N: 0 to 16', example='0e478b7a-4262-4802-b8cb-00d3fb40826X'),
          dataDiskPerformanceLevel?: string(name='DataDiskPerformanceLevel', description='The performance level of the ESSD used as the data disk. The parameter takes effect only when the Queues.N.DataDisks.N.DataDiskCategory parameter is set to cloud_essd. Valid values:

*   PL0: A single ESSD can deliver up to 10,000 random read/write IOPS.
*   PL1: A single ESSD can deliver up to 50,000 random read/write IOPS.
*   PL2: A single ESSD can deliver up to 100,000 random read/write IOPS.
*   PL3: A single ESSD can deliver up to 1,000,000 random read/write IOPS.

Default value: PL1

Valid values of N: 0 to 16', example='PL1'),
          dataDiskSize?: int32(name='DataDiskSize', description='The size of the data disk. Unit: GB.

Valid values: 40 to 500

Default value: 40

Valid values of N: 0 to 16', example='40'),
        }
      ](name='DataDisks'),
      enableAutoGrow?: boolean(name='EnableAutoGrow', description='Specifies whether the queue enables auto scale-out. Valid values:

*   true: enables auto scale-out.
*   false: disables auto scale-out

Valid values of N: 1 to 8

Default value: false', example='false'),
      enableAutoShrink?: boolean(name='EnableAutoShrink', description='Specifies whether the queue enables auto scale-in. Valid values:

*   true: enables auto scale-in.
*   false: disables auto scale-in

Valid values of N: 1 to 8

Default value: false', example='false'),
      hostNamePrefix?: string(name='HostNamePrefix', description='The hostname prefix of the host that is used to perform scale-out for the queue. You can manage compute nodes that have a specified hostname prefix.

Valid values of N: 1 to 8', example='compute'),
      hostNameSuffix?: string(name='HostNameSuffix', description='The hostname suffix of the host that is used to perform scale-out for the queue. You can manage nodes that have a specified hostname suffix.

Valid values of N: 1 to 8', example='000'),
      instanceType?: string(name='InstanceType', description='The instance type of the compute nodes that are automatically added in the queue. Valid values of N: 1 to 8', example='ecs.n1.medium'),
      instanceTypes?: [ 
        {
          instanceType?: string(name='InstanceType', description='The instance type of the compute nodes that are automatically added in the queue.

N queue names can be set at the same time. Valid values of N: 1 to 8.

The instance types of N compute nodes in the queue can be set at the same time when auto scaling is performed in the queue. Valid values of N: 0 to 500.', example='ecs.n1.tiny'),
          spotDuration?: int32(name='SpotDuration', example='0'),
          spotInterruptionBehavior?: string(name='SpotInterruptionBehavior', example='Terminate'),
          spotPriceLimit?: float(name='SpotPriceLimit', description='The maximum hourly price of the compute nodes that are automatically added in the queue. The value can be accurate to three decimal places. The parameter takes effect only when `Queues.N.InstanceTypes.N.SpotStrategy` is set to `Queues.N.InstanceTypes.N.SpotStrategy`.

The maximum hourly prices of the compute nodes that are automatically added in N queues can be set the same time. Valid values of N: 1 to 8.

The maximum hourly prices of N compute nodes in the queue can be set at the same time when auto scaling is performed in the queue. Valid values of N: 0 to 500.', example='0.660'),
          spotStrategy?: string(name='SpotStrategy', description='The bidding method of the compute nodes that are automatically added in the queue. Valid values:

*   NoSpot: The compute nodes are pay-as-you-go instances.
*   SpotWithPriceLimit: The compute nodes are preemptible instances that have a user-defined maximum hourly price.
*   SpotAsPriceGo: The compute nodes are preemptible instances for which the market price at the time of purchase is used as the bid price.

Default value: NoSpot

N queue names can be set at the same time. Valid values of N: 1 to 8.

The bidding methods of N compute nodes in the queue can be set at the same time when auto scaling is performed in the queue. Valid values of N: 0 to 500.', example='SpotWithPriceLimit'),
          vSwitchId?: string(name='VSwitchId', description='The vSwitch ID of the compute nodes that are automatically added in the queue.

N queue names can be set at the same time. Valid values of N: 1 to 8.

The vSwitch IDs of N compute nodes in the queue can be set at the same time when auto scaling is performed in the queue. Valid values of N: 0 to 500.', example='vsw-bp1lfcjbfb099rrjn****'),
          zoneId?: string(name='ZoneId', description='The zone ID of the compute nodes that are automatically added in the queue belongs.

N queue names can be set at the same time. Valid values of N: 1 to 8.

The zone IDs of N compute nodes in the queue can be set at the same time when auto scaling is performed in the queue. Valid values of N: 0 to 500.', example='cn-hangzhou-b'),
        }
      ](name='InstanceTypes'),
      maxNodesInQueue?: int32(name='MaxNodesInQueue', description='The maximum number of the compute nodes that can be added in the queue. Valid values: 0 to 500.

Valid values of N: 1 to 8

Default value: 100', example='30'),
      maxNodesPerCycle?: long(name='MaxNodesPerCycle', description='The maximum number of compute nodes that can be added in each round of scale-out. Valid values: 0 to 99.

Default value: 0', example='20'),
      minNodesInQueue?: int32(name='MinNodesInQueue', description='The minimum number of the compute nodes that can be removed in the queue. Valid values: 0 to 50.

Valid values of N: 1 to 8

Default value: 0', example='0'),
      minNodesPerCycle?: long(name='MinNodesPerCycle', description='The minimum number of compute nodes that can be added in each round of scale-out. Valid values: 1 to 99.

Default value: 1

If the compute nodes that you want to add in a round is less than the minimum compute nodes that can be added, the value of this parameter is automatically changed to the number of compute nodes that you want to add. This ensures that compute nodes can be added as expected.

>  The configuration takes effect only for the minimum compute nodes that can be added in the current round.', example='5'),
      queueImageId?: string(name='QueueImageId', description='The image ID of the queue where scale-out is performed. Valid values of N: 1 to 8.

> 
*   If you set both `Queues.N.QueueImageId` and `ImageId`, `Queues.N.QueueImageId` prevails.
*   If you set `Queues.N.QueueImageId` or `ImageId`, the parameter that you set takes effect.
*   If you leave both `Queues.N.QueueImageId` and `ImageId` empty, the image that was specified when you created the cluster or the last time when you scaled out the cluster is used by default.', example='centos_7_03_64_20G_alibase_201708****'),
      queueName?: string(name='QueueName', description='The name of the queue. N queue names can be set at the same time. Valid values of N: 1 to 8.', example='cluster1'),
      spotPriceLimit?: float(name='SpotPriceLimit', description='The maximum hourly price of the compute nodes that are automatically added in the queue. The value can be accurate to three decimal places. The parameter takes effect only when `Queues.N.SpotStrategy` is set to `SpotWithPriceLimit`.

Valid values of N: 1 to 8', example='0.662'),
      spotStrategy?: string(name='SpotStrategy', description='The bidding method of the compute nodes that are automatically added in the queue. Valid values of N: 1 to 8

Valid values:

*   NoSpot: The compute nodes are pay-as-you-go instances.
*   SpotWithPriceLimit: The compute nodes are preemptible instances that have a user-defined maximum hourly price.
*   SpotAsPriceGo: The compute nodes are preemptible instances for which the market price at the time of purchase is used as the bid price.

Default value: NoSpot', example='NoSpot'),
      systemDiskCategory?: string(name='SystemDiskCategory', description='The type of the system disk specified for the compute nodes that are added in the queue. Valid values:

*   cloud_efficiency: ultra disk.
*   cloud_ssd: SSD.
*   cloud_essd: ESSD.
*   cloud: basic disk. Disks of this type are retired.

Valid values of N: 1 to 8

Default value: cloud_efficiency', example='cloud_efficiency'),
      systemDiskLevel?: string(name='SystemDiskLevel', description='The performance level of the system disk specified for the compute nodes that are added in the queue. Valid values:

*   PL0: A single ESSD can deliver up to 10,000 random read/write IOPS.
*   PL1: A single ESSD can deliver up to 50,000 random read/write IOPS.
*   PL2: A single ESSD can deliver up to 100,000 random read/write IOPS.
*   PL3: A single ESSD can deliver up to 1,000,000 random read/write IOPS.

Valid values of N: 1 to 8

Default value: PL1', example='PL1'),
      systemDiskSize?: int32(name='SystemDiskSize', description='The size of the system disk specified for the compute nodes that are added in the queue. Unit: GB.

Valid values: 40 to 500

Valid values of N: 1 to 8

Default value: 40', example='40'),
    }
  ](name='Queues'),
  shrinkIdleTimes?: int32(name='ShrinkIdleTimes', description='The number of consecutive times that a compute node is idle during the resource scale-in check.

Valid values: 2 to 5

Default value: 3

If the parameter is set to 3, a compute node is idle for more than three consecutive times. In this case, the node is released. If a compute node is idle for more than 6 minutes in a row, it is released by default. This is because the default value of the ShrinkIntervalInMinutes parameter is 2.', example='3'),
  shrinkIntervalInMinutes?: int32(name='ShrinkIntervalInMinutes', description='The interval between two consecutive rounds of scale-in. Unit: minutes.

Valid values: 2 to 10

Default value: 2', example='2'),
  spotPriceLimit?: float(name='SpotPriceLimit', description='The maximum hourly price of the compute nodes. The value can be accurate to three decimal places. The parameter takes effect only when `SpotStrategy` is set to `SpotWithPriceLimit`.', example='0.062'),
  spotStrategy?: string(name='SpotStrategy', description='The preemption policy of the compute nodes. Valid values:

*   NoSpot: The compute nodes are pay-as-you-go instances.
*   SpotWithPriceLimit: The compute nodes are preemptible instances that have a user-defined maximum hourly price.
*   SpotAsPriceGo: The compute nodes are preemptible instances for which the market price at the time of purchase is used as the bid price.

Default value: NoSpot', example='SpotWithPriceLimit'),
}

model SetAutoScaleConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-13358736C-A1D7-6C044FE7****'),
}

model SetAutoScaleConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetAutoScaleConfigResponseBody(name='body'),
}

/**
  * If you specify different auto scaling settings in the Queue Configuration section and Global Configurations section on the Auto Scale page, the settings in the Queue Configuration section prevail.
  *
  * @param request SetAutoScaleConfigRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return SetAutoScaleConfigResponse
 */
async function setAutoScaleConfigWithOptions(request: SetAutoScaleConfigRequest, runtime: Util.RuntimeOptions): SetAutoScaleConfigResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetAutoScaleConfig',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * If you specify different auto scaling settings in the Queue Configuration section and Global Configurations section on the Auto Scale page, the settings in the Queue Configuration section prevail.
  *
  * @param request SetAutoScaleConfigRequest
  * @return SetAutoScaleConfigResponse
 */
async function setAutoScaleConfig(request: SetAutoScaleConfigRequest): SetAutoScaleConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return setAutoScaleConfigWithOptions(request, runtime);
}

model SetGWSClusterPolicyRequest {
  asyncMode?: boolean(name='AsyncMode', description='Specifies whether to support the asynchronous calls.

*   false: not supported. The result is returned after the request is completed.
*   true: supported. The result is immediately returned while the request is being processed.

Default value: false.', example='true'),
  clipboard?: string(name='Clipboard', description='The permissions on the clipboard. Valid values:

*   read: read-only. You can copy data from your local computer to the cloud desktop, but cannot copy data from the cloud desktop to your local computer.
*   readwrite: read and write. You can copy data between your local computer and the cloud desktop.
*   off: disabled. You cannot copy data between your local computer and the cloud desktop.

Default value: off.', example='readwrite'),
  clusterId?: string(name='ClusterId', description='The ID of the visualization service.', example='gws-rhz99q8rc****'),
  localDrive?: string(name='LocalDrive', description='The permissions on local disk mapping. Valid values:

*   read: read-only. The disks on your local computer are mapped to the cloud desktop. You can only read (copy) files on the local computer, but cannot modify the files.
*   readwrite: read and write. The disks on your local computer are mapped to the cloud desktop. You can read (copy) and modify files on your local computer.
*   off: disabled. The disks on your local computer are not mapped to the cloud desktop.

Default value: off.', example='read'),
  udpPort?: string(name='UdpPort', description='The UDP port. Valid values:

*   on
*   off

Default value: on.', example='on'),
  usbRedirect?: string(name='UsbRedirect', description='The USB redirection feature. Valid values:

*   on
*   off

Default value: off.', example='on'),
  watermark?: string(name='Watermark', description='The watermarking feature. Valid values:

*   on
*   off

Default value: off.', example='on'),
}

model SetGWSClusterPolicyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='142951B5-815A-4324-B598-6E1C11FBF6E4'),
}

model SetGWSClusterPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetGWSClusterPolicyResponseBody(name='body'),
}

async function setGWSClusterPolicyWithOptions(request: SetGWSClusterPolicyRequest, runtime: Util.RuntimeOptions): SetGWSClusterPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.asyncMode)) {
    query['AsyncMode'] = request.asyncMode;
  }
  if (!Util.isUnset(request.clipboard)) {
    query['Clipboard'] = request.clipboard;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.localDrive)) {
    query['LocalDrive'] = request.localDrive;
  }
  if (!Util.isUnset(request.udpPort)) {
    query['UdpPort'] = request.udpPort;
  }
  if (!Util.isUnset(request.usbRedirect)) {
    query['UsbRedirect'] = request.usbRedirect;
  }
  if (!Util.isUnset(request.watermark)) {
    query['Watermark'] = request.watermark;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetGWSClusterPolicy',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setGWSClusterPolicy(request: SetGWSClusterPolicyRequest): SetGWSClusterPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return setGWSClusterPolicyWithOptions(request, runtime);
}

model SetGWSInstanceNameRequest {
  instanceId?: string(name='InstanceId', example='i-bp1bzqq4rj1eemun****'),
  name?: string(name='Name', example='c0-i01-1-g6-2c8g'),
}

model SetGWSInstanceNameResponseBody = {
  requestId?: string(name='RequestId', example='0505220-2409-4B78-B7B6-CD5F294518C9'),
}

model SetGWSInstanceNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetGWSInstanceNameResponseBody(name='body'),
}

async function setGWSInstanceNameWithOptions(request: SetGWSInstanceNameRequest, runtime: Util.RuntimeOptions): SetGWSInstanceNameResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetGWSInstanceName',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setGWSInstanceName(request: SetGWSInstanceNameRequest): SetGWSInstanceNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return setGWSInstanceNameWithOptions(request, runtime);
}

model SetGWSInstanceUserRequest {
  instanceId?: string(name='InstanceId', description='The ID of the visualization instance.', example='i-bp1bzqq4rj1eemun****'),
  userName?: string(name='UserName', description='The name of the user.', example='test_****'),
  userUid?: string(name='UserUid', description='The ID of the user.', example='217346586905362****'),
}

model SetGWSInstanceUserResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CDC4FF2F-62DB-48D2-B342-A3B9E2684B99rrwr'),
}

model SetGWSInstanceUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetGWSInstanceUserResponseBody(name='body'),
}

async function setGWSInstanceUserWithOptions(request: SetGWSInstanceUserRequest, runtime: Util.RuntimeOptions): SetGWSInstanceUserResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetGWSInstanceUser',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setGWSInstanceUser(request: SetGWSInstanceUserRequest): SetGWSInstanceUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return setGWSInstanceUserWithOptions(request, runtime);
}

model SetPostScriptsRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-sh-EnjshUxn'),
  postInstallScripts?: [ 
    {
      args?: string(name='Args', description='The parameter that is used to run the Nth post-installation script. Valid values of N: 1 to 16.', example='-h'),
      url?: string(name='Url', description='The URL that is used to download the Nth post-installation script. Valid values of N: 1 to 16.', example='https://bucket.oss-cn-shanghai.aliyuncs.com/postscript_examples.sh'),
    }
  ](name='PostInstallScripts'),
  regionId?: string(name='RegionId', description='The ID of the region where the cluster resides. You can call the [ListRegions](~~188593~~) operation to query the latest region list.', example='cn-shanghai'),
}

model SetPostScriptsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='B745C159-3155-4B94-95D0-4B73D4D2****'),
}

model SetPostScriptsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetPostScriptsResponseBody(name='body'),
}

async function setPostScriptsWithOptions(request: SetPostScriptsRequest, runtime: Util.RuntimeOptions): SetPostScriptsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetPostScripts',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setPostScripts(request: SetPostScriptsRequest): SetPostScriptsResponse {
  var runtime = new Util.RuntimeOptions{};
  return setPostScriptsWithOptions(request, runtime);
}

model SetQueueRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****'),
  node?: [ 
    {
      name?: string(name='Name', description='The name of the compute node that you want to move. Valid values of N: 1 to 100.

You can call the [ListNodes](~~87161~~) operation to query the names of the compute nodes.', example='compute1'),
    }
  ](name='Node'),
  queueName?: string(name='QueueName', description='The name of the destination queue.

You can call the [ListQueues](~~92176~~) operation to query the queue name.', example='work'),
}

model SetQueueResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='DFC3EAA9-F11F-4ED0-836F-4FFCB279E700'),
}

model SetQueueResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetQueueResponseBody(name='body'),
}

async function setQueueWithOptions(request: SetQueueRequest, runtime: Util.RuntimeOptions): SetQueueResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetQueue',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setQueue(request: SetQueueRequest): SetQueueResponse {
  var runtime = new Util.RuntimeOptions{};
  return setQueueWithOptions(request, runtime);
}

model SetSchedulerInfoRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****'),
  pbsInfo?: [ 
    {
      aclLimit?: [ 
        {
          aclUsers?: string(name='AclUsers', description='The user that can use the queue. Separate multiple users with commas (`,`).

If you specify users, you must specify the PbsInfo.N.AclLimit.N.Queue parameter.', example='user1,user2'),
          queue?: string(name='Queue', description='AclLimit specifies the queue that has limits when it is used. Valid values of N: 0 to 100.

If you set `PbsInfo.N.AclLimit.N.Queue` to `workq` and `PbsInfo.N.AclLimit.N.AclUsers` to `user1,user2`, workq can be used only by user1 and user2.', example='workq'),
        }
      ](name='AclLimit'),
      jobHistoryDuration?: int32(name='JobHistoryDuration', description='The retention period of jobs. After the retention period is exceeded, job data is deleted. Unit: days.

Valid values: 1 to 30

Default value: 14', example='14'),
      resourceLimit?: [ 
        {
          cpus?: int32(name='Cpus', description='The maximum number of vCPUs that can be used for nodes in a queue.', example='2'),
          maxJobs?: int32(name='MaxJobs', description='The maximum number of jobs that can be submitted to the cluster. If the total number of running jobs and queuing jobs exceeds the value, no more jobs can be submitted.', example='1000'),
          mem?: string(name='Mem', description='The maximum memory resources that can be used in a queue. Units:

*   gb
*   mb
*   kb', example='2gb'),
          nodes?: int32(name='Nodes', description='The maximum number of nodes that can be used in a queue.', example='2'),
          queue?: string(name='Queue', description='PbsInfo specifies the number of PBS schedulers that can be configured in the cluster. Valid values of N: 0 to 100.

ResourceLimit specifies the maximum number of queue resources that can be used. Valid values of N: 0 to 100.

Queue specifies the name of the queue that is used to run jobs.

If one of the User, Cpus, Nodes, and Mem parameters is set in ResourceLimit, you must specify the Queue parameter.', example='workq'),
          user?: string(name='User', description='The name of the user that runs jobs.', example='user1'),
        }
      ](name='ResourceLimit'),
      schedInterval?: int32(name='SchedInterval', description='PbsInfo specifies the number of PBS schedulers that can be configured in the cluster. Valid values of N: 0 to 100.

SchedInterval specifies the scheduling period. Unit: seconds.

A scheduling period is the interval between two consecutive running jobs. If you set SchedInterval to 60, another job can be run 60 seconds after a job starts running.

Default value: 60', example='60'),
      schedMaxJobs?: int32(name='SchedMaxJobs', description='The maximum number of jobs that can be scheduled in the cluster. If the total number of running jobs and queuing jobs exceeds the value, no more jobs can be submitted. Default value: 20000.', example='20000'),
      schedMaxQueuedJobs?: int32(name='SchedMaxQueuedJobs', description='The maximum number of queuing jobs that can be scheduled in the cluster. If the number of queuing jobs exceeds the value, no more jobs can be submitted. Default value: 10000.', example='10000'),
    }
  ](name='PbsInfo'),
  regionId?: string(name='RegionId', description='The ID of the region.

You can call the [ListRegions](~~188593~~) operation to obtain the IDs of regions supported by Elastic High Performance Computing (E-HPC).', example='cn-hangzhou'),
  scheduler?: [ 
    {
      schedName?: string(name='SchedName', description='The name of the scheduler. Valid values:

*   pbs
*   pbs19
*   slurm
*   slurm19
*   slurm20

>  If you set Scheduler.N.SchedName to pbs or pbs19, you must specify at least one of the PbsInfo.N.SchedInterval, PbsInfo.N.JobHistoryDuration, and PbsInfo.N.AclLimit parameters. If you set Scheduler.N.SchedName to slurm, slurm19, or slurm20, you must specify at least one of the SlurmInfo.N.SchedInterval and SlurmInfo.N.BackfillInterval parameters.', example='pbs'),
    }
  ](name='Scheduler'),
  slurmInfo?: [ 
    {
      backfillInterval?: int32(name='BackfillInterval', description='The backfill scheduling period. Unit: seconds.

Default value: 60', example='60'),
      schedInterval?: int32(name='SchedInterval', description='SlurmInfo specifies the number of Slurm schedulers that can be configured in the cluster. Valid values of N: 0 to 100.

SchedInterval specifies the scheduling period. Unit: seconds.

Default value: 60', example='60'),
    }
  ](name='SlurmInfo'),
}

model SetSchedulerInfoResponseBody = {
  message?: string(name='Message', description='The response message.', example='pbs: scheduler setting successfully.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='BBC2F93D-003A-49C4-850C-B826EECF****'),
}

model SetSchedulerInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetSchedulerInfoResponseBody(name='body'),
}

async function setSchedulerInfoWithOptions(request: SetSchedulerInfoRequest, runtime: Util.RuntimeOptions): SetSchedulerInfoResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetSchedulerInfo',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setSchedulerInfo(request: SetSchedulerInfoRequest): SetSchedulerInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return setSchedulerInfoWithOptions(request, runtime);
}

model StartClusterRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster that you want to start.', example='ehpc-hz-FYUr32****'),
}

model StartClusterResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='76E1ADE7-D15A-457F-AAFD-06C5A5F052D0'),
  taskId?: string(name='TaskId', description='The ID of the task.', example='76E1ADE7-D15A-457F-AAFD-06C5A5F052D0'),
}

model StartClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartClusterResponseBody(name='body'),
}

async function startClusterWithOptions(request: StartClusterRequest, runtime: Util.RuntimeOptions): StartClusterResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartCluster',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startCluster(request: StartClusterRequest): StartClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return startClusterWithOptions(request, runtime);
}

model StartGWSInstanceRequest {
  instanceId?: string(name='InstanceId', description='The ID of the visualization instance.', example='i-bp1bzqq4rj1eemun****'),
}

model StartGWSInstanceResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model StartGWSInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartGWSInstanceResponseBody(name='body'),
}

async function startGWSInstanceWithOptions(request: StartGWSInstanceRequest, runtime: Util.RuntimeOptions): StartGWSInstanceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartGWSInstance',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startGWSInstance(request: StartGWSInstanceRequest): StartGWSInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return startGWSInstanceWithOptions(request, runtime);
}

model StartNodesRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****'),
  instance?: [ 
    {
      id?: string(name='Id', description='The ID of the Nth node. Valid values of N: 1 to 100.

Make sure that the node is in the Stopped state. You can call the [ListNodes](~~87161~~) operation to query the status of the node.', example='i-bp13p7vlcb1uihfv****'),
    }
  ](name='Instance'),
  role?: string(name='Role', description='The role of the node. Valid values:

*   Manager: management node
*   Login: logon node
*   Compute: compute node

Default value: Compute', example='Compute'),
}

model StartNodesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  taskId?: string(name='TaskId', description='The ID of the task.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model StartNodesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartNodesResponseBody(name='body'),
}

async function startNodesWithOptions(request: StartNodesRequest, runtime: Util.RuntimeOptions): StartNodesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartNodes',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startNodes(request: StartNodesRequest): StartNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return startNodesWithOptions(request, runtime);
}

model StartVisualServiceRequest {
  cidrIp?: string(name='CidrIp', description='A public IP address of logon nodes in the cluster.', example='190.100.**.**'),
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-jeJki6****'),
  port?: int32(name='Port', description='The fixed port. Set the value to 12016', example='12016'),
}

model StartVisualServiceResponseBody = {
  message?: string(name='Message', description='The status of the VNC Remote visualization service. Valid values:

*   Service started
*   Service stopped', example='StartVisualService'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='896D338C-E4F4-41EC-A154-D605E5DE6880'),
}

model StartVisualServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartVisualServiceResponseBody(name='body'),
}

async function startVisualServiceWithOptions(request: StartVisualServiceRequest, runtime: Util.RuntimeOptions): StartVisualServiceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartVisualService',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startVisualService(request: StartVisualServiceRequest): StartVisualServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return startVisualServiceWithOptions(request, runtime);
}

model StopClusterRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****'),
}

model StopClusterResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  taskId?: string(name='TaskId', description='The ID of the task.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model StopClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopClusterResponseBody(name='body'),
}

/**
  * If you stop a subscription compute node, its billing is not affected. If you stop a pay-as-you-go compute node for which you have enabled the *economical mode*, you are no longer charged for its computing resources. For more information, see [Economical mode](~~63353~~).
  *
  * @param request StopClusterRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return StopClusterResponse
 */
async function stopClusterWithOptions(request: StopClusterRequest, runtime: Util.RuntimeOptions): StopClusterResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopCluster',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * If you stop a subscription compute node, its billing is not affected. If you stop a pay-as-you-go compute node for which you have enabled the *economical mode*, you are no longer charged for its computing resources. For more information, see [Economical mode](~~63353~~).
  *
  * @param request StopClusterRequest
  * @return StopClusterResponse
 */
async function stopCluster(request: StopClusterRequest): StopClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopClusterWithOptions(request, runtime);
}

model StopGWSInstanceRequest {
  instanceId?: string(name='InstanceId', example='i-bp1bzqq4rj1eemun****'),
}

model StopGWSInstanceResponseBody = {
  requestId?: string(name='RequestId', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model StopGWSInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopGWSInstanceResponseBody(name='body'),
}

async function stopGWSInstanceWithOptions(request: StopGWSInstanceRequest, runtime: Util.RuntimeOptions): StopGWSInstanceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopGWSInstance',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopGWSInstance(request: StopGWSInstanceRequest): StopGWSInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopGWSInstanceWithOptions(request, runtime);
}

model StopJobsRequest {
  async?: boolean(name='Async', description='Specifies whether to use an asynchronous link to stop the job.

Default value: false', example='false'),
  clusterId?: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****'),
  jobs?: string(name='Jobs', description='The list of jobs that you want to stop. Maximum number of jobs: 100. Minimum number of jobs: 1.

Format: `[{"Id": "0.sched****"},{"Id": "1.sched****"}]`. Separate multiple jobs with commas (,).

You can call the [ListJobs](~~87251~~) operation to query the job ID.

>  You can stop only jobs that are in the RUNNING or QUEUED state.', example='[{"Id":"1.sched****"},{"Id":"0.sched****"}]'),
}

model StopJobsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model StopJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopJobsResponseBody(name='body'),
}

async function stopJobsWithOptions(request: StopJobsRequest, runtime: Util.RuntimeOptions): StopJobsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopJobs',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopJobs(request: StopJobsRequest): StopJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopJobsWithOptions(request, runtime);
}

model StopNodesRequest {
  clusterId?: string(name='ClusterId', description='The ID of the E-HPC cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****'),
  instance?: [ 
    {
      id?: string(name='Id', description='The ID of the Nth node that you want to stop. Valid values of N: 1 to 100

You can call the [ListNodes](~~87161~~) operation to query the IDs of the compute nodes.', example='i-bp13p7vlcb1uihf****'),
    }
  ](name='Instance'),
  role?: string(name='Role', description='The role of the node. Valid values:

*   Manager: management node
*   Login: logon node
*   Compute: compute node

Default value: Compute', example='Compute'),
}

model StopNodesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  taskId?: string(name='TaskId', description='The ID of the task.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model StopNodesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopNodesResponseBody(name='body'),
}

async function stopNodesWithOptions(request: StopNodesRequest, runtime: Util.RuntimeOptions): StopNodesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopNodes',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopNodes(request: StopNodesRequest): StopNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopNodesWithOptions(request, runtime);
}

model StopVisualServiceRequest {
  cidrIp?: string(name='CidrIp', description='A public IP address of login nodes in the cluster.', example='100.168.**.**'),
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-jeJki6****'),
  port?: int32(name='Port', description='The fixed port. Set the value to 12016.', example='12016'),
}

model StopVisualServiceResponseBody = {
  message?: string(name='Message', description='The status of the VNC Remote Service. Valid values:

*   Service started
*   Service stopped', example='Service stopped'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='896D338C-E4F4-41EC-A154-D605E5DE6880'),
}

model StopVisualServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopVisualServiceResponseBody(name='body'),
}

async function stopVisualServiceWithOptions(request: StopVisualServiceRequest, runtime: Util.RuntimeOptions): StopVisualServiceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopVisualService',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopVisualService(request: StopVisualServiceRequest): StopVisualServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopVisualServiceWithOptions(request, runtime);
}

model SubmitJobRequest {
  jobRetry?: {
    count?: int32(name='Count'),
    onExitCode?: int32(name='OnExitCode'),
    priority?: int32(name='Priority'),
  }(name='JobRetry'),
  arrayRequest?: string(name='ArrayRequest', description='The job array.

Format: X-Y:Z. The minimum index value X is the first index. The maximum index value Y is the last index. Z is the step size. For example, 2-7:2 indicates that three jobs need to be run and their index values are 2, 4, and 6.', example='1-10:2'),
  async?: boolean(name='Async', description='Specifies whether to use an asynchronous link to submit the job.

Default value: false.', example='false'),
  clockTime?: string(name='ClockTime', description='The maximum running time of the job. Valid formats:

*   hh:mm:ss
*   mm:ss
*   ss

We recommend that you use the hh:mm:ss format. If the maximum running time is 12 hours, set the value to 12:00:00.', example='12:00:00'),
  clusterId?: string(name='ClusterId', description='The cluster ID.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****'),
  commandLine?: string(name='CommandLine', description='The command that is used to run the job.', example='./LammpsTest/lammps.pbs'),
  containerId?: string(name='ContainerId', description='The ID of the containerized application. If you want to use a container application, you must specify its ID.

You can call the [ListContainerApps](~~87333~~) operation to query the container application ID.', example='ehpc-container-uerfrfffff****'),
  cpu?: int32(name='Cpu', description='The number of CPU cores required by a single compute node.', example='2'),
  gpu?: int32(name='Gpu', description='The maximum GPU usage required by a single compute node.

The parameter takes effect only when the cluster uses PBS and a compute node is a GPU-accelerated instance.', example='1'),
  inputFileUrl?: string(name='InputFileUrl', description='The URL of the job file that is uploaded to an Object Storage Service (OSS) bucket.', example='https://ehpc-hangzhou.oss-cn-hangzhou.aliyuncs.com/test-u4****/testlist_ehpc.sh'),
  jobQueue?: string(name='JobQueue', description='The name of the queue in which the job is run.

You can call the [ListQueues](~~92176~~) operation to query the name of the queue.', example='workq'),
  mem?: string(name='Mem', description='The maximum memory usage required by a single compute node. Unit: GB, MB, or KB. The unit is case-insensitive.', example='1GB'),
  name?: string(name='Name', description='The name of the job. The name must be 6 to 30 characters in length and start with a letter. It can contain letters, digits, and periods (.).', example='job1'),
  node?: int32(name='Node', description='The number of compute nodes required to run the job.

> If the parameter is not specified, the Cpu, Task, Thread, Mem, and Gpu parameters become invalid.', example='2'),
  packagePath?: string(name='PackagePath', description='The path that is used to run the job.', example='./Tem'),
  postCmdLine?: string(name='PostCmdLine', description='The command to perform on the job after the job is submitted.', example='example.sh'),
  priority?: int32(name='Priority', description='The priority of the job. Valid values: 0 to 9. A larger value indicates a higher priority.

Default value: 0.', example='0'),
  reRunable?: boolean(name='ReRunable', description='Specifies whether the job can be rerun. Valid values:

*   true: The job can be rerun.
*   false: The job cannot be rerun.', example='false'),
  runasUser?: string(name='RunasUser', description='The name of the user that runs the job.

You can call the [ListUsers](~~188572~~) operation to query the users of the cluster.', example='testuser'),
  runasUserPassword?: string(name='RunasUserPassword', description='The password that corresponds to the username.', example='12****'),
  stderrRedirectPath?: string(name='StderrRedirectPath', description='The output file path of stderr.', example='./LammpsTest'),
  stdoutRedirectPath?: string(name='StdoutRedirectPath', description='The output file path of stdout.', example='./LammpsTest'),
  task?: int32(name='Task', description='The number of processes created for a single compute node.

The parameter is applicable to Message Passing Interface (MPI) jobs.', example='2'),
  thread?: int32(name='Thread', description='The number of threads created for a single compute node.

The parameter is applicable to OpenMP jobs.', example='1'),
  unzipCmd?: string(name='UnzipCmd', description='The command for file decompression. The command that is used to decompress the job files downloaded from an OSS bucket. Valid values:

*   tar xzf: Decompresses GZIP files.
*   tar xf: Decompresses TAR files.
*   unzip: Decompresses ZIP files.', example='tar xzf'),
  variables?: string(name='Variables', description='The runtime variables passed to the job. They can be accessed by using environment variables in the executable file.', example='[{Name:test1,Value:value1},{Name:test2,Value:value2}]'),
}

model SubmitJobResponseBody = {
  jobId?: string(name='JobId', description='The ID of the job.', example='1.manager'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model SubmitJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitJobResponseBody(name='body'),
}

/**
  * ## Description
  * Before you submit a job in a cluster, you must upload a job file to the cluster, for example, job.sh. For more information, see [CreateJobFile](~~159049~~).
  *
  * @param request SubmitJobRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return SubmitJobResponse
 */
async function submitJobWithOptions(request: SubmitJobRequest, runtime: Util.RuntimeOptions): SubmitJobResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitJob',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * ## Description
  * Before you submit a job in a cluster, you must upload a job file to the cluster, for example, job.sh. For more information, see [CreateJobFile](~~159049~~).
  *
  * @param request SubmitJobRequest
  * @return SubmitJobResponse
 */
async function submitJob(request: SubmitJobRequest): SubmitJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitJobWithOptions(request, runtime);
}

model SummaryImagesRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-jeJki6****'),
  containerType?: string(name='ContainerType', description='The type of the image. Set the value to singularity.', example='singularity'),
}

model SummaryImagesResponseBody = {
  imagesName?: string(name='ImagesName', description='The names of all images in the cluster.', example='{"summaryImages":["gromacs.sif","linpack.sif","sccIntelMPI1.sif","test.sif","usergromac.sif.user"]}'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='896D338C-E4F4-41EC-A154-D605E5DE****'),
}

model SummaryImagesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SummaryImagesResponseBody(name='body'),
}

async function summaryImagesWithOptions(request: SummaryImagesRequest, runtime: Util.RuntimeOptions): SummaryImagesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SummaryImages',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function summaryImages(request: SummaryImagesRequest): SummaryImagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return summaryImagesWithOptions(request, runtime);
}

model SummaryImagesInfoRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-ibug699XXX'),
  containerType?: string(name='ContainerType', description='The container type of the image. Set the value to singularity.', example='singularity'),
  imageName?: string(name='ImageName', description='The name of the image. You can call the [SummaryImages](~~440783~~) operation to query the names of all images in a cluster.', example='test.sif'),
}

model SummaryImagesInfoResponseBody = {
  imagesInfo?: string(name='ImagesInfo', description='The detailed information about the image.', example='{"summaryImagesInfo":[{"ImageName":"gromacs.sif","ImageSize":"4","CreateTime":"16:18","CreateDate":"Apr.1"},{"ImageName":"linpack.sif","ImageSize":"665847525","CreateTime":"14:45","CreateDate":"Apr.1"},{"ImageName":"sccIntelMPI1.sif","ImageSize":"665847525","CreateTime":"14:41","CreateDate":"Apr.1"},{"ImageName":"test.sif","ImageSize":"24","CreateTime":"12:25","CreateDate":"Apr.20"},{"ImageName":"usergromac.sif.user","ImageSize":"4","CreateTime":"15:16","CreateDate":"Apr.19"}]}'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='896D338C-E4F4-41EC-A154-D605E5DE****'),
}

model SummaryImagesInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SummaryImagesInfoResponseBody(name='body'),
}

async function summaryImagesInfoWithOptions(request: SummaryImagesInfoRequest, runtime: Util.RuntimeOptions): SummaryImagesInfoResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SummaryImagesInfo',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function summaryImagesInfo(request: SummaryImagesInfoRequest): SummaryImagesInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return summaryImagesInfoWithOptions(request, runtime);
}

model SyncUsersRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the list of E-HPC clusters.', example='ehpc-hz-gh5WKb****'),
  regionId?: string(name='RegionId', description='The ID of the region where the cluster resides.

You can call the [ListRegions](~~188593~~) operation to query the list of regions where E-HPC is available.', example='cn-hangzhou'),
}

model SyncUsersResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model SyncUsersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SyncUsersResponseBody(name='body'),
}

async function syncUsersWithOptions(request: SyncUsersRequest, runtime: Util.RuntimeOptions): SyncUsersResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SyncUsers',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function syncUsers(request: SyncUsersRequest): SyncUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return syncUsersWithOptions(request, runtime);
}

model TagResourcesRequest {
  regionId?: string(name='RegionId', description='The ID of the region to which the resource belongs.', example='cn-hangzhou'),
  resourceId?: [ string ](name='ResourceId'),
  resourceType?: string(name='ResourceType', description='The type of the resource. Set the value to cluster, which indicates E-HPC clusters.', example='cluster'),
  tag?: [ 
    {
      key?: string(name='Key', description='The key of the tag. The tag key cannot be an empty string. It can be up to 128 characters in length and cannot contain `http://` or `https://`. It must not start with `acs:` or `aliyun`.', example='TestKey'),
      value?: string(name='Value', description='The value of the tag. The tag key cannot be an empty string. It can be up to 128 characters in length and cannot contain `http://` or `https://`. It must not start with `acs:` or `aliyun`.', example='TestValue'),
    }
  ](name='Tag'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResourcesWithOptions(request: TagResourcesRequest, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TagResources',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagResourcesWithOptions(request, runtime);
}

model UnTagResourcesRequest {
  all?: boolean(name='All', description='Specifies whether to remove all tags from the resource. This parameter is valid only when the TagKey.N parameter is not specified. Valid values:

*   true
*   false

Default value: false', example='false'),
  regionId?: string(name='RegionId', description='The ID of the region to which the resource belongs.', example='cn-hangzhou'),
  resourceId?: [ string ](name='ResourceId'),
  resourceType?: string(name='ResourceType', description='The type of the resource. Set the value to cluster, which indicates E-HPC clusters.', example='cluster'),
  tagKey?: [ string ](name='TagKey'),
}

model UnTagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model UnTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UnTagResourcesResponseBody(name='body'),
}

async function unTagResourcesWithOptions(request: UnTagResourcesRequest, runtime: Util.RuntimeOptions): UnTagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.all)) {
    query['All'] = request.all;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagKey)) {
    query['TagKey'] = request.tagKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UnTagResources',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function unTagResources(request: UnTagResourcesRequest): UnTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return unTagResourcesWithOptions(request, runtime);
}

model UninstallSoftwareRequest {
  application?: string(name='Application', description='The name of the software that you want to uninstall.

You can call the [ListInstalledSoftware](~~188591~~) operation to query the software that is installed in the cluster.', example='ABYSS_2.1.5'),
  clusterId?: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-jeJki6****'),
}

model UninstallSoftwareResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='C84FB8EF-5580-4B82-9BDE-6657814C****'),
}

model UninstallSoftwareResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UninstallSoftwareResponseBody(name='body'),
}

async function uninstallSoftwareWithOptions(request: UninstallSoftwareRequest, runtime: Util.RuntimeOptions): UninstallSoftwareResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UninstallSoftware',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function uninstallSoftware(request: UninstallSoftwareRequest): UninstallSoftwareResponse {
  var runtime = new Util.RuntimeOptions{};
  return uninstallSoftwareWithOptions(request, runtime);
}

model UpdateClusterVolumesRequest {
  additionalVolumes?: [ 
    {
      jobQueue?: string(name='JobQueue', description='The queue name of the nth attached mounted filesystem.', example='work'),
      localDirectory?: string(name='LocalDirectory', description='The on-premises mount directory for the nth additional mounted file system.', example='/ff'),
      location?: string(name='Location', description='The storage location of the nth attached mounted file system. Valid values:

*   OnPremise: hybrid cloud cluster
*   PublicCloud: public cloud cluster', example='PublicCloud'),
      remoteDirectory?: string(name='RemoteDirectory', description='The remote directory to be mounted by the nth additional mounted file system.', example='/test'),
      roles?: [ 
        {
          name?: string(name='Name', description='The node type on which the nth additional mounted file system is mounted. Valid values:

*   Manager: management node
*   Login: logon node
*   Compute: compute node', example='["Compute"]'),
        }
      ](name='Roles'),
      volumeId?: string(name='VolumeId', description='The ID of the nth additional mounted file system.', example='extreme-00b88****'),
      volumeMountOption?: string(name='VolumeMountOption'),
      volumeMountpoint?: string(name='VolumeMountpoint', description='The domain name of the mount target for the nth additional mounted file system.', example='0088****-sihc.cn-hangzhou.extreme.nas.aliyuncs.com'),
      volumeProtocol?: string(name='VolumeProtocol', description='The protocol type of the nth additional mounted file system. Valid values:

*   NFS
*   SMB', example='NFS'),
      volumeType?: string(name='VolumeType', description='The type of the nth additional mounted file system. Currently, only NAS is supported.

Valid values of N: 1 to 10.', example='NAS'),
    }
  ](name='AdditionalVolumes'),
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-FYUr32****'),
}

model UpdateClusterVolumesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F6757FA4-8FED-4602-B7F5-3550C0842122'),
}

model UpdateClusterVolumesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateClusterVolumesResponseBody(name='body'),
}

async function updateClusterVolumesWithOptions(request: UpdateClusterVolumesRequest, runtime: Util.RuntimeOptions): UpdateClusterVolumesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateClusterVolumes',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateClusterVolumes(request: UpdateClusterVolumesRequest): UpdateClusterVolumesResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateClusterVolumesWithOptions(request, runtime);
}

model UpdateQueueConfigRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.

You can call the [ListClusters](~~87116~~) operation to query the cluster ID.', example='ehpc-hz-FYUr32****'),
  computeInstanceType?: string(name='ComputeInstanceType', description='The instance type of the node.

You can call the [ListPreferredEcsTypes](~~188592~~) operation to query the recommended instance types.', example='ecs.n1.tiny'),
  queueName?: string(name='QueueName', description='The name of the queue.', example='workq'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.

You can call the [ListResourceGroups](~~158855~~) operation to query the IDs of resource groups.', example='rg-acfmxazb4ph****'),
}

model UpdateQueueConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5198C3E8-85F5-4280-8547-687C1710****'),
}

model UpdateQueueConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateQueueConfigResponseBody(name='body'),
}

/**
  * After you update the instance types of a resource group, the nodes that you add by scaling out the cluster are automatically included in the resource group.
  *
  * @param request UpdateQueueConfigRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateQueueConfigResponse
 */
async function updateQueueConfigWithOptions(request: UpdateQueueConfigRequest, runtime: Util.RuntimeOptions): UpdateQueueConfigResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateQueueConfig',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * After you update the instance types of a resource group, the nodes that you add by scaling out the cluster are automatically included in the resource group.
  *
  * @param request UpdateQueueConfigRequest
  * @return UpdateQueueConfigResponse
 */
async function updateQueueConfig(request: UpdateQueueConfigRequest): UpdateQueueConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateQueueConfigWithOptions(request, runtime);
}

model UpgradeClientRequest {
  clientVersion?: string(name='ClientVersion', description='The version to which the client will be upgraded. By default, the client is upgraded to the latest version. You can call the [ListCurrentClientVersion](~~87223~~) operation to query the latest version number of the Elastic High Performance Computing (E-HPC) client.', example='2.0.0'),
  clusterId?: string(name='ClusterId', description='The ID of the cluster.', example='ehpc-hz-FYUr32****'),
}

model UpgradeClientResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='4994fbcd-2a09-4045-b2b2-2c3bee8e9296'),
}

model UpgradeClientResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpgradeClientResponseBody(name='body'),
}

async function upgradeClientWithOptions(request: UpgradeClientRequest, runtime: Util.RuntimeOptions): UpgradeClientResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpgradeClient',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function upgradeClient(request: UpgradeClientRequest): UpgradeClientResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeClientWithOptions(request, runtime);
}

