/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('ehpc', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model AddContainerAppRequest {
  name?: string(name='Name'),
  repository?: string(name='Repository'),
  description?: string(name='Description'),
  imageTag?: string(name='ImageTag'),
  containerType?: string(name='ContainerType'),
}

model AddContainerAppResponseBody = {
  requestId?: string(name='RequestId'),
  containerId?: {
    containerId?: [ string ](name='ContainerId')
  }(name='ContainerId'),
}

model AddContainerAppResponse = {
  headers: map[string]string(name='headers'),
  body: AddContainerAppResponseBody(name='body'),
}

async function addContainerAppWithOptions(request: AddContainerAppRequest, runtime: Util.RuntimeOptions): AddContainerAppResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('AddContainerApp', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function addContainerApp(request: AddContainerAppRequest): AddContainerAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return addContainerAppWithOptions(request, runtime);
}

model AddLocalNodesRequest {
  clusterId?: string(name='ClusterId'),
  nodes?: string(name='Nodes'),
}

model AddLocalNodesResponseBody = {
  requestId?: string(name='RequestId'),
  instanceIds?: {
    instanceId?: [ string ](name='InstanceId')
  }(name='InstanceIds'),
}

model AddLocalNodesResponse = {
  headers: map[string]string(name='headers'),
  body: AddLocalNodesResponseBody(name='body'),
}

async function addLocalNodesWithOptions(request: AddLocalNodesRequest, runtime: Util.RuntimeOptions): AddLocalNodesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('AddLocalNodes', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function addLocalNodes(request: AddLocalNodesRequest): AddLocalNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return addLocalNodesWithOptions(request, runtime);
}

model AddNodesRequest {
  clusterId?: string(name='ClusterId'),
  imageOwnerAlias?: string(name='ImageOwnerAlias'),
  imageId?: string(name='ImageId'),
  count?: int32(name='Count'),
  instanceType?: string(name='InstanceType'),
  computeSpotStrategy?: string(name='ComputeSpotStrategy'),
  computeSpotPriceLimit?: string(name='ComputeSpotPriceLimit'),
  ecsChargeType?: string(name='EcsChargeType'),
  period?: int32(name='Period'),
  periodUnit?: string(name='PeriodUnit'),
  autoRenew?: string(name='AutoRenew'),
  autoRenewPeriod?: int32(name='AutoRenewPeriod'),
  jobQueue?: string(name='JobQueue'),
  createMode?: string(name='CreateMode'),
  systemDiskType?: string(name='SystemDiskType'),
  systemDiskSize?: int32(name='SystemDiskSize'),
  zoneId?: string(name='ZoneId'),
  vSwitchId?: string(name='VSwitchId'),
  hostNamePrefix?: string(name='HostNamePrefix'),
  hostNameSuffix?: string(name='HostNameSuffix'),
  computeEnableHt?: boolean(name='ComputeEnableHt'),
  allocatePublicAddress?: boolean(name='AllocatePublicAddress'),
  internetChargeType?: string(name='InternetChargeType'),
  internetMaxBandWidthIn?: int32(name='InternetMaxBandWidthIn'),
  internetMaxBandWidthOut?: int32(name='InternetMaxBandWidthOut'),
  clientToken?: string(name='ClientToken'),
  systemDiskLevel?: string(name='SystemDiskLevel'),
}

model AddNodesResponseBody = {
  taskId?: string(name='TaskId'),
  requestId?: string(name='RequestId'),
  instanceIds?: {
    instanceId?: [ string ](name='InstanceId')
  }(name='InstanceIds'),
}

model AddNodesResponse = {
  headers: map[string]string(name='headers'),
  body: AddNodesResponseBody(name='body'),
}

async function addNodesWithOptions(request: AddNodesRequest, runtime: Util.RuntimeOptions): AddNodesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('AddNodes', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function addNodes(request: AddNodesRequest): AddNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return addNodesWithOptions(request, runtime);
}

model AddQueueRequest {
  clusterId?: string(name='ClusterId'),
  queueName?: string(name='QueueName'),
}

model AddQueueResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddQueueResponse = {
  headers: map[string]string(name='headers'),
  body: AddQueueResponseBody(name='body'),
}

async function addQueueWithOptions(request: AddQueueRequest, runtime: Util.RuntimeOptions): AddQueueResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('AddQueue', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function addQueue(request: AddQueueRequest): AddQueueResponse {
  var runtime = new Util.RuntimeOptions{};
  return addQueueWithOptions(request, runtime);
}

model AddSecurityGroupRequest {
  clusterId?: string(name='ClusterId'),
  securityGroupId?: string(name='SecurityGroupId'),
  clientToken?: string(name='ClientToken'),
}

model AddSecurityGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddSecurityGroupResponse = {
  headers: map[string]string(name='headers'),
  body: AddSecurityGroupResponseBody(name='body'),
}

async function addSecurityGroupWithOptions(request: AddSecurityGroupRequest, runtime: Util.RuntimeOptions): AddSecurityGroupResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('AddSecurityGroup', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function addSecurityGroup(request: AddSecurityGroupRequest): AddSecurityGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return addSecurityGroupWithOptions(request, runtime);
}

model AddUsersRequest {
  clusterId?: string(name='ClusterId'),
  user?: [ 
    {
      password?: string(name='Password'),
      name?: string(name='Name'),
      group?: string(name='Group'),
    }
  ](name='User'),
}

model AddUsersResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddUsersResponse = {
  headers: map[string]string(name='headers'),
  body: AddUsersResponseBody(name='body'),
}

async function addUsersWithOptions(request: AddUsersRequest, runtime: Util.RuntimeOptions): AddUsersResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('AddUsers', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function addUsers(request: AddUsersRequest): AddUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return addUsersWithOptions(request, runtime);
}

model ApplyNodesRequest {
  clusterId?: string(name='ClusterId'),
  imageId?: string(name='ImageId'),
  computeSpotStrategy?: string(name='ComputeSpotStrategy'),
  computeSpotPriceLimit?: float(name='ComputeSpotPriceLimit'),
  systemDiskType?: string(name='SystemDiskType'),
  systemDiskSize?: int32(name='SystemDiskSize'),
  hostNamePrefix?: string(name='HostNamePrefix'),
  hostNameSuffix?: string(name='HostNameSuffix'),
  allocatePublicAddress?: boolean(name='AllocatePublicAddress'),
  internetChargeType?: string(name='InternetChargeType'),
  internetMaxBandWidthIn?: int32(name='InternetMaxBandWidthIn'),
  internetMaxBandWidthOut?: int32(name='InternetMaxBandWidthOut'),
  cores?: int32(name='Cores'),
  memory?: int32(name='Memory'),
  instanceFamilyLevel?: string(name='InstanceFamilyLevel'),
  targetCapacity?: int32(name='TargetCapacity'),
  resourceAmountType?: string(name='ResourceAmountType'),
  priorityStrategy?: string(name='PriorityStrategy'),
  strictSatisfiedTargetCapacity?: boolean(name='StrictSatisfiedTargetCapacity'),
  systemDiskLevel?: string(name='SystemDiskLevel'),
  zoneInfos?: [ 
    {
      vSwitchId?: string(name='VSwitchId'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='ZoneInfos'),
  instanceTypeModel?: [ 
    {
      maxPrice?: float(name='MaxPrice'),
      targetImageId?: string(name='TargetImageId'),
      instanceType?: string(name='InstanceType'),
    }
  ](name='InstanceTypeModel'),
}

model ApplyNodesResponseBody = {
  taskId?: string(name='TaskId'),
  requestId?: string(name='RequestId'),
  satisfiedAmount?: int32(name='SatisfiedAmount'),
  instanceIds?: {
    instanceId?: [ string ](name='InstanceId')
  }(name='InstanceIds'),
  detail?: string(name='Detail'),
}

model ApplyNodesResponse = {
  headers: map[string]string(name='headers'),
  body: ApplyNodesResponseBody(name='body'),
}

async function applyNodesWithOptions(request: ApplyNodesRequest, runtime: Util.RuntimeOptions): ApplyNodesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ApplyNodes', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function applyNodes(request: ApplyNodesRequest): ApplyNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return applyNodesWithOptions(request, runtime);
}

model BindAccountToClusterUserRequest {
  clusterId?: string(name='ClusterId'),
  userName?: string(name='UserName'),
  userPwd?: string(name='UserPwd'),
  accountUid?: string(name='AccountUid'),
  accountName?: string(name='AccountName'),
}

model BindAccountToClusterUserResponseBody = {
  requestId?: string(name='RequestId'),
}

model BindAccountToClusterUserResponse = {
  headers: map[string]string(name='headers'),
  body: BindAccountToClusterUserResponseBody(name='body'),
}

async function bindAccountToClusterUserWithOptions(request: BindAccountToClusterUserRequest, runtime: Util.RuntimeOptions): BindAccountToClusterUserResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('BindAccountToClusterUser', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function bindAccountToClusterUser(request: BindAccountToClusterUserRequest): BindAccountToClusterUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return bindAccountToClusterUserWithOptions(request, runtime);
}

model CreateClusterRequest {
  ecsOrder?: {
    manager: {
        count?: int32(name='Count'),
        instanceType?: string(name='InstanceType'),
    }(name='Manager'),
    compute: {
        count?: int32(name='Count'),
        instanceType?: string(name='InstanceType'),
    }(name='Compute'),
    login: {
        count?: int32(name='Count'),
        instanceType?: string(name='InstanceType'),
    }(name='Login'),
  }(name='EcsOrder'),
  zoneId?: string(name='ZoneId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  ehpcVersion?: string(name='EhpcVersion'),
  clientVersion?: string(name='ClientVersion'),
  osTag?: string(name='OsTag'),
  accountType?: string(name='AccountType'),
  schedulerType?: string(name='SchedulerType'),
  securityGroupId?: string(name='SecurityGroupId'),
  securityGroupName?: string(name='SecurityGroupName'),
  vpcId?: string(name='VpcId'),
  vSwitchId?: string(name='VSwitchId'),
  volumeType?: string(name='VolumeType'),
  volumeId?: string(name='VolumeId'),
  volumeProtocol?: string(name='VolumeProtocol'),
  volumeMountpoint?: string(name='VolumeMountpoint'),
  remoteDirectory?: string(name='RemoteDirectory'),
  deployMode?: string(name='DeployMode'),
  haEnable?: boolean(name='HaEnable'),
  ecsChargeType?: string(name='EcsChargeType'),
  password?: string(name='Password'),
  keyPairName?: string(name='KeyPairName'),
  imageOwnerAlias?: string(name='ImageOwnerAlias'),
  imageId?: string(name='ImageId'),
  sccClusterId?: string(name='SccClusterId'),
  computeSpotStrategy?: string(name='ComputeSpotStrategy'),
  computeSpotPriceLimit?: string(name='ComputeSpotPriceLimit'),
  computeEnableHt?: boolean(name='ComputeEnableHt'),
  period?: int32(name='Period'),
  periodUnit?: string(name='PeriodUnit'),
  autoRenew?: string(name='AutoRenew'),
  autoRenewPeriod?: int32(name='AutoRenewPeriod'),
  inputFileUrl?: string(name='InputFileUrl'),
  jobQueue?: string(name='JobQueue'),
  systemDiskType?: string(name='SystemDiskType'),
  systemDiskSize?: int32(name='SystemDiskSize'),
  remoteVisEnable?: string(name='RemoteVisEnable'),
  resourceGroupId?: string(name='ResourceGroupId'),
  clientToken?: string(name='ClientToken'),
  withoutElasticIp?: boolean(name='WithoutElasticIp'),
  systemDiskLevel?: string(name='SystemDiskLevel'),
  isComputeEss?: boolean(name='IsComputeEss'),
  application?: [ 
    {
      tag?: string(name='Tag'),
    }
  ](name='Application'),
  additionalVolumes?: [ 
    {
      jobQueue?: string(name='JobQueue'),
      volumeId?: string(name='VolumeId'),
      roles?: [ 
        {
          name?: string(name='Name'),
        }
      ](name='Roles'),
      remoteDirectory?: string(name='RemoteDirectory'),
      volumeMountpoint?: string(name='VolumeMountpoint'),
      localDirectory?: string(name='LocalDirectory'),
      volumeType?: string(name='VolumeType'),
      volumeProtocol?: string(name='VolumeProtocol'),
      location?: string(name='Location'),
    }
  ](name='AdditionalVolumes'),
  postInstallScript?: [ 
    {
      args?: string(name='Args'),
      url?: string(name='Url'),
    }
  ](name='PostInstallScript'),
}

model CreateClusterResponseBody = {
  taskId?: string(name='TaskId'),
  requestId?: string(name='RequestId'),
  clusterId?: string(name='ClusterId'),
}

model CreateClusterResponse = {
  headers: map[string]string(name='headers'),
  body: CreateClusterResponseBody(name='body'),
}

async function createClusterWithOptions(request: CreateClusterRequest, runtime: Util.RuntimeOptions): CreateClusterResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('CreateCluster', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function createCluster(request: CreateClusterRequest): CreateClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return createClusterWithOptions(request, runtime);
}

model CreateGWSClusterRequest {
  vpcId?: string(name='VpcId'),
  clusterType?: string(name='ClusterType'),
  name?: string(name='Name'),
  vSwitchId?: string(name='VSwitchId'),
}

model CreateGWSClusterResponseBody = {
  requestId?: string(name='RequestId'),
  clusterId?: string(name='ClusterId'),
}

model CreateGWSClusterResponse = {
  headers: map[string]string(name='headers'),
  body: CreateGWSClusterResponseBody(name='body'),
}

async function createGWSClusterWithOptions(request: CreateGWSClusterRequest, runtime: Util.RuntimeOptions): CreateGWSClusterResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('CreateGWSCluster', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function createGWSCluster(request: CreateGWSClusterRequest): CreateGWSClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return createGWSClusterWithOptions(request, runtime);
}

model CreateGWSImageRequest {
  instanceId?: string(name='InstanceId'),
  name?: string(name='Name'),
}

model CreateGWSImageResponseBody = {
  requestId?: string(name='RequestId'),
  imageId?: string(name='ImageId'),
}

model CreateGWSImageResponse = {
  headers: map[string]string(name='headers'),
  body: CreateGWSImageResponseBody(name='body'),
}

async function createGWSImageWithOptions(request: CreateGWSImageRequest, runtime: Util.RuntimeOptions): CreateGWSImageResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('CreateGWSImage', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function createGWSImage(request: CreateGWSImageRequest): CreateGWSImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return createGWSImageWithOptions(request, runtime);
}

model CreateGWSInstanceRequest {
  clusterId?: string(name='ClusterId'),
  imageId?: string(name='ImageId'),
  systemDiskSize?: int32(name='SystemDiskSize'),
  systemDiskCategory?: string(name='SystemDiskCategory'),
  instanceType?: string(name='InstanceType'),
  instanceChargeType?: string(name='InstanceChargeType'),
  workMode?: string(name='WorkMode'),
  allocatePublicAddress?: boolean(name='AllocatePublicAddress'),
  internetChargeType?: string(name='InternetChargeType'),
  internetMaxBandwidthIn?: int32(name='InternetMaxBandwidthIn'),
  internetMaxBandwidthOut?: int32(name='InternetMaxBandwidthOut'),
  name?: string(name='Name'),
  period?: string(name='Period'),
  periodUnit?: string(name='PeriodUnit'),
  autoRenew?: boolean(name='AutoRenew'),
  appList?: string(name='AppList'),
  vSwitchId?: string(name='VSwitchId'),
}

model CreateGWSInstanceResponseBody = {
  requestId?: string(name='RequestId'),
  instanceId?: string(name='InstanceId'),
}

model CreateGWSInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateGWSInstanceResponseBody(name='body'),
}

async function createGWSInstanceWithOptions(request: CreateGWSInstanceRequest, runtime: Util.RuntimeOptions): CreateGWSInstanceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('CreateGWSInstance', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function createGWSInstance(request: CreateGWSInstanceRequest): CreateGWSInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createGWSInstanceWithOptions(request, runtime);
}

model CreateHybridClusterRequest {
  ecsOrder?: {
    compute: {
        instanceType?: string(name='InstanceType'),
    }(name='Compute'),
  }(name='EcsOrder'),
  zoneId?: string(name='ZoneId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  ehpcVersion?: string(name='EhpcVersion'),
  clientVersion?: string(name='ClientVersion'),
  osTag?: string(name='OsTag'),
  domain?: string(name='Domain'),
  location?: string(name='Location'),
  securityGroupId?: string(name='SecurityGroupId'),
  securityGroupName?: string(name='SecurityGroupName'),
  vpcId?: string(name='VpcId'),
  vSwitchId?: string(name='VSwitchId'),
  volumeType?: string(name='VolumeType'),
  volumeId?: string(name='VolumeId'),
  volumeProtocol?: string(name='VolumeProtocol'),
  volumeMountpoint?: string(name='VolumeMountpoint'),
  remoteDirectory?: string(name='RemoteDirectory'),
  onPremiseVolumeProtocol?: string(name='OnPremiseVolumeProtocol'),
  onPremiseVolumeMountPoint?: string(name='OnPremiseVolumeMountPoint'),
  onPremiseVolumeRemotePath?: string(name='OnPremiseVolumeRemotePath'),
  onPremiseVolumeLocalPath?: string(name='OnPremiseVolumeLocalPath'),
  password?: string(name='Password'),
  keyPairName?: string(name='KeyPairName'),
  jobQueue?: string(name='JobQueue'),
  resourceGroupId?: string(name='ResourceGroupId'),
  schedulerPreInstall?: boolean(name='SchedulerPreInstall'),
  computeSpotStrategy?: string(name='ComputeSpotStrategy'),
  computeSpotPriceLimit?: float(name='ComputeSpotPriceLimit'),
  imageOwnerAlias?: string(name='ImageOwnerAlias'),
  imageId?: string(name='ImageId'),
  clientToken?: string(name='ClientToken'),
  multiOs?: boolean(name='MultiOs'),
  nodes?: [ 
    {
      schedulerType?: string(name='SchedulerType'),
      ipAddress?: string(name='IpAddress'),
      hostName?: string(name='HostName'),
      role?: string(name='Role'),
      accountType?: string(name='AccountType'),
    }
  ](name='Nodes'),
  application?: [ 
    {
      tag?: string(name='Tag'),
    }
  ](name='Application'),
  postInstallScript?: [ 
    {
      args?: string(name='Args'),
      url?: string(name='Url'),
    }
  ](name='PostInstallScript'),
}

model CreateHybridClusterResponseBody = {
  taskId?: string(name='TaskId'),
  requestId?: string(name='RequestId'),
  clusterId?: string(name='ClusterId'),
}

model CreateHybridClusterResponse = {
  headers: map[string]string(name='headers'),
  body: CreateHybridClusterResponseBody(name='body'),
}

async function createHybridClusterWithOptions(request: CreateHybridClusterRequest, runtime: Util.RuntimeOptions): CreateHybridClusterResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('CreateHybridCluster', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function createHybridCluster(request: CreateHybridClusterRequest): CreateHybridClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return createHybridClusterWithOptions(request, runtime);
}

model CreateJobFileRequest {
  clusterId?: string(name='ClusterId'),
  runasUser?: string(name='RunasUser'),
  runasUserPassword?: string(name='RunasUserPassword'),
  content?: string(name='Content'),
  targetFile?: string(name='TargetFile'),
}

model CreateJobFileResponseBody = {
  requestId?: string(name='RequestId'),
  templateId?: string(name='TemplateId'),
}

model CreateJobFileResponse = {
  headers: map[string]string(name='headers'),
  body: CreateJobFileResponseBody(name='body'),
}

async function createJobFileWithOptions(request: CreateJobFileRequest, runtime: Util.RuntimeOptions): CreateJobFileResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('CreateJobFile', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function createJobFile(request: CreateJobFileRequest): CreateJobFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return createJobFileWithOptions(request, runtime);
}

model CreateJobTemplateRequest {
  commandLine?: string(name='CommandLine'),
  name?: string(name='Name'),
  runasUser?: string(name='RunasUser'),
  priority?: int32(name='Priority'),
  packagePath?: string(name='PackagePath'),
  stdoutRedirectPath?: string(name='StdoutRedirectPath'),
  stderrRedirectPath?: string(name='StderrRedirectPath'),
  reRunable?: boolean(name='ReRunable'),
  arrayRequest?: string(name='ArrayRequest'),
  variables?: string(name='Variables'),
  queue?: string(name='Queue'),
  clockTime?: string(name='ClockTime'),
  node?: int32(name='Node'),
  task?: int32(name='Task'),
  thread?: int32(name='Thread'),
  mem?: string(name='Mem'),
  gpu?: int32(name='Gpu'),
}

model CreateJobTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  templateId?: string(name='TemplateId'),
}

model CreateJobTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: CreateJobTemplateResponseBody(name='body'),
}

async function createJobTemplateWithOptions(request: CreateJobTemplateRequest, runtime: Util.RuntimeOptions): CreateJobTemplateResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('CreateJobTemplate', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function createJobTemplate(request: CreateJobTemplateRequest): CreateJobTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return createJobTemplateWithOptions(request, runtime);
}

model DeleteClusterRequest {
  clusterId?: string(name='ClusterId'),
  releaseInstance?: string(name='ReleaseInstance'),
}

model DeleteClusterResponseBody = {
  taskId?: string(name='TaskId'),
  requestId?: string(name='RequestId'),
}

model DeleteClusterResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteClusterResponseBody(name='body'),
}

async function deleteClusterWithOptions(request: DeleteClusterRequest, runtime: Util.RuntimeOptions): DeleteClusterResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('DeleteCluster', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function deleteCluster(request: DeleteClusterRequest): DeleteClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteClusterWithOptions(request, runtime);
}

model DeleteContainerAppsRequest {
  containerApp?: [ 
    {
      id?: string(name='Id'),
    }
  ](name='ContainerApp'),
}

model DeleteContainerAppsResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteContainerAppsResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteContainerAppsResponseBody(name='body'),
}

async function deleteContainerAppsWithOptions(request: DeleteContainerAppsRequest, runtime: Util.RuntimeOptions): DeleteContainerAppsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('DeleteContainerApps', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function deleteContainerApps(request: DeleteContainerAppsRequest): DeleteContainerAppsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteContainerAppsWithOptions(request, runtime);
}

model DeleteGWSClusterRequest {
  clusterId?: string(name='ClusterId'),
}

model DeleteGWSClusterResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteGWSClusterResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteGWSClusterResponseBody(name='body'),
}

async function deleteGWSClusterWithOptions(request: DeleteGWSClusterRequest, runtime: Util.RuntimeOptions): DeleteGWSClusterResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('DeleteGWSCluster', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function deleteGWSCluster(request: DeleteGWSClusterRequest): DeleteGWSClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGWSClusterWithOptions(request, runtime);
}

model DeleteGWSInstanceRequest {
  instanceId?: string(name='InstanceId'),
}

model DeleteGWSInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteGWSInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteGWSInstanceResponseBody(name='body'),
}

async function deleteGWSInstanceWithOptions(request: DeleteGWSInstanceRequest, runtime: Util.RuntimeOptions): DeleteGWSInstanceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('DeleteGWSInstance', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function deleteGWSInstance(request: DeleteGWSInstanceRequest): DeleteGWSInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGWSInstanceWithOptions(request, runtime);
}

model DeleteImageRequest {
  clusterId?: string(name='ClusterId'),
  repository?: string(name='Repository'),
  imageTag?: string(name='ImageTag'),
  containerType?: string(name='ContainerType'),
}

model DeleteImageResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteImageResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteImageResponseBody(name='body'),
}

async function deleteImageWithOptions(request: DeleteImageRequest, runtime: Util.RuntimeOptions): DeleteImageResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('DeleteImage', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function deleteImage(request: DeleteImageRequest): DeleteImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteImageWithOptions(request, runtime);
}

model DeleteJobsRequest {
  clusterId?: string(name='ClusterId'),
  jobs?: string(name='Jobs'),
}

model DeleteJobsResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteJobsResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteJobsResponseBody(name='body'),
}

async function deleteJobsWithOptions(request: DeleteJobsRequest, runtime: Util.RuntimeOptions): DeleteJobsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('DeleteJobs', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function deleteJobs(request: DeleteJobsRequest): DeleteJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteJobsWithOptions(request, runtime);
}

model DeleteJobTemplatesRequest {
  templates?: string(name='Templates'),
}

model DeleteJobTemplatesResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteJobTemplatesResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteJobTemplatesResponseBody(name='body'),
}

async function deleteJobTemplatesWithOptions(request: DeleteJobTemplatesRequest, runtime: Util.RuntimeOptions): DeleteJobTemplatesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('DeleteJobTemplates', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function deleteJobTemplates(request: DeleteJobTemplatesRequest): DeleteJobTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteJobTemplatesWithOptions(request, runtime);
}

model DeleteNodesRequest {
  clusterId?: string(name='ClusterId'),
  releaseInstance?: boolean(name='ReleaseInstance'),
  instance?: [ 
    {
      id?: string(name='Id'),
    }
  ](name='Instance'),
}

model DeleteNodesResponseBody = {
  taskId?: string(name='TaskId'),
  requestId?: string(name='RequestId'),
}

model DeleteNodesResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteNodesResponseBody(name='body'),
}

async function deleteNodesWithOptions(request: DeleteNodesRequest, runtime: Util.RuntimeOptions): DeleteNodesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('DeleteNodes', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function deleteNodes(request: DeleteNodesRequest): DeleteNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteNodesWithOptions(request, runtime);
}

model DeleteQueueRequest {
  clusterId?: string(name='ClusterId'),
  queueName?: string(name='QueueName'),
}

model DeleteQueueResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteQueueResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteQueueResponseBody(name='body'),
}

async function deleteQueueWithOptions(request: DeleteQueueRequest, runtime: Util.RuntimeOptions): DeleteQueueResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('DeleteQueue', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function deleteQueue(request: DeleteQueueRequest): DeleteQueueResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteQueueWithOptions(request, runtime);
}

model DeleteSecurityGroupRequest {
  clusterId?: string(name='ClusterId'),
  securityGroupId?: string(name='SecurityGroupId'),
}

model DeleteSecurityGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteSecurityGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSecurityGroupResponseBody(name='body'),
}

async function deleteSecurityGroupWithOptions(request: DeleteSecurityGroupRequest, runtime: Util.RuntimeOptions): DeleteSecurityGroupResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('DeleteSecurityGroup', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function deleteSecurityGroup(request: DeleteSecurityGroupRequest): DeleteSecurityGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSecurityGroupWithOptions(request, runtime);
}

model DeleteUsersRequest {
  clusterId?: string(name='ClusterId'),
  user?: [ 
    {
      name?: string(name='Name'),
    }
  ](name='User'),
}

model DeleteUsersResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteUsersResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteUsersResponseBody(name='body'),
}

async function deleteUsersWithOptions(request: DeleteUsersRequest, runtime: Util.RuntimeOptions): DeleteUsersResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('DeleteUsers', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function deleteUsers(request: DeleteUsersRequest): DeleteUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteUsersWithOptions(request, runtime);
}

model DescribeAutoScaleConfigRequest {
  clusterId?: string(name='ClusterId'),
}

model DescribeAutoScaleConfigResponseBody = {
  extraNodesGrowRatio?: int32(name='ExtraNodesGrowRatio'),
  requestId?: string(name='RequestId'),
  enableAutoGrow?: boolean(name='EnableAutoGrow'),
  clusterId?: string(name='ClusterId'),
  maxNodesInCluster?: int32(name='MaxNodesInCluster'),
  shrinkIdleTimes?: int32(name='ShrinkIdleTimes'),
  enableAutoShrink?: boolean(name='EnableAutoShrink'),
  clusterType?: string(name='ClusterType'),
  growRatio?: int32(name='GrowRatio'),
  growIntervalInMinutes?: int32(name='GrowIntervalInMinutes'),
  uid?: string(name='Uid'),
  growTimeoutInMinutes?: int32(name='GrowTimeoutInMinutes'),
  shrinkIntervalInMinutes?: int32(name='ShrinkIntervalInMinutes'),
  spotPriceLimit?: string(name='SpotPriceLimit'),
  excludeNodes?: string(name='ExcludeNodes'),
  spotStrategy?: string(name='SpotStrategy'),
}

model DescribeAutoScaleConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAutoScaleConfigResponseBody(name='body'),
}

async function describeAutoScaleConfigWithOptions(request: DescribeAutoScaleConfigRequest, runtime: Util.RuntimeOptions): DescribeAutoScaleConfigResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('DescribeAutoScaleConfig', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function describeAutoScaleConfig(request: DescribeAutoScaleConfigRequest): DescribeAutoScaleConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAutoScaleConfigWithOptions(request, runtime);
}

model DescribeClusterRequest {
  clusterId?: string(name='ClusterId'),
}

model DescribeClusterResponseBody = {
  clusterInfo?: {
    status?: string(name='Status'),
    vpcId?: string(name='VpcId'),
    keyPairName?: string(name='KeyPairName'),
    ecsChargeType?: string(name='EcsChargeType'),
    securityGroupId?: string(name='SecurityGroupId'),
    sccClusterId?: string(name='SccClusterId'),
    createTime?: string(name='CreateTime'),
    accountType?: string(name='AccountType'),
    volumeProtocol?: string(name='VolumeProtocol'),
    description?: string(name='Description'),
    volumeId?: string(name='VolumeId'),
    haEnable?: boolean(name='HaEnable'),
    baseOsTag?: string(name='BaseOsTag'),
    name?: string(name='Name'),
    imageId?: string(name='ImageId'),
    postInstallScripts?: {
      postInstallScriptInfo?: [ 
      {
        args?: string(name='Args'),
        url?: string(name='Url'),
      }
    ](name='PostInstallScriptInfo')
    }(name='PostInstallScripts'),
    schedulerType?: string(name='SchedulerType'),
    deployMode?: string(name='DeployMode'),
    imageOwnerAlias?: string(name='ImageOwnerAlias'),
    remoteDirectory?: string(name='RemoteDirectory'),
    volumeMountpoint?: string(name='VolumeMountpoint'),
    osTag?: string(name='OsTag'),
    regionId?: string(name='RegionId'),
    vSwitchId?: string(name='VSwitchId'),
    ecsInfo?: {
      manager?: {
        instanceType?: string(name='InstanceType'),
        count?: int32(name='Count'),
      }(name='Manager'),
      compute?: {
        instanceType?: string(name='InstanceType'),
        count?: int32(name='Count'),
      }(name='Compute'),
      login?: {
        instanceType?: string(name='InstanceType'),
        count?: int32(name='Count'),
      }(name='Login'),
    }(name='EcsInfo'),
    imageName?: string(name='ImageName'),
    applications?: {
      applicationInfo?: [ 
      {
        version?: string(name='Version'),
        tag?: string(name='Tag'),
        name?: string(name='Name'),
      }
    ](name='ApplicationInfo')
    }(name='Applications'),
    volumeType?: string(name='VolumeType'),
    location?: string(name='Location'),
    id?: string(name='Id'),
    clientVersion?: string(name='ClientVersion'),
  }(name='ClusterInfo'),
  requestId?: string(name='RequestId'),
}

model DescribeClusterResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeClusterResponseBody(name='body'),
}

async function describeClusterWithOptions(request: DescribeClusterRequest, runtime: Util.RuntimeOptions): DescribeClusterResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('DescribeCluster', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function describeCluster(request: DescribeClusterRequest): DescribeClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterWithOptions(request, runtime);
}

model DescribeContainerAppRequest {
  containerId?: string(name='ContainerId'),
}

model DescribeContainerAppResponseBody = {
  containerAppInfo?: {
    type?: string(name='Type'),
    description?: string(name='Description'),
    createTime?: string(name='CreateTime'),
    repository?: string(name='Repository'),
    imageTag?: string(name='ImageTag'),
    name?: string(name='Name'),
    id?: string(name='Id'),
  }(name='ContainerAppInfo'),
  requestId?: string(name='RequestId'),
}

model DescribeContainerAppResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeContainerAppResponseBody(name='body'),
}

async function describeContainerAppWithOptions(request: DescribeContainerAppRequest, runtime: Util.RuntimeOptions): DescribeContainerAppResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('DescribeContainerApp', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function describeContainerApp(request: DescribeContainerAppRequest): DescribeContainerAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeContainerAppWithOptions(request, runtime);
}

model DescribeGWSClusterPolicyRequest {
  clusterId?: string(name='ClusterId'),
  taskId?: string(name='TaskId'),
  asyncMode?: boolean(name='AsyncMode'),
}

model DescribeGWSClusterPolicyResponseBody = {
  requestId?: string(name='RequestId'),
  localDrive?: string(name='LocalDrive'),
  usbRedirect?: string(name='UsbRedirect'),
  clipboard?: string(name='Clipboard'),
  watermark?: string(name='Watermark'),
}

model DescribeGWSClusterPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeGWSClusterPolicyResponseBody(name='body'),
}

async function describeGWSClusterPolicyWithOptions(request: DescribeGWSClusterPolicyRequest, runtime: Util.RuntimeOptions): DescribeGWSClusterPolicyResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeGWSClusterPolicy', '2018-04-12', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeGWSClusterPolicy(request: DescribeGWSClusterPolicyRequest): DescribeGWSClusterPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGWSClusterPolicyWithOptions(request, runtime);
}

model DescribeGWSClustersRequest {
  clusterId?: string(name='ClusterId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model DescribeGWSClustersResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  clusters?: {
    clusterInfo?: [ 
    {
      vpcId?: string(name='VpcId'),
      status?: string(name='Status'),
      instanceCount?: int32(name='InstanceCount'),
      createTime?: string(name='CreateTime'),
      clusterId?: string(name='ClusterId'),
    }
  ](name='ClusterInfo')
  }(name='Clusters'),
  callerType?: string(name='CallerType'),
}

model DescribeGWSClustersResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeGWSClustersResponseBody(name='body'),
}

async function describeGWSClustersWithOptions(request: DescribeGWSClustersRequest, runtime: Util.RuntimeOptions): DescribeGWSClustersResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('DescribeGWSClusters', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function describeGWSClusters(request: DescribeGWSClustersRequest): DescribeGWSClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGWSClustersWithOptions(request, runtime);
}

model DescribeGWSImagesRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model DescribeGWSImagesResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  images?: {
    imageInfo?: [ 
    {
      status?: string(name='Status'),
      imageType?: string(name='ImageType'),
      progress?: string(name='Progress'),
      size?: int32(name='Size'),
      createTime?: string(name='CreateTime'),
      name?: string(name='Name'),
      imageId?: string(name='ImageId'),
    }
  ](name='ImageInfo')
  }(name='Images'),
}

model DescribeGWSImagesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeGWSImagesResponseBody(name='body'),
}

async function describeGWSImagesWithOptions(request: DescribeGWSImagesRequest, runtime: Util.RuntimeOptions): DescribeGWSImagesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('DescribeGWSImages', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function describeGWSImages(request: DescribeGWSImagesRequest): DescribeGWSImagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGWSImagesWithOptions(request, runtime);
}

model DescribeGWSInstancesRequest {
  clusterId?: string(name='ClusterId'),
  instanceId?: string(name='InstanceId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  userUid?: long(name='UserUid'),
  userName?: string(name='UserName'),
}

model DescribeGWSInstancesResponseBody = {
  instances?: {
    instanceInfo?: [ 
    {
      status?: string(name='Status'),
      appList?: {
        appInfo?: [ 
        {
          appName?: string(name='AppName'),
          appPath?: string(name='AppPath'),
          appArgs?: string(name='AppArgs'),
        }
      ](name='AppInfo')
      }(name='AppList'),
      workMode?: string(name='WorkMode'),
      expireTime?: string(name='ExpireTime'),
      createTime?: string(name='CreateTime'),
      instanceId?: string(name='InstanceId'),
      name?: string(name='Name'),
      instanceType?: string(name='InstanceType'),
      userName?: string(name='UserName'),
      clusterId?: string(name='ClusterId'),
    }
  ](name='InstanceInfo')
  }(name='Instances'),
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
}

model DescribeGWSInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeGWSInstancesResponseBody(name='body'),
}

async function describeGWSInstancesWithOptions(request: DescribeGWSInstancesRequest, runtime: Util.RuntimeOptions): DescribeGWSInstancesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('DescribeGWSInstances', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function describeGWSInstances(request: DescribeGWSInstancesRequest): DescribeGWSInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGWSInstancesWithOptions(request, runtime);
}

model DescribeImageRequest {
  clusterId?: string(name='ClusterId'),
  repository?: string(name='Repository'),
  imageTag?: string(name='ImageTag'),
  containerType?: string(name='ContainerType'),
}

model DescribeImageResponseBody = {
  requestId?: string(name='RequestId'),
  imageInfo?: {
    type?: string(name='Type'),
    status?: string(name='Status'),
    updateDateTime?: string(name='UpdateDateTime'),
    repository?: string(name='Repository'),
    tag?: string(name='Tag'),
    system?: string(name='System'),
    imageId?: string(name='ImageId'),
  }(name='ImageInfo'),
}

model DescribeImageResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeImageResponseBody(name='body'),
}

async function describeImageWithOptions(request: DescribeImageRequest, runtime: Util.RuntimeOptions): DescribeImageResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('DescribeImage', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function describeImage(request: DescribeImageRequest): DescribeImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageWithOptions(request, runtime);
}

model DescribeImageGatewayConfigRequest {
  clusterId?: string(name='ClusterId'),
}

model DescribeImageGatewayConfigResponseBody = {
  requestId?: string(name='RequestId'),
  imagegw?: {
    locations?: {
      locationInfo?: [ 
      {
        remoteType?: string(name='RemoteType'),
        URL?: string(name='URL'),
        location?: string(name='Location'),
        authentication?: string(name='Authentication'),
      }
    ](name='LocationInfo')
    }(name='Locations'),
    updateDateTime?: string(name='UpdateDateTime'),
    imageExpirationTimeout?: string(name='ImageExpirationTimeout'),
    mongoDBURI?: string(name='MongoDBURI'),
    defaultImageLocation?: string(name='DefaultImageLocation'),
    pullUpdateTimeout?: long(name='PullUpdateTimeout'),
  }(name='Imagegw'),
}

model DescribeImageGatewayConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeImageGatewayConfigResponseBody(name='body'),
}

async function describeImageGatewayConfigWithOptions(request: DescribeImageGatewayConfigRequest, runtime: Util.RuntimeOptions): DescribeImageGatewayConfigResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('DescribeImageGatewayConfig', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function describeImageGatewayConfig(request: DescribeImageGatewayConfigRequest): DescribeImageGatewayConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageGatewayConfigWithOptions(request, runtime);
}

model DescribeImagePriceRequest {
  imageId?: string(name='ImageId'),
  priceUnit?: string(name='PriceUnit'),
  skuCode?: string(name='SkuCode'),
  period?: int32(name='Period'),
  amount?: int32(name='Amount'),
  orderType?: string(name='OrderType'),
}

model DescribeImagePriceResponseBody = {
  originalPrice?: float(name='OriginalPrice'),
  requestId?: string(name='RequestId'),
  amount?: int32(name='Amount'),
  discountPrice?: float(name='DiscountPrice'),
  imageId?: string(name='ImageId'),
  tradePrice?: float(name='TradePrice'),
}

model DescribeImagePriceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeImagePriceResponseBody(name='body'),
}

async function describeImagePriceWithOptions(request: DescribeImagePriceRequest, runtime: Util.RuntimeOptions): DescribeImagePriceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('DescribeImagePrice', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function describeImagePrice(request: DescribeImagePriceRequest): DescribeImagePriceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImagePriceWithOptions(request, runtime);
}

model DescribeJobRequest {
  clusterId?: string(name='ClusterId'),
  jobId?: string(name='JobId'),
}

model DescribeJobResponseBody = {
  requestId?: string(name='RequestId'),
  message?: {
    jobInfo?: string(name='JobInfo'),
  }(name='Message'),
}

model DescribeJobResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeJobResponseBody(name='body'),
}

async function describeJobWithOptions(request: DescribeJobRequest, runtime: Util.RuntimeOptions): DescribeJobResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('DescribeJob', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function describeJob(request: DescribeJobRequest): DescribeJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeJobWithOptions(request, runtime);
}

model DescribeNFSClientStatusRequest {
  instanceId?: string(name='InstanceId'),
}

model DescribeNFSClientStatusResponseBody = {
  status?: string(name='Status'),
  requestId?: string(name='RequestId'),
  result?: {
    output?: string(name='Output'),
    invokeRecordStatus?: string(name='InvokeRecordStatus'),
    exitCode?: int32(name='ExitCode'),
  }(name='Result'),
}

model DescribeNFSClientStatusResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeNFSClientStatusResponseBody(name='body'),
}

async function describeNFSClientStatusWithOptions(request: DescribeNFSClientStatusRequest, runtime: Util.RuntimeOptions): DescribeNFSClientStatusResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('DescribeNFSClientStatus', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function describeNFSClientStatus(request: DescribeNFSClientStatusRequest): DescribeNFSClientStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeNFSClientStatusWithOptions(request, runtime);
}

model DescribePriceRequest {
  priceUnit?: string(name='PriceUnit'),
  chargeType?: string(name='ChargeType'),
  orderType?: string(name='OrderType'),
  commodities?: [ 
    {
      amount?: int32(name='Amount'),
      systemDiskSize?: int32(name='SystemDiskSize'),
      systemDiskPerformanceLevel?: string(name='SystemDiskPerformanceLevel'),
      nodeType?: string(name='NodeType'),
      systemDiskCategory?: string(name='SystemDiskCategory'),
      internetChargeType?: string(name='InternetChargeType'),
      networkType?: string(name='NetworkType'),
      instanceType?: string(name='InstanceType'),
      period?: int32(name='Period'),
      internetMaxBandWidthOut?: int32(name='InternetMaxBandWidthOut'),
    }
  ](name='Commodities'),
}

model DescribePriceResponseBody = {
  prices?: {
    priceInfo?: [ 
    {
      nodeType?: string(name='NodeType'),
      tradePrice?: float(name='TradePrice'),
      originalPrice?: float(name='OriginalPrice'),
      currency?: string(name='Currency'),
    }
  ](name='PriceInfo')
  }(name='Prices'),
  totalTradePrice?: float(name='TotalTradePrice'),
  requestId?: string(name='RequestId'),
}

model DescribePriceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePriceResponseBody(name='body'),
}

async function describePriceWithOptions(request: DescribePriceRequest, runtime: Util.RuntimeOptions): DescribePriceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('DescribePrice', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function describePrice(request: DescribePriceRequest): DescribePriceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePriceWithOptions(request, runtime);
}

model EcdDeleteDesktopsRequest {
  desktopId?: [ string ](name='DesktopId'),
}

model EcdDeleteDesktopsResponseBody = {
  requestId?: string(name='RequestId'),
}

model EcdDeleteDesktopsResponse = {
  headers: map[string]string(name='headers'),
  body: EcdDeleteDesktopsResponseBody(name='body'),
}

async function ecdDeleteDesktopsWithOptions(request: EcdDeleteDesktopsRequest, runtime: Util.RuntimeOptions): EcdDeleteDesktopsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('EcdDeleteDesktops', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function ecdDeleteDesktops(request: EcdDeleteDesktopsRequest): EcdDeleteDesktopsResponse {
  var runtime = new Util.RuntimeOptions{};
  return ecdDeleteDesktopsWithOptions(request, runtime);
}

model EditJobTemplateRequest {
  templateId?: string(name='TemplateId'),
  commandLine?: string(name='CommandLine'),
  name?: string(name='Name'),
  runasUser?: string(name='RunasUser'),
  priority?: int32(name='Priority'),
  packagePath?: string(name='PackagePath'),
  stdoutRedirectPath?: string(name='StdoutRedirectPath'),
  stderrRedirectPath?: string(name='StderrRedirectPath'),
  reRunable?: boolean(name='ReRunable'),
  arrayRequest?: string(name='ArrayRequest'),
  variables?: string(name='Variables'),
  queue?: string(name='Queue'),
  clockTime?: string(name='ClockTime'),
  node?: int32(name='Node'),
  task?: int32(name='Task'),
  thread?: int32(name='Thread'),
  mem?: string(name='Mem'),
  gpu?: int32(name='Gpu'),
}

model EditJobTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  templateId?: string(name='TemplateId'),
}

model EditJobTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: EditJobTemplateResponseBody(name='body'),
}

async function editJobTemplateWithOptions(request: EditJobTemplateRequest, runtime: Util.RuntimeOptions): EditJobTemplateResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('EditJobTemplate', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function editJobTemplate(request: EditJobTemplateRequest): EditJobTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return editJobTemplateWithOptions(request, runtime);
}

model GetAccountingReportRequest {
  clusterId?: string(name='ClusterId'),
  startTime?: int32(name='StartTime'),
  endTime?: int32(name='EndTime'),
  reportType?: string(name='ReportType'),
  filterValue?: string(name='FilterValue'),
  dim?: string(name='Dim'),
  jobId?: string(name='JobId'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
}

model GetAccountingReportResponseBody = {
  metrics?: string(name='Metrics'),
  totalCount?: int32(name='TotalCount'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  totalCoreTime?: int32(name='TotalCoreTime'),
  data?: {
    data?: [ string ](name='Data')
  }(name='Data'),
}

model GetAccountingReportResponse = {
  headers: map[string]string(name='headers'),
  body: GetAccountingReportResponseBody(name='body'),
}

async function getAccountingReportWithOptions(request: GetAccountingReportRequest, runtime: Util.RuntimeOptions): GetAccountingReportResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('GetAccountingReport', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function getAccountingReport(request: GetAccountingReportRequest): GetAccountingReportResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAccountingReportWithOptions(request, runtime);
}

model GetAutoScaleConfigRequest {
  clusterId?: string(name='ClusterId'),
}

model GetAutoScaleConfigResponseBody = {
  extraNodesGrowRatio?: int32(name='ExtraNodesGrowRatio'),
  requestId?: string(name='RequestId'),
  enableAutoGrow?: boolean(name='EnableAutoGrow'),
  clusterId?: string(name='ClusterId'),
  maxNodesInCluster?: int32(name='MaxNodesInCluster'),
  shrinkIdleTimes?: int32(name='ShrinkIdleTimes'),
  enableAutoShrink?: boolean(name='EnableAutoShrink'),
  clusterType?: string(name='ClusterType'),
  growRatio?: int32(name='GrowRatio'),
  growIntervalInMinutes?: int32(name='GrowIntervalInMinutes'),
  uid?: string(name='Uid'),
  growTimeoutInMinutes?: int32(name='GrowTimeoutInMinutes'),
  imageId?: string(name='ImageId'),
  shrinkIntervalInMinutes?: int32(name='ShrinkIntervalInMinutes'),
  spotPriceLimit?: float(name='SpotPriceLimit'),
  queues?: {
    queueInfo?: [ 
    {
      minNodesInQueue?: int32(name='MinNodesInQueue'),
      maxNodesInQueue?: int32(name='MaxNodesInQueue'),
      enableAutoShrink?: boolean(name='EnableAutoShrink'),
      queueName?: string(name='QueueName'),
      queueImageId?: string(name='QueueImageId'),
      enableAutoGrow?: boolean(name='EnableAutoGrow'),
      resourceGroupId?: string(name='ResourceGroupId'),
      spotPriceLimit?: float(name='SpotPriceLimit'),
      instanceTypes?: {
        instanceTypeInfo?: [ 
        {
          hostNamePrefix?: string(name='HostNamePrefix'),
          vSwitchId?: string(name='VSwitchId'),
          zoneId?: string(name='ZoneId'),
          spotPriceLimit?: float(name='SpotPriceLimit'),
          instanceType?: string(name='InstanceType'),
          spotStrategy?: string(name='SpotStrategy'),
        }
      ](name='InstanceTypeInfo')
      }(name='InstanceTypes'),
      instanceType?: string(name='InstanceType'),
      spotStrategy?: string(name='SpotStrategy'),
    }
  ](name='QueueInfo')
  }(name='Queues'),
  excludeNodes?: string(name='ExcludeNodes'),
  spotStrategy?: string(name='SpotStrategy'),
}

model GetAutoScaleConfigResponse = {
  headers: map[string]string(name='headers'),
  body: GetAutoScaleConfigResponseBody(name='body'),
}

async function getAutoScaleConfigWithOptions(request: GetAutoScaleConfigRequest, runtime: Util.RuntimeOptions): GetAutoScaleConfigResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('GetAutoScaleConfig', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function getAutoScaleConfig(request: GetAutoScaleConfigRequest): GetAutoScaleConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAutoScaleConfigWithOptions(request, runtime);
}

model GetCloudMetricLogsRequest {
  clusterId?: string(name='ClusterId'),
  from?: int32(name='From'),
  to?: int32(name='To'),
  reverse?: boolean(name='Reverse'),
  aggregationType?: string(name='AggregationType'),
  aggregationInterval?: int32(name='AggregationInterval'),
  metricScope?: string(name='MetricScope'),
  filter?: string(name='Filter'),
  metricCategories?: string(name='MetricCategories'),
}

model GetCloudMetricLogsResponseBody = {
  requestId?: string(name='RequestId'),
  metricLogs?: {
    metricLog?: [ 
    {
      time?: int32(name='Time'),
      diskDevice?: string(name='DiskDevice'),
      networkInterface?: string(name='NetworkInterface'),
      metricData?: string(name='MetricData'),
      hostname?: string(name='Hostname'),
      instanceId?: string(name='InstanceId'),
    }
  ](name='MetricLog')
  }(name='MetricLogs'),
}

model GetCloudMetricLogsResponse = {
  headers: map[string]string(name='headers'),
  body: GetCloudMetricLogsResponseBody(name='body'),
}

async function getCloudMetricLogsWithOptions(request: GetCloudMetricLogsRequest, runtime: Util.RuntimeOptions): GetCloudMetricLogsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('GetCloudMetricLogs', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function getCloudMetricLogs(request: GetCloudMetricLogsRequest): GetCloudMetricLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCloudMetricLogsWithOptions(request, runtime);
}

model GetCloudMetricProfilingRequest {
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  profilingId?: string(name='ProfilingId'),
}

model GetCloudMetricProfilingResponseBody = {
  requestId?: string(name='RequestId'),
  svgUrls?: {
    svgInfo?: [ 
    {
      type?: string(name='Type'),
      size?: int32(name='Size'),
      url?: string(name='Url'),
      name?: string(name='Name'),
    }
  ](name='SvgInfo')
  }(name='SvgUrls'),
}

model GetCloudMetricProfilingResponse = {
  headers: map[string]string(name='headers'),
  body: GetCloudMetricProfilingResponseBody(name='body'),
}

async function getCloudMetricProfilingWithOptions(request: GetCloudMetricProfilingRequest, runtime: Util.RuntimeOptions): GetCloudMetricProfilingResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('GetCloudMetricProfiling', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function getCloudMetricProfiling(request: GetCloudMetricProfilingRequest): GetCloudMetricProfilingResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCloudMetricProfilingWithOptions(request, runtime);
}

model GetClusterVolumesRequest {
  clusterId?: string(name='ClusterId'),
}

model GetClusterVolumesResponseBody = {
  volumes?: {
    volumeInfo?: [ 
    {
      jobQueue?: string(name='JobQueue'),
      volumeId?: string(name='VolumeId'),
      roles?: {
        roleInfo?: [ 
        {
          name?: string(name='Name'),
        }
      ](name='RoleInfo')
      }(name='Roles'),
      remoteDirectory?: string(name='RemoteDirectory'),
      volumeMountpoint?: string(name='VolumeMountpoint'),
      localDirectory?: string(name='LocalDirectory'),
      volumeType?: string(name='VolumeType'),
      mustKeep?: boolean(name='MustKeep'),
      location?: string(name='Location'),
      volumeProtocol?: string(name='VolumeProtocol'),
    }
  ](name='VolumeInfo')
  }(name='Volumes'),
  requestId?: string(name='RequestId'),
  regionId?: string(name='RegionId'),
}

model GetClusterVolumesResponse = {
  headers: map[string]string(name='headers'),
  body: GetClusterVolumesResponseBody(name='body'),
}

async function getClusterVolumesWithOptions(request: GetClusterVolumesRequest, runtime: Util.RuntimeOptions): GetClusterVolumesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('GetClusterVolumes', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function getClusterVolumes(request: GetClusterVolumesRequest): GetClusterVolumesResponse {
  var runtime = new Util.RuntimeOptions{};
  return getClusterVolumesWithOptions(request, runtime);
}

model GetGWSConnectTicketRequest {
  instanceId?: string(name='InstanceId'),
  appName?: string(name='AppName'),
}

model GetGWSConnectTicketResponseBody = {
  ticket?: string(name='Ticket'),
  requestId?: string(name='RequestId'),
}

model GetGWSConnectTicketResponse = {
  headers: map[string]string(name='headers'),
  body: GetGWSConnectTicketResponseBody(name='body'),
}

async function getGWSConnectTicketWithOptions(request: GetGWSConnectTicketRequest, runtime: Util.RuntimeOptions): GetGWSConnectTicketResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('GetGWSConnectTicket', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function getGWSConnectTicket(request: GetGWSConnectTicketRequest): GetGWSConnectTicketResponse {
  var runtime = new Util.RuntimeOptions{};
  return getGWSConnectTicketWithOptions(request, runtime);
}

model GetHealthMonitorLogsRequest {
  clusterId?: string(name='ClusterId'),
  startTime?: int32(name='StartTime'),
  endTime?: int32(name='EndTime'),
  enableReverse?: boolean(name='EnableReverse'),
  filter?: string(name='Filter'),
}

model GetHealthMonitorLogsResponseBody = {
  logInfo?: {
    logs?: [ 
    {
      time?: int32(name='Time'),
      itemDescription?: string(name='ItemDescription'),
      itemName?: string(name='ItemName'),
      healthId?: string(name='HealthId'),
      checkList?: {
        checkList?: [ 
        {
          checkInfo?: string(name='CheckInfo'),
          checkDescription?: string(name='CheckDescription'),
          checkSolution?: string(name='CheckSolution'),
          checkName?: string(name='CheckName'),
        }
      ](name='CheckList')
      }(name='CheckList'),
      sceneDescription?: string(name='SceneDescription'),
      hostName?: string(name='HostName'),
      sceneName?: string(name='SceneName'),
      instanceId?: string(name='InstanceId'),
      level?: string(name='Level'),
    }
  ](name='Logs')
  }(name='LogInfo'),
  requestId?: string(name='RequestId'),
}

model GetHealthMonitorLogsResponse = {
  headers: map[string]string(name='headers'),
  body: GetHealthMonitorLogsResponseBody(name='body'),
}

async function getHealthMonitorLogsWithOptions(request: GetHealthMonitorLogsRequest, runtime: Util.RuntimeOptions): GetHealthMonitorLogsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('GetHealthMonitorLogs', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function getHealthMonitorLogs(request: GetHealthMonitorLogsRequest): GetHealthMonitorLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getHealthMonitorLogsWithOptions(request, runtime);
}

model GetHybridClusterConfigRequest {
  clusterId?: string(name='ClusterId'),
  node?: string(name='Node'),
}

model GetHybridClusterConfigResponseBody = {
  requestId?: string(name='RequestId'),
  clusterConfig?: string(name='ClusterConfig'),
}

model GetHybridClusterConfigResponse = {
  headers: map[string]string(name='headers'),
  body: GetHybridClusterConfigResponseBody(name='body'),
}

async function getHybridClusterConfigWithOptions(request: GetHybridClusterConfigRequest, runtime: Util.RuntimeOptions): GetHybridClusterConfigResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('GetHybridClusterConfig', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function getHybridClusterConfig(request: GetHybridClusterConfigRequest): GetHybridClusterConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return getHybridClusterConfigWithOptions(request, runtime);
}

model GetIfEcsTypeSupportHtConfigRequest {
  instanceType?: string(name='InstanceType'),
}

model GetIfEcsTypeSupportHtConfigResponseBody = {
  defaultHtEnabled?: boolean(name='DefaultHtEnabled'),
  requestId?: string(name='RequestId'),
  supportHtConfig?: boolean(name='SupportHtConfig'),
  instanceType?: string(name='InstanceType'),
}

model GetIfEcsTypeSupportHtConfigResponse = {
  headers: map[string]string(name='headers'),
  body: GetIfEcsTypeSupportHtConfigResponseBody(name='body'),
}

async function getIfEcsTypeSupportHtConfigWithOptions(request: GetIfEcsTypeSupportHtConfigRequest, runtime: Util.RuntimeOptions): GetIfEcsTypeSupportHtConfigResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('GetIfEcsTypeSupportHtConfig', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function getIfEcsTypeSupportHtConfig(request: GetIfEcsTypeSupportHtConfigRequest): GetIfEcsTypeSupportHtConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return getIfEcsTypeSupportHtConfigWithOptions(request, runtime);
}

model GetVisualServiceStatusRequest {
  clusterId?: string(name='ClusterId'),
}

model GetVisualServiceStatusResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetVisualServiceStatusResponse = {
  headers: map[string]string(name='headers'),
  body: GetVisualServiceStatusResponseBody(name='body'),
}

async function getVisualServiceStatusWithOptions(request: GetVisualServiceStatusRequest, runtime: Util.RuntimeOptions): GetVisualServiceStatusResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('GetVisualServiceStatus', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function getVisualServiceStatus(request: GetVisualServiceStatusRequest): GetVisualServiceStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVisualServiceStatusWithOptions(request, runtime);
}

model GetWorkbenchTokenRequest {
  clusterId?: string(name='ClusterId'),
  userName?: string(name='UserName'),
  userPassword?: string(name='UserPassword'),
  port?: int32(name='Port'),
  accountSessionTicket?: string(name='AccountSessionTicket'),
  accountUid?: string(name='AccountUid'),
  instanceId?: string(name='InstanceId'),
}

model GetWorkbenchTokenResponseBody = {
  requestId?: string(name='RequestId'),
  root?: {
    instanceLoginView?: {
      defaultViewUrl?: string(name='defaultViewUrl'),
      rdpViewUrl?: string(name='rdpViewUrl'),
      baseViewUrl?: string(name='baseViewUrl'),
      fileTreeViewUrl?: string(name='fileTreeViewUrl'),
      terminalViewUrl?: string(name='terminalViewUrl'),
      viewName?: string(name='viewName'),
    }(name='instanceLoginView'),
  }(name='root'),
}

model GetWorkbenchTokenResponse = {
  headers: map[string]string(name='headers'),
  body: GetWorkbenchTokenResponseBody(name='body'),
}

async function getWorkbenchTokenWithOptions(request: GetWorkbenchTokenRequest, runtime: Util.RuntimeOptions): GetWorkbenchTokenResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('GetWorkbenchToken', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function getWorkbenchToken(request: GetWorkbenchTokenRequest): GetWorkbenchTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return getWorkbenchTokenWithOptions(request, runtime);
}

model InitializeEHPCRequest {
  regionId?: string(name='RegionId'),
}

model InitializeEHPCResponseBody = {
  requestId?: string(name='RequestId'),
}

model InitializeEHPCResponse = {
  headers: map[string]string(name='headers'),
  body: InitializeEHPCResponseBody(name='body'),
}

async function initializeEHPCWithOptions(request: InitializeEHPCRequest, runtime: Util.RuntimeOptions): InitializeEHPCResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('InitializeEHPC', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function initializeEHPC(request: InitializeEHPCRequest): InitializeEHPCResponse {
  var runtime = new Util.RuntimeOptions{};
  return initializeEHPCWithOptions(request, runtime);
}

model InstallSoftwareRequest {
  clusterId?: string(name='ClusterId'),
  application?: string(name='Application'),
}

model InstallSoftwareResponseBody = {
  requestId?: string(name='RequestId'),
}

model InstallSoftwareResponse = {
  headers: map[string]string(name='headers'),
  body: InstallSoftwareResponseBody(name='body'),
}

async function installSoftwareWithOptions(request: InstallSoftwareRequest, runtime: Util.RuntimeOptions): InstallSoftwareResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('InstallSoftware', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function installSoftware(request: InstallSoftwareRequest): InstallSoftwareResponse {
  var runtime = new Util.RuntimeOptions{};
  return installSoftwareWithOptions(request, runtime);
}

model InvokeShellCommandRequest {
  clusterId?: string(name='ClusterId'),
  command?: string(name='Command'),
  workingDir?: string(name='WorkingDir'),
  timeout?: int32(name='Timeout'),
  instance?: [ 
    {
      id?: string(name='Id'),
    }
  ](name='Instance'),
}

model InvokeShellCommandResponseBody = {
  requestId?: string(name='RequestId'),
  commandId?: string(name='CommandId'),
  instanceIds?: {
    instanceId?: [ string ](name='InstanceId')
  }(name='InstanceIds'),
}

model InvokeShellCommandResponse = {
  headers: map[string]string(name='headers'),
  body: InvokeShellCommandResponseBody(name='body'),
}

async function invokeShellCommandWithOptions(request: InvokeShellCommandRequest, runtime: Util.RuntimeOptions): InvokeShellCommandResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('InvokeShellCommand', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function invokeShellCommand(request: InvokeShellCommandRequest): InvokeShellCommandResponse {
  var runtime = new Util.RuntimeOptions{};
  return invokeShellCommandWithOptions(request, runtime);
}

model ListAccountMappingRequest {
  clusterId?: string(name='ClusterId'),
}

model ListAccountMappingResponseBody = {
  requestId?: string(name='RequestId'),
  userMappings?: {
    userMapping?: [ 
    {
      accountId?: string(name='AccountId'),
      userName?: string(name='UserName'),
      accountName?: string(name='AccountName'),
    }
  ](name='UserMapping')
  }(name='UserMappings'),
}

model ListAccountMappingResponse = {
  headers: map[string]string(name='headers'),
  body: ListAccountMappingResponseBody(name='body'),
}

async function listAccountMappingWithOptions(request: ListAccountMappingRequest, runtime: Util.RuntimeOptions): ListAccountMappingResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListAccountMapping', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listAccountMapping(request: ListAccountMappingRequest): ListAccountMappingResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAccountMappingWithOptions(request, runtime);
}

model ListAvailableEcsTypesRequest {
  zoneId?: string(name='ZoneId'),
  spotStrategy?: string(name='SpotStrategy'),
  instanceChargeType?: string(name='InstanceChargeType'),
  showSoldOut?: boolean(name='ShowSoldOut'),
}

model ListAvailableEcsTypesResponseBody = {
  supportSpotInstance?: boolean(name='SupportSpotInstance'),
  requestId?: string(name='RequestId'),
  instanceTypeFamilies?: {
    instanceTypeFamilyInfo?: [ 
    {
      instanceTypeFamilyId?: string(name='InstanceTypeFamilyId'),
      types?: {
        typesInfo?: [ 
        {
          status?: string(name='Status'),
          instanceTypeId?: string(name='InstanceTypeId'),
          instanceBandwidthRx?: int32(name='InstanceBandwidthRx'),
          GPUSpec?: string(name='GPUSpec'),
          instanceBandwidthTx?: int32(name='InstanceBandwidthTx'),
          instancePpsRx?: int32(name='InstancePpsRx'),
          instancePpsTx?: int32(name='InstancePpsTx'),
          GPUAmount?: int32(name='GPUAmount'),
          cpuCoreCount?: int32(name='CpuCoreCount'),
          memorySize?: int32(name='MemorySize'),
          eniQuantity?: int32(name='EniQuantity'),
        }
      ](name='TypesInfo')
      }(name='Types'),
      generation?: string(name='Generation'),
    }
  ](name='InstanceTypeFamilyInfo')
  }(name='InstanceTypeFamilies'),
}

model ListAvailableEcsTypesResponse = {
  headers: map[string]string(name='headers'),
  body: ListAvailableEcsTypesResponseBody(name='body'),
}

async function listAvailableEcsTypesWithOptions(request: ListAvailableEcsTypesRequest, runtime: Util.RuntimeOptions): ListAvailableEcsTypesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListAvailableEcsTypes', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listAvailableEcsTypes(request: ListAvailableEcsTypesRequest): ListAvailableEcsTypesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAvailableEcsTypesWithOptions(request, runtime);
}

model ListAvailableFileSystemTypesResponseBody = {
  fileSystemTypeList?: {
    fileSystemTypes?: [ 
    {
      fileSystemType?: string(name='FileSystemType'),
      available?: boolean(name='Available'),
      protocolType?: string(name='ProtocolType'),
      storageTypes?: {
        storageType?: [ string ](name='StorageType')
      }(name='StorageTypes'),
    }
  ](name='FileSystemTypes')
  }(name='FileSystemTypeList'),
  requestId?: string(name='RequestId'),
}

model ListAvailableFileSystemTypesResponse = {
  headers: map[string]string(name='headers'),
  body: ListAvailableFileSystemTypesResponseBody(name='body'),
}

async function listAvailableFileSystemTypesWithOptions(runtime: Util.RuntimeOptions): ListAvailableFileSystemTypesResponse {
  var req = new OpenApi.OpenApiRequest{};
  return doRPCRequest('ListAvailableFileSystemTypes', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listAvailableFileSystemTypes(): ListAvailableFileSystemTypesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAvailableFileSystemTypesWithOptions(runtime);
}

model ListCloudMetricProfilingsRequest {
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListCloudMetricProfilingsResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  profilings?: {
    profilingInfo?: [ 
    {
      profilingId?: string(name='ProfilingId'),
      triggerTime?: string(name='TriggerTime'),
      pid?: int32(name='Pid'),
      hostName?: string(name='HostName'),
      duration?: int32(name='Duration'),
      instanceId?: string(name='InstanceId'),
      freq?: int32(name='Freq'),
    }
  ](name='ProfilingInfo')
  }(name='Profilings'),
}

model ListCloudMetricProfilingsResponse = {
  headers: map[string]string(name='headers'),
  body: ListCloudMetricProfilingsResponseBody(name='body'),
}

async function listCloudMetricProfilingsWithOptions(request: ListCloudMetricProfilingsRequest, runtime: Util.RuntimeOptions): ListCloudMetricProfilingsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListCloudMetricProfilings', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listCloudMetricProfilings(request: ListCloudMetricProfilingsRequest): ListCloudMetricProfilingsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCloudMetricProfilingsWithOptions(request, runtime);
}

model ListClusterLogsRequest {
  clusterId?: string(name='ClusterId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListClusterLogsResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  clusterId?: string(name='ClusterId'),
  logs?: {
    logInfo?: [ 
    {
      operation?: string(name='Operation'),
      createTime?: string(name='CreateTime'),
      message?: string(name='Message'),
      level?: string(name='Level'),
    }
  ](name='LogInfo')
  }(name='Logs'),
}

model ListClusterLogsResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterLogsResponseBody(name='body'),
}

async function listClusterLogsWithOptions(request: ListClusterLogsRequest, runtime: Util.RuntimeOptions): ListClusterLogsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListClusterLogs', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listClusterLogs(request: ListClusterLogsRequest): ListClusterLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClusterLogsWithOptions(request, runtime);
}

model ListClustersRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListClustersResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  clusters?: {
    clusterInfoSimple?: [ 
    {
      vpcId?: string(name='VpcId'),
      status?: string(name='Status'),
      createTime?: string(name='CreateTime'),
      isComputeEss?: boolean(name='IsComputeEss'),
      usedResources?: {
        cpu?: int32(name='Cpu'),
        gpu?: int32(name='Gpu'),
        memory?: int32(name='Memory'),
      }(name='UsedResources'),
      computeSpotStrategy?: string(name='ComputeSpotStrategy'),
      accountType?: string(name='AccountType'),
      count?: int32(name='Count'),
      ehpcVersion?: string(name='EhpcVersion'),
      description?: string(name='Description'),
      baseOsTag?: string(name='BaseOsTag'),
      name?: string(name='Name'),
      imageId?: string(name='ImageId'),
      computeSpotPriceLimit?: float(name='ComputeSpotPriceLimit'),
      schedulerType?: string(name='SchedulerType'),
      nodeSuffix?: string(name='NodeSuffix'),
      deployMode?: string(name='DeployMode'),
      imageOwnerAlias?: string(name='ImageOwnerAlias'),
      osTag?: string(name='OsTag'),
      nodePrefix?: string(name='NodePrefix'),
      instanceType?: string(name='InstanceType'),
      managers?: {
        exceptionCount?: int32(name='ExceptionCount'),
        normalCount?: int32(name='NormalCount'),
        operatingCount?: int32(name='OperatingCount'),
        stoppedCount?: int32(name='StoppedCount'),
        total?: int32(name='Total'),
      }(name='Managers'),
      instanceChargeType?: string(name='InstanceChargeType'),
      regionId?: string(name='RegionId'),
      vSwitchId?: string(name='VSwitchId'),
      totalResources?: {
        cpu?: int32(name='Cpu'),
        gpu?: int32(name='Gpu'),
        memory?: int32(name='Memory'),
      }(name='TotalResources'),
      zoneId?: string(name='ZoneId'),
      computes?: {
        exceptionCount?: int32(name='ExceptionCount'),
        normalCount?: int32(name='NormalCount'),
        operatingCount?: int32(name='OperatingCount'),
        stoppedCount?: int32(name='StoppedCount'),
        total?: int32(name='Total'),
      }(name='Computes'),
      loginNodes?: string(name='LoginNodes'),
      id?: string(name='Id'),
      location?: string(name='Location'),
      clientVersion?: string(name='ClientVersion'),
    }
  ](name='ClusterInfoSimple')
  }(name='Clusters'),
}

model ListClustersResponse = {
  headers: map[string]string(name='headers'),
  body: ListClustersResponseBody(name='body'),
}

async function listClustersWithOptions(request: ListClustersRequest, runtime: Util.RuntimeOptions): ListClustersResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListClusters', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listClusters(request: ListClustersRequest): ListClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClustersWithOptions(request, runtime);
}

model ListClustersMetaRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListClustersMetaResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  clusters?: {
    clusterInfoSimple?: [ 
    {
      vpcId?: string(name='VpcId'),
      status?: string(name='Status'),
      schedulerType?: string(name='SchedulerType'),
      deployMode?: string(name='DeployMode'),
      isComputeEss?: boolean(name='IsComputeEss'),
      osTag?: string(name='OsTag'),
      accountType?: string(name='AccountType'),
      description?: string(name='Description'),
      name?: string(name='Name'),
      location?: string(name='Location'),
      id?: string(name='Id'),
      clientVersion?: string(name='ClientVersion'),
    }
  ](name='ClusterInfoSimple')
  }(name='Clusters'),
}

model ListClustersMetaResponse = {
  headers: map[string]string(name='headers'),
  body: ListClustersMetaResponseBody(name='body'),
}

async function listClustersMetaWithOptions(request: ListClustersMetaRequest, runtime: Util.RuntimeOptions): ListClustersMetaResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListClustersMeta', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listClustersMeta(request: ListClustersMetaRequest): ListClustersMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClustersMetaWithOptions(request, runtime);
}

model ListCommandsRequest {
  clusterId?: string(name='ClusterId'),
  commandId?: string(name='CommandId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListCommandsResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  commands?: {
    command?: [ 
    {
      timeout?: string(name='Timeout'),
      workingDir?: string(name='WorkingDir'),
      commandContent?: string(name='CommandContent'),
      commandId?: string(name='CommandId'),
    }
  ](name='Command')
  }(name='Commands'),
}

model ListCommandsResponse = {
  headers: map[string]string(name='headers'),
  body: ListCommandsResponseBody(name='body'),
}

async function listCommandsWithOptions(request: ListCommandsRequest, runtime: Util.RuntimeOptions): ListCommandsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListCommands', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listCommands(request: ListCommandsRequest): ListCommandsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCommandsWithOptions(request, runtime);
}

model ListContainerAppsRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListContainerAppsResponseBody = {
  containerApps?: {
    containerApps?: [ 
    {
      type?: string(name='Type'),
      description?: string(name='Description'),
      createTime?: string(name='CreateTime'),
      repository?: string(name='Repository'),
      imageTag?: string(name='ImageTag'),
      name?: string(name='Name'),
      id?: string(name='Id'),
    }
  ](name='ContainerApps')
  }(name='ContainerApps'),
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
}

model ListContainerAppsResponse = {
  headers: map[string]string(name='headers'),
  body: ListContainerAppsResponseBody(name='body'),
}

async function listContainerAppsWithOptions(request: ListContainerAppsRequest, runtime: Util.RuntimeOptions): ListContainerAppsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListContainerApps', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listContainerApps(request: ListContainerAppsRequest): ListContainerAppsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listContainerAppsWithOptions(request, runtime);
}

model ListContainerImagesRequest {
  clusterId?: string(name='ClusterId'),
  containerType?: string(name='ContainerType'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListContainerImagesResponseBody = {
  totalCount?: int32(name='TotalCount'),
  DBInfo?: string(name='DBInfo'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  images?: {
    images?: [ 
    {
      type?: string(name='Type'),
      status?: string(name='Status'),
      updateDateTime?: string(name='UpdateDateTime'),
      repository?: string(name='Repository'),
      tag?: string(name='Tag'),
      system?: string(name='System'),
      imageId?: string(name='ImageId'),
    }
  ](name='Images')
  }(name='Images'),
}

model ListContainerImagesResponse = {
  headers: map[string]string(name='headers'),
  body: ListContainerImagesResponseBody(name='body'),
}

async function listContainerImagesWithOptions(request: ListContainerImagesRequest, runtime: Util.RuntimeOptions): ListContainerImagesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListContainerImages', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listContainerImages(request: ListContainerImagesRequest): ListContainerImagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listContainerImagesWithOptions(request, runtime);
}

model ListCpfsFileSystemsRequest {
  fileSystemId?: string(name='FileSystemId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListCpfsFileSystemsResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  fileSystemList?: {
    fileSystems?: [ 
    {
      fileSystemId?: string(name='FileSystemId'),
      capacity?: string(name='Capacity'),
      createTime?: string(name='CreateTime'),
      mountTargetList?: {
        mountTargets?: [ 
        {
          vpcId?: string(name='VpcId'),
          status?: string(name='Status'),
          mountTargetDomain?: string(name='MountTargetDomain'),
          vswId?: string(name='VswId'),
          networkType?: string(name='NetworkType'),
        }
      ](name='MountTargets')
      }(name='MountTargetList'),
      zoneId?: string(name='ZoneId'),
      protocolType?: string(name='ProtocolType'),
      destription?: string(name='Destription'),
      regionId?: string(name='RegionId'),
    }
  ](name='FileSystems')
  }(name='FileSystemList'),
}

model ListCpfsFileSystemsResponse = {
  headers: map[string]string(name='headers'),
  body: ListCpfsFileSystemsResponseBody(name='body'),
}

async function listCpfsFileSystemsWithOptions(request: ListCpfsFileSystemsRequest, runtime: Util.RuntimeOptions): ListCpfsFileSystemsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListCpfsFileSystems', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listCpfsFileSystems(request: ListCpfsFileSystemsRequest): ListCpfsFileSystemsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCpfsFileSystemsWithOptions(request, runtime);
}

model ListCurrentClientVersionResponseBody = {
  requestId?: string(name='RequestId'),
  clientVersion?: string(name='ClientVersion'),
}

model ListCurrentClientVersionResponse = {
  headers: map[string]string(name='headers'),
  body: ListCurrentClientVersionResponseBody(name='body'),
}

async function listCurrentClientVersionWithOptions(runtime: Util.RuntimeOptions): ListCurrentClientVersionResponse {
  var req = new OpenApi.OpenApiRequest{};
  return doRPCRequest('ListCurrentClientVersion', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listCurrentClientVersion(): ListCurrentClientVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCurrentClientVersionWithOptions(runtime);
}

model ListCustomImagesRequest {
  imageOwnerAlias?: string(name='ImageOwnerAlias'),
  baseOsTag?: string(name='BaseOsTag'),
  instanceType?: string(name='InstanceType'),
  clusterId?: string(name='ClusterId'),
}

model ListCustomImagesResponseBody = {
  requestId?: string(name='RequestId'),
  images?: {
    imageInfo?: [ 
    {
      status?: string(name='Status'),
      postInstallScript?: string(name='PostInstallScript'),
      imageOwnerAlias?: string(name='ImageOwnerAlias'),
      osTag?: {
        version?: string(name='Version'),
        baseOsTag?: string(name='BaseOsTag'),
        platform?: string(name='Platform'),
        osTag?: string(name='OsTag'),
        architecture?: string(name='Architecture'),
      }(name='OsTag'),
      skuCode?: string(name='SkuCode'),
      pricingCycle?: string(name='PricingCycle'),
      description?: string(name='Description'),
      size?: int32(name='Size'),
      baseOsTag?: {
        version?: string(name='Version'),
        platform?: string(name='Platform'),
        osTag?: string(name='OsTag'),
        architecture?: string(name='Architecture'),
      }(name='BaseOsTag'),
      imageName?: string(name='ImageName'),
      imageId?: string(name='ImageId'),
      uid?: string(name='Uid'),
      productCode?: string(name='ProductCode'),
    }
  ](name='ImageInfo')
  }(name='Images'),
}

model ListCustomImagesResponse = {
  headers: map[string]string(name='headers'),
  body: ListCustomImagesResponseBody(name='body'),
}

async function listCustomImagesWithOptions(request: ListCustomImagesRequest, runtime: Util.RuntimeOptions): ListCustomImagesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListCustomImages', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listCustomImages(request: ListCustomImagesRequest): ListCustomImagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCustomImagesWithOptions(request, runtime);
}

model ListFileSystemWithMountTargetsRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListFileSystemWithMountTargetsResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  fileSystemList?: {
    fileSystems?: [ 
    {
      status?: string(name='Status'),
      capacity?: int32(name='Capacity'),
      mountTargetList?: {
        mountTargets?: [ 
        {
          status?: string(name='Status'),
          vpcId?: string(name='VpcId'),
          mountTargetDomain?: string(name='MountTargetDomain'),
          accessGroup?: string(name='AccessGroup'),
          vswId?: string(name='VswId'),
          networkType?: string(name='NetworkType'),
        }
      ](name='MountTargets')
      }(name='MountTargetList'),
      createTime?: string(name='CreateTime'),
      packageList?: {
        packages?: [ 
        {
          packageId?: string(name='PackageId'),
        }
      ](name='Packages')
      }(name='PackageList'),
      storageType?: string(name='StorageType'),
      bandWidth?: int32(name='BandWidth'),
      regionId?: string(name='RegionId'),
      fileSystemType?: string(name='FileSystemType'),
      fileSystemId?: string(name='FileSystemId'),
      meteredSize?: int32(name='MeteredSize'),
      encryptType?: int32(name='EncryptType'),
      protocolType?: string(name='ProtocolType'),
      destription?: string(name='Destription'),
    }
  ](name='FileSystems')
  }(name='FileSystemList'),
}

model ListFileSystemWithMountTargetsResponse = {
  headers: map[string]string(name='headers'),
  body: ListFileSystemWithMountTargetsResponseBody(name='body'),
}

async function listFileSystemWithMountTargetsWithOptions(request: ListFileSystemWithMountTargetsRequest, runtime: Util.RuntimeOptions): ListFileSystemWithMountTargetsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListFileSystemWithMountTargets', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listFileSystemWithMountTargets(request: ListFileSystemWithMountTargetsRequest): ListFileSystemWithMountTargetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFileSystemWithMountTargetsWithOptions(request, runtime);
}

model ListImagesRequest {
  baseOsTag?: string(name='BaseOsTag'),
  instanceType?: string(name='InstanceType'),
}

model ListImagesResponseBody = {
  requestId?: string(name='RequestId'),
  osTags?: {
    osInfo?: [ 
    {
      version?: string(name='Version'),
      baseOsTag?: string(name='BaseOsTag'),
      platform?: string(name='Platform'),
      osTag?: string(name='OsTag'),
      imageId?: string(name='ImageId'),
      architecture?: string(name='Architecture'),
    }
  ](name='OsInfo')
  }(name='OsTags'),
}

model ListImagesResponse = {
  headers: map[string]string(name='headers'),
  body: ListImagesResponseBody(name='body'),
}

async function listImagesWithOptions(request: ListImagesRequest, runtime: Util.RuntimeOptions): ListImagesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListImages', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listImages(request: ListImagesRequest): ListImagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listImagesWithOptions(request, runtime);
}

model ListInstalledSoftwareRequest {
  clusterId?: string(name='ClusterId'),
}

model ListInstalledSoftwareResponseBody = {
  requestId?: string(name='RequestId'),
  softwareList?: {
    softwareList?: [ 
    {
      softwareVersion?: string(name='SoftwareVersion'),
      softwareName?: string(name='SoftwareName'),
      softwareId?: string(name='SoftwareId'),
      softwareStatus?: string(name='SoftwareStatus'),
    }
  ](name='SoftwareList')
  }(name='SoftwareList'),
}

model ListInstalledSoftwareResponse = {
  headers: map[string]string(name='headers'),
  body: ListInstalledSoftwareResponseBody(name='body'),
}

async function listInstalledSoftwareWithOptions(request: ListInstalledSoftwareRequest, runtime: Util.RuntimeOptions): ListInstalledSoftwareResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListInstalledSoftware', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listInstalledSoftware(request: ListInstalledSoftwareRequest): ListInstalledSoftwareResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInstalledSoftwareWithOptions(request, runtime);
}

model ListInvocationResultsRequest {
  clusterId?: string(name='ClusterId'),
  commandId?: string(name='CommandId'),
  invokeRecordStatus?: string(name='InvokeRecordStatus'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  instance?: [ 
    {
      id?: string(name='Id'),
    }
  ](name='Instance'),
}

model ListInvocationResultsResponseBody = {
  invocationResults?: {
    invocationResult?: [ 
    {
      success?: boolean(name='Success'),
      message?: string(name='Message'),
      finishedTime?: string(name='FinishedTime'),
      commandId?: string(name='CommandId'),
      instanceId?: string(name='InstanceId'),
      invokeRecordStatus?: string(name='InvokeRecordStatus'),
      exitCode?: int32(name='ExitCode'),
    }
  ](name='InvocationResult')
  }(name='InvocationResults'),
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
}

model ListInvocationResultsResponse = {
  headers: map[string]string(name='headers'),
  body: ListInvocationResultsResponseBody(name='body'),
}

async function listInvocationResultsWithOptions(request: ListInvocationResultsRequest, runtime: Util.RuntimeOptions): ListInvocationResultsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListInvocationResults', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listInvocationResults(request: ListInvocationResultsRequest): ListInvocationResultsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInvocationResultsWithOptions(request, runtime);
}

model ListInvocationStatusRequest {
  clusterId?: string(name='ClusterId'),
  commandId?: string(name='CommandId'),
}

model ListInvocationStatusResponseBody = {
  invokeStatus?: string(name='InvokeStatus'),
  requestId?: string(name='RequestId'),
  commandId?: string(name='CommandId'),
  invokeInstances?: {
    invokeInstance?: [ 
    {
      instanceId?: string(name='InstanceId'),
      instanceInvokeStatus?: string(name='InstanceInvokeStatus'),
    }
  ](name='InvokeInstance')
  }(name='InvokeInstances'),
}

model ListInvocationStatusResponse = {
  headers: map[string]string(name='headers'),
  body: ListInvocationStatusResponseBody(name='body'),
}

async function listInvocationStatusWithOptions(request: ListInvocationStatusRequest, runtime: Util.RuntimeOptions): ListInvocationStatusResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListInvocationStatus', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listInvocationStatus(request: ListInvocationStatusRequest): ListInvocationStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInvocationStatusWithOptions(request, runtime);
}

model ListJobsRequest {
  clusterId?: string(name='ClusterId'),
  owner?: string(name='Owner'),
  state?: string(name='State'),
  rerunable?: string(name='Rerunable'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListJobsResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  jobs?: {
    jobInfo?: [ 
    {
      owner?: string(name='Owner'),
      comment?: string(name='Comment'),
      stderr?: string(name='Stderr'),
      state?: string(name='State'),
      priority?: string(name='Priority'),
      shellPath?: string(name='ShellPath'),
      stdout?: string(name='Stdout'),
      arrayRequest?: string(name='ArrayRequest'),
      startTime?: string(name='StartTime'),
      lastModifyTime?: string(name='LastModifyTime'),
      nodeList?: string(name='NodeList'),
      name?: string(name='Name'),
      id?: string(name='Id'),
      submitTime?: string(name='SubmitTime'),
      resources?: {
        nodes?: int32(name='Nodes'),
        cores?: int32(name='Cores'),
      }(name='Resources'),
    }
  ](name='JobInfo')
  }(name='Jobs'),
}

model ListJobsResponse = {
  headers: map[string]string(name='headers'),
  body: ListJobsResponseBody(name='body'),
}

async function listJobsWithOptions(request: ListJobsRequest, runtime: Util.RuntimeOptions): ListJobsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListJobs', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listJobs(request: ListJobsRequest): ListJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listJobsWithOptions(request, runtime);
}

model ListJobTemplatesRequest {
  name?: string(name='Name'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListJobTemplatesResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  templates?: {
    jobTemplates?: [ 
    {
      task?: int32(name='Task'),
      commandLine?: string(name='CommandLine'),
      variables?: string(name='Variables'),
      priority?: int32(name='Priority'),
      queue?: string(name='Queue'),
      mem?: string(name='Mem'),
      arrayRequest?: string(name='ArrayRequest'),
      thread?: int32(name='Thread'),
      stderrRedirectPath?: string(name='StderrRedirectPath'),
      stdoutRedirectPath?: string(name='StdoutRedirectPath'),
      node?: int32(name='Node'),
      gpu?: int32(name='Gpu'),
      packagePath?: string(name='PackagePath'),
      clockTime?: string(name='ClockTime'),
      reRunable?: boolean(name='ReRunable'),
      name?: string(name='Name'),
      id?: string(name='Id'),
      runasUser?: string(name='RunasUser'),
    }
  ](name='JobTemplates')
  }(name='Templates'),
}

model ListJobTemplatesResponse = {
  headers: map[string]string(name='headers'),
  body: ListJobTemplatesResponseBody(name='body'),
}

async function listJobTemplatesWithOptions(request: ListJobTemplatesRequest, runtime: Util.RuntimeOptions): ListJobTemplatesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListJobTemplates', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listJobTemplates(request: ListJobTemplatesRequest): ListJobTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listJobTemplatesWithOptions(request, runtime);
}

model ListNodesRequest {
  clusterId?: string(name='ClusterId'),
  role?: string(name='Role'),
  hostName?: string(name='HostName'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  sequence?: string(name='Sequence'),
  sortBy?: string(name='SortBy'),
  filter?: string(name='Filter'),
  privateIpAddress?: string(name='PrivateIpAddress'),
}

model ListNodesResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  nodes?: {
    nodeInfo?: [ 
    {
      status?: string(name='Status'),
      vpcId?: string(name='VpcId'),
      expired?: boolean(name='Expired'),
      usedResources?: {
        cpu?: int32(name='Cpu'),
        gpu?: int32(name='Gpu'),
        memory?: int32(name='Memory'),
      }(name='UsedResources'),
      spotStrategy?: string(name='SpotStrategy'),
      publicIpAddress?: string(name='PublicIpAddress'),
      createdByEhpc?: boolean(name='CreatedByEhpc'),
      ipAddress?: string(name='IpAddress'),
      version?: string(name='Version'),
      addTime?: string(name='AddTime'),
      imageId?: string(name='ImageId'),
      createMode?: string(name='CreateMode'),
      htEnabled?: boolean(name='HtEnabled'),
      imageOwnerAlias?: string(name='ImageOwnerAlias'),
      roles?: {
        role?: [ string ](name='Role')
      }(name='Roles'),
      lockReason?: string(name='LockReason'),
      hostName?: string(name='HostName'),
      instanceType?: string(name='InstanceType'),
      regionId?: string(name='RegionId'),
      totalResources?: {
        cpu?: int32(name='Cpu'),
        gpu?: int32(name='Gpu'),
        memory?: int32(name='Memory'),
      }(name='TotalResources'),
      vSwitchId?: string(name='VSwitchId'),
      expiredTime?: string(name='ExpiredTime'),
      zoneId?: string(name='ZoneId'),
      id?: string(name='Id'),
      location?: string(name='Location'),
    }
  ](name='NodeInfo')
  }(name='Nodes'),
}

model ListNodesResponse = {
  headers: map[string]string(name='headers'),
  body: ListNodesResponseBody(name='body'),
}

async function listNodesWithOptions(request: ListNodesRequest, runtime: Util.RuntimeOptions): ListNodesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListNodes', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listNodes(request: ListNodesRequest): ListNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNodesWithOptions(request, runtime);
}

model ListNodesByQueueRequest {
  clusterId?: string(name='ClusterId'),
  queueName?: string(name='QueueName'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListNodesByQueueResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  nodes?: {
    nodeInfo?: [ 
    {
      status?: string(name='Status'),
      vpcId?: string(name='VpcId'),
      htEnabled?: boolean(name='HtEnabled'),
      expired?: boolean(name='Expired'),
      imageOwnerAlias?: string(name='ImageOwnerAlias'),
      hostName?: string(name='HostName'),
      lockReason?: string(name='LockReason'),
      usedResources?: {
        cpu?: int32(name='Cpu'),
        gpu?: int32(name='Gpu'),
        memory?: int32(name='Memory'),
      }(name='UsedResources'),
      spotStrategy?: string(name='SpotStrategy'),
      publicIpAddress?: string(name='PublicIpAddress'),
      regionId?: string(name='RegionId'),
      createdByEhpc?: boolean(name='CreatedByEhpc'),
      vSwitchId?: string(name='VSwitchId'),
      totalResources?: {
        cpu?: int32(name='Cpu'),
        gpu?: int32(name='Gpu'),
        memory?: int32(name='Memory'),
      }(name='TotalResources'),
      ipAddress?: string(name='IpAddress'),
      expiredTime?: string(name='ExpiredTime'),
      version?: string(name='Version'),
      zoneId?: string(name='ZoneId'),
      addTime?: string(name='AddTime'),
      imageId?: string(name='ImageId'),
      location?: string(name='Location'),
      id?: string(name='Id'),
      createMode?: string(name='CreateMode'),
    }
  ](name='NodeInfo')
  }(name='Nodes'),
}

model ListNodesByQueueResponse = {
  headers: map[string]string(name='headers'),
  body: ListNodesByQueueResponseBody(name='body'),
}

async function listNodesByQueueWithOptions(request: ListNodesByQueueRequest, runtime: Util.RuntimeOptions): ListNodesByQueueResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListNodesByQueue', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listNodesByQueue(request: ListNodesByQueueRequest): ListNodesByQueueResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNodesByQueueWithOptions(request, runtime);
}

model ListNodesNoPagingRequest {
  clusterId?: string(name='ClusterId'),
  role?: string(name='Role'),
  hostName?: string(name='HostName'),
  onlyDetached?: boolean(name='OnlyDetached'),
  sequence?: string(name='Sequence'),
}

model ListNodesNoPagingResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  nodes?: {
    nodeInfo?: [ 
    {
      status?: string(name='Status'),
      hostName?: string(name='HostName'),
      instanceType?: string(name='InstanceType'),
      regionId?: string(name='RegionId'),
      imageId?: string(name='ImageId'),
      id?: string(name='Id'),
    }
  ](name='NodeInfo')
  }(name='Nodes'),
}

model ListNodesNoPagingResponse = {
  headers: map[string]string(name='headers'),
  body: ListNodesNoPagingResponseBody(name='body'),
}

async function listNodesNoPagingWithOptions(request: ListNodesNoPagingRequest, runtime: Util.RuntimeOptions): ListNodesNoPagingResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListNodesNoPaging', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listNodesNoPaging(request: ListNodesNoPagingRequest): ListNodesNoPagingResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNodesNoPagingWithOptions(request, runtime);
}

model ListPreferredEcsTypesRequest {
  zoneId?: string(name='ZoneId'),
  spotStrategy?: string(name='SpotStrategy'),
  instanceChargeType?: string(name='InstanceChargeType'),
}

model ListPreferredEcsTypesResponseBody = {
  series?: {
    seriesInfo?: [ 
    {
      seriesId?: string(name='SeriesId'),
      seriesName?: string(name='SeriesName'),
      roles?: {
        manager?: {
          instanceTypeId?: [ string ](name='InstanceTypeId')
        }(name='Manager'),
        compute?: {
          instanceTypeId?: [ string ](name='InstanceTypeId')
        }(name='Compute'),
        login?: {
          instanceTypeId?: [ string ](name='InstanceTypeId')
        }(name='Login'),
      }(name='Roles'),
    }
  ](name='SeriesInfo')
  }(name='Series'),
  supportSpotInstance?: boolean(name='SupportSpotInstance'),
  requestId?: string(name='RequestId'),
}

model ListPreferredEcsTypesResponse = {
  headers: map[string]string(name='headers'),
  body: ListPreferredEcsTypesResponseBody(name='body'),
}

async function listPreferredEcsTypesWithOptions(request: ListPreferredEcsTypesRequest, runtime: Util.RuntimeOptions): ListPreferredEcsTypesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListPreferredEcsTypes', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listPreferredEcsTypes(request: ListPreferredEcsTypesRequest): ListPreferredEcsTypesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPreferredEcsTypesWithOptions(request, runtime);
}

model ListQueuesRequest {
  clusterId?: string(name='ClusterId'),
}

model ListQueuesResponseBody = {
  requestId?: string(name='RequestId'),
  queues?: {
    queueInfo?: [ 
    {
      type?: string(name='Type'),
      hostNamePrefix?: string(name='HostNamePrefix'),
      queueName?: string(name='QueueName'),
      enableAutoGrow?: boolean(name='EnableAutoGrow'),
      resourceGroupId?: string(name='ResourceGroupId'),
      imageId?: string(name='ImageId'),
      hostNameSuffix?: string(name='HostNameSuffix'),
      computeInstanceType?: {
        instanceType?: [ string ](name='InstanceType')
      }(name='ComputeInstanceType'),
      spotStrategy?: string(name='SpotStrategy'),
      spotInstanceTypes?: {
        instance?: [ 
        {
          spotPriceLimit?: float(name='SpotPriceLimit'),
          instanceType?: string(name='InstanceType'),
        }
      ](name='Instance')
      }(name='SpotInstanceTypes'),
    }
  ](name='QueueInfo')
  }(name='Queues'),
}

model ListQueuesResponse = {
  headers: map[string]string(name='headers'),
  body: ListQueuesResponseBody(name='body'),
}

async function listQueuesWithOptions(request: ListQueuesRequest, runtime: Util.RuntimeOptions): ListQueuesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListQueues', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listQueues(request: ListQueuesRequest): ListQueuesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listQueuesWithOptions(request, runtime);
}

model ListRegionsResponseBody = {
  requestId?: string(name='RequestId'),
  regions?: {
    regionInfo?: [ 
    {
      localName?: string(name='LocalName'),
      regionId?: string(name='RegionId'),
    }
  ](name='RegionInfo')
  }(name='Regions'),
}

model ListRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListRegionsResponseBody(name='body'),
}

async function listRegionsWithOptions(runtime: Util.RuntimeOptions): ListRegionsResponse {
  var req = new OpenApi.OpenApiRequest{};
  return doRPCRequest('ListRegions', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listRegions(): ListRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRegionsWithOptions(runtime);
}

model ListSecurityGroupsRequest {
  clusterId?: string(name='ClusterId'),
}

model ListSecurityGroupsResponseBody = {
  securityGroups?: {
    securityGroup?: [ string ](name='SecurityGroup')
  }(name='SecurityGroups'),
  totalCount?: int32(name='TotalCount'),
  requestId?: string(name='RequestId'),
}

model ListSecurityGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: ListSecurityGroupsResponseBody(name='body'),
}

async function listSecurityGroupsWithOptions(request: ListSecurityGroupsRequest, runtime: Util.RuntimeOptions): ListSecurityGroupsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListSecurityGroups', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listSecurityGroups(request: ListSecurityGroupsRequest): ListSecurityGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSecurityGroupsWithOptions(request, runtime);
}

model ListSoftwaresRequest {
  ehpcVersion?: string(name='EhpcVersion'),
  osTag?: string(name='OsTag'),
}

model ListSoftwaresResponseBody = {
  requestId?: string(name='RequestId'),
  softwares?: {
    softwareInfo?: [ 
    {
      schedulerType?: string(name='SchedulerType'),
      osTag?: string(name='OsTag'),
      schedulerVersion?: string(name='SchedulerVersion'),
      accountVersion?: string(name='AccountVersion'),
      applications?: {
        applicationInfo?: [ 
        {
          required?: boolean(name='Required'),
          version?: string(name='Version'),
          tag?: string(name='Tag'),
          name?: string(name='Name'),
        }
      ](name='ApplicationInfo')
      }(name='Applications'),
      accountType?: string(name='AccountType'),
      ehpcVersion?: string(name='EhpcVersion'),
    }
  ](name='SoftwareInfo')
  }(name='Softwares'),
}

model ListSoftwaresResponse = {
  headers: map[string]string(name='headers'),
  body: ListSoftwaresResponseBody(name='body'),
}

async function listSoftwaresWithOptions(request: ListSoftwaresRequest, runtime: Util.RuntimeOptions): ListSoftwaresResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListSoftwares', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listSoftwares(request: ListSoftwaresRequest): ListSoftwaresResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSoftwaresWithOptions(request, runtime);
}

model ListTasksRequest {
  clusterId?: string(name='ClusterId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  taskId?: string(name='TaskId'),
  archived?: boolean(name='Archived'),
}

model ListTasksResponseBody = {
  totalCount?: int32(name='TotalCount'),
  tasks?: [ 
    {
      status?: string(name='Status'),
      taskType?: string(name='TaskType'),
      totalSteps?: int32(name='TotalSteps'),
      currentStep?: int32(name='CurrentStep'),
      result?: string(name='Result'),
      errors?: string(name='Errors'),
      taskId?: string(name='TaskId'),
      request?: string(name='Request'),
      clusterId?: string(name='ClusterId'),
    }
  ](name='Tasks'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
}

model ListTasksResponse = {
  headers: map[string]string(name='headers'),
  body: ListTasksResponseBody(name='body'),
}

async function listTasksWithOptions(request: ListTasksRequest, runtime: Util.RuntimeOptions): ListTasksResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListTasks', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listTasks(request: ListTasksRequest): ListTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTasksWithOptions(request, runtime);
}

model ListUsersRequest {
  clusterId?: string(name='ClusterId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListUsersResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  users?: {
    userInfo?: [ 
    {
      name?: string(name='Name'),
      addTime?: string(name='AddTime'),
      group?: string(name='Group'),
    }
  ](name='UserInfo')
  }(name='Users'),
}

model ListUsersResponse = {
  headers: map[string]string(name='headers'),
  body: ListUsersResponseBody(name='body'),
}

async function listUsersWithOptions(request: ListUsersRequest, runtime: Util.RuntimeOptions): ListUsersResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListUsers', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listUsers(request: ListUsersRequest): ListUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUsersWithOptions(request, runtime);
}

model ListVolumesRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListVolumesResponseBody = {
  totalCount?: int32(name='TotalCount'),
  volumes?: {
    volumeInfo?: [ 
    {
      volumeId?: string(name='VolumeId'),
      clusterName?: string(name='ClusterName'),
      remoteDirectory?: string(name='RemoteDirectory'),
      volumeMountpoint?: string(name='VolumeMountpoint'),
      additionalVolumes?: {
        volumeInfo?: [ 
        {
          jobQueue?: string(name='JobQueue'),
          volumeId?: string(name='VolumeId'),
          remoteDirectory?: string(name='RemoteDirectory'),
          volumeMountpoint?: string(name='VolumeMountpoint'),
          role?: string(name='Role'),
          localDirectory?: string(name='LocalDirectory'),
          volumeType?: string(name='VolumeType'),
          location?: string(name='Location'),
          volumeProtocol?: string(name='VolumeProtocol'),
        }
      ](name='VolumeInfo')
      }(name='AdditionalVolumes'),
      volumeType?: string(name='VolumeType'),
      volumeProtocol?: string(name='VolumeProtocol'),
      regionId?: string(name='RegionId'),
      clusterId?: string(name='ClusterId'),
    }
  ](name='VolumeInfo')
  }(name='Volumes'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
}

model ListVolumesResponse = {
  headers: map[string]string(name='headers'),
  body: ListVolumesResponseBody(name='body'),
}

async function listVolumesWithOptions(request: ListVolumesRequest, runtime: Util.RuntimeOptions): ListVolumesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListVolumes', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listVolumes(request: ListVolumesRequest): ListVolumesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVolumesWithOptions(request, runtime);
}

model ModifyClusterAttributesRequest {
  clusterId?: string(name='ClusterId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  imageOwnerAlias?: string(name='ImageOwnerAlias'),
  imageId?: string(name='ImageId'),
}

model ModifyClusterAttributesResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyClusterAttributesResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyClusterAttributesResponseBody(name='body'),
}

async function modifyClusterAttributesWithOptions(request: ModifyClusterAttributesRequest, runtime: Util.RuntimeOptions): ModifyClusterAttributesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ModifyClusterAttributes', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function modifyClusterAttributes(request: ModifyClusterAttributesRequest): ModifyClusterAttributesResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyClusterAttributesWithOptions(request, runtime);
}

model ModifyContainerAppAttributesRequest {
  containerId?: string(name='ContainerId'),
  description?: string(name='Description'),
}

model ModifyContainerAppAttributesResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyContainerAppAttributesResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyContainerAppAttributesResponseBody(name='body'),
}

async function modifyContainerAppAttributesWithOptions(request: ModifyContainerAppAttributesRequest, runtime: Util.RuntimeOptions): ModifyContainerAppAttributesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ModifyContainerAppAttributes', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function modifyContainerAppAttributes(request: ModifyContainerAppAttributesRequest): ModifyContainerAppAttributesResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyContainerAppAttributesWithOptions(request, runtime);
}

model ModifyImageGatewayConfigRequest {
  clusterId?: string(name='ClusterId'),
  DBType?: string(name='DBType'),
  DBUsername?: string(name='DBUsername'),
  DBPassword?: string(name='DBPassword'),
  DBServerInfo?: string(name='DBServerInfo'),
  defaultRepoLocation?: string(name='DefaultRepoLocation'),
  pullUpdateTimeout?: int32(name='PullUpdateTimeout'),
  imageExpirationTimeout?: string(name='ImageExpirationTimeout'),
  repo?: [ 
    {
      auth?: string(name='Auth'),
      URL?: string(name='URL'),
      location?: string(name='Location'),
    }
  ](name='Repo'),
}

model ModifyImageGatewayConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyImageGatewayConfigResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyImageGatewayConfigResponseBody(name='body'),
}

async function modifyImageGatewayConfigWithOptions(request: ModifyImageGatewayConfigRequest, runtime: Util.RuntimeOptions): ModifyImageGatewayConfigResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ModifyImageGatewayConfig', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function modifyImageGatewayConfig(request: ModifyImageGatewayConfigRequest): ModifyImageGatewayConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyImageGatewayConfigWithOptions(request, runtime);
}

model ModifyUserGroupsRequest {
  clusterId?: string(name='ClusterId'),
  user?: [ 
    {
      name?: string(name='Name'),
      group?: string(name='Group'),
    }
  ](name='User'),
}

model ModifyUserGroupsResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyUserGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyUserGroupsResponseBody(name='body'),
}

async function modifyUserGroupsWithOptions(request: ModifyUserGroupsRequest, runtime: Util.RuntimeOptions): ModifyUserGroupsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ModifyUserGroups', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function modifyUserGroups(request: ModifyUserGroupsRequest): ModifyUserGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyUserGroupsWithOptions(request, runtime);
}

model ModifyUserPasswordsRequest {
  clusterId?: string(name='ClusterId'),
  user?: [ 
    {
      password?: string(name='Password'),
      name?: string(name='Name'),
    }
  ](name='User'),
}

model ModifyUserPasswordsResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyUserPasswordsResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyUserPasswordsResponseBody(name='body'),
}

async function modifyUserPasswordsWithOptions(request: ModifyUserPasswordsRequest, runtime: Util.RuntimeOptions): ModifyUserPasswordsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ModifyUserPasswords', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function modifyUserPasswords(request: ModifyUserPasswordsRequest): ModifyUserPasswordsResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyUserPasswordsWithOptions(request, runtime);
}

model ModifyVisualServicePasswdRequest {
  clusterId?: string(name='ClusterId'),
  runasUser?: string(name='RunasUser'),
  runasUserPassword?: string(name='RunasUserPassword'),
  passwd?: string(name='Passwd'),
}

model ModifyVisualServicePasswdResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ModifyVisualServicePasswdResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyVisualServicePasswdResponseBody(name='body'),
}

async function modifyVisualServicePasswdWithOptions(request: ModifyVisualServicePasswdRequest, runtime: Util.RuntimeOptions): ModifyVisualServicePasswdResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ModifyVisualServicePasswd', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function modifyVisualServicePasswd(request: ModifyVisualServicePasswdRequest): ModifyVisualServicePasswdResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyVisualServicePasswdWithOptions(request, runtime);
}

model MountNFSRequest {
  instanceId?: string(name='InstanceId'),
  nfsDir?: string(name='NfsDir'),
  mountDir?: string(name='MountDir'),
  protocolType?: string(name='ProtocolType'),
  remoteDir?: string(name='RemoteDir'),
}

model MountNFSResponseBody = {
  requestId?: string(name='RequestId'),
  invokeId?: string(name='InvokeId'),
}

model MountNFSResponse = {
  headers: map[string]string(name='headers'),
  body: MountNFSResponseBody(name='body'),
}

async function mountNFSWithOptions(request: MountNFSRequest, runtime: Util.RuntimeOptions): MountNFSResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('MountNFS', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function mountNFS(request: MountNFSRequest): MountNFSResponse {
  var runtime = new Util.RuntimeOptions{};
  return mountNFSWithOptions(request, runtime);
}

model PullImageRequest {
  clusterId?: string(name='ClusterId'),
  repository?: string(name='Repository'),
  imageTag?: string(name='ImageTag'),
  containerType?: string(name='ContainerType'),
}

model PullImageResponseBody = {
  requestId?: string(name='RequestId'),
}

model PullImageResponse = {
  headers: map[string]string(name='headers'),
  body: PullImageResponseBody(name='body'),
}

async function pullImageWithOptions(request: PullImageRequest, runtime: Util.RuntimeOptions): PullImageResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('PullImage', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function pullImage(request: PullImageRequest): PullImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return pullImageWithOptions(request, runtime);
}

model QueryServicePackAndPriceResponseBody = {
  originalPrice?: float(name='OriginalPrice'),
  requestId?: string(name='RequestId'),
  discountPrice?: float(name='DiscountPrice'),
  currency?: string(name='Currency'),
  servicePack?: {
    servicePackInfo?: [ 
    {
      endTime?: int32(name='EndTime'),
      capacity?: int32(name='Capacity'),
      startTime?: int32(name='StartTime'),
      instanceName?: string(name='InstanceName'),
    }
  ](name='ServicePackInfo')
  }(name='ServicePack'),
  regionId?: string(name='RegionId'),
  tradePrice?: float(name='TradePrice'),
  originalAmount?: int32(name='OriginalAmount'),
  chargeAmount?: int32(name='ChargeAmount'),
}

model QueryServicePackAndPriceResponse = {
  headers: map[string]string(name='headers'),
  body: QueryServicePackAndPriceResponseBody(name='body'),
}

async function queryServicePackAndPriceWithOptions(runtime: Util.RuntimeOptions): QueryServicePackAndPriceResponse {
  var req = new OpenApi.OpenApiRequest{};
  return doRPCRequest('QueryServicePackAndPrice', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function queryServicePackAndPrice(): QueryServicePackAndPriceResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryServicePackAndPriceWithOptions(runtime);
}

model RecoverClusterRequest {
  clusterId?: string(name='ClusterId'),
  osTag?: string(name='OsTag'),
  accountType?: string(name='AccountType'),
  schedulerType?: string(name='SchedulerType'),
  imageOwnerAlias?: string(name='ImageOwnerAlias'),
  imageId?: string(name='ImageId'),
  clientVersion?: string(name='ClientVersion'),
}

model RecoverClusterResponseBody = {
  taskId?: string(name='TaskId'),
  requestId?: string(name='RequestId'),
}

model RecoverClusterResponse = {
  headers: map[string]string(name='headers'),
  body: RecoverClusterResponseBody(name='body'),
}

async function recoverClusterWithOptions(request: RecoverClusterRequest, runtime: Util.RuntimeOptions): RecoverClusterResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('RecoverCluster', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function recoverCluster(request: RecoverClusterRequest): RecoverClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return recoverClusterWithOptions(request, runtime);
}

model RerunJobsRequest {
  clusterId?: string(name='ClusterId'),
  jobs?: string(name='Jobs'),
}

model RerunJobsResponseBody = {
  requestId?: string(name='RequestId'),
}

model RerunJobsResponse = {
  headers: map[string]string(name='headers'),
  body: RerunJobsResponseBody(name='body'),
}

async function rerunJobsWithOptions(request: RerunJobsRequest, runtime: Util.RuntimeOptions): RerunJobsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('RerunJobs', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function rerunJobs(request: RerunJobsRequest): RerunJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return rerunJobsWithOptions(request, runtime);
}

model ResetNodesRequest {
  clusterId?: string(name='ClusterId'),
  instance?: [ 
    {
      id?: string(name='Id'),
    }
  ](name='Instance'),
}

model ResetNodesResponseBody = {
  taskId?: string(name='TaskId'),
  requestId?: string(name='RequestId'),
}

model ResetNodesResponse = {
  headers: map[string]string(name='headers'),
  body: ResetNodesResponseBody(name='body'),
}

async function resetNodesWithOptions(request: ResetNodesRequest, runtime: Util.RuntimeOptions): ResetNodesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ResetNodes', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function resetNodes(request: ResetNodesRequest): ResetNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return resetNodesWithOptions(request, runtime);
}

model RunCloudMetricProfilingRequest {
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  hostName?: string(name='HostName'),
  processId?: int32(name='ProcessId'),
  duration?: int32(name='Duration'),
  freq?: int32(name='Freq'),
}

model RunCloudMetricProfilingResponseBody = {
  requestId?: string(name='RequestId'),
}

model RunCloudMetricProfilingResponse = {
  headers: map[string]string(name='headers'),
  body: RunCloudMetricProfilingResponseBody(name='body'),
}

async function runCloudMetricProfilingWithOptions(request: RunCloudMetricProfilingRequest, runtime: Util.RuntimeOptions): RunCloudMetricProfilingResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('RunCloudMetricProfiling', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function runCloudMetricProfiling(request: RunCloudMetricProfilingRequest): RunCloudMetricProfilingResponse {
  var runtime = new Util.RuntimeOptions{};
  return runCloudMetricProfilingWithOptions(request, runtime);
}

model SetAutoScaleConfigRequest {
  clusterId?: string(name='ClusterId'),
  enableAutoGrow?: boolean(name='EnableAutoGrow'),
  enableAutoShrink?: boolean(name='EnableAutoShrink'),
  growIntervalInMinutes?: int32(name='GrowIntervalInMinutes'),
  shrinkIntervalInMinutes?: int32(name='ShrinkIntervalInMinutes'),
  shrinkIdleTimes?: int32(name='ShrinkIdleTimes'),
  growTimeoutInMinutes?: int32(name='GrowTimeoutInMinutes'),
  extraNodesGrowRatio?: int32(name='ExtraNodesGrowRatio'),
  growRatio?: int32(name='GrowRatio'),
  maxNodesInCluster?: int32(name='MaxNodesInCluster'),
  excludeNodes?: string(name='ExcludeNodes'),
  spotStrategy?: string(name='SpotStrategy'),
  spotPriceLimit?: float(name='SpotPriceLimit'),
  imageId?: string(name='ImageId'),
  queues?: [ 
    {
      minNodesInQueue?: int32(name='MinNodesInQueue'),
      maxNodesInQueue?: int32(name='MaxNodesInQueue'),
      enableAutoShrink?: boolean(name='EnableAutoShrink'),
      queueName?: string(name='QueueName'),
      enableAutoGrow?: boolean(name='EnableAutoGrow'),
      queueImageId?: string(name='QueueImageId'),
      spotPriceLimit?: float(name='SpotPriceLimit'),
      instanceTypes?: [ 
        {
          hostNamePrefix?: string(name='HostNamePrefix'),
          vSwitchId?: string(name='VSwitchId'),
          zoneId?: string(name='ZoneId'),
          spotPriceLimit?: float(name='SpotPriceLimit'),
          instanceType?: string(name='InstanceType'),
          spotStrategy?: string(name='SpotStrategy'),
        }
      ](name='InstanceTypes'),
      instanceType?: string(name='InstanceType'),
      spotStrategy?: string(name='SpotStrategy'),
    }
  ](name='Queues'),
}

model SetAutoScaleConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetAutoScaleConfigResponse = {
  headers: map[string]string(name='headers'),
  body: SetAutoScaleConfigResponseBody(name='body'),
}

async function setAutoScaleConfigWithOptions(request: SetAutoScaleConfigRequest, runtime: Util.RuntimeOptions): SetAutoScaleConfigResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('SetAutoScaleConfig', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function setAutoScaleConfig(request: SetAutoScaleConfigRequest): SetAutoScaleConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return setAutoScaleConfigWithOptions(request, runtime);
}

model SetGWSClusterPolicyRequest {
  clusterId?: string(name='ClusterId'),
  clipboard?: string(name='Clipboard'),
  localDrive?: string(name='LocalDrive'),
  usbRedirect?: string(name='UsbRedirect'),
  watermark?: string(name='Watermark'),
  udpPort?: string(name='UdpPort'),
  asyncMode?: boolean(name='AsyncMode'),
}

model SetGWSClusterPolicyResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetGWSClusterPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: SetGWSClusterPolicyResponseBody(name='body'),
}

async function setGWSClusterPolicyWithOptions(request: SetGWSClusterPolicyRequest, runtime: Util.RuntimeOptions): SetGWSClusterPolicyResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SetGWSClusterPolicy', '2018-04-12', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function setGWSClusterPolicy(request: SetGWSClusterPolicyRequest): SetGWSClusterPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return setGWSClusterPolicyWithOptions(request, runtime);
}

model SetGWSInstanceNameRequest {
  instanceId?: string(name='InstanceId'),
  name?: string(name='Name'),
}

model SetGWSInstanceNameResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetGWSInstanceNameResponse = {
  headers: map[string]string(name='headers'),
  body: SetGWSInstanceNameResponseBody(name='body'),
}

async function setGWSInstanceNameWithOptions(request: SetGWSInstanceNameRequest, runtime: Util.RuntimeOptions): SetGWSInstanceNameResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('SetGWSInstanceName', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function setGWSInstanceName(request: SetGWSInstanceNameRequest): SetGWSInstanceNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return setGWSInstanceNameWithOptions(request, runtime);
}

model SetGWSInstanceUserRequest {
  instanceId?: string(name='InstanceId'),
  userUid?: string(name='UserUid'),
  userName?: string(name='UserName'),
}

model SetGWSInstanceUserResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetGWSInstanceUserResponse = {
  headers: map[string]string(name='headers'),
  body: SetGWSInstanceUserResponseBody(name='body'),
}

async function setGWSInstanceUserWithOptions(request: SetGWSInstanceUserRequest, runtime: Util.RuntimeOptions): SetGWSInstanceUserResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('SetGWSInstanceUser', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function setGWSInstanceUser(request: SetGWSInstanceUserRequest): SetGWSInstanceUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return setGWSInstanceUserWithOptions(request, runtime);
}

model SetJobUserRequest {
  clusterId?: string(name='ClusterId'),
  runasUser?: string(name='RunasUser'),
  runasUserPassword?: string(name='RunasUserPassword'),
}

model SetJobUserResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetJobUserResponse = {
  headers: map[string]string(name='headers'),
  body: SetJobUserResponseBody(name='body'),
}

async function setJobUserWithOptions(request: SetJobUserRequest, runtime: Util.RuntimeOptions): SetJobUserResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('SetJobUser', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function setJobUser(request: SetJobUserRequest): SetJobUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return setJobUserWithOptions(request, runtime);
}

model SetQueueRequest {
  clusterId?: string(name='ClusterId'),
  queueName?: string(name='QueueName'),
  node?: [ 
    {
      name?: string(name='Name'),
    }
  ](name='Node'),
}

model SetQueueResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetQueueResponse = {
  headers: map[string]string(name='headers'),
  body: SetQueueResponseBody(name='body'),
}

async function setQueueWithOptions(request: SetQueueRequest, runtime: Util.RuntimeOptions): SetQueueResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('SetQueue', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function setQueue(request: SetQueueRequest): SetQueueResponse {
  var runtime = new Util.RuntimeOptions{};
  return setQueueWithOptions(request, runtime);
}

model StartClusterRequest {
  clusterId?: string(name='ClusterId'),
}

model StartClusterResponseBody = {
  taskId?: string(name='TaskId'),
  requestId?: string(name='RequestId'),
}

model StartClusterResponse = {
  headers: map[string]string(name='headers'),
  body: StartClusterResponseBody(name='body'),
}

async function startClusterWithOptions(request: StartClusterRequest, runtime: Util.RuntimeOptions): StartClusterResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('StartCluster', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function startCluster(request: StartClusterRequest): StartClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return startClusterWithOptions(request, runtime);
}

model StartGWSInstanceRequest {
  instanceId?: string(name='InstanceId'),
}

model StartGWSInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model StartGWSInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: StartGWSInstanceResponseBody(name='body'),
}

async function startGWSInstanceWithOptions(request: StartGWSInstanceRequest, runtime: Util.RuntimeOptions): StartGWSInstanceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('StartGWSInstance', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function startGWSInstance(request: StartGWSInstanceRequest): StartGWSInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return startGWSInstanceWithOptions(request, runtime);
}

model StartNodesRequest {
  clusterId?: string(name='ClusterId'),
  role?: string(name='Role'),
  instance?: [ 
    {
      id?: string(name='Id'),
    }
  ](name='Instance'),
}

model StartNodesResponseBody = {
  taskId?: string(name='TaskId'),
  requestId?: string(name='RequestId'),
}

model StartNodesResponse = {
  headers: map[string]string(name='headers'),
  body: StartNodesResponseBody(name='body'),
}

async function startNodesWithOptions(request: StartNodesRequest, runtime: Util.RuntimeOptions): StartNodesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('StartNodes', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function startNodes(request: StartNodesRequest): StartNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return startNodesWithOptions(request, runtime);
}

model StartVisualServiceRequest {
  clusterId?: string(name='ClusterId'),
  cidrIp?: string(name='CidrIp'),
  port?: int32(name='Port'),
}

model StartVisualServiceResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model StartVisualServiceResponse = {
  headers: map[string]string(name='headers'),
  body: StartVisualServiceResponseBody(name='body'),
}

async function startVisualServiceWithOptions(request: StartVisualServiceRequest, runtime: Util.RuntimeOptions): StartVisualServiceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('StartVisualService', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function startVisualService(request: StartVisualServiceRequest): StartVisualServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return startVisualServiceWithOptions(request, runtime);
}

model StopClusterRequest {
  clusterId?: string(name='ClusterId'),
}

model StopClusterResponseBody = {
  taskId?: string(name='TaskId'),
  requestId?: string(name='RequestId'),
}

model StopClusterResponse = {
  headers: map[string]string(name='headers'),
  body: StopClusterResponseBody(name='body'),
}

async function stopClusterWithOptions(request: StopClusterRequest, runtime: Util.RuntimeOptions): StopClusterResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('StopCluster', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function stopCluster(request: StopClusterRequest): StopClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopClusterWithOptions(request, runtime);
}

model StopGWSInstanceRequest {
  instanceId?: string(name='InstanceId'),
}

model StopGWSInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model StopGWSInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: StopGWSInstanceResponseBody(name='body'),
}

async function stopGWSInstanceWithOptions(request: StopGWSInstanceRequest, runtime: Util.RuntimeOptions): StopGWSInstanceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('StopGWSInstance', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function stopGWSInstance(request: StopGWSInstanceRequest): StopGWSInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopGWSInstanceWithOptions(request, runtime);
}

model StopJobsRequest {
  clusterId?: string(name='ClusterId'),
  jobs?: string(name='Jobs'),
}

model StopJobsResponseBody = {
  requestId?: string(name='RequestId'),
}

model StopJobsResponse = {
  headers: map[string]string(name='headers'),
  body: StopJobsResponseBody(name='body'),
}

async function stopJobsWithOptions(request: StopJobsRequest, runtime: Util.RuntimeOptions): StopJobsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('StopJobs', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function stopJobs(request: StopJobsRequest): StopJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopJobsWithOptions(request, runtime);
}

model StopNodesRequest {
  clusterId?: string(name='ClusterId'),
  role?: string(name='Role'),
  instance?: [ 
    {
      id?: string(name='Id'),
    }
  ](name='Instance'),
}

model StopNodesResponseBody = {
  taskId?: string(name='TaskId'),
  requestId?: string(name='RequestId'),
}

model StopNodesResponse = {
  headers: map[string]string(name='headers'),
  body: StopNodesResponseBody(name='body'),
}

async function stopNodesWithOptions(request: StopNodesRequest, runtime: Util.RuntimeOptions): StopNodesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('StopNodes', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function stopNodes(request: StopNodesRequest): StopNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopNodesWithOptions(request, runtime);
}

model StopVisualServiceRequest {
  clusterId?: string(name='ClusterId'),
  cidrIp?: string(name='CidrIp'),
  port?: int32(name='Port'),
}

model StopVisualServiceResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model StopVisualServiceResponse = {
  headers: map[string]string(name='headers'),
  body: StopVisualServiceResponseBody(name='body'),
}

async function stopVisualServiceWithOptions(request: StopVisualServiceRequest, runtime: Util.RuntimeOptions): StopVisualServiceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('StopVisualService', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function stopVisualService(request: StopVisualServiceRequest): StopVisualServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopVisualServiceWithOptions(request, runtime);
}

model SubmitJobRequest {
  clusterId?: string(name='ClusterId'),
  commandLine?: string(name='CommandLine'),
  runasUser?: string(name='RunasUser'),
  runasUserPassword?: string(name='RunasUserPassword'),
  name?: string(name='Name'),
  priority?: int32(name='Priority'),
  packagePath?: string(name='PackagePath'),
  stdoutRedirectPath?: string(name='StdoutRedirectPath'),
  stderrRedirectPath?: string(name='StderrRedirectPath'),
  reRunable?: boolean(name='ReRunable'),
  arrayRequest?: string(name='ArrayRequest'),
  variables?: string(name='Variables'),
  inputFileUrl?: string(name='InputFileUrl'),
  unzipCmd?: string(name='UnzipCmd'),
  postCmdLine?: string(name='PostCmdLine'),
  containerId?: string(name='ContainerId'),
  jobQueue?: string(name='JobQueue'),
  node?: int32(name='Node'),
  task?: int32(name='Task'),
  thread?: int32(name='Thread'),
  mem?: string(name='Mem'),
  gpu?: int32(name='Gpu'),
  clockTime?: string(name='ClockTime'),
}

model SubmitJobResponseBody = {
  requestId?: string(name='RequestId'),
  jobId?: string(name='JobId'),
}

model SubmitJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitJobResponseBody(name='body'),
}

async function submitJobWithOptions(request: SubmitJobRequest, runtime: Util.RuntimeOptions): SubmitJobResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('SubmitJob', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function submitJob(request: SubmitJobRequest): SubmitJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitJobWithOptions(request, runtime);
}

model UnbindAccountToClusterUserRequest {
  clusterId?: string(name='ClusterId'),
  userName?: string(name='UserName'),
  accountUid?: string(name='AccountUid'),
}

model UnbindAccountToClusterUserResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnbindAccountToClusterUserResponse = {
  headers: map[string]string(name='headers'),
  body: UnbindAccountToClusterUserResponseBody(name='body'),
}

async function unbindAccountToClusterUserWithOptions(request: UnbindAccountToClusterUserRequest, runtime: Util.RuntimeOptions): UnbindAccountToClusterUserResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('UnbindAccountToClusterUser', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function unbindAccountToClusterUser(request: UnbindAccountToClusterUserRequest): UnbindAccountToClusterUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return unbindAccountToClusterUserWithOptions(request, runtime);
}

model UninstallSoftwareRequest {
  clusterId?: string(name='ClusterId'),
  application?: string(name='Application'),
}

model UninstallSoftwareResponseBody = {
  requestId?: string(name='RequestId'),
}

model UninstallSoftwareResponse = {
  headers: map[string]string(name='headers'),
  body: UninstallSoftwareResponseBody(name='body'),
}

async function uninstallSoftwareWithOptions(request: UninstallSoftwareRequest, runtime: Util.RuntimeOptions): UninstallSoftwareResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('UninstallSoftware', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function uninstallSoftware(request: UninstallSoftwareRequest): UninstallSoftwareResponse {
  var runtime = new Util.RuntimeOptions{};
  return uninstallSoftwareWithOptions(request, runtime);
}

model UpdateClusterVolumesRequest {
  clusterId?: string(name='ClusterId'),
  additionalVolumes?: [ 
    {
      jobQueue?: string(name='JobQueue'),
      volumeId?: string(name='VolumeId'),
      roles?: [ 
        {
          name?: string(name='Name'),
        }
      ](name='Roles'),
      remoteDirectory?: string(name='RemoteDirectory'),
      volumeMountpoint?: string(name='VolumeMountpoint'),
      localDirectory?: string(name='LocalDirectory'),
      volumeType?: string(name='VolumeType'),
      volumeProtocol?: string(name='VolumeProtocol'),
      location?: string(name='Location'),
    }
  ](name='AdditionalVolumes'),
}

model UpdateClusterVolumesResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateClusterVolumesResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateClusterVolumesResponseBody(name='body'),
}

async function updateClusterVolumesWithOptions(request: UpdateClusterVolumesRequest, runtime: Util.RuntimeOptions): UpdateClusterVolumesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('UpdateClusterVolumes', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function updateClusterVolumes(request: UpdateClusterVolumesRequest): UpdateClusterVolumesResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateClusterVolumesWithOptions(request, runtime);
}

model UpdateQueueConfigRequest {
  clusterId?: string(name='ClusterId'),
  queueName?: string(name='QueueName'),
  resourceGroupId?: string(name='ResourceGroupId'),
  computeInstanceType?: string(name='ComputeInstanceType'),
}

model UpdateQueueConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateQueueConfigResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateQueueConfigResponseBody(name='body'),
}

async function updateQueueConfigWithOptions(request: UpdateQueueConfigRequest, runtime: Util.RuntimeOptions): UpdateQueueConfigResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('UpdateQueueConfig', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function updateQueueConfig(request: UpdateQueueConfigRequest): UpdateQueueConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateQueueConfigWithOptions(request, runtime);
}

model UpgradeClientRequest {
  clusterId?: string(name='ClusterId'),
  clientVersion?: string(name='ClientVersion'),
}

model UpgradeClientResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpgradeClientResponse = {
  headers: map[string]string(name='headers'),
  body: UpgradeClientResponseBody(name='body'),
}

async function upgradeClientWithOptions(request: UpgradeClientRequest, runtime: Util.RuntimeOptions): UpgradeClientResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('UpgradeClient', '2018-04-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function upgradeClient(request: UpgradeClientRequest): UpgradeClientResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeClientWithOptions(request, runtime);
}

