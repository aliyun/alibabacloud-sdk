/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('ehpc', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AddContainerAppRequest {
  containerType?: string(name='ContainerType'),
  description?: string(name='Description'),
  imageTag?: string(name='ImageTag'),
  name?: string(name='Name'),
  repository?: string(name='Repository'),
}

model AddContainerAppResponseBody = {
  containerId?: {
    containerId?: [ string ](name='ContainerId')
  }(name='ContainerId'),
  requestId?: string(name='RequestId'),
}

model AddContainerAppResponse = {
  headers: map[string]string(name='headers'),
  body: AddContainerAppResponseBody(name='body'),
}

async function addContainerAppWithOptions(request: AddContainerAppRequest, runtime: Util.RuntimeOptions): AddContainerAppResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddContainerApp',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addContainerApp(request: AddContainerAppRequest): AddContainerAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return addContainerAppWithOptions(request, runtime);
}

model AddExistedNodesRequest {
  clientToken?: string(name='ClientToken'),
  clusterId?: string(name='ClusterId'),
  imageId?: string(name='ImageId'),
  imageOwnerAlias?: string(name='ImageOwnerAlias'),
  instance?: [ 
    {
      id?: string(name='Id'),
    }
  ](name='Instance'),
  jobQueue?: string(name='JobQueue'),
}

model AddExistedNodesResponseBody = {
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model AddExistedNodesResponse = {
  headers: map[string]string(name='headers'),
  body: AddExistedNodesResponseBody(name='body'),
}

async function addExistedNodesWithOptions(request: AddExistedNodesRequest, runtime: Util.RuntimeOptions): AddExistedNodesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddExistedNodes',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addExistedNodes(request: AddExistedNodesRequest): AddExistedNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return addExistedNodesWithOptions(request, runtime);
}

model AddLocalNodesRequest {
  clusterId?: string(name='ClusterId'),
  nodes?: string(name='Nodes'),
}

model AddLocalNodesResponseBody = {
  instanceIds?: {
    instanceId?: [ string ](name='InstanceId')
  }(name='InstanceIds'),
  requestId?: string(name='RequestId'),
}

model AddLocalNodesResponse = {
  headers: map[string]string(name='headers'),
  body: AddLocalNodesResponseBody(name='body'),
}

async function addLocalNodesWithOptions(request: AddLocalNodesRequest, runtime: Util.RuntimeOptions): AddLocalNodesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddLocalNodes',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addLocalNodes(request: AddLocalNodesRequest): AddLocalNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return addLocalNodesWithOptions(request, runtime);
}

model AddNodesRequest {
  allocatePublicAddress?: boolean(name='AllocatePublicAddress'),
  autoRenew?: string(name='AutoRenew'),
  autoRenewPeriod?: int32(name='AutoRenewPeriod'),
  clientToken?: string(name='ClientToken'),
  clusterId?: string(name='ClusterId'),
  computeEnableHt?: boolean(name='ComputeEnableHt'),
  computeSpotPriceLimit?: string(name='ComputeSpotPriceLimit'),
  computeSpotStrategy?: string(name='ComputeSpotStrategy'),
  count?: int32(name='Count'),
  createMode?: string(name='CreateMode'),
  dataDisks?: [ 
    {
      dataDiskCategory?: string(name='DataDiskCategory'),
      dataDiskDeleteWithInstance?: boolean(name='DataDiskDeleteWithInstance'),
      dataDiskEncrypted?: boolean(name='DataDiskEncrypted'),
      dataDiskKMSKeyId?: string(name='DataDiskKMSKeyId'),
      dataDiskPerformanceLevel?: string(name='DataDiskPerformanceLevel'),
      dataDiskSize?: int32(name='DataDiskSize'),
    }
  ](name='DataDisks'),
  ecsChargeType?: string(name='EcsChargeType'),
  hostNamePrefix?: string(name='HostNamePrefix'),
  hostNameSuffix?: string(name='HostNameSuffix'),
  imageId?: string(name='ImageId'),
  imageOwnerAlias?: string(name='ImageOwnerAlias'),
  instanceType?: string(name='InstanceType'),
  internetChargeType?: string(name='InternetChargeType'),
  internetMaxBandWidthIn?: int32(name='InternetMaxBandWidthIn'),
  internetMaxBandWidthOut?: int32(name='InternetMaxBandWidthOut'),
  jobQueue?: string(name='JobQueue'),
  minCount?: int32(name='MinCount'),
  period?: int32(name='Period'),
  periodUnit?: string(name='PeriodUnit'),
  sync?: boolean(name='Sync'),
  systemDiskLevel?: string(name='SystemDiskLevel'),
  systemDiskSize?: int32(name='SystemDiskSize'),
  systemDiskType?: string(name='SystemDiskType'),
  vSwitchId?: string(name='VSwitchId'),
  zoneId?: string(name='ZoneId'),
}

model AddNodesResponseBody = {
  instanceIds?: {
    instanceId?: [ string ](name='InstanceId')
  }(name='InstanceIds'),
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model AddNodesResponse = {
  headers: map[string]string(name='headers'),
  body: AddNodesResponseBody(name='body'),
}

async function addNodesWithOptions(request: AddNodesRequest, runtime: Util.RuntimeOptions): AddNodesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddNodes',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addNodes(request: AddNodesRequest): AddNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return addNodesWithOptions(request, runtime);
}

model AddQueueRequest {
  clusterId?: string(name='ClusterId'),
  queueName?: string(name='QueueName'),
}

model AddQueueResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddQueueResponse = {
  headers: map[string]string(name='headers'),
  body: AddQueueResponseBody(name='body'),
}

async function addQueueWithOptions(request: AddQueueRequest, runtime: Util.RuntimeOptions): AddQueueResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddQueue',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addQueue(request: AddQueueRequest): AddQueueResponse {
  var runtime = new Util.RuntimeOptions{};
  return addQueueWithOptions(request, runtime);
}

model AddSecurityGroupRequest {
  clientToken?: string(name='ClientToken'),
  clusterId?: string(name='ClusterId'),
  securityGroupId?: string(name='SecurityGroupId'),
}

model AddSecurityGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddSecurityGroupResponse = {
  headers: map[string]string(name='headers'),
  body: AddSecurityGroupResponseBody(name='body'),
}

async function addSecurityGroupWithOptions(request: AddSecurityGroupRequest, runtime: Util.RuntimeOptions): AddSecurityGroupResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddSecurityGroup',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addSecurityGroup(request: AddSecurityGroupRequest): AddSecurityGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return addSecurityGroupWithOptions(request, runtime);
}

model AddUsersRequest {
  clusterId?: string(name='ClusterId'),
  user?: [ 
    {
      group?: string(name='Group'),
      name?: string(name='Name'),
      password?: string(name='Password'),
    }
  ](name='User'),
}

model AddUsersResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddUsersResponse = {
  headers: map[string]string(name='headers'),
  body: AddUsersResponseBody(name='body'),
}

async function addUsersWithOptions(request: AddUsersRequest, runtime: Util.RuntimeOptions): AddUsersResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddUsers',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addUsers(request: AddUsersRequest): AddUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return addUsersWithOptions(request, runtime);
}

model ApplyNodesRequest {
  allocatePublicAddress?: boolean(name='AllocatePublicAddress'),
  clusterId?: string(name='ClusterId'),
  computeSpotPriceLimit?: float(name='ComputeSpotPriceLimit'),
  computeSpotStrategy?: string(name='ComputeSpotStrategy'),
  cores?: int32(name='Cores'),
  hostNamePrefix?: string(name='HostNamePrefix'),
  hostNameSuffix?: string(name='HostNameSuffix'),
  imageId?: string(name='ImageId'),
  instanceFamilyLevel?: string(name='InstanceFamilyLevel'),
  instanceTypeModel?: [ 
    {
      instanceType?: string(name='InstanceType'),
      maxPrice?: float(name='MaxPrice'),
      targetImageId?: string(name='TargetImageId'),
    }
  ](name='InstanceTypeModel'),
  internetChargeType?: string(name='InternetChargeType'),
  internetMaxBandWidthIn?: int32(name='InternetMaxBandWidthIn'),
  internetMaxBandWidthOut?: int32(name='InternetMaxBandWidthOut'),
  interval?: int32(name='Interval'),
  jobQueue?: string(name='JobQueue'),
  memory?: int32(name='Memory'),
  priorityStrategy?: string(name='PriorityStrategy'),
  resourceAmountType?: string(name='ResourceAmountType'),
  round?: int32(name='Round'),
  strictResourceProvision?: boolean(name='StrictResourceProvision'),
  strictSatisfiedTargetCapacity?: boolean(name='StrictSatisfiedTargetCapacity'),
  systemDiskLevel?: string(name='SystemDiskLevel'),
  systemDiskSize?: int32(name='SystemDiskSize'),
  systemDiskType?: string(name='SystemDiskType'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  targetCapacity?: int32(name='TargetCapacity'),
  zoneInfos?: [ 
    {
      vSwitchId?: string(name='VSwitchId'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='ZoneInfos'),
}

model ApplyNodesResponseBody = {
  detail?: string(name='Detail'),
  instanceIds?: {
    instanceId?: [ string ](name='InstanceId')
  }(name='InstanceIds'),
  requestId?: string(name='RequestId'),
  satisfiedAmount?: int32(name='SatisfiedAmount'),
  taskId?: string(name='TaskId'),
}

model ApplyNodesResponse = {
  headers: map[string]string(name='headers'),
  body: ApplyNodesResponseBody(name='body'),
}

async function applyNodesWithOptions(request: ApplyNodesRequest, runtime: Util.RuntimeOptions): ApplyNodesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ApplyNodes',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function applyNodes(request: ApplyNodesRequest): ApplyNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return applyNodesWithOptions(request, runtime);
}

model CreateClusterRequest {
  ecsOrder?: {
    compute: {
        count?: int32(name='Count'),
        instanceType?: string(name='InstanceType'),
    }(name='Compute'),
    login: {
        count?: int32(name='Count'),
        instanceType?: string(name='InstanceType'),
    }(name='Login'),
    manager: {
        count?: int32(name='Count'),
        instanceType?: string(name='InstanceType'),
    }(name='Manager'),
  }(name='EcsOrder'),
  accountType?: string(name='AccountType'),
  additionalVolumes?: [ 
    {
      jobQueue?: string(name='JobQueue'),
      localDirectory?: string(name='LocalDirectory'),
      location?: string(name='Location'),
      remoteDirectory?: string(name='RemoteDirectory'),
      roles?: [ 
        {
          name?: string(name='Name'),
        }
      ](name='Roles'),
      volumeId?: string(name='VolumeId'),
      volumeMountpoint?: string(name='VolumeMountpoint'),
      volumeProtocol?: string(name='VolumeProtocol'),
      volumeType?: string(name='VolumeType'),
    }
  ](name='AdditionalVolumes'),
  application?: [ 
    {
      tag?: string(name='Tag'),
    }
  ](name='Application'),
  autoRenew?: string(name='AutoRenew'),
  autoRenewPeriod?: int32(name='AutoRenewPeriod'),
  clientToken?: string(name='ClientToken'),
  clientVersion?: string(name='ClientVersion'),
  clusterVersion?: string(name='ClusterVersion'),
  computeEnableHt?: boolean(name='ComputeEnableHt'),
  computeSpotPriceLimit?: string(name='ComputeSpotPriceLimit'),
  computeSpotStrategy?: string(name='ComputeSpotStrategy'),
  deployMode?: string(name='DeployMode'),
  description?: string(name='Description'),
  ecsChargeType?: string(name='EcsChargeType'),
  ehpcVersion?: string(name='EhpcVersion'),
  haEnable?: boolean(name='HaEnable'),
  imageId?: string(name='ImageId'),
  imageOwnerAlias?: string(name='ImageOwnerAlias'),
  inputFileUrl?: string(name='InputFileUrl'),
  isComputeEss?: boolean(name='IsComputeEss'),
  jobQueue?: string(name='JobQueue'),
  keyPairName?: string(name='KeyPairName'),
  name?: string(name='Name'),
  osTag?: string(name='OsTag'),
  password?: string(name='Password'),
  period?: int32(name='Period'),
  periodUnit?: string(name='PeriodUnit'),
  plugin?: string(name='Plugin'),
  postInstallScript?: [ 
    {
      args?: string(name='Args'),
      url?: string(name='Url'),
    }
  ](name='PostInstallScript'),
  ramNodeTypes?: [ string ](name='RamNodeTypes'),
  ramRoleName?: string(name='RamRoleName'),
  remoteDirectory?: string(name='RemoteDirectory'),
  remoteVisEnable?: string(name='RemoteVisEnable'),
  resourceGroupId?: string(name='ResourceGroupId'),
  sccClusterId?: string(name='SccClusterId'),
  schedulerType?: string(name='SchedulerType'),
  securityGroupId?: string(name='SecurityGroupId'),
  securityGroupName?: string(name='SecurityGroupName'),
  systemDiskLevel?: string(name='SystemDiskLevel'),
  systemDiskSize?: int32(name='SystemDiskSize'),
  systemDiskType?: string(name='SystemDiskType'),
  vSwitchId?: string(name='VSwitchId'),
  volumeId?: string(name='VolumeId'),
  volumeMountpoint?: string(name='VolumeMountpoint'),
  volumeProtocol?: string(name='VolumeProtocol'),
  volumeType?: string(name='VolumeType'),
  vpcId?: string(name='VpcId'),
  withoutAgent?: boolean(name='WithoutAgent'),
  withoutElasticIp?: boolean(name='WithoutElasticIp'),
  zoneId?: string(name='ZoneId'),
}

model CreateClusterResponseBody = {
  clusterId?: string(name='ClusterId'),
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model CreateClusterResponse = {
  headers: map[string]string(name='headers'),
  body: CreateClusterResponseBody(name='body'),
}

async function createClusterWithOptions(request: CreateClusterRequest, runtime: Util.RuntimeOptions): CreateClusterResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateCluster',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createCluster(request: CreateClusterRequest): CreateClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return createClusterWithOptions(request, runtime);
}

model CreateGWSClusterRequest {
  clusterType?: string(name='ClusterType'),
  name?: string(name='Name'),
  vSwitchId?: string(name='VSwitchId'),
  vpcId?: string(name='VpcId'),
}

model CreateGWSClusterResponseBody = {
  clusterId?: string(name='ClusterId'),
  requestId?: string(name='RequestId'),
}

model CreateGWSClusterResponse = {
  headers: map[string]string(name='headers'),
  body: CreateGWSClusterResponseBody(name='body'),
}

async function createGWSClusterWithOptions(request: CreateGWSClusterRequest, runtime: Util.RuntimeOptions): CreateGWSClusterResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateGWSCluster',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createGWSCluster(request: CreateGWSClusterRequest): CreateGWSClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return createGWSClusterWithOptions(request, runtime);
}

model CreateGWSImageRequest {
  instanceId?: string(name='InstanceId'),
  name?: string(name='Name'),
}

model CreateGWSImageResponseBody = {
  imageId?: string(name='ImageId'),
  requestId?: string(name='RequestId'),
}

model CreateGWSImageResponse = {
  headers: map[string]string(name='headers'),
  body: CreateGWSImageResponseBody(name='body'),
}

async function createGWSImageWithOptions(request: CreateGWSImageRequest, runtime: Util.RuntimeOptions): CreateGWSImageResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateGWSImage',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createGWSImage(request: CreateGWSImageRequest): CreateGWSImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return createGWSImageWithOptions(request, runtime);
}

model CreateGWSInstanceRequest {
  allocatePublicAddress?: boolean(name='AllocatePublicAddress'),
  appList?: string(name='AppList'),
  autoRenew?: boolean(name='AutoRenew'),
  clusterId?: string(name='ClusterId'),
  imageId?: string(name='ImageId'),
  instanceChargeType?: string(name='InstanceChargeType'),
  instanceType?: string(name='InstanceType'),
  internetChargeType?: string(name='InternetChargeType'),
  internetMaxBandwidthIn?: int32(name='InternetMaxBandwidthIn'),
  internetMaxBandwidthOut?: int32(name='InternetMaxBandwidthOut'),
  name?: string(name='Name'),
  period?: string(name='Period'),
  periodUnit?: string(name='PeriodUnit'),
  systemDiskCategory?: string(name='SystemDiskCategory'),
  systemDiskSize?: int32(name='SystemDiskSize'),
  vSwitchId?: string(name='VSwitchId'),
  workMode?: string(name='WorkMode'),
}

model CreateGWSInstanceResponseBody = {
  instanceId?: string(name='InstanceId'),
  requestId?: string(name='RequestId'),
}

model CreateGWSInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateGWSInstanceResponseBody(name='body'),
}

async function createGWSInstanceWithOptions(request: CreateGWSInstanceRequest, runtime: Util.RuntimeOptions): CreateGWSInstanceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateGWSInstance',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createGWSInstance(request: CreateGWSInstanceRequest): CreateGWSInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createGWSInstanceWithOptions(request, runtime);
}

model CreateHybridClusterRequest {
  ecsOrder?: {
    compute: {
        instanceType?: string(name='InstanceType'),
    }(name='Compute'),
  }(name='EcsOrder'),
  application?: [ 
    {
      tag?: string(name='Tag'),
    }
  ](name='Application'),
  clientToken?: string(name='ClientToken'),
  clientVersion?: string(name='ClientVersion'),
  computeSpotPriceLimit?: float(name='ComputeSpotPriceLimit'),
  computeSpotStrategy?: string(name='ComputeSpotStrategy'),
  description?: string(name='Description'),
  domain?: string(name='Domain'),
  ehpcVersion?: string(name='EhpcVersion'),
  imageId?: string(name='ImageId'),
  imageOwnerAlias?: string(name='ImageOwnerAlias'),
  jobQueue?: string(name='JobQueue'),
  keyPairName?: string(name='KeyPairName'),
  location?: string(name='Location'),
  multiOs?: boolean(name='MultiOs'),
  name?: string(name='Name'),
  nodes?: [ 
    {
      accountType?: string(name='AccountType'),
      hostName?: string(name='HostName'),
      ipAddress?: string(name='IpAddress'),
      role?: string(name='Role'),
      schedulerType?: string(name='SchedulerType'),
    }
  ](name='Nodes'),
  onPremiseVolumeLocalPath?: string(name='OnPremiseVolumeLocalPath'),
  onPremiseVolumeMountPoint?: string(name='OnPremiseVolumeMountPoint'),
  onPremiseVolumeProtocol?: string(name='OnPremiseVolumeProtocol'),
  onPremiseVolumeRemotePath?: string(name='OnPremiseVolumeRemotePath'),
  osTag?: string(name='OsTag'),
  password?: string(name='Password'),
  postInstallScript?: [ 
    {
      args?: string(name='Args'),
      url?: string(name='Url'),
    }
  ](name='PostInstallScript'),
  remoteDirectory?: string(name='RemoteDirectory'),
  resourceGroupId?: string(name='ResourceGroupId'),
  schedulerPreInstall?: boolean(name='SchedulerPreInstall'),
  securityGroupId?: string(name='SecurityGroupId'),
  securityGroupName?: string(name='SecurityGroupName'),
  vSwitchId?: string(name='VSwitchId'),
  volumeId?: string(name='VolumeId'),
  volumeMountpoint?: string(name='VolumeMountpoint'),
  volumeProtocol?: string(name='VolumeProtocol'),
  volumeType?: string(name='VolumeType'),
  vpcId?: string(name='VpcId'),
  zoneId?: string(name='ZoneId'),
}

model CreateHybridClusterResponseBody = {
  clusterId?: string(name='ClusterId'),
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model CreateHybridClusterResponse = {
  headers: map[string]string(name='headers'),
  body: CreateHybridClusterResponseBody(name='body'),
}

async function createHybridClusterWithOptions(request: CreateHybridClusterRequest, runtime: Util.RuntimeOptions): CreateHybridClusterResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateHybridCluster',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createHybridCluster(request: CreateHybridClusterRequest): CreateHybridClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return createHybridClusterWithOptions(request, runtime);
}

model CreateJobFileRequest {
  clusterId?: string(name='ClusterId'),
  content?: string(name='Content'),
  runasUser?: string(name='RunasUser'),
  runasUserPassword?: string(name='RunasUserPassword'),
  targetFile?: string(name='TargetFile'),
}

model CreateJobFileResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateJobFileResponse = {
  headers: map[string]string(name='headers'),
  body: CreateJobFileResponseBody(name='body'),
}

async function createJobFileWithOptions(request: CreateJobFileRequest, runtime: Util.RuntimeOptions): CreateJobFileResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateJobFile',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createJobFile(request: CreateJobFileRequest): CreateJobFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return createJobFileWithOptions(request, runtime);
}

model CreateJobTemplateRequest {
  arrayRequest?: string(name='ArrayRequest'),
  clockTime?: string(name='ClockTime'),
  commandLine?: string(name='CommandLine'),
  gpu?: int32(name='Gpu'),
  inputFileUrl?: string(name='InputFileUrl'),
  mem?: string(name='Mem'),
  name?: string(name='Name'),
  node?: int32(name='Node'),
  packagePath?: string(name='PackagePath'),
  priority?: int32(name='Priority'),
  queue?: string(name='Queue'),
  reRunable?: boolean(name='ReRunable'),
  runasUser?: string(name='RunasUser'),
  stderrRedirectPath?: string(name='StderrRedirectPath'),
  stdoutRedirectPath?: string(name='StdoutRedirectPath'),
  task?: int32(name='Task'),
  thread?: int32(name='Thread'),
  unzipCmd?: string(name='UnzipCmd'),
  variables?: string(name='Variables'),
  withUnzipCmd?: boolean(name='WithUnzipCmd'),
}

model CreateJobTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  templateId?: string(name='TemplateId'),
}

model CreateJobTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: CreateJobTemplateResponseBody(name='body'),
}

async function createJobTemplateWithOptions(request: CreateJobTemplateRequest, runtime: Util.RuntimeOptions): CreateJobTemplateResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateJobTemplate',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createJobTemplate(request: CreateJobTemplateRequest): CreateJobTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return createJobTemplateWithOptions(request, runtime);
}

model DeleteClusterRequest {
  clusterId?: string(name='ClusterId'),
  releaseInstance?: string(name='ReleaseInstance'),
}

model DeleteClusterResponseBody = {
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model DeleteClusterResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteClusterResponseBody(name='body'),
}

async function deleteClusterWithOptions(request: DeleteClusterRequest, runtime: Util.RuntimeOptions): DeleteClusterResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCluster',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteCluster(request: DeleteClusterRequest): DeleteClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteClusterWithOptions(request, runtime);
}

model DeleteContainerAppsRequest {
  containerApp?: [ 
    {
      id?: string(name='Id'),
    }
  ](name='ContainerApp'),
}

model DeleteContainerAppsResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteContainerAppsResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteContainerAppsResponseBody(name='body'),
}

async function deleteContainerAppsWithOptions(request: DeleteContainerAppsRequest, runtime: Util.RuntimeOptions): DeleteContainerAppsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteContainerApps',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteContainerApps(request: DeleteContainerAppsRequest): DeleteContainerAppsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteContainerAppsWithOptions(request, runtime);
}

model DeleteGWSClusterRequest {
  clusterId?: string(name='ClusterId'),
}

model DeleteGWSClusterResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteGWSClusterResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteGWSClusterResponseBody(name='body'),
}

async function deleteGWSClusterWithOptions(request: DeleteGWSClusterRequest, runtime: Util.RuntimeOptions): DeleteGWSClusterResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGWSCluster',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteGWSCluster(request: DeleteGWSClusterRequest): DeleteGWSClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGWSClusterWithOptions(request, runtime);
}

model DeleteGWSInstanceRequest {
  instanceId?: string(name='InstanceId'),
}

model DeleteGWSInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteGWSInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteGWSInstanceResponseBody(name='body'),
}

async function deleteGWSInstanceWithOptions(request: DeleteGWSInstanceRequest, runtime: Util.RuntimeOptions): DeleteGWSInstanceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGWSInstance',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteGWSInstance(request: DeleteGWSInstanceRequest): DeleteGWSInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGWSInstanceWithOptions(request, runtime);
}

model DeleteImageRequest {
  clusterId?: string(name='ClusterId'),
  containerType?: string(name='ContainerType'),
  imageTag?: string(name='ImageTag'),
  repository?: string(name='Repository'),
}

model DeleteImageResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteImageResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteImageResponseBody(name='body'),
}

async function deleteImageWithOptions(request: DeleteImageRequest, runtime: Util.RuntimeOptions): DeleteImageResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteImage',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteImage(request: DeleteImageRequest): DeleteImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteImageWithOptions(request, runtime);
}

model DeleteJobTemplatesRequest {
  templates?: string(name='Templates'),
}

model DeleteJobTemplatesResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteJobTemplatesResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteJobTemplatesResponseBody(name='body'),
}

async function deleteJobTemplatesWithOptions(request: DeleteJobTemplatesRequest, runtime: Util.RuntimeOptions): DeleteJobTemplatesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteJobTemplates',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteJobTemplates(request: DeleteJobTemplatesRequest): DeleteJobTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteJobTemplatesWithOptions(request, runtime);
}

model DeleteJobsRequest {
  clusterId?: string(name='ClusterId'),
  jobs?: string(name='Jobs'),
}

model DeleteJobsResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteJobsResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteJobsResponseBody(name='body'),
}

async function deleteJobsWithOptions(request: DeleteJobsRequest, runtime: Util.RuntimeOptions): DeleteJobsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteJobs',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteJobs(request: DeleteJobsRequest): DeleteJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteJobsWithOptions(request, runtime);
}

model DeleteNodesRequest {
  clusterId?: string(name='ClusterId'),
  instance?: [ 
    {
      id?: string(name='Id'),
    }
  ](name='Instance'),
  releaseInstance?: boolean(name='ReleaseInstance'),
  sync?: boolean(name='Sync'),
}

model DeleteNodesResponseBody = {
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model DeleteNodesResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteNodesResponseBody(name='body'),
}

async function deleteNodesWithOptions(request: DeleteNodesRequest, runtime: Util.RuntimeOptions): DeleteNodesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteNodes',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteNodes(request: DeleteNodesRequest): DeleteNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteNodesWithOptions(request, runtime);
}

model DeleteQueueRequest {
  clusterId?: string(name='ClusterId'),
  queueName?: string(name='QueueName'),
}

model DeleteQueueResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteQueueResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteQueueResponseBody(name='body'),
}

async function deleteQueueWithOptions(request: DeleteQueueRequest, runtime: Util.RuntimeOptions): DeleteQueueResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteQueue',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteQueue(request: DeleteQueueRequest): DeleteQueueResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteQueueWithOptions(request, runtime);
}

model DeleteSecurityGroupRequest {
  clusterId?: string(name='ClusterId'),
  securityGroupId?: string(name='SecurityGroupId'),
}

model DeleteSecurityGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteSecurityGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSecurityGroupResponseBody(name='body'),
}

async function deleteSecurityGroupWithOptions(request: DeleteSecurityGroupRequest, runtime: Util.RuntimeOptions): DeleteSecurityGroupResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSecurityGroup',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSecurityGroup(request: DeleteSecurityGroupRequest): DeleteSecurityGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSecurityGroupWithOptions(request, runtime);
}

model DeleteUsersRequest {
  clusterId?: string(name='ClusterId'),
  user?: [ 
    {
      name?: string(name='Name'),
    }
  ](name='User'),
}

model DeleteUsersResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteUsersResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteUsersResponseBody(name='body'),
}

async function deleteUsersWithOptions(request: DeleteUsersRequest, runtime: Util.RuntimeOptions): DeleteUsersResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteUsers',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteUsers(request: DeleteUsersRequest): DeleteUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteUsersWithOptions(request, runtime);
}

model DescribeAutoScaleConfigRequest {
  clusterId?: string(name='ClusterId'),
}

model DescribeAutoScaleConfigResponseBody = {
  clusterId?: string(name='ClusterId'),
  clusterType?: string(name='ClusterType'),
  enableAutoGrow?: boolean(name='EnableAutoGrow'),
  enableAutoShrink?: boolean(name='EnableAutoShrink'),
  excludeNodes?: string(name='ExcludeNodes'),
  extraNodesGrowRatio?: int32(name='ExtraNodesGrowRatio'),
  growIntervalInMinutes?: int32(name='GrowIntervalInMinutes'),
  growRatio?: int32(name='GrowRatio'),
  growTimeoutInMinutes?: int32(name='GrowTimeoutInMinutes'),
  maxNodesInCluster?: int32(name='MaxNodesInCluster'),
  requestId?: string(name='RequestId'),
  shrinkIdleTimes?: int32(name='ShrinkIdleTimes'),
  shrinkIntervalInMinutes?: int32(name='ShrinkIntervalInMinutes'),
  spotPriceLimit?: string(name='SpotPriceLimit'),
  spotStrategy?: string(name='SpotStrategy'),
  uid?: string(name='Uid'),
}

model DescribeAutoScaleConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAutoScaleConfigResponseBody(name='body'),
}

async function describeAutoScaleConfigWithOptions(request: DescribeAutoScaleConfigRequest, runtime: Util.RuntimeOptions): DescribeAutoScaleConfigResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAutoScaleConfig',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAutoScaleConfig(request: DescribeAutoScaleConfigRequest): DescribeAutoScaleConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAutoScaleConfigWithOptions(request, runtime);
}

model DescribeClusterRequest {
  clusterId?: string(name='ClusterId'),
}

model DescribeClusterResponseBody = {
  clusterInfo?: {
    accountType?: string(name='AccountType'),
    applications?: {
      applicationInfo?: [ 
      {
        name?: string(name='Name'),
        tag?: string(name='Tag'),
        version?: string(name='Version'),
      }
    ](name='ApplicationInfo')
    }(name='Applications'),
    baseOsTag?: string(name='BaseOsTag'),
    clientVersion?: string(name='ClientVersion'),
    createTime?: string(name='CreateTime'),
    deployMode?: string(name='DeployMode'),
    description?: string(name='Description'),
    ecsChargeType?: string(name='EcsChargeType'),
    ecsInfo?: {
      compute?: {
        count?: int32(name='Count'),
        instanceType?: string(name='InstanceType'),
      }(name='Compute'),
      login?: {
        count?: int32(name='Count'),
        instanceType?: string(name='InstanceType'),
      }(name='Login'),
      manager?: {
        count?: int32(name='Count'),
        instanceType?: string(name='InstanceType'),
      }(name='Manager'),
      proxyMgr?: {
        count?: int32(name='Count'),
        instanceType?: string(name='InstanceType'),
      }(name='ProxyMgr'),
    }(name='EcsInfo'),
    haEnable?: boolean(name='HaEnable'),
    id?: string(name='Id'),
    imageId?: string(name='ImageId'),
    imageName?: string(name='ImageName'),
    imageOwnerAlias?: string(name='ImageOwnerAlias'),
    keyPairName?: string(name='KeyPairName'),
    location?: string(name='Location'),
    name?: string(name='Name'),
    onPremiseInfo?: {
      onPremiseInfo?: [ 
      {
        hostName?: string(name='HostName'),
        IP?: string(name='IP'),
        type?: string(name='Type'),
      }
    ](name='OnPremiseInfo')
    }(name='OnPremiseInfo'),
    osTag?: string(name='OsTag'),
    postInstallScripts?: {
      postInstallScriptInfo?: [ 
      {
        args?: string(name='Args'),
        url?: string(name='Url'),
      }
    ](name='PostInstallScriptInfo')
    }(name='PostInstallScripts'),
    regionId?: string(name='RegionId'),
    remoteDirectory?: string(name='RemoteDirectory'),
    sccClusterId?: string(name='SccClusterId'),
    schedulerType?: string(name='SchedulerType'),
    securityGroupId?: string(name='SecurityGroupId'),
    status?: string(name='Status'),
    vSwitchId?: string(name='VSwitchId'),
    volumeId?: string(name='VolumeId'),
    volumeMountpoint?: string(name='VolumeMountpoint'),
    volumeProtocol?: string(name='VolumeProtocol'),
    volumeType?: string(name='VolumeType'),
    vpcId?: string(name='VpcId'),
  }(name='ClusterInfo'),
  requestId?: string(name='RequestId'),
}

model DescribeClusterResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeClusterResponseBody(name='body'),
}

async function describeClusterWithOptions(request: DescribeClusterRequest, runtime: Util.RuntimeOptions): DescribeClusterResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCluster',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCluster(request: DescribeClusterRequest): DescribeClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterWithOptions(request, runtime);
}

model DescribeContainerAppRequest {
  containerId?: string(name='ContainerId'),
}

model DescribeContainerAppResponseBody = {
  containerAppInfo?: {
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    imageTag?: string(name='ImageTag'),
    name?: string(name='Name'),
    repository?: string(name='Repository'),
    type?: string(name='Type'),
  }(name='ContainerAppInfo'),
  requestId?: string(name='RequestId'),
}

model DescribeContainerAppResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeContainerAppResponseBody(name='body'),
}

async function describeContainerAppWithOptions(request: DescribeContainerAppRequest, runtime: Util.RuntimeOptions): DescribeContainerAppResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeContainerApp',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeContainerApp(request: DescribeContainerAppRequest): DescribeContainerAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeContainerAppWithOptions(request, runtime);
}

model DescribeGWSClusterPolicyRequest {
  asyncMode?: boolean(name='AsyncMode'),
  clusterId?: string(name='ClusterId'),
  taskId?: string(name='TaskId'),
}

model DescribeGWSClusterPolicyResponseBody = {
  clipboard?: string(name='Clipboard'),
  localDrive?: string(name='LocalDrive'),
  requestId?: string(name='RequestId'),
  usbRedirect?: string(name='UsbRedirect'),
  watermark?: string(name='Watermark'),
}

model DescribeGWSClusterPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeGWSClusterPolicyResponseBody(name='body'),
}

async function describeGWSClusterPolicyWithOptions(request: DescribeGWSClusterPolicyRequest, runtime: Util.RuntimeOptions): DescribeGWSClusterPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.asyncMode)) {
    query['AsyncMode'] = request.asyncMode;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGWSClusterPolicy',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGWSClusterPolicy(request: DescribeGWSClusterPolicyRequest): DescribeGWSClusterPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGWSClusterPolicyWithOptions(request, runtime);
}

model DescribeGWSClustersRequest {
  clusterId?: string(name='ClusterId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model DescribeGWSClustersResponseBody = {
  callerType?: string(name='CallerType'),
  clusters?: {
    clusterInfo?: [ 
    {
      clusterId?: string(name='ClusterId'),
      createTime?: string(name='CreateTime'),
      instanceCount?: int32(name='InstanceCount'),
      status?: string(name='Status'),
      vpcId?: string(name='VpcId'),
    }
  ](name='ClusterInfo')
  }(name='Clusters'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeGWSClustersResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeGWSClustersResponseBody(name='body'),
}

async function describeGWSClustersWithOptions(request: DescribeGWSClustersRequest, runtime: Util.RuntimeOptions): DescribeGWSClustersResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGWSClusters',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGWSClusters(request: DescribeGWSClustersRequest): DescribeGWSClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGWSClustersWithOptions(request, runtime);
}

model DescribeGWSImagesRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model DescribeGWSImagesResponseBody = {
  images?: {
    imageInfo?: [ 
    {
      createTime?: string(name='CreateTime'),
      imageId?: string(name='ImageId'),
      imageType?: string(name='ImageType'),
      name?: string(name='Name'),
      progress?: string(name='Progress'),
      size?: int32(name='Size'),
      status?: string(name='Status'),
    }
  ](name='ImageInfo')
  }(name='Images'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeGWSImagesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeGWSImagesResponseBody(name='body'),
}

async function describeGWSImagesWithOptions(request: DescribeGWSImagesRequest, runtime: Util.RuntimeOptions): DescribeGWSImagesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGWSImages',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGWSImages(request: DescribeGWSImagesRequest): DescribeGWSImagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGWSImagesWithOptions(request, runtime);
}

model DescribeGWSInstancesRequest {
  clusterId?: string(name='ClusterId'),
  instanceId?: string(name='InstanceId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  userName?: string(name='UserName'),
  userUid?: long(name='UserUid'),
}

model DescribeGWSInstancesResponseBody = {
  instances?: {
    instanceInfo?: [ 
    {
      appList?: {
        appInfo?: [ 
        {
          appArgs?: string(name='AppArgs'),
          appName?: string(name='AppName'),
          appPath?: string(name='AppPath'),
        }
      ](name='AppInfo')
      }(name='AppList'),
      clusterId?: string(name='ClusterId'),
      createTime?: string(name='CreateTime'),
      expireTime?: string(name='ExpireTime'),
      instanceId?: string(name='InstanceId'),
      instanceType?: string(name='InstanceType'),
      name?: string(name='Name'),
      status?: string(name='Status'),
      userName?: string(name='UserName'),
      workMode?: string(name='WorkMode'),
    }
  ](name='InstanceInfo')
  }(name='Instances'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeGWSInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeGWSInstancesResponseBody(name='body'),
}

async function describeGWSInstancesWithOptions(request: DescribeGWSInstancesRequest, runtime: Util.RuntimeOptions): DescribeGWSInstancesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGWSInstances',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGWSInstances(request: DescribeGWSInstancesRequest): DescribeGWSInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGWSInstancesWithOptions(request, runtime);
}

model DescribeImageRequest {
  clusterId?: string(name='ClusterId'),
  containerType?: string(name='ContainerType'),
  imageTag?: string(name='ImageTag'),
  repository?: string(name='Repository'),
}

model DescribeImageResponseBody = {
  imageInfo?: {
    imageId?: string(name='ImageId'),
    repository?: string(name='Repository'),
    status?: string(name='Status'),
    system?: string(name='System'),
    tag?: string(name='Tag'),
    type?: string(name='Type'),
    updateDateTime?: string(name='UpdateDateTime'),
  }(name='ImageInfo'),
  requestId?: string(name='RequestId'),
}

model DescribeImageResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeImageResponseBody(name='body'),
}

async function describeImageWithOptions(request: DescribeImageRequest, runtime: Util.RuntimeOptions): DescribeImageResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImage',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeImage(request: DescribeImageRequest): DescribeImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageWithOptions(request, runtime);
}

model DescribeImageGatewayConfigRequest {
  clusterId?: string(name='ClusterId'),
}

model DescribeImageGatewayConfigResponseBody = {
  imagegw?: {
    defaultImageLocation?: string(name='DefaultImageLocation'),
    imageExpirationTimeout?: string(name='ImageExpirationTimeout'),
    locations?: {
      locationInfo?: [ 
      {
        authentication?: string(name='Authentication'),
        location?: string(name='Location'),
        remoteType?: string(name='RemoteType'),
        URL?: string(name='URL'),
      }
    ](name='LocationInfo')
    }(name='Locations'),
    mongoDBURI?: string(name='MongoDBURI'),
    pullUpdateTimeout?: long(name='PullUpdateTimeout'),
    updateDateTime?: string(name='UpdateDateTime'),
  }(name='Imagegw'),
  requestId?: string(name='RequestId'),
}

model DescribeImageGatewayConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeImageGatewayConfigResponseBody(name='body'),
}

async function describeImageGatewayConfigWithOptions(request: DescribeImageGatewayConfigRequest, runtime: Util.RuntimeOptions): DescribeImageGatewayConfigResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageGatewayConfig',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeImageGatewayConfig(request: DescribeImageGatewayConfigRequest): DescribeImageGatewayConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageGatewayConfigWithOptions(request, runtime);
}

model DescribeImagePriceRequest {
  amount?: int32(name='Amount'),
  imageId?: string(name='ImageId'),
  orderType?: string(name='OrderType'),
  period?: int32(name='Period'),
  priceUnit?: string(name='PriceUnit'),
  skuCode?: string(name='SkuCode'),
}

model DescribeImagePriceResponseBody = {
  amount?: int32(name='Amount'),
  discountPrice?: float(name='DiscountPrice'),
  imageId?: string(name='ImageId'),
  originalPrice?: float(name='OriginalPrice'),
  requestId?: string(name='RequestId'),
  tradePrice?: float(name='TradePrice'),
}

model DescribeImagePriceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeImagePriceResponseBody(name='body'),
}

async function describeImagePriceWithOptions(request: DescribeImagePriceRequest, runtime: Util.RuntimeOptions): DescribeImagePriceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImagePrice',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeImagePrice(request: DescribeImagePriceRequest): DescribeImagePriceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImagePriceWithOptions(request, runtime);
}

model DescribeJobRequest {
  clusterId?: string(name='ClusterId'),
  jobId?: string(name='JobId'),
}

model DescribeJobResponseBody = {
  message?: {
    jobInfo?: string(name='JobInfo'),
  }(name='Message'),
  requestId?: string(name='RequestId'),
}

model DescribeJobResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeJobResponseBody(name='body'),
}

async function describeJobWithOptions(request: DescribeJobRequest, runtime: Util.RuntimeOptions): DescribeJobResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeJob',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeJob(request: DescribeJobRequest): DescribeJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeJobWithOptions(request, runtime);
}

model DescribeNFSClientStatusRequest {
  instanceId?: string(name='InstanceId'),
}

model DescribeNFSClientStatusResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    exitCode?: int32(name='ExitCode'),
    invokeRecordStatus?: string(name='InvokeRecordStatus'),
    output?: string(name='Output'),
  }(name='Result'),
  status?: string(name='Status'),
}

model DescribeNFSClientStatusResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeNFSClientStatusResponseBody(name='body'),
}

async function describeNFSClientStatusWithOptions(request: DescribeNFSClientStatusRequest, runtime: Util.RuntimeOptions): DescribeNFSClientStatusResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeNFSClientStatus',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeNFSClientStatus(request: DescribeNFSClientStatusRequest): DescribeNFSClientStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeNFSClientStatusWithOptions(request, runtime);
}

model DescribePriceRequest {
  chargeType?: string(name='ChargeType'),
  commodities?: [ 
    {
      amount?: int32(name='Amount'),
      dataDisks?: [ 
        {
          category?: string(name='category'),
          deleteWithInstance?: boolean(name='deleteWithInstance'),
          encrypted?: boolean(name='encrypted'),
          performanceLevel?: string(name='performanceLevel'),
          size?: int32(name='size'),
        }
      ](name='DataDisks'),
      instanceType?: string(name='InstanceType'),
      internetChargeType?: string(name='InternetChargeType'),
      internetMaxBandWidthOut?: int32(name='InternetMaxBandWidthOut'),
      networkType?: string(name='NetworkType'),
      nodeType?: string(name='NodeType'),
      period?: int32(name='Period'),
      systemDiskCategory?: string(name='SystemDiskCategory'),
      systemDiskPerformanceLevel?: string(name='SystemDiskPerformanceLevel'),
      systemDiskSize?: int32(name='SystemDiskSize'),
    }
  ](name='Commodities'),
  orderType?: string(name='OrderType'),
  priceUnit?: string(name='PriceUnit'),
}

model DescribePriceResponseBody = {
  prices?: {
    priceInfo?: [ 
    {
      currency?: string(name='Currency'),
      nodeType?: string(name='NodeType'),
      originalPrice?: float(name='OriginalPrice'),
      tradePrice?: float(name='TradePrice'),
    }
  ](name='PriceInfo')
  }(name='Prices'),
  requestId?: string(name='RequestId'),
  totalTradePrice?: float(name='TotalTradePrice'),
}

model DescribePriceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePriceResponseBody(name='body'),
}

async function describePriceWithOptions(request: DescribePriceRequest, runtime: Util.RuntimeOptions): DescribePriceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePrice',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePrice(request: DescribePriceRequest): DescribePriceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePriceWithOptions(request, runtime);
}

model EditJobTemplateRequest {
  arrayRequest?: string(name='ArrayRequest'),
  clockTime?: string(name='ClockTime'),
  commandLine?: string(name='CommandLine'),
  gpu?: int32(name='Gpu'),
  inputFileUrl?: string(name='InputFileUrl'),
  mem?: string(name='Mem'),
  name?: string(name='Name'),
  node?: int32(name='Node'),
  packagePath?: string(name='PackagePath'),
  priority?: int32(name='Priority'),
  queue?: string(name='Queue'),
  reRunable?: boolean(name='ReRunable'),
  runasUser?: string(name='RunasUser'),
  stderrRedirectPath?: string(name='StderrRedirectPath'),
  stdoutRedirectPath?: string(name='StdoutRedirectPath'),
  task?: int32(name='Task'),
  templateId?: string(name='TemplateId'),
  thread?: int32(name='Thread'),
  unzipCmd?: string(name='UnzipCmd'),
  variables?: string(name='Variables'),
  withUnzipCmd?: boolean(name='WithUnzipCmd'),
}

model EditJobTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  templateId?: string(name='TemplateId'),
}

model EditJobTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: EditJobTemplateResponseBody(name='body'),
}

async function editJobTemplateWithOptions(request: EditJobTemplateRequest, runtime: Util.RuntimeOptions): EditJobTemplateResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EditJobTemplate',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function editJobTemplate(request: EditJobTemplateRequest): EditJobTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return editJobTemplateWithOptions(request, runtime);
}

model GetAccountingReportRequest {
  clusterId?: string(name='ClusterId'),
  dim?: string(name='Dim'),
  endTime?: int32(name='EndTime'),
  filterValue?: string(name='FilterValue'),
  jobId?: string(name='JobId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  reportType?: string(name='ReportType'),
  startTime?: int32(name='StartTime'),
}

model GetAccountingReportResponseBody = {
  data?: {
    data?: [ string ](name='Data')
  }(name='Data'),
  metrics?: string(name='Metrics'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCoreTime?: int32(name='TotalCoreTime'),
  totalCount?: int32(name='TotalCount'),
}

model GetAccountingReportResponse = {
  headers: map[string]string(name='headers'),
  body: GetAccountingReportResponseBody(name='body'),
}

async function getAccountingReportWithOptions(request: GetAccountingReportRequest, runtime: Util.RuntimeOptions): GetAccountingReportResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAccountingReport',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAccountingReport(request: GetAccountingReportRequest): GetAccountingReportResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAccountingReportWithOptions(request, runtime);
}

model GetAutoScaleConfigRequest {
  clusterId?: string(name='ClusterId'),
}

model GetAutoScaleConfigResponseBody = {
  clusterId?: string(name='ClusterId'),
  clusterType?: string(name='ClusterType'),
  enableAutoGrow?: boolean(name='EnableAutoGrow'),
  enableAutoShrink?: boolean(name='EnableAutoShrink'),
  excludeNodes?: string(name='ExcludeNodes'),
  extraNodesGrowRatio?: int32(name='ExtraNodesGrowRatio'),
  growIntervalInMinutes?: int32(name='GrowIntervalInMinutes'),
  growRatio?: int32(name='GrowRatio'),
  growTimeoutInMinutes?: int32(name='GrowTimeoutInMinutes'),
  imageId?: string(name='ImageId'),
  maxNodesInCluster?: int32(name='MaxNodesInCluster'),
  queues?: {
    queueInfo?: [ 
    {
      dataDisks?: {
        dataDisksInfo?: [ 
        {
          dataDiskCategory?: string(name='DataDiskCategory'),
          dataDiskDeleteWithInstance?: boolean(name='DataDiskDeleteWithInstance'),
          dataDiskEncrypted?: boolean(name='DataDiskEncrypted'),
          dataDiskKMSKeyId?: string(name='DataDiskKMSKeyId'),
          dataDiskPerformanceLevel?: string(name='DataDiskPerformanceLevel'),
          dataDiskSize?: int32(name='DataDiskSize'),
        }
      ](name='DataDisksInfo')
      }(name='DataDisks'),
      enableAutoGrow?: boolean(name='EnableAutoGrow'),
      enableAutoShrink?: boolean(name='EnableAutoShrink'),
      hostNamePrefix?: string(name='HostNamePrefix'),
      hostNameSuffix?: string(name='HostNameSuffix'),
      instanceType?: string(name='InstanceType'),
      instanceTypes?: {
        instanceTypeInfo?: [ 
        {
          hostNamePrefix?: string(name='HostNamePrefix'),
          instanceType?: string(name='InstanceType'),
          spotPriceLimit?: float(name='SpotPriceLimit'),
          spotStrategy?: string(name='SpotStrategy'),
          vSwitchId?: string(name='VSwitchId'),
          zoneId?: string(name='ZoneId'),
        }
      ](name='InstanceTypeInfo')
      }(name='InstanceTypes'),
      maxNodesInQueue?: int32(name='MaxNodesInQueue'),
      minNodesInQueue?: int32(name='MinNodesInQueue'),
      queueImageId?: string(name='QueueImageId'),
      queueName?: string(name='QueueName'),
      resourceGroupId?: string(name='ResourceGroupId'),
      spotPriceLimit?: float(name='SpotPriceLimit'),
      spotStrategy?: string(name='SpotStrategy'),
      systemDiskCategory?: string(name='SystemDiskCategory'),
      systemDiskLevel?: string(name='SystemDiskLevel'),
      systemDiskSize?: int32(name='SystemDiskSize'),
    }
  ](name='QueueInfo')
  }(name='Queues'),
  requestId?: string(name='RequestId'),
  shrinkIdleTimes?: int32(name='ShrinkIdleTimes'),
  shrinkIntervalInMinutes?: int32(name='ShrinkIntervalInMinutes'),
  spotPriceLimit?: float(name='SpotPriceLimit'),
  spotStrategy?: string(name='SpotStrategy'),
  uid?: string(name='Uid'),
}

model GetAutoScaleConfigResponse = {
  headers: map[string]string(name='headers'),
  body: GetAutoScaleConfigResponseBody(name='body'),
}

async function getAutoScaleConfigWithOptions(request: GetAutoScaleConfigRequest, runtime: Util.RuntimeOptions): GetAutoScaleConfigResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAutoScaleConfig',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAutoScaleConfig(request: GetAutoScaleConfigRequest): GetAutoScaleConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAutoScaleConfigWithOptions(request, runtime);
}

model GetCloudMetricLogsRequest {
  aggregationInterval?: int32(name='AggregationInterval'),
  aggregationType?: string(name='AggregationType'),
  clusterId?: string(name='ClusterId'),
  filter?: string(name='Filter'),
  from?: int32(name='From'),
  metricCategories?: string(name='MetricCategories'),
  metricScope?: string(name='MetricScope'),
  reverse?: boolean(name='Reverse'),
  to?: int32(name='To'),
}

model GetCloudMetricLogsResponseBody = {
  metricLogs?: {
    metricLog?: [ 
    {
      diskDevice?: string(name='DiskDevice'),
      hostname?: string(name='Hostname'),
      instanceId?: string(name='InstanceId'),
      metricData?: string(name='MetricData'),
      networkInterface?: string(name='NetworkInterface'),
      time?: int32(name='Time'),
    }
  ](name='MetricLog')
  }(name='MetricLogs'),
  requestId?: string(name='RequestId'),
}

model GetCloudMetricLogsResponse = {
  headers: map[string]string(name='headers'),
  body: GetCloudMetricLogsResponseBody(name='body'),
}

async function getCloudMetricLogsWithOptions(request: GetCloudMetricLogsRequest, runtime: Util.RuntimeOptions): GetCloudMetricLogsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCloudMetricLogs',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getCloudMetricLogs(request: GetCloudMetricLogsRequest): GetCloudMetricLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCloudMetricLogsWithOptions(request, runtime);
}

model GetCloudMetricProfilingRequest {
  clusterId?: string(name='ClusterId'),
  profilingId?: string(name='ProfilingId'),
  regionId?: string(name='RegionId'),
}

model GetCloudMetricProfilingResponseBody = {
  requestId?: string(name='RequestId'),
  svgUrls?: {
    svgInfo?: [ 
    {
      name?: string(name='Name'),
      size?: int32(name='Size'),
      type?: string(name='Type'),
      url?: string(name='Url'),
    }
  ](name='SvgInfo')
  }(name='SvgUrls'),
}

model GetCloudMetricProfilingResponse = {
  headers: map[string]string(name='headers'),
  body: GetCloudMetricProfilingResponseBody(name='body'),
}

async function getCloudMetricProfilingWithOptions(request: GetCloudMetricProfilingRequest, runtime: Util.RuntimeOptions): GetCloudMetricProfilingResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCloudMetricProfiling',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getCloudMetricProfiling(request: GetCloudMetricProfilingRequest): GetCloudMetricProfilingResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCloudMetricProfilingWithOptions(request, runtime);
}

model GetClusterVolumesRequest {
  clusterId?: string(name='ClusterId'),
}

model GetClusterVolumesResponseBody = {
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  volumes?: {
    volumeInfo?: [ 
    {
      jobQueue?: string(name='JobQueue'),
      localDirectory?: string(name='LocalDirectory'),
      location?: string(name='Location'),
      mustKeep?: boolean(name='MustKeep'),
      remoteDirectory?: string(name='RemoteDirectory'),
      roles?: {
        roleInfo?: [ 
        {
          name?: string(name='Name'),
        }
      ](name='RoleInfo')
      }(name='Roles'),
      volumeId?: string(name='VolumeId'),
      volumeMountpoint?: string(name='VolumeMountpoint'),
      volumeProtocol?: string(name='VolumeProtocol'),
      volumeType?: string(name='VolumeType'),
    }
  ](name='VolumeInfo')
  }(name='Volumes'),
}

model GetClusterVolumesResponse = {
  headers: map[string]string(name='headers'),
  body: GetClusterVolumesResponseBody(name='body'),
}

async function getClusterVolumesWithOptions(request: GetClusterVolumesRequest, runtime: Util.RuntimeOptions): GetClusterVolumesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetClusterVolumes',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getClusterVolumes(request: GetClusterVolumesRequest): GetClusterVolumesResponse {
  var runtime = new Util.RuntimeOptions{};
  return getClusterVolumesWithOptions(request, runtime);
}

model GetGWSConnectTicketRequest {
  appName?: string(name='AppName'),
  instanceId?: string(name='InstanceId'),
}

model GetGWSConnectTicketResponseBody = {
  requestId?: string(name='RequestId'),
  ticket?: string(name='Ticket'),
}

model GetGWSConnectTicketResponse = {
  headers: map[string]string(name='headers'),
  body: GetGWSConnectTicketResponseBody(name='body'),
}

async function getGWSConnectTicketWithOptions(request: GetGWSConnectTicketRequest, runtime: Util.RuntimeOptions): GetGWSConnectTicketResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetGWSConnectTicket',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getGWSConnectTicket(request: GetGWSConnectTicketRequest): GetGWSConnectTicketResponse {
  var runtime = new Util.RuntimeOptions{};
  return getGWSConnectTicketWithOptions(request, runtime);
}

model GetHybridClusterConfigRequest {
  clusterId?: string(name='ClusterId'),
  node?: string(name='Node'),
}

model GetHybridClusterConfigResponseBody = {
  clusterConfig?: string(name='ClusterConfig'),
  requestId?: string(name='RequestId'),
}

model GetHybridClusterConfigResponse = {
  headers: map[string]string(name='headers'),
  body: GetHybridClusterConfigResponseBody(name='body'),
}

async function getHybridClusterConfigWithOptions(request: GetHybridClusterConfigRequest, runtime: Util.RuntimeOptions): GetHybridClusterConfigResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetHybridClusterConfig',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getHybridClusterConfig(request: GetHybridClusterConfigRequest): GetHybridClusterConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return getHybridClusterConfigWithOptions(request, runtime);
}

model GetIfEcsTypeSupportHtConfigRequest {
  instanceType?: string(name='InstanceType'),
}

model GetIfEcsTypeSupportHtConfigResponseBody = {
  defaultHtEnabled?: boolean(name='DefaultHtEnabled'),
  instanceType?: string(name='InstanceType'),
  requestId?: string(name='RequestId'),
  supportHtConfig?: boolean(name='SupportHtConfig'),
}

model GetIfEcsTypeSupportHtConfigResponse = {
  headers: map[string]string(name='headers'),
  body: GetIfEcsTypeSupportHtConfigResponseBody(name='body'),
}

async function getIfEcsTypeSupportHtConfigWithOptions(request: GetIfEcsTypeSupportHtConfigRequest, runtime: Util.RuntimeOptions): GetIfEcsTypeSupportHtConfigResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetIfEcsTypeSupportHtConfig',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getIfEcsTypeSupportHtConfig(request: GetIfEcsTypeSupportHtConfigRequest): GetIfEcsTypeSupportHtConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return getIfEcsTypeSupportHtConfigWithOptions(request, runtime);
}

model GetSchedulerInfoRequest {
  clusterId?: string(name='ClusterId'),
  regionId?: string(name='RegionId'),
  scheduler?: [ 
    {
      schedName?: string(name='SchedName'),
    }
  ](name='Scheduler'),
}

model GetSchedulerInfoResponseBody = {
  requestId?: string(name='RequestId'),
  schedInfo?: [ 
    {
      configuration?: string(name='Configuration'),
      schedName?: string(name='SchedName'),
    }
  ](name='SchedInfo'),
}

model GetSchedulerInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetSchedulerInfoResponseBody(name='body'),
}

async function getSchedulerInfoWithOptions(request: GetSchedulerInfoRequest, runtime: Util.RuntimeOptions): GetSchedulerInfoResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSchedulerInfo',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSchedulerInfo(request: GetSchedulerInfoRequest): GetSchedulerInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSchedulerInfoWithOptions(request, runtime);
}

model GetVisualServiceStatusRequest {
  clusterId?: string(name='ClusterId'),
}

model GetVisualServiceStatusResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetVisualServiceStatusResponse = {
  headers: map[string]string(name='headers'),
  body: GetVisualServiceStatusResponseBody(name='body'),
}

async function getVisualServiceStatusWithOptions(request: GetVisualServiceStatusRequest, runtime: Util.RuntimeOptions): GetVisualServiceStatusResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetVisualServiceStatus',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getVisualServiceStatus(request: GetVisualServiceStatusRequest): GetVisualServiceStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVisualServiceStatusWithOptions(request, runtime);
}

model InitializeEHPCRequest {
  regionId?: string(name='RegionId'),
}

model InitializeEHPCResponseBody = {
  requestId?: string(name='RequestId'),
}

model InitializeEHPCResponse = {
  headers: map[string]string(name='headers'),
  body: InitializeEHPCResponseBody(name='body'),
}

async function initializeEHPCWithOptions(request: InitializeEHPCRequest, runtime: Util.RuntimeOptions): InitializeEHPCResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InitializeEHPC',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function initializeEHPC(request: InitializeEHPCRequest): InitializeEHPCResponse {
  var runtime = new Util.RuntimeOptions{};
  return initializeEHPCWithOptions(request, runtime);
}

model InstallSoftwareRequest {
  application?: string(name='Application'),
  clusterId?: string(name='ClusterId'),
}

model InstallSoftwareResponseBody = {
  requestId?: string(name='RequestId'),
}

model InstallSoftwareResponse = {
  headers: map[string]string(name='headers'),
  body: InstallSoftwareResponseBody(name='body'),
}

async function installSoftwareWithOptions(request: InstallSoftwareRequest, runtime: Util.RuntimeOptions): InstallSoftwareResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InstallSoftware',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function installSoftware(request: InstallSoftwareRequest): InstallSoftwareResponse {
  var runtime = new Util.RuntimeOptions{};
  return installSoftwareWithOptions(request, runtime);
}

model InvokeShellCommandRequest {
  clusterId?: string(name='ClusterId'),
  command?: string(name='Command'),
  instance?: [ 
    {
      id?: string(name='Id'),
    }
  ](name='Instance'),
  timeout?: int32(name='Timeout'),
  workingDir?: string(name='WorkingDir'),
}

model InvokeShellCommandResponseBody = {
  commandId?: string(name='CommandId'),
  instanceIds?: {
    instanceId?: [ string ](name='InstanceId')
  }(name='InstanceIds'),
  requestId?: string(name='RequestId'),
}

model InvokeShellCommandResponse = {
  headers: map[string]string(name='headers'),
  body: InvokeShellCommandResponseBody(name='body'),
}

async function invokeShellCommandWithOptions(request: InvokeShellCommandRequest, runtime: Util.RuntimeOptions): InvokeShellCommandResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InvokeShellCommand',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function invokeShellCommand(request: InvokeShellCommandRequest): InvokeShellCommandResponse {
  var runtime = new Util.RuntimeOptions{};
  return invokeShellCommandWithOptions(request, runtime);
}

model ListAvailableEcsTypesRequest {
  instanceChargeType?: string(name='InstanceChargeType'),
  showSoldOut?: boolean(name='ShowSoldOut'),
  spotStrategy?: string(name='SpotStrategy'),
  zoneId?: string(name='ZoneId'),
}

model ListAvailableEcsTypesResponseBody = {
  instanceTypeFamilies?: {
    instanceTypeFamilyInfo?: [ 
    {
      generation?: string(name='Generation'),
      instanceTypeFamilyId?: string(name='InstanceTypeFamilyId'),
      types?: {
        typesInfo?: [ 
        {
          cpuCoreCount?: int32(name='CpuCoreCount'),
          eniQuantity?: int32(name='EniQuantity'),
          GPUAmount?: int32(name='GPUAmount'),
          GPUSpec?: string(name='GPUSpec'),
          instanceBandwidthRx?: int32(name='InstanceBandwidthRx'),
          instanceBandwidthTx?: int32(name='InstanceBandwidthTx'),
          instancePpsRx?: int32(name='InstancePpsRx'),
          instancePpsTx?: int32(name='InstancePpsTx'),
          instanceTypeId?: string(name='InstanceTypeId'),
          memorySize?: int32(name='MemorySize'),
          status?: string(name='Status'),
          zoneIds?: {
            zoneId?: [ string ](name='ZoneId')
          }(name='ZoneIds'),
        }
      ](name='TypesInfo')
      }(name='Types'),
    }
  ](name='InstanceTypeFamilyInfo')
  }(name='InstanceTypeFamilies'),
  requestId?: string(name='RequestId'),
  supportSpotInstance?: boolean(name='SupportSpotInstance'),
}

model ListAvailableEcsTypesResponse = {
  headers: map[string]string(name='headers'),
  body: ListAvailableEcsTypesResponseBody(name='body'),
}

async function listAvailableEcsTypesWithOptions(request: ListAvailableEcsTypesRequest, runtime: Util.RuntimeOptions): ListAvailableEcsTypesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAvailableEcsTypes',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAvailableEcsTypes(request: ListAvailableEcsTypesRequest): ListAvailableEcsTypesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAvailableEcsTypesWithOptions(request, runtime);
}

model ListCloudMetricProfilingsRequest {
  clusterId?: string(name='ClusterId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
}

model ListCloudMetricProfilingsResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  profilings?: {
    profilingInfo?: [ 
    {
      duration?: int32(name='Duration'),
      freq?: int32(name='Freq'),
      hostName?: string(name='HostName'),
      instanceId?: string(name='InstanceId'),
      pid?: int32(name='Pid'),
      profilingId?: string(name='ProfilingId'),
      triggerTime?: string(name='TriggerTime'),
    }
  ](name='ProfilingInfo')
  }(name='Profilings'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListCloudMetricProfilingsResponse = {
  headers: map[string]string(name='headers'),
  body: ListCloudMetricProfilingsResponseBody(name='body'),
}

async function listCloudMetricProfilingsWithOptions(request: ListCloudMetricProfilingsRequest, runtime: Util.RuntimeOptions): ListCloudMetricProfilingsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCloudMetricProfilings',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listCloudMetricProfilings(request: ListCloudMetricProfilingsRequest): ListCloudMetricProfilingsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCloudMetricProfilingsWithOptions(request, runtime);
}

model ListClusterLogsRequest {
  clusterId?: string(name='ClusterId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListClusterLogsResponseBody = {
  clusterId?: string(name='ClusterId'),
  logs?: {
    logInfo?: [ 
    {
      createTime?: string(name='CreateTime'),
      level?: string(name='Level'),
      message?: string(name='Message'),
      operation?: string(name='Operation'),
    }
  ](name='LogInfo')
  }(name='Logs'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListClusterLogsResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterLogsResponseBody(name='body'),
}

async function listClusterLogsWithOptions(request: ListClusterLogsRequest, runtime: Util.RuntimeOptions): ListClusterLogsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListClusterLogs',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listClusterLogs(request: ListClusterLogsRequest): ListClusterLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClusterLogsWithOptions(request, runtime);
}

model ListClustersRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListClustersResponseBody = {
  clusters?: {
    clusterInfoSimple?: [ 
    {
      accountType?: string(name='AccountType'),
      baseOsTag?: string(name='BaseOsTag'),
      clientVersion?: string(name='ClientVersion'),
      computeSpotPriceLimit?: float(name='ComputeSpotPriceLimit'),
      computeSpotStrategy?: string(name='ComputeSpotStrategy'),
      computes?: {
        exceptionCount?: int32(name='ExceptionCount'),
        normalCount?: int32(name='NormalCount'),
        operatingCount?: int32(name='OperatingCount'),
        stoppedCount?: int32(name='StoppedCount'),
        total?: int32(name='Total'),
      }(name='Computes'),
      count?: int32(name='Count'),
      createTime?: string(name='CreateTime'),
      deployMode?: string(name='DeployMode'),
      description?: string(name='Description'),
      ehpcVersion?: string(name='EhpcVersion'),
      hasPlugin?: boolean(name='HasPlugin'),
      id?: string(name='Id'),
      imageId?: string(name='ImageId'),
      imageOwnerAlias?: string(name='ImageOwnerAlias'),
      instanceChargeType?: string(name='InstanceChargeType'),
      instanceType?: string(name='InstanceType'),
      isComputeEss?: boolean(name='IsComputeEss'),
      location?: string(name='Location'),
      loginNodes?: string(name='LoginNodes'),
      managers?: {
        exceptionCount?: int32(name='ExceptionCount'),
        normalCount?: int32(name='NormalCount'),
        operatingCount?: int32(name='OperatingCount'),
        stoppedCount?: int32(name='StoppedCount'),
        total?: int32(name='Total'),
      }(name='Managers'),
      name?: string(name='Name'),
      nodePrefix?: string(name='NodePrefix'),
      nodeSuffix?: string(name='NodeSuffix'),
      osTag?: string(name='OsTag'),
      regionId?: string(name='RegionId'),
      schedulerType?: string(name='SchedulerType'),
      status?: string(name='Status'),
      totalResources?: {
        cpu?: int32(name='Cpu'),
        gpu?: int32(name='Gpu'),
        memory?: int32(name='Memory'),
      }(name='TotalResources'),
      usedResources?: {
        cpu?: int32(name='Cpu'),
        gpu?: int32(name='Gpu'),
        memory?: int32(name='Memory'),
      }(name='UsedResources'),
      vSwitchId?: string(name='VSwitchId'),
      vpcId?: string(name='VpcId'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='ClusterInfoSimple')
  }(name='Clusters'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListClustersResponse = {
  headers: map[string]string(name='headers'),
  body: ListClustersResponseBody(name='body'),
}

async function listClustersWithOptions(request: ListClustersRequest, runtime: Util.RuntimeOptions): ListClustersResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListClusters',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listClusters(request: ListClustersRequest): ListClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClustersWithOptions(request, runtime);
}

model ListClustersMetaRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListClustersMetaResponseBody = {
  clusters?: {
    clusterInfoSimple?: [ 
    {
      accountType?: string(name='AccountType'),
      clientVersion?: string(name='ClientVersion'),
      deployMode?: string(name='DeployMode'),
      description?: string(name='Description'),
      hasPlugin?: boolean(name='HasPlugin'),
      id?: string(name='Id'),
      isComputeEss?: boolean(name='IsComputeEss'),
      location?: string(name='Location'),
      name?: string(name='Name'),
      osTag?: string(name='OsTag'),
      schedulerType?: string(name='SchedulerType'),
      status?: string(name='Status'),
      vpcId?: string(name='VpcId'),
    }
  ](name='ClusterInfoSimple')
  }(name='Clusters'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListClustersMetaResponse = {
  headers: map[string]string(name='headers'),
  body: ListClustersMetaResponseBody(name='body'),
}

async function listClustersMetaWithOptions(request: ListClustersMetaRequest, runtime: Util.RuntimeOptions): ListClustersMetaResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListClustersMeta',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listClustersMeta(request: ListClustersMetaRequest): ListClustersMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClustersMetaWithOptions(request, runtime);
}

model ListCommandsRequest {
  clusterId?: string(name='ClusterId'),
  commandId?: string(name='CommandId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListCommandsResponseBody = {
  commands?: {
    command?: [ 
    {
      commandContent?: string(name='CommandContent'),
      commandId?: string(name='CommandId'),
      timeout?: string(name='Timeout'),
      workingDir?: string(name='WorkingDir'),
    }
  ](name='Command')
  }(name='Commands'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListCommandsResponse = {
  headers: map[string]string(name='headers'),
  body: ListCommandsResponseBody(name='body'),
}

async function listCommandsWithOptions(request: ListCommandsRequest, runtime: Util.RuntimeOptions): ListCommandsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCommands',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listCommands(request: ListCommandsRequest): ListCommandsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCommandsWithOptions(request, runtime);
}

model ListContainerAppsRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListContainerAppsResponseBody = {
  containerApps?: {
    containerApps?: [ 
    {
      createTime?: string(name='CreateTime'),
      description?: string(name='Description'),
      id?: string(name='Id'),
      imageTag?: string(name='ImageTag'),
      name?: string(name='Name'),
      repository?: string(name='Repository'),
      type?: string(name='Type'),
    }
  ](name='ContainerApps')
  }(name='ContainerApps'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListContainerAppsResponse = {
  headers: map[string]string(name='headers'),
  body: ListContainerAppsResponseBody(name='body'),
}

async function listContainerAppsWithOptions(request: ListContainerAppsRequest, runtime: Util.RuntimeOptions): ListContainerAppsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListContainerApps',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listContainerApps(request: ListContainerAppsRequest): ListContainerAppsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listContainerAppsWithOptions(request, runtime);
}

model ListContainerImagesRequest {
  clusterId?: string(name='ClusterId'),
  containerType?: string(name='ContainerType'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListContainerImagesResponseBody = {
  DBInfo?: string(name='DBInfo'),
  images?: {
    images?: [ 
    {
      imageId?: string(name='ImageId'),
      repository?: string(name='Repository'),
      status?: string(name='Status'),
      system?: string(name='System'),
      tag?: string(name='Tag'),
      type?: string(name='Type'),
      updateDateTime?: string(name='UpdateDateTime'),
    }
  ](name='Images')
  }(name='Images'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListContainerImagesResponse = {
  headers: map[string]string(name='headers'),
  body: ListContainerImagesResponseBody(name='body'),
}

async function listContainerImagesWithOptions(request: ListContainerImagesRequest, runtime: Util.RuntimeOptions): ListContainerImagesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListContainerImages',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listContainerImages(request: ListContainerImagesRequest): ListContainerImagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listContainerImagesWithOptions(request, runtime);
}

model ListCpfsFileSystemsRequest {
  fileSystemId?: string(name='FileSystemId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListCpfsFileSystemsResponseBody = {
  fileSystemList?: {
    fileSystems?: [ 
    {
      capacity?: string(name='Capacity'),
      createTime?: string(name='CreateTime'),
      destription?: string(name='Destription'),
      fileSystemId?: string(name='FileSystemId'),
      mountTargetList?: {
        mountTargets?: [ 
        {
          mountTargetDomain?: string(name='MountTargetDomain'),
          networkType?: string(name='NetworkType'),
          status?: string(name='Status'),
          vpcId?: string(name='VpcId'),
          vswId?: string(name='VswId'),
        }
      ](name='MountTargets')
      }(name='MountTargetList'),
      protocolType?: string(name='ProtocolType'),
      regionId?: string(name='RegionId'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='FileSystems')
  }(name='FileSystemList'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListCpfsFileSystemsResponse = {
  headers: map[string]string(name='headers'),
  body: ListCpfsFileSystemsResponseBody(name='body'),
}

async function listCpfsFileSystemsWithOptions(request: ListCpfsFileSystemsRequest, runtime: Util.RuntimeOptions): ListCpfsFileSystemsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCpfsFileSystems',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listCpfsFileSystems(request: ListCpfsFileSystemsRequest): ListCpfsFileSystemsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCpfsFileSystemsWithOptions(request, runtime);
}

model ListCurrentClientVersionResponseBody = {
  clientVersion?: string(name='ClientVersion'),
  requestId?: string(name='RequestId'),
}

model ListCurrentClientVersionResponse = {
  headers: map[string]string(name='headers'),
  body: ListCurrentClientVersionResponseBody(name='body'),
}

async function listCurrentClientVersionWithOptions(runtime: Util.RuntimeOptions): ListCurrentClientVersionResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'ListCurrentClientVersion',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listCurrentClientVersion(): ListCurrentClientVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCurrentClientVersionWithOptions(runtime);
}

model ListCustomImagesRequest {
  baseOsTag?: string(name='BaseOsTag'),
  clusterId?: string(name='ClusterId'),
  imageOwnerAlias?: string(name='ImageOwnerAlias'),
  instanceType?: string(name='InstanceType'),
}

model ListCustomImagesResponseBody = {
  images?: {
    imageInfo?: [ 
    {
      baseOsTag?: {
        architecture?: string(name='Architecture'),
        osTag?: string(name='OsTag'),
        platform?: string(name='Platform'),
        version?: string(name='Version'),
      }(name='BaseOsTag'),
      description?: string(name='Description'),
      imageId?: string(name='ImageId'),
      imageName?: string(name='ImageName'),
      imageOwnerAlias?: string(name='ImageOwnerAlias'),
      osTag?: {
        architecture?: string(name='Architecture'),
        baseOsTag?: string(name='BaseOsTag'),
        osTag?: string(name='OsTag'),
        platform?: string(name='Platform'),
        version?: string(name='Version'),
      }(name='OsTag'),
      postInstallScript?: string(name='PostInstallScript'),
      pricingCycle?: string(name='PricingCycle'),
      productCode?: string(name='ProductCode'),
      size?: int32(name='Size'),
      skuCode?: string(name='SkuCode'),
      status?: string(name='Status'),
      uid?: string(name='Uid'),
    }
  ](name='ImageInfo')
  }(name='Images'),
  requestId?: string(name='RequestId'),
}

model ListCustomImagesResponse = {
  headers: map[string]string(name='headers'),
  body: ListCustomImagesResponseBody(name='body'),
}

async function listCustomImagesWithOptions(request: ListCustomImagesRequest, runtime: Util.RuntimeOptions): ListCustomImagesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCustomImages',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listCustomImages(request: ListCustomImagesRequest): ListCustomImagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCustomImagesWithOptions(request, runtime);
}

model ListFileSystemWithMountTargetsRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListFileSystemWithMountTargetsResponseBody = {
  fileSystemList?: {
    fileSystems?: [ 
    {
      bandWidth?: int32(name='BandWidth'),
      capacity?: int32(name='Capacity'),
      createTime?: string(name='CreateTime'),
      destription?: string(name='Destription'),
      encryptType?: int32(name='EncryptType'),
      fileSystemId?: string(name='FileSystemId'),
      fileSystemType?: string(name='FileSystemType'),
      meteredSize?: int32(name='MeteredSize'),
      mountTargetList?: {
        mountTargets?: [ 
        {
          accessGroup?: string(name='AccessGroup'),
          mountTargetDomain?: string(name='MountTargetDomain'),
          networkType?: string(name='NetworkType'),
          status?: string(name='Status'),
          vpcId?: string(name='VpcId'),
          vswId?: string(name='VswId'),
        }
      ](name='MountTargets')
      }(name='MountTargetList'),
      packageList?: {
        packages?: [ 
        {
          packageId?: string(name='PackageId'),
        }
      ](name='Packages')
      }(name='PackageList'),
      protocolType?: string(name='ProtocolType'),
      regionId?: string(name='RegionId'),
      status?: string(name='Status'),
      storageType?: string(name='StorageType'),
    }
  ](name='FileSystems')
  }(name='FileSystemList'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListFileSystemWithMountTargetsResponse = {
  headers: map[string]string(name='headers'),
  body: ListFileSystemWithMountTargetsResponseBody(name='body'),
}

async function listFileSystemWithMountTargetsWithOptions(request: ListFileSystemWithMountTargetsRequest, runtime: Util.RuntimeOptions): ListFileSystemWithMountTargetsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFileSystemWithMountTargets',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFileSystemWithMountTargets(request: ListFileSystemWithMountTargetsRequest): ListFileSystemWithMountTargetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFileSystemWithMountTargetsWithOptions(request, runtime);
}

model ListImagesRequest {
  baseOsTag?: string(name='BaseOsTag'),
  instanceType?: string(name='InstanceType'),
}

model ListImagesResponseBody = {
  osTags?: {
    osInfo?: [ 
    {
      architecture?: string(name='Architecture'),
      baseOsTag?: string(name='BaseOsTag'),
      imageId?: string(name='ImageId'),
      osTag?: string(name='OsTag'),
      platform?: string(name='Platform'),
      version?: string(name='Version'),
    }
  ](name='OsInfo')
  }(name='OsTags'),
  requestId?: string(name='RequestId'),
}

model ListImagesResponse = {
  headers: map[string]string(name='headers'),
  body: ListImagesResponseBody(name='body'),
}

async function listImagesWithOptions(request: ListImagesRequest, runtime: Util.RuntimeOptions): ListImagesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListImages',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listImages(request: ListImagesRequest): ListImagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listImagesWithOptions(request, runtime);
}

model ListInstalledSoftwareRequest {
  clusterId?: string(name='ClusterId'),
}

model ListInstalledSoftwareResponseBody = {
  requestId?: string(name='RequestId'),
  softwareList?: {
    softwareList?: [ 
    {
      softwareId?: string(name='SoftwareId'),
      softwareName?: string(name='SoftwareName'),
      softwareStatus?: string(name='SoftwareStatus'),
      softwareVersion?: string(name='SoftwareVersion'),
    }
  ](name='SoftwareList')
  }(name='SoftwareList'),
}

model ListInstalledSoftwareResponse = {
  headers: map[string]string(name='headers'),
  body: ListInstalledSoftwareResponseBody(name='body'),
}

async function listInstalledSoftwareWithOptions(request: ListInstalledSoftwareRequest, runtime: Util.RuntimeOptions): ListInstalledSoftwareResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInstalledSoftware',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listInstalledSoftware(request: ListInstalledSoftwareRequest): ListInstalledSoftwareResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInstalledSoftwareWithOptions(request, runtime);
}

model ListInvocationResultsRequest {
  clusterId?: string(name='ClusterId'),
  commandId?: string(name='CommandId'),
  instance?: [ 
    {
      id?: string(name='Id'),
    }
  ](name='Instance'),
  invokeRecordStatus?: string(name='InvokeRecordStatus'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListInvocationResultsResponseBody = {
  invocationResults?: {
    invocationResult?: [ 
    {
      commandId?: string(name='CommandId'),
      exitCode?: int32(name='ExitCode'),
      finishedTime?: string(name='FinishedTime'),
      instanceId?: string(name='InstanceId'),
      invokeRecordStatus?: string(name='InvokeRecordStatus'),
      message?: string(name='Message'),
      success?: boolean(name='Success'),
    }
  ](name='InvocationResult')
  }(name='InvocationResults'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListInvocationResultsResponse = {
  headers: map[string]string(name='headers'),
  body: ListInvocationResultsResponseBody(name='body'),
}

async function listInvocationResultsWithOptions(request: ListInvocationResultsRequest, runtime: Util.RuntimeOptions): ListInvocationResultsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInvocationResults',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listInvocationResults(request: ListInvocationResultsRequest): ListInvocationResultsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInvocationResultsWithOptions(request, runtime);
}

model ListInvocationStatusRequest {
  clusterId?: string(name='ClusterId'),
  commandId?: string(name='CommandId'),
}

model ListInvocationStatusResponseBody = {
  commandId?: string(name='CommandId'),
  invokeInstances?: {
    invokeInstance?: [ 
    {
      instanceId?: string(name='InstanceId'),
      instanceInvokeStatus?: string(name='InstanceInvokeStatus'),
    }
  ](name='InvokeInstance')
  }(name='InvokeInstances'),
  invokeStatus?: string(name='InvokeStatus'),
  requestId?: string(name='RequestId'),
}

model ListInvocationStatusResponse = {
  headers: map[string]string(name='headers'),
  body: ListInvocationStatusResponseBody(name='body'),
}

async function listInvocationStatusWithOptions(request: ListInvocationStatusRequest, runtime: Util.RuntimeOptions): ListInvocationStatusResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInvocationStatus',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listInvocationStatus(request: ListInvocationStatusRequest): ListInvocationStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInvocationStatusWithOptions(request, runtime);
}

model ListJobTemplatesRequest {
  name?: string(name='Name'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListJobTemplatesResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  templates?: {
    jobTemplates?: [ 
    {
      arrayRequest?: string(name='ArrayRequest'),
      clockTime?: string(name='ClockTime'),
      commandLine?: string(name='CommandLine'),
      gpu?: int32(name='Gpu'),
      id?: string(name='Id'),
      inputFileUrl?: string(name='InputFileUrl'),
      mem?: string(name='Mem'),
      name?: string(name='Name'),
      node?: int32(name='Node'),
      packagePath?: string(name='PackagePath'),
      priority?: int32(name='Priority'),
      queue?: string(name='Queue'),
      reRunable?: boolean(name='ReRunable'),
      runasUser?: string(name='RunasUser'),
      stderrRedirectPath?: string(name='StderrRedirectPath'),
      stdoutRedirectPath?: string(name='StdoutRedirectPath'),
      task?: int32(name='Task'),
      thread?: int32(name='Thread'),
      unzipCmd?: string(name='UnzipCmd'),
      variables?: string(name='Variables'),
      withUnzipCmd?: boolean(name='WithUnzipCmd'),
    }
  ](name='JobTemplates')
  }(name='Templates'),
  totalCount?: int32(name='TotalCount'),
}

model ListJobTemplatesResponse = {
  headers: map[string]string(name='headers'),
  body: ListJobTemplatesResponseBody(name='body'),
}

async function listJobTemplatesWithOptions(request: ListJobTemplatesRequest, runtime: Util.RuntimeOptions): ListJobTemplatesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListJobTemplates',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listJobTemplates(request: ListJobTemplatesRequest): ListJobTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listJobTemplatesWithOptions(request, runtime);
}

model ListJobsRequest {
  clusterId?: string(name='ClusterId'),
  owner?: string(name='Owner'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  rerunable?: string(name='Rerunable'),
  state?: string(name='State'),
}

model ListJobsResponseBody = {
  jobs?: {
    jobInfo?: [ 
    {
      arrayRequest?: string(name='ArrayRequest'),
      comment?: string(name='Comment'),
      id?: string(name='Id'),
      lastModifyTime?: string(name='LastModifyTime'),
      name?: string(name='Name'),
      nodeList?: string(name='NodeList'),
      owner?: string(name='Owner'),
      priority?: string(name='Priority'),
      resources?: {
        cores?: int32(name='Cores'),
        nodes?: int32(name='Nodes'),
      }(name='Resources'),
      shellPath?: string(name='ShellPath'),
      startTime?: string(name='StartTime'),
      state?: string(name='State'),
      stderr?: string(name='Stderr'),
      stdout?: string(name='Stdout'),
      submitTime?: string(name='SubmitTime'),
    }
  ](name='JobInfo')
  }(name='Jobs'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListJobsResponse = {
  headers: map[string]string(name='headers'),
  body: ListJobsResponseBody(name='body'),
}

async function listJobsWithOptions(request: ListJobsRequest, runtime: Util.RuntimeOptions): ListJobsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListJobs',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listJobs(request: ListJobsRequest): ListJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listJobsWithOptions(request, runtime);
}

model ListNodesRequest {
  clusterId?: string(name='ClusterId'),
  filter?: string(name='Filter'),
  hostName?: string(name='HostName'),
  hostNamePrefix?: string(name='HostNamePrefix'),
  hostNameSuffix?: string(name='HostNameSuffix'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  privateIpAddress?: string(name='PrivateIpAddress'),
  role?: string(name='Role'),
  sequence?: string(name='Sequence'),
  sortBy?: string(name='SortBy'),
}

model ListNodesResponseBody = {
  nodes?: {
    nodeInfo?: [ 
    {
      addTime?: string(name='AddTime'),
      createMode?: string(name='CreateMode'),
      createdByEhpc?: boolean(name='CreatedByEhpc'),
      expired?: boolean(name='Expired'),
      expiredTime?: string(name='ExpiredTime'),
      hostName?: string(name='HostName'),
      htEnabled?: boolean(name='HtEnabled'),
      id?: string(name='Id'),
      imageId?: string(name='ImageId'),
      imageOwnerAlias?: string(name='ImageOwnerAlias'),
      instanceType?: string(name='InstanceType'),
      ipAddress?: string(name='IpAddress'),
      location?: string(name='Location'),
      lockReason?: string(name='LockReason'),
      publicIpAddress?: string(name='PublicIpAddress'),
      regionId?: string(name='RegionId'),
      roles?: {
        role?: [ string ](name='Role')
      }(name='Roles'),
      spotStrategy?: string(name='SpotStrategy'),
      stateInSched?: string(name='StateInSched'),
      status?: string(name='Status'),
      totalResources?: {
        cpu?: int32(name='Cpu'),
        gpu?: int32(name='Gpu'),
        memory?: int32(name='Memory'),
      }(name='TotalResources'),
      usedResources?: {
        cpu?: int32(name='Cpu'),
        gpu?: int32(name='Gpu'),
        memory?: int32(name='Memory'),
      }(name='UsedResources'),
      vSwitchId?: string(name='VSwitchId'),
      version?: string(name='Version'),
      vpcId?: string(name='VpcId'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='NodeInfo')
  }(name='Nodes'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListNodesResponse = {
  headers: map[string]string(name='headers'),
  body: ListNodesResponseBody(name='body'),
}

async function listNodesWithOptions(request: ListNodesRequest, runtime: Util.RuntimeOptions): ListNodesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListNodes',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listNodes(request: ListNodesRequest): ListNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNodesWithOptions(request, runtime);
}

model ListNodesByQueueRequest {
  clusterId?: string(name='ClusterId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  queueName?: string(name='QueueName'),
}

model ListNodesByQueueResponseBody = {
  nodes?: {
    nodeInfo?: [ 
    {
      addTime?: string(name='AddTime'),
      createMode?: string(name='CreateMode'),
      createdByEhpc?: boolean(name='CreatedByEhpc'),
      expired?: boolean(name='Expired'),
      expiredTime?: string(name='ExpiredTime'),
      hostName?: string(name='HostName'),
      htEnabled?: boolean(name='HtEnabled'),
      id?: string(name='Id'),
      imageId?: string(name='ImageId'),
      imageOwnerAlias?: string(name='ImageOwnerAlias'),
      ipAddress?: string(name='IpAddress'),
      location?: string(name='Location'),
      lockReason?: string(name='LockReason'),
      publicIpAddress?: string(name='PublicIpAddress'),
      regionId?: string(name='RegionId'),
      spotStrategy?: string(name='SpotStrategy'),
      stateInSched?: string(name='StateInSched'),
      status?: string(name='Status'),
      totalResources?: {
        cpu?: int32(name='Cpu'),
        gpu?: int32(name='Gpu'),
        memory?: int32(name='Memory'),
      }(name='TotalResources'),
      usedResources?: {
        cpu?: int32(name='Cpu'),
        gpu?: int32(name='Gpu'),
        memory?: int32(name='Memory'),
      }(name='UsedResources'),
      vSwitchId?: string(name='VSwitchId'),
      version?: string(name='Version'),
      vpcId?: string(name='VpcId'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='NodeInfo')
  }(name='Nodes'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListNodesByQueueResponse = {
  headers: map[string]string(name='headers'),
  body: ListNodesByQueueResponseBody(name='body'),
}

async function listNodesByQueueWithOptions(request: ListNodesByQueueRequest, runtime: Util.RuntimeOptions): ListNodesByQueueResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListNodesByQueue',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listNodesByQueue(request: ListNodesByQueueRequest): ListNodesByQueueResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNodesByQueueWithOptions(request, runtime);
}

model ListNodesNoPagingRequest {
  clusterId?: string(name='ClusterId'),
  hostName?: string(name='HostName'),
  role?: string(name='Role'),
  sequence?: string(name='Sequence'),
}

model ListNodesNoPagingResponseBody = {
  nodes?: {
    nodeInfo?: [ 
    {
      hostName?: string(name='HostName'),
      id?: string(name='Id'),
      imageId?: string(name='ImageId'),
      instanceType?: string(name='InstanceType'),
      status?: string(name='Status'),
    }
  ](name='NodeInfo')
  }(name='Nodes'),
  requestId?: string(name='RequestId'),
}

model ListNodesNoPagingResponse = {
  headers: map[string]string(name='headers'),
  body: ListNodesNoPagingResponseBody(name='body'),
}

async function listNodesNoPagingWithOptions(request: ListNodesNoPagingRequest, runtime: Util.RuntimeOptions): ListNodesNoPagingResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListNodesNoPaging',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listNodesNoPaging(request: ListNodesNoPagingRequest): ListNodesNoPagingResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNodesNoPagingWithOptions(request, runtime);
}

model ListPreferredEcsTypesRequest {
  instanceChargeType?: string(name='InstanceChargeType'),
  spotStrategy?: string(name='SpotStrategy'),
  zoneId?: string(name='ZoneId'),
}

model ListPreferredEcsTypesResponseBody = {
  requestId?: string(name='RequestId'),
  series?: {
    seriesInfo?: [ 
    {
      roles?: {
        compute?: {
          instanceTypeId?: [ string ](name='InstanceTypeId')
        }(name='Compute'),
        login?: {
          instanceTypeId?: [ string ](name='InstanceTypeId')
        }(name='Login'),
        manager?: {
          instanceTypeId?: [ string ](name='InstanceTypeId')
        }(name='Manager'),
      }(name='Roles'),
      seriesId?: string(name='SeriesId'),
      seriesName?: string(name='SeriesName'),
    }
  ](name='SeriesInfo')
  }(name='Series'),
  supportSpotInstance?: boolean(name='SupportSpotInstance'),
}

model ListPreferredEcsTypesResponse = {
  headers: map[string]string(name='headers'),
  body: ListPreferredEcsTypesResponseBody(name='body'),
}

async function listPreferredEcsTypesWithOptions(request: ListPreferredEcsTypesRequest, runtime: Util.RuntimeOptions): ListPreferredEcsTypesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPreferredEcsTypes',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPreferredEcsTypes(request: ListPreferredEcsTypesRequest): ListPreferredEcsTypesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPreferredEcsTypesWithOptions(request, runtime);
}

model ListQueuesRequest {
  clusterId?: string(name='ClusterId'),
}

model ListQueuesResponseBody = {
  queues?: {
    queueInfo?: [ 
    {
      computeInstanceType?: {
        instanceType?: [ string ](name='InstanceType')
      }(name='ComputeInstanceType'),
      enableAutoGrow?: boolean(name='EnableAutoGrow'),
      hostNamePrefix?: string(name='HostNamePrefix'),
      hostNameSuffix?: string(name='HostNameSuffix'),
      imageId?: string(name='ImageId'),
      queueName?: string(name='QueueName'),
      resourceGroupId?: string(name='ResourceGroupId'),
      spotInstanceTypes?: {
        instance?: [ 
        {
          instanceType?: string(name='InstanceType'),
          spotPriceLimit?: float(name='SpotPriceLimit'),
        }
      ](name='Instance')
      }(name='SpotInstanceTypes'),
      spotStrategy?: string(name='SpotStrategy'),
      type?: string(name='Type'),
    }
  ](name='QueueInfo')
  }(name='Queues'),
  requestId?: string(name='RequestId'),
}

model ListQueuesResponse = {
  headers: map[string]string(name='headers'),
  body: ListQueuesResponseBody(name='body'),
}

async function listQueuesWithOptions(request: ListQueuesRequest, runtime: Util.RuntimeOptions): ListQueuesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListQueues',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listQueues(request: ListQueuesRequest): ListQueuesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listQueuesWithOptions(request, runtime);
}

model ListRegionsResponseBody = {
  regions?: {
    regionInfo?: [ 
    {
      localName?: string(name='LocalName'),
      regionId?: string(name='RegionId'),
    }
  ](name='RegionInfo')
  }(name='Regions'),
  requestId?: string(name='RequestId'),
}

model ListRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListRegionsResponseBody(name='body'),
}

async function listRegionsWithOptions(runtime: Util.RuntimeOptions): ListRegionsResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'ListRegions',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listRegions(): ListRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRegionsWithOptions(runtime);
}

model ListSecurityGroupsRequest {
  clusterId?: string(name='ClusterId'),
}

model ListSecurityGroupsResponseBody = {
  requestId?: string(name='RequestId'),
  securityGroups?: {
    securityGroup?: [ string ](name='SecurityGroup')
  }(name='SecurityGroups'),
  totalCount?: int32(name='TotalCount'),
}

model ListSecurityGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: ListSecurityGroupsResponseBody(name='body'),
}

async function listSecurityGroupsWithOptions(request: ListSecurityGroupsRequest, runtime: Util.RuntimeOptions): ListSecurityGroupsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSecurityGroups',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSecurityGroups(request: ListSecurityGroupsRequest): ListSecurityGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSecurityGroupsWithOptions(request, runtime);
}

model ListSoftwaresRequest {
  ehpcVersion?: string(name='EhpcVersion'),
  osTag?: string(name='OsTag'),
}

model ListSoftwaresResponseBody = {
  requestId?: string(name='RequestId'),
  softwares?: {
    softwareInfo?: [ 
    {
      accountType?: string(name='AccountType'),
      accountVersion?: string(name='AccountVersion'),
      applications?: {
        applicationInfo?: [ 
        {
          name?: string(name='Name'),
          required?: boolean(name='Required'),
          tag?: string(name='Tag'),
          version?: string(name='Version'),
        }
      ](name='ApplicationInfo')
      }(name='Applications'),
      ehpcVersion?: string(name='EhpcVersion'),
      osTag?: string(name='OsTag'),
      schedulerType?: string(name='SchedulerType'),
      schedulerVersion?: string(name='SchedulerVersion'),
    }
  ](name='SoftwareInfo')
  }(name='Softwares'),
}

model ListSoftwaresResponse = {
  headers: map[string]string(name='headers'),
  body: ListSoftwaresResponseBody(name='body'),
}

async function listSoftwaresWithOptions(request: ListSoftwaresRequest, runtime: Util.RuntimeOptions): ListSoftwaresResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSoftwares',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSoftwares(request: ListSoftwaresRequest): ListSoftwaresResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSoftwaresWithOptions(request, runtime);
}

model ListTasksRequest {
  archived?: boolean(name='Archived'),
  clusterId?: string(name='ClusterId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  taskId?: string(name='TaskId'),
}

model ListTasksResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  tasks?: [ 
    {
      clusterId?: string(name='ClusterId'),
      currentStep?: int32(name='CurrentStep'),
      errors?: string(name='Errors'),
      request?: string(name='Request'),
      result?: string(name='Result'),
      status?: string(name='Status'),
      taskId?: string(name='TaskId'),
      taskType?: string(name='TaskType'),
      totalSteps?: int32(name='TotalSteps'),
    }
  ](name='Tasks'),
  totalCount?: int32(name='TotalCount'),
}

model ListTasksResponse = {
  headers: map[string]string(name='headers'),
  body: ListTasksResponseBody(name='body'),
}

async function listTasksWithOptions(request: ListTasksRequest, runtime: Util.RuntimeOptions): ListTasksResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTasks',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTasks(request: ListTasksRequest): ListTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTasksWithOptions(request, runtime);
}

model ListUsersRequest {
  clusterId?: string(name='ClusterId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListUsersResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  users?: {
    userInfo?: [ 
    {
      addTime?: string(name='AddTime'),
      group?: string(name='Group'),
      name?: string(name='Name'),
    }
  ](name='UserInfo')
  }(name='Users'),
}

model ListUsersResponse = {
  headers: map[string]string(name='headers'),
  body: ListUsersResponseBody(name='body'),
}

async function listUsersWithOptions(request: ListUsersRequest, runtime: Util.RuntimeOptions): ListUsersResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUsers',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listUsers(request: ListUsersRequest): ListUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUsersWithOptions(request, runtime);
}

model ListVolumesRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListVolumesResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  volumes?: {
    volumeInfo?: [ 
    {
      additionalVolumes?: {
        volumeInfo?: [ 
        {
          jobQueue?: string(name='JobQueue'),
          localDirectory?: string(name='LocalDirectory'),
          location?: string(name='Location'),
          remoteDirectory?: string(name='RemoteDirectory'),
          role?: string(name='Role'),
          volumeId?: string(name='VolumeId'),
          volumeMountpoint?: string(name='VolumeMountpoint'),
          volumeProtocol?: string(name='VolumeProtocol'),
          volumeType?: string(name='VolumeType'),
        }
      ](name='VolumeInfo')
      }(name='AdditionalVolumes'),
      clusterId?: string(name='ClusterId'),
      clusterName?: string(name='ClusterName'),
      regionId?: string(name='RegionId'),
      remoteDirectory?: string(name='RemoteDirectory'),
      volumeId?: string(name='VolumeId'),
      volumeMountpoint?: string(name='VolumeMountpoint'),
      volumeProtocol?: string(name='VolumeProtocol'),
      volumeType?: string(name='VolumeType'),
    }
  ](name='VolumeInfo')
  }(name='Volumes'),
}

model ListVolumesResponse = {
  headers: map[string]string(name='headers'),
  body: ListVolumesResponseBody(name='body'),
}

async function listVolumesWithOptions(request: ListVolumesRequest, runtime: Util.RuntimeOptions): ListVolumesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListVolumes',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listVolumes(request: ListVolumesRequest): ListVolumesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVolumesWithOptions(request, runtime);
}

model ModifyClusterAttributesRequest {
  clusterId?: string(name='ClusterId'),
  description?: string(name='Description'),
  imageId?: string(name='ImageId'),
  imageOwnerAlias?: string(name='ImageOwnerAlias'),
  name?: string(name='Name'),
}

model ModifyClusterAttributesResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyClusterAttributesResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyClusterAttributesResponseBody(name='body'),
}

async function modifyClusterAttributesWithOptions(request: ModifyClusterAttributesRequest, runtime: Util.RuntimeOptions): ModifyClusterAttributesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyClusterAttributes',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyClusterAttributes(request: ModifyClusterAttributesRequest): ModifyClusterAttributesResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyClusterAttributesWithOptions(request, runtime);
}

model ModifyContainerAppAttributesRequest {
  containerId?: string(name='ContainerId'),
  description?: string(name='Description'),
}

model ModifyContainerAppAttributesResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyContainerAppAttributesResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyContainerAppAttributesResponseBody(name='body'),
}

async function modifyContainerAppAttributesWithOptions(request: ModifyContainerAppAttributesRequest, runtime: Util.RuntimeOptions): ModifyContainerAppAttributesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyContainerAppAttributes',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyContainerAppAttributes(request: ModifyContainerAppAttributesRequest): ModifyContainerAppAttributesResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyContainerAppAttributesWithOptions(request, runtime);
}

model ModifyImageGatewayConfigRequest {
  clusterId?: string(name='ClusterId'),
  DBPassword?: string(name='DBPassword'),
  DBServerInfo?: string(name='DBServerInfo'),
  DBType?: string(name='DBType'),
  DBUsername?: string(name='DBUsername'),
  defaultRepoLocation?: string(name='DefaultRepoLocation'),
  imageExpirationTimeout?: string(name='ImageExpirationTimeout'),
  pullUpdateTimeout?: int32(name='PullUpdateTimeout'),
  repo?: [ 
    {
      auth?: string(name='Auth'),
      location?: string(name='Location'),
      URL?: string(name='URL'),
    }
  ](name='Repo'),
}

model ModifyImageGatewayConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyImageGatewayConfigResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyImageGatewayConfigResponseBody(name='body'),
}

async function modifyImageGatewayConfigWithOptions(request: ModifyImageGatewayConfigRequest, runtime: Util.RuntimeOptions): ModifyImageGatewayConfigResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyImageGatewayConfig',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyImageGatewayConfig(request: ModifyImageGatewayConfigRequest): ModifyImageGatewayConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyImageGatewayConfigWithOptions(request, runtime);
}

model ModifyUserGroupsRequest {
  clusterId?: string(name='ClusterId'),
  user?: [ 
    {
      group?: string(name='Group'),
      name?: string(name='Name'),
    }
  ](name='User'),
}

model ModifyUserGroupsResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyUserGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyUserGroupsResponseBody(name='body'),
}

async function modifyUserGroupsWithOptions(request: ModifyUserGroupsRequest, runtime: Util.RuntimeOptions): ModifyUserGroupsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyUserGroups',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyUserGroups(request: ModifyUserGroupsRequest): ModifyUserGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyUserGroupsWithOptions(request, runtime);
}

model ModifyUserPasswordsRequest {
  clusterId?: string(name='ClusterId'),
  user?: [ 
    {
      name?: string(name='Name'),
      password?: string(name='Password'),
    }
  ](name='User'),
}

model ModifyUserPasswordsResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyUserPasswordsResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyUserPasswordsResponseBody(name='body'),
}

async function modifyUserPasswordsWithOptions(request: ModifyUserPasswordsRequest, runtime: Util.RuntimeOptions): ModifyUserPasswordsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyUserPasswords',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyUserPasswords(request: ModifyUserPasswordsRequest): ModifyUserPasswordsResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyUserPasswordsWithOptions(request, runtime);
}

model ModifyVisualServicePasswdRequest {
  clusterId?: string(name='ClusterId'),
  passwd?: string(name='Passwd'),
  runasUser?: string(name='RunasUser'),
  runasUserPassword?: string(name='RunasUserPassword'),
}

model ModifyVisualServicePasswdResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ModifyVisualServicePasswdResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyVisualServicePasswdResponseBody(name='body'),
}

async function modifyVisualServicePasswdWithOptions(request: ModifyVisualServicePasswdRequest, runtime: Util.RuntimeOptions): ModifyVisualServicePasswdResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyVisualServicePasswd',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyVisualServicePasswd(request: ModifyVisualServicePasswdRequest): ModifyVisualServicePasswdResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyVisualServicePasswdWithOptions(request, runtime);
}

model MountNFSRequest {
  instanceId?: string(name='InstanceId'),
  mountDir?: string(name='MountDir'),
  nfsDir?: string(name='NfsDir'),
  protocolType?: string(name='ProtocolType'),
  remoteDir?: string(name='RemoteDir'),
}

model MountNFSResponseBody = {
  invokeId?: string(name='InvokeId'),
  requestId?: string(name='RequestId'),
}

model MountNFSResponse = {
  headers: map[string]string(name='headers'),
  body: MountNFSResponseBody(name='body'),
}

async function mountNFSWithOptions(request: MountNFSRequest, runtime: Util.RuntimeOptions): MountNFSResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'MountNFS',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function mountNFS(request: MountNFSRequest): MountNFSResponse {
  var runtime = new Util.RuntimeOptions{};
  return mountNFSWithOptions(request, runtime);
}

model PullImageRequest {
  clusterId?: string(name='ClusterId'),
  containerType?: string(name='ContainerType'),
  imageTag?: string(name='ImageTag'),
  repository?: string(name='Repository'),
}

model PullImageResponseBody = {
  requestId?: string(name='RequestId'),
}

model PullImageResponse = {
  headers: map[string]string(name='headers'),
  body: PullImageResponseBody(name='body'),
}

async function pullImageWithOptions(request: PullImageRequest, runtime: Util.RuntimeOptions): PullImageResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PullImage',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function pullImage(request: PullImageRequest): PullImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return pullImageWithOptions(request, runtime);
}

model QueryServicePackAndPriceResponseBody = {
  chargeAmount?: int32(name='ChargeAmount'),
  currency?: string(name='Currency'),
  discountPrice?: float(name='DiscountPrice'),
  originalAmount?: int32(name='OriginalAmount'),
  originalPrice?: float(name='OriginalPrice'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  servicePack?: {
    servicePackInfo?: [ 
    {
      capacity?: int32(name='Capacity'),
      endTime?: int32(name='EndTime'),
      instanceName?: string(name='InstanceName'),
      startTime?: int32(name='StartTime'),
    }
  ](name='ServicePackInfo')
  }(name='ServicePack'),
  tradePrice?: float(name='TradePrice'),
}

model QueryServicePackAndPriceResponse = {
  headers: map[string]string(name='headers'),
  body: QueryServicePackAndPriceResponseBody(name='body'),
}

async function queryServicePackAndPriceWithOptions(runtime: Util.RuntimeOptions): QueryServicePackAndPriceResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'QueryServicePackAndPrice',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryServicePackAndPrice(): QueryServicePackAndPriceResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryServicePackAndPriceWithOptions(runtime);
}

model RecoverClusterRequest {
  accountType?: string(name='AccountType'),
  clientVersion?: string(name='ClientVersion'),
  clusterId?: string(name='ClusterId'),
  imageId?: string(name='ImageId'),
  imageOwnerAlias?: string(name='ImageOwnerAlias'),
  osTag?: string(name='OsTag'),
  schedulerType?: string(name='SchedulerType'),
}

model RecoverClusterResponseBody = {
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model RecoverClusterResponse = {
  headers: map[string]string(name='headers'),
  body: RecoverClusterResponseBody(name='body'),
}

async function recoverClusterWithOptions(request: RecoverClusterRequest, runtime: Util.RuntimeOptions): RecoverClusterResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RecoverCluster',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function recoverCluster(request: RecoverClusterRequest): RecoverClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return recoverClusterWithOptions(request, runtime);
}

model RerunJobsRequest {
  clusterId?: string(name='ClusterId'),
  jobs?: string(name='Jobs'),
}

model RerunJobsResponseBody = {
  requestId?: string(name='RequestId'),
}

model RerunJobsResponse = {
  headers: map[string]string(name='headers'),
  body: RerunJobsResponseBody(name='body'),
}

async function rerunJobsWithOptions(request: RerunJobsRequest, runtime: Util.RuntimeOptions): RerunJobsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RerunJobs',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function rerunJobs(request: RerunJobsRequest): RerunJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return rerunJobsWithOptions(request, runtime);
}

model ResetNodesRequest {
  clusterId?: string(name='ClusterId'),
  instance?: [ 
    {
      id?: string(name='Id'),
    }
  ](name='Instance'),
}

model ResetNodesResponseBody = {
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model ResetNodesResponse = {
  headers: map[string]string(name='headers'),
  body: ResetNodesResponseBody(name='body'),
}

async function resetNodesWithOptions(request: ResetNodesRequest, runtime: Util.RuntimeOptions): ResetNodesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResetNodes',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function resetNodes(request: ResetNodesRequest): ResetNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return resetNodesWithOptions(request, runtime);
}

model RunCloudMetricProfilingRequest {
  clusterId?: string(name='ClusterId'),
  duration?: int32(name='Duration'),
  freq?: int32(name='Freq'),
  hostName?: string(name='HostName'),
  processId?: int32(name='ProcessId'),
  regionId?: string(name='RegionId'),
}

model RunCloudMetricProfilingResponseBody = {
  requestId?: string(name='RequestId'),
}

model RunCloudMetricProfilingResponse = {
  headers: map[string]string(name='headers'),
  body: RunCloudMetricProfilingResponseBody(name='body'),
}

async function runCloudMetricProfilingWithOptions(request: RunCloudMetricProfilingRequest, runtime: Util.RuntimeOptions): RunCloudMetricProfilingResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RunCloudMetricProfiling',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function runCloudMetricProfiling(request: RunCloudMetricProfilingRequest): RunCloudMetricProfilingResponse {
  var runtime = new Util.RuntimeOptions{};
  return runCloudMetricProfilingWithOptions(request, runtime);
}

model SetAutoScaleConfigRequest {
  clusterId?: string(name='ClusterId'),
  enableAutoGrow?: boolean(name='EnableAutoGrow'),
  enableAutoShrink?: boolean(name='EnableAutoShrink'),
  excludeNodes?: string(name='ExcludeNodes'),
  extraNodesGrowRatio?: int32(name='ExtraNodesGrowRatio'),
  growIntervalInMinutes?: int32(name='GrowIntervalInMinutes'),
  growRatio?: int32(name='GrowRatio'),
  growTimeoutInMinutes?: int32(name='GrowTimeoutInMinutes'),
  imageId?: string(name='ImageId'),
  maxNodesInCluster?: int32(name='MaxNodesInCluster'),
  queues?: [ 
    {
      dataDisks?: [ 
        {
          dataDiskCategory?: string(name='DataDiskCategory'),
          dataDiskDeleteWithInstance?: boolean(name='DataDiskDeleteWithInstance'),
          dataDiskEncrypted?: boolean(name='DataDiskEncrypted'),
          dataDiskKMSKeyId?: string(name='DataDiskKMSKeyId'),
          dataDiskPerformanceLevel?: string(name='DataDiskPerformanceLevel'),
          dataDiskSize?: int32(name='DataDiskSize'),
        }
      ](name='DataDisks'),
      enableAutoGrow?: boolean(name='EnableAutoGrow'),
      enableAutoShrink?: boolean(name='EnableAutoShrink'),
      hostNamePrefix?: string(name='HostNamePrefix'),
      hostNameSuffix?: string(name='HostNameSuffix'),
      instanceType?: string(name='InstanceType'),
      instanceTypes?: [ 
        {
          instanceType?: string(name='InstanceType'),
          spotPriceLimit?: float(name='SpotPriceLimit'),
          spotStrategy?: string(name='SpotStrategy'),
          vSwitchId?: string(name='VSwitchId'),
          zoneId?: string(name='ZoneId'),
        }
      ](name='InstanceTypes'),
      maxNodesInQueue?: int32(name='MaxNodesInQueue'),
      minNodesInQueue?: int32(name='MinNodesInQueue'),
      queueImageId?: string(name='QueueImageId'),
      queueName?: string(name='QueueName'),
      spotPriceLimit?: float(name='SpotPriceLimit'),
      spotStrategy?: string(name='SpotStrategy'),
      systemDiskCategory?: string(name='SystemDiskCategory'),
      systemDiskLevel?: string(name='SystemDiskLevel'),
      systemDiskSize?: int32(name='SystemDiskSize'),
    }
  ](name='Queues'),
  shrinkIdleTimes?: int32(name='ShrinkIdleTimes'),
  shrinkIntervalInMinutes?: int32(name='ShrinkIntervalInMinutes'),
  spotPriceLimit?: float(name='SpotPriceLimit'),
  spotStrategy?: string(name='SpotStrategy'),
}

model SetAutoScaleConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetAutoScaleConfigResponse = {
  headers: map[string]string(name='headers'),
  body: SetAutoScaleConfigResponseBody(name='body'),
}

async function setAutoScaleConfigWithOptions(request: SetAutoScaleConfigRequest, runtime: Util.RuntimeOptions): SetAutoScaleConfigResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetAutoScaleConfig',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setAutoScaleConfig(request: SetAutoScaleConfigRequest): SetAutoScaleConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return setAutoScaleConfigWithOptions(request, runtime);
}

model SetGWSClusterPolicyRequest {
  asyncMode?: boolean(name='AsyncMode'),
  clipboard?: string(name='Clipboard'),
  clusterId?: string(name='ClusterId'),
  localDrive?: string(name='LocalDrive'),
  udpPort?: string(name='UdpPort'),
  usbRedirect?: string(name='UsbRedirect'),
  watermark?: string(name='Watermark'),
}

model SetGWSClusterPolicyResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetGWSClusterPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: SetGWSClusterPolicyResponseBody(name='body'),
}

async function setGWSClusterPolicyWithOptions(request: SetGWSClusterPolicyRequest, runtime: Util.RuntimeOptions): SetGWSClusterPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.asyncMode)) {
    query['AsyncMode'] = request.asyncMode;
  }
  if (!Util.isUnset(request.clipboard)) {
    query['Clipboard'] = request.clipboard;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.localDrive)) {
    query['LocalDrive'] = request.localDrive;
  }
  if (!Util.isUnset(request.udpPort)) {
    query['UdpPort'] = request.udpPort;
  }
  if (!Util.isUnset(request.usbRedirect)) {
    query['UsbRedirect'] = request.usbRedirect;
  }
  if (!Util.isUnset(request.watermark)) {
    query['Watermark'] = request.watermark;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetGWSClusterPolicy',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setGWSClusterPolicy(request: SetGWSClusterPolicyRequest): SetGWSClusterPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return setGWSClusterPolicyWithOptions(request, runtime);
}

model SetGWSInstanceNameRequest {
  instanceId?: string(name='InstanceId'),
  name?: string(name='Name'),
}

model SetGWSInstanceNameResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetGWSInstanceNameResponse = {
  headers: map[string]string(name='headers'),
  body: SetGWSInstanceNameResponseBody(name='body'),
}

async function setGWSInstanceNameWithOptions(request: SetGWSInstanceNameRequest, runtime: Util.RuntimeOptions): SetGWSInstanceNameResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetGWSInstanceName',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setGWSInstanceName(request: SetGWSInstanceNameRequest): SetGWSInstanceNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return setGWSInstanceNameWithOptions(request, runtime);
}

model SetGWSInstanceUserRequest {
  instanceId?: string(name='InstanceId'),
  userName?: string(name='UserName'),
  userUid?: string(name='UserUid'),
}

model SetGWSInstanceUserResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetGWSInstanceUserResponse = {
  headers: map[string]string(name='headers'),
  body: SetGWSInstanceUserResponseBody(name='body'),
}

async function setGWSInstanceUserWithOptions(request: SetGWSInstanceUserRequest, runtime: Util.RuntimeOptions): SetGWSInstanceUserResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetGWSInstanceUser',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setGWSInstanceUser(request: SetGWSInstanceUserRequest): SetGWSInstanceUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return setGWSInstanceUserWithOptions(request, runtime);
}

model SetQueueRequest {
  clusterId?: string(name='ClusterId'),
  node?: [ 
    {
      name?: string(name='Name'),
    }
  ](name='Node'),
  queueName?: string(name='QueueName'),
}

model SetQueueResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetQueueResponse = {
  headers: map[string]string(name='headers'),
  body: SetQueueResponseBody(name='body'),
}

async function setQueueWithOptions(request: SetQueueRequest, runtime: Util.RuntimeOptions): SetQueueResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetQueue',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setQueue(request: SetQueueRequest): SetQueueResponse {
  var runtime = new Util.RuntimeOptions{};
  return setQueueWithOptions(request, runtime);
}

model SetSchedulerInfoRequest {
  clusterId?: string(name='ClusterId'),
  pbsInfo?: [ 
    {
      aclLimit?: [ 
        {
          aclUsers?: string(name='AclUsers'),
          queue?: string(name='Queue'),
        }
      ](name='AclLimit'),
      jobHistoryDuration?: int32(name='JobHistoryDuration'),
      resourceLimit?: [ 
        {
          cpus?: int32(name='Cpus'),
          mem?: string(name='Mem'),
          nodes?: int32(name='Nodes'),
          queue?: string(name='Queue'),
          user?: string(name='User'),
        }
      ](name='ResourceLimit'),
      schedInterval?: int32(name='SchedInterval'),
    }
  ](name='PbsInfo'),
  regionId?: string(name='RegionId'),
  scheduler?: [ 
    {
      schedName?: string(name='SchedName'),
    }
  ](name='Scheduler'),
  slurmInfo?: [ 
    {
      backfillInterval?: int32(name='BackfillInterval'),
      schedInterval?: int32(name='SchedInterval'),
    }
  ](name='SlurmInfo'),
}

model SetSchedulerInfoResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model SetSchedulerInfoResponse = {
  headers: map[string]string(name='headers'),
  body: SetSchedulerInfoResponseBody(name='body'),
}

async function setSchedulerInfoWithOptions(request: SetSchedulerInfoRequest, runtime: Util.RuntimeOptions): SetSchedulerInfoResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetSchedulerInfo',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setSchedulerInfo(request: SetSchedulerInfoRequest): SetSchedulerInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return setSchedulerInfoWithOptions(request, runtime);
}

model StartClusterRequest {
  clusterId?: string(name='ClusterId'),
}

model StartClusterResponseBody = {
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model StartClusterResponse = {
  headers: map[string]string(name='headers'),
  body: StartClusterResponseBody(name='body'),
}

async function startClusterWithOptions(request: StartClusterRequest, runtime: Util.RuntimeOptions): StartClusterResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartCluster',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startCluster(request: StartClusterRequest): StartClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return startClusterWithOptions(request, runtime);
}

model StartGWSInstanceRequest {
  instanceId?: string(name='InstanceId'),
}

model StartGWSInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model StartGWSInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: StartGWSInstanceResponseBody(name='body'),
}

async function startGWSInstanceWithOptions(request: StartGWSInstanceRequest, runtime: Util.RuntimeOptions): StartGWSInstanceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartGWSInstance',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startGWSInstance(request: StartGWSInstanceRequest): StartGWSInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return startGWSInstanceWithOptions(request, runtime);
}

model StartNodesRequest {
  clusterId?: string(name='ClusterId'),
  instance?: [ 
    {
      id?: string(name='Id'),
    }
  ](name='Instance'),
  role?: string(name='Role'),
}

model StartNodesResponseBody = {
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model StartNodesResponse = {
  headers: map[string]string(name='headers'),
  body: StartNodesResponseBody(name='body'),
}

async function startNodesWithOptions(request: StartNodesRequest, runtime: Util.RuntimeOptions): StartNodesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartNodes',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startNodes(request: StartNodesRequest): StartNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return startNodesWithOptions(request, runtime);
}

model StartVisualServiceRequest {
  cidrIp?: string(name='CidrIp'),
  clusterId?: string(name='ClusterId'),
  port?: int32(name='Port'),
}

model StartVisualServiceResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model StartVisualServiceResponse = {
  headers: map[string]string(name='headers'),
  body: StartVisualServiceResponseBody(name='body'),
}

async function startVisualServiceWithOptions(request: StartVisualServiceRequest, runtime: Util.RuntimeOptions): StartVisualServiceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartVisualService',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startVisualService(request: StartVisualServiceRequest): StartVisualServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return startVisualServiceWithOptions(request, runtime);
}

model StopClusterRequest {
  clusterId?: string(name='ClusterId'),
}

model StopClusterResponseBody = {
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model StopClusterResponse = {
  headers: map[string]string(name='headers'),
  body: StopClusterResponseBody(name='body'),
}

async function stopClusterWithOptions(request: StopClusterRequest, runtime: Util.RuntimeOptions): StopClusterResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopCluster',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopCluster(request: StopClusterRequest): StopClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopClusterWithOptions(request, runtime);
}

model StopGWSInstanceRequest {
  instanceId?: string(name='InstanceId'),
}

model StopGWSInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model StopGWSInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: StopGWSInstanceResponseBody(name='body'),
}

async function stopGWSInstanceWithOptions(request: StopGWSInstanceRequest, runtime: Util.RuntimeOptions): StopGWSInstanceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopGWSInstance',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopGWSInstance(request: StopGWSInstanceRequest): StopGWSInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopGWSInstanceWithOptions(request, runtime);
}

model StopJobsRequest {
  clusterId?: string(name='ClusterId'),
  jobs?: string(name='Jobs'),
}

model StopJobsResponseBody = {
  requestId?: string(name='RequestId'),
}

model StopJobsResponse = {
  headers: map[string]string(name='headers'),
  body: StopJobsResponseBody(name='body'),
}

async function stopJobsWithOptions(request: StopJobsRequest, runtime: Util.RuntimeOptions): StopJobsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopJobs',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopJobs(request: StopJobsRequest): StopJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopJobsWithOptions(request, runtime);
}

model StopNodesRequest {
  clusterId?: string(name='ClusterId'),
  instance?: [ 
    {
      id?: string(name='Id'),
    }
  ](name='Instance'),
  role?: string(name='Role'),
}

model StopNodesResponseBody = {
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model StopNodesResponse = {
  headers: map[string]string(name='headers'),
  body: StopNodesResponseBody(name='body'),
}

async function stopNodesWithOptions(request: StopNodesRequest, runtime: Util.RuntimeOptions): StopNodesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopNodes',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopNodes(request: StopNodesRequest): StopNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopNodesWithOptions(request, runtime);
}

model StopVisualServiceRequest {
  cidrIp?: string(name='CidrIp'),
  clusterId?: string(name='ClusterId'),
  port?: int32(name='Port'),
}

model StopVisualServiceResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model StopVisualServiceResponse = {
  headers: map[string]string(name='headers'),
  body: StopVisualServiceResponseBody(name='body'),
}

async function stopVisualServiceWithOptions(request: StopVisualServiceRequest, runtime: Util.RuntimeOptions): StopVisualServiceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopVisualService',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopVisualService(request: StopVisualServiceRequest): StopVisualServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopVisualServiceWithOptions(request, runtime);
}

model SubmitJobRequest {
  arrayRequest?: string(name='ArrayRequest'),
  clockTime?: string(name='ClockTime'),
  clusterId?: string(name='ClusterId'),
  commandLine?: string(name='CommandLine'),
  containerId?: string(name='ContainerId'),
  gpu?: int32(name='Gpu'),
  inputFileUrl?: string(name='InputFileUrl'),
  jobQueue?: string(name='JobQueue'),
  mem?: string(name='Mem'),
  name?: string(name='Name'),
  node?: int32(name='Node'),
  packagePath?: string(name='PackagePath'),
  postCmdLine?: string(name='PostCmdLine'),
  priority?: int32(name='Priority'),
  reRunable?: boolean(name='ReRunable'),
  runasUser?: string(name='RunasUser'),
  runasUserPassword?: string(name='RunasUserPassword'),
  stderrRedirectPath?: string(name='StderrRedirectPath'),
  stdoutRedirectPath?: string(name='StdoutRedirectPath'),
  task?: int32(name='Task'),
  thread?: int32(name='Thread'),
  unzipCmd?: string(name='UnzipCmd'),
  variables?: string(name='Variables'),
}

model SubmitJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model SubmitJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitJobResponseBody(name='body'),
}

async function submitJobWithOptions(request: SubmitJobRequest, runtime: Util.RuntimeOptions): SubmitJobResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitJob',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitJob(request: SubmitJobRequest): SubmitJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitJobWithOptions(request, runtime);
}

model SyncUsersRequest {
  clusterId?: string(name='ClusterId'),
  regionId?: string(name='RegionId'),
}

model SyncUsersResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model SyncUsersResponse = {
  headers: map[string]string(name='headers'),
  body: SyncUsersResponseBody(name='body'),
}

async function syncUsersWithOptions(request: SyncUsersRequest, runtime: Util.RuntimeOptions): SyncUsersResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SyncUsers',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function syncUsers(request: SyncUsersRequest): SyncUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return syncUsersWithOptions(request, runtime);
}

model UninstallSoftwareRequest {
  application?: string(name='Application'),
  clusterId?: string(name='ClusterId'),
}

model UninstallSoftwareResponseBody = {
  requestId?: string(name='RequestId'),
}

model UninstallSoftwareResponse = {
  headers: map[string]string(name='headers'),
  body: UninstallSoftwareResponseBody(name='body'),
}

async function uninstallSoftwareWithOptions(request: UninstallSoftwareRequest, runtime: Util.RuntimeOptions): UninstallSoftwareResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UninstallSoftware',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function uninstallSoftware(request: UninstallSoftwareRequest): UninstallSoftwareResponse {
  var runtime = new Util.RuntimeOptions{};
  return uninstallSoftwareWithOptions(request, runtime);
}

model UpdateClusterVolumesRequest {
  additionalVolumes?: [ 
    {
      jobQueue?: string(name='JobQueue'),
      localDirectory?: string(name='LocalDirectory'),
      location?: string(name='Location'),
      remoteDirectory?: string(name='RemoteDirectory'),
      roles?: [ 
        {
          name?: string(name='Name'),
        }
      ](name='Roles'),
      volumeId?: string(name='VolumeId'),
      volumeMountpoint?: string(name='VolumeMountpoint'),
      volumeProtocol?: string(name='VolumeProtocol'),
      volumeType?: string(name='VolumeType'),
    }
  ](name='AdditionalVolumes'),
  clusterId?: string(name='ClusterId'),
}

model UpdateClusterVolumesResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateClusterVolumesResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateClusterVolumesResponseBody(name='body'),
}

async function updateClusterVolumesWithOptions(request: UpdateClusterVolumesRequest, runtime: Util.RuntimeOptions): UpdateClusterVolumesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateClusterVolumes',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateClusterVolumes(request: UpdateClusterVolumesRequest): UpdateClusterVolumesResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateClusterVolumesWithOptions(request, runtime);
}

model UpdateQueueConfigRequest {
  clusterId?: string(name='ClusterId'),
  computeInstanceType?: string(name='ComputeInstanceType'),
  queueName?: string(name='QueueName'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model UpdateQueueConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateQueueConfigResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateQueueConfigResponseBody(name='body'),
}

async function updateQueueConfigWithOptions(request: UpdateQueueConfigRequest, runtime: Util.RuntimeOptions): UpdateQueueConfigResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateQueueConfig',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateQueueConfig(request: UpdateQueueConfigRequest): UpdateQueueConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateQueueConfigWithOptions(request, runtime);
}

model UpgradeClientRequest {
  clientVersion?: string(name='ClientVersion'),
  clusterId?: string(name='ClusterId'),
}

model UpgradeClientResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpgradeClientResponse = {
  headers: map[string]string(name='headers'),
  body: UpgradeClientResponseBody(name='body'),
}

async function upgradeClientWithOptions(request: UpgradeClientRequest, runtime: Util.RuntimeOptions): UpgradeClientResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpgradeClient',
    version = '2018-04-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function upgradeClient(request: UpgradeClientRequest): UpgradeClientResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeClientWithOptions(request, runtime);
}

