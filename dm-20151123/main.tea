/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('dm', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AddIpfilterRequest {
  ipAddress?: string(name='IpAddress', description='IP Address/IP Range/IP Segment

This parameter is required.', example='xxx.xxx.xxx.xxx
xxx.xxx.xxx.xxx-xxx.xxx.xxx.xxx
xxx.xxx.xxx.xxx/xxx'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model AddIpfilterResponseBody = {
  ipFilterId?: string(name='IpFilterId', description='ID corresponding to the IP', example='10795'),
  requestId?: string(name='RequestId', description='Request ID', example='0E9282E8-DC08-5445-8FB0-B9F0CA28B249'),
}

model AddIpfilterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddIpfilterResponseBody(name='body'),
}

/**
 * @summary Add IP Protection Information
 *
 * @param request AddIpfilterRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddIpfilterResponse
 */
async function addIpfilterWithOptions(request: AddIpfilterRequest, runtime: Util.RuntimeOptions): AddIpfilterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ipAddress)) {
    query['IpAddress'] = request.ipAddress;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddIpfilter',
    version = '2015-11-23',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Add IP Protection Information
 *
 * @param request AddIpfilterRequest
 * @return AddIpfilterResponse
 */
async function addIpfilter(request: AddIpfilterRequest): AddIpfilterResponse {
  var runtime = new Util.RuntimeOptions{};
  return addIpfilterWithOptions(request, runtime);
}

model ApproveReplyMailAddressRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ticket?: string(name='Ticket', description='Email address Ticket credential, part of the string in the verification email\\\\"s URL.

This parameter is required.', example='a724068dac9a45d19574375adeca0d7d'),
}

model ApproveReplyMailAddressResponseBody = {
  requestId?: string(name='RequestId', description='Request ID', example='10A1AD70-E48E-476D-98D9-39BD92193837'),
}

model ApproveReplyMailAddressResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ApproveReplyMailAddressResponseBody(name='body'),
}

/**
 * @summary Verify Reply Address
 *
 * @param request ApproveReplyMailAddressRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ApproveReplyMailAddressResponse
 */
async function approveReplyMailAddressWithOptions(request: ApproveReplyMailAddressRequest, runtime: Util.RuntimeOptions): ApproveReplyMailAddressResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.ticket)) {
    query['Ticket'] = request.ticket;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ApproveReplyMailAddress',
    version = '2015-11-23',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Verify Reply Address
 *
 * @param request ApproveReplyMailAddressRequest
 * @return ApproveReplyMailAddressResponse
 */
async function approveReplyMailAddress(request: ApproveReplyMailAddressRequest): ApproveReplyMailAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return approveReplyMailAddressWithOptions(request, runtime);
}

model BatchSendMailRequest {
  accountName?: string(name='AccountName', description='The sending address configured in the management console.

This parameter is required.', example='test@example.com'),
  addressType?: int32(name='AddressType', description='- 0: Random account
- 1: Sending address

This parameter is required.', example='1'),
  clickTrace?: string(name='ClickTrace', description='- 1: Enable data tracking function
- 0 (default): Disable data tracking function', example='0'),
  headers?: string(name='Headers', description='Currently, the standard fields that can be added to the email header are Message-ID, List-Unsubscribe, and List-Unsubscribe-Post. Standard fields will overwrite the existing values in the email header, while non-standard fields need to start with X-User- and will be appended to the email header. Currently, up to 10 headers can be passed in JSON format, and both standard and non-standard fields must comply with the syntax requirements for headers.', example='{
  "Message-ID": "<msg0001@example.com>",
  "X-User-UID1": "UID-1-000001",
  "X-User-UID2": "UID-2-000001"
}'),
  ipPoolId?: string(name='IpPoolId'),
  ownerId?: long(name='OwnerId'),
  receiversName?: string(name='ReceiversName', description='The name of the recipient list that has been created and uploaded. Note: The recipient list should not be deleted until at least 10 minutes after the task is triggered, otherwise it may cause sending failure.

This parameter is required.', example='test2'),
  replyAddress?: string(name='ReplyAddress', description='Reply address', example='test2***@example.net'),
  replyAddressAlias?: string(name='ReplyAddressAlias', description='Alias for the reply address', example='Lucy'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  tagName?: string(name='TagName', description='Email tag name.', example='test3'),
  templateName?: string(name='TemplateName', description='The name of a pre-created and approved template.

This parameter is required.', example='test1'),
  unSubscribeFilterLevel?: string(name='UnSubscribeFilterLevel', description='Filter level. Refer to the [Unsubscribe Function Link Generation and Filtering Mechanism](https://help.aliyun.com/document_detail/2689048.html) document.
- disabled: No filtering
- default: Use the default strategy, bulk addresses use sender address level filtering
- mailfrom: Sender address level filtering
- mailfrom_domain: Sender domain level filtering
- edm_id: Account level filtering', example='mailfrom_domain'),
  unSubscribeLinkType?: string(name='UnSubscribeLinkType', description='Type of generated unsubscribe link. Refer to the [Unsubscribe Function Link Generation and Filtering Mechanism](https://help.aliyun.com/document_detail/2689048.html) document.
- disabled: Not generated
- default: Use the default strategy: Generate an unsubscribe link when sending from a bulk email address to specific domains, such as those containing keywords like "gmail", "yahoo",
"google", "aol.com", "hotmail",
"outlook", "ymail.com", etc.
- zh-cn: Generated, for future content preparation
- en-us: Generated, for future content preparation', example='default'),
}

model BatchSendMailResponseBody = {
  envId?: string(name='EnvId', description='Event ID', example='600000136562052858'),
  requestId?: string(name='RequestId', description='Request ID', example='12D086F6-8F31-4658-84C1-006DED011A85'),
}

model BatchSendMailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchSendMailResponseBody(name='body'),
}

/**
 * @summary Batch Send Emails
 *
 * @param request BatchSendMailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchSendMailResponse
 */
async function batchSendMailWithOptions(request: BatchSendMailRequest, runtime: Util.RuntimeOptions): BatchSendMailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.addressType)) {
    query['AddressType'] = request.addressType;
  }
  if (!Util.isUnset(request.clickTrace)) {
    query['ClickTrace'] = request.clickTrace;
  }
  if (!Util.isUnset(request.headers)) {
    query['Headers'] = request.headers;
  }
  if (!Util.isUnset(request.ipPoolId)) {
    query['IpPoolId'] = request.ipPoolId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.receiversName)) {
    query['ReceiversName'] = request.receiversName;
  }
  if (!Util.isUnset(request.replyAddress)) {
    query['ReplyAddress'] = request.replyAddress;
  }
  if (!Util.isUnset(request.replyAddressAlias)) {
    query['ReplyAddressAlias'] = request.replyAddressAlias;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.tagName)) {
    query['TagName'] = request.tagName;
  }
  if (!Util.isUnset(request.templateName)) {
    query['TemplateName'] = request.templateName;
  }
  if (!Util.isUnset(request.unSubscribeFilterLevel)) {
    query['UnSubscribeFilterLevel'] = request.unSubscribeFilterLevel;
  }
  if (!Util.isUnset(request.unSubscribeLinkType)) {
    query['UnSubscribeLinkType'] = request.unSubscribeLinkType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BatchSendMail',
    version = '2015-11-23',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Batch Send Emails
 *
 * @param request BatchSendMailRequest
 * @return BatchSendMailResponse
 */
async function batchSendMail(request: BatchSendMailRequest): BatchSendMailResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchSendMailWithOptions(request, runtime);
}

model CheckDomainRequest {
  domainId?: int32(name='DomainId', description='Domain ID.

This parameter is required.', example='153345'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CheckDomainResponseBody = {
  domainStatus?: int32(name='DomainStatus', description='Domain status. Indicates whether the verification was successful, with values as follows:

- **0**: Available, verified successfully
- **1**: Unavailable, verification failed', example='1'),
  requestId?: string(name='RequestId', description='Request ID', example='F0B82E83-A1D9-4FE6-97D2-F4B231F80B02'),
}

model CheckDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CheckDomainResponseBody(name='body'),
}

/**
 * @summary Check Domain Status
 *
 * @param request CheckDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CheckDomainResponse
 */
async function checkDomainWithOptions(request: CheckDomainRequest, runtime: Util.RuntimeOptions): CheckDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainId)) {
    query['DomainId'] = request.domainId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckDomain',
    version = '2015-11-23',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Check Domain Status
 *
 * @param request CheckDomainRequest
 * @return CheckDomainResponse
 */
async function checkDomain(request: CheckDomainRequest): CheckDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkDomainWithOptions(request, runtime);
}

model CheckReplyToMailAddressRequest {
  lang?: string(name='Lang', description='Language.

en is English, and any other value or an empty value defaults to Chinese.', example='无'),
  mailAddressId?: int32(name='MailAddressId', description='Sender Address ID

This parameter is required.', example='126545'),
  ownerId?: long(name='OwnerId'),
  region?: string(name='Region', description='Region', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CheckReplyToMailAddressResponseBody = {
  requestId?: string(name='RequestId', description='Request ID', example='10A1AD70-E48E-476D-98D9-39BD92193837'),
}

model CheckReplyToMailAddressResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CheckReplyToMailAddressResponseBody(name='body'),
}

/**
 * @summary Validate Reply-To Address
 *
 * @param request CheckReplyToMailAddressRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CheckReplyToMailAddressResponse
 */
async function checkReplyToMailAddressWithOptions(request: CheckReplyToMailAddressRequest, runtime: Util.RuntimeOptions): CheckReplyToMailAddressResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.mailAddressId)) {
    query['MailAddressId'] = request.mailAddressId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckReplyToMailAddress',
    version = '2015-11-23',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Validate Reply-To Address
 *
 * @param request CheckReplyToMailAddressRequest
 * @return CheckReplyToMailAddressResponse
 */
async function checkReplyToMailAddress(request: CheckReplyToMailAddressRequest): CheckReplyToMailAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkReplyToMailAddressWithOptions(request, runtime);
}

model CreateDomainRequest {
  domainName?: string(name='DomainName', description='Domain name, length 1-50, can include numbers, uppercase letters, lowercase letters, ., and -.

This parameter is required.', example='sub.example.com'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  dkimSelector?: string(name='dkimSelector', description='The selector field in the DKIM protocol, used to identify a specific public key. It is recommended to leave it blank, as the system will automatically generate it based on cluster information. If the user specifies it manually, for example, if the sending domain is "sub.example.com" and dkimSelector is set to "default", then the host record will be "default._domainkey.sub"
Constraints: 
1. The length must not exceed 60 characters. 
2. It must consist of visible characters only. 
3. It cannot start with a hyphen (-). 
4. It cannot end with a hyphen (-). 
5. It cannot contain any of the following characters: _ :;/!*~.@#$%^&()+=[{]}|?<>,\\\\""', example='default'),
}

model CreateDomainResponseBody = {
  domainId?: string(name='DomainId', description='Domain ID', example='158910'),
  requestId?: string(name='RequestId', description='Request ID', example='B49AD828-25D1-488C-90B7-8853C1944486'),
}

model CreateDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDomainResponseBody(name='body'),
}

/**
 * @summary Create Domain
 *
 * @param request CreateDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDomainResponse
 */
async function createDomainWithOptions(request: CreateDomainRequest, runtime: Util.RuntimeOptions): CreateDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.dkimSelector)) {
    query['dkimSelector'] = request.dkimSelector;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDomain',
    version = '2015-11-23',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Create Domain
 *
 * @param request CreateDomainRequest
 * @return CreateDomainResponse
 */
async function createDomain(request: CreateDomainRequest): CreateDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDomainWithOptions(request, runtime);
}

model CreateMailAddressRequest {
  accountName?: string(name='AccountName', description='Sender\\\\"s email address

This parameter is required.', example='test1@example.com'),
  ownerId?: long(name='OwnerId'),
  replyAddress?: string(name='ReplyAddress', description='Reply-to address', example='test2@example.com'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sendtype?: string(name='Sendtype', description='Type of sending. Values:

- batch: Bulk emails

- trigger: Triggered emails

This parameter is required.', example='batch'),
}

model CreateMailAddressResponseBody = {
  mailAddressId?: string(name='MailAddressId', description='Mail address ID', example='15123'),
  requestId?: string(name='RequestId', description='Request ID', example='95A7D497-F8DD-4834-B81E-C1783236E55F'),
}

model CreateMailAddressResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMailAddressResponseBody(name='body'),
}

/**
 * @summary Create a mail address.
 *
 * @param request CreateMailAddressRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateMailAddressResponse
 */
async function createMailAddressWithOptions(request: CreateMailAddressRequest, runtime: Util.RuntimeOptions): CreateMailAddressResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.replyAddress)) {
    query['ReplyAddress'] = request.replyAddress;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sendtype)) {
    query['Sendtype'] = request.sendtype;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateMailAddress',
    version = '2015-11-23',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Create a mail address.
 *
 * @param request CreateMailAddressRequest
 * @return CreateMailAddressResponse
 */
async function createMailAddress(request: CreateMailAddressRequest): CreateMailAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMailAddressWithOptions(request, runtime);
}

model CreateReceiverRequest {
  desc?: string(name='Desc', description='List description.', example='the description'),
  ownerId?: long(name='OwnerId'),
  receiversAlias?: string(name='ReceiversAlias', description='List alias, an email address less than 30 characters long.

This parameter is required.', example='a***@example.net'),
  receiversName?: string(name='ReceiversName', description='List name, must be unique, with a length of 1-30 characters.

This parameter is required.', example='test'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateReceiverResponseBody = {
  receiverId?: string(name='ReceiverId', description='Receiver list ID', example='7312e09b8fffc5c7b2e2fbf5b6dc2073'),
  requestId?: string(name='RequestId', description='Request ID', example='10A1AD70-E48E-476D-98D9-39BD92193837'),
}

model CreateReceiverResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateReceiverResponseBody(name='body'),
}

/**
 * @summary Create Receiver List
 *
 * @param request CreateReceiverRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateReceiverResponse
 */
async function createReceiverWithOptions(request: CreateReceiverRequest, runtime: Util.RuntimeOptions): CreateReceiverResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.desc)) {
    query['Desc'] = request.desc;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.receiversAlias)) {
    query['ReceiversAlias'] = request.receiversAlias;
  }
  if (!Util.isUnset(request.receiversName)) {
    query['ReceiversName'] = request.receiversName;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateReceiver',
    version = '2015-11-23',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Create Receiver List
 *
 * @param request CreateReceiverRequest
 * @return CreateReceiverResponse
 */
async function createReceiver(request: CreateReceiverRequest): CreateReceiverResponse {
  var runtime = new Util.RuntimeOptions{};
  return createReceiverWithOptions(request, runtime);
}

model CreateTagRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  tagDescription?: string(name='TagDescription', description='Tag description', example='test description'),
  tagName?: string(name='TagName', description='Tag name. Limitations: 1-50 characters, allowing English letters, numbers, and underscores.

This parameter is required.', example='test'),
}

model CreateTagResponseBody = {
  requestId?: string(name='RequestId', description='Request ID', example='10A1AD70-E48E-476D-98D9-39BD92193837'),
  tagId?: string(name='TagId', description='Tag ID', example='91141'),
}

model CreateTagResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateTagResponseBody(name='body'),
}

/**
 * @summary Create Tag
 *
 * @param request CreateTagRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateTagResponse
 */
async function createTagWithOptions(request: CreateTagRequest, runtime: Util.RuntimeOptions): CreateTagResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.tagDescription)) {
    query['TagDescription'] = request.tagDescription;
  }
  if (!Util.isUnset(request.tagName)) {
    query['TagName'] = request.tagName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateTag',
    version = '2015-11-23',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Create Tag
 *
 * @param request CreateTagRequest
 * @return CreateTagResponse
 */
async function createTag(request: CreateTagRequest): CreateTagResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTagWithOptions(request, runtime);
}

model CreateUserSuppressionRequest {
  address?: string(name='Address', description='Email address or domain name', example='test@example.net'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateUserSuppressionResponseBody = {
  requestId?: string(name='RequestId', description='Request ID', example='1A846D66-5EC7-551B-9687-5BF1963DCFC1'),
  suppressionId?: string(name='SuppressionId', description='Invalid address number', example='59511'),
}

model CreateUserSuppressionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateUserSuppressionResponseBody(name='body'),
}

/**
 * @summary Create User\\"s Invalid Address
 *
 * @param request CreateUserSuppressionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateUserSuppressionResponse
 */
async function createUserSuppressionWithOptions(request: CreateUserSuppressionRequest, runtime: Util.RuntimeOptions): CreateUserSuppressionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.address)) {
    query['Address'] = request.address;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateUserSuppression',
    version = '2015-11-23',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Create User\\"s Invalid Address
 *
 * @param request CreateUserSuppressionRequest
 * @return CreateUserSuppressionResponse
 */
async function createUserSuppression(request: CreateUserSuppressionRequest): CreateUserSuppressionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createUserSuppressionWithOptions(request, runtime);
}

model DeleteDomainRequest {
  domainId?: int32(name='DomainId', description='Domain ID.

This parameter is required.', example='326***'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteDomainResponseBody = {
  requestId?: string(name='RequestId', description='Request ID.', example='E3DFF97B-00CF-5333-8125-3D6819471984'),
}

model DeleteDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDomainResponseBody(name='body'),
}

/**
 * @summary Delete Domain
 *
 * @param request DeleteDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDomainResponse
 */
async function deleteDomainWithOptions(request: DeleteDomainRequest, runtime: Util.RuntimeOptions): DeleteDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainId)) {
    query['DomainId'] = request.domainId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDomain',
    version = '2015-11-23',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Delete Domain
 *
 * @param request DeleteDomainRequest
 * @return DeleteDomainResponse
 */
async function deleteDomain(request: DeleteDomainRequest): DeleteDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDomainWithOptions(request, runtime);
}

model DeleteInvalidAddressRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  toAddress?: string(name='ToAddress', description='Target address', example='test1***@example.net'),
}

model DeleteInvalidAddressResponseBody = {
  requestId?: string(name='RequestId', description='Request ID', example='2D086F6-xxxx-xxxx-xxxx-006DED011A85'),
}

model DeleteInvalidAddressResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteInvalidAddressResponseBody(name='body'),
}

/**
 * @summary Remove invalid addresses from the invalid address database
 *
 * @param request DeleteInvalidAddressRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteInvalidAddressResponse
 */
async function deleteInvalidAddressWithOptions(request: DeleteInvalidAddressRequest, runtime: Util.RuntimeOptions): DeleteInvalidAddressResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.toAddress)) {
    query['ToAddress'] = request.toAddress;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteInvalidAddress',
    version = '2015-11-23',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Remove invalid addresses from the invalid address database
 *
 * @param request DeleteInvalidAddressRequest
 * @return DeleteInvalidAddressResponse
 */
async function deleteInvalidAddress(request: DeleteInvalidAddressRequest): DeleteInvalidAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteInvalidAddressWithOptions(request, runtime);
}

model DeleteIpfilterByEdmIdRequest {
  fromType?: int32(name='FromType', description='Deprecated, kept for historical compatibility.', example='1'),
  id?: string(name='Id', description='Record ID', example='10120'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteIpfilterByEdmIdResponseBody = {
  requestId?: string(name='RequestId', description='Request ID.', example='E3DFF97B-00CF-5333-8125-3D6819471984'),
}

model DeleteIpfilterByEdmIdResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteIpfilterByEdmIdResponseBody(name='body'),
}

/**
 * @summary Delete IP Protection Information
 *
 * @param request DeleteIpfilterByEdmIdRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteIpfilterByEdmIdResponse
 */
async function deleteIpfilterByEdmIdWithOptions(request: DeleteIpfilterByEdmIdRequest, runtime: Util.RuntimeOptions): DeleteIpfilterByEdmIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fromType)) {
    query['FromType'] = request.fromType;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteIpfilterByEdmId',
    version = '2015-11-23',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Delete IP Protection Information
 *
 * @param request DeleteIpfilterByEdmIdRequest
 * @return DeleteIpfilterByEdmIdResponse
 */
async function deleteIpfilterByEdmId(request: DeleteIpfilterByEdmIdRequest): DeleteIpfilterByEdmIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteIpfilterByEdmIdWithOptions(request, runtime);
}

model DeleteMailAddressRequest {
  mailAddressId?: int32(name='MailAddressId', description='Mail Address ID

This parameter is required.', example='23457'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteMailAddressResponseBody = {
  requestId?: string(name='RequestId', description='Request ID', example='10A1AD70-E48E-476D-98D9-39BD92193837'),
}

model DeleteMailAddressResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteMailAddressResponseBody(name='body'),
}

/**
 * @summary Delete Mail Address
 *
 * @param request DeleteMailAddressRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteMailAddressResponse
 */
async function deleteMailAddressWithOptions(request: DeleteMailAddressRequest, runtime: Util.RuntimeOptions): DeleteMailAddressResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.mailAddressId)) {
    query['MailAddressId'] = request.mailAddressId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMailAddress',
    version = '2015-11-23',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Delete Mail Address
 *
 * @param request DeleteMailAddressRequest
 * @return DeleteMailAddressResponse
 */
async function deleteMailAddress(request: DeleteMailAddressRequest): DeleteMailAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMailAddressWithOptions(request, runtime);
}

model DeleteReceiverRequest {
  ownerId?: long(name='OwnerId'),
  receiverId?: string(name='ReceiverId', description='Receiver list ID

This parameter is required.', example='144adfa772cfe47631de7e86d7da13ae'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteReceiverResponseBody = {
  requestId?: string(name='RequestId', description='Request ID', example='10A1AD70-E48E-476D-98D9-39BD92193837'),
}

model DeleteReceiverResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteReceiverResponseBody(name='body'),
}

/**
 * @summary Delete Receiver List
 *
 * @param request DeleteReceiverRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteReceiverResponse
 */
async function deleteReceiverWithOptions(request: DeleteReceiverRequest, runtime: Util.RuntimeOptions): DeleteReceiverResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.receiverId)) {
    query['ReceiverId'] = request.receiverId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteReceiver',
    version = '2015-11-23',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Delete Receiver List
 *
 * @param request DeleteReceiverRequest
 * @return DeleteReceiverResponse
 */
async function deleteReceiver(request: DeleteReceiverRequest): DeleteReceiverResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteReceiverWithOptions(request, runtime);
}

model DeleteReceiverDetailRequest {
  email?: string(name='Email', description='The single recipient to be deleted from the recipient list', example='test@example.com'),
  ownerId?: long(name='OwnerId'),
  receiverId?: string(name='ReceiverId', description='Recipient list ID

This parameter is required.', example='53228b7d80c36257927ecd029ccd3c9a'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteReceiverDetailResponseBody = {
  requestId?: string(name='RequestId', description='Request ID', example='10A1AD70-E48E-476D-98D9-39BD92193837'),
}

model DeleteReceiverDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteReceiverDetailResponseBody(name='body'),
}

/**
 * @summary Delete a Single Recipient
 *
 * @param request DeleteReceiverDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteReceiverDetailResponse
 */
async function deleteReceiverDetailWithOptions(request: DeleteReceiverDetailRequest, runtime: Util.RuntimeOptions): DeleteReceiverDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.email)) {
    query['Email'] = request.email;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.receiverId)) {
    query['ReceiverId'] = request.receiverId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteReceiverDetail',
    version = '2015-11-23',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Delete a Single Recipient
 *
 * @param request DeleteReceiverDetailRequest
 * @return DeleteReceiverDetailResponse
 */
async function deleteReceiverDetail(request: DeleteReceiverDetailRequest): DeleteReceiverDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteReceiverDetailWithOptions(request, runtime);
}

model DeleteTagRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  tagId?: int32(name='TagId', description='The ID of the tag

This parameter is required.', example='123'),
}

model DeleteTagResponseBody = {
  requestId?: string(name='RequestId', description='Request ID', example='10A1AD70-E48E-476D-98D9-39BD92193837'),
}

model DeleteTagResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteTagResponseBody(name='body'),
}

/**
 * @summary Delete Tag
 *
 * @param request DeleteTagRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteTagResponse
 */
async function deleteTagWithOptions(request: DeleteTagRequest, runtime: Util.RuntimeOptions): DeleteTagResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.tagId)) {
    query['TagId'] = request.tagId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteTag',
    version = '2015-11-23',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Delete Tag
 *
 * @param request DeleteTagRequest
 * @return DeleteTagResponse
 */
async function deleteTag(request: DeleteTagRequest): DeleteTagResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTagWithOptions(request, runtime);
}

model DescAccountSummaryRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescAccountSummaryResponseBody = {
  dailyQuota?: int32(name='DailyQuota', description='Daily quota', example='2000'),
  dailyRemainFreeQuota?: int32(name='DailyRemainFreeQuota', description='remaining amount of daily free quota', example='100'),
  dayuStatus?: int32(name='DayuStatus', description='Dayu status (deprecated, retained for compatibility reasons.)', example='0'),
  domains?: int32(name='Domains', description='Number of domains', example='1'),
  enableTimes?: int32(name='EnableTimes', description='Effective time', example='0'),
  mailAddresses?: int32(name='MailAddresses', description='Number of sending addresses', example='0'),
  maxQuotaLevel?: int32(name='MaxQuotaLevel', description='Maximum level', example='10'),
  monthQuota?: int32(name='MonthQuota', description='Monthly quota', example='60000'),
  quotaLevel?: int32(name='QuotaLevel', description='Credit level', example='2'),
  receivers?: int32(name='Receivers', description='Number of recipients', example='0'),
  remainFreeQuota?: int32(name='RemainFreeQuota', description='Remaining amount of total free quota', example='1910'),
  requestId?: string(name='RequestId', description='Request ID', example='82B295BB-7E69-491F-9896-ECEAFF09E1A4'),
  smsRecord?: int32(name='SmsRecord', description='Deprecated, retained for compatibility reasons.', example='0'),
  smsSign?: int32(name='SmsSign', description='Deprecated, retained for compatibility reasons.', example='0'),
  smsTemplates?: int32(name='SmsTemplates', description='Deprecated, retained for compatibility reasons.', example='0'),
  tags?: int32(name='Tags', description='Number of tags', example='0'),
  templates?: int32(name='Templates', description='Number of templates', example='1'),
  userStatus?: int32(name='UserStatus', description='User status:
1 Frozen
2 In arrears
4 Restricted from sending
8 Logically deleted', example='0'),
}

model DescAccountSummaryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescAccountSummaryResponseBody(name='body'),
}

/**
 * @summary Retrieve account information.
 *
 * @param request DescAccountSummaryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescAccountSummaryResponse
 */
async function descAccountSummaryWithOptions(request: DescAccountSummaryRequest, runtime: Util.RuntimeOptions): DescAccountSummaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescAccountSummary',
    version = '2015-11-23',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Retrieve account information.
 *
 * @param request DescAccountSummaryRequest
 * @return DescAccountSummaryResponse
 */
async function descAccountSummary(request: DescAccountSummaryRequest): DescAccountSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return descAccountSummaryWithOptions(request, runtime);
}

model DescDomainRequest {
  domainId?: int32(name='DomainId', description='Domain ID. Can be obtained through QueryDomainByParam.

This parameter is required.', example='13464'),
  ownerId?: long(name='OwnerId'),
  requireRealTimeDnsRecords?: boolean(name='RequireRealTimeDnsRecords', description='Determines whether to perform real-time DNS resolution', example='true'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescDomainResponseBody = {
  cnameAuthStatus?: string(name='CnameAuthStatus', description='CNAME verification flag, 0 for success, 1 for failure.', example='1'),
  cnameConfirmStatus?: string(name='CnameConfirmStatus', description='Indicates whether the CNAME host record has been modified, 1 for modified (reverting to the original value also counts as modification), 0 for not modified.', example='0'),
  cnameRecord?: string(name='CnameRecord', description='Custom part of the CNAME host record', example='dmtrace'),
  createTime?: string(name='CreateTime', description='Creation time', example='2025-03-19T12:49Z'),
  defaultDomain?: string(name='DefaultDomain', description='Whether it is the default domain,

Value: 0 No (this field is deprecated)', example='0'),
  dkimAuthStatus?: string(name='DkimAuthStatus', description='DKIM verification flag, indicating whether the DKIM record set by the user in DNS has passed validation, 0: Passed, 1: Not passed', example='0'),
  dkimPublicKey?: string(name='DkimPublicKey', description='DKIM public key value, the value that users need to set for the DKIM record in DNS', example='v=DKIM1; k=rsa; p=MIGfMA0GCSqGSI...'),
  dkimRR?: string(name='DkimRR', description='DKIM host record, the key that the user needs to set in the DNS for the DKIM record', example='aliyun-cn-hangzhou._domainkey.hangzhou26'),
  dmarcAuthStatus?: int32(name='DmarcAuthStatus', description='DMARC verification flag, indicating whether the DMARC record set by the user in DNS has passed validation, 0: Passed, 1: Not passed', example='1'),
  dmarcHostRecord?: string(name='DmarcHostRecord', description='DMARC host record value', example='_dmarc.xxx'),
  dmarcRecord?: string(name='DmarcRecord', description='DMARC record value', example='v=DMARC1;p=none;rua=mailto:dmarc_report@service.aliyun.com'),
  dnsDmarc?: string(name='DnsDmarc', description='DMARC record value resolved through the public domain name', example='v=DMARC1;p=none;rua=mailto:dmarc_report@service.aliyun.com'),
  dnsMx?: string(name='DnsMx', description='MX record value resolved from the public network domain', example='mx01.dm.aliyun.com'),
  dnsSpf?: string(name='DnsSpf', description='SPF record value resolved from the public network domain', example='v=xxxx'),
  dnsTxt?: string(name='DnsTxt', description='Ownership record value resolved from the public network domain', example='0c40d5f125af4e42892a'),
  domainId?: string(name='DomainId', description='Domain ID', example='158910'),
  domainName?: string(name='DomainName', description='Domain name', example='test.example.net'),
  domainStatus?: string(name='DomainStatus', description='Domain status. Indicates whether the verification was successful, with values:

- **0**: Available, verified successfully
- **1**: Unavailable, verification failed', example='1'),
  domainType?: string(name='DomainType', description='Ownership record provided by the email push console', example='0c40d5f125af4e42892a'),
  hostRecord?: string(name='HostRecord', description='Host record', example='xxx'),
  icpStatus?: string(name='IcpStatus', description='Filing status. **1** indicates filed, **0** indicates not filed.', example='1'),
  mxAuthStatus?: string(name='MxAuthStatus', description='MX verification flag, 0 for success, 1 for failure.', example='1'),
  mxRecord?: string(name='MxRecord', description='MX record value provided by the email push console', example='mx01.dm.aliyun.com'),
  requestId?: string(name='RequestId', description='Request ID', example='51B74264-46B4-43C8-A9A0-6B8E8BC04F34'),
  spfAuthStatus?: string(name='SpfAuthStatus', description='SPF verification flag, 0 for success, 1 for failure.', example='1'),
  spfRecord?: string(name='SpfRecord', description='SPF record value provided by the email push console', example='include:spf1.dm.aliyun.com'),
  spfRecordV2?: string(name='SpfRecordV2', description='SPF record. Previously, the SPF display content needed to be calculated by the calling end based on the spfRecord in the response. The new field spfRecordV2 replaces spfRecord, and the calling end can directly display this field after obtaining it;', example='v=spf1 include:spf1.dm.aliyun.com -all'),
  tlDomainName?: string(name='TlDomainName', description='Primary domain', example='example.com'),
  tracefRecord?: string(name='TracefRecord', description='CNAME record value provided by the email push console', example='tracedm.aliyuncs.com'),
}

model DescDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescDomainResponseBody(name='body'),
}

/**
 * @summary Get Domain Details
 *
 * @param request DescDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescDomainResponse
 */
async function descDomainWithOptions(request: DescDomainRequest, runtime: Util.RuntimeOptions): DescDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainId)) {
    query['DomainId'] = request.domainId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.requireRealTimeDnsRecords)) {
    query['RequireRealTimeDnsRecords'] = request.requireRealTimeDnsRecords;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescDomain',
    version = '2015-11-23',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Get Domain Details
 *
 * @param request DescDomainRequest
 * @return DescDomainResponse
 */
async function descDomain(request: DescDomainRequest): DescDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return descDomainWithOptions(request, runtime);
}

model GetIpProtectionRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model GetIpProtectionResponseBody = {
  ipProtection?: string(name='IpProtection', description='IP protection switch, On: 1 Off: 0', example='0'),
  requestId?: string(name='RequestId', description='Request ID', example='B30E5A62-2E64-577D-A70E-8C6781D6C975'),
}

model GetIpProtectionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetIpProtectionResponseBody(name='body'),
}

/**
 * @summary Get IP Protection Information
 *
 * @param request GetIpProtectionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetIpProtectionResponse
 */
async function getIpProtectionWithOptions(request: GetIpProtectionRequest, runtime: Util.RuntimeOptions): GetIpProtectionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetIpProtection',
    version = '2015-11-23',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Get IP Protection Information
 *
 * @param request GetIpProtectionRequest
 * @return GetIpProtectionResponse
 */
async function getIpProtection(request: GetIpProtectionRequest): GetIpProtectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return getIpProtectionWithOptions(request, runtime);
}

model GetIpfilterListRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model GetIpfilterListResponseBody = {
  pageNumber?: int32(name='PageNumber', description='Current page number', example='1'),
  pageSize?: int32(name='PageSize', description='Number of items per page', example='10'),
  requestId?: string(name='RequestId', description='Request ID', example='84DD77C7-A091-5139-9530-2D1F7CCE59E0'),
  totalCount?: int32(name='TotalCount', description='Total count', example='1'),
  data?: {
    ipfilters?: [ 
    {
      createTime?: string(name='CreateTime', description='timestamp', example='1653547140'),
      id?: string(name='Id', description='Record ID', example='10083'),
      ipAddress?: string(name='IpAddress', description='IP address/IP range/IP segment', example='xxx.xxx.xxx.xxx
xxx.xxx.xxx.xxx-xxx.xxx.xxx.xxx
xxx.xxx.xxx.xxx/xxx'),
    }
  ](name='ipfilters')
  }(name='data', description='Data records'),
}

model GetIpfilterListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetIpfilterListResponseBody(name='body'),
}

/**
 * @summary Retrieve IP Protection Information
 *
 * @param request GetIpfilterListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetIpfilterListResponse
 */
async function getIpfilterListWithOptions(request: GetIpfilterListRequest, runtime: Util.RuntimeOptions): GetIpfilterListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetIpfilterList',
    version = '2015-11-23',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Retrieve IP Protection Information
 *
 * @param request GetIpfilterListRequest
 * @return GetIpfilterListResponse
 */
async function getIpfilterList(request: GetIpfilterListRequest): GetIpfilterListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getIpfilterListWithOptions(request, runtime);
}

model GetSuppressionListLevelRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model GetSuppressionListLevelResponseBody = {
  requestId?: string(name='RequestId'),
  suppressionListLevel?: string(name='SuppressionListLevel'),
}

model GetSuppressionListLevelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetSuppressionListLevelResponseBody(name='body'),
}

/**
 * @summary 获取用户无效地址级别配置
 *
 * @param request GetSuppressionListLevelRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetSuppressionListLevelResponse
 */
async function getSuppressionListLevelWithOptions(request: GetSuppressionListLevelRequest, runtime: Util.RuntimeOptions): GetSuppressionListLevelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSuppressionListLevel',
    version = '2015-11-23',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取用户无效地址级别配置
 *
 * @param request GetSuppressionListLevelRequest
 * @return GetSuppressionListLevelResponse
 */
async function getSuppressionListLevel(request: GetSuppressionListLevelRequest): GetSuppressionListLevelResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSuppressionListLevelWithOptions(request, runtime);
}

model GetTrackListRequest {
  accountName?: string(name='AccountName', description='Sender address.

> If not filled, it represents all addresses; if TagName is provided, this parameter must not be empty.', example='test@example.com'),
  dedicatedIp?: string(name='DedicatedIp'),
  dedicatedIpPoolId?: string(name='DedicatedIpPoolId'),
  endTime?: string(name='EndTime', description='End time, the span between start and end time cannot exceed 7 days. Format: yyyy-MM-dd.

This parameter is required.', example='2019-09-29'),
  esp?: string(name='Esp'),
  offset?: string(name='Offset', description='For the first query, set to 0; for subsequent queries, fixed at 1. 1 indicates pagination in ascending order by time. (This field is deprecated)', example='(This field is deprecated)'),
  offsetCreateTime?: string(name='OffsetCreateTime', description='Used for pagination. Not set for the first query, but for subsequent queries, it should be set to the value of OffsetCreateTime from the previous response. (This field is deprecated)', example='(This field is deprecated)'),
  offsetCreateTimeDesc?: string(name='OffsetCreateTimeDesc', description='(This field is deprecated)', example='(This field is deprecated)'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: string(name='PageNumber', description='Page number', example='1'),
  pageSize?: string(name='PageSize', description='Page size', example='10'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startTime?: string(name='StartTime', description='Start time, which cannot be earlier than 30 days. Format: yyyy-MM-dd.

This parameter is required.', example='2019-09-29'),
  tagName?: string(name='TagName', description='Tag name', example='tagname'),
  total?: string(name='Total', description='(This field is deprecated)', example='(This field is deprecated)'),
}

model GetTrackListResponseBody = {
  offsetCreateTime?: string(name='OffsetCreateTime', description='Used for pagination. Not set for the first query, but for subsequent queries, it should be set to the value of OffsetCreateTime from the previous response. (This field is deprecated)', example='(This field is deprecated)'),
  offsetCreateTimeDesc?: string(name='OffsetCreateTimeDesc', description='(This field is deprecated)', example='(This field is deprecated)'),
  pageNo?: int32(name='PageNo', description='Current page number', example='1'),
  pageSize?: int32(name='PageSize', description='Number of items per page', example='10'),
  requestId?: string(name='RequestId', description='Request ID', example='10A1AD70-E48E-476D-98D9-39BD92193837'),
  total?: int32(name='Total', description='Total number of items', example='100'),
  totalPages?: int32(name='TotalPages'),
  data?: {
    stat?: [ 
    {
      createTime?: string(name='CreateTime', description='Creation time', example='2019-09-29T13:28Z'),
      rcptClickCount?: string(name='RcptClickCount', description='Click count', example='0'),
      rcptClickRate?: string(name='RcptClickRate', description='Click rate', example='0'),
      rcptOpenCount?: string(name='RcptOpenCount', description='Number of Opens', example='0'),
      rcptOpenRate?: string(name='RcptOpenRate', description='Open rate', example='0'),
      rcptUniqueClickCount?: string(name='RcptUniqueClickCount', description='Unique click count', example='0'),
      rcptUniqueClickRate?: string(name='RcptUniqueClickRate', description='Unique click rate', example='0'),
      rcptUniqueOpenCount?: string(name='RcptUniqueOpenCount', description='Unique open count', example='0'),
      rcptUniqueOpenRate?: string(name='RcptUniqueOpenRate', description='Unique open rate', example='0'),
      totalNumber?: string(name='TotalNumber', description='Total number', example='0'),
    }
  ](name='stat')
  }(name='data', description='Tracking data records'),
}

model GetTrackListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetTrackListResponseBody(name='body'),
}

/**
 * @summary Get tracking information
 *
 * @param request GetTrackListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetTrackListResponse
 */
async function getTrackListWithOptions(request: GetTrackListRequest, runtime: Util.RuntimeOptions): GetTrackListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.dedicatedIp)) {
    query['DedicatedIp'] = request.dedicatedIp;
  }
  if (!Util.isUnset(request.dedicatedIpPoolId)) {
    query['DedicatedIpPoolId'] = request.dedicatedIpPoolId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.esp)) {
    query['Esp'] = request.esp;
  }
  if (!Util.isUnset(request.offset)) {
    query['Offset'] = request.offset;
  }
  if (!Util.isUnset(request.offsetCreateTime)) {
    query['OffsetCreateTime'] = request.offsetCreateTime;
  }
  if (!Util.isUnset(request.offsetCreateTimeDesc)) {
    query['OffsetCreateTimeDesc'] = request.offsetCreateTimeDesc;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.tagName)) {
    query['TagName'] = request.tagName;
  }
  if (!Util.isUnset(request.total)) {
    query['Total'] = request.total;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTrackList',
    version = '2015-11-23',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Get tracking information
 *
 * @param request GetTrackListRequest
 * @return GetTrackListResponse
 */
async function getTrackList(request: GetTrackListRequest): GetTrackListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTrackListWithOptions(request, runtime);
}

model GetTrackListByMailFromAndTagNameRequest {
  accountName?: string(name='AccountName', description='Sender address.

> If not filled, it represents all addresses; if there is a TagName, this parameter must not be empty.', example='e-service@amegroups.cn'),
  dedicatedIp?: string(name='DedicatedIp'),
  dedicatedIpPoolId?: string(name='DedicatedIpPoolId'),
  endTime?: string(name='EndTime', description='End time, with a span from the start time that cannot exceed 15 days. Format: yyyy-MM-dd.

This parameter is required.', example='2019-09-29'),
  esp?: string(name='Esp'),
  offset?: string(name='Offset', description='For the first query, set to 0; for subsequent queries, fixed at 1. 1 indicates pagination in ascending order by time. (This field is deprecated)', example='（本字段已废弃）'),
  offsetCreateTime?: string(name='OffsetCreateTime', description='Used for pagination. Not set for the first query; for subsequent queries, set to the value of OffsetCreateTime from the previous response. (This field is deprecated)', example='（本字段已废弃）'),
  offsetCreateTimeDesc?: string(name='OffsetCreateTimeDesc', description='(This field is deprecated)', example='（本字段已废弃）'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: string(name='PageNumber', description='Current page number', example='1'),
  pageSize?: string(name='PageSize', description='Page size', example='10'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startTime?: string(name='StartTime', description='Start time, which cannot be earlier than 30 days. Format: yyyy-MM-dd.

This parameter is required.', example='2019-09-29'),
  tagName?: string(name='TagName', description='Email tag. If not filled, it represents all tags.', example='Subscription'),
  total?: string(name='Total', description='(This field is deprecated)', example='（本字段已废弃）'),
}

model GetTrackListByMailFromAndTagNameResponseBody = {
  offsetCreateTime?: string(name='OffsetCreateTime', description='Used for pagination. Not set for the first query; for subsequent queries, set to the value of OffsetCreateTime from the previous response. (This field is deprecated)', example='（本字段已废弃）'),
  offsetCreateTimeDesc?: string(name='OffsetCreateTimeDesc', description='(This field is deprecated)', example='（本字段已废弃）'),
  pageNo?: int32(name='PageNo', description='Current page number', example='1'),
  pageSize?: int32(name='PageSize', description='Page size', example='20'),
  requestId?: string(name='RequestId', description='Request ID', example='10A1AD70-E48E-476D-98D9-39BD92193837'),
  total?: int32(name='Total', description='(This field is deprecated)', example='4'),
  totalPages?: string(name='TotalPages'),
  trackList?: {
    stat?: [ 
    {
      createTime?: string(name='CreateTime', description='Creation time', example='2025-01-11T10:11Z'),
      rcptClickCount?: string(name='RcptClickCount', description='Click count', example='0'),
      rcptClickRate?: string(name='RcptClickRate', description='Click rate', example='0'),
      rcptOpenCount?: string(name='RcptOpenCount', description='Number of opens', example='0'),
      rcptOpenRate?: string(name='RcptOpenRate', description='Open rate', example='0'),
      rcptUniqueClickCount?: string(name='RcptUniqueClickCount', description='Unique click count', example='0'),
      rcptUniqueClickRate?: string(name='RcptUniqueClickRate', description='Unique click rate', example='0'),
      rcptUniqueOpenCount?: string(name='RcptUniqueOpenCount', description='Unique open count', example='0'),
      rcptUniqueOpenRate?: string(name='RcptUniqueOpenRate', description='Unique open rate', example='0'),
      totalNumber?: string(name='TotalNumber', description='Total number', example='0'),
    }
  ](name='Stat')
  }(name='TrackList', description='Tracking data records'),
}

model GetTrackListByMailFromAndTagNameResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetTrackListByMailFromAndTagNameResponseBody(name='body'),
}

/**
 * @summary Get tracking information based on the sender address and tag name
 *
 * @param request GetTrackListByMailFromAndTagNameRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetTrackListByMailFromAndTagNameResponse
 */
async function getTrackListByMailFromAndTagNameWithOptions(request: GetTrackListByMailFromAndTagNameRequest, runtime: Util.RuntimeOptions): GetTrackListByMailFromAndTagNameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.dedicatedIp)) {
    query['DedicatedIp'] = request.dedicatedIp;
  }
  if (!Util.isUnset(request.dedicatedIpPoolId)) {
    query['DedicatedIpPoolId'] = request.dedicatedIpPoolId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.esp)) {
    query['Esp'] = request.esp;
  }
  if (!Util.isUnset(request.offset)) {
    query['Offset'] = request.offset;
  }
  if (!Util.isUnset(request.offsetCreateTime)) {
    query['OffsetCreateTime'] = request.offsetCreateTime;
  }
  if (!Util.isUnset(request.offsetCreateTimeDesc)) {
    query['OffsetCreateTimeDesc'] = request.offsetCreateTimeDesc;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.tagName)) {
    query['TagName'] = request.tagName;
  }
  if (!Util.isUnset(request.total)) {
    query['Total'] = request.total;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTrackListByMailFromAndTagName',
    version = '2015-11-23',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Get tracking information based on the sender address and tag name
 *
 * @param request GetTrackListByMailFromAndTagNameRequest
 * @return GetTrackListByMailFromAndTagNameResponse
 */
async function getTrackListByMailFromAndTagName(request: GetTrackListByMailFromAndTagNameRequest): GetTrackListByMailFromAndTagNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTrackListByMailFromAndTagNameWithOptions(request, runtime);
}

model GetUserResponseBody = {
  data?: {
    enableEventbridge?: boolean(name='EnableEventbridge', description='Whether EventBridge is enabled', example='true'),
  }(name='Data', description='Returned Content'),
  requestId?: string(name='RequestId', description='Request ID', example='10A1AD70-E48E-476D-98D9-39BD92193837'),
}

model GetUserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetUserResponseBody(name='body'),
}

/**
 * @summary Get Account Details
 *
 * @param request GetUserRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetUserResponse
 */
async function getUserWithOptions(runtime: Util.RuntimeOptions): GetUserResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetUser',
    version = '2015-11-23',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Get Account Details
 *
 * @return GetUserResponse
 */
async function getUser(): GetUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return getUserWithOptions(runtime);
}

model ListUserSuppressionRequest {
  address?: string(name='Address', description='Email address or domain name', example='test@example.net'),
  endBounceTime?: int32(name='EndBounceTime', description='End time of the last bounce hit, timestamp, accurate to the second. The span between start and end times cannot exceed 7 days.', example='1715669077'),
  endCreateTime?: int32(name='EndCreateTime', description='End creation time, timestamp, accurate to the second. The span between start and end times cannot exceed 7 days.', example='1715669077'),
  ownerId?: long(name='OwnerId'),
  pageNo?: int32(name='PageNo', description='Current page number', example='1'),
  pageSize?: int32(name='PageSize', description='Page size', example='10'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startBounceTime?: int32(name='StartBounceTime', description='Start time of the last bounce hit, timestamp, accurate to the second.', example='1715668852'),
  startCreateTime?: int32(name='StartCreateTime', description='Start creation time, timestamp, accurate to the second.', example='1715668852'),
}

model ListUserSuppressionResponseBody = {
  data?: {
    userSuppressions?: [ 
    {
      address?: string(name='Address', description='Email address or domain name', example='test@example.net'),
      createTime?: int32(name='CreateTime', description='Creation time, timestamp, accurate to the second.', example='1715667435'),
      lastBounceTime?: int32(name='LastBounceTime', description='Last bounce hit time, timestamp, accurate to the second.', example='1715667451'),
      suppressionId?: int32(name='SuppressionId', description='Invalid address ID', example='59511'),
      type?: string(name='Type', description='Source of entry, invalid address type
- system
- user', example='user'),
    }
  ](name='UserSuppressions')
  }(name='Data', description='Returned results.'),
  pageNumber?: int32(name='PageNumber', description='Page number', example='1'),
  pageSize?: int32(name='PageSize', description='Page size', example='10'),
  requestId?: string(name='RequestId', description='Request ID', example='1A846D66-5EC7-551B-9687-5BF1963DCFC1'),
  totalCount?: int32(name='TotalCount', description='Total count', example='2'),
}

model ListUserSuppressionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListUserSuppressionResponseBody(name='body'),
}

/**
 * @summary List User Invalid Addresses.
 *
 * @param request ListUserSuppressionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListUserSuppressionResponse
 */
async function listUserSuppressionWithOptions(request: ListUserSuppressionRequest, runtime: Util.RuntimeOptions): ListUserSuppressionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.address)) {
    query['Address'] = request.address;
  }
  if (!Util.isUnset(request.endBounceTime)) {
    query['EndBounceTime'] = request.endBounceTime;
  }
  if (!Util.isUnset(request.endCreateTime)) {
    query['EndCreateTime'] = request.endCreateTime;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.startBounceTime)) {
    query['StartBounceTime'] = request.startBounceTime;
  }
  if (!Util.isUnset(request.startCreateTime)) {
    query['StartCreateTime'] = request.startCreateTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUserSuppression',
    version = '2015-11-23',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary List User Invalid Addresses.
 *
 * @param request ListUserSuppressionRequest
 * @return ListUserSuppressionResponse
 */
async function listUserSuppression(request: ListUserSuppressionRequest): ListUserSuppressionResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUserSuppressionWithOptions(request, runtime);
}

model ModifyMailAddressRequest {
  mailAddressId?: int32(name='MailAddressId', description='Sending address ID

This parameter is required.', example='1344565'),
  ownerId?: long(name='OwnerId'),
  password?: string(name='Password', description='- Length should be 10 to 20 characters, and must include numbers, uppercase letters, and lowercase letters.

- Must contain at least 2 digits, 2 uppercase letters, and 2 lowercase letters, and neither the digits nor the letters can consist of a single character repeated.

- Cannot be the same as the last set password.', example='DM1mail1234'),
  replyAddress?: string(name='ReplyAddress', description='Reply address', example='a***@example.net'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyMailAddressResponseBody = {
  requestId?: string(name='RequestId', description='Request ID', example='10A1AD70-E48E-476D-98D9-39BD92193837'),
}

model ModifyMailAddressResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyMailAddressResponseBody(name='body'),
}

/**
 * @summary Modify the sending address
 *
 * @param request ModifyMailAddressRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyMailAddressResponse
 */
async function modifyMailAddressWithOptions(request: ModifyMailAddressRequest, runtime: Util.RuntimeOptions): ModifyMailAddressResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.mailAddressId)) {
    query['MailAddressId'] = request.mailAddressId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.replyAddress)) {
    query['ReplyAddress'] = request.replyAddress;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyMailAddress',
    version = '2015-11-23',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modify the sending address
 *
 * @param request ModifyMailAddressRequest
 * @return ModifyMailAddressResponse
 */
async function modifyMailAddress(request: ModifyMailAddressRequest): ModifyMailAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyMailAddressWithOptions(request, runtime);
}

model ModifyPWByDomainRequest {
  domainName?: string(name='DomainName', description='Domain name, length 1-50, can include numbers, uppercase letters, lowercase letters, ., and -.

This parameter is required.', example='example.com'),
  ownerId?: long(name='OwnerId'),
  password?: string(name='Password', description='- Length should be between 10 to 20 characters, and must contain numbers, uppercase letters, and lowercase letters.

- At least 2 digits, 2 uppercase letters, and 2 lowercase letters are required, and neither digits nor letters can consist of a single character repeated.

- Cannot be the same as the last set password.

This parameter is required.', example='DM1mail1234'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyPWByDomainResponseBody = {
  code?: string(name='Code', description='Status code', example='OK'),
  message?: string(name='Message', description='Description of the status code', example='test'),
  requestId?: string(name='RequestId', description='Request ID', example='02B2A890-CBD8-4806-9BCA-C93190CE7EF6'),
  success?: boolean(name='Success', description='Whether it was successful', example='true'),
}

model ModifyPWByDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyPWByDomainResponseBody(name='body'),
}

/**
 * @summary Modify the domain-level password
 *
 * @param request ModifyPWByDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyPWByDomainResponse
 */
async function modifyPWByDomainWithOptions(request: ModifyPWByDomainRequest, runtime: Util.RuntimeOptions): ModifyPWByDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyPWByDomain',
    version = '2015-11-23',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modify the domain-level password
 *
 * @param request ModifyPWByDomainRequest
 * @return ModifyPWByDomainResponse
 */
async function modifyPWByDomain(request: ModifyPWByDomainRequest): ModifyPWByDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyPWByDomainWithOptions(request, runtime);
}

model ModifyTagRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  tagDescription?: string(name='TagDescription', description='Tag Description', example='test description'),
  tagId?: int32(name='TagId', description='Tag ID

This parameter is required.', example='100674'),
  tagName?: string(name='TagName', description='Tag Name

This parameter is required.', example='test'),
}

model ModifyTagResponseBody = {
  requestId?: string(name='RequestId', description='Request ID', example='00BD30D8-2E86-523A-BFC7-63B7FF931A06'),
}

model ModifyTagResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyTagResponseBody(name='body'),
}

/**
 * @summary Modify Tag
 *
 * @param request ModifyTagRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyTagResponse
 */
async function modifyTagWithOptions(request: ModifyTagRequest, runtime: Util.RuntimeOptions): ModifyTagResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.tagDescription)) {
    query['TagDescription'] = request.tagDescription;
  }
  if (!Util.isUnset(request.tagId)) {
    query['TagId'] = request.tagId;
  }
  if (!Util.isUnset(request.tagName)) {
    query['TagName'] = request.tagName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyTag',
    version = '2015-11-23',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modify Tag
 *
 * @param request ModifyTagRequest
 * @return ModifyTagResponse
 */
async function modifyTag(request: ModifyTagRequest): ModifyTagResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyTagWithOptions(request, runtime);
}

model QueryDomainByParamRequest {
  keyWord?: string(name='KeyWord', description='Domain name, length 1-50, can include numbers, uppercase and lowercase letters, ., -.', example='example.com'),
  ownerId?: long(name='OwnerId'),
  pageNo?: int32(name='PageNo', description='Current page number. Default: 1', example='1'),
  pageSize?: int32(name='PageSize', description='Number of items per page, default: 10', example='10'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  status?: int32(name='Status', description='- 0 indicates normal
- 1 indicates abnormal', example='0'),
}

model QueryDomainByParamResponseBody = {
  pageNumber?: int32(name='PageNumber', description='Current page number', example='1'),
  pageSize?: int32(name='PageSize', description='Page size', example='50'),
  requestId?: string(name='RequestId', description='Request ID', example='8C90CCD3-627C-4F87-AD8C-2F03146071EB'),
  totalCount?: int32(name='TotalCount', description='Total count', example='2'),
  data?: {
    domain?: [ 
    {
      cnameAuthStatus?: string(name='CnameAuthStatus', description='Track verification', example='0'),
      confirmStatus?: string(name='ConfirmStatus', description='CName verification status, success: 0; failure: 1', example='0'),
      createTime?: string(name='CreateTime', description='Creation time', example='2019-09-29T13:28Z'),
      domainId?: string(name='DomainId', description='Domain ID', example='158923'),
      domainName?: string(name='DomainName', description='Domain name', example='example.com'),
      domainRecord?: string(name='DomainRecord', description='Domain record', example='6bd86901b9fe4618a046'),
      domainStatus?: string(name='DomainStatus', description='Domain status.

- 0: Available, verified
- 1: Unavailable, verification failed', example='0'),
      icpStatus?: string(name='IcpStatus', description='ICP filing status.

- 1 indicates filed
- 0 indicates not filed', example='1'),
      mxAuthStatus?: string(name='MxAuthStatus', description='MX authentication status, success: 0, failure: 1.', example='0'),
      spfAuthStatus?: string(name='SpfAuthStatus', description='SPF authentication status, success: 0, failure: 1.', example='0'),
      utcCreateTime?: long(name='UtcCreateTime', description='Creation time in UTC format.', example='1569734892'),
    }
  ](name='domain')
  }(name='data', description='List of domains'),
}

model QueryDomainByParamResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryDomainByParamResponseBody(name='body'),
}

/**
 * @summary Query domain information
 *
 * @param request QueryDomainByParamRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDomainByParamResponse
 */
async function queryDomainByParamWithOptions(request: QueryDomainByParamRequest, runtime: Util.RuntimeOptions): QueryDomainByParamResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyWord)) {
    query['KeyWord'] = request.keyWord;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDomainByParam',
    version = '2015-11-23',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Query domain information
 *
 * @param request QueryDomainByParamRequest
 * @return QueryDomainByParamResponse
 */
async function queryDomainByParam(request: QueryDomainByParamRequest): QueryDomainByParamResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDomainByParamWithOptions(request, runtime);
}

model QueryInvalidAddressRequest {
  endTime?: string(name='EndTime', description='End time, with a span from the start time that cannot exceed 30 days, in the format yyyy-MM-dd.', example='2019-09-29'),
  keyWord?: string(name='KeyWord', description='Keyword. If not provided, it represents all invalid addresses.', example='info'),
  length?: int32(name='Length', description='Number of items per request.', example='100'),
  nextStart?: string(name='NextStart', description='Request starting position.', example='***'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startTime?: string(name='StartTime', description='Start time, which cannot be earlier than 30 days ago, in the format yyyy-MM-dd.', example='2019-09-29'),
}

model QueryInvalidAddressResponseBody = {
  nextStart?: string(name='NextStart', description='Next request starting position.', example='2'),
  requestId?: string(name='RequestId', description='Request ID.', example='95A7D497-F8DD-4834-B81E-C1783236E55F'),
  totalCount?: int32(name='TotalCount', description='Total count.', example='3'),
  data?: {
    mailDetail?: [ 
    {
      lastUpdateTime?: string(name='LastUpdateTime', description='Update time.', example='2021-04-28T17:11Z'),
      toAddress?: string(name='ToAddress', description='Recipient address.', example='toaddress@example.com'),
      utcLastUpdateTime?: long(name='UtcLastUpdateTime', description='Update time (in timestamp format).', example='1619601108'),
    }
  ](name='mailDetail')
  }(name='data', description='Records.'),
}

model QueryInvalidAddressResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryInvalidAddressResponseBody(name='body'),
}

/**
 * @summary NextStart changed to string
 *
 * @description Retrieve deduplicated invalid address information. If an email is sent to the same invalid address multiple times, only the first occurrence will be recorded. The query should be based on the time when the address was first classified as invalid.
 *
 * @param request QueryInvalidAddressRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryInvalidAddressResponse
 */
async function queryInvalidAddressWithOptions(request: QueryInvalidAddressRequest, runtime: Util.RuntimeOptions): QueryInvalidAddressResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.keyWord)) {
    query['KeyWord'] = request.keyWord;
  }
  if (!Util.isUnset(request.length)) {
    query['Length'] = request.length;
  }
  if (!Util.isUnset(request.nextStart)) {
    query['NextStart'] = request.nextStart;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryInvalidAddress',
    version = '2015-11-23',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary NextStart changed to string
 *
 * @description Retrieve deduplicated invalid address information. If an email is sent to the same invalid address multiple times, only the first occurrence will be recorded. The query should be based on the time when the address was first classified as invalid.
 *
 * @param request QueryInvalidAddressRequest
 * @return QueryInvalidAddressResponse
 */
async function queryInvalidAddress(request: QueryInvalidAddressRequest): QueryInvalidAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryInvalidAddressWithOptions(request, runtime);
}

model QueryMailAddressByParamRequest {
  keyWord?: string(name='KeyWord', description='Email address, length 1-60, supports numbers, letters, ., -, @.', example='账号+@+域名'),
  ownerId?: long(name='OwnerId'),
  pageNo?: int32(name='PageNo', description='Current page number, default: 1', example='1'),
  pageSize?: int32(name='PageSize', description='Page size, default: 10', example='10'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sendtype?: string(name='Sendtype', description='Type of sending address. Values:

- batch: bulk email
- trigger: triggered email', example='batch'),
}

model QueryMailAddressByParamResponseBody = {
  pageNumber?: int32(name='PageNumber', description='Current page number', example='1'),
  pageSize?: int32(name='PageSize', description='Page size', example='10'),
  requestId?: string(name='RequestId', description='Request ID', example='95A7D497-F8DD-4834-B81E-C1783236E55F'),
  totalCount?: int32(name='TotalCount', description='Total count', example='2'),
  data?: {
    mailAddress?: [ 
    {
      accountName?: string(name='AccountName', description='Sending address', example='账户+@+域名'),
      accountStatus?: string(name='AccountStatus', description='Account status, frozen: 1, normal: 0.', example='0'),
      createTime?: string(name='CreateTime', description='Creation time', example='2019-09-29T13:28Z'),
      dailyCount?: string(name='DailyCount', description='Daily quota limit', example='10000'),
      dailyReqCount?: string(name='DailyReqCount', description='Daily quota', example='100'),
      domainStatus?: string(name='DomainStatus', description='Domain status, 0 indicates normal, 1 indicates abnormal.', example='0'),
      mailAddressId?: string(name='MailAddressId', description='Mail address ID', example='12122'),
      monthCount?: string(name='MonthCount', description='Monthly quota limit', example='300000'),
      monthReqCount?: string(name='MonthReqCount', description='Monthly quota', example='20000'),
      replyAddress?: string(name='ReplyAddress', description='Reply address', example='test@example.com'),
      replyStatus?: string(name='ReplyStatus', description='Reply address status', example='0'),
      sendtype?: string(name='Sendtype', description='Type of sending address. Values:

- batch: bulk email
- trigger: triggered email', example='batch'),
    }
  ](name='mailAddress')
  }(name='data', description='List of mail addresses'),
}

model QueryMailAddressByParamResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMailAddressByParamResponseBody(name='body'),
}

/**
 * @summary Query the list of mail addresses.
 *
 * @param request QueryMailAddressByParamRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryMailAddressByParamResponse
 */
async function queryMailAddressByParamWithOptions(request: QueryMailAddressByParamRequest, runtime: Util.RuntimeOptions): QueryMailAddressByParamResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyWord)) {
    query['KeyWord'] = request.keyWord;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sendtype)) {
    query['Sendtype'] = request.sendtype;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryMailAddressByParam',
    version = '2015-11-23',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Query the list of mail addresses.
 *
 * @param request QueryMailAddressByParamRequest
 * @return QueryMailAddressByParamResponse
 */
async function queryMailAddressByParam(request: QueryMailAddressByParamRequest): QueryMailAddressByParamResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMailAddressByParamWithOptions(request, runtime);
}

model QueryReceiverByParamRequest {
  keyWord?: string(name='KeyWord', description='Keyword, defaults to all information if not specified', example='mesh-notification'),
  ownerId?: long(name='OwnerId'),
  pageNo?: int32(name='PageNo', description='Current page number', example='1'),
  pageSize?: int32(name='PageSize', description='Number of items per page, default: 10', example='10'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  status?: int32(name='Status', description='Delivery result. If not filled, it represents all statuses. Values:

- 0: Success
- 2: Invalid address
- 3: Spam
- 4: Failure', example='1'),
}

model QueryReceiverByParamResponseBody = {
  nextStart?: string(name='NextStart', description='Used for pagination. If there are more results, set this returned value to the NextStart in the next request.', example='6aec200853#102#1638894326#test@example.com'),
  pageSize?: int32(name='PageSize', description='Number of items displayed per page.', example='10'),
  requestId?: string(name='RequestId', description='Request ID', example='10A1AD70-E48E-476D-98D9-39BD92193837'),
  totalCount?: int32(name='TotalCount', description='Total count', example='15'),
  data?: {
    receiver?: [ 
    {
      count?: string(name='Count', description='Total number of recipient addresses', example='3'),
      createTime?: string(name='CreateTime', description='Creation time', example='2019-09-29T13:28Z'),
      desc?: string(name='Desc', description='Description', example='Description'),
      receiverId?: string(name='ReceiverId', description='Recipient list ID', example='0c910a7143044b1e116719eb678907b3'),
      receiversAlias?: string(name='ReceiversAlias', description='Recipient list alias', example='10***@example.com'),
      receiversName?: string(name='ReceiversName', description='Recipient list name', example='TKP000442-333'),
      receiversStatus?: string(name='ReceiversStatus', description='List status. Values:

- 0: Uploading
- 1: Upload completed', example='0'),
      utcCreateTime?: long(name='UtcCreateTime', description='UTC formatted creation time', example='1569734892'),
    }
  ](name='receiver')
  }(name='data', description='Detailed information of the recipient list'),
}

model QueryReceiverByParamResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryReceiverByParamResponseBody(name='body'),
}

/**
 * @summary Query the details of the recipient list
 *
 * @param request QueryReceiverByParamRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryReceiverByParamResponse
 */
async function queryReceiverByParamWithOptions(request: QueryReceiverByParamRequest, runtime: Util.RuntimeOptions): QueryReceiverByParamResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyWord)) {
    query['KeyWord'] = request.keyWord;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryReceiverByParam',
    version = '2015-11-23',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Query the details of the recipient list
 *
 * @param request QueryReceiverByParamRequest
 * @return QueryReceiverByParamResponse
 */
async function queryReceiverByParam(request: QueryReceiverByParamRequest): QueryReceiverByParamResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryReceiverByParamWithOptions(request, runtime);
}

model QueryReceiverDetailRequest {
  keyWord?: string(name='KeyWord', description='Recipient address, length 0-50', example='b***@example.net'),
  nextStart?: string(name='NextStart', description='Starting position for the next item, default: 0', example='0'),
  ownerId?: long(name='OwnerId'),
  pageSize?: int32(name='PageSize', description='Number of items per page, default: 10', example='10'),
  receiverId?: string(name='ReceiverId', description='Recipient list ID (returned when creating a recipient list using the CreateReceiver API).

This parameter is required.', example='1235'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryReceiverDetailResponseBody = {
  dataSchema?: string(name='DataSchema', description='Field name for the Data of recipients', example='UserName,NickName,Gender,Birthday,Mobile'),
  nextStart?: string(name='NextStart', description='Used for pagination. If there are more results, set this returned value to the NextStart in the next request.', example='90f0243616#40test@example.com'),
  requestId?: string(name='RequestId', description='Request ID', example='10A1AD70-E48E-476D-98D9-39BD92193837'),
  totalCount?: int32(name='TotalCount', description='Total count (deprecated field, kept for historical compatibility)', example='361'),
  data?: {
    detail?: [ 
    {
      createTime?: string(name='CreateTime', description='Creation Time', example='2019-09-29T13:28Z'),
      data?: string(name='Data', description='Content', example='{\\\\"Domains\\\\": [\\\\"a.example.net\\\\", \\\\"b.example.net\\\\", \\\\"c.example.net\\\\", \\\\"d.example.net\\\\"]}'),
      email?: string(name='Email', description='Recipient address', example='a***@example.net'),
      utcCreateTime?: long(name='UtcCreateTime', description='Creation time in UTC format', example='1569734892'),
    }
  ](name='detail')
  }(name='data', description='Detailed information'),
}

model QueryReceiverDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryReceiverDetailResponseBody(name='body'),
}

/**
 * @summary Retrieve detailed information about a recipient list
 *
 * @param request QueryReceiverDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryReceiverDetailResponse
 */
async function queryReceiverDetailWithOptions(request: QueryReceiverDetailRequest, runtime: Util.RuntimeOptions): QueryReceiverDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyWord)) {
    query['KeyWord'] = request.keyWord;
  }
  if (!Util.isUnset(request.nextStart)) {
    query['NextStart'] = request.nextStart;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.receiverId)) {
    query['ReceiverId'] = request.receiverId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryReceiverDetail',
    version = '2015-11-23',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Retrieve detailed information about a recipient list
 *
 * @param request QueryReceiverDetailRequest
 * @return QueryReceiverDetailResponse
 */
async function queryReceiverDetail(request: QueryReceiverDetailRequest): QueryReceiverDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryReceiverDetailWithOptions(request, runtime);
}

model QueryTagByParamRequest {
  keyWord?: string(name='KeyWord', description='Tag name, length 1-50, defaults to all tags if not specified.', example='1aTag'),
  ownerId?: long(name='OwnerId'),
  pageNo?: int32(name='PageNo', description='Page number', example='1'),
  pageSize?: int32(name='PageSize', description='Page size', example='10'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryTagByParamResponseBody = {
  pageNumber?: int32(name='PageNumber', description='Current page number', example='5'),
  pageSize?: int32(name='PageSize', description='Page size', example='10'),
  requestId?: string(name='RequestId', description='Request ID', example='10A1AD70-E48E-476D-98D9-39BD92193837'),
  totalCount?: int32(name='TotalCount', description='Total count', example='2'),
  data?: {
    tag?: [ 
    {
      tagDescription?: string(name='TagDescription', description='Tag description', example='test description'),
      tagId?: string(name='TagId', description='Tag ID', example='52366'),
      tagName?: string(name='TagName', description='Tag name', example='hellopal'),
    }
  ](name='tag')
  }(name='data', description='Data records'),
}

model QueryTagByParamResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryTagByParamResponseBody(name='body'),
}

/**
 * @summary Call QueryTagByParam to retrieve tags.
 *
 * @param request QueryTagByParamRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryTagByParamResponse
 */
async function queryTagByParamWithOptions(request: QueryTagByParamRequest, runtime: Util.RuntimeOptions): QueryTagByParamResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyWord)) {
    query['KeyWord'] = request.keyWord;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTagByParam',
    version = '2015-11-23',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Call QueryTagByParam to retrieve tags.
 *
 * @param request QueryTagByParamRequest
 * @return QueryTagByParamResponse
 */
async function queryTagByParam(request: QueryTagByParamRequest): QueryTagByParamResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTagByParamWithOptions(request, runtime);
}

model QueryTaskByParamRequest {
  keyWord?: string(name='KeyWord', description='Keyword, defaults to all information.', example='mesh-notification-788717'),
  ownerId?: long(name='OwnerId'),
  pageNo?: int32(name='PageNo', description='Current page number, default is 1.', example='1'),
  pageSize?: int32(name='PageSize', description='Page size, default is 10.', example='10'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  status?: int32(name='Status', description='Status, defaults to all statuses.', example='0'),
}

model QueryTaskByParamResponseBody = {
  pageNumber?: int32(name='PageNumber', description='Current page number.', example='3'),
  pageSize?: int32(name='PageSize', description='Page size.', example='10'),
  requestId?: string(name='RequestId', description='Request ID.', example='10A1AD70-E48E-476D-98D9-39BD92193837'),
  totalCount?: int32(name='TotalCount', description='Total count.', example='15'),
  data?: {
    task?: [ 
    {
      addressType?: string(name='AddressType', description='Address type, sending address: 1; random address: 0;', example='0'),
      createTime?: string(name='CreateTime', description='Creation time.', example='2022-04-18T10:36Z'),
      ipPoolId?: string(name='IpPoolId'),
      ipPoolName?: string(name='IpPoolName'),
      receiversName?: string(name='ReceiversName', description='Receiver\\\\"s name.', example='TKP000442-333'),
      requestCount?: string(name='RequestCount', description='Request count.', example='1'),
      tagName?: string(name='TagName', description='Tag.', example='202201'),
      taskId?: string(name='TaskId', description='Task ID.', example='1054296'),
      taskStatus?: string(name='TaskStatus', description='Task status, sent successfully: 1.', example='1'),
      templateName?: string(name='TemplateName', description='Template name.', example='Short Simple'),
      utcCreateTime?: long(name='UtcCreateTime', description='Creation time in UTC format.', example='1569734892'),
    }
  ](name='task')
  }(name='data', description='Returned results.'),
}

model QueryTaskByParamResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryTaskByParamResponseBody(name='body'),
}

/**
 * @summary Query task.
 *
 * @param request QueryTaskByParamRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryTaskByParamResponse
 */
async function queryTaskByParamWithOptions(request: QueryTaskByParamRequest, runtime: Util.RuntimeOptions): QueryTaskByParamResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyWord)) {
    query['KeyWord'] = request.keyWord;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTaskByParam',
    version = '2015-11-23',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Query task.
 *
 * @param request QueryTaskByParamRequest
 * @return QueryTaskByParamResponse
 */
async function queryTaskByParam(request: QueryTaskByParamRequest): QueryTaskByParamResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTaskByParamWithOptions(request, runtime);
}

model RemoveUserSuppressionRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  suppressionIds?: string(name='SuppressionIds', example='59511'),
}

model RemoveUserSuppressionResponseBody = {
  requestId?: string(name='RequestId', example='1A846D66-5EC7-551B-9687-5BF1963DCFC1'),
}

model RemoveUserSuppressionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveUserSuppressionResponseBody(name='body'),
}

/**
 * @summary 删除用户无效地址
 *
 * @param request RemoveUserSuppressionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveUserSuppressionResponse
 */
async function removeUserSuppressionWithOptions(request: RemoveUserSuppressionRequest, runtime: Util.RuntimeOptions): RemoveUserSuppressionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.suppressionIds)) {
    query['SuppressionIds'] = request.suppressionIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemoveUserSuppression',
    version = '2015-11-23',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 删除用户无效地址
 *
 * @param request RemoveUserSuppressionRequest
 * @return RemoveUserSuppressionResponse
 */
async function removeUserSuppression(request: RemoveUserSuppressionRequest): RemoveUserSuppressionResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeUserSuppressionWithOptions(request, runtime);
}

model SaveReceiverDetailRequest {
  detail?: string(name='Detail', description='Content, supports uploading multiple recipients at once, with a limit of 500 records per upload. Each record is separated by {} and commas, example:

[{ },{ },{ }...], the format within {} is as follows:

[{"b":"birthday","e":"xxx@example.net","g":"gender","m":"mobile","n":"nickname","u":"name"}], when passing values, pass it as a string, not a list.

If a duplicate recipient address is inserted, it will return "ErrorCount": 1

This parameter is required.', example='[{"b":"birthday","e":"xxx@alibaba-inc.com","g":"gender","m":"mobile","n":"nickname","u":"name"}]'),
  ownerId?: long(name='OwnerId'),
  receiverId?: string(name='ReceiverId', description='Recipient list ID

This parameter is required.', example='34642'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model SaveReceiverDetailResponseBody = {
  data?: {
    detail?: [ 
    {
      email?: string(name='Email', description='Recipient address.', example='test@example.com'),
    }
  ](name='Detail')
  }(name='Data', description='List of recipient addresses that failed to upload.'),
  errorCount?: int32(name='ErrorCount', description='Number of errors.', example='638'),
  requestId?: string(name='RequestId', description='Request ID', example='10A1AD70-E48E-476D-98D9-39BD92193837'),
  successCount?: int32(name='SuccessCount', description='Number of successes.', example='274'),
}

model SaveReceiverDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SaveReceiverDetailResponseBody(name='body'),
}

/**
 * @summary Create a Single Recipient
 *
 * @param request SaveReceiverDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SaveReceiverDetailResponse
 */
async function saveReceiverDetailWithOptions(request: SaveReceiverDetailRequest, runtime: Util.RuntimeOptions): SaveReceiverDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.detail)) {
    query['Detail'] = request.detail;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.receiverId)) {
    query['ReceiverId'] = request.receiverId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveReceiverDetail',
    version = '2015-11-23',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Create a Single Recipient
 *
 * @param request SaveReceiverDetailRequest
 * @return SaveReceiverDetailResponse
 */
async function saveReceiverDetail(request: SaveReceiverDetailRequest): SaveReceiverDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveReceiverDetailWithOptions(request, runtime);
}

model SendTestByTemplateRequest {
  accountName?: string(name='AccountName', description='Sender address, with a maximum length of 60 characters

This parameter is required.', example='test@example.com'),
  birthday?: string(name='Birthday', description='Birthday, with a maximum length of 30 characters', example='2000/01/01'),
  email?: string(name='Email', description='Recipient address, with a maximum length of 60 characters

This parameter is required.', example='test1@example.com'),
  gender?: string(name='Gender', description='Gender, with a maximum length of 30 characters', example='doctor'),
  mobile?: string(name='Mobile', description='Mobile, with a maximum length of 30 characters', example='1380000****'),
  nickName?: string(name='NickName', description='NickName, with a maximum length of 30 characters', example='LC'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  templateId?: int32(name='TemplateId', description='Template ID

This parameter is required.', example='123'),
  userName?: string(name='UserName', description='UserName, with a maximum length of 30 characters', example='Lucy'),
}

model SendTestByTemplateResponseBody = {
  requestId?: string(name='RequestId', description='Request ID', example='10A1AD70-E48E-476D-98D9-39BD92193837'),
}

model SendTestByTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SendTestByTemplateResponseBody(name='body'),
}

/**
 * @summary Send Template Test Email
 *
 * @param request SendTestByTemplateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SendTestByTemplateResponse
 */
async function sendTestByTemplateWithOptions(request: SendTestByTemplateRequest, runtime: Util.RuntimeOptions): SendTestByTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.birthday)) {
    query['Birthday'] = request.birthday;
  }
  if (!Util.isUnset(request.email)) {
    query['Email'] = request.email;
  }
  if (!Util.isUnset(request.gender)) {
    query['Gender'] = request.gender;
  }
  if (!Util.isUnset(request.mobile)) {
    query['Mobile'] = request.mobile;
  }
  if (!Util.isUnset(request.nickName)) {
    query['NickName'] = request.nickName;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SendTestByTemplate',
    version = '2015-11-23',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Send Template Test Email
 *
 * @param request SendTestByTemplateRequest
 * @return SendTestByTemplateResponse
 */
async function sendTestByTemplate(request: SendTestByTemplateRequest): SendTestByTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return sendTestByTemplateWithOptions(request, runtime);
}

model SenderStatisticsByTagNameAndBatchIDRequest {
  accountName?: string(name='AccountName', description='Sending address. If not filled, it represents all addresses.', example='xxx'),
  dedicatedIp?: string(name='DedicatedIp'),
  dedicatedIpPoolId?: string(name='DedicatedIpPoolId'),
  endTime?: string(name='EndTime', description='End time, which cannot exceed 7 days from the start time, in the format yyyy-MM-dd.

This parameter is required.', example='2019-09-29'),
  esp?: string(name='Esp'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startTime?: string(name='StartTime', description='Start time, in the format yyyy-MM-dd.

This parameter is required.', example='2019-09-29'),
  tagName?: string(name='TagName', description='Email tag. If not filled, it represents all tags.', example='xxx'),
}

model SenderStatisticsByTagNameAndBatchIDResponseBody = {
  requestId?: string(name='RequestId', description='Request ID', example='10A1AD70-E48E-476D-98D9-39BD92193837'),
  totalCount?: int32(name='TotalCount', description='Total count', example='1'),
  data?: {
    stat?: [ 
    {
      createTime?: string(name='CreateTime', description='Creation time', example='2021-07-02'),
      faildCount?: string(name='faildCount', description='Failure count', example='0'),
      requestCount?: string(name='requestCount', description='Request count', example='4'),
      succeededPercent?: string(name='succeededPercent', description='Success rate', example='100.00%'),
      successCount?: string(name='successCount', description='Success count', example='4'),
      unavailableCount?: string(name='unavailableCount', description='Invalid count', example='0'),
      unavailablePercent?: string(name='unavailablePercent', description='Unavailability rate', example='0%'),
    }
  ](name='stat')
  }(name='data', description='Data records'),
}

model SenderStatisticsByTagNameAndBatchIDResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SenderStatisticsByTagNameAndBatchIDResponseBody(name='body'),
}

/**
 * @summary Retrieve Sending Data under Specified Conditions
 *
 * @param request SenderStatisticsByTagNameAndBatchIDRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SenderStatisticsByTagNameAndBatchIDResponse
 */
async function senderStatisticsByTagNameAndBatchIDWithOptions(request: SenderStatisticsByTagNameAndBatchIDRequest, runtime: Util.RuntimeOptions): SenderStatisticsByTagNameAndBatchIDResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.dedicatedIp)) {
    query['DedicatedIp'] = request.dedicatedIp;
  }
  if (!Util.isUnset(request.dedicatedIpPoolId)) {
    query['DedicatedIpPoolId'] = request.dedicatedIpPoolId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.esp)) {
    query['Esp'] = request.esp;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.tagName)) {
    query['TagName'] = request.tagName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SenderStatisticsByTagNameAndBatchID',
    version = '2015-11-23',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Retrieve Sending Data under Specified Conditions
 *
 * @param request SenderStatisticsByTagNameAndBatchIDRequest
 * @return SenderStatisticsByTagNameAndBatchIDResponse
 */
async function senderStatisticsByTagNameAndBatchID(request: SenderStatisticsByTagNameAndBatchIDRequest): SenderStatisticsByTagNameAndBatchIDResponse {
  var runtime = new Util.RuntimeOptions{};
  return senderStatisticsByTagNameAndBatchIDWithOptions(request, runtime);
}

model SenderStatisticsDetailByParamRequest {
  accountName?: string(name='AccountName', description='Sending address. If not filled, it represents all addresses.

> **AccountName**, **TagName**, and **ToAddress** can all be left unfilled. If any are filled, only one of these parameters can be passed; you cannot pass a combination of two or more.', example='s***@example.net'),
  endTime?: string(name='EndTime', description='End time. The span between start and end times cannot exceed 30 days, format: yyyy-MM-dd HH:mm.', example='2021-04-29 00:00'),
  length?: int32(name='Length', description='Specifies the number of results to return in this request. Range is 1~100.', example='5'),
  nextStart?: string(name='NextStart', description='Used for pagination. Specifies the offset for this request. If there are more results, set this returned value to the NextStart in the next request.', example='90f0243616#203#a***@example.net-1658817837#a***@example.net.247475288187'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startTime?: string(name='StartTime', description='Start time. The span between start and end times cannot exceed 30 days, format: yyyy-MM-dd HH:mm', example='2021-04-28 00:00'),
  status?: int32(name='Status', description='Delivery result. If not filled, it represents all statuses. Values:

- 0: Success
- 2: Invalid Address
- 3: Spam
- 4: Failure', example='0'),
  tagName?: string(name='TagName', description='Email tag. If not filled, it represents all tags.', example='EmailQuestionnaireHelioscam'),
  toAddress?: string(name='ToAddress', description='Recipient address. If not filled, it represents all recipient addresses.', example='b***@example.net'),
}

model SenderStatisticsDetailByParamResponseBody = {
  nextStart?: string(name='NextStart', description='Used for pagination. If there are more results, set this returned value to the NextStart in the next request.', example='90f0243616#203#a***@example.net-1658817689#a***@example.net.247141122178'),
  requestId?: string(name='RequestId', description='Request ID', example='B5AB8EBB-EE64-4BB2-B085-B92CC5DEDC41'),
  data?: {
    mailDetail?: [ 
    {
      accountName?: string(name='AccountName', description='Sending address', example='s***@example.net'),
      errorClassification?: string(name='ErrorClassification', description='Detailed classification of error reasons: - SendOk - SmtpNxBox
etc.', example='SendOk'),
      lastUpdateTime?: string(name='LastUpdateTime', description='Update time', example='2021-04-28T17:11Z'),
      message?: string(name='Message', description='Delivery detail information', example='250 Send Mail OK'),
      status?: int32(name='Status', description='Delivery status: 0 Success, 2 Invalid Address, 3 Spam, 4 Other Failures', example='0'),
      subject?: string(name='Subject', description='Email subject', example='test subject'),
      toAddress?: string(name='ToAddress', description='Recipient address', example='b***@example.net'),
      utcLastUpdateTime?: string(name='UtcLastUpdateTime', description='UTC formatted update time', example='1619601108'),
    }
  ](name='mailDetail')
  }(name='data', description='Detailed records'),
}

model SenderStatisticsDetailByParamResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SenderStatisticsDetailByParamResponseBody(name='body'),
}

/**
 * @summary Query Delivery Result Details
 *
 * @param request SenderStatisticsDetailByParamRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SenderStatisticsDetailByParamResponse
 */
async function senderStatisticsDetailByParamWithOptions(request: SenderStatisticsDetailByParamRequest, runtime: Util.RuntimeOptions): SenderStatisticsDetailByParamResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.length)) {
    query['Length'] = request.length;
  }
  if (!Util.isUnset(request.nextStart)) {
    query['NextStart'] = request.nextStart;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.tagName)) {
    query['TagName'] = request.tagName;
  }
  if (!Util.isUnset(request.toAddress)) {
    query['ToAddress'] = request.toAddress;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SenderStatisticsDetailByParam',
    version = '2015-11-23',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Query Delivery Result Details
 *
 * @param request SenderStatisticsDetailByParamRequest
 * @return SenderStatisticsDetailByParamResponse
 */
async function senderStatisticsDetailByParam(request: SenderStatisticsDetailByParamRequest): SenderStatisticsDetailByParamResponse {
  var runtime = new Util.RuntimeOptions{};
  return senderStatisticsDetailByParamWithOptions(request, runtime);
}

model SetSuppressionListLevelRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  suppressionListLevel?: string(name='SuppressionListLevel'),
}

model SetSuppressionListLevelResponseBody = {
  requestId?: string(name='RequestId'),
  suppressionListLevel?: string(name='SuppressionListLevel'),
}

model SetSuppressionListLevelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetSuppressionListLevelResponseBody(name='body'),
}

/**
 * @summary 设置用户无效地址级别配置
 *
 * @param request SetSuppressionListLevelRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetSuppressionListLevelResponse
 */
async function setSuppressionListLevelWithOptions(request: SetSuppressionListLevelRequest, runtime: Util.RuntimeOptions): SetSuppressionListLevelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.suppressionListLevel)) {
    query['SuppressionListLevel'] = request.suppressionListLevel;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetSuppressionListLevel',
    version = '2015-11-23',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 设置用户无效地址级别配置
 *
 * @param request SetSuppressionListLevelRequest
 * @return SetSuppressionListLevelResponse
 */
async function setSuppressionListLevel(request: SetSuppressionListLevelRequest): SetSuppressionListLevelResponse {
  var runtime = new Util.RuntimeOptions{};
  return setSuppressionListLevelWithOptions(request, runtime);
}

model SingleSendMailRequest {
  accountName?: string(name='AccountName', description='The sending address configured in the management console.

This parameter is required.', example='test***@example.net'),
  addressType?: int32(name='AddressType', description='Address type. Values:

0: Random account

1: Sending address

This parameter is required.', example='1'),
  clickTrace?: string(name='ClickTrace', description='1: Enable data tracking function

0 (default): Disable data tracking function.', example='0'),
  fromAlias?: string(name='FromAlias', description='Sender nickname, with a maximum length of 15 characters.

For example, if the sender\\\\"s nickname is set to "Xiaohong" and the sending address is test***@example.net, the recipient will see the sending address as "Xiaohong" <test***@example.net>.', example='Xiaohong'),
  headers?: string(name='Headers', description='Standard fields that can currently be added to the email header include Message-ID, List-Unsubscribe, and List-Unsubscribe-Post. Standard fields will overwrite existing values in the email header, while non-standard fields need to start with X-User- and will be appended to the email header.
Currently, up to 10 headers can be passed in JSON format, and both standard and non-standard fields must comply with the syntax requirements for headers.', example='{
  "Message-ID": "<msg0001@example.com>",
  "X-User-UID1": "UID-1-000001",
  "X-User-UID2": "UID-2-000001"
}'),
  htmlBody?: string(name='HtmlBody', description='Email HTML body, limited to 80K by the SDK. Note: HtmlBody and TextBody are for different types of email content, and one of them must be provided.', example='body'),
  ipPoolId?: string(name='IpPoolId'),
  ownerId?: long(name='OwnerId'),
  replyAddress?: string(name='ReplyAddress', description='Reply-to address', example='test2***@example.net'),
  replyAddressAlias?: string(name='ReplyAddressAlias', description='Reply-to address nickname', example='Xiaohong'),
  replyToAddress?: boolean(name='ReplyToAddress', description='Whether to enable the reply-to address configured in the management console (the status must be verified). The value range is the string `true` or `false` (not a boolean value).

This parameter is required.', example='true'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  subject?: string(name='Subject', description='Email subject, with a maximum length of 100 characters.

This parameter is required.', example='Subject'),
  tagName?: string(name='TagName', description='A tag created in the email push console, used to categorize batches of emails sent. You can use tags to query the sending status of each batch. Additionally, if the email tracking feature is enabled, you must use an email tag when sending emails.', example='test'),
  textBody?: string(name='TextBody', description='Email text body, limited to 80K by the SDK. Note: HtmlBody and TextBody are for different types of email content, and one of them must be provided.', example='body'),
  toAddress?: string(name='ToAddress', description='Recipient addresses. Multiple email addresses can be separated by commas, with a maximum of 100 addresses (supports mailing lists).

This parameter is required.', example='test1***@example.net'),
  unSubscribeFilterLevel?: string(name='UnSubscribeFilterLevel', description='Filtering level. Refer to the [Unsubscribe Function Link Generation and Filtering Mechanism](https://help.aliyun.com/document_detail/2689048.html) document.

disabled: No filtering

default: Use the default strategy, bulk addresses use the sending address level filtering

mailfrom: Sending address level filtering

mailfrom_domain: Sending domain level filtering

edm_id: Account level filtering', example='mailfrom_domain'),
  unSubscribeLinkType?: string(name='UnSubscribeLinkType', description='Type of the generated unsubscribe link. Refer to the [Unsubscribe Function Link Generation and Filtering Mechanism](https://help.aliyun.com/document_detail/2689048.html) document.

disabled: Do not generate

default: Use the default strategy: Generate unsubscribe links for bulk-type sending addresses when sending to specific domains, such as those containing keywords like "gmail", "yahoo",

"google", "aol.com", "hotmail",

"outlook", "ymail.com", etc.

zh-cn: Generate, for future content preparation

en-us: Generate, for future content preparation', example='default'),
}

model SingleSendMailResponseBody = {
  envId?: string(name='EnvId', description='Event ID', example='600000xxxxxxxxxx642'),
  requestId?: string(name='RequestId', description='Request ID', example='2D086F6-xxxx-xxxx-xxxx-006DED011A85'),
}

model SingleSendMailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SingleSendMailResponseBody(name='body'),
}

/**
 * @summary API for Sending Emails
 *
 * @param request SingleSendMailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SingleSendMailResponse
 */
async function singleSendMailWithOptions(request: SingleSendMailRequest, runtime: Util.RuntimeOptions): SingleSendMailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.addressType)) {
    query['AddressType'] = request.addressType;
  }
  if (!Util.isUnset(request.clickTrace)) {
    query['ClickTrace'] = request.clickTrace;
  }
  if (!Util.isUnset(request.fromAlias)) {
    query['FromAlias'] = request.fromAlias;
  }
  if (!Util.isUnset(request.headers)) {
    query['Headers'] = request.headers;
  }
  if (!Util.isUnset(request.htmlBody)) {
    query['HtmlBody'] = request.htmlBody;
  }
  if (!Util.isUnset(request.ipPoolId)) {
    query['IpPoolId'] = request.ipPoolId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.replyAddress)) {
    query['ReplyAddress'] = request.replyAddress;
  }
  if (!Util.isUnset(request.replyAddressAlias)) {
    query['ReplyAddressAlias'] = request.replyAddressAlias;
  }
  if (!Util.isUnset(request.replyToAddress)) {
    query['ReplyToAddress'] = request.replyToAddress;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.subject)) {
    query['Subject'] = request.subject;
  }
  if (!Util.isUnset(request.tagName)) {
    query['TagName'] = request.tagName;
  }
  if (!Util.isUnset(request.textBody)) {
    query['TextBody'] = request.textBody;
  }
  if (!Util.isUnset(request.toAddress)) {
    query['ToAddress'] = request.toAddress;
  }
  if (!Util.isUnset(request.unSubscribeFilterLevel)) {
    query['UnSubscribeFilterLevel'] = request.unSubscribeFilterLevel;
  }
  if (!Util.isUnset(request.unSubscribeLinkType)) {
    query['UnSubscribeLinkType'] = request.unSubscribeLinkType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SingleSendMail',
    version = '2015-11-23',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary API for Sending Emails
 *
 * @param request SingleSendMailRequest
 * @return SingleSendMailResponse
 */
async function singleSendMail(request: SingleSendMailRequest): SingleSendMailResponse {
  var runtime = new Util.RuntimeOptions{};
  return singleSendMailWithOptions(request, runtime);
}

model UpdateIpProtectionRequest {
  ipProtection?: string(name='IpProtection', description='IP protection switch, On: 1 Off: 0', example='0'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model UpdateIpProtectionResponseBody = {
  requestId?: string(name='RequestId', description='Request ID', example='B653A6FC-D1AD-5936-A262-F50994ED2574'),
}

model UpdateIpProtectionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateIpProtectionResponseBody(name='body'),
}

/**
 * @summary Update IP Protection API
 *
 * @param request UpdateIpProtectionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateIpProtectionResponse
 */
async function updateIpProtectionWithOptions(request: UpdateIpProtectionRequest, runtime: Util.RuntimeOptions): UpdateIpProtectionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ipProtection)) {
    query['IpProtection'] = request.ipProtection;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateIpProtection',
    version = '2015-11-23',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Update IP Protection API
 *
 * @param request UpdateIpProtectionRequest
 * @return UpdateIpProtectionResponse
 */
async function updateIpProtection(request: UpdateIpProtectionRequest): UpdateIpProtectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateIpProtectionWithOptions(request, runtime);
}

model UpdateUserRequest {
  user?: {
    enableEventbridge?: boolean(name='EnableEventbridge', description='Whether EventBridge is enabled', example='true'),
  }(name='User', description='User Information'),
}

model UpdateUserShrinkRequest {
  userShrink?: string(name='User', description='User Information'),
}

model UpdateUserResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request', example='7BC346F6-1092-5852-B6E2-CCE2E5AAE51F'),
}

model UpdateUserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateUserResponseBody(name='body'),
}

/**
 * @summary Update account information
 *
 * @param tmpReq UpdateUserRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateUserResponse
 */
async function updateUserWithOptions(tmpReq: UpdateUserRequest, runtime: Util.RuntimeOptions): UpdateUserResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateUserShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.user)) {
    request.userShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.user, 'User', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.userShrink)) {
    body['User'] = request.userShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateUser',
    version = '2015-11-23',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Update account information
 *
 * @param request UpdateUserRequest
 * @return UpdateUserResponse
 */
async function updateUser(request: UpdateUserRequest): UpdateUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateUserWithOptions(request, runtime);
}

