/**
  *
  */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'Dm';
  @version = '2015-11-23';
  @endpointRule = '';
  @endpointMap = {
  };
}

function close(): void {
  @handler.close();
}

model AddIpfilterRequest {
  ipAddress: string(name='IpAddress', description='IP Address/IP Range/IP Segment

This parameter is required.', example='xxx.xxx.xxx.xxx
xxx.xxx.xxx.xxx-xxx.xxx.xxx.xxx
xxx.xxx.xxx.xxx/xxx', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model AddIpfilterResponseBody = {
  ipFilterId?: string(name='IpFilterId', description='ID corresponding to the IP', example='10795'),
  requestId?: string(name='RequestId', description='Request ID', example='0E9282E8-DC08-5445-8FB0-B9F0CA28B249'),
}

model AddIpfilterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddIpfilterResponseBody(name='body'),
}

/**
  * @param request  the request parameters of AddIpfilter  AddIpfilterRequest
  * @return AddIpfilterResponse
 */
async function addIpfilter(request: AddIpfilterRequest): AddIpfilterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddIpfilter', 'POST', '/', 'json', false, 'json', request);
}

model ApproveReplyMailAddressRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ticket: string(name='Ticket', description='Email address Ticket credential, part of the string in the verification email\\"s URL.

This parameter is required.', example='a724068dac9a45d19574375adeca0d7d', position='Query'),
}

model ApproveReplyMailAddressResponseBody = {
  requestId?: string(name='RequestId', description='Request ID', example='10A1AD70-E48E-476D-98D9-39BD92193837'),
}

model ApproveReplyMailAddressResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ApproveReplyMailAddressResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ApproveReplyMailAddress  ApproveReplyMailAddressRequest
  * @return ApproveReplyMailAddressResponse
 */
async function approveReplyMailAddress(request: ApproveReplyMailAddressRequest): ApproveReplyMailAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ApproveReplyMailAddress', 'POST', '/', 'json', false, 'json', request);
}

model BatchSendMailRequest {
  accountName: string(name='AccountName', description='The sending address configured in the management console.

This parameter is required.', example='test@example.com', position='Query'),
  addressType: int32(name='AddressType', description='- 0: Random account
- 1: Sending address

This parameter is required.', example='1', minimum=0, maximum=1, position='Query'),
  clickTrace?: string(name='ClickTrace', description='- 1: Enable data tracking function
- 0 (default): Disable data tracking function', example='0', position='Query'),
  headers?: string(name='Headers', description='Currently, the standard fields that can be added to the email header are Message-ID, List-Unsubscribe, and List-Unsubscribe-Post. Standard fields will overwrite the existing values in the email header, while non-standard fields must start with X-User- and will be appended to the email header. Currently, up to 10 headers can be passed in JSON format, and both standard and non-standard fields must comply with the syntax requirements for headers.', example='{
  "Message-ID": "<msg0001@example.com>",
  "X-User-UID1": "UID-1-000001",
  "X-User-UID2": "UID-2-000001"
}', position='Query'),
  ipPoolId?: string(name='IpPoolId', description='dedicated IP pool ID. Users who have purchased an dedicated IP can use this parameter to specify the outgoing IP for this send operation.', example='xxx', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  receiversName: string(name='ReceiversName', description='The name of the recipient list that has been created and uploaded with recipients. Note: The recipient list should not be deleted until at least 10 minutes after the task is triggered, otherwise it may cause sending failure.

This parameter is required.', example='test2', position='Query'),
  replyAddress?: string(name='ReplyAddress', description='Reply address', example='test2***@example.net', position='Query'),
  replyAddressAlias?: string(name='ReplyAddressAlias', description='Alias for the reply address', example='Lucy', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  tagName?: string(name='TagName', description='Email tag name.', example='test3', position='Query'),
  templateName: string(name='TemplateName', description='The name of the template that has been created and approved in advance.

This parameter is required.', example='test1', position='Query'),
  unSubscribeFilterLevel?: string(name='UnSubscribeFilterLevel', description='Filtering level. Refer to the [Unsubscribe Function Link Generation and Filtering Mechanism](https://help.aliyun.com/document_detail/2689048.html) document.
- disabled: No filtering
- default: Use the default strategy, bulk addresses use sender address-level filtering
- mailfrom: Sender address-level filtering
- mailfrom_domain: Sender domain-level filtering
- edm_id: Account-level filtering', example='mailfrom_domain', position='Query'),
  unSubscribeLinkType?: string(name='UnSubscribeLinkType', description='The type of generated unsubscribe link. Refer to the [Unsubscribe Function Link Generation and Filtering Mechanism](https://help.aliyun.com/document_detail/2689048.html) document.
- disabled: Do not generate
- default: Use the default strategy: Generate an unsubscribe link when a bulk-type sending address sends to specific domains, such as those containing keywords like "gmail", "yahoo",
"google", "aol.com", "hotmail",
"outlook", "ymail.com", etc.
- zh-cn: Generate, for future content preparation
- en-us: Generate, for future content preparation', example='default', position='Query'),
}

model BatchSendMailResponseBody = {
  envId?: string(name='EnvId', description='Event ID', example='xxx'),
  requestId?: string(name='RequestId', description='Request ID', example='12D086F6-8F31-4658-84C1-006DED011A85'),
}

model BatchSendMailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchSendMailResponseBody(name='body'),
}

/**
  * @param request  the request parameters of BatchSendMail  BatchSendMailRequest
  * @return BatchSendMailResponse
 */
async function batchSendMail(request: BatchSendMailRequest): BatchSendMailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'BatchSendMail', 'POST', '/', 'json', false, 'json', request);
}

model ChangeDomainDkimRecordRequest {
  dkimRsaLength?: int32(name='DkimRsaLength', position='Query'),
  domain?: string(name='Domain', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ChangeDomainDkimRecordResponseBody = {
  changed?: boolean(name='Changed'),
  dkimPublicKey?: string(name='DkimPublicKey'),
  dkimRsaLength?: int32(name='DkimRsaLength'),
  hostname?: string(name='Hostname'),
  requestId?: string(name='RequestId'),
}

model ChangeDomainDkimRecordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ChangeDomainDkimRecordResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ChangeDomainDkimRecord  ChangeDomainDkimRecordRequest
  * @return ChangeDomainDkimRecordResponse
 */
async function changeDomainDkimRecord(request: ChangeDomainDkimRecordRequest): ChangeDomainDkimRecordResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ChangeDomainDkimRecord', 'POST', '/', 'json', false, 'json', request);
}

model CheckDomainRequest {
  domainId: int32(name='DomainId', description='Domain ID.

This parameter is required.', example='153345', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CheckDomainResponseBody = {
  domainStatus?: int32(name='DomainStatus', description='Domain status. Indicates whether the verification was successful, with values as follows:

- **0**: Available, verified successfully
- **1**: Unavailable, verification failed', example='1'),
  requestId?: string(name='RequestId', description='Request ID', example='F0B82E83-A1D9-4FE6-97D2-F4B231F80B02'),
}

model CheckDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CheckDomainResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CheckDomain  CheckDomainRequest
  * @return CheckDomainResponse
 */
async function checkDomain(request: CheckDomainRequest): CheckDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CheckDomain', 'POST', '/', 'json', false, 'json', request);
}

model CheckReplyToMailAddressRequest {
  lang?: string(name='Lang', description='Language.

en is English, and any other value or an empty value defaults to Chinese.', example='en', position='Query'),
  mailAddressId: int32(name='MailAddressId', description='Sender Address ID

This parameter is required.', example='126545', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  region?: string(name='Region', description='Region', example='cn-hangzhou', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CheckReplyToMailAddressResponseBody = {
  requestId?: string(name='RequestId', description='Request ID', example='10A1AD70-E48E-476D-98D9-39BD92193837'),
}

model CheckReplyToMailAddressResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CheckReplyToMailAddressResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CheckReplyToMailAddress  CheckReplyToMailAddressRequest
  * @return CheckReplyToMailAddressResponse
 */
async function checkReplyToMailAddress(request: CheckReplyToMailAddressRequest): CheckReplyToMailAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CheckReplyToMailAddress', 'POST', '/', 'json', false, 'json', request);
}

model CreateDomainRequest {
  domainName: string(name='DomainName', description='Domain name, length 1-50, can include numbers, uppercase letters, lowercase letters, ., and -.

This parameter is required.', example='sub.example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  dkimSelector?: string(name='dkimSelector', description='The selector field in the DKIM protocol, used to identify a specific public key. It is recommended to leave it blank, as the system will automatically generate it based on cluster information. If the user specifies it manually, for example, if the sending domain is "sub.example.com" and dkimSelector is set to "default", then the host record will be "default._domainkey.sub"
Constraints: 
1. The length must not exceed 60 characters. 
2. It must consist of visible characters only. 
3. It cannot start with a hyphen (-). 
4. It cannot end with a hyphen (-). 
5. It cannot contain any of the following characters: _ :;/!*~.@#$%^&()+=[{]}|?<>,\\""', example='default', position='Query'),
}

model CreateDomainResponseBody = {
  domainId?: string(name='DomainId', description='Domain ID', example='158910'),
  requestId?: string(name='RequestId', description='Request ID', example='B49AD828-25D1-488C-90B7-8853C1944486'),
}

model CreateDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDomainResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateDomain  CreateDomainRequest
  * @return CreateDomainResponse
 */
async function createDomain(request: CreateDomainRequest): CreateDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDomain', 'POST', '/', 'json', false, 'json', request);
}

model CreateMailAddressRequest {
  accountName: string(name='AccountName', description='Sender\\"s email address

This parameter is required.', example='test1@example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  replyAddress?: string(name='ReplyAddress', description='Reply-to address', example='test2@example.com', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  sendtype: string(name='Sendtype', description='Type of sending. Values:

- batch: Bulk emails

- trigger: Triggered emails

This parameter is required.', example='batch', position='Query'),
}

model CreateMailAddressResponseBody = {
  mailAddressId?: string(name='MailAddressId', description='Mail address ID', example='15123'),
  requestId?: string(name='RequestId', description='Request ID', example='95A7D497-F8DD-4834-B81E-C1783236E55F'),
}

model CreateMailAddressResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMailAddressResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateMailAddress  CreateMailAddressRequest
  * @return CreateMailAddressResponse
 */
async function createMailAddress(request: CreateMailAddressRequest): CreateMailAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateMailAddress', 'POST', '/', 'json', false, 'json', request);
}

model CreateReceiverRequest {
  desc?: string(name='Desc', description='List description.', example='the description', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  receiversAlias: string(name='ReceiversAlias', description='List alias, an email address less than 30 characters long.

This parameter is required.', example='a***@example.net', position='Query'),
  receiversName: string(name='ReceiversName', description='List name, must be unique, with a length of 1-30 characters.

This parameter is required.', example='test', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CreateReceiverResponseBody = {
  receiverId?: string(name='ReceiverId', description='Receiver list ID', example='7312e09b8fffc5c7b2e2fbf5b6dc2073'),
  requestId?: string(name='RequestId', description='Request ID', example='10A1AD70-E48E-476D-98D9-39BD92193837'),
}

model CreateReceiverResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateReceiverResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateReceiver  CreateReceiverRequest
  * @return CreateReceiverResponse
 */
async function createReceiver(request: CreateReceiverRequest): CreateReceiverResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateReceiver', 'POST', '/', 'json', false, 'json', request);
}

model CreateTagRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  tagDescription?: string(name='TagDescription', description='Tag description', example='test description', position='Query'),
  tagName: string(name='TagName', description='Tag name. Limitations: 1-50 characters, allowing English letters, numbers, and underscores.

This parameter is required.', example='test', position='Query'),
}

model CreateTagResponseBody = {
  requestId?: string(name='RequestId', description='Request ID', example='10A1AD70-E48E-476D-98D9-39BD92193837'),
  tagId?: string(name='TagId', description='Tag ID', example='91141'),
}

model CreateTagResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateTagResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateTag  CreateTagRequest
  * @return CreateTagResponse
 */
async function createTag(request: CreateTagRequest): CreateTagResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateTag', 'POST', '/', 'json', false, 'json', request);
}

model CreateUserSuppressionRequest {
  address?: string(name='Address', description='Email address or domain name', example='test@example.net', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CreateUserSuppressionResponseBody = {
  requestId?: string(name='RequestId', description='Request ID', example='1A846D66-5EC7-551B-9687-5BF1963DCFC1'),
  suppressionId?: string(name='SuppressionId', description='Invalid address number', example='59511'),
}

model CreateUserSuppressionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateUserSuppressionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateUserSuppression  CreateUserSuppressionRequest
  * @return CreateUserSuppressionResponse
 */
async function createUserSuppression(request: CreateUserSuppressionRequest): CreateUserSuppressionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateUserSuppression', 'POST', '/', 'json', false, 'json', request);
}

model DedicatedIpAutoRenewalRequest {
  regionId?: string(name='RegionId', position='Host'),
  autoRenewal: string(name='AutoRenewal', description='Whether to enable auto-renewal

This parameter is required.', example='false', position='Query'),
  buyResourceIds: string(name='BuyResourceIds', description='Purchase instance ID, separated by English commas if multiple.

This parameter is required.', example='xxx,xxx', position='Query'),
}

model DedicatedIpAutoRenewalResponseBody = {
  requestId?: string(name='RequestId', description='Request ID', example='xxx'),
}

model DedicatedIpAutoRenewalResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DedicatedIpAutoRenewalResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DedicatedIpAutoRenewal  DedicatedIpAutoRenewalRequest
  * @return DedicatedIpAutoRenewalResponse
 */
async function dedicatedIpAutoRenewal(request: DedicatedIpAutoRenewalRequest): DedicatedIpAutoRenewalResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DedicatedIpAutoRenewal', 'POST', '/', 'json', false, 'json', request);
}

model DedicatedIpChangeWarmupTypeRequest {
  regionId?: string(name='RegionId', position='Host'),
  id?: string(name='Id', description='Dedicated IP ID', example='xxx', position='Query'),
  warmupType?: string(name='WarmupType', description='Warmup method', example='sysCusStream', position='Query'),
}

model DedicatedIpChangeWarmupTypeResponseBody = {
  requestId?: string(name='RequestId', description='Request ID', example='xxx'),
}

model DedicatedIpChangeWarmupTypeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DedicatedIpChangeWarmupTypeResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DedicatedIpChangeWarmupType  DedicatedIpChangeWarmupTypeRequest
  * @return DedicatedIpChangeWarmupTypeResponse
 */
async function dedicatedIpChangeWarmupType(request: DedicatedIpChangeWarmupTypeRequest): DedicatedIpChangeWarmupTypeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DedicatedIpChangeWarmupType', 'POST', '/', 'json', false, 'json', request);
}

model DedicatedIpListRequest {
  regionId?: string(name='RegionId', position='Host'),
  keyword?: string(name='Keyword', description='IP search keyword', example='xxx', position='Query'),
  pageIndex?: int32(name='PageIndex', description='Pagination index, starting from 1', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='Page size', example='10', position='Query'),
}

model DedicatedIpListResponseBody = {
  currentPage?: int32(name='CurrentPage', description='Current page', example='1'),
  hasMore?: boolean(name='HasMore', description='Whether there is a next page', example='false'),
  ips?: [ 
    {
      expiredTime?: string(name='ExpiredTime', description='Expiration time', example='2025-06-12T09:19:20Z'),
      id?: string(name='Id', description='IP ID, consistent with the purchased instance ID', example='xxx'),
      instanceId?: string(name='InstanceId', description='Purchased instance ID', example='xxx'),
      ip?: string(name='Ip', description='IP address', example='xxx'),
      ipExt?: {
        autoRenewal?: boolean(name='AutoRenewal', description='Whether auto-renewal is enabled', example='false'),
        hasSendMail?: boolean(name='HasSendMail', description='Whether an email has been sent', example='true'),
        lastWarmUpTypeChangedTime?: string(name='LastWarmUpTypeChangedTime'),
      }(name='IpExt', description='Extended information'),
      ipPoolName?: string(name='IpPoolName', description='Name of the IP pool', example='xxx'),
      startTime?: string(name='StartTime', description='Purchase time', example='2025-05-12T09:19:20Z'),
      status?: string(name='Status', description='IP status', example='sold'),
      warmupStatus?: string(name='WarmupStatus', description='Warm-up status', example='finish'),
      warmupType?: string(name='WarmupType', description='Warm-up method', example='cusSelfManager'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='Ips', description='IP list'),
  pageSize?: int32(name='PageSize', description='Page size', example='10'),
  requestId?: string(name='RequestId', description='Request ID', example='xxx'),
  totalCounts?: int32(name='TotalCounts', description='Total amount of purchased IP data', example='5'),
}

model DedicatedIpListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DedicatedIpListResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DedicatedIpList  DedicatedIpListRequest
  * @return DedicatedIpListResponse
 */
async function dedicatedIpList(request: DedicatedIpListRequest): DedicatedIpListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DedicatedIpList', 'POST', '/', 'json', false, 'json', request);
}

model DedicatedIpNonePoolListRequest {
  regionId?: string(name='RegionId', position='Host'),
}

model DedicatedIpNonePoolListResponseBody = {
  ips?: [ 
    {
      id?: string(name='Id', description='Purchased instance ID', example='xxx'),
      ip?: string(name='Ip', description='IP address', example='xxx'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='Ips', description='Information on IPs not added to the IP pool'),
  requestId?: string(name='RequestId', description='Request ID', example='xxx'),
}

model DedicatedIpNonePoolListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DedicatedIpNonePoolListResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DedicatedIpNonePoolList  DedicatedIpNonePoolListRequest
  * @return DedicatedIpNonePoolListResponse
 */
async function dedicatedIpNonePoolList(request: DedicatedIpNonePoolListRequest): DedicatedIpNonePoolListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DedicatedIpNonePoolList', 'POST', '/', 'json', false, 'json', request);
}

model DedicatedIpPoolCreateRequest {
  regionId?: string(name='RegionId', position='Host'),
  buyResourceIds?: string(name='BuyResourceIds', description='Purchased IP instance IDs, separated by commas; derived from the IP purchase instance IDs returned by the DedicatedIpNonePoolList interface.', example='xxx,xxx', position='Query'),
  name?: string(name='Name', description='IP pool name;
Length should be 1-50 characters, allowing English letters, numbers, _, and -. The name cannot be modified after the IP pool is created.', example='xxx', minLength=1, maxLength=50, position='Query'),
}

model DedicatedIpPoolCreateResponseBody = {
  id?: string(name='Id', description='IP pool ID', example='xxx'),
  requestId?: string(name='RequestId', description='Request ID', example='xxx'),
}

model DedicatedIpPoolCreateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DedicatedIpPoolCreateResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DedicatedIpPoolCreate  DedicatedIpPoolCreateRequest
  * @return DedicatedIpPoolCreateResponse
 */
async function dedicatedIpPoolCreate(request: DedicatedIpPoolCreateRequest): DedicatedIpPoolCreateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DedicatedIpPoolCreate', 'POST', '/', 'json', false, 'json', request);
}

model DedicatedIpPoolDeleteRequest {
  regionId?: string(name='RegionId', position='Host'),
  id?: string(name='Id', example='xxx', position='Query'),
}

model DedicatedIpPoolDeleteResponseBody = {
  requestId?: string(name='RequestId', example='xxx'),
}

model DedicatedIpPoolDeleteResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DedicatedIpPoolDeleteResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DedicatedIpPoolDelete  DedicatedIpPoolDeleteRequest
  * @return DedicatedIpPoolDeleteResponse
 */
async function dedicatedIpPoolDelete(request: DedicatedIpPoolDeleteRequest): DedicatedIpPoolDeleteResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DedicatedIpPoolDelete', 'POST', '/', 'json', false, 'json', request);
}

model DedicatedIpPoolListRequest {
  regionId?: string(name='RegionId', position='Host'),
  keyword?: string(name='Keyword', description='Search keyword for the name', example='xxx', position='Query'),
  pageIndex?: int32(name='PageIndex', description='Page index, starting from 1', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='Number of items per page', example='10', position='Query'),
}

model DedicatedIpPoolListResponseBody = {
  currentPage?: string(name='CurrentPage', description='Current page', example='1'),
  hasMore?: boolean(name='HasMore', description='Whether there is a next page', example='false'),
  ipPools?: [ 
    {
      createTime?: string(name='CreateTime', description='Creation time', example='2025-05-23T07:41:43Z'),
      id?: string(name='Id', description='IP pool ID', example='xxx'),
      ipCount?: int32(name='IpCount', description='Number of source IP addresses', example='1'),
      ips?: [ 
        {
          id?: string(name='Id', description='Instance purchase ID', example='xxx'),
          ip?: string(name='Ip', description='IP address', example='xxx'),
          zoneId?: string(name='ZoneId'),
        }
      ](name='Ips', description='List of IPs'),
      name?: string(name='Name', description='IP pool name', example='xxx'),
    }
  ](name='IpPools', description='List of IP pools'),
  pageSize?: string(name='PageSize', description='Page size', example='10'),
  requestId?: string(name='RequestId', description='Request ID', example='xxx'),
  totalCounts?: int32(name='TotalCounts', description='Total number of data under the current request conditions', example='5'),
}

model DedicatedIpPoolListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DedicatedIpPoolListResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DedicatedIpPoolList  DedicatedIpPoolListRequest
  * @return DedicatedIpPoolListResponse
 */
async function dedicatedIpPoolList(request: DedicatedIpPoolListRequest): DedicatedIpPoolListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DedicatedIpPoolList', 'POST', '/', 'json', false, 'json', request);
}

model DedicatedIpPoolUpdateRequest {
  regionId?: string(name='RegionId', position='Host'),
  buyResourceIds?: string(name='BuyResourceIds', description='Purchased IP instance IDs, separated by commas; sourced from the DedicatedIpNonePoolList API\\"s returned IP purchase instance IDs', example='xxx,xxx', position='Query'),
  id?: string(name='Id', description='IP pool ID', example='xxx', position='Query'),
  updateResource?: boolean(name='UpdateResource', description='Whether to change the associated IP, enter true', example='true', position='Query'),
}

model DedicatedIpPoolUpdateResponseBody = {
  id?: string(name='Id', description='IP pool ID', example='xxx'),
  requestId?: string(name='RequestId', description='Request ID', example='xxx'),
}

model DedicatedIpPoolUpdateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DedicatedIpPoolUpdateResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DedicatedIpPoolUpdate  DedicatedIpPoolUpdateRequest
  * @return DedicatedIpPoolUpdateResponse
 */
async function dedicatedIpPoolUpdate(request: DedicatedIpPoolUpdateRequest): DedicatedIpPoolUpdateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DedicatedIpPoolUpdate', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDomainRequest {
  domainId: int32(name='DomainId', description='Domain ID.

This parameter is required.', example='326***', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteDomainResponseBody = {
  requestId?: string(name='RequestId', description='Request ID.', example='E3DFF97B-00CF-5333-8125-3D6819471984'),
}

model DeleteDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDomainResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteDomain  DeleteDomainRequest
  * @return DeleteDomainResponse
 */
async function deleteDomain(request: DeleteDomainRequest): DeleteDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDomain', 'POST', '/', 'json', false, 'json', request);
}

model DeleteInvalidAddressRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  toAddress?: string(name='ToAddress', description='Target address', example='test1***@example.net', position='Query'),
}

model DeleteInvalidAddressResponseBody = {
  requestId?: string(name='RequestId', description='Request ID', example='2D086F6-xxxx-xxxx-xxxx-006DED011A85'),
}

model DeleteInvalidAddressResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteInvalidAddressResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteInvalidAddress  DeleteInvalidAddressRequest
  * @return DeleteInvalidAddressResponse
 */
async function deleteInvalidAddress(request: DeleteInvalidAddressRequest): DeleteInvalidAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteInvalidAddress', 'POST', '/', 'json', false, 'json', request);
}

model DeleteIpfilterByEdmIdRequest {
  fromType?: int32(name='FromType', description='Deprecated, kept for historical compatibility.', example='1', minimum=1, maximum=2, position='Query'),
  id?: string(name='Id', description='Record ID', example='10120', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteIpfilterByEdmIdResponseBody = {
  requestId?: string(name='RequestId', description='Request ID.', example='E3DFF97B-00CF-5333-8125-3D6819471984'),
}

model DeleteIpfilterByEdmIdResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteIpfilterByEdmIdResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteIpfilterByEdmId  DeleteIpfilterByEdmIdRequest
  * @return DeleteIpfilterByEdmIdResponse
 */
async function deleteIpfilterByEdmId(request: DeleteIpfilterByEdmIdRequest): DeleteIpfilterByEdmIdResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteIpfilterByEdmId', 'POST', '/', 'json', false, 'json', request);
}

model DeleteMailAddressRequest {
  mailAddressId: int32(name='MailAddressId', description='Mail Address ID

This parameter is required.', example='23457', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteMailAddressResponseBody = {
  requestId?: string(name='RequestId', description='Request ID', example='10A1AD70-E48E-476D-98D9-39BD92193837'),
}

model DeleteMailAddressResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteMailAddressResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteMailAddress  DeleteMailAddressRequest
  * @return DeleteMailAddressResponse
 */
async function deleteMailAddress(request: DeleteMailAddressRequest): DeleteMailAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteMailAddress', 'POST', '/', 'json', false, 'json', request);
}

model DeleteReceiverRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  receiverId: string(name='ReceiverId', description='Receiver list ID

This parameter is required.', example='144adfa772cfe47631de7e86d7da13ae', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteReceiverResponseBody = {
  requestId?: string(name='RequestId', description='Request ID', example='10A1AD70-E48E-476D-98D9-39BD92193837'),
}

model DeleteReceiverResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteReceiverResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteReceiver  DeleteReceiverRequest
  * @return DeleteReceiverResponse
 */
async function deleteReceiver(request: DeleteReceiverRequest): DeleteReceiverResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteReceiver', 'POST', '/', 'json', false, 'json', request);
}

model DeleteReceiverDetailRequest {
  email?: string(name='Email', description='The single recipient to be deleted from the recipient list', example='test@example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  receiverId: string(name='ReceiverId', description='Recipient list ID

This parameter is required.', example='53228b7d80c36257927ecd029ccd3c9a', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteReceiverDetailResponseBody = {
  requestId?: string(name='RequestId', description='Request ID', example='10A1AD70-E48E-476D-98D9-39BD92193837'),
}

model DeleteReceiverDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteReceiverDetailResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteReceiverDetail  DeleteReceiverDetailRequest
  * @return DeleteReceiverDetailResponse
 */
async function deleteReceiverDetail(request: DeleteReceiverDetailRequest): DeleteReceiverDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteReceiverDetail', 'POST', '/', 'json', false, 'json', request);
}

model DeleteTagRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  tagId: int32(name='TagId', description='The ID of the tag

This parameter is required.', example='123', position='Query'),
}

model DeleteTagResponseBody = {
  requestId?: string(name='RequestId', description='Request ID', example='10A1AD70-E48E-476D-98D9-39BD92193837'),
}

model DeleteTagResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteTagResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteTag  DeleteTagRequest
  * @return DeleteTagResponse
 */
async function deleteTag(request: DeleteTagRequest): DeleteTagResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteTag', 'POST', '/', 'json', false, 'json', request);
}

model DescAccountSummaryRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescAccountSummaryResponseBody = {
  dailyQuota?: int32(name='DailyQuota', description='Daily quota', example='2000'),
  dailyRemainFreeQuota?: int32(name='DailyRemainFreeQuota', description='remaining amount of daily free quota', example='100'),
  dayuStatus?: int32(name='DayuStatus', description='Dayu status (deprecated, retained for compatibility reasons.)', example='0'),
  domains?: int32(name='Domains', description='Number of domains', example='1'),
  enableTimes?: int32(name='EnableTimes', description='Effective time', example='0'),
  ipChannelType?: string(name='IpChannelType'),
  mailAddresses?: int32(name='MailAddresses', description='Number of sending addresses', example='0'),
  maxQuotaLevel?: int32(name='MaxQuotaLevel', description='Maximum level', example='10'),
  monthQuota?: int32(name='MonthQuota', description='Monthly quota', example='60000'),
  quotaLevel?: int32(name='QuotaLevel', description='Credit level', example='2'),
  receivers?: int32(name='Receivers', description='Number of recipients', example='0'),
  remainFreeQuota?: int32(name='RemainFreeQuota', description='Remaining amount of total free quota', example='1910'),
  requestId?: string(name='RequestId', description='Request ID', example='82B295BB-7E69-491F-9896-ECEAFF09E1A4'),
  smsRecord?: int32(name='SmsRecord', description='Deprecated, retained for compatibility reasons.', example='0'),
  smsSign?: int32(name='SmsSign', description='Deprecated, retained for compatibility reasons.', example='0'),
  smsTemplates?: int32(name='SmsTemplates', description='Deprecated, retained for compatibility reasons.', example='0'),
  tags?: int32(name='Tags', description='Number of tags', example='0'),
  templates?: int32(name='Templates', description='Number of templates', example='1'),
  userStatus?: int32(name='UserStatus', description='User status:
1 Frozen
2 In arrears
4 Restricted from sending
8 Logically deleted', example='0'),
}

model DescAccountSummaryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescAccountSummaryResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescAccountSummary  DescAccountSummaryRequest
  * @return DescAccountSummaryResponse
 */
async function descAccountSummary(request: DescAccountSummaryRequest): DescAccountSummaryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescAccountSummary', 'POST', '/', 'json', false, 'json', request);
}

model DescDomainRequest {
  domainId: int32(name='DomainId', description='Domain ID. Can be obtained through QueryDomainByParam.

This parameter is required.', example='13464', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  requireRealTimeDnsRecords?: boolean(name='RequireRealTimeDnsRecords', description='Determines whether to perform real-time DNS resolution', example='true', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescDomainResponseBody = {
  cnameAuthStatus?: string(name='CnameAuthStatus', description='CNAME verification flag, 0 for success, 1 for failure.', example='1'),
  cnameConfirmStatus?: string(name='CnameConfirmStatus', description='Indicates whether the CNAME host record has been modified, 1 for modified (reverting to the original value also counts as modification), 0 for not modified.', example='0'),
  cnameRecord?: string(name='CnameRecord', description='Custom part of the CNAME host record', example='dmtrace'),
  createTime?: string(name='CreateTime', description='Creation time', example='2025-03-19T12:49Z'),
  defaultDomain?: string(name='DefaultDomain', description='Whether it is the default domain,

Value: 0 No (this field is deprecated)', example='0'),
  dkimAuthStatus?: string(name='DkimAuthStatus', description='DKIM verification flag, indicating whether the DKIM record set by the user in DNS has passed validation, 0: Passed, 1: Not passed', example='0'),
  dkimPublicKey?: string(name='DkimPublicKey', description='DKIM public key value, the value that users need to set for the DKIM record in DNS', example='v=DKIM1; k=rsa; p=MIGfMA0GCSqGSI...'),
  dkimRR?: string(name='DkimRR', description='DKIM host record, the key that the user needs to set in the DNS for the DKIM record', example='aliyun-cn-hangzhou._domainkey.hangzhou26'),
  dkimRsaLength?: int32(name='DkimRsaLength'),
  dmarcAuthStatus?: int32(name='DmarcAuthStatus', description='DMARC verification flag, indicating whether the DMARC record set by the user in DNS has passed validation, 0: Passed, 1: Not passed', example='1'),
  dmarcHostRecord?: string(name='DmarcHostRecord', description='DMARC host record value', example='_dmarc.xxx'),
  dmarcRecord?: string(name='DmarcRecord', description='DMARC record value', example='v=DMARC1;p=none;rua=mailto:dmarc_report@service.aliyun.com'),
  dnsDmarc?: string(name='DnsDmarc', description='DMARC record value resolved through the public domain name', example='v=DMARC1;p=none;rua=mailto:dmarc_report@service.aliyun.com'),
  dnsMx?: string(name='DnsMx', description='MX record value resolved from the public network domain', example='mx01.dm.aliyun.com'),
  dnsSpf?: string(name='DnsSpf', description='SPF record value resolved from the public network domain', example='v=xxxx'),
  dnsTxt?: string(name='DnsTxt', description='Ownership record value resolved from the public network domain', example='0c40d5f125af4e42892a'),
  domainId?: string(name='DomainId', description='Domain ID', example='158910'),
  domainName?: string(name='DomainName', description='Domain name', example='test.example.net'),
  domainStatus?: string(name='DomainStatus', description='Domain status. Indicates whether the verification was successful, with values:

- **0**: Available, verified successfully
- **1**: Unavailable, verification failed', example='1'),
  domainType?: string(name='DomainType', description='Ownership record provided by the email push console', example='0c40d5f125af4e42892a'),
  hostRecord?: string(name='HostRecord', description='Host record', example='xxx'),
  icpStatus?: string(name='IcpStatus', description='Filing status. **1** indicates filed, **0** indicates not filed.', example='1'),
  mxAuthStatus?: string(name='MxAuthStatus', description='MX verification flag, 0 for success, 1 for failure.', example='1'),
  mxRecord?: string(name='MxRecord', description='MX record value provided by the email push console', example='mx01.dm.aliyun.com'),
  requestId?: string(name='RequestId', description='Request ID', example='51B74264-46B4-43C8-A9A0-6B8E8BC04F34'),
  spfAuthStatus?: string(name='SpfAuthStatus', description='SPF verification flag, 0 for success, 1 for failure.', example='1'),
  spfRecord?: string(name='SpfRecord', description='SPF record value provided by the email push console', example='include:spf1.dm.aliyun.com'),
  spfRecordV2?: string(name='SpfRecordV2', description='SPF record. Previously, the SPF display content needed to be calculated by the calling end based on the spfRecord in the response. The new field spfRecordV2 replaces spfRecord, and the calling end can directly display this field after obtaining it;', example='v=spf1 include:spf1.dm.aliyun.com -all'),
  tlDomainName?: string(name='TlDomainName', description='Primary domain', example='example.com'),
  tracefRecord?: string(name='TracefRecord', description='CNAME record value provided by the email push console', example='tracedm.aliyuncs.com'),
}

model DescDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescDomainResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescDomain  DescDomainRequest
  * @return DescDomainResponse
 */
async function descDomain(request: DescDomainRequest): DescDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescDomain', 'POST', '/', 'json', false, 'json', request);
}

model GetDedicatedIpWarmUpDetailRequest {
  regionId?: string(name='RegionId', position='Host'),
  dedicatedIp?: string(name='DedicatedIp', position='Query'),
  endDayMark?: long(name='EndDayMark', position='Query'),
  esp?: string(name='Esp', position='Query'),
  startDayMark?: long(name='StartDayMark', position='Query'),
}

model GetDedicatedIpWarmUpDetailResponseBody = {
  detail?: [ 
    {
      dayMark?: long(name='DayMark'),
      deliverCounts?: long(name='DeliverCounts'),
      esp?: string(name='Esp'),
      sendCounts?: long(name='SendCounts'),
    }
  ](name='Detail'),
  requestId?: string(name='RequestId'),
}

model GetDedicatedIpWarmUpDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDedicatedIpWarmUpDetailResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetDedicatedIpWarmUpDetail  GetDedicatedIpWarmUpDetailRequest
  * @return GetDedicatedIpWarmUpDetailResponse
 */
async function getDedicatedIpWarmUpDetail(request: GetDedicatedIpWarmUpDetailRequest): GetDedicatedIpWarmUpDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetDedicatedIpWarmUpDetail', 'POST', '/', 'json', false, 'json', request);
}

model GetDedicatedIpWarmUpInfoRequest {
  regionId?: string(name='RegionId', position='Host'),
  dedicatedIp?: string(name='DedicatedIp', position='Query'),
}

model GetDedicatedIpWarmUpInfoResponseBody = {
  info?: [ 
    {
      esp?: string(name='Esp'),
      finished?: boolean(name='Finished'),
    }
  ](name='Info'),
  requestId?: string(name='RequestId'),
}

model GetDedicatedIpWarmUpInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDedicatedIpWarmUpInfoResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetDedicatedIpWarmUpInfo  GetDedicatedIpWarmUpInfoRequest
  * @return GetDedicatedIpWarmUpInfoResponse
 */
async function getDedicatedIpWarmUpInfo(request: GetDedicatedIpWarmUpInfoRequest): GetDedicatedIpWarmUpInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetDedicatedIpWarmUpInfo', 'POST', '/', 'json', false, 'json', request);
}

model GetIpProtectionRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model GetIpProtectionResponseBody = {
  ipProtection?: string(name='IpProtection', description='IP protection switch, On: 1 Off: 0', example='0'),
  requestId?: string(name='RequestId', description='Request ID', example='B30E5A62-2E64-577D-A70E-8C6781D6C975'),
}

model GetIpProtectionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetIpProtectionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetIpProtection  GetIpProtectionRequest
  * @return GetIpProtectionResponse
 */
async function getIpProtection(request: GetIpProtectionRequest): GetIpProtectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetIpProtection', 'POST', '/', 'json', false, 'json', request);
}

model GetIpfilterListRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model GetIpfilterListResponseBody = {
  pageNumber?: int32(name='PageNumber', description='Current page number', example='1'),
  pageSize?: int32(name='PageSize', description='Number of items per page', example='10'),
  requestId?: string(name='RequestId', description='Request ID', example='84DD77C7-A091-5139-9530-2D1F7CCE59E0'),
  totalCount?: int32(name='TotalCount', description='Total count', example='1'),
  data?: {
    ipfilters?: [ 
    {
      createTime?: string(name='CreateTime', description='timestamp', example='1653547140'),
      id?: string(name='Id', description='Record ID', example='10083'),
      ipAddress?: string(name='IpAddress', description='IP address/IP range/IP segment', example='xxx.xxx.xxx.xxx
xxx.xxx.xxx.xxx-xxx.xxx.xxx.xxx
xxx.xxx.xxx.xxx/xxx'),
    }
  ](name='ipfilters')
  }(name='data', description='Data records'),
}

model GetIpfilterListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetIpfilterListResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetIpfilterList  GetIpfilterListRequest
  * @return GetIpfilterListResponse
 */
async function getIpfilterList(request: GetIpfilterListRequest): GetIpfilterListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetIpfilterList', 'POST', '/', 'json', false, 'json', request);
}

model GetSuppressionListLevelRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model GetSuppressionListLevelResponseBody = {
  requestId?: string(name='RequestId'),
  suppressionListLevel?: string(name='SuppressionListLevel'),
}

model GetSuppressionListLevelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetSuppressionListLevelResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetSuppressionListLevel  GetSuppressionListLevelRequest
  * @return GetSuppressionListLevelResponse
 */
async function getSuppressionListLevel(request: GetSuppressionListLevelRequest): GetSuppressionListLevelResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetSuppressionListLevel', 'POST', '/', 'json', false, 'json', request);
}

model GetTrackListRequest {
  accountName?: string(name='AccountName', description='Sender address.

> If not filled, it represents all addresses; if TagName is provided, this parameter must not be empty.', example='test@example.com', position='Query'),
  dedicatedIp?: string(name='DedicatedIp', position='Query'),
  dedicatedIpPoolId?: string(name='DedicatedIpPoolId', position='Query'),
  endTime: string(name='EndTime', description='End time, the span between start and end time cannot exceed 7 days. Format: yyyy-MM-dd.

This parameter is required.', example='2019-09-29', position='Query'),
  esp?: string(name='Esp', position='Query'),
  offset?: string(name='Offset', description='For the first query, set to 0; for subsequent queries, fixed at 1. 1 indicates pagination in ascending order by time. (This field is deprecated)', example='(This field is deprecated)', position='Query'),
  offsetCreateTime?: string(name='OffsetCreateTime', description='Used for pagination. Not set for the first query, but for subsequent queries, it should be set to the value of OffsetCreateTime from the previous response. (This field is deprecated)', example='(This field is deprecated)', position='Query'),
  offsetCreateTimeDesc?: string(name='OffsetCreateTimeDesc', description='(This field is deprecated)', example='(This field is deprecated)', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: string(name='PageNumber', description='Page number', example='1', position='Query'),
  pageSize?: string(name='PageSize', description='Page size', example='10', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTime: string(name='StartTime', description='Start time, which cannot be earlier than 30 days. Format: yyyy-MM-dd.

This parameter is required.', example='2019-09-29', position='Query'),
  tagName?: string(name='TagName', description='Tag name', example='tagname', position='Query'),
  total?: string(name='Total', description='(This field is deprecated)', example='(This field is deprecated)', position='Query'),
}

model GetTrackListResponseBody = {
  offsetCreateTime?: string(name='OffsetCreateTime', description='Used for pagination. Not set for the first query, but for subsequent queries, it should be set to the value of OffsetCreateTime from the previous response. (This field is deprecated)', example='(This field is deprecated)'),
  offsetCreateTimeDesc?: string(name='OffsetCreateTimeDesc', description='(This field is deprecated)', example='(This field is deprecated)'),
  pageNo?: int32(name='PageNo', description='Current page number', example='1'),
  pageSize?: int32(name='PageSize', description='Number of items per page', example='10'),
  requestId?: string(name='RequestId', description='Request ID', example='10A1AD70-E48E-476D-98D9-39BD92193837'),
  total?: int32(name='Total', description='Total number of items', example='100'),
  totalPages?: int32(name='TotalPages'),
  data?: {
    stat?: [ 
    {
      createTime?: string(name='CreateTime', description='Creation time', example='2019-09-29T13:28Z'),
      rcptClickCount?: string(name='RcptClickCount', description='Click count', example='0'),
      rcptClickRate?: string(name='RcptClickRate', description='Click rate', example='0'),
      rcptOpenCount?: string(name='RcptOpenCount', description='Number of Opens', example='0'),
      rcptOpenRate?: string(name='RcptOpenRate', description='Open rate', example='0'),
      rcptUniqueClickCount?: string(name='RcptUniqueClickCount', description='Unique click count', example='0'),
      rcptUniqueClickRate?: string(name='RcptUniqueClickRate', description='Unique click rate', example='0'),
      rcptUniqueOpenCount?: string(name='RcptUniqueOpenCount', description='Unique open count', example='0'),
      rcptUniqueOpenRate?: string(name='RcptUniqueOpenRate', description='Unique open rate', example='0'),
      totalNumber?: string(name='TotalNumber', description='Total number', example='0'),
    }
  ](name='stat')
  }(name='data', description='Tracking data records'),
}

model GetTrackListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetTrackListResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetTrackList  GetTrackListRequest
  * @return GetTrackListResponse
 */
async function getTrackList(request: GetTrackListRequest): GetTrackListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetTrackList', 'POST', '/', 'json', false, 'json', request);
}

model GetTrackListByMailFromAndTagNameRequest {
  accountName?: string(name='AccountName', description='Sender address.

> If not filled, it represents all addresses; if there is a TagName, this parameter must not be empty.', example='e-service@amegroups.cn', position='Query'),
  dedicatedIp?: string(name='DedicatedIp', position='Query'),
  dedicatedIpPoolId?: string(name='DedicatedIpPoolId', position='Query'),
  endTime: string(name='EndTime', description='End time, with a span from the start time that cannot exceed 15 days. Format: yyyy-MM-dd.

This parameter is required.', example='2019-09-29', position='Query'),
  esp?: string(name='Esp', position='Query'),
  offset?: string(name='Offset', description='For the first query, set to 0; for subsequent queries, fixed at 1. 1 indicates pagination in ascending order by time. (This field is deprecated)', example='（本字段已废弃）', position='Query'),
  offsetCreateTime?: string(name='OffsetCreateTime', description='Used for pagination. Not set for the first query; for subsequent queries, set to the value of OffsetCreateTime from the previous response. (This field is deprecated)', example='（本字段已废弃）', position='Query'),
  offsetCreateTimeDesc?: string(name='OffsetCreateTimeDesc', description='(This field is deprecated)', example='（本字段已废弃）', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: string(name='PageNumber', description='Current page number', example='1', position='Query'),
  pageSize?: string(name='PageSize', description='Page size', example='10', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTime: string(name='StartTime', description='Start time, which cannot be earlier than 30 days. Format: yyyy-MM-dd.

This parameter is required.', example='2019-09-29', position='Query'),
  tagName?: string(name='TagName', description='Email tag. If not filled, it represents all tags.', example='Subscription', position='Query'),
  total?: string(name='Total', description='(This field is deprecated)', example='（本字段已废弃）', position='Query'),
}

model GetTrackListByMailFromAndTagNameResponseBody = {
  offsetCreateTime?: string(name='OffsetCreateTime', description='Used for pagination. Not set for the first query; for subsequent queries, set to the value of OffsetCreateTime from the previous response. (This field is deprecated)', example='（本字段已废弃）'),
  offsetCreateTimeDesc?: string(name='OffsetCreateTimeDesc', description='(This field is deprecated)', example='（本字段已废弃）'),
  pageNo?: int32(name='PageNo', description='Current page number', example='1'),
  pageSize?: int32(name='PageSize', description='Page size', example='20'),
  requestId?: string(name='RequestId', description='Request ID', example='10A1AD70-E48E-476D-98D9-39BD92193837'),
  total?: int32(name='Total', description='(This field is deprecated)', example='4'),
  totalPages?: string(name='TotalPages'),
  trackList?: {
    stat?: [ 
    {
      createTime?: string(name='CreateTime', description='Creation time', example='2025-01-11T10:11Z'),
      rcptClickCount?: string(name='RcptClickCount', description='Click count', example='0'),
      rcptClickRate?: string(name='RcptClickRate', description='Click rate', example='0'),
      rcptOpenCount?: string(name='RcptOpenCount', description='Number of opens', example='0'),
      rcptOpenRate?: string(name='RcptOpenRate', description='Open rate', example='0'),
      rcptUniqueClickCount?: string(name='RcptUniqueClickCount', description='Unique click count', example='0'),
      rcptUniqueClickRate?: string(name='RcptUniqueClickRate', description='Unique click rate', example='0'),
      rcptUniqueOpenCount?: string(name='RcptUniqueOpenCount', description='Unique open count', example='0'),
      rcptUniqueOpenRate?: string(name='RcptUniqueOpenRate', description='Unique open rate', example='0'),
      totalNumber?: string(name='TotalNumber', description='Total number', example='0'),
    }
  ](name='Stat')
  }(name='TrackList', description='Tracking data records'),
}

model GetTrackListByMailFromAndTagNameResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetTrackListByMailFromAndTagNameResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetTrackListByMailFromAndTagName  GetTrackListByMailFromAndTagNameRequest
  * @return GetTrackListByMailFromAndTagNameResponse
 */
async function getTrackListByMailFromAndTagName(request: GetTrackListByMailFromAndTagNameRequest): GetTrackListByMailFromAndTagNameResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetTrackListByMailFromAndTagName', 'POST', '/', 'json', false, 'json', request);
}

model GetUserRequest {
  regionId?: string(name='RegionId', position='Host'),
}

model GetUserResponseBody = {
  data?: {
    enableEventbridge?: boolean(name='EnableEventbridge', description='Whether EventBridge is enabled', example='true'),
  }(name='Data', description='Returned Content'),
  requestId?: string(name='RequestId', description='Request ID', example='10A1AD70-E48E-476D-98D9-39BD92193837'),
}

model GetUserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetUserResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetUser  GetUserRequest
  * @return GetUserResponse
 */
async function getUser(request: GetUserRequest): GetUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetUser', 'GET', '/', 'json', false, 'json', request);
}

model ListBlockSendingRequest {
  regionId?: string(name='RegionId', position='Host'),
  beginTime?: int32(name='BeginTime', example='1731463398242', position='Query'),
  blockEmail?: string(name='BlockEmail', example='xxxx@rcpt.com', position='Query'),
  blockType: string(name='BlockType', description='This parameter is required.', example='UNSUB', position='Query'),
  endTime?: int32(name='EndTime', example='1732463398242', position='Query'),
  maxResults?: int32(name='MaxResults', example='50', position='Query'),
  nextToken?: string(name='NextToken', example='xxxxxyyyyyy', position='Query'),
  senderEmail?: string(name='SenderEmail', example='xxxx@sender.com', position='Query'),
}

model ListBlockSendingResponseBody = {
  data?: [ 
    {
      blockEmail?: string(name='BlockEmail', example='xxxx@rcpt.com'),
      blockTime?: int32(name='BlockTime', example='1723259364'),
      reason?: int32(name='Reason', example='1'),
      sendTime?: int32(name='SendTime', example='1723249364'),
      senderEmail?: string(name='SenderEmail', example='xxxx@sender.com'),
    }
  ](name='Data'),
  maxResults?: int32(name='MaxResults', example='50'),
  nextToken?: string(name='NextToken', example='xxxxyyyy'),
  requestId?: string(name='RequestId', example='XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX'),
}

model ListBlockSendingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListBlockSendingResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListBlockSending  ListBlockSendingRequest
  * @return ListBlockSendingResponse
 */
async function listBlockSending(request: ListBlockSendingRequest): ListBlockSendingResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListBlockSending', 'POST', '/', 'json', false, 'json', request);
}

model ListUserSuppressionRequest {
  regionId?: string(name='RegionId', position='Host'),
  address?: string(name='Address', description='Email address or domain name', example='test@example.net', position='Query'),
  endBounceTime?: int32(name='EndBounceTime', description='End time of the last bounce hit, timestamp, accurate to the second. The span between start and end times cannot exceed 7 days.', example='1715669077', position='Query'),
  endCreateTime?: int32(name='EndCreateTime', description='End creation time, timestamp, accurate to the second. The span between start and end times cannot exceed 7 days.', example='1715669077', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNo?: int32(name='PageNo', description='Current page number', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='Page size', example='10', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startBounceTime?: int32(name='StartBounceTime', description='Start time of the last bounce hit, timestamp, accurate to the second.', example='1715668852', position='Query'),
  startCreateTime?: int32(name='StartCreateTime', description='Start creation time, timestamp, accurate to the second.', example='1715668852', position='Query'),
}

model ListUserSuppressionResponseBody = {
  data?: {
    userSuppressions?: [ 
    {
      address?: string(name='Address', description='Email address or domain name', example='test@example.net'),
      createTime?: int32(name='CreateTime', description='Creation time, timestamp, accurate to the second.', example='1715667435'),
      lastBounceTime?: int32(name='LastBounceTime', description='Last bounce hit time, timestamp, accurate to the second.', example='1715667451'),
      suppressionId?: int32(name='SuppressionId', description='Invalid address ID', example='59511'),
      type?: string(name='Type', description='Source of entry, invalid address type
- system
- user', example='user'),
    }
  ](name='UserSuppressions')
  }(name='Data', description='Returned results.'),
  pageNumber?: int32(name='PageNumber', description='Page number', example='1'),
  pageSize?: int32(name='PageSize', description='Page size', example='10'),
  requestId?: string(name='RequestId', description='Request ID', example='1A846D66-5EC7-551B-9687-5BF1963DCFC1'),
  totalCount?: int32(name='TotalCount', description='Total count', example='2'),
}

model ListUserSuppressionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListUserSuppressionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListUserSuppression  ListUserSuppressionRequest
  * @return ListUserSuppressionResponse
 */
async function listUserSuppression(request: ListUserSuppressionRequest): ListUserSuppressionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListUserSuppression', 'POST', '/', 'json', false, 'json', request);
}

model ModifyMailAddressRequest {
  mailAddressId: int32(name='MailAddressId', description='Sending address ID

This parameter is required.', example='1344565', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  password?: string(name='Password', description='- Length should be 10 to 20 characters, and must include numbers, uppercase letters, and lowercase letters.

- Must contain at least 2 digits, 2 uppercase letters, and 2 lowercase letters, and neither the digits nor the letters can consist of a single character repeated.

- Cannot be the same as the last set password.', example='DM1mail1234', position='Query'),
  replyAddress?: string(name='ReplyAddress', description='Reply address', example='a***@example.net', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyMailAddressResponseBody = {
  requestId?: string(name='RequestId', description='Request ID', example='10A1AD70-E48E-476D-98D9-39BD92193837'),
}

model ModifyMailAddressResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyMailAddressResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ModifyMailAddress  ModifyMailAddressRequest
  * @return ModifyMailAddressResponse
 */
async function modifyMailAddress(request: ModifyMailAddressRequest): ModifyMailAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyMailAddress', 'POST', '/', 'json', false, 'json', request);
}

model ModifyPWByDomainRequest {
  domainName: string(name='DomainName', description='Domain name, length 1-50, can include numbers, uppercase letters, lowercase letters, ., and -.

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  password: string(name='Password', description='- Length should be between 10 to 20 characters, and must contain numbers, uppercase letters, and lowercase letters.

- At least 2 digits, 2 uppercase letters, and 2 lowercase letters are required, and neither digits nor letters can consist of a single character repeated.

- Cannot be the same as the last set password.

This parameter is required.', example='DM1mail1234', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyPWByDomainResponseBody = {
  code?: string(name='Code', description='Status code', example='OK'),
  message?: string(name='Message', description='Description of the status code', example='test'),
  requestId?: string(name='RequestId', description='Request ID', example='02B2A890-CBD8-4806-9BCA-C93190CE7EF6'),
  success?: boolean(name='Success', description='Whether it was successful', example='true'),
}

model ModifyPWByDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyPWByDomainResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ModifyPWByDomain  ModifyPWByDomainRequest
  * @return ModifyPWByDomainResponse
 */
async function modifyPWByDomain(request: ModifyPWByDomainRequest): ModifyPWByDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyPWByDomain', 'POST', '/', 'json', false, 'json', request);
}

model ModifyTagRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  tagDescription?: string(name='TagDescription', description='Tag Description', example='test description', position='Query'),
  tagId: int32(name='TagId', description='Tag ID

This parameter is required.', example='100674', position='Query'),
  tagName: string(name='TagName', description='Tag Name

This parameter is required.', example='test', position='Query'),
}

model ModifyTagResponseBody = {
  requestId?: string(name='RequestId', description='Request ID', example='00BD30D8-2E86-523A-BFC7-63B7FF931A06'),
}

model ModifyTagResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyTagResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ModifyTag  ModifyTagRequest
  * @return ModifyTagResponse
 */
async function modifyTag(request: ModifyTagRequest): ModifyTagResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyTag', 'POST', '/', 'json', false, 'json', request);
}

model QueryDomainByParamRequest {
  keyWord?: string(name='KeyWord', description='Domain name, length 1-50, can include numbers, uppercase and lowercase letters, ., -.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNo?: int32(name='PageNo', description='Current page number. Default: 1', example='1', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', description='Number of items per page, default: 10', example='10', minimum=1, maximum=1000, position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  status?: int32(name='Status', description='- 0 indicates normal
- 1 indicates abnormal', example='0', minimum=0, maximum=2, position='Query'),
}

model QueryDomainByParamResponseBody = {
  pageNumber?: int32(name='PageNumber', description='Current page number', example='1'),
  pageSize?: int32(name='PageSize', description='Page size', example='50'),
  requestId?: string(name='RequestId', description='Request ID', example='8C90CCD3-627C-4F87-AD8C-2F03146071EB'),
  totalCount?: int32(name='TotalCount', description='Total count', example='2'),
  data?: {
    domain?: [ 
    {
      cnameAuthStatus?: string(name='CnameAuthStatus', description='Track verification', example='0'),
      confirmStatus?: string(name='ConfirmStatus', description='CName verification status, success: 0; failure: 1', example='0'),
      createTime?: string(name='CreateTime', description='Creation time', example='2019-09-29T13:28Z'),
      domainId?: string(name='DomainId', description='Domain ID', example='158923'),
      domainName?: string(name='DomainName', description='Domain name', example='example.com'),
      domainRecord?: string(name='DomainRecord', description='Domain record', example='6bd86901b9fe4618a046'),
      domainStatus?: string(name='DomainStatus', description='Domain status.

- 0: Available, verified
- 1: Unavailable, verification failed', example='0'),
      icpStatus?: string(name='IcpStatus', description='ICP filing status.

- 1 indicates filed
- 0 indicates not filed', example='1'),
      mxAuthStatus?: string(name='MxAuthStatus', description='MX authentication status, success: 0, failure: 1.', example='0'),
      spfAuthStatus?: string(name='SpfAuthStatus', description='SPF authentication status, success: 0, failure: 1.', example='0'),
      utcCreateTime?: long(name='UtcCreateTime', description='Creation time in UTC format.', example='1569734892'),
    }
  ](name='domain')
  }(name='data', description='List of domains'),
}

model QueryDomainByParamResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryDomainByParamResponseBody(name='body'),
}

/**
  * @param request  the request parameters of QueryDomainByParam  QueryDomainByParamRequest
  * @return QueryDomainByParamResponse
 */
async function queryDomainByParam(request: QueryDomainByParamRequest): QueryDomainByParamResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryDomainByParam', 'POST', '/', 'json', false, 'json', request);
}

model QueryInvalidAddressRequest {
  endTime?: string(name='EndTime', description='End time, with a span from the start time that cannot exceed 30 days, in the format yyyy-MM-dd.', example='2019-09-29', position='Query'),
  keyWord?: string(name='KeyWord', description='Keyword. If not provided, it represents all invalid addresses.', example='info', position='Query'),
  length?: int32(name='Length', description='Number of items per request.', example='100', minimum=1, maximum=100, position='Query'),
  nextStart?: string(name='NextStart', description='Request starting position.', example='***', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTime?: string(name='StartTime', description='Start time, which cannot be earlier than 30 days ago, in the format yyyy-MM-dd.', example='2019-09-29', position='Query'),
}

model QueryInvalidAddressResponseBody = {
  nextStart?: string(name='NextStart', description='Next request starting position.', example='2'),
  requestId?: string(name='RequestId', description='Request ID.', example='95A7D497-F8DD-4834-B81E-C1783236E55F'),
  totalCount?: int32(name='TotalCount', description='Total count.', example='3'),
  data?: {
    mailDetail?: [ 
    {
      lastUpdateTime?: string(name='LastUpdateTime', description='Update time.', example='2021-04-28T17:11Z'),
      toAddress?: string(name='ToAddress', description='Recipient address.', example='toaddress@example.com'),
      utcLastUpdateTime?: long(name='UtcLastUpdateTime', description='Update time (in timestamp format).', example='1619601108'),
    }
  ](name='mailDetail')
  }(name='data', description='Records.'),
}

model QueryInvalidAddressResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryInvalidAddressResponseBody(name='body'),
}

/**
  * @description Retrieve deduplicated invalid address information. If an email is sent to the same invalid address multiple times, only the first occurrence will be recorded. The query should be based on the time when the address was first classified as invalid.
  * @param request  the request parameters of QueryInvalidAddress  QueryInvalidAddressRequest
  * @return QueryInvalidAddressResponse
 */
async function queryInvalidAddress(request: QueryInvalidAddressRequest): QueryInvalidAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryInvalidAddress', 'POST', '/', 'json', false, 'json', request);
}

model QueryMailAddressByParamRequest {
  keyWord?: string(name='KeyWord', description='Email address, length 1-60, supports numbers, letters, ., -, @.', example='sender@example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNo?: int32(name='PageNo', description='Current page number, default: 1', example='1', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', description='Page size, default: 10', example='10', minimum=1, maximum=500, position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  sendtype?: string(name='Sendtype', description='Sending address type. Values:

- batch: bulk email
- trigger: triggered email', example='batch', position='Query'),
}

model QueryMailAddressByParamResponseBody = {
  pageNumber?: int32(name='PageNumber', description='Current page number', example='1'),
  pageSize?: int32(name='PageSize', description='Page size', example='10'),
  requestId?: string(name='RequestId', description='Request ID', example='95A7D497-F8DD-4834-B81E-C1783236E55F'),
  totalCount?: int32(name='TotalCount', description='Total count', example='2'),
  data?: {
    mailAddress?: [ 
    {
      accountName?: string(name='AccountName', description='Sending address', example='sender@example.com'),
      accountStatus?: string(name='AccountStatus', description='Account status, frozen: 1, normal: 0.', example='0'),
      createTime?: string(name='CreateTime', description='Creation time', example='2019-09-29T13:28Z'),
      dailyCount?: string(name='DailyCount', description='Daily quota limit', example='10000'),
      dailyReqCount?: string(name='DailyReqCount', description='Daily quota', example='100'),
      domainStatus?: string(name='DomainStatus', description='Domain status, 0 indicates normal, 1 indicates abnormal.', example='0'),
      mailAddressId?: string(name='MailAddressId', description='Sending address ID', example='12122'),
      monthCount?: string(name='MonthCount', description='Monthly quota limit', example='300000'),
      monthReqCount?: string(name='MonthReqCount', description='Monthly quota', example='20000'),
      replyAddress?: string(name='ReplyAddress', description='Reply address', example='test@example.com'),
      replyStatus?: string(name='ReplyStatus', description='Reply address status', example='0'),
      sendtype?: string(name='Sendtype', description='Sending address type. Values:

- batch: bulk email
- trigger: triggered email', example='batch'),
    }
  ](name='mailAddress')
  }(name='data', description='List of sending addresses'),
}

model QueryMailAddressByParamResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMailAddressByParamResponseBody(name='body'),
}

/**
  * @param request  the request parameters of QueryMailAddressByParam  QueryMailAddressByParamRequest
  * @return QueryMailAddressByParamResponse
 */
async function queryMailAddressByParam(request: QueryMailAddressByParamRequest): QueryMailAddressByParamResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryMailAddressByParam', 'POST', '/', 'json', false, 'json', request);
}

model QueryReceiverByParamRequest {
  keyWord?: string(name='KeyWord', description='Keyword, defaults to all information if not specified', example='mesh-notification', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNo?: int32(name='PageNo', description='Current page number', example='1', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', description='Number of items per page, default: 10', example='10', minimum=1, maximum=50, position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  status?: int32(name='Status', description='Delivery result. If not filled, it represents all statuses. Values:

- 0: Success
- 2: Invalid address
- 3: Spam
- 4: Failure', example='1', minimum=0, maximum=2, position='Query'),
}

model QueryReceiverByParamResponseBody = {
  nextStart?: string(name='NextStart', description='Used for pagination. If there are more results, set this returned value to the NextStart in the next request.', example='6aec200853#102#1638894326#test@example.com'),
  pageSize?: int32(name='PageSize', description='Number of items displayed per page.', example='10'),
  requestId?: string(name='RequestId', description='Request ID', example='10A1AD70-E48E-476D-98D9-39BD92193837'),
  totalCount?: int32(name='TotalCount', description='Total count', example='15'),
  data?: {
    receiver?: [ 
    {
      count?: string(name='Count', description='Total number of recipient addresses', example='3'),
      createTime?: string(name='CreateTime', description='Creation time', example='2019-09-29T13:28Z'),
      desc?: string(name='Desc', description='Description', example='Description'),
      receiverId?: string(name='ReceiverId', description='Recipient list ID', example='0c910a7143044b1e116719eb678907b3'),
      receiversAlias?: string(name='ReceiversAlias', description='Recipient list alias', example='10***@example.com'),
      receiversName?: string(name='ReceiversName', description='Recipient list name', example='TKP000442-333'),
      receiversStatus?: string(name='ReceiversStatus', description='List status. Values:

- 0: Uploading
- 1: Upload completed', example='0'),
      utcCreateTime?: long(name='UtcCreateTime', description='UTC formatted creation time', example='1569734892'),
    }
  ](name='receiver')
  }(name='data', description='Detailed information of the recipient list'),
}

model QueryReceiverByParamResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryReceiverByParamResponseBody(name='body'),
}

/**
  * @param request  the request parameters of QueryReceiverByParam  QueryReceiverByParamRequest
  * @return QueryReceiverByParamResponse
 */
async function queryReceiverByParam(request: QueryReceiverByParamRequest): QueryReceiverByParamResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryReceiverByParam', 'POST', '/', 'json', false, 'json', request);
}

model QueryReceiverDetailRequest {
  keyWord?: string(name='KeyWord', description='Recipient address, length 0-50', example='b***@example.net', position='Query'),
  nextStart?: string(name='NextStart', description='Starting position for the next item, default: 0', example='0', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageSize?: int32(name='PageSize', description='Number of items per page, default: 10', example='10', minimum=1, maximum=50, position='Query'),
  receiverId: string(name='ReceiverId', description='Recipient list ID (returned when creating a recipient list using the CreateReceiver API).

This parameter is required.', example='1235', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model QueryReceiverDetailResponseBody = {
  dataSchema?: string(name='DataSchema', description='Field name for the Data of recipients', example='UserName,NickName,Gender,Birthday,Mobile'),
  nextStart?: string(name='NextStart', description='Used for pagination. If there are more results, set this returned value to the NextStart in the next request.', example='90f0243616#40test@example.com'),
  requestId?: string(name='RequestId', description='Request ID', example='10A1AD70-E48E-476D-98D9-39BD92193837'),
  totalCount?: int32(name='TotalCount', description='Total count (deprecated field, kept for historical compatibility)', example='361'),
  data?: {
    detail?: [ 
    {
      createTime?: string(name='CreateTime', description='Creation Time', example='2019-09-29T13:28Z'),
      data?: string(name='Data', description='Content', example='{\\"Domains\\": [\\"a.example.net\\", \\"b.example.net\\", \\"c.example.net\\", \\"d.example.net\\"]}'),
      email?: string(name='Email', description='Recipient address', example='a***@example.net'),
      utcCreateTime?: long(name='UtcCreateTime', description='Creation time in UTC format', example='1569734892'),
    }
  ](name='detail')
  }(name='data', description='Detailed information'),
}

model QueryReceiverDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryReceiverDetailResponseBody(name='body'),
}

/**
  * @param request  the request parameters of QueryReceiverDetail  QueryReceiverDetailRequest
  * @return QueryReceiverDetailResponse
 */
async function queryReceiverDetail(request: QueryReceiverDetailRequest): QueryReceiverDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryReceiverDetail', 'POST', '/', 'json', false, 'json', request);
}

model QueryTagByParamRequest {
  keyWord?: string(name='KeyWord', description='Tag name, length 1-50, defaults to all tags if not specified.', example='1aTag', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNo?: int32(name='PageNo', description='Page number', example='1', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', description='Page size', example='10', minimum=1, maximum=500, position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model QueryTagByParamResponseBody = {
  pageNumber?: int32(name='PageNumber', description='Current page number', example='5'),
  pageSize?: int32(name='PageSize', description='Page size', example='10'),
  requestId?: string(name='RequestId', description='Request ID', example='10A1AD70-E48E-476D-98D9-39BD92193837'),
  totalCount?: int32(name='TotalCount', description='Total count', example='2'),
  data?: {
    tag?: [ 
    {
      tagDescription?: string(name='TagDescription', description='Tag description', example='test description'),
      tagId?: string(name='TagId', description='Tag ID', example='52366'),
      tagName?: string(name='TagName', description='Tag name', example='hellopal'),
    }
  ](name='tag')
  }(name='data', description='Data records'),
}

model QueryTagByParamResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryTagByParamResponseBody(name='body'),
}

/**
  * @param request  the request parameters of QueryTagByParam  QueryTagByParamRequest
  * @return QueryTagByParamResponse
 */
async function queryTagByParam(request: QueryTagByParamRequest): QueryTagByParamResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryTagByParam', 'POST', '/', 'json', false, 'json', request);
}

model QueryTaskByParamRequest {
  keyWord?: string(name='KeyWord', description='Keyword, defaults to all information', example='mesh-notification-788717', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNo?: int32(name='PageNo', description='Current page number, default is 1', example='1', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', description='Page size, default is 10', example='10', minimum=1, maximum=50, position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  status?: int32(name='Status', description='Status, defaults to all statuses', example='0', minimum=0, maximum=2, position='Query'),
}

model QueryTaskByParamResponseBody = {
  pageNumber?: int32(name='PageNumber', description='Current page number', example='3'),
  pageSize?: int32(name='PageSize', description='Page size', example='10'),
  requestId?: string(name='RequestId', description='Request ID', example='10A1AD70-E48E-476D-98D9-39BD92193837'),
  totalCount?: int32(name='TotalCount', description='Total count', example='15'),
  data?: {
    task?: [ 
    {
      addressType?: string(name='AddressType', description='Address type, sending address: 1; random address: 0;', example='0'),
      createTime?: string(name='CreateTime', description='Creation time', example='2022-04-18T10:36Z'),
      ipPoolId?: string(name='IpPoolId', description='dedicated IP pool ID.', example='xxx'),
      ipPoolName?: string(name='IpPoolName', description='dedicated IP pool name.', example='test'),
      receiversName?: string(name='ReceiversName', description='Receiver\\"s name', example='TKP000442-333'),
      requestCount?: string(name='RequestCount', description='Request count', example='1'),
      tagName?: string(name='TagName', description='Tag', example='202201'),
      taskId?: string(name='TaskId', description='Task ID', example='1054296'),
      taskStatus?: string(name='TaskStatus', description='Task status, sent successfully: 1', example='1'),
      templateName?: string(name='TemplateName', description='Template name', example='Short Simple'),
      utcCreateTime?: long(name='UtcCreateTime', description='Creation time in UTC format', example='1569734892'),
    }
  ](name='task')
  }(name='data', description='Returned results'),
}

model QueryTaskByParamResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryTaskByParamResponseBody(name='body'),
}

/**
  * @param request  the request parameters of QueryTaskByParam  QueryTaskByParamRequest
  * @return QueryTaskByParamResponse
 */
async function queryTaskByParam(request: QueryTaskByParamRequest): QueryTaskByParamResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryTaskByParam', 'POST', '/', 'json', false, 'json', request);
}

model RemoveUserSuppressionRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  suppressionIds?: string(name='SuppressionIds', example='59511', position='Query'),
}

model RemoveUserSuppressionResponseBody = {
  requestId?: string(name='RequestId', example='1A846D66-5EC7-551B-9687-5BF1963DCFC1'),
}

model RemoveUserSuppressionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveUserSuppressionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of RemoveUserSuppression  RemoveUserSuppressionRequest
  * @return RemoveUserSuppressionResponse
 */
async function removeUserSuppression(request: RemoveUserSuppressionRequest): RemoveUserSuppressionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RemoveUserSuppression', 'POST', '/', 'json', false, 'json', request);
}

model SaveReceiverDetailRequest {
  detail: string(name='Detail', description='Content, supports uploading multiple recipients at once, with a limit of 500 records per upload. Each record is separated by {} and commas, example:

[{ },{ },{ }...], the format within {} is as follows:

[{"b":"birthday","e":"xxx@example.net","g":"gender","m":"mobile","n":"nickname","u":"name"}], when passing values, pass it as a string, not a list.

If a duplicate recipient address is inserted, it will return "ErrorCount": 1

This parameter is required.', example='[{"b":"birthday","e":"xxx@alibaba-inc.com","g":"gender","m":"mobile","n":"nickname","u":"name"}]', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  receiverId: string(name='ReceiverId', description='Recipient list ID

This parameter is required.', example='34642', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model SaveReceiverDetailResponseBody = {
  data?: {
    detail?: [ 
    {
      email?: string(name='Email', description='Recipient address.', example='test@example.com'),
    }
  ](name='Detail')
  }(name='Data', description='List of recipient addresses that failed to upload.'),
  errorCount?: int32(name='ErrorCount', description='Number of errors.', example='638'),
  requestId?: string(name='RequestId', description='Request ID', example='10A1AD70-E48E-476D-98D9-39BD92193837'),
  successCount?: int32(name='SuccessCount', description='Number of successes.', example='274'),
}

model SaveReceiverDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SaveReceiverDetailResponseBody(name='body'),
}

/**
  * @param request  the request parameters of SaveReceiverDetail  SaveReceiverDetailRequest
  * @return SaveReceiverDetailResponse
 */
async function saveReceiverDetail(request: SaveReceiverDetailRequest): SaveReceiverDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SaveReceiverDetail', 'POST', '/', 'json', false, 'json', request);
}

model SendTestByTemplateRequest {
  accountName: string(name='AccountName', description='Sender address, with a maximum length of 60 characters

This parameter is required.', example='test@example.com', position='Query'),
  birthday?: string(name='Birthday', description='Birthday, with a maximum length of 30 characters', example='2000/01/01', position='Query'),
  email: string(name='Email', description='Recipient address, with a maximum length of 60 characters

This parameter is required.', example='test1@example.com', position='Query'),
  gender?: string(name='Gender', description='Gender, with a maximum length of 30 characters', example='doctor', position='Query'),
  mobile?: string(name='Mobile', description='Mobile, with a maximum length of 30 characters', example='1380000****', position='Query'),
  nickName?: string(name='NickName', description='NickName, with a maximum length of 30 characters', example='LC', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  templateId: int32(name='TemplateId', description='Template ID

This parameter is required.', example='123', position='Query'),
  userName?: string(name='UserName', description='UserName, with a maximum length of 30 characters', example='Lucy', position='Query'),
}

model SendTestByTemplateResponseBody = {
  requestId?: string(name='RequestId', description='Request ID', example='10A1AD70-E48E-476D-98D9-39BD92193837'),
}

model SendTestByTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SendTestByTemplateResponseBody(name='body'),
}

/**
  * @param request  the request parameters of SendTestByTemplate  SendTestByTemplateRequest
  * @return SendTestByTemplateResponse
 */
async function sendTestByTemplate(request: SendTestByTemplateRequest): SendTestByTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SendTestByTemplate', 'POST', '/', 'json', false, 'json', request);
}

model SenderStatisticsByTagNameAndBatchIDRequest {
  accountName?: string(name='AccountName', description='Sending address. If not filled, it represents all addresses.', example='xxx', position='Query'),
  dedicatedIp?: string(name='DedicatedIp', position='Query'),
  dedicatedIpPoolId?: string(name='DedicatedIpPoolId', position='Query'),
  endTime: string(name='EndTime', description='End time, which cannot exceed 7 days from the start time, in the format yyyy-MM-dd.

This parameter is required.', example='2019-09-29', position='Query'),
  esp?: string(name='Esp', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTime: string(name='StartTime', description='Start time, in the format yyyy-MM-dd.

This parameter is required.', example='2019-09-29', position='Query'),
  tagName?: string(name='TagName', description='Email tag. If not filled, it represents all tags.', example='xxx', position='Query'),
}

model SenderStatisticsByTagNameAndBatchIDResponseBody = {
  requestId?: string(name='RequestId', description='Request ID', example='10A1AD70-E48E-476D-98D9-39BD92193837'),
  totalCount?: int32(name='TotalCount', description='Total count', example='1'),
  data?: {
    stat?: [ 
    {
      createTime?: string(name='CreateTime', description='Creation time', example='2021-07-02'),
      faildCount?: string(name='faildCount', description='Failure count', example='0'),
      requestCount?: string(name='requestCount', description='Request count', example='4'),
      succeededPercent?: string(name='succeededPercent', description='Success rate', example='100.00%'),
      successCount?: string(name='successCount', description='Success count', example='4'),
      unavailableCount?: string(name='unavailableCount', description='Invalid count', example='0'),
      unavailablePercent?: string(name='unavailablePercent', description='Unavailability rate', example='0%'),
    }
  ](name='stat')
  }(name='data', description='Data records'),
}

model SenderStatisticsByTagNameAndBatchIDResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SenderStatisticsByTagNameAndBatchIDResponseBody(name='body'),
}

/**
  * @param request  the request parameters of SenderStatisticsByTagNameAndBatchID  SenderStatisticsByTagNameAndBatchIDRequest
  * @return SenderStatisticsByTagNameAndBatchIDResponse
 */
async function senderStatisticsByTagNameAndBatchID(request: SenderStatisticsByTagNameAndBatchIDRequest): SenderStatisticsByTagNameAndBatchIDResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SenderStatisticsByTagNameAndBatchID', 'POST', '/', 'json', false, 'json', request);
}

model SenderStatisticsDetailByParamRequest {
  accountName?: string(name='AccountName', description='Sending address. If not filled, it represents all addresses.

> **AccountName**, **TagName**, and **ToAddress** can all be left unfilled. If any are filled, only one of these parameters can be passed; you cannot pass a combination of two or more.', example='s***@example.net', position='Query'),
  endTime?: string(name='EndTime', description='End time. The span between start and end times cannot exceed 30 days, format: yyyy-MM-dd HH:mm.', example='2021-04-29 00:00', position='Query'),
  length?: int32(name='Length', description='Specifies the number of results to return in this request. Range is 1~100.', example='5', minimum=1, maximum=100, position='Query'),
  nextStart?: string(name='NextStart', description='Used for pagination. Specifies the offset for this request. If there are more results, set this returned value to the NextStart in the next request.', example='90f0243616#203#a***@example.net-1658817837#a***@example.net.247475288187', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTime?: string(name='StartTime', description='Start time. The span between start and end times cannot exceed 30 days, format: yyyy-MM-dd HH:mm', example='2021-04-28 00:00', position='Query'),
  status?: int32(name='Status', description='Delivery result. If not filled, it represents all statuses. Values:

- 0: Success
- 2: Invalid Address
- 3: Spam
- 4: Failure', example='0', minimum=0, maximum=4, position='Query'),
  tagName?: string(name='TagName', description='Email tag. If not filled, it represents all tags.', example='EmailQuestionnaireHelioscam', position='Query'),
  toAddress?: string(name='ToAddress', description='Recipient address. If not filled, it represents all recipient addresses.', example='b***@example.net', position='Query'),
}

model SenderStatisticsDetailByParamResponseBody = {
  nextStart?: string(name='NextStart', description='Used for pagination. If there are more results, set this returned value to the NextStart in the next request.', example='90f0243616#203#a***@example.net-1658817689#a***@example.net.247141122178'),
  requestId?: string(name='RequestId', description='Request ID', example='B5AB8EBB-EE64-4BB2-B085-B92CC5DEDC41'),
  data?: {
    mailDetail?: [ 
    {
      accountName?: string(name='AccountName', description='Sending address', example='s***@example.net'),
      errorClassification?: string(name='ErrorClassification', description='Detailed classification of error reasons: - SendOk - SmtpNxBox
etc.', example='SendOk'),
      lastUpdateTime?: string(name='LastUpdateTime', description='Update time', example='2021-04-28T17:11Z'),
      message?: string(name='Message', description='Delivery detail information', example='250 Send Mail OK'),
      status?: int32(name='Status', description='Delivery status: 0 Success, 2 Invalid Address, 3 Spam, 4 Other Failures', example='0'),
      subject?: string(name='Subject', description='Email subject', example='test subject'),
      toAddress?: string(name='ToAddress', description='Recipient address', example='b***@example.net'),
      utcLastUpdateTime?: string(name='UtcLastUpdateTime', description='UTC formatted update time', example='1619601108'),
    }
  ](name='mailDetail')
  }(name='data', description='Detailed records'),
}

model SenderStatisticsDetailByParamResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SenderStatisticsDetailByParamResponseBody(name='body'),
}

/**
  * @param request  the request parameters of SenderStatisticsDetailByParam  SenderStatisticsDetailByParamRequest
  * @return SenderStatisticsDetailByParamResponse
 */
async function senderStatisticsDetailByParam(request: SenderStatisticsDetailByParamRequest): SenderStatisticsDetailByParamResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SenderStatisticsDetailByParam', 'POST', '/', 'json', false, 'json', request);
}

model SetSuppressionListLevelRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  suppressionListLevel?: string(name='SuppressionListLevel', position='Query'),
}

model SetSuppressionListLevelResponseBody = {
  requestId?: string(name='RequestId'),
  suppressionListLevel?: string(name='SuppressionListLevel'),
}

model SetSuppressionListLevelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetSuppressionListLevelResponseBody(name='body'),
}

/**
  * @param request  the request parameters of SetSuppressionListLevel  SetSuppressionListLevelRequest
  * @return SetSuppressionListLevelResponse
 */
async function setSuppressionListLevel(request: SetSuppressionListLevelRequest): SetSuppressionListLevelResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetSuppressionListLevel', 'POST', '/', 'json', false, 'json', request);
}

model UnblockSendingRequest {
  regionId?: string(name='RegionId', position='Host'),
  blockEmail: string(name='BlockEmail', description='Blacklisted recipient\\"s email address

This parameter is required.', example='recipient@example.com', position='Query'),
  blockType: string(name='BlockType', description='Blacklist type
- UNSUB: Unsubscribe
- REPORT: Report

This parameter is required.', example='UNSUB', position='Query'),
  senderEmail: string(name='SenderEmail', description='Sender\\"s email address

This parameter is required.', example='sender@example.com', position='Query'),
}

model UnblockSendingResponseBody = {
  requestId?: string(name='RequestId', description='Request ID', example='10A1AD70-E48E-476D-98D9-39BD92193837'),
}

model UnblockSendingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UnblockSendingResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UnblockSending  UnblockSendingRequest
  * @return UnblockSendingResponse
 */
async function unblockSending(request: UnblockSendingRequest): UnblockSendingResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UnblockSending', 'POST', '/', 'json', false, 'json', request);
}

model UpdateIpProtectionRequest {
  ipProtection?: string(name='IpProtection', description='IP protection switch, On: 1 Off: 0', example='0', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model UpdateIpProtectionResponseBody = {
  requestId?: string(name='RequestId', description='Request ID', example='B653A6FC-D1AD-5936-A262-F50994ED2574'),
}

model UpdateIpProtectionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateIpProtectionResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateIpProtection  UpdateIpProtectionRequest
  * @return UpdateIpProtectionResponse
 */
async function updateIpProtection(request: UpdateIpProtectionRequest): UpdateIpProtectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateIpProtection', 'POST', '/', 'json', false, 'json', request);
}

model UpdateUserRequest {
  regionId?: string(name='RegionId', position='Host'),
  user?: {
    enableEventbridge?: boolean(name='EnableEventbridge', description='Whether EventBridge is enabled', example='true'),
  }(name='User', description='User Information', shrink='json', position='Body'),
}

model UpdateUserResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request', example='7BC346F6-1092-5852-B6E2-CCE2E5AAE51F'),
}

model UpdateUserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateUserResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateUser  UpdateUserRequest
  * @return UpdateUserResponse
 */
async function updateUser(request: UpdateUserRequest): UpdateUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateUser', 'POST', '/', 'json', true, 'form', request);
}

