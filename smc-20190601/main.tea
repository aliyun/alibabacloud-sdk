/**
 *
 */
import Util;
import OpenApi;

import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'central';
  

  checkConfig(config);
  @endpoint = getEndpoint('smc', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model CreateReplicationJobRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  sourceId?: string(name='SourceId'),
  targetType?: string(name='TargetType'),
  scheduledStartTime?: string(name='ScheduledStartTime'),
  validTime?: string(name='ValidTime'),
  imageName?: string(name='ImageName'),
  instanceId?: string(name='InstanceId'),
  systemDiskSize?: int32(name='SystemDiskSize'),
  vpcId?: string(name='VpcId'),
  vSwitchId?: string(name='VSwitchId'),
  replicationParameters?: string(name='ReplicationParameters'),
  netMode?: int32(name='NetMode'),
  runOnce?: boolean(name='RunOnce'),
  frequency?: int32(name='Frequency'),
  maxNumberOfImageToKeep?: int32(name='MaxNumberOfImageToKeep'),
  instanceType?: string(name='InstanceType'),
  launchTemplateId?: string(name='LaunchTemplateId'),
  launchTemplateVersion?: string(name='LaunchTemplateVersion'),
  instanceRamRole?: string(name='InstanceRamRole'),
  containerNamespace?: string(name='ContainerNamespace'),
  containerRepository?: string(name='ContainerRepository'),
  containerTag?: string(name='ContainerTag'),
  licenseType?: string(name='LicenseType'),
  dataDisk?: [ 
    {
      index?: int32(name='Index'),
      part?: [ 
        {
          sizeBytes?: long(name='SizeBytes'),
          block?: boolean(name='Block'),
          device?: string(name='Device'),
        }
      ](name='Part'),
      size?: int32(name='Size'),
    }
  ](name='DataDisk'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  systemDiskPart?: [ 
    {
      sizeBytes?: long(name='SizeBytes'),
      block?: boolean(name='Block'),
      device?: string(name='Device'),
    }
  ](name='SystemDiskPart'),
}

model CreateReplicationJobResponseBody = {
  requestId?: string(name='RequestId'),
  jobId?: string(name='JobId'),
}

model CreateReplicationJobResponse = {
  headers: map[string]string(name='headers'),
  body: CreateReplicationJobResponseBody(name='body'),
}

async function createReplicationJobWithOptions(request: CreateReplicationJobRequest, runtime: Util.RuntimeOptions): CreateReplicationJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateReplicationJob', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createReplicationJob(request: CreateReplicationJobRequest): CreateReplicationJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return createReplicationJobWithOptions(request, runtime);
}

model CutOverReplicationJobRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  jobId?: string(name='JobId'),
  syncData?: boolean(name='SyncData'),
}

model CutOverReplicationJobResponseBody = {
  requestId?: string(name='RequestId'),
}

model CutOverReplicationJobResponse = {
  headers: map[string]string(name='headers'),
  body: CutOverReplicationJobResponseBody(name='body'),
}

async function cutOverReplicationJobWithOptions(request: CutOverReplicationJobRequest, runtime: Util.RuntimeOptions): CutOverReplicationJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CutOverReplicationJob', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function cutOverReplicationJob(request: CutOverReplicationJobRequest): CutOverReplicationJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return cutOverReplicationJobWithOptions(request, runtime);
}

model DeleteReplicationJobRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  jobId?: string(name='JobId'),
}

model DeleteReplicationJobResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteReplicationJobResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteReplicationJobResponseBody(name='body'),
}

async function deleteReplicationJobWithOptions(request: DeleteReplicationJobRequest, runtime: Util.RuntimeOptions): DeleteReplicationJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteReplicationJob', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteReplicationJob(request: DeleteReplicationJobRequest): DeleteReplicationJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteReplicationJobWithOptions(request, runtime);
}

model DeleteSourceServerRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  sourceId?: string(name='SourceId'),
  force?: boolean(name='Force'),
}

model DeleteSourceServerResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteSourceServerResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSourceServerResponseBody(name='body'),
}

async function deleteSourceServerWithOptions(request: DeleteSourceServerRequest, runtime: Util.RuntimeOptions): DeleteSourceServerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteSourceServer', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteSourceServer(request: DeleteSourceServerRequest): DeleteSourceServerResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSourceServerWithOptions(request, runtime);
}

model DescribeReplicationJobsRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
  status?: string(name='Status'),
  businessStatus?: string(name='BusinessStatus'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  sourceId?: [ string ](name='SourceId'),
  jobId?: [ string ](name='JobId'),
}

model DescribeReplicationJobsResponseBody = {
  totalCount?: int32(name='TotalCount'),
  replicationJobs?: {
    replicationJob?: [ 
    {
      frequency?: int32(name='Frequency'),
      vpcId?: string(name='VpcId'),
      creationTime?: string(name='CreationTime'),
      status?: string(name='Status'),
      scheduledStartTime?: string(name='ScheduledStartTime'),
      maxNumberOfImageToKeep?: int32(name='MaxNumberOfImageToKeep'),
      containerNamespace?: string(name='ContainerNamespace'),
      dataDisks?: {
        dataDisk?: [ 
        {
          index?: int32(name='Index'),
          size?: int32(name='Size'),
          parts?: {
            part?: [ 
            {
              sizeBytes?: long(name='SizeBytes'),
              block?: boolean(name='Block'),
              device?: string(name='Device'),
            }
          ](name='Part')
          }(name='Parts'),
        }
      ](name='DataDisk')
      }(name='DataDisks'),
      statusInfo?: string(name='StatusInfo'),
      instanceRamRole?: string(name='InstanceRamRole'),
      systemDiskSize?: int32(name='SystemDiskSize'),
      description?: string(name='Description'),
      replicationParameters?: string(name='ReplicationParameters'),
      errorCode?: string(name='ErrorCode'),
      validTime?: string(name='ValidTime'),
      netMode?: int32(name='NetMode'),
      containerTag?: string(name='ContainerTag'),
      licenseType?: string(name='LicenseType'),
      name?: string(name='Name'),
      imageId?: string(name='ImageId'),
      progress?: float(name='Progress'),
      runOnce?: boolean(name='RunOnce'),
      launchTemplateId?: string(name='LaunchTemplateId'),
      containerRepository?: string(name='ContainerRepository'),
      instanceId?: string(name='InstanceId'),
      systemDiskParts?: {
        systemDiskPart?: [ 
        {
          sizeBytes?: long(name='SizeBytes'),
          block?: boolean(name='Block'),
          device?: string(name='Device'),
        }
      ](name='SystemDiskPart')
      }(name='SystemDiskParts'),
      instanceType?: string(name='InstanceType'),
      sourceId?: string(name='SourceId'),
      launchTemplateVersion?: string(name='LaunchTemplateVersion'),
      regionId?: string(name='RegionId'),
      transitionInstanceId?: string(name='TransitionInstanceId'),
      endTime?: string(name='EndTime'),
      startTime?: string(name='StartTime'),
      vSwitchId?: string(name='VSwitchId'),
      jobId?: string(name='JobId'),
      imageName?: string(name='ImageName'),
      businessStatus?: string(name='BusinessStatus'),
      replicationJobRuns?: {
        replicationJobRun?: [ 
        {
          endTime?: string(name='EndTime'),
          type?: string(name='Type'),
          startTime?: string(name='StartTime'),
          imageId?: string(name='ImageId'),
        }
      ](name='ReplicationJobRun')
      }(name='ReplicationJobRuns'),
      targetType?: string(name='TargetType'),
    }
  ](name='ReplicationJob')
  }(name='ReplicationJobs'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
}

model DescribeReplicationJobsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeReplicationJobsResponseBody(name='body'),
}

async function describeReplicationJobsWithOptions(request: DescribeReplicationJobsRequest, runtime: Util.RuntimeOptions): DescribeReplicationJobsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeReplicationJobs', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeReplicationJobs(request: DescribeReplicationJobsRequest): DescribeReplicationJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeReplicationJobsWithOptions(request, runtime);
}

model DescribeSourceServersRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  jobId?: string(name='JobId'),
  state?: string(name='State'),
  name?: string(name='Name'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  sourceId?: [ string ](name='SourceId'),
}

model DescribeSourceServersResponseBody = {
  sourceServers?: {
    sourceServer?: [ 
    {
      creationTime?: string(name='CreationTime'),
      heartbeatRate?: int32(name='HeartbeatRate'),
      state?: string(name='State'),
      dataDisks?: {
        dataDisk?: [ 
        {
          index?: int32(name='Index'),
          size?: int32(name='Size'),
          parts?: {
            part?: [ 
            {
              canBlock?: boolean(name='CanBlock'),
              sizeBytes?: long(name='SizeBytes'),
              need?: boolean(name='Need'),
              device?: string(name='Device'),
              path?: string(name='Path'),
            }
          ](name='Part')
          }(name='Parts'),
          path?: string(name='Path'),
        }
      ](name='DataDisk')
      }(name='DataDisks'),
      systemDiskParts?: {
        systemDiskPart?: [ 
        {
          canBlock?: boolean(name='CanBlock'),
          sizeBytes?: long(name='SizeBytes'),
          need?: boolean(name='Need'),
          device?: string(name='Device'),
          path?: string(name='Path'),
        }
      ](name='SystemDiskPart')
      }(name='SystemDiskParts'),
      kernelLevel?: int32(name='KernelLevel'),
      sourceId?: string(name='SourceId'),
      agentVersion?: string(name='AgentVersion'),
      statusInfo?: string(name='StatusInfo'),
      systemDiskSize?: int32(name='SystemDiskSize'),
      description?: string(name='Description'),
      errorCode?: string(name='ErrorCode'),
      jobId?: string(name='JobId'),
      platform?: string(name='Platform'),
      replicationDriver?: string(name='ReplicationDriver'),
      name?: string(name='Name'),
      systemInfo?: string(name='SystemInfo'),
      architecture?: string(name='Architecture'),
    }
  ](name='SourceServer')
  }(name='SourceServers'),
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
}

model DescribeSourceServersResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSourceServersResponseBody(name='body'),
}

async function describeSourceServersWithOptions(request: DescribeSourceServersRequest, runtime: Util.RuntimeOptions): DescribeSourceServersResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeSourceServers', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeSourceServers(request: DescribeSourceServersRequest): DescribeSourceServersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSourceServersWithOptions(request, runtime);
}

model ListTagResourcesRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceType?: string(name='ResourceType'),
  nextToken?: string(name='NextToken'),
  resourceId?: [ string ](name='ResourceId'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  tagResources?: {
    tagResource?: [ 
    {
      resourceType?: string(name='ResourceType'),
      tagValue?: string(name='TagValue'),
      resourceId?: string(name='ResourceId'),
      tagKey?: string(name='TagKey'),
    }
  ](name='TagResource')
  }(name='TagResources'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListTagResources', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagResourcesWithOptions(request, runtime);
}

model ModifyReplicationJobAttributeRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  jobId?: string(name='JobId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  targetType?: string(name='TargetType'),
  scheduledStartTime?: string(name='ScheduledStartTime'),
  imageName?: string(name='ImageName'),
  instanceId?: string(name='InstanceId'),
  systemDiskSize?: int32(name='SystemDiskSize'),
  frequency?: int32(name='Frequency'),
  maxNumberOfImageToKeep?: int32(name='MaxNumberOfImageToKeep'),
  instanceType?: string(name='InstanceType'),
  launchTemplateId?: string(name='LaunchTemplateId'),
  launchTemplateVersion?: string(name='LaunchTemplateVersion'),
  instanceRamRole?: string(name='InstanceRamRole'),
  containerNamespace?: string(name='ContainerNamespace'),
  containerRepository?: string(name='ContainerRepository'),
  containerTag?: string(name='ContainerTag'),
  validTime?: string(name='ValidTime'),
  systemDiskPart?: [ 
    {
      sizeBytes?: long(name='SizeBytes'),
      block?: boolean(name='Block'),
      device?: string(name='Device'),
    }
  ](name='SystemDiskPart'),
  dataDisk?: [ 
    {
      index?: int32(name='Index'),
      part?: [ 
        {
          sizeBytes?: long(name='SizeBytes'),
          block?: boolean(name='Block'),
          device?: string(name='Device'),
        }
      ](name='Part'),
      size?: int32(name='Size'),
    }
  ](name='DataDisk'),
}

model ModifyReplicationJobAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyReplicationJobAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyReplicationJobAttributeResponseBody(name='body'),
}

async function modifyReplicationJobAttributeWithOptions(request: ModifyReplicationJobAttributeRequest, runtime: Util.RuntimeOptions): ModifyReplicationJobAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyReplicationJobAttribute', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyReplicationJobAttribute(request: ModifyReplicationJobAttributeRequest): ModifyReplicationJobAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyReplicationJobAttributeWithOptions(request, runtime);
}

model ModifySourceServerAttributeRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  sourceId?: string(name='SourceId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
}

model ModifySourceServerAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifySourceServerAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifySourceServerAttributeResponseBody(name='body'),
}

async function modifySourceServerAttributeWithOptions(request: ModifySourceServerAttributeRequest, runtime: Util.RuntimeOptions): ModifySourceServerAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifySourceServerAttribute', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifySourceServerAttribute(request: ModifySourceServerAttributeRequest): ModifySourceServerAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifySourceServerAttributeWithOptions(request, runtime);
}

model StartReplicationJobRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  jobId?: string(name='JobId'),
}

model StartReplicationJobResponseBody = {
  requestId?: string(name='RequestId'),
}

model StartReplicationJobResponse = {
  headers: map[string]string(name='headers'),
  body: StartReplicationJobResponseBody(name='body'),
}

async function startReplicationJobWithOptions(request: StartReplicationJobRequest, runtime: Util.RuntimeOptions): StartReplicationJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('StartReplicationJob', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function startReplicationJob(request: StartReplicationJobRequest): StartReplicationJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return startReplicationJobWithOptions(request, runtime);
}

model StopReplicationJobRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  jobId?: string(name='JobId'),
}

model StopReplicationJobResponseBody = {
  requestId?: string(name='RequestId'),
}

model StopReplicationJobResponse = {
  headers: map[string]string(name='headers'),
  body: StopReplicationJobResponseBody(name='body'),
}

async function stopReplicationJobWithOptions(request: StopReplicationJobRequest, runtime: Util.RuntimeOptions): StopReplicationJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('StopReplicationJob', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function stopReplicationJob(request: StopReplicationJobRequest): StopReplicationJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopReplicationJobWithOptions(request, runtime);
}

model TagResourcesRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceType?: string(name='ResourceType'),
  resourceId?: [ string ](name='ResourceId'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResourcesWithOptions(request: TagResourcesRequest, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('TagResources', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagResourcesWithOptions(request, runtime);
}

model UntagResourcesRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceType?: string(name='ResourceType'),
  all?: boolean(name='All'),
  resourceId?: [ string ](name='ResourceId'),
  tagKey?: [ string ](name='TagKey'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResourcesWithOptions(request: UntagResourcesRequest, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UntagResources', '2019-06-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return untagResourcesWithOptions(request, runtime);
}

