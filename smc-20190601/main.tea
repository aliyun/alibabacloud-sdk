/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'central';
  

  checkConfig(config);
  @endpoint = getEndpoint('smc', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model CreateReplicationJobRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  sourceId?: string(name='SourceId'),
  targetType?: string(name='TargetType'),
  scheduledStartTime?: string(name='ScheduledStartTime'),
  validTime?: string(name='ValidTime'),
  imageName?: string(name='ImageName'),
  instanceId?: string(name='InstanceId'),
  systemDiskSize?: int32(name='SystemDiskSize'),
  vpcId?: string(name='VpcId'),
  vSwitchId?: string(name='VSwitchId'),
  replicationParameters?: string(name='ReplicationParameters'),
  netMode?: int32(name='NetMode'),
  runOnce?: boolean(name='RunOnce'),
  frequency?: int32(name='Frequency'),
  maxNumberOfImageToKeep?: int32(name='MaxNumberOfImageToKeep'),
  instanceType?: string(name='InstanceType'),
  launchTemplateId?: string(name='LaunchTemplateId'),
  launchTemplateVersion?: string(name='LaunchTemplateVersion'),
  instanceRamRole?: string(name='InstanceRamRole'),
  containerNamespace?: string(name='ContainerNamespace'),
  containerRepository?: string(name='ContainerRepository'),
  containerTag?: string(name='ContainerTag'),
  licenseType?: string(name='LicenseType'),
  dataDisk?: [ 
    {
      index?: int32(name='Index'),
      part?: [ 
        {
          sizeBytes?: long(name='SizeBytes'),
          block?: boolean(name='Block'),
          device?: string(name='Device'),
        }
      ](name='Part'),
      size?: int32(name='Size'),
    }
  ](name='DataDisk'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  systemDiskPart?: [ 
    {
      sizeBytes?: long(name='SizeBytes'),
      block?: boolean(name='Block'),
      device?: string(name='Device'),
    }
  ](name='SystemDiskPart'),
}

model CreateReplicationJobResponseBody = {
  requestId?: string(name='RequestId'),
  jobId?: string(name='JobId'),
}

model CreateReplicationJobResponse = {
  headers: map[string]string(name='headers'),
  body: CreateReplicationJobResponseBody(name='body'),
}

async function createReplicationJobWithOptions(request: CreateReplicationJobRequest, runtime: Util.RuntimeOptions): CreateReplicationJobResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["RegionId"] = request.regionId;
  query["ClientToken"] = request.clientToken;
  query["Name"] = request.name;
  query["Description"] = request.description;
  query["SourceId"] = request.sourceId;
  query["TargetType"] = request.targetType;
  query["ScheduledStartTime"] = request.scheduledStartTime;
  query["ValidTime"] = request.validTime;
  query["ImageName"] = request.imageName;
  query["InstanceId"] = request.instanceId;
  query["SystemDiskSize"] = request.systemDiskSize;
  query["VpcId"] = request.vpcId;
  query["VSwitchId"] = request.vSwitchId;
  query["ReplicationParameters"] = request.replicationParameters;
  query["NetMode"] = request.netMode;
  query["RunOnce"] = request.runOnce;
  query["Frequency"] = request.frequency;
  query["MaxNumberOfImageToKeep"] = request.maxNumberOfImageToKeep;
  query["InstanceType"] = request.instanceType;
  query["LaunchTemplateId"] = request.launchTemplateId;
  query["LaunchTemplateVersion"] = request.launchTemplateVersion;
  query["InstanceRamRole"] = request.instanceRamRole;
  query["ContainerNamespace"] = request.containerNamespace;
  query["ContainerRepository"] = request.containerRepository;
  query["ContainerTag"] = request.containerTag;
  query["LicenseType"] = request.licenseType;
  query["DataDisk"] = request.dataDisk;
  query["Tag"] = request.tag;
  query["SystemDiskPart"] = request.systemDiskPart;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateReplicationJob',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createReplicationJob(request: CreateReplicationJobRequest): CreateReplicationJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return createReplicationJobWithOptions(request, runtime);
}

model CutOverReplicationJobRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  jobId?: string(name='JobId'),
  syncData?: boolean(name='SyncData'),
}

model CutOverReplicationJobResponseBody = {
  requestId?: string(name='RequestId'),
}

model CutOverReplicationJobResponse = {
  headers: map[string]string(name='headers'),
  body: CutOverReplicationJobResponseBody(name='body'),
}

async function cutOverReplicationJobWithOptions(request: CutOverReplicationJobRequest, runtime: Util.RuntimeOptions): CutOverReplicationJobResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["JobId"] = request.jobId;
  query["SyncData"] = request.syncData;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CutOverReplicationJob',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cutOverReplicationJob(request: CutOverReplicationJobRequest): CutOverReplicationJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return cutOverReplicationJobWithOptions(request, runtime);
}

model DeleteReplicationJobRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  jobId?: string(name='JobId'),
}

model DeleteReplicationJobResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteReplicationJobResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteReplicationJobResponseBody(name='body'),
}

async function deleteReplicationJobWithOptions(request: DeleteReplicationJobRequest, runtime: Util.RuntimeOptions): DeleteReplicationJobResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["JobId"] = request.jobId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteReplicationJob',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteReplicationJob(request: DeleteReplicationJobRequest): DeleteReplicationJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteReplicationJobWithOptions(request, runtime);
}

model DeleteSourceServerRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  sourceId?: string(name='SourceId'),
  force?: boolean(name='Force'),
}

model DeleteSourceServerResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteSourceServerResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSourceServerResponseBody(name='body'),
}

async function deleteSourceServerWithOptions(request: DeleteSourceServerRequest, runtime: Util.RuntimeOptions): DeleteSourceServerResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["SourceId"] = request.sourceId;
  query["Force"] = request.force;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSourceServer',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSourceServer(request: DeleteSourceServerRequest): DeleteSourceServerResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSourceServerWithOptions(request, runtime);
}

model DescribeReplicationJobsRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
  status?: string(name='Status'),
  businessStatus?: string(name='BusinessStatus'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  sourceId?: [ string ](name='SourceId'),
  jobId?: [ string ](name='JobId'),
}

model DescribeReplicationJobsResponseBody = {
  totalCount?: int32(name='TotalCount'),
  replicationJobs?: {
    replicationJob?: [ 
    {
      frequency?: int32(name='Frequency'),
      vpcId?: string(name='VpcId'),
      creationTime?: string(name='CreationTime'),
      status?: string(name='Status'),
      scheduledStartTime?: string(name='ScheduledStartTime'),
      maxNumberOfImageToKeep?: int32(name='MaxNumberOfImageToKeep'),
      containerNamespace?: string(name='ContainerNamespace'),
      dataDisks?: {
        dataDisk?: [ 
        {
          index?: int32(name='Index'),
          size?: int32(name='Size'),
          parts?: {
            part?: [ 
            {
              sizeBytes?: long(name='SizeBytes'),
              block?: boolean(name='Block'),
              device?: string(name='Device'),
            }
          ](name='Part')
          }(name='Parts'),
        }
      ](name='DataDisk')
      }(name='DataDisks'),
      statusInfo?: string(name='StatusInfo'),
      instanceRamRole?: string(name='InstanceRamRole'),
      systemDiskSize?: int32(name='SystemDiskSize'),
      description?: string(name='Description'),
      replicationParameters?: string(name='ReplicationParameters'),
      errorCode?: string(name='ErrorCode'),
      validTime?: string(name='ValidTime'),
      netMode?: int32(name='NetMode'),
      containerTag?: string(name='ContainerTag'),
      licenseType?: string(name='LicenseType'),
      name?: string(name='Name'),
      imageId?: string(name='ImageId'),
      progress?: float(name='Progress'),
      runOnce?: boolean(name='RunOnce'),
      launchTemplateId?: string(name='LaunchTemplateId'),
      containerRepository?: string(name='ContainerRepository'),
      instanceId?: string(name='InstanceId'),
      systemDiskParts?: {
        systemDiskPart?: [ 
        {
          sizeBytes?: long(name='SizeBytes'),
          block?: boolean(name='Block'),
          device?: string(name='Device'),
        }
      ](name='SystemDiskPart')
      }(name='SystemDiskParts'),
      instanceType?: string(name='InstanceType'),
      sourceId?: string(name='SourceId'),
      launchTemplateVersion?: string(name='LaunchTemplateVersion'),
      regionId?: string(name='RegionId'),
      transitionInstanceId?: string(name='TransitionInstanceId'),
      endTime?: string(name='EndTime'),
      startTime?: string(name='StartTime'),
      vSwitchId?: string(name='VSwitchId'),
      jobId?: string(name='JobId'),
      imageName?: string(name='ImageName'),
      businessStatus?: string(name='BusinessStatus'),
      replicationJobRuns?: {
        replicationJobRun?: [ 
        {
          endTime?: string(name='EndTime'),
          type?: string(name='Type'),
          startTime?: string(name='StartTime'),
          imageId?: string(name='ImageId'),
        }
      ](name='ReplicationJobRun')
      }(name='ReplicationJobRuns'),
      targetType?: string(name='TargetType'),
    }
  ](name='ReplicationJob')
  }(name='ReplicationJobs'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
}

model DescribeReplicationJobsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeReplicationJobsResponseBody(name='body'),
}

async function describeReplicationJobsWithOptions(request: DescribeReplicationJobsRequest, runtime: Util.RuntimeOptions): DescribeReplicationJobsResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["Name"] = request.name;
  query["RegionId"] = request.regionId;
  query["Status"] = request.status;
  query["BusinessStatus"] = request.businessStatus;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  query["SourceId"] = request.sourceId;
  query["JobId"] = request.jobId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeReplicationJobs',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeReplicationJobs(request: DescribeReplicationJobsRequest): DescribeReplicationJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeReplicationJobsWithOptions(request, runtime);
}

model DescribeSourceServersRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  jobId?: string(name='JobId'),
  state?: string(name='State'),
  name?: string(name='Name'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  sourceId?: [ string ](name='SourceId'),
}

model DescribeSourceServersResponseBody = {
  sourceServers?: {
    sourceServer?: [ 
    {
      creationTime?: string(name='CreationTime'),
      heartbeatRate?: int32(name='HeartbeatRate'),
      state?: string(name='State'),
      dataDisks?: {
        dataDisk?: [ 
        {
          index?: int32(name='Index'),
          size?: int32(name='Size'),
          parts?: {
            part?: [ 
            {
              canBlock?: boolean(name='CanBlock'),
              sizeBytes?: long(name='SizeBytes'),
              need?: boolean(name='Need'),
              device?: string(name='Device'),
              path?: string(name='Path'),
            }
          ](name='Part')
          }(name='Parts'),
          path?: string(name='Path'),
        }
      ](name='DataDisk')
      }(name='DataDisks'),
      systemDiskParts?: {
        systemDiskPart?: [ 
        {
          canBlock?: boolean(name='CanBlock'),
          sizeBytes?: long(name='SizeBytes'),
          need?: boolean(name='Need'),
          device?: string(name='Device'),
          path?: string(name='Path'),
        }
      ](name='SystemDiskPart')
      }(name='SystemDiskParts'),
      kernelLevel?: int32(name='KernelLevel'),
      sourceId?: string(name='SourceId'),
      agentVersion?: string(name='AgentVersion'),
      statusInfo?: string(name='StatusInfo'),
      systemDiskSize?: int32(name='SystemDiskSize'),
      description?: string(name='Description'),
      errorCode?: string(name='ErrorCode'),
      jobId?: string(name='JobId'),
      platform?: string(name='Platform'),
      replicationDriver?: string(name='ReplicationDriver'),
      name?: string(name='Name'),
      systemInfo?: string(name='SystemInfo'),
      architecture?: string(name='Architecture'),
    }
  ](name='SourceServer')
  }(name='SourceServers'),
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
}

model DescribeSourceServersResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSourceServersResponseBody(name='body'),
}

async function describeSourceServersWithOptions(request: DescribeSourceServersRequest, runtime: Util.RuntimeOptions): DescribeSourceServersResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["JobId"] = request.jobId;
  query["State"] = request.state;
  query["Name"] = request.name;
  query["PageNumber"] = request.pageNumber;
  query["PageSize"] = request.pageSize;
  query["SourceId"] = request.sourceId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSourceServers',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSourceServers(request: DescribeSourceServersRequest): DescribeSourceServersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSourceServersWithOptions(request, runtime);
}

model ListTagResourcesRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceType?: string(name='ResourceType'),
  nextToken?: string(name='NextToken'),
  resourceId?: [ string ](name='ResourceId'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  tagResources?: {
    tagResource?: [ 
    {
      resourceType?: string(name='ResourceType'),
      tagValue?: string(name='TagValue'),
      resourceId?: string(name='ResourceId'),
      tagKey?: string(name='TagKey'),
    }
  ](name='TagResource')
  }(name='TagResources'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceType"] = request.resourceType;
  query["NextToken"] = request.nextToken;
  query["ResourceId"] = request.resourceId;
  query["Tag"] = request.tag;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListTagResources',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagResourcesWithOptions(request, runtime);
}

model ModifyReplicationJobAttributeRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  jobId?: string(name='JobId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  targetType?: string(name='TargetType'),
  scheduledStartTime?: string(name='ScheduledStartTime'),
  imageName?: string(name='ImageName'),
  instanceId?: string(name='InstanceId'),
  systemDiskSize?: int32(name='SystemDiskSize'),
  frequency?: int32(name='Frequency'),
  maxNumberOfImageToKeep?: int32(name='MaxNumberOfImageToKeep'),
  instanceType?: string(name='InstanceType'),
  launchTemplateId?: string(name='LaunchTemplateId'),
  launchTemplateVersion?: string(name='LaunchTemplateVersion'),
  instanceRamRole?: string(name='InstanceRamRole'),
  containerNamespace?: string(name='ContainerNamespace'),
  containerRepository?: string(name='ContainerRepository'),
  containerTag?: string(name='ContainerTag'),
  validTime?: string(name='ValidTime'),
  systemDiskPart?: [ 
    {
      sizeBytes?: long(name='SizeBytes'),
      block?: boolean(name='Block'),
      device?: string(name='Device'),
    }
  ](name='SystemDiskPart'),
  dataDisk?: [ 
    {
      index?: int32(name='Index'),
      part?: [ 
        {
          sizeBytes?: long(name='SizeBytes'),
          block?: boolean(name='Block'),
          device?: string(name='Device'),
        }
      ](name='Part'),
      size?: int32(name='Size'),
    }
  ](name='DataDisk'),
}

model ModifyReplicationJobAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyReplicationJobAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyReplicationJobAttributeResponseBody(name='body'),
}

async function modifyReplicationJobAttributeWithOptions(request: ModifyReplicationJobAttributeRequest, runtime: Util.RuntimeOptions): ModifyReplicationJobAttributeResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["JobId"] = request.jobId;
  query["Name"] = request.name;
  query["Description"] = request.description;
  query["TargetType"] = request.targetType;
  query["ScheduledStartTime"] = request.scheduledStartTime;
  query["ImageName"] = request.imageName;
  query["InstanceId"] = request.instanceId;
  query["SystemDiskSize"] = request.systemDiskSize;
  query["Frequency"] = request.frequency;
  query["MaxNumberOfImageToKeep"] = request.maxNumberOfImageToKeep;
  query["InstanceType"] = request.instanceType;
  query["LaunchTemplateId"] = request.launchTemplateId;
  query["LaunchTemplateVersion"] = request.launchTemplateVersion;
  query["InstanceRamRole"] = request.instanceRamRole;
  query["ContainerNamespace"] = request.containerNamespace;
  query["ContainerRepository"] = request.containerRepository;
  query["ContainerTag"] = request.containerTag;
  query["ValidTime"] = request.validTime;
  query["SystemDiskPart"] = request.systemDiskPart;
  query["DataDisk"] = request.dataDisk;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ModifyReplicationJobAttribute',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyReplicationJobAttribute(request: ModifyReplicationJobAttributeRequest): ModifyReplicationJobAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyReplicationJobAttributeWithOptions(request, runtime);
}

model ModifySourceServerAttributeRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  sourceId?: string(name='SourceId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
}

model ModifySourceServerAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifySourceServerAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifySourceServerAttributeResponseBody(name='body'),
}

async function modifySourceServerAttributeWithOptions(request: ModifySourceServerAttributeRequest, runtime: Util.RuntimeOptions): ModifySourceServerAttributeResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["SourceId"] = request.sourceId;
  query["Name"] = request.name;
  query["Description"] = request.description;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ModifySourceServerAttribute',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifySourceServerAttribute(request: ModifySourceServerAttributeRequest): ModifySourceServerAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifySourceServerAttributeWithOptions(request, runtime);
}

model StartReplicationJobRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  jobId?: string(name='JobId'),
}

model StartReplicationJobResponseBody = {
  requestId?: string(name='RequestId'),
}

model StartReplicationJobResponse = {
  headers: map[string]string(name='headers'),
  body: StartReplicationJobResponseBody(name='body'),
}

async function startReplicationJobWithOptions(request: StartReplicationJobRequest, runtime: Util.RuntimeOptions): StartReplicationJobResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["JobId"] = request.jobId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'StartReplicationJob',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startReplicationJob(request: StartReplicationJobRequest): StartReplicationJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return startReplicationJobWithOptions(request, runtime);
}

model StopReplicationJobRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  jobId?: string(name='JobId'),
}

model StopReplicationJobResponseBody = {
  requestId?: string(name='RequestId'),
}

model StopReplicationJobResponse = {
  headers: map[string]string(name='headers'),
  body: StopReplicationJobResponseBody(name='body'),
}

async function stopReplicationJobWithOptions(request: StopReplicationJobRequest, runtime: Util.RuntimeOptions): StopReplicationJobResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["JobId"] = request.jobId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'StopReplicationJob',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopReplicationJob(request: StopReplicationJobRequest): StopReplicationJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopReplicationJobWithOptions(request, runtime);
}

model TagResourcesRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceType?: string(name='ResourceType'),
  resourceId?: [ string ](name='ResourceId'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResourcesWithOptions(request: TagResourcesRequest, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceType"] = request.resourceType;
  query["ResourceId"] = request.resourceId;
  query["Tag"] = request.tag;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'TagResources',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagResourcesWithOptions(request, runtime);
}

model UntagResourcesRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceType?: string(name='ResourceType'),
  all?: boolean(name='All'),
  resourceId?: [ string ](name='ResourceId'),
  tagKey?: [ string ](name='TagKey'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResourcesWithOptions(request: UntagResourcesRequest, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceType"] = request.resourceType;
  query["All"] = request.all;
  query["ResourceId"] = request.resourceId;
  query["TagKey"] = request.tagKey;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UntagResources',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return untagResourcesWithOptions(request, runtime);
}

