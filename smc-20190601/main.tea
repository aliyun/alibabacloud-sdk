/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'central';
  
  checkConfig(config);
  @endpoint = getEndpoint('smc', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model CreateAccessTokenRequest {
  count?: string(name='Count'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  timeToLiveInDays?: string(name='TimeToLiveInDays'),
}

model CreateAccessTokenResponseBody = {
  accessTokenCode?: string(name='AccessTokenCode'),
  accessTokenId?: string(name='AccessTokenId'),
  requestId?: string(name='RequestId'),
}

model CreateAccessTokenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAccessTokenResponseBody(name='body'),
}

async function createAccessTokenWithOptions(request: CreateAccessTokenRequest, runtime: Util.RuntimeOptions): CreateAccessTokenResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.count)) {
    query['Count'] = request.count;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.timeToLiveInDays)) {
    query['TimeToLiveInDays'] = request.timeToLiveInDays;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateAccessToken',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createAccessToken(request: CreateAccessTokenRequest): CreateAccessTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAccessTokenWithOptions(request, runtime);
}

model CreateReplicationJobRequest {
  clientToken?: string(name='ClientToken'),
  containerNamespace?: string(name='ContainerNamespace'),
  containerRepository?: string(name='ContainerRepository'),
  containerTag?: string(name='ContainerTag'),
  dataDisk?: [ 
    {
      index?: int32(name='Index'),
      part?: [ 
        {
          block?: boolean(name='Block'),
          device?: string(name='Device'),
          sizeBytes?: long(name='SizeBytes'),
        }
      ](name='Part'),
      size?: int32(name='Size'),
    }
  ](name='DataDisk'),
  description?: string(name='Description'),
  frequency?: int32(name='Frequency'),
  imageName?: string(name='ImageName'),
  instanceId?: string(name='InstanceId'),
  instanceRamRole?: string(name='InstanceRamRole'),
  instanceType?: string(name='InstanceType'),
  jobType?: int32(name='JobType'),
  launchTemplateId?: string(name='LaunchTemplateId'),
  launchTemplateVersion?: string(name='LaunchTemplateVersion'),
  licenseType?: string(name='LicenseType'),
  maxNumberOfImageToKeep?: int32(name='MaxNumberOfImageToKeep'),
  name?: string(name='Name'),
  netMode?: int32(name='NetMode'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  replicationParameters?: string(name='ReplicationParameters'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  runOnce?: boolean(name='RunOnce'),
  scheduledStartTime?: string(name='ScheduledStartTime'),
  sourceId?: string(name='SourceId'),
  systemDiskPart?: [ 
    {
      block?: boolean(name='Block'),
      device?: string(name='Device'),
      sizeBytes?: long(name='SizeBytes'),
    }
  ](name='SystemDiskPart'),
  systemDiskSize?: int32(name='SystemDiskSize'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  targetType?: string(name='TargetType'),
  vSwitchId?: string(name='VSwitchId'),
  validTime?: string(name='ValidTime'),
  vpcId?: string(name='VpcId'),
}

model CreateReplicationJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model CreateReplicationJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateReplicationJobResponseBody(name='body'),
}

async function createReplicationJobWithOptions(request: CreateReplicationJobRequest, runtime: Util.RuntimeOptions): CreateReplicationJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.containerNamespace)) {
    query['ContainerNamespace'] = request.containerNamespace;
  }
  if (!Util.isUnset(request.containerRepository)) {
    query['ContainerRepository'] = request.containerRepository;
  }
  if (!Util.isUnset(request.containerTag)) {
    query['ContainerTag'] = request.containerTag;
  }
  if (!Util.isUnset(request.dataDisk)) {
    query['DataDisk'] = request.dataDisk;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.frequency)) {
    query['Frequency'] = request.frequency;
  }
  if (!Util.isUnset(request.imageName)) {
    query['ImageName'] = request.imageName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceRamRole)) {
    query['InstanceRamRole'] = request.instanceRamRole;
  }
  if (!Util.isUnset(request.instanceType)) {
    query['InstanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.jobType)) {
    query['JobType'] = request.jobType;
  }
  if (!Util.isUnset(request.launchTemplateId)) {
    query['LaunchTemplateId'] = request.launchTemplateId;
  }
  if (!Util.isUnset(request.launchTemplateVersion)) {
    query['LaunchTemplateVersion'] = request.launchTemplateVersion;
  }
  if (!Util.isUnset(request.licenseType)) {
    query['LicenseType'] = request.licenseType;
  }
  if (!Util.isUnset(request.maxNumberOfImageToKeep)) {
    query['MaxNumberOfImageToKeep'] = request.maxNumberOfImageToKeep;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.netMode)) {
    query['NetMode'] = request.netMode;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.replicationParameters)) {
    query['ReplicationParameters'] = request.replicationParameters;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.runOnce)) {
    query['RunOnce'] = request.runOnce;
  }
  if (!Util.isUnset(request.scheduledStartTime)) {
    query['ScheduledStartTime'] = request.scheduledStartTime;
  }
  if (!Util.isUnset(request.sourceId)) {
    query['SourceId'] = request.sourceId;
  }
  if (!Util.isUnset(request.systemDiskPart)) {
    query['SystemDiskPart'] = request.systemDiskPart;
  }
  if (!Util.isUnset(request.systemDiskSize)) {
    query['SystemDiskSize'] = request.systemDiskSize;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.validTime)) {
    query['ValidTime'] = request.validTime;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateReplicationJob',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createReplicationJob(request: CreateReplicationJobRequest): CreateReplicationJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return createReplicationJobWithOptions(request, runtime);
}

model CutOverReplicationJobRequest {
  jobId?: string(name='JobId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  syncData?: boolean(name='SyncData'),
}

model CutOverReplicationJobResponseBody = {
  requestId?: string(name='RequestId'),
}

model CutOverReplicationJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CutOverReplicationJobResponseBody(name='body'),
}

async function cutOverReplicationJobWithOptions(request: CutOverReplicationJobRequest, runtime: Util.RuntimeOptions): CutOverReplicationJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.syncData)) {
    query['SyncData'] = request.syncData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CutOverReplicationJob',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cutOverReplicationJob(request: CutOverReplicationJobRequest): CutOverReplicationJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return cutOverReplicationJobWithOptions(request, runtime);
}

model DeleteAccessTokenRequest {
  accessTokenId?: string(name='AccessTokenId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
}

model DeleteAccessTokenResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteAccessTokenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAccessTokenResponseBody(name='body'),
}

async function deleteAccessTokenWithOptions(request: DeleteAccessTokenRequest, runtime: Util.RuntimeOptions): DeleteAccessTokenResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessTokenId)) {
    query['AccessTokenId'] = request.accessTokenId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAccessToken',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteAccessToken(request: DeleteAccessTokenRequest): DeleteAccessTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAccessTokenWithOptions(request, runtime);
}

model DeleteReplicationJobRequest {
  jobId?: string(name='JobId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
}

model DeleteReplicationJobResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteReplicationJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteReplicationJobResponseBody(name='body'),
}

async function deleteReplicationJobWithOptions(request: DeleteReplicationJobRequest, runtime: Util.RuntimeOptions): DeleteReplicationJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteReplicationJob',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteReplicationJob(request: DeleteReplicationJobRequest): DeleteReplicationJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteReplicationJobWithOptions(request, runtime);
}

model DeleteSourceServerRequest {
  force?: boolean(name='Force'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  sourceId?: string(name='SourceId'),
}

model DeleteSourceServerResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteSourceServerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSourceServerResponseBody(name='body'),
}

async function deleteSourceServerWithOptions(request: DeleteSourceServerRequest, runtime: Util.RuntimeOptions): DeleteSourceServerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.force)) {
    query['Force'] = request.force;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.sourceId)) {
    query['SourceId'] = request.sourceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSourceServer',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSourceServer(request: DeleteSourceServerRequest): DeleteSourceServerResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSourceServerWithOptions(request, runtime);
}

model DescribeReplicationJobsRequest {
  businessStatus?: string(name='BusinessStatus'),
  instanceId?: [ string ](name='InstanceId'),
  jobId?: [ string ](name='JobId'),
  jobType?: int32(name='JobType'),
  name?: string(name='Name'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  sourceId?: [ string ](name='SourceId'),
  status?: string(name='Status'),
}

model DescribeReplicationJobsResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  replicationJobs?: {
    replicationJob?: [ 
    {
      businessStatus?: string(name='BusinessStatus'),
      containerNamespace?: string(name='ContainerNamespace'),
      containerRepository?: string(name='ContainerRepository'),
      containerTag?: string(name='ContainerTag'),
      creationTime?: string(name='CreationTime'),
      dataDisks?: {
        dataDisk?: [ 
        {
          index?: int32(name='Index'),
          parts?: {
            part?: [ 
            {
              block?: boolean(name='Block'),
              device?: string(name='Device'),
              sizeBytes?: long(name='SizeBytes'),
            }
          ](name='Part')
          }(name='Parts'),
          size?: int32(name='Size'),
        }
      ](name='DataDisk')
      }(name='DataDisks'),
      description?: string(name='Description'),
      endTime?: string(name='EndTime'),
      errorCode?: string(name='ErrorCode'),
      frequency?: int32(name='Frequency'),
      imageId?: string(name='ImageId'),
      imageName?: string(name='ImageName'),
      instanceId?: string(name='InstanceId'),
      instanceRamRole?: string(name='InstanceRamRole'),
      instanceType?: string(name='InstanceType'),
      jobId?: string(name='JobId'),
      jobType?: int32(name='JobType'),
      launchTemplateId?: string(name='LaunchTemplateId'),
      launchTemplateVersion?: string(name='LaunchTemplateVersion'),
      licenseType?: string(name='LicenseType'),
      maxNumberOfImageToKeep?: int32(name='MaxNumberOfImageToKeep'),
      name?: string(name='Name'),
      netMode?: int32(name='NetMode'),
      progress?: float(name='Progress'),
      regionId?: string(name='RegionId'),
      replicationJobRuns?: {
        replicationJobRun?: [ 
        {
          endTime?: string(name='EndTime'),
          imageId?: string(name='ImageId'),
          startTime?: string(name='StartTime'),
          type?: string(name='Type'),
        }
      ](name='ReplicationJobRun')
      }(name='ReplicationJobRuns'),
      replicationParameters?: string(name='ReplicationParameters'),
      runOnce?: boolean(name='RunOnce'),
      scheduledStartTime?: string(name='ScheduledStartTime'),
      sourceId?: string(name='SourceId'),
      startTime?: string(name='StartTime'),
      status?: string(name='Status'),
      statusInfo?: string(name='StatusInfo'),
      systemDiskParts?: {
        systemDiskPart?: [ 
        {
          block?: boolean(name='Block'),
          device?: string(name='Device'),
          sizeBytes?: long(name='SizeBytes'),
        }
      ](name='SystemDiskPart')
      }(name='SystemDiskParts'),
      systemDiskSize?: int32(name='SystemDiskSize'),
      targetType?: string(name='TargetType'),
      transitionInstanceId?: string(name='TransitionInstanceId'),
      vSwitchId?: string(name='VSwitchId'),
      validTime?: string(name='ValidTime'),
      vpcId?: string(name='VpcId'),
    }
  ](name='ReplicationJob')
  }(name='ReplicationJobs'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeReplicationJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeReplicationJobsResponseBody(name='body'),
}

async function describeReplicationJobsWithOptions(request: DescribeReplicationJobsRequest, runtime: Util.RuntimeOptions): DescribeReplicationJobsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.businessStatus)) {
    query['BusinessStatus'] = request.businessStatus;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.jobType)) {
    query['JobType'] = request.jobType;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.sourceId)) {
    query['SourceId'] = request.sourceId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeReplicationJobs',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeReplicationJobs(request: DescribeReplicationJobsRequest): DescribeReplicationJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeReplicationJobsWithOptions(request, runtime);
}

model DescribeSourceServersRequest {
  jobId?: string(name='JobId'),
  name?: string(name='Name'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  sourceId?: [ string ](name='SourceId'),
  state?: string(name='State'),
}

model DescribeSourceServersResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  sourceServers?: {
    sourceServer?: [ 
    {
      agentVersion?: string(name='AgentVersion'),
      architecture?: string(name='Architecture'),
      creationTime?: string(name='CreationTime'),
      dataDisks?: {
        dataDisk?: [ 
        {
          index?: int32(name='Index'),
          parts?: {
            part?: [ 
            {
              canBlock?: boolean(name='CanBlock'),
              device?: string(name='Device'),
              need?: boolean(name='Need'),
              path?: string(name='Path'),
              sizeBytes?: long(name='SizeBytes'),
            }
          ](name='Part')
          }(name='Parts'),
          path?: string(name='Path'),
          size?: int32(name='Size'),
        }
      ](name='DataDisk')
      }(name='DataDisks'),
      description?: string(name='Description'),
      errorCode?: string(name='ErrorCode'),
      heartbeatRate?: int32(name='HeartbeatRate'),
      jobId?: string(name='JobId'),
      kernelLevel?: int32(name='KernelLevel'),
      name?: string(name='Name'),
      platform?: string(name='Platform'),
      replicationDriver?: string(name='ReplicationDriver'),
      sourceId?: string(name='SourceId'),
      state?: string(name='State'),
      statusInfo?: string(name='StatusInfo'),
      systemDiskParts?: {
        systemDiskPart?: [ 
        {
          canBlock?: boolean(name='CanBlock'),
          device?: string(name='Device'),
          need?: boolean(name='Need'),
          path?: string(name='Path'),
          sizeBytes?: long(name='SizeBytes'),
        }
      ](name='SystemDiskPart')
      }(name='SystemDiskParts'),
      systemDiskSize?: int32(name='SystemDiskSize'),
      systemInfo?: string(name='SystemInfo'),
    }
  ](name='SourceServer')
  }(name='SourceServers'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeSourceServersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSourceServersResponseBody(name='body'),
}

async function describeSourceServersWithOptions(request: DescribeSourceServersRequest, runtime: Util.RuntimeOptions): DescribeSourceServersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.sourceId)) {
    query['SourceId'] = request.sourceId;
  }
  if (!Util.isUnset(request.state)) {
    query['State'] = request.state;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSourceServers',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSourceServers(request: DescribeSourceServersRequest): DescribeSourceServersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSourceServersWithOptions(request, runtime);
}

model DisableAccessTokenRequest {
  accessTokenId?: string(name='AccessTokenId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
}

model DisableAccessTokenResponseBody = {
  requestId?: string(name='RequestId'),
}

model DisableAccessTokenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DisableAccessTokenResponseBody(name='body'),
}

async function disableAccessTokenWithOptions(request: DisableAccessTokenRequest, runtime: Util.RuntimeOptions): DisableAccessTokenResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessTokenId)) {
    query['AccessTokenId'] = request.accessTokenId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableAccessToken',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function disableAccessToken(request: DisableAccessTokenRequest): DisableAccessTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableAccessTokenWithOptions(request, runtime);
}

model ListAccessTokensRequest {
  accessTokenId?: [ string ](name='AccessTokenId'),
  name?: string(name='Name'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  status?: string(name='Status'),
}

model ListAccessTokensResponseBody = {
  accessTokens?: {
    accessToken?: [ 
    {
      accessTokenId?: string(name='AccessTokenId'),
      count?: string(name='Count'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      name?: string(name='Name'),
      registeredCount?: string(name='RegisteredCount'),
      status?: string(name='Status'),
      timeToLiveInDays?: string(name='TimeToLiveInDays'),
    }
  ](name='AccessToken')
  }(name='AccessTokens'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListAccessTokensResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAccessTokensResponseBody(name='body'),
}

async function listAccessTokensWithOptions(request: ListAccessTokensRequest, runtime: Util.RuntimeOptions): ListAccessTokensResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessTokenId)) {
    query['AccessTokenId'] = request.accessTokenId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAccessTokens',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAccessTokens(request: ListAccessTokensRequest): ListAccessTokensResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAccessTokensWithOptions(request, runtime);
}

model ListTagResourcesRequest {
  nextToken?: string(name='NextToken'),
  ownerId?: long(name='OwnerId'),
  resourceId?: [ string ](name='ResourceId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceType?: string(name='ResourceType'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  tagResources?: {
    tagResource?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='TagResource')
  }(name='TagResources'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagResources',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagResourcesWithOptions(request, runtime);
}

model ModifyReplicationJobAttributeRequest {
  containerNamespace?: string(name='ContainerNamespace'),
  containerRepository?: string(name='ContainerRepository'),
  containerTag?: string(name='ContainerTag'),
  dataDisk?: [ 
    {
      index?: int32(name='Index'),
      part?: [ 
        {
          block?: boolean(name='Block'),
          device?: string(name='Device'),
          sizeBytes?: long(name='SizeBytes'),
        }
      ](name='Part'),
      size?: int32(name='Size'),
    }
  ](name='DataDisk'),
  description?: string(name='Description'),
  frequency?: int32(name='Frequency'),
  imageName?: string(name='ImageName'),
  instanceId?: string(name='InstanceId'),
  instanceRamRole?: string(name='InstanceRamRole'),
  instanceType?: string(name='InstanceType'),
  jobId?: string(name='JobId'),
  launchTemplateId?: string(name='LaunchTemplateId'),
  launchTemplateVersion?: string(name='LaunchTemplateVersion'),
  maxNumberOfImageToKeep?: int32(name='MaxNumberOfImageToKeep'),
  name?: string(name='Name'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  scheduledStartTime?: string(name='ScheduledStartTime'),
  systemDiskPart?: [ 
    {
      block?: boolean(name='Block'),
      device?: string(name='Device'),
      sizeBytes?: long(name='SizeBytes'),
    }
  ](name='SystemDiskPart'),
  systemDiskSize?: int32(name='SystemDiskSize'),
  targetType?: string(name='TargetType'),
  validTime?: string(name='ValidTime'),
}

model ModifyReplicationJobAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyReplicationJobAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyReplicationJobAttributeResponseBody(name='body'),
}

async function modifyReplicationJobAttributeWithOptions(request: ModifyReplicationJobAttributeRequest, runtime: Util.RuntimeOptions): ModifyReplicationJobAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.containerNamespace)) {
    query['ContainerNamespace'] = request.containerNamespace;
  }
  if (!Util.isUnset(request.containerRepository)) {
    query['ContainerRepository'] = request.containerRepository;
  }
  if (!Util.isUnset(request.containerTag)) {
    query['ContainerTag'] = request.containerTag;
  }
  if (!Util.isUnset(request.dataDisk)) {
    query['DataDisk'] = request.dataDisk;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.frequency)) {
    query['Frequency'] = request.frequency;
  }
  if (!Util.isUnset(request.imageName)) {
    query['ImageName'] = request.imageName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceRamRole)) {
    query['InstanceRamRole'] = request.instanceRamRole;
  }
  if (!Util.isUnset(request.instanceType)) {
    query['InstanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.launchTemplateId)) {
    query['LaunchTemplateId'] = request.launchTemplateId;
  }
  if (!Util.isUnset(request.launchTemplateVersion)) {
    query['LaunchTemplateVersion'] = request.launchTemplateVersion;
  }
  if (!Util.isUnset(request.maxNumberOfImageToKeep)) {
    query['MaxNumberOfImageToKeep'] = request.maxNumberOfImageToKeep;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.scheduledStartTime)) {
    query['ScheduledStartTime'] = request.scheduledStartTime;
  }
  if (!Util.isUnset(request.systemDiskPart)) {
    query['SystemDiskPart'] = request.systemDiskPart;
  }
  if (!Util.isUnset(request.systemDiskSize)) {
    query['SystemDiskSize'] = request.systemDiskSize;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  if (!Util.isUnset(request.validTime)) {
    query['ValidTime'] = request.validTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyReplicationJobAttribute',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyReplicationJobAttribute(request: ModifyReplicationJobAttributeRequest): ModifyReplicationJobAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyReplicationJobAttributeWithOptions(request, runtime);
}

model ModifySourceServerAttributeRequest {
  description?: string(name='Description'),
  name?: string(name='Name'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  sourceId?: string(name='SourceId'),
}

model ModifySourceServerAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifySourceServerAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifySourceServerAttributeResponseBody(name='body'),
}

async function modifySourceServerAttributeWithOptions(request: ModifySourceServerAttributeRequest, runtime: Util.RuntimeOptions): ModifySourceServerAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.sourceId)) {
    query['SourceId'] = request.sourceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifySourceServerAttribute',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifySourceServerAttribute(request: ModifySourceServerAttributeRequest): ModifySourceServerAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifySourceServerAttributeWithOptions(request, runtime);
}

model StartReplicationJobRequest {
  jobId?: string(name='JobId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
}

model StartReplicationJobResponseBody = {
  requestId?: string(name='RequestId'),
}

model StartReplicationJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartReplicationJobResponseBody(name='body'),
}

async function startReplicationJobWithOptions(request: StartReplicationJobRequest, runtime: Util.RuntimeOptions): StartReplicationJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartReplicationJob',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startReplicationJob(request: StartReplicationJobRequest): StartReplicationJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return startReplicationJobWithOptions(request, runtime);
}

model StopReplicationJobRequest {
  jobId?: string(name='JobId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
}

model StopReplicationJobResponseBody = {
  requestId?: string(name='RequestId'),
}

model StopReplicationJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopReplicationJobResponseBody(name='body'),
}

async function stopReplicationJobWithOptions(request: StopReplicationJobRequest, runtime: Util.RuntimeOptions): StopReplicationJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopReplicationJob',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopReplicationJob(request: StopReplicationJobRequest): StopReplicationJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopReplicationJobWithOptions(request, runtime);
}

model TagResourcesRequest {
  ownerId?: long(name='OwnerId'),
  resourceId?: [ string ](name='ResourceId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceType?: string(name='ResourceType'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResourcesWithOptions(request: TagResourcesRequest, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TagResources',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagResourcesWithOptions(request, runtime);
}

model UntagResourcesRequest {
  all?: boolean(name='All'),
  ownerId?: long(name='OwnerId'),
  resourceId?: [ string ](name='ResourceId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceType?: string(name='ResourceType'),
  tagKey?: [ string ](name='TagKey'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResourcesWithOptions(request: UntagResourcesRequest, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.all)) {
    query['All'] = request.all;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagKey)) {
    query['TagKey'] = request.tagKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UntagResources',
    version = '2019-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return untagResourcesWithOptions(request, runtime);
}

