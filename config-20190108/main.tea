/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'central';
  @endpointMap = {
    cn-shanghai = 'config.cn-shanghai.aliyuncs.com',
    ap-southeast-1 = 'config.ap-southeast-1.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('config', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model ActiveConfigRulesRequest {
  configRuleIds?: string(name='ConfigRuleIds'),
}

model ActiveConfigRulesResponseBody = {
  operateRuleResult?: {
    operateRuleItemList?: [ 
      {
        configRuleId?: string(name='ConfigRuleId'),
        errorCode?: string(name='ErrorCode'),
        success?: boolean(name='Success'),
      }
    ](name='OperateRuleItemList'),
  }(name='OperateRuleResult'),
  requestId?: string(name='RequestId'),
}

model ActiveConfigRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ActiveConfigRulesResponseBody(name='body'),
}

async function activeConfigRulesWithOptions(request: ActiveConfigRulesRequest, runtime: Util.RuntimeOptions): ActiveConfigRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.configRuleIds)) {
    query['ConfigRuleIds'] = request.configRuleIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ActiveConfigRules',
    version = '2019-01-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function activeConfigRules(request: ActiveConfigRulesRequest): ActiveConfigRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return activeConfigRulesWithOptions(request, runtime);
}

model DeleteConfigRulesRequest {
  configRuleIds?: string(name='ConfigRuleIds'),
}

model DeleteConfigRulesResponseBody = {
  operateRuleResult?: {
    operateRuleItemList?: [ 
      {
        configRuleId?: string(name='ConfigRuleId'),
        errorCode?: string(name='ErrorCode'),
        success?: boolean(name='Success'),
      }
    ](name='OperateRuleItemList'),
  }(name='OperateRuleResult'),
  requestId?: string(name='RequestId'),
}

model DeleteConfigRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteConfigRulesResponseBody(name='body'),
}

async function deleteConfigRulesWithOptions(request: DeleteConfigRulesRequest, runtime: Util.RuntimeOptions): DeleteConfigRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.configRuleIds)) {
    query['ConfigRuleIds'] = request.configRuleIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteConfigRules',
    version = '2019-01-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteConfigRules(request: DeleteConfigRulesRequest): DeleteConfigRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteConfigRulesWithOptions(request, runtime);
}

model DescribeComplianceRequest {
  complianceType?: string(name='ComplianceType'),
  configRuleId?: string(name='ConfigRuleId'),
  memberId?: long(name='MemberId'),
  multiAccount?: boolean(name='MultiAccount'),
  resourceId?: string(name='ResourceId'),
  resourceType?: string(name='ResourceType'),
}

model DescribeComplianceResponseBody = {
  complianceResult?: {
    compliances?: [ 
      {
        complianceType?: string(name='ComplianceType'),
        count?: int32(name='Count'),
      }
    ](name='Compliances'),
    totalCount?: long(name='TotalCount'),
  }(name='ComplianceResult'),
  requestId?: string(name='RequestId'),
}

model DescribeComplianceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeComplianceResponseBody(name='body'),
}

async function describeComplianceWithOptions(request: DescribeComplianceRequest, runtime: Util.RuntimeOptions): DescribeComplianceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.complianceType)) {
    query['ComplianceType'] = request.complianceType;
  }
  if (!Util.isUnset(request.configRuleId)) {
    query['ConfigRuleId'] = request.configRuleId;
  }
  if (!Util.isUnset(request.memberId)) {
    query['MemberId'] = request.memberId;
  }
  if (!Util.isUnset(request.multiAccount)) {
    query['MultiAccount'] = request.multiAccount;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCompliance',
    version = '2019-01-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCompliance(request: DescribeComplianceRequest): DescribeComplianceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeComplianceWithOptions(request, runtime);
}

model DescribeComplianceSummaryRequest {
  memberId?: long(name='MemberId'),
  multiAccount?: boolean(name='MultiAccount'),
}

model DescribeComplianceSummaryResponseBody = {
  complianceSummary?: {
    complianceSummaryByConfigRule?: {
      complianceSummaryTimestamp?: long(name='ComplianceSummaryTimestamp'),
      compliantCount?: int32(name='CompliantCount'),
      nonCompliantCount?: int32(name='NonCompliantCount'),
      totalCount?: long(name='TotalCount'),
    }(name='ComplianceSummaryByConfigRule'),
    complianceSummaryByResource?: {
      complianceSummaryTimestamp?: long(name='ComplianceSummaryTimestamp'),
      compliantCount?: int32(name='CompliantCount'),
      nonCompliantCount?: int32(name='NonCompliantCount'),
      totalCount?: long(name='TotalCount'),
    }(name='ComplianceSummaryByResource'),
  }(name='ComplianceSummary'),
  requestId?: string(name='RequestId'),
}

model DescribeComplianceSummaryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeComplianceSummaryResponseBody(name='body'),
}

async function describeComplianceSummaryWithOptions(request: DescribeComplianceSummaryRequest, runtime: Util.RuntimeOptions): DescribeComplianceSummaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.memberId)) {
    query['MemberId'] = request.memberId;
  }
  if (!Util.isUnset(request.multiAccount)) {
    query['MultiAccount'] = request.multiAccount;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeComplianceSummary',
    version = '2019-01-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeComplianceSummary(request: DescribeComplianceSummaryRequest): DescribeComplianceSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeComplianceSummaryWithOptions(request, runtime);
}

model DescribeConfigRuleRequest {
  configRuleId?: string(name='ConfigRuleId'),
  memberId?: long(name='MemberId'),
  multiAccount?: boolean(name='MultiAccount'),
}

model DescribeConfigRuleResponseBody = {
  configRule?: {
    configRuleArn?: string(name='ConfigRuleArn'),
    configRuleEvaluationStatus?: {
      firstActivatedTimestamp?: long(name='FirstActivatedTimestamp'),
      firstEvaluationStarted?: boolean(name='FirstEvaluationStarted'),
      lastErrorCode?: string(name='LastErrorCode'),
      lastErrorMessage?: string(name='LastErrorMessage'),
      lastFailedEvaluationTimestamp?: long(name='LastFailedEvaluationTimestamp'),
      lastFailedInvocationTimestamp?: long(name='LastFailedInvocationTimestamp'),
      lastSuccessfulEvaluationTimestamp?: long(name='LastSuccessfulEvaluationTimestamp'),
      lastSuccessfulInvocationTimestamp?: long(name='LastSuccessfulInvocationTimestamp'),
    }(name='ConfigRuleEvaluationStatus'),
    configRuleId?: string(name='ConfigRuleId'),
    configRuleName?: string(name='ConfigRuleName'),
    configRuleState?: string(name='ConfigRuleState'),
    createTimestamp?: long(name='CreateTimestamp'),
    description?: string(name='Description'),
    inputParameters?: map[string]any(name='InputParameters'),
    managedRule?: {
      compulsoryInputParameterDetails?: map[string]any(name='CompulsoryInputParameterDetails'),
      description?: string(name='Description'),
      identifier?: string(name='Identifier'),
      labels?: [ string ](name='Labels'),
      managedRuleName?: string(name='ManagedRuleName'),
      optionalInputParameterDetails?: map[string]any(name='OptionalInputParameterDetails'),
      sourceDetails?: [ 
        {
          eventSource?: string(name='EventSource'),
          maximumExecutionFrequency?: string(name='MaximumExecutionFrequency'),
          messageType?: string(name='MessageType'),
        }
      ](name='SourceDetails'),
    }(name='ManagedRule'),
    maximumExecutionFrequency?: string(name='MaximumExecutionFrequency'),
    modifiedTimestamp?: long(name='ModifiedTimestamp'),
    riskLevel?: int32(name='RiskLevel'),
    scope?: {
      complianceResourceId?: string(name='ComplianceResourceId'),
      complianceResourceTypes?: [ string ](name='ComplianceResourceTypes'),
    }(name='Scope'),
    source?: {
      identifier?: string(name='Identifier'),
      owner?: string(name='Owner'),
      sourceConditions?: [ 
        {
          desiredValue?: string(name='DesiredValue'),
          name?: string(name='Name'),
          operator?: string(name='Operator'),
          tips?: string(name='Tips'),
        }
      ](name='SourceConditions'),
      sourceDetails?: [ 
        {
          eventSource?: string(name='EventSource'),
          maximumExecutionFrequency?: string(name='MaximumExecutionFrequency'),
          messageType?: string(name='MessageType'),
        }
      ](name='SourceDetails'),
    }(name='Source'),
  }(name='ConfigRule'),
  requestId?: string(name='RequestId'),
}

model DescribeConfigRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeConfigRuleResponseBody(name='body'),
}

async function describeConfigRuleWithOptions(request: DescribeConfigRuleRequest, runtime: Util.RuntimeOptions): DescribeConfigRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.configRuleId)) {
    query['ConfigRuleId'] = request.configRuleId;
  }
  if (!Util.isUnset(request.memberId)) {
    query['MemberId'] = request.memberId;
  }
  if (!Util.isUnset(request.multiAccount)) {
    query['MultiAccount'] = request.multiAccount;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeConfigRule',
    version = '2019-01-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeConfigRule(request: DescribeConfigRuleRequest): DescribeConfigRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeConfigRuleWithOptions(request, runtime);
}

model DescribeConfigurationRecorderResponseBody = {
  configurationRecorder?: {
    accountId?: long(name='AccountId'),
    configurationRecorderStatus?: string(name='ConfigurationRecorderStatus'),
    organizationEnableStatus?: string(name='OrganizationEnableStatus'),
    organizationMasterId?: long(name='OrganizationMasterId'),
    resourceTypes?: [ string ](name='ResourceTypes'),
  }(name='ConfigurationRecorder'),
  requestId?: string(name='RequestId'),
}

model DescribeConfigurationRecorderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeConfigurationRecorderResponseBody(name='body'),
}

async function describeConfigurationRecorderWithOptions(runtime: Util.RuntimeOptions): DescribeConfigurationRecorderResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeConfigurationRecorder',
    version = '2019-01-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeConfigurationRecorder(): DescribeConfigurationRecorderResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeConfigurationRecorderWithOptions(runtime);
}

model DescribeDeliveryChannelsRequest {
  deliveryChannelIds?: string(name='DeliveryChannelIds'),
}

model DescribeDeliveryChannelsResponseBody = {
  deliveryChannels?: [ 
    {
      configurationItemChangeNotification?: boolean(name='ConfigurationItemChangeNotification'),
      configurationSnapshot?: boolean(name='ConfigurationSnapshot'),
      deliveryChannelAssumeRoleArn?: string(name='DeliveryChannelAssumeRoleArn'),
      deliveryChannelCondition?: string(name='DeliveryChannelCondition'),
      deliveryChannelId?: string(name='DeliveryChannelId'),
      deliveryChannelName?: string(name='DeliveryChannelName'),
      deliveryChannelTargetArn?: string(name='DeliveryChannelTargetArn'),
      deliveryChannelType?: string(name='DeliveryChannelType'),
      description?: string(name='Description'),
      nonCompliantNotification?: boolean(name='NonCompliantNotification'),
      oversizedDataOSSTargetArn?: string(name='OversizedDataOSSTargetArn'),
      status?: int32(name='Status'),
    }
  ](name='DeliveryChannels'),
  requestId?: string(name='RequestId'),
}

model DescribeDeliveryChannelsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDeliveryChannelsResponseBody(name='body'),
}

async function describeDeliveryChannelsWithOptions(request: DescribeDeliveryChannelsRequest, runtime: Util.RuntimeOptions): DescribeDeliveryChannelsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deliveryChannelIds)) {
    query['DeliveryChannelIds'] = request.deliveryChannelIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDeliveryChannels',
    version = '2019-01-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDeliveryChannels(request: DescribeDeliveryChannelsRequest): DescribeDeliveryChannelsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDeliveryChannelsWithOptions(request, runtime);
}

model DescribeDiscoveredResourceRequest {
  memberId?: long(name='MemberId'),
  multiAccount?: boolean(name='MultiAccount'),
  region?: string(name='Region'),
  resourceId?: string(name='ResourceId'),
  resourceType?: string(name='ResourceType'),
}

model DescribeDiscoveredResourceResponseBody = {
  discoveredResourceDetail?: {
    accountId?: long(name='AccountId'),
    availabilityZone?: string(name='AvailabilityZone'),
    configuration?: string(name='Configuration'),
    region?: string(name='Region'),
    resourceCreationTime?: long(name='ResourceCreationTime'),
    resourceDeleted?: int32(name='ResourceDeleted'),
    resourceId?: string(name='ResourceId'),
    resourceName?: string(name='ResourceName'),
    resourceStatus?: string(name='ResourceStatus'),
    resourceType?: string(name='ResourceType'),
    tags?: string(name='Tags'),
  }(name='DiscoveredResourceDetail'),
  requestId?: string(name='RequestId'),
}

model DescribeDiscoveredResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDiscoveredResourceResponseBody(name='body'),
}

async function describeDiscoveredResourceWithOptions(request: DescribeDiscoveredResourceRequest, runtime: Util.RuntimeOptions): DescribeDiscoveredResourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.memberId)) {
    query['MemberId'] = request.memberId;
  }
  if (!Util.isUnset(request.multiAccount)) {
    query['MultiAccount'] = request.multiAccount;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDiscoveredResource',
    version = '2019-01-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDiscoveredResource(request: DescribeDiscoveredResourceRequest): DescribeDiscoveredResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDiscoveredResourceWithOptions(request, runtime);
}

model DescribeEvaluationResultsRequest {
  complianceType?: string(name='ComplianceType'),
  configRuleId?: string(name='ConfigRuleId'),
  memberId?: long(name='MemberId'),
  multiAccount?: boolean(name='MultiAccount'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  resourceId?: string(name='ResourceId'),
  resourceType?: string(name='ResourceType'),
}

model DescribeEvaluationResultsResponseBody = {
  evaluationResults?: {
    evaluationResultList?: [ 
      {
        annotation?: string(name='Annotation'),
        complianceType?: string(name='ComplianceType'),
        configRuleInvokedTimestamp?: long(name='ConfigRuleInvokedTimestamp'),
        evaluationResultIdentifier?: {
          evaluationResultQualifier?: {
            configRuleArn?: string(name='ConfigRuleArn'),
            configRuleId?: string(name='ConfigRuleId'),
            configRuleName?: string(name='ConfigRuleName'),
            regionId?: string(name='RegionId'),
            resourceId?: string(name='ResourceId'),
            resourceName?: string(name='ResourceName'),
            resourceType?: string(name='ResourceType'),
          }(name='EvaluationResultQualifier'),
          orderingTimestamp?: long(name='OrderingTimestamp'),
        }(name='EvaluationResultIdentifier'),
        invokingEventMessageType?: string(name='InvokingEventMessageType'),
        remediationEnabled?: boolean(name='RemediationEnabled'),
        resultRecordedTimestamp?: long(name='ResultRecordedTimestamp'),
        riskLevel?: int32(name='RiskLevel'),
      }
    ](name='EvaluationResultList'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: long(name='TotalCount'),
  }(name='EvaluationResults'),
  requestId?: string(name='RequestId'),
}

model DescribeEvaluationResultsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeEvaluationResultsResponseBody(name='body'),
}

async function describeEvaluationResultsWithOptions(request: DescribeEvaluationResultsRequest, runtime: Util.RuntimeOptions): DescribeEvaluationResultsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeEvaluationResults',
    version = '2019-01-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeEvaluationResults(request: DescribeEvaluationResultsRequest): DescribeEvaluationResultsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEvaluationResultsWithOptions(request, runtime);
}

model GetAggregateDiscoveredResourceRequest {
  aggregatorId?: string(name='AggregatorId'),
  region?: string(name='Region'),
  resourceId?: string(name='ResourceId'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType'),
}

model GetAggregateDiscoveredResourceResponseBody = {
  discoveredResourceDetail?: {
    accountId?: long(name='AccountId'),
    availabilityZone?: string(name='AvailabilityZone'),
    configuration?: string(name='Configuration'),
    region?: string(name='Region'),
    resourceCreationTime?: long(name='ResourceCreationTime'),
    resourceDeleted?: int32(name='ResourceDeleted'),
    resourceId?: string(name='ResourceId'),
    resourceName?: string(name='ResourceName'),
    resourceStatus?: string(name='ResourceStatus'),
    resourceType?: string(name='ResourceType'),
    tags?: string(name='Tags'),
  }(name='DiscoveredResourceDetail'),
  requestId?: string(name='RequestId'),
}

model GetAggregateDiscoveredResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAggregateDiscoveredResourceResponseBody(name='body'),
}

async function getAggregateDiscoveredResourceWithOptions(request: GetAggregateDiscoveredResourceRequest, runtime: Util.RuntimeOptions): GetAggregateDiscoveredResourceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAggregateDiscoveredResource',
    version = '2019-01-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAggregateDiscoveredResource(request: GetAggregateDiscoveredResourceRequest): GetAggregateDiscoveredResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAggregateDiscoveredResourceWithOptions(request, runtime);
}

model GetDiscoveredResourceCountsRequest {
  groupByKey?: string(name='GroupByKey'),
  memberId?: long(name='MemberId'),
  multiAccount?: boolean(name='MultiAccount'),
}

model GetDiscoveredResourceCountsResponseBody = {
  groupedResourceCounts?: {
    groupByKey?: string(name='GroupByKey'),
    groupedResourceCountList?: [ 
      {
        groupName?: string(name='GroupName'),
        resourceCount?: long(name='ResourceCount'),
      }
    ](name='GroupedResourceCountList'),
  }(name='GroupedResourceCounts'),
  requestId?: string(name='RequestId'),
}

model GetDiscoveredResourceCountsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDiscoveredResourceCountsResponseBody(name='body'),
}

async function getDiscoveredResourceCountsWithOptions(request: GetDiscoveredResourceCountsRequest, runtime: Util.RuntimeOptions): GetDiscoveredResourceCountsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupByKey)) {
    query['GroupByKey'] = request.groupByKey;
  }
  if (!Util.isUnset(request.memberId)) {
    query['MemberId'] = request.memberId;
  }
  if (!Util.isUnset(request.multiAccount)) {
    query['MultiAccount'] = request.multiAccount;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDiscoveredResourceCounts',
    version = '2019-01-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDiscoveredResourceCounts(request: GetDiscoveredResourceCountsRequest): GetDiscoveredResourceCountsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDiscoveredResourceCountsWithOptions(request, runtime);
}

model GetDiscoveredResourceSummaryRequest {
  memberId?: long(name='MemberId'),
  multiAccount?: boolean(name='MultiAccount'),
}

model GetDiscoveredResourceSummaryResponseBody = {
  discoveredResourceSummary?: {
    regionCount?: int32(name='RegionCount'),
    resourceCount?: int32(name='ResourceCount'),
    resourceTypeCount?: int32(name='ResourceTypeCount'),
  }(name='DiscoveredResourceSummary'),
  requestId?: string(name='RequestId'),
}

model GetDiscoveredResourceSummaryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDiscoveredResourceSummaryResponseBody(name='body'),
}

async function getDiscoveredResourceSummaryWithOptions(request: GetDiscoveredResourceSummaryRequest, runtime: Util.RuntimeOptions): GetDiscoveredResourceSummaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.memberId)) {
    query['MemberId'] = request.memberId;
  }
  if (!Util.isUnset(request.multiAccount)) {
    query['MultiAccount'] = request.multiAccount;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDiscoveredResourceSummary',
    version = '2019-01-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDiscoveredResourceSummary(request: GetDiscoveredResourceSummaryRequest): GetDiscoveredResourceSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDiscoveredResourceSummaryWithOptions(request, runtime);
}

model GetResourceComplianceTimelineRequest {
  endTime?: long(name='EndTime'),
  limit?: int32(name='Limit'),
  memberId?: string(name='MemberId'),
  multiAccount?: boolean(name='MultiAccount'),
  nextToken?: string(name='NextToken'),
  region?: string(name='Region'),
  resourceId?: string(name='ResourceId'),
  resourceType?: string(name='ResourceType'),
  startTime?: long(name='StartTime'),
}

model GetResourceComplianceTimelineResponseBody = {
  requestId?: string(name='RequestId'),
  resourceComplianceTimeline?: {
    complianceList?: [ 
      {
        accountId?: string(name='AccountId'),
        availabilityZone?: string(name='AvailabilityZone'),
        captureTime?: long(name='CaptureTime'),
        configuration?: string(name='Configuration'),
        configurationDiff?: string(name='ConfigurationDiff'),
        region?: string(name='Region'),
        resourceCreateTime?: long(name='ResourceCreateTime'),
        resourceId?: string(name='ResourceId'),
        resourceName?: string(name='ResourceName'),
        resourceStatus?: string(name='ResourceStatus'),
        resourceType?: string(name='ResourceType'),
        tags?: string(name='Tags'),
      }
    ](name='ComplianceList'),
    limit?: int32(name='Limit'),
    nextToken?: string(name='NextToken'),
    totalCount?: long(name='TotalCount'),
  }(name='ResourceComplianceTimeline'),
}

model GetResourceComplianceTimelineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetResourceComplianceTimelineResponseBody(name='body'),
}

async function getResourceComplianceTimelineWithOptions(request: GetResourceComplianceTimelineRequest, runtime: Util.RuntimeOptions): GetResourceComplianceTimelineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.memberId)) {
    query['MemberId'] = request.memberId;
  }
  if (!Util.isUnset(request.multiAccount)) {
    query['MultiAccount'] = request.multiAccount;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetResourceComplianceTimeline',
    version = '2019-01-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getResourceComplianceTimeline(request: GetResourceComplianceTimelineRequest): GetResourceComplianceTimelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return getResourceComplianceTimelineWithOptions(request, runtime);
}

model GetResourceConfigurationTimelineRequest {
  endTime?: long(name='EndTime'),
  limit?: int32(name='Limit'),
  memberId?: long(name='MemberId'),
  multiAccount?: boolean(name='MultiAccount'),
  nextToken?: string(name='NextToken'),
  region?: string(name='Region'),
  resourceId?: string(name='ResourceId'),
  resourceType?: string(name='ResourceType'),
  startTime?: long(name='StartTime'),
}

model GetResourceConfigurationTimelineResponseBody = {
  requestId?: string(name='RequestId'),
  resourceConfigurationTimeline?: {
    configurationList?: [ 
      {
        accountId?: long(name='AccountId'),
        availabilityZone?: string(name='AvailabilityZone'),
        captureTime?: string(name='CaptureTime'),
        configurationDiff?: string(name='ConfigurationDiff'),
        region?: string(name='Region'),
        resourceCreateTime?: string(name='ResourceCreateTime'),
        resourceEventType?: string(name='ResourceEventType'),
        resourceId?: string(name='ResourceId'),
        resourceName?: string(name='ResourceName'),
        resourceType?: string(name='ResourceType'),
        tags?: string(name='Tags'),
      }
    ](name='ConfigurationList'),
    limit?: int32(name='Limit'),
    nextToken?: string(name='NextToken'),
    totalCount?: long(name='TotalCount'),
  }(name='ResourceConfigurationTimeline'),
}

model GetResourceConfigurationTimelineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetResourceConfigurationTimelineResponseBody(name='body'),
}

async function getResourceConfigurationTimelineWithOptions(request: GetResourceConfigurationTimelineRequest, runtime: Util.RuntimeOptions): GetResourceConfigurationTimelineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.memberId)) {
    query['MemberId'] = request.memberId;
  }
  if (!Util.isUnset(request.multiAccount)) {
    query['MultiAccount'] = request.multiAccount;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetResourceConfigurationTimeline',
    version = '2019-01-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getResourceConfigurationTimeline(request: GetResourceConfigurationTimelineRequest): GetResourceConfigurationTimelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return getResourceConfigurationTimelineWithOptions(request, runtime);
}

model GetSupportedResourceTypesResponseBody = {
  requestId?: string(name='RequestId'),
  resourceTypes?: [ string ](name='ResourceTypes'),
}

model GetSupportedResourceTypesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSupportedResourceTypesResponseBody(name='body'),
}

async function getSupportedResourceTypesWithOptions(runtime: Util.RuntimeOptions): GetSupportedResourceTypesResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetSupportedResourceTypes',
    version = '2019-01-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSupportedResourceTypes(): GetSupportedResourceTypesResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSupportedResourceTypesWithOptions(runtime);
}

model ListAggregateDiscoveredResourcesRequest {
  aggregatorId?: string(name='AggregatorId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regions?: string(name='Regions'),
  resourceDeleted?: int32(name='ResourceDeleted'),
  resourceId?: string(name='ResourceId'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceTypes?: string(name='ResourceTypes'),
}

model ListAggregateDiscoveredResourcesResponseBody = {
  discoveredResourceProfiles?: {
    discoveredResourceProfileList?: [ 
      {
        accountId?: long(name='AccountId'),
        region?: string(name='Region'),
        resourceCreationTime?: long(name='ResourceCreationTime'),
        resourceDeleted?: int32(name='ResourceDeleted'),
        resourceId?: string(name='ResourceId'),
        resourceName?: string(name='ResourceName'),
        resourceOwnerId?: long(name='ResourceOwnerId'),
        resourceStatus?: string(name='ResourceStatus'),
        resourceType?: string(name='ResourceType'),
        tags?: string(name='Tags'),
      }
    ](name='DiscoveredResourceProfileList'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='DiscoveredResourceProfiles'),
  requestId?: string(name='RequestId'),
}

model ListAggregateDiscoveredResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAggregateDiscoveredResourcesResponseBody(name='body'),
}

async function listAggregateDiscoveredResourcesWithOptions(request: ListAggregateDiscoveredResourcesRequest, runtime: Util.RuntimeOptions): ListAggregateDiscoveredResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aggregatorId)) {
    query['AggregatorId'] = request.aggregatorId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regions)) {
    query['Regions'] = request.regions;
  }
  if (!Util.isUnset(request.resourceDeleted)) {
    query['ResourceDeleted'] = request.resourceDeleted;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.resourceTypes)) {
    query['ResourceTypes'] = request.resourceTypes;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAggregateDiscoveredResources',
    version = '2019-01-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAggregateDiscoveredResources(request: ListAggregateDiscoveredResourcesRequest): ListAggregateDiscoveredResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAggregateDiscoveredResourcesWithOptions(request, runtime);
}

model ListConfigRulesRequest {
  compliancePackId?: string(name='CompliancePackId'),
  complianceType?: string(name='ComplianceType'),
  configRuleName?: string(name='ConfigRuleName'),
  configRuleState?: string(name='ConfigRuleState'),
  memberId?: long(name='MemberId'),
  multiAccount?: boolean(name='MultiAccount'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  riskLevel?: int32(name='RiskLevel'),
}

model ListConfigRulesResponseBody = {
  configRules?: {
    configRuleList?: [ 
      {
        accountId?: long(name='AccountId'),
        automationType?: string(name='AutomationType'),
        compliance?: {
          complianceType?: string(name='ComplianceType'),
          count?: int32(name='Count'),
        }(name='Compliance'),
        compliancePackId?: string(name='CompliancePackId'),
        configRuleArn?: string(name='ConfigRuleArn'),
        configRuleId?: string(name='ConfigRuleId'),
        configRuleName?: string(name='ConfigRuleName'),
        configRuleState?: string(name='ConfigRuleState'),
        createBy?: {
          compliancePackId?: string(name='CompliancePackId'),
          compliancePackName?: string(name='CompliancePackName'),
        }(name='CreateBy'),
        description?: string(name='Description'),
        riskLevel?: int32(name='RiskLevel'),
        sourceIdentifier?: string(name='SourceIdentifier'),
        sourceOwner?: string(name='SourceOwner'),
        tags?: [ 
          {
            key?: string(name='Key'),
            value?: string(name='Value'),
          }
        ](name='Tags'),
      }
    ](name='ConfigRuleList'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: long(name='TotalCount'),
  }(name='ConfigRules'),
  requestId?: string(name='RequestId'),
}

model ListConfigRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListConfigRulesResponseBody(name='body'),
}

async function listConfigRulesWithOptions(request: ListConfigRulesRequest, runtime: Util.RuntimeOptions): ListConfigRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.compliancePackId)) {
    query['CompliancePackId'] = request.compliancePackId;
  }
  if (!Util.isUnset(request.complianceType)) {
    query['ComplianceType'] = request.complianceType;
  }
  if (!Util.isUnset(request.configRuleName)) {
    query['ConfigRuleName'] = request.configRuleName;
  }
  if (!Util.isUnset(request.configRuleState)) {
    query['ConfigRuleState'] = request.configRuleState;
  }
  if (!Util.isUnset(request.memberId)) {
    query['MemberId'] = request.memberId;
  }
  if (!Util.isUnset(request.multiAccount)) {
    query['MultiAccount'] = request.multiAccount;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.riskLevel)) {
    query['RiskLevel'] = request.riskLevel;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListConfigRules',
    version = '2019-01-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listConfigRules(request: ListConfigRulesRequest): ListConfigRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listConfigRulesWithOptions(request, runtime);
}

model ListDiscoveredResourcesRequest {
  memberId?: long(name='MemberId'),
  multiAccount?: boolean(name='MultiAccount'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regions?: string(name='Regions'),
  resourceDeleted?: int32(name='ResourceDeleted'),
  resourceId?: string(name='ResourceId'),
  resourceTypes?: string(name='ResourceTypes'),
}

model ListDiscoveredResourcesResponseBody = {
  discoveredResourceProfiles?: {
    discoveredResourceProfileList?: [ 
      {
        accountId?: long(name='AccountId'),
        region?: string(name='Region'),
        resourceCreationTime?: long(name='ResourceCreationTime'),
        resourceDeleted?: int32(name='ResourceDeleted'),
        resourceId?: string(name='ResourceId'),
        resourceName?: string(name='ResourceName'),
        resourceStatus?: string(name='ResourceStatus'),
        resourceType?: string(name='ResourceType'),
        tags?: string(name='Tags'),
      }
    ](name='DiscoveredResourceProfileList'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='DiscoveredResourceProfiles'),
  requestId?: string(name='RequestId'),
}

model ListDiscoveredResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDiscoveredResourcesResponseBody(name='body'),
}

async function listDiscoveredResourcesWithOptions(request: ListDiscoveredResourcesRequest, runtime: Util.RuntimeOptions): ListDiscoveredResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.memberId)) {
    query['MemberId'] = request.memberId;
  }
  if (!Util.isUnset(request.multiAccount)) {
    query['MultiAccount'] = request.multiAccount;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regions)) {
    query['Regions'] = request.regions;
  }
  if (!Util.isUnset(request.resourceDeleted)) {
    query['ResourceDeleted'] = request.resourceDeleted;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceTypes)) {
    query['ResourceTypes'] = request.resourceTypes;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDiscoveredResources',
    version = '2019-01-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDiscoveredResources(request: ListDiscoveredResourcesRequest): ListDiscoveredResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDiscoveredResourcesWithOptions(request, runtime);
}

model ListRemediationTemplatesRequest {
  managedRuleIdentifier?: string(name='ManagedRuleIdentifier'),
  remediationType?: string(name='RemediationType'),
}

model ListRemediationTemplatesResponseBody = {
  remediationTemplates?: [ 
    {
      remediationType?: string(name='RemediationType'),
      templateDefinition?: string(name='TemplateDefinition'),
      templateIdentifier?: string(name='TemplateIdentifier'),
      templateName?: string(name='TemplateName'),
    }
  ](name='RemediationTemplates'),
  requestId?: string(name='RequestId'),
}

model ListRemediationTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRemediationTemplatesResponseBody(name='body'),
}

async function listRemediationTemplatesWithOptions(request: ListRemediationTemplatesRequest, runtime: Util.RuntimeOptions): ListRemediationTemplatesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.managedRuleIdentifier)) {
    query['ManagedRuleIdentifier'] = request.managedRuleIdentifier;
  }
  if (!Util.isUnset(request.remediationType)) {
    query['RemediationType'] = request.remediationType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRemediationTemplates',
    version = '2019-01-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listRemediationTemplates(request: ListRemediationTemplatesRequest): ListRemediationTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRemediationTemplatesWithOptions(request, runtime);
}

model PutConfigRuleRequest {
  clientToken?: string(name='ClientToken'),
  configRuleId?: string(name='ConfigRuleId'),
  configRuleName?: string(name='ConfigRuleName'),
  description?: string(name='Description'),
  inputParameters?: string(name='InputParameters'),
  memberId?: long(name='MemberId'),
  multiAccount?: boolean(name='MultiAccount'),
  riskLevel?: int32(name='RiskLevel'),
  scopeComplianceResourceId?: string(name='ScopeComplianceResourceId'),
  scopeComplianceResourceTypes?: string(name='ScopeComplianceResourceTypes'),
  sourceDetailMessageType?: string(name='SourceDetailMessageType'),
  sourceIdentifier?: string(name='SourceIdentifier'),
  sourceMaximumExecutionFrequency?: string(name='SourceMaximumExecutionFrequency'),
  sourceOwner?: string(name='SourceOwner'),
}

model PutConfigRuleResponseBody = {
  configRuleId?: string(name='ConfigRuleId'),
  requestId?: string(name='RequestId'),
}

model PutConfigRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PutConfigRuleResponseBody(name='body'),
}

async function putConfigRuleWithOptions(request: PutConfigRuleRequest, runtime: Util.RuntimeOptions): PutConfigRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.memberId)) {
    query['MemberId'] = request.memberId;
  }
  if (!Util.isUnset(request.multiAccount)) {
    query['MultiAccount'] = request.multiAccount;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.configRuleId)) {
    body['ConfigRuleId'] = request.configRuleId;
  }
  if (!Util.isUnset(request.configRuleName)) {
    body['ConfigRuleName'] = request.configRuleName;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.inputParameters)) {
    body['InputParameters'] = request.inputParameters;
  }
  if (!Util.isUnset(request.riskLevel)) {
    body['RiskLevel'] = request.riskLevel;
  }
  if (!Util.isUnset(request.scopeComplianceResourceId)) {
    body['ScopeComplianceResourceId'] = request.scopeComplianceResourceId;
  }
  if (!Util.isUnset(request.scopeComplianceResourceTypes)) {
    body['ScopeComplianceResourceTypes'] = request.scopeComplianceResourceTypes;
  }
  if (!Util.isUnset(request.sourceDetailMessageType)) {
    body['SourceDetailMessageType'] = request.sourceDetailMessageType;
  }
  if (!Util.isUnset(request.sourceIdentifier)) {
    body['SourceIdentifier'] = request.sourceIdentifier;
  }
  if (!Util.isUnset(request.sourceMaximumExecutionFrequency)) {
    body['SourceMaximumExecutionFrequency'] = request.sourceMaximumExecutionFrequency;
  }
  if (!Util.isUnset(request.sourceOwner)) {
    body['SourceOwner'] = request.sourceOwner;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PutConfigRule',
    version = '2019-01-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function putConfigRule(request: PutConfigRuleRequest): PutConfigRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return putConfigRuleWithOptions(request, runtime);
}

model PutConfigurationRecorderRequest {
  resourceTypes?: string(name='ResourceTypes'),
}

model PutConfigurationRecorderResponseBody = {
  configurationRecorder?: {
    accountId?: long(name='AccountId'),
    configurationRecorderStatus?: string(name='ConfigurationRecorderStatus'),
    resourceTypes?: [ string ](name='ResourceTypes'),
  }(name='ConfigurationRecorder'),
  requestId?: string(name='RequestId'),
}

model PutConfigurationRecorderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PutConfigurationRecorderResponseBody(name='body'),
}

async function putConfigurationRecorderWithOptions(request: PutConfigurationRecorderRequest, runtime: Util.RuntimeOptions): PutConfigurationRecorderResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.resourceTypes)) {
    body['ResourceTypes'] = request.resourceTypes;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PutConfigurationRecorder',
    version = '2019-01-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function putConfigurationRecorder(request: PutConfigurationRecorderRequest): PutConfigurationRecorderResponse {
  var runtime = new Util.RuntimeOptions{};
  return putConfigurationRecorderWithOptions(request, runtime);
}

model PutDeliveryChannelRequest {
  clientToken?: string(name='ClientToken'),
  deliveryChannelAssumeRoleArn?: string(name='DeliveryChannelAssumeRoleArn'),
  deliveryChannelCondition?: string(name='DeliveryChannelCondition'),
  deliveryChannelId?: string(name='DeliveryChannelId'),
  deliveryChannelName?: string(name='DeliveryChannelName'),
  deliveryChannelTargetArn?: string(name='DeliveryChannelTargetArn'),
  deliveryChannelType?: string(name='DeliveryChannelType'),
  description?: string(name='Description'),
  status?: int32(name='Status'),
}

model PutDeliveryChannelResponseBody = {
  deliveryChannelId?: string(name='DeliveryChannelId'),
  requestId?: string(name='RequestId'),
}

model PutDeliveryChannelResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PutDeliveryChannelResponseBody(name='body'),
}

async function putDeliveryChannelWithOptions(request: PutDeliveryChannelRequest, runtime: Util.RuntimeOptions): PutDeliveryChannelResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.deliveryChannelAssumeRoleArn)) {
    body['DeliveryChannelAssumeRoleArn'] = request.deliveryChannelAssumeRoleArn;
  }
  if (!Util.isUnset(request.deliveryChannelCondition)) {
    body['DeliveryChannelCondition'] = request.deliveryChannelCondition;
  }
  if (!Util.isUnset(request.deliveryChannelId)) {
    body['DeliveryChannelId'] = request.deliveryChannelId;
  }
  if (!Util.isUnset(request.deliveryChannelName)) {
    body['DeliveryChannelName'] = request.deliveryChannelName;
  }
  if (!Util.isUnset(request.deliveryChannelTargetArn)) {
    body['DeliveryChannelTargetArn'] = request.deliveryChannelTargetArn;
  }
  if (!Util.isUnset(request.deliveryChannelType)) {
    body['DeliveryChannelType'] = request.deliveryChannelType;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.status)) {
    body['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PutDeliveryChannel',
    version = '2019-01-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function putDeliveryChannel(request: PutDeliveryChannelRequest): PutDeliveryChannelResponse {
  var runtime = new Util.RuntimeOptions{};
  return putDeliveryChannelWithOptions(request, runtime);
}

model PutEvaluationsRequest {
  evaluations?: string(name='Evaluations'),
  resultToken?: string(name='ResultToken'),
}

model PutEvaluationsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model PutEvaluationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PutEvaluationsResponseBody(name='body'),
}

async function putEvaluationsWithOptions(request: PutEvaluationsRequest, runtime: Util.RuntimeOptions): PutEvaluationsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.evaluations)) {
    body['Evaluations'] = request.evaluations;
  }
  if (!Util.isUnset(request.resultToken)) {
    body['ResultToken'] = request.resultToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PutEvaluations',
    version = '2019-01-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function putEvaluations(request: PutEvaluationsRequest): PutEvaluationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return putEvaluationsWithOptions(request, runtime);
}

model StartConfigRuleEvaluationRequest {
  compliancePackId?: string(name='CompliancePackId'),
  configRuleId?: string(name='ConfigRuleId'),
  revertEvaluation?: boolean(name='RevertEvaluation'),
}

model StartConfigRuleEvaluationResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model StartConfigRuleEvaluationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartConfigRuleEvaluationResponseBody(name='body'),
}

async function startConfigRuleEvaluationWithOptions(request: StartConfigRuleEvaluationRequest, runtime: Util.RuntimeOptions): StartConfigRuleEvaluationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.compliancePackId)) {
    query['CompliancePackId'] = request.compliancePackId;
  }
  if (!Util.isUnset(request.configRuleId)) {
    query['ConfigRuleId'] = request.configRuleId;
  }
  if (!Util.isUnset(request.revertEvaluation)) {
    query['RevertEvaluation'] = request.revertEvaluation;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartConfigRuleEvaluation',
    version = '2019-01-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startConfigRuleEvaluation(request: StartConfigRuleEvaluationRequest): StartConfigRuleEvaluationResponse {
  var runtime = new Util.RuntimeOptions{};
  return startConfigRuleEvaluationWithOptions(request, runtime);
}

model StartConfigurationRecorderRequest {
  enterpriseEdition?: boolean(name='EnterpriseEdition'),
}

model StartConfigurationRecorderResponseBody = {
  configurationRecorder?: {
    accountId?: long(name='AccountId'),
    configurationRecorderStatus?: string(name='ConfigurationRecorderStatus'),
    organizationEnableStatus?: string(name='OrganizationEnableStatus'),
    organizationMasterId?: long(name='OrganizationMasterId'),
    resourceTypes?: [ string ](name='ResourceTypes'),
  }(name='ConfigurationRecorder'),
  requestId?: string(name='RequestId'),
}

model StartConfigurationRecorderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartConfigurationRecorderResponseBody(name='body'),
}

async function startConfigurationRecorderWithOptions(request: StartConfigurationRecorderRequest, runtime: Util.RuntimeOptions): StartConfigurationRecorderResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.enterpriseEdition)) {
    body['EnterpriseEdition'] = request.enterpriseEdition;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'StartConfigurationRecorder',
    version = '2019-01-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startConfigurationRecorder(request: StartConfigurationRecorderRequest): StartConfigurationRecorderResponse {
  var runtime = new Util.RuntimeOptions{};
  return startConfigurationRecorderWithOptions(request, runtime);
}

model StopConfigRulesRequest {
  configRuleIds?: string(name='ConfigRuleIds'),
}

model StopConfigRulesResponseBody = {
  operateRuleResult?: {
    operateRuleItemList?: [ 
      {
        configRuleId?: string(name='ConfigRuleId'),
        errorCode?: string(name='ErrorCode'),
        success?: boolean(name='Success'),
      }
    ](name='OperateRuleItemList'),
  }(name='OperateRuleResult'),
  requestId?: string(name='RequestId'),
}

model StopConfigRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopConfigRulesResponseBody(name='body'),
}

async function stopConfigRulesWithOptions(request: StopConfigRulesRequest, runtime: Util.RuntimeOptions): StopConfigRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.configRuleIds)) {
    query['ConfigRuleIds'] = request.configRuleIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopConfigRules',
    version = '2019-01-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopConfigRules(request: StopConfigRulesRequest): StopConfigRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopConfigRulesWithOptions(request, runtime);
}

