/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'central';
  
  checkConfig(config);
  @endpoint = getEndpoint('ram', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AddUserToGroupRequest {
  groupName?: string(name='GroupName'),
  userName?: string(name='UserName'),
}

model AddUserToGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddUserToGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddUserToGroupResponseBody(name='body'),
}

async function addUserToGroupWithOptions(request: AddUserToGroupRequest, runtime: Util.RuntimeOptions): AddUserToGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddUserToGroup',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addUserToGroup(request: AddUserToGroupRequest): AddUserToGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return addUserToGroupWithOptions(request, runtime);
}

model AttachPolicyToGroupRequest {
  groupName?: string(name='GroupName'),
  policyName?: string(name='PolicyName'),
  policyType?: string(name='PolicyType'),
}

model AttachPolicyToGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model AttachPolicyToGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AttachPolicyToGroupResponseBody(name='body'),
}

async function attachPolicyToGroupWithOptions(request: AttachPolicyToGroupRequest, runtime: Util.RuntimeOptions): AttachPolicyToGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.policyName)) {
    query['PolicyName'] = request.policyName;
  }
  if (!Util.isUnset(request.policyType)) {
    query['PolicyType'] = request.policyType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AttachPolicyToGroup',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function attachPolicyToGroup(request: AttachPolicyToGroupRequest): AttachPolicyToGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachPolicyToGroupWithOptions(request, runtime);
}

model AttachPolicyToRoleRequest {
  policyName?: string(name='PolicyName'),
  policyType?: string(name='PolicyType'),
  roleName?: string(name='RoleName'),
}

model AttachPolicyToRoleResponseBody = {
  requestId?: string(name='RequestId'),
}

model AttachPolicyToRoleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AttachPolicyToRoleResponseBody(name='body'),
}

async function attachPolicyToRoleWithOptions(request: AttachPolicyToRoleRequest, runtime: Util.RuntimeOptions): AttachPolicyToRoleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.policyName)) {
    query['PolicyName'] = request.policyName;
  }
  if (!Util.isUnset(request.policyType)) {
    query['PolicyType'] = request.policyType;
  }
  if (!Util.isUnset(request.roleName)) {
    query['RoleName'] = request.roleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AttachPolicyToRole',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function attachPolicyToRole(request: AttachPolicyToRoleRequest): AttachPolicyToRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachPolicyToRoleWithOptions(request, runtime);
}

model AttachPolicyToUserRequest {
  policyName?: string(name='PolicyName'),
  policyType?: string(name='PolicyType'),
  userName?: string(name='UserName'),
}

model AttachPolicyToUserResponseBody = {
  requestId?: string(name='RequestId'),
}

model AttachPolicyToUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AttachPolicyToUserResponseBody(name='body'),
}

async function attachPolicyToUserWithOptions(request: AttachPolicyToUserRequest, runtime: Util.RuntimeOptions): AttachPolicyToUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.policyName)) {
    query['PolicyName'] = request.policyName;
  }
  if (!Util.isUnset(request.policyType)) {
    query['PolicyType'] = request.policyType;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AttachPolicyToUser',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function attachPolicyToUser(request: AttachPolicyToUserRequest): AttachPolicyToUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachPolicyToUserWithOptions(request, runtime);
}

model BindMFADeviceRequest {
  authenticationCode1?: string(name='AuthenticationCode1'),
  authenticationCode2?: string(name='AuthenticationCode2'),
  serialNumber?: string(name='SerialNumber'),
  userName?: string(name='UserName'),
}

model BindMFADeviceResponseBody = {
  requestId?: string(name='RequestId'),
}

model BindMFADeviceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BindMFADeviceResponseBody(name='body'),
}

async function bindMFADeviceWithOptions(request: BindMFADeviceRequest, runtime: Util.RuntimeOptions): BindMFADeviceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.authenticationCode1)) {
    query['AuthenticationCode1'] = request.authenticationCode1;
  }
  if (!Util.isUnset(request.authenticationCode2)) {
    query['AuthenticationCode2'] = request.authenticationCode2;
  }
  if (!Util.isUnset(request.serialNumber)) {
    query['SerialNumber'] = request.serialNumber;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BindMFADevice',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function bindMFADevice(request: BindMFADeviceRequest): BindMFADeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return bindMFADeviceWithOptions(request, runtime);
}

model ChangePasswordRequest {
  newPassword?: string(name='NewPassword'),
  oldPassword?: string(name='OldPassword'),
}

model ChangePasswordResponseBody = {
  requestId?: string(name='RequestId'),
}

model ChangePasswordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ChangePasswordResponseBody(name='body'),
}

async function changePasswordWithOptions(request: ChangePasswordRequest, runtime: Util.RuntimeOptions): ChangePasswordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.newPassword)) {
    query['NewPassword'] = request.newPassword;
  }
  if (!Util.isUnset(request.oldPassword)) {
    query['OldPassword'] = request.oldPassword;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ChangePassword',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function changePassword(request: ChangePasswordRequest): ChangePasswordResponse {
  var runtime = new Util.RuntimeOptions{};
  return changePasswordWithOptions(request, runtime);
}

model ClearAccountAliasResponseBody = {
  requestId?: string(name='RequestId'),
}

model ClearAccountAliasResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ClearAccountAliasResponseBody(name='body'),
}

async function clearAccountAliasWithOptions(runtime: Util.RuntimeOptions): ClearAccountAliasResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'ClearAccountAlias',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function clearAccountAlias(): ClearAccountAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  return clearAccountAliasWithOptions(runtime);
}

model CreateAccessKeyRequest {
  userName?: string(name='UserName'),
}

model CreateAccessKeyResponseBody = {
  accessKey?: {
    accessKeyId?: string(name='AccessKeyId'),
    accessKeySecret?: string(name='AccessKeySecret'),
    createDate?: string(name='CreateDate'),
    status?: string(name='Status'),
  }(name='AccessKey'),
  requestId?: string(name='RequestId'),
}

model CreateAccessKeyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAccessKeyResponseBody(name='body'),
}

async function createAccessKeyWithOptions(request: CreateAccessKeyRequest, runtime: Util.RuntimeOptions): CreateAccessKeyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateAccessKey',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createAccessKey(request: CreateAccessKeyRequest): CreateAccessKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAccessKeyWithOptions(request, runtime);
}

model CreateGroupRequest {
  comments?: string(name='Comments'),
  groupName?: string(name='GroupName'),
}

model CreateGroupResponseBody = {
  group?: {
    comments?: string(name='Comments'),
    createDate?: string(name='CreateDate'),
    groupId?: string(name='GroupId'),
    groupName?: string(name='GroupName'),
  }(name='Group'),
  requestId?: string(name='RequestId'),
}

model CreateGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateGroupResponseBody(name='body'),
}

async function createGroupWithOptions(request: CreateGroupRequest, runtime: Util.RuntimeOptions): CreateGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.comments)) {
    query['Comments'] = request.comments;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateGroup',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createGroup(request: CreateGroupRequest): CreateGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createGroupWithOptions(request, runtime);
}

model CreateLoginProfileRequest {
  MFABindRequired?: boolean(name='MFABindRequired'),
  password?: string(name='Password'),
  passwordResetRequired?: boolean(name='PasswordResetRequired'),
  userName?: string(name='UserName'),
}

model CreateLoginProfileResponseBody = {
  loginProfile?: {
    createDate?: string(name='CreateDate'),
    MFABindRequired?: boolean(name='MFABindRequired'),
    passwordResetRequired?: boolean(name='PasswordResetRequired'),
    userName?: string(name='UserName'),
  }(name='LoginProfile'),
  requestId?: string(name='RequestId'),
}

model CreateLoginProfileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateLoginProfileResponseBody(name='body'),
}

async function createLoginProfileWithOptions(request: CreateLoginProfileRequest, runtime: Util.RuntimeOptions): CreateLoginProfileResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.MFABindRequired)) {
    query['MFABindRequired'] = request.MFABindRequired;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.passwordResetRequired)) {
    query['PasswordResetRequired'] = request.passwordResetRequired;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateLoginProfile',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createLoginProfile(request: CreateLoginProfileRequest): CreateLoginProfileResponse {
  var runtime = new Util.RuntimeOptions{};
  return createLoginProfileWithOptions(request, runtime);
}

model CreatePolicyRequest {
  description?: string(name='Description'),
  policyDocument?: string(name='PolicyDocument'),
  policyName?: string(name='PolicyName'),
}

model CreatePolicyResponseBody = {
  policy?: {
    createDate?: string(name='CreateDate'),
    defaultVersion?: string(name='DefaultVersion'),
    description?: string(name='Description'),
    policyName?: string(name='PolicyName'),
    policyType?: string(name='PolicyType'),
  }(name='Policy'),
  requestId?: string(name='RequestId'),
}

model CreatePolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreatePolicyResponseBody(name='body'),
}

async function createPolicyWithOptions(request: CreatePolicyRequest, runtime: Util.RuntimeOptions): CreatePolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.policyDocument)) {
    query['PolicyDocument'] = request.policyDocument;
  }
  if (!Util.isUnset(request.policyName)) {
    query['PolicyName'] = request.policyName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreatePolicy',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createPolicy(request: CreatePolicyRequest): CreatePolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return createPolicyWithOptions(request, runtime);
}

model CreatePolicyVersionRequest {
  policyDocument?: string(name='PolicyDocument'),
  policyName?: string(name='PolicyName'),
  rotateStrategy?: string(name='RotateStrategy'),
  setAsDefault?: boolean(name='SetAsDefault'),
}

model CreatePolicyVersionResponseBody = {
  policyVersion?: {
    createDate?: string(name='CreateDate'),
    isDefaultVersion?: boolean(name='IsDefaultVersion'),
    policyDocument?: string(name='PolicyDocument'),
    versionId?: string(name='VersionId'),
  }(name='PolicyVersion'),
  requestId?: string(name='RequestId'),
}

model CreatePolicyVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreatePolicyVersionResponseBody(name='body'),
}

async function createPolicyVersionWithOptions(request: CreatePolicyVersionRequest, runtime: Util.RuntimeOptions): CreatePolicyVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.policyDocument)) {
    query['PolicyDocument'] = request.policyDocument;
  }
  if (!Util.isUnset(request.policyName)) {
    query['PolicyName'] = request.policyName;
  }
  if (!Util.isUnset(request.rotateStrategy)) {
    query['RotateStrategy'] = request.rotateStrategy;
  }
  if (!Util.isUnset(request.setAsDefault)) {
    query['SetAsDefault'] = request.setAsDefault;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreatePolicyVersion',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createPolicyVersion(request: CreatePolicyVersionRequest): CreatePolicyVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createPolicyVersionWithOptions(request, runtime);
}

model CreateRoleRequest {
  assumeRolePolicyDocument?: string(name='AssumeRolePolicyDocument'),
  description?: string(name='Description'),
  maxSessionDuration?: long(name='MaxSessionDuration'),
  roleName?: string(name='RoleName'),
}

model CreateRoleResponseBody = {
  requestId?: string(name='RequestId'),
  role?: {
    arn?: string(name='Arn'),
    assumeRolePolicyDocument?: string(name='AssumeRolePolicyDocument'),
    createDate?: string(name='CreateDate'),
    description?: string(name='Description'),
    maxSessionDuration?: long(name='MaxSessionDuration'),
    roleId?: string(name='RoleId'),
    roleName?: string(name='RoleName'),
  }(name='Role'),
}

model CreateRoleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRoleResponseBody(name='body'),
}

async function createRoleWithOptions(request: CreateRoleRequest, runtime: Util.RuntimeOptions): CreateRoleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.assumeRolePolicyDocument)) {
    query['AssumeRolePolicyDocument'] = request.assumeRolePolicyDocument;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.maxSessionDuration)) {
    query['MaxSessionDuration'] = request.maxSessionDuration;
  }
  if (!Util.isUnset(request.roleName)) {
    query['RoleName'] = request.roleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateRole',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createRole(request: CreateRoleRequest): CreateRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRoleWithOptions(request, runtime);
}

model CreateUserRequest {
  comments?: string(name='Comments'),
  displayName?: string(name='DisplayName'),
  email?: string(name='Email'),
  mobilePhone?: string(name='MobilePhone'),
  userName?: string(name='UserName'),
}

model CreateUserResponseBody = {
  requestId?: string(name='RequestId'),
  user?: {
    comments?: string(name='Comments'),
    createDate?: string(name='CreateDate'),
    displayName?: string(name='DisplayName'),
    email?: string(name='Email'),
    mobilePhone?: string(name='MobilePhone'),
    userId?: string(name='UserId'),
    userName?: string(name='UserName'),
  }(name='User'),
}

model CreateUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateUserResponseBody(name='body'),
}

async function createUserWithOptions(request: CreateUserRequest, runtime: Util.RuntimeOptions): CreateUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.comments)) {
    query['Comments'] = request.comments;
  }
  if (!Util.isUnset(request.displayName)) {
    query['DisplayName'] = request.displayName;
  }
  if (!Util.isUnset(request.email)) {
    query['Email'] = request.email;
  }
  if (!Util.isUnset(request.mobilePhone)) {
    query['MobilePhone'] = request.mobilePhone;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateUser',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createUser(request: CreateUserRequest): CreateUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return createUserWithOptions(request, runtime);
}

model CreateVirtualMFADeviceRequest {
  virtualMFADeviceName?: string(name='VirtualMFADeviceName'),
}

model CreateVirtualMFADeviceResponseBody = {
  requestId?: string(name='RequestId'),
  virtualMFADevice?: {
    base32StringSeed?: string(name='Base32StringSeed'),
    QRCodePNG?: string(name='QRCodePNG'),
    serialNumber?: string(name='SerialNumber'),
  }(name='VirtualMFADevice'),
}

model CreateVirtualMFADeviceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateVirtualMFADeviceResponseBody(name='body'),
}

async function createVirtualMFADeviceWithOptions(request: CreateVirtualMFADeviceRequest, runtime: Util.RuntimeOptions): CreateVirtualMFADeviceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.virtualMFADeviceName)) {
    query['VirtualMFADeviceName'] = request.virtualMFADeviceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateVirtualMFADevice',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createVirtualMFADevice(request: CreateVirtualMFADeviceRequest): CreateVirtualMFADeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVirtualMFADeviceWithOptions(request, runtime);
}

model DeleteAccessKeyRequest {
  userAccessKeyId?: string(name='UserAccessKeyId'),
  userName?: string(name='UserName'),
}

model DeleteAccessKeyResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteAccessKeyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAccessKeyResponseBody(name='body'),
}

async function deleteAccessKeyWithOptions(request: DeleteAccessKeyRequest, runtime: Util.RuntimeOptions): DeleteAccessKeyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.userAccessKeyId)) {
    query['UserAccessKeyId'] = request.userAccessKeyId;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAccessKey',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteAccessKey(request: DeleteAccessKeyRequest): DeleteAccessKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAccessKeyWithOptions(request, runtime);
}

model DeleteGroupRequest {
  groupName?: string(name='GroupName'),
}

model DeleteGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteGroupResponseBody(name='body'),
}

async function deleteGroupWithOptions(request: DeleteGroupRequest, runtime: Util.RuntimeOptions): DeleteGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGroup',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteGroup(request: DeleteGroupRequest): DeleteGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGroupWithOptions(request, runtime);
}

model DeleteLoginProfileRequest {
  userName?: string(name='UserName'),
}

model DeleteLoginProfileResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteLoginProfileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteLoginProfileResponseBody(name='body'),
}

async function deleteLoginProfileWithOptions(request: DeleteLoginProfileRequest, runtime: Util.RuntimeOptions): DeleteLoginProfileResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteLoginProfile',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteLoginProfile(request: DeleteLoginProfileRequest): DeleteLoginProfileResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteLoginProfileWithOptions(request, runtime);
}

model DeletePolicyRequest {
  policyName?: string(name='PolicyName'),
}

model DeletePolicyResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeletePolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeletePolicyResponseBody(name='body'),
}

async function deletePolicyWithOptions(request: DeletePolicyRequest, runtime: Util.RuntimeOptions): DeletePolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.policyName)) {
    query['PolicyName'] = request.policyName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeletePolicy',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deletePolicy(request: DeletePolicyRequest): DeletePolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return deletePolicyWithOptions(request, runtime);
}

model DeletePolicyVersionRequest {
  policyName?: string(name='PolicyName'),
  versionId?: string(name='VersionId'),
}

model DeletePolicyVersionResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeletePolicyVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeletePolicyVersionResponseBody(name='body'),
}

async function deletePolicyVersionWithOptions(request: DeletePolicyVersionRequest, runtime: Util.RuntimeOptions): DeletePolicyVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.policyName)) {
    query['PolicyName'] = request.policyName;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeletePolicyVersion',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deletePolicyVersion(request: DeletePolicyVersionRequest): DeletePolicyVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return deletePolicyVersionWithOptions(request, runtime);
}

model DeleteRoleRequest {
  roleName?: string(name='RoleName'),
}

model DeleteRoleResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteRoleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteRoleResponseBody(name='body'),
}

async function deleteRoleWithOptions(request: DeleteRoleRequest, runtime: Util.RuntimeOptions): DeleteRoleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.roleName)) {
    query['RoleName'] = request.roleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRole',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteRole(request: DeleteRoleRequest): DeleteRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRoleWithOptions(request, runtime);
}

model DeleteUserRequest {
  userName?: string(name='UserName'),
}

model DeleteUserResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteUserResponseBody(name='body'),
}

async function deleteUserWithOptions(request: DeleteUserRequest, runtime: Util.RuntimeOptions): DeleteUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteUser',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteUser(request: DeleteUserRequest): DeleteUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteUserWithOptions(request, runtime);
}

model DeleteVirtualMFADeviceRequest {
  serialNumber?: string(name='SerialNumber'),
}

model DeleteVirtualMFADeviceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVirtualMFADeviceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteVirtualMFADeviceResponseBody(name='body'),
}

async function deleteVirtualMFADeviceWithOptions(request: DeleteVirtualMFADeviceRequest, runtime: Util.RuntimeOptions): DeleteVirtualMFADeviceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.serialNumber)) {
    query['SerialNumber'] = request.serialNumber;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteVirtualMFADevice',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteVirtualMFADevice(request: DeleteVirtualMFADeviceRequest): DeleteVirtualMFADeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVirtualMFADeviceWithOptions(request, runtime);
}

model DetachPolicyFromGroupRequest {
  groupName?: string(name='GroupName'),
  policyName?: string(name='PolicyName'),
  policyType?: string(name='PolicyType'),
}

model DetachPolicyFromGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model DetachPolicyFromGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetachPolicyFromGroupResponseBody(name='body'),
}

async function detachPolicyFromGroupWithOptions(request: DetachPolicyFromGroupRequest, runtime: Util.RuntimeOptions): DetachPolicyFromGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.policyName)) {
    query['PolicyName'] = request.policyName;
  }
  if (!Util.isUnset(request.policyType)) {
    query['PolicyType'] = request.policyType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DetachPolicyFromGroup',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detachPolicyFromGroup(request: DetachPolicyFromGroupRequest): DetachPolicyFromGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachPolicyFromGroupWithOptions(request, runtime);
}

model DetachPolicyFromRoleRequest {
  policyName?: string(name='PolicyName'),
  policyType?: string(name='PolicyType'),
  roleName?: string(name='RoleName'),
}

model DetachPolicyFromRoleResponseBody = {
  requestId?: string(name='RequestId'),
}

model DetachPolicyFromRoleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetachPolicyFromRoleResponseBody(name='body'),
}

async function detachPolicyFromRoleWithOptions(request: DetachPolicyFromRoleRequest, runtime: Util.RuntimeOptions): DetachPolicyFromRoleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.policyName)) {
    query['PolicyName'] = request.policyName;
  }
  if (!Util.isUnset(request.policyType)) {
    query['PolicyType'] = request.policyType;
  }
  if (!Util.isUnset(request.roleName)) {
    query['RoleName'] = request.roleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DetachPolicyFromRole',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detachPolicyFromRole(request: DetachPolicyFromRoleRequest): DetachPolicyFromRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachPolicyFromRoleWithOptions(request, runtime);
}

model DetachPolicyFromUserRequest {
  policyName?: string(name='PolicyName'),
  policyType?: string(name='PolicyType'),
  userName?: string(name='UserName'),
}

model DetachPolicyFromUserResponseBody = {
  requestId?: string(name='RequestId'),
}

model DetachPolicyFromUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetachPolicyFromUserResponseBody(name='body'),
}

async function detachPolicyFromUserWithOptions(request: DetachPolicyFromUserRequest, runtime: Util.RuntimeOptions): DetachPolicyFromUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.policyName)) {
    query['PolicyName'] = request.policyName;
  }
  if (!Util.isUnset(request.policyType)) {
    query['PolicyType'] = request.policyType;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DetachPolicyFromUser',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detachPolicyFromUser(request: DetachPolicyFromUserRequest): DetachPolicyFromUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachPolicyFromUserWithOptions(request, runtime);
}

model GetAccessKeyLastUsedRequest {
  userAccessKeyId?: string(name='UserAccessKeyId'),
  userName?: string(name='UserName'),
}

model GetAccessKeyLastUsedResponseBody = {
  accessKeyLastUsed?: {
    lastUsedDate?: string(name='LastUsedDate'),
  }(name='AccessKeyLastUsed'),
  requestId?: string(name='RequestId'),
}

model GetAccessKeyLastUsedResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAccessKeyLastUsedResponseBody(name='body'),
}

async function getAccessKeyLastUsedWithOptions(request: GetAccessKeyLastUsedRequest, runtime: Util.RuntimeOptions): GetAccessKeyLastUsedResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.userAccessKeyId)) {
    query['UserAccessKeyId'] = request.userAccessKeyId;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAccessKeyLastUsed',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAccessKeyLastUsed(request: GetAccessKeyLastUsedRequest): GetAccessKeyLastUsedResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAccessKeyLastUsedWithOptions(request, runtime);
}

model GetAccountAliasResponseBody = {
  accountAlias?: string(name='AccountAlias'),
  requestId?: string(name='RequestId'),
}

model GetAccountAliasResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAccountAliasResponseBody(name='body'),
}

async function getAccountAliasWithOptions(runtime: Util.RuntimeOptions): GetAccountAliasResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetAccountAlias',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAccountAlias(): GetAccountAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAccountAliasWithOptions(runtime);
}

model GetGroupRequest {
  groupName?: string(name='GroupName'),
}

model GetGroupResponseBody = {
  group?: {
    comments?: string(name='Comments'),
    createDate?: string(name='CreateDate'),
    groupId?: string(name='GroupId'),
    groupName?: string(name='GroupName'),
    updateDate?: string(name='UpdateDate'),
  }(name='Group'),
  requestId?: string(name='RequestId'),
}

model GetGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetGroupResponseBody(name='body'),
}

async function getGroupWithOptions(request: GetGroupRequest, runtime: Util.RuntimeOptions): GetGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetGroup',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getGroup(request: GetGroupRequest): GetGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return getGroupWithOptions(request, runtime);
}

model GetLoginProfileRequest {
  userName?: string(name='UserName'),
}

model GetLoginProfileResponseBody = {
  loginProfile?: {
    createDate?: string(name='CreateDate'),
    MFABindRequired?: boolean(name='MFABindRequired'),
    passwordResetRequired?: boolean(name='PasswordResetRequired'),
    userName?: string(name='UserName'),
  }(name='LoginProfile'),
  requestId?: string(name='RequestId'),
}

model GetLoginProfileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetLoginProfileResponseBody(name='body'),
}

async function getLoginProfileWithOptions(request: GetLoginProfileRequest, runtime: Util.RuntimeOptions): GetLoginProfileResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetLoginProfile',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getLoginProfile(request: GetLoginProfileRequest): GetLoginProfileResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLoginProfileWithOptions(request, runtime);
}

model GetPasswordPolicyResponseBody = {
  passwordPolicy?: {
    hardExpiry?: boolean(name='HardExpiry'),
    maxLoginAttemps?: int32(name='MaxLoginAttemps'),
    maxPasswordAge?: int32(name='MaxPasswordAge'),
    minimumPasswordLength?: int32(name='MinimumPasswordLength'),
    passwordReusePrevention?: int32(name='PasswordReusePrevention'),
    requireLowercaseCharacters?: boolean(name='RequireLowercaseCharacters'),
    requireNumbers?: boolean(name='RequireNumbers'),
    requireSymbols?: boolean(name='RequireSymbols'),
    requireUppercaseCharacters?: boolean(name='RequireUppercaseCharacters'),
  }(name='PasswordPolicy'),
  requestId?: string(name='RequestId'),
}

model GetPasswordPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPasswordPolicyResponseBody(name='body'),
}

async function getPasswordPolicyWithOptions(runtime: Util.RuntimeOptions): GetPasswordPolicyResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetPasswordPolicy',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPasswordPolicy(): GetPasswordPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPasswordPolicyWithOptions(runtime);
}

model GetPolicyRequest {
  policyName?: string(name='PolicyName'),
  policyType?: string(name='PolicyType'),
}

model GetPolicyResponseBody = {
  defaultPolicyVersion?: {
    createDate?: string(name='CreateDate'),
    isDefaultVersion?: boolean(name='IsDefaultVersion'),
    policyDocument?: string(name='PolicyDocument'),
    versionId?: string(name='VersionId'),
  }(name='DefaultPolicyVersion'),
  policy?: {
    attachmentCount?: int32(name='AttachmentCount'),
    createDate?: string(name='CreateDate'),
    defaultVersion?: string(name='DefaultVersion'),
    description?: string(name='Description'),
    policyDocument?: string(name='PolicyDocument'),
    policyName?: string(name='PolicyName'),
    policyType?: string(name='PolicyType'),
    updateDate?: string(name='UpdateDate'),
  }(name='Policy'),
  requestId?: string(name='RequestId'),
}

model GetPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPolicyResponseBody(name='body'),
}

async function getPolicyWithOptions(request: GetPolicyRequest, runtime: Util.RuntimeOptions): GetPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.policyName)) {
    query['PolicyName'] = request.policyName;
  }
  if (!Util.isUnset(request.policyType)) {
    query['PolicyType'] = request.policyType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetPolicy',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPolicy(request: GetPolicyRequest): GetPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPolicyWithOptions(request, runtime);
}

model GetPolicyVersionRequest {
  policyName?: string(name='PolicyName'),
  policyType?: string(name='PolicyType'),
  versionId?: string(name='VersionId'),
}

model GetPolicyVersionResponseBody = {
  policyVersion?: {
    createDate?: string(name='CreateDate'),
    isDefaultVersion?: boolean(name='IsDefaultVersion'),
    policyDocument?: string(name='PolicyDocument'),
    versionId?: string(name='VersionId'),
  }(name='PolicyVersion'),
  requestId?: string(name='RequestId'),
}

model GetPolicyVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPolicyVersionResponseBody(name='body'),
}

async function getPolicyVersionWithOptions(request: GetPolicyVersionRequest, runtime: Util.RuntimeOptions): GetPolicyVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.policyName)) {
    query['PolicyName'] = request.policyName;
  }
  if (!Util.isUnset(request.policyType)) {
    query['PolicyType'] = request.policyType;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetPolicyVersion',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPolicyVersion(request: GetPolicyVersionRequest): GetPolicyVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPolicyVersionWithOptions(request, runtime);
}

model GetRoleRequest {
  roleName?: string(name='RoleName'),
}

model GetRoleResponseBody = {
  requestId?: string(name='RequestId'),
  role?: {
    arn?: string(name='Arn'),
    assumeRolePolicyDocument?: string(name='AssumeRolePolicyDocument'),
    createDate?: string(name='CreateDate'),
    description?: string(name='Description'),
    maxSessionDuration?: long(name='MaxSessionDuration'),
    roleId?: string(name='RoleId'),
    roleName?: string(name='RoleName'),
    updateDate?: string(name='UpdateDate'),
  }(name='Role'),
}

model GetRoleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRoleResponseBody(name='body'),
}

async function getRoleWithOptions(request: GetRoleRequest, runtime: Util.RuntimeOptions): GetRoleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.roleName)) {
    query['RoleName'] = request.roleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRole',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRole(request: GetRoleRequest): GetRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRoleWithOptions(request, runtime);
}

model GetSecurityPreferenceResponseBody = {
  requestId?: string(name='RequestId'),
  securityPreference?: {
    accessKeyPreference?: {
      allowUserToManageAccessKeys?: boolean(name='AllowUserToManageAccessKeys'),
    }(name='AccessKeyPreference'),
    loginProfilePreference?: {
      allowUserToChangePassword?: boolean(name='AllowUserToChangePassword'),
      enableSaveMFATicket?: boolean(name='EnableSaveMFATicket'),
      loginNetworkMasks?: string(name='LoginNetworkMasks'),
      loginSessionDuration?: int32(name='LoginSessionDuration'),
    }(name='LoginProfilePreference'),
    MFAPreference?: {
      allowUserToManageMFADevices?: boolean(name='AllowUserToManageMFADevices'),
    }(name='MFAPreference'),
    publicKeyPreference?: {
      allowUserToManagePublicKeys?: boolean(name='AllowUserToManagePublicKeys'),
    }(name='PublicKeyPreference'),
  }(name='SecurityPreference'),
}

model GetSecurityPreferenceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSecurityPreferenceResponseBody(name='body'),
}

async function getSecurityPreferenceWithOptions(runtime: Util.RuntimeOptions): GetSecurityPreferenceResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetSecurityPreference',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSecurityPreference(): GetSecurityPreferenceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSecurityPreferenceWithOptions(runtime);
}

model GetUserRequest {
  userName?: string(name='UserName'),
}

model GetUserResponseBody = {
  requestId?: string(name='RequestId'),
  user?: {
    comments?: string(name='Comments'),
    createDate?: string(name='CreateDate'),
    displayName?: string(name='DisplayName'),
    email?: string(name='Email'),
    lastLoginDate?: string(name='LastLoginDate'),
    mobilePhone?: string(name='MobilePhone'),
    updateDate?: string(name='UpdateDate'),
    userId?: string(name='UserId'),
    userName?: string(name='UserName'),
  }(name='User'),
}

model GetUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetUserResponseBody(name='body'),
}

async function getUserWithOptions(request: GetUserRequest, runtime: Util.RuntimeOptions): GetUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetUser',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getUser(request: GetUserRequest): GetUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return getUserWithOptions(request, runtime);
}

model GetUserMFAInfoRequest {
  userName?: string(name='UserName'),
}

model GetUserMFAInfoResponseBody = {
  MFADevice?: {
    serialNumber?: string(name='SerialNumber'),
    type?: string(name='Type'),
  }(name='MFADevice'),
  requestId?: string(name='RequestId'),
}

model GetUserMFAInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetUserMFAInfoResponseBody(name='body'),
}

async function getUserMFAInfoWithOptions(request: GetUserMFAInfoRequest, runtime: Util.RuntimeOptions): GetUserMFAInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetUserMFAInfo',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getUserMFAInfo(request: GetUserMFAInfoRequest): GetUserMFAInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getUserMFAInfoWithOptions(request, runtime);
}

model ListAccessKeysRequest {
  userName?: string(name='UserName'),
}

model ListAccessKeysResponseBody = {
  accessKeys?: {
    accessKey?: [ 
    {
      accessKeyId?: string(name='AccessKeyId'),
      createDate?: string(name='CreateDate'),
      status?: string(name='Status'),
    }
  ](name='AccessKey')
  }(name='AccessKeys'),
  requestId?: string(name='RequestId'),
}

model ListAccessKeysResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAccessKeysResponseBody(name='body'),
}

async function listAccessKeysWithOptions(request: ListAccessKeysRequest, runtime: Util.RuntimeOptions): ListAccessKeysResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAccessKeys',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAccessKeys(request: ListAccessKeysRequest): ListAccessKeysResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAccessKeysWithOptions(request, runtime);
}

model ListEntitiesForPolicyRequest {
  policyName?: string(name='PolicyName'),
  policyType?: string(name='PolicyType'),
}

model ListEntitiesForPolicyResponseBody = {
  groups?: {
    group?: [ 
    {
      attachDate?: string(name='AttachDate'),
      comments?: string(name='Comments'),
      groupName?: string(name='GroupName'),
    }
  ](name='Group')
  }(name='Groups'),
  requestId?: string(name='RequestId'),
  roles?: {
    role?: [ 
    {
      arn?: string(name='Arn'),
      attachDate?: string(name='AttachDate'),
      description?: string(name='Description'),
      roleId?: string(name='RoleId'),
      roleName?: string(name='RoleName'),
    }
  ](name='Role')
  }(name='Roles'),
  users?: {
    user?: [ 
    {
      attachDate?: string(name='AttachDate'),
      displayName?: string(name='DisplayName'),
      userId?: string(name='UserId'),
      userName?: string(name='UserName'),
    }
  ](name='User')
  }(name='Users'),
}

model ListEntitiesForPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListEntitiesForPolicyResponseBody(name='body'),
}

async function listEntitiesForPolicyWithOptions(request: ListEntitiesForPolicyRequest, runtime: Util.RuntimeOptions): ListEntitiesForPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.policyName)) {
    query['PolicyName'] = request.policyName;
  }
  if (!Util.isUnset(request.policyType)) {
    query['PolicyType'] = request.policyType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListEntitiesForPolicy',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listEntitiesForPolicy(request: ListEntitiesForPolicyRequest): ListEntitiesForPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEntitiesForPolicyWithOptions(request, runtime);
}

model ListGroupsRequest {
  marker?: string(name='Marker'),
  maxItems?: int32(name='MaxItems'),
}

model ListGroupsResponseBody = {
  groups?: {
    group?: [ 
    {
      comments?: string(name='Comments'),
      createDate?: string(name='CreateDate'),
      groupId?: string(name='GroupId'),
      groupName?: string(name='GroupName'),
      updateDate?: string(name='UpdateDate'),
    }
  ](name='Group')
  }(name='Groups'),
  isTruncated?: boolean(name='IsTruncated'),
  marker?: string(name='Marker'),
  requestId?: string(name='RequestId'),
}

model ListGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListGroupsResponseBody(name='body'),
}

async function listGroupsWithOptions(request: ListGroupsRequest, runtime: Util.RuntimeOptions): ListGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.marker)) {
    query['Marker'] = request.marker;
  }
  if (!Util.isUnset(request.maxItems)) {
    query['MaxItems'] = request.maxItems;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListGroups',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listGroups(request: ListGroupsRequest): ListGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listGroupsWithOptions(request, runtime);
}

model ListGroupsForUserRequest {
  userName?: string(name='UserName'),
}

model ListGroupsForUserResponseBody = {
  groups?: {
    group?: [ 
    {
      comments?: string(name='Comments'),
      groupId?: string(name='GroupId'),
      groupName?: string(name='GroupName'),
      joinDate?: string(name='JoinDate'),
    }
  ](name='Group')
  }(name='Groups'),
  requestId?: string(name='RequestId'),
}

model ListGroupsForUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListGroupsForUserResponseBody(name='body'),
}

async function listGroupsForUserWithOptions(request: ListGroupsForUserRequest, runtime: Util.RuntimeOptions): ListGroupsForUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListGroupsForUser',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listGroupsForUser(request: ListGroupsForUserRequest): ListGroupsForUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return listGroupsForUserWithOptions(request, runtime);
}

model ListPoliciesRequest {
  marker?: string(name='Marker'),
  maxItems?: int32(name='MaxItems'),
  policyType?: string(name='PolicyType'),
}

model ListPoliciesResponseBody = {
  isTruncated?: boolean(name='IsTruncated'),
  marker?: string(name='Marker'),
  policies?: {
    policy?: [ 
    {
      attachmentCount?: int32(name='AttachmentCount'),
      createDate?: string(name='CreateDate'),
      defaultVersion?: string(name='DefaultVersion'),
      description?: string(name='Description'),
      policyName?: string(name='PolicyName'),
      policyType?: string(name='PolicyType'),
      updateDate?: string(name='UpdateDate'),
    }
  ](name='Policy')
  }(name='Policies'),
  requestId?: string(name='RequestId'),
}

model ListPoliciesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPoliciesResponseBody(name='body'),
}

async function listPoliciesWithOptions(request: ListPoliciesRequest, runtime: Util.RuntimeOptions): ListPoliciesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.marker)) {
    query['Marker'] = request.marker;
  }
  if (!Util.isUnset(request.maxItems)) {
    query['MaxItems'] = request.maxItems;
  }
  if (!Util.isUnset(request.policyType)) {
    query['PolicyType'] = request.policyType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPolicies',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPolicies(request: ListPoliciesRequest): ListPoliciesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPoliciesWithOptions(request, runtime);
}

model ListPoliciesForGroupRequest {
  groupName?: string(name='GroupName'),
}

model ListPoliciesForGroupResponseBody = {
  policies?: {
    policy?: [ 
    {
      attachDate?: string(name='AttachDate'),
      defaultVersion?: string(name='DefaultVersion'),
      description?: string(name='Description'),
      policyName?: string(name='PolicyName'),
      policyType?: string(name='PolicyType'),
    }
  ](name='Policy')
  }(name='Policies'),
  requestId?: string(name='RequestId'),
}

model ListPoliciesForGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPoliciesForGroupResponseBody(name='body'),
}

async function listPoliciesForGroupWithOptions(request: ListPoliciesForGroupRequest, runtime: Util.RuntimeOptions): ListPoliciesForGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPoliciesForGroup',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPoliciesForGroup(request: ListPoliciesForGroupRequest): ListPoliciesForGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPoliciesForGroupWithOptions(request, runtime);
}

model ListPoliciesForRoleRequest {
  roleName?: string(name='RoleName'),
}

model ListPoliciesForRoleResponseBody = {
  policies?: {
    policy?: [ 
    {
      attachDate?: string(name='AttachDate'),
      defaultVersion?: string(name='DefaultVersion'),
      description?: string(name='Description'),
      policyName?: string(name='PolicyName'),
      policyType?: string(name='PolicyType'),
    }
  ](name='Policy')
  }(name='Policies'),
  requestId?: string(name='RequestId'),
}

model ListPoliciesForRoleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPoliciesForRoleResponseBody(name='body'),
}

async function listPoliciesForRoleWithOptions(request: ListPoliciesForRoleRequest, runtime: Util.RuntimeOptions): ListPoliciesForRoleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.roleName)) {
    query['RoleName'] = request.roleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPoliciesForRole',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPoliciesForRole(request: ListPoliciesForRoleRequest): ListPoliciesForRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPoliciesForRoleWithOptions(request, runtime);
}

model ListPoliciesForUserRequest {
  userName?: string(name='UserName'),
}

model ListPoliciesForUserResponseBody = {
  policies?: {
    policy?: [ 
    {
      attachDate?: string(name='AttachDate'),
      defaultVersion?: string(name='DefaultVersion'),
      description?: string(name='Description'),
      policyName?: string(name='PolicyName'),
      policyType?: string(name='PolicyType'),
    }
  ](name='Policy')
  }(name='Policies'),
  requestId?: string(name='RequestId'),
}

model ListPoliciesForUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPoliciesForUserResponseBody(name='body'),
}

async function listPoliciesForUserWithOptions(request: ListPoliciesForUserRequest, runtime: Util.RuntimeOptions): ListPoliciesForUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPoliciesForUser',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPoliciesForUser(request: ListPoliciesForUserRequest): ListPoliciesForUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPoliciesForUserWithOptions(request, runtime);
}

model ListPolicyVersionsRequest {
  policyName?: string(name='PolicyName'),
  policyType?: string(name='PolicyType'),
}

model ListPolicyVersionsResponseBody = {
  policyVersions?: {
    policyVersion?: [ 
    {
      createDate?: string(name='CreateDate'),
      isDefaultVersion?: boolean(name='IsDefaultVersion'),
      policyDocument?: string(name='PolicyDocument'),
      versionId?: string(name='VersionId'),
    }
  ](name='PolicyVersion')
  }(name='PolicyVersions'),
  requestId?: string(name='RequestId'),
}

model ListPolicyVersionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPolicyVersionsResponseBody(name='body'),
}

async function listPolicyVersionsWithOptions(request: ListPolicyVersionsRequest, runtime: Util.RuntimeOptions): ListPolicyVersionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.policyName)) {
    query['PolicyName'] = request.policyName;
  }
  if (!Util.isUnset(request.policyType)) {
    query['PolicyType'] = request.policyType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPolicyVersions',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPolicyVersions(request: ListPolicyVersionsRequest): ListPolicyVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPolicyVersionsWithOptions(request, runtime);
}

model ListRolesRequest {
  marker?: string(name='Marker'),
  maxItems?: int32(name='MaxItems'),
}

model ListRolesResponseBody = {
  isTruncated?: boolean(name='IsTruncated'),
  marker?: string(name='Marker'),
  requestId?: string(name='RequestId'),
  roles?: {
    role?: [ 
    {
      arn?: string(name='Arn'),
      createDate?: string(name='CreateDate'),
      description?: string(name='Description'),
      maxSessionDuration?: long(name='MaxSessionDuration'),
      roleId?: string(name='RoleId'),
      roleName?: string(name='RoleName'),
      updateDate?: string(name='UpdateDate'),
    }
  ](name='Role')
  }(name='Roles'),
}

model ListRolesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRolesResponseBody(name='body'),
}

async function listRolesWithOptions(request: ListRolesRequest, runtime: Util.RuntimeOptions): ListRolesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.marker)) {
    query['Marker'] = request.marker;
  }
  if (!Util.isUnset(request.maxItems)) {
    query['MaxItems'] = request.maxItems;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRoles',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listRoles(request: ListRolesRequest): ListRolesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRolesWithOptions(request, runtime);
}

model ListUsersRequest {
  marker?: string(name='Marker'),
  maxItems?: int32(name='MaxItems'),
}

model ListUsersResponseBody = {
  isTruncated?: boolean(name='IsTruncated'),
  marker?: string(name='Marker'),
  requestId?: string(name='RequestId'),
  users?: {
    user?: [ 
    {
      comments?: string(name='Comments'),
      createDate?: string(name='CreateDate'),
      displayName?: string(name='DisplayName'),
      email?: string(name='Email'),
      mobilePhone?: string(name='MobilePhone'),
      updateDate?: string(name='UpdateDate'),
      userId?: string(name='UserId'),
      userName?: string(name='UserName'),
    }
  ](name='User')
  }(name='Users'),
}

model ListUsersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListUsersResponseBody(name='body'),
}

async function listUsersWithOptions(request: ListUsersRequest, runtime: Util.RuntimeOptions): ListUsersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.marker)) {
    query['Marker'] = request.marker;
  }
  if (!Util.isUnset(request.maxItems)) {
    query['MaxItems'] = request.maxItems;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUsers',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listUsers(request: ListUsersRequest): ListUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUsersWithOptions(request, runtime);
}

model ListUsersForGroupRequest {
  groupName?: string(name='GroupName'),
  marker?: string(name='Marker'),
  maxItems?: int32(name='MaxItems'),
}

model ListUsersForGroupResponseBody = {
  isTruncated?: boolean(name='IsTruncated'),
  marker?: string(name='Marker'),
  requestId?: string(name='RequestId'),
  users?: {
    user?: [ 
    {
      displayName?: string(name='DisplayName'),
      joinDate?: string(name='JoinDate'),
      userName?: string(name='UserName'),
    }
  ](name='User')
  }(name='Users'),
}

model ListUsersForGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListUsersForGroupResponseBody(name='body'),
}

async function listUsersForGroupWithOptions(request: ListUsersForGroupRequest, runtime: Util.RuntimeOptions): ListUsersForGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.marker)) {
    query['Marker'] = request.marker;
  }
  if (!Util.isUnset(request.maxItems)) {
    query['MaxItems'] = request.maxItems;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUsersForGroup',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listUsersForGroup(request: ListUsersForGroupRequest): ListUsersForGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUsersForGroupWithOptions(request, runtime);
}

model ListVirtualMFADevicesResponseBody = {
  requestId?: string(name='RequestId'),
  virtualMFADevices?: {
    virtualMFADevice?: [ 
    {
      activateDate?: string(name='ActivateDate'),
      serialNumber?: string(name='SerialNumber'),
      user?: {
        displayName?: string(name='DisplayName'),
        userId?: string(name='UserId'),
        userName?: string(name='UserName'),
      }(name='User'),
    }
  ](name='VirtualMFADevice')
  }(name='VirtualMFADevices'),
}

model ListVirtualMFADevicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListVirtualMFADevicesResponseBody(name='body'),
}

async function listVirtualMFADevicesWithOptions(runtime: Util.RuntimeOptions): ListVirtualMFADevicesResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'ListVirtualMFADevices',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listVirtualMFADevices(): ListVirtualMFADevicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVirtualMFADevicesWithOptions(runtime);
}

model RemoveUserFromGroupRequest {
  groupName?: string(name='GroupName'),
  userName?: string(name='UserName'),
}

model RemoveUserFromGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveUserFromGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveUserFromGroupResponseBody(name='body'),
}

async function removeUserFromGroupWithOptions(request: RemoveUserFromGroupRequest, runtime: Util.RuntimeOptions): RemoveUserFromGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemoveUserFromGroup',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removeUserFromGroup(request: RemoveUserFromGroupRequest): RemoveUserFromGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeUserFromGroupWithOptions(request, runtime);
}

model SetAccountAliasRequest {
  accountAlias?: string(name='AccountAlias'),
}

model SetAccountAliasResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetAccountAliasResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetAccountAliasResponseBody(name='body'),
}

async function setAccountAliasWithOptions(request: SetAccountAliasRequest, runtime: Util.RuntimeOptions): SetAccountAliasResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountAlias)) {
    query['AccountAlias'] = request.accountAlias;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetAccountAlias',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setAccountAlias(request: SetAccountAliasRequest): SetAccountAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  return setAccountAliasWithOptions(request, runtime);
}

model SetDefaultPolicyVersionRequest {
  policyName?: string(name='PolicyName'),
  versionId?: string(name='VersionId'),
}

model SetDefaultPolicyVersionResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetDefaultPolicyVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetDefaultPolicyVersionResponseBody(name='body'),
}

async function setDefaultPolicyVersionWithOptions(request: SetDefaultPolicyVersionRequest, runtime: Util.RuntimeOptions): SetDefaultPolicyVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.policyName)) {
    query['PolicyName'] = request.policyName;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetDefaultPolicyVersion',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setDefaultPolicyVersion(request: SetDefaultPolicyVersionRequest): SetDefaultPolicyVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDefaultPolicyVersionWithOptions(request, runtime);
}

model SetPasswordPolicyRequest {
  hardExpiry?: boolean(name='HardExpiry'),
  maxLoginAttemps?: int32(name='MaxLoginAttemps'),
  maxPasswordAge?: int32(name='MaxPasswordAge'),
  minimumPasswordLength?: int32(name='MinimumPasswordLength'),
  passwordReusePrevention?: int32(name='PasswordReusePrevention'),
  requireLowercaseCharacters?: boolean(name='RequireLowercaseCharacters'),
  requireNumbers?: boolean(name='RequireNumbers'),
  requireSymbols?: boolean(name='RequireSymbols'),
  requireUppercaseCharacters?: boolean(name='RequireUppercaseCharacters'),
}

model SetPasswordPolicyResponseBody = {
  passwordPolicy?: {
    hardExpiry?: boolean(name='HardExpiry'),
    maxLoginAttemps?: int32(name='MaxLoginAttemps'),
    maxPasswordAge?: int32(name='MaxPasswordAge'),
    minimumPasswordLength?: int32(name='MinimumPasswordLength'),
    passwordReusePrevention?: int32(name='PasswordReusePrevention'),
    requireLowercaseCharacters?: boolean(name='RequireLowercaseCharacters'),
    requireNumbers?: boolean(name='RequireNumbers'),
    requireSymbols?: boolean(name='RequireSymbols'),
    requireUppercaseCharacters?: boolean(name='RequireUppercaseCharacters'),
  }(name='PasswordPolicy'),
  requestId?: string(name='RequestId'),
}

model SetPasswordPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetPasswordPolicyResponseBody(name='body'),
}

async function setPasswordPolicyWithOptions(request: SetPasswordPolicyRequest, runtime: Util.RuntimeOptions): SetPasswordPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.hardExpiry)) {
    query['HardExpiry'] = request.hardExpiry;
  }
  if (!Util.isUnset(request.maxLoginAttemps)) {
    query['MaxLoginAttemps'] = request.maxLoginAttemps;
  }
  if (!Util.isUnset(request.maxPasswordAge)) {
    query['MaxPasswordAge'] = request.maxPasswordAge;
  }
  if (!Util.isUnset(request.minimumPasswordLength)) {
    query['MinimumPasswordLength'] = request.minimumPasswordLength;
  }
  if (!Util.isUnset(request.passwordReusePrevention)) {
    query['PasswordReusePrevention'] = request.passwordReusePrevention;
  }
  if (!Util.isUnset(request.requireLowercaseCharacters)) {
    query['RequireLowercaseCharacters'] = request.requireLowercaseCharacters;
  }
  if (!Util.isUnset(request.requireNumbers)) {
    query['RequireNumbers'] = request.requireNumbers;
  }
  if (!Util.isUnset(request.requireSymbols)) {
    query['RequireSymbols'] = request.requireSymbols;
  }
  if (!Util.isUnset(request.requireUppercaseCharacters)) {
    query['RequireUppercaseCharacters'] = request.requireUppercaseCharacters;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetPasswordPolicy',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setPasswordPolicy(request: SetPasswordPolicyRequest): SetPasswordPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return setPasswordPolicyWithOptions(request, runtime);
}

model SetSecurityPreferenceRequest {
  allowUserToChangePassword?: boolean(name='AllowUserToChangePassword'),
  allowUserToManageAccessKeys?: boolean(name='AllowUserToManageAccessKeys'),
  allowUserToManageMFADevices?: boolean(name='AllowUserToManageMFADevices'),
  allowUserToManagePublicKeys?: boolean(name='AllowUserToManagePublicKeys'),
  enableSaveMFATicket?: boolean(name='EnableSaveMFATicket'),
  loginNetworkMasks?: string(name='LoginNetworkMasks'),
  loginSessionDuration?: int32(name='LoginSessionDuration'),
}

model SetSecurityPreferenceResponseBody = {
  requestId?: string(name='RequestId'),
  securityPreference?: {
    accessKeyPreference?: {
      allowUserToManageAccessKeys?: boolean(name='AllowUserToManageAccessKeys'),
    }(name='AccessKeyPreference'),
    loginProfilePreference?: {
      allowUserToChangePassword?: boolean(name='AllowUserToChangePassword'),
      enableSaveMFATicket?: boolean(name='EnableSaveMFATicket'),
      loginNetworkMasks?: string(name='LoginNetworkMasks'),
      loginSessionDuration?: int32(name='LoginSessionDuration'),
    }(name='LoginProfilePreference'),
    MFAPreference?: {
      allowUserToManageMFADevices?: boolean(name='AllowUserToManageMFADevices'),
    }(name='MFAPreference'),
    publicKeyPreference?: {
      allowUserToManagePublicKeys?: boolean(name='AllowUserToManagePublicKeys'),
    }(name='PublicKeyPreference'),
  }(name='SecurityPreference'),
}

model SetSecurityPreferenceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetSecurityPreferenceResponseBody(name='body'),
}

async function setSecurityPreferenceWithOptions(request: SetSecurityPreferenceRequest, runtime: Util.RuntimeOptions): SetSecurityPreferenceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.allowUserToChangePassword)) {
    query['AllowUserToChangePassword'] = request.allowUserToChangePassword;
  }
  if (!Util.isUnset(request.allowUserToManageAccessKeys)) {
    query['AllowUserToManageAccessKeys'] = request.allowUserToManageAccessKeys;
  }
  if (!Util.isUnset(request.allowUserToManageMFADevices)) {
    query['AllowUserToManageMFADevices'] = request.allowUserToManageMFADevices;
  }
  if (!Util.isUnset(request.allowUserToManagePublicKeys)) {
    query['AllowUserToManagePublicKeys'] = request.allowUserToManagePublicKeys;
  }
  if (!Util.isUnset(request.enableSaveMFATicket)) {
    query['EnableSaveMFATicket'] = request.enableSaveMFATicket;
  }
  if (!Util.isUnset(request.loginNetworkMasks)) {
    query['LoginNetworkMasks'] = request.loginNetworkMasks;
  }
  if (!Util.isUnset(request.loginSessionDuration)) {
    query['LoginSessionDuration'] = request.loginSessionDuration;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetSecurityPreference',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setSecurityPreference(request: SetSecurityPreferenceRequest): SetSecurityPreferenceResponse {
  var runtime = new Util.RuntimeOptions{};
  return setSecurityPreferenceWithOptions(request, runtime);
}

model UnbindMFADeviceRequest {
  userName?: string(name='UserName'),
}

model UnbindMFADeviceResponseBody = {
  MFADevice?: {
    serialNumber?: string(name='SerialNumber'),
  }(name='MFADevice'),
  requestId?: string(name='RequestId'),
}

model UnbindMFADeviceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UnbindMFADeviceResponseBody(name='body'),
}

async function unbindMFADeviceWithOptions(request: UnbindMFADeviceRequest, runtime: Util.RuntimeOptions): UnbindMFADeviceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UnbindMFADevice',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function unbindMFADevice(request: UnbindMFADeviceRequest): UnbindMFADeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return unbindMFADeviceWithOptions(request, runtime);
}

model UpdateAccessKeyRequest {
  status?: string(name='Status'),
  userAccessKeyId?: string(name='UserAccessKeyId'),
  userName?: string(name='UserName'),
}

model UpdateAccessKeyResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateAccessKeyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAccessKeyResponseBody(name='body'),
}

async function updateAccessKeyWithOptions(request: UpdateAccessKeyRequest, runtime: Util.RuntimeOptions): UpdateAccessKeyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.userAccessKeyId)) {
    query['UserAccessKeyId'] = request.userAccessKeyId;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAccessKey',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAccessKey(request: UpdateAccessKeyRequest): UpdateAccessKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAccessKeyWithOptions(request, runtime);
}

model UpdateGroupRequest {
  groupName?: string(name='GroupName'),
  newComments?: string(name='NewComments'),
  newGroupName?: string(name='NewGroupName'),
}

model UpdateGroupResponseBody = {
  group?: {
    comments?: string(name='Comments'),
    createDate?: string(name='CreateDate'),
    groupId?: string(name='GroupId'),
    groupName?: string(name='GroupName'),
    updateDate?: string(name='UpdateDate'),
  }(name='Group'),
  requestId?: string(name='RequestId'),
}

model UpdateGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateGroupResponseBody(name='body'),
}

async function updateGroupWithOptions(request: UpdateGroupRequest, runtime: Util.RuntimeOptions): UpdateGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.newComments)) {
    query['NewComments'] = request.newComments;
  }
  if (!Util.isUnset(request.newGroupName)) {
    query['NewGroupName'] = request.newGroupName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateGroup',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateGroup(request: UpdateGroupRequest): UpdateGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateGroupWithOptions(request, runtime);
}

model UpdateLoginProfileRequest {
  MFABindRequired?: boolean(name='MFABindRequired'),
  password?: string(name='Password'),
  passwordResetRequired?: boolean(name='PasswordResetRequired'),
  userName?: string(name='UserName'),
}

model UpdateLoginProfileResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateLoginProfileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateLoginProfileResponseBody(name='body'),
}

async function updateLoginProfileWithOptions(request: UpdateLoginProfileRequest, runtime: Util.RuntimeOptions): UpdateLoginProfileResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.MFABindRequired)) {
    query['MFABindRequired'] = request.MFABindRequired;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.passwordResetRequired)) {
    query['PasswordResetRequired'] = request.passwordResetRequired;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLoginProfile',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateLoginProfile(request: UpdateLoginProfileRequest): UpdateLoginProfileResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateLoginProfileWithOptions(request, runtime);
}

model UpdatePolicyDescriptionRequest {
  newDescription?: string(name='NewDescription'),
  policyName?: string(name='PolicyName'),
}

model UpdatePolicyDescriptionResponseBody = {
  policy?: {
    createDate?: string(name='CreateDate'),
    defaultVersion?: string(name='DefaultVersion'),
    description?: string(name='Description'),
    policyName?: string(name='PolicyName'),
    policyType?: string(name='PolicyType'),
    updateDate?: string(name='UpdateDate'),
  }(name='Policy'),
  requestId?: string(name='RequestId'),
}

model UpdatePolicyDescriptionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdatePolicyDescriptionResponseBody(name='body'),
}

async function updatePolicyDescriptionWithOptions(request: UpdatePolicyDescriptionRequest, runtime: Util.RuntimeOptions): UpdatePolicyDescriptionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.newDescription)) {
    query['NewDescription'] = request.newDescription;
  }
  if (!Util.isUnset(request.policyName)) {
    query['PolicyName'] = request.policyName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdatePolicyDescription',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updatePolicyDescription(request: UpdatePolicyDescriptionRequest): UpdatePolicyDescriptionResponse {
  var runtime = new Util.RuntimeOptions{};
  return updatePolicyDescriptionWithOptions(request, runtime);
}

model UpdateRoleRequest {
  newAssumeRolePolicyDocument?: string(name='NewAssumeRolePolicyDocument'),
  newDescription?: string(name='NewDescription'),
  newMaxSessionDuration?: long(name='NewMaxSessionDuration'),
  roleName?: string(name='RoleName'),
}

model UpdateRoleResponseBody = {
  requestId?: string(name='RequestId'),
  role?: {
    arn?: string(name='Arn'),
    assumeRolePolicyDocument?: string(name='AssumeRolePolicyDocument'),
    createDate?: string(name='CreateDate'),
    description?: string(name='Description'),
    maxSessionDuration?: long(name='MaxSessionDuration'),
    roleId?: string(name='RoleId'),
    roleName?: string(name='RoleName'),
    updateDate?: string(name='UpdateDate'),
  }(name='Role'),
}

model UpdateRoleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateRoleResponseBody(name='body'),
}

async function updateRoleWithOptions(request: UpdateRoleRequest, runtime: Util.RuntimeOptions): UpdateRoleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.newAssumeRolePolicyDocument)) {
    query['NewAssumeRolePolicyDocument'] = request.newAssumeRolePolicyDocument;
  }
  if (!Util.isUnset(request.newDescription)) {
    query['NewDescription'] = request.newDescription;
  }
  if (!Util.isUnset(request.newMaxSessionDuration)) {
    query['NewMaxSessionDuration'] = request.newMaxSessionDuration;
  }
  if (!Util.isUnset(request.roleName)) {
    query['RoleName'] = request.roleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateRole',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateRole(request: UpdateRoleRequest): UpdateRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateRoleWithOptions(request, runtime);
}

model UpdateUserRequest {
  newComments?: string(name='NewComments'),
  newDisplayName?: string(name='NewDisplayName'),
  newEmail?: string(name='NewEmail'),
  newMobilePhone?: string(name='NewMobilePhone'),
  newUserName?: string(name='NewUserName'),
  userName?: string(name='UserName'),
}

model UpdateUserResponseBody = {
  requestId?: string(name='RequestId'),
  user?: {
    comments?: string(name='Comments'),
    createDate?: string(name='CreateDate'),
    displayName?: string(name='DisplayName'),
    email?: string(name='Email'),
    mobilePhone?: string(name='MobilePhone'),
    updateDate?: string(name='UpdateDate'),
    userId?: string(name='UserId'),
    userName?: string(name='UserName'),
  }(name='User'),
}

model UpdateUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateUserResponseBody(name='body'),
}

async function updateUserWithOptions(request: UpdateUserRequest, runtime: Util.RuntimeOptions): UpdateUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.newComments)) {
    query['NewComments'] = request.newComments;
  }
  if (!Util.isUnset(request.newDisplayName)) {
    query['NewDisplayName'] = request.newDisplayName;
  }
  if (!Util.isUnset(request.newEmail)) {
    query['NewEmail'] = request.newEmail;
  }
  if (!Util.isUnset(request.newMobilePhone)) {
    query['NewMobilePhone'] = request.newMobilePhone;
  }
  if (!Util.isUnset(request.newUserName)) {
    query['NewUserName'] = request.newUserName;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateUser',
    version = '2015-05-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateUser(request: UpdateUserRequest): UpdateUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateUserWithOptions(request, runtime);
}

