/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('composer', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model CloneFlowRequest {
  flowId?: string(name='FlowId'),
  versionId?: string(name='VersionId'),
}

model CloneFlowResponseBody = {
  flowId?: string(name='FlowId'),
  requestId?: string(name='RequestId'),
}

model CloneFlowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CloneFlowResponseBody(name='body'),
}

async function cloneFlowWithOptions(request: CloneFlowRequest, runtime: Util.RuntimeOptions): CloneFlowResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.flowId)) {
    body['FlowId'] = request.flowId;
  }
  if (!Util.isUnset(request.versionId)) {
    body['VersionId'] = request.versionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CloneFlow',
    version = '2018-12-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cloneFlow(request: CloneFlowRequest): CloneFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return cloneFlowWithOptions(request, runtime);
}

model CreateFlowRequest {
  definition?: string(name='Definition'),
  flowDescription?: string(name='FlowDescription'),
  flowName?: string(name='FlowName'),
  flowSource?: string(name='FlowSource'),
  templateId?: string(name='TemplateId'),
}

model CreateFlowResponseBody = {
  flowId?: string(name='FlowId'),
  requestId?: string(name='RequestId'),
}

model CreateFlowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateFlowResponseBody(name='body'),
}

async function createFlowWithOptions(request: CreateFlowRequest, runtime: Util.RuntimeOptions): CreateFlowResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.definition)) {
    body['Definition'] = request.definition;
  }
  if (!Util.isUnset(request.flowDescription)) {
    body['FlowDescription'] = request.flowDescription;
  }
  if (!Util.isUnset(request.flowName)) {
    body['FlowName'] = request.flowName;
  }
  if (!Util.isUnset(request.flowSource)) {
    body['FlowSource'] = request.flowSource;
  }
  if (!Util.isUnset(request.templateId)) {
    body['TemplateId'] = request.templateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateFlow',
    version = '2018-12-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createFlow(request: CreateFlowRequest): CreateFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFlowWithOptions(request, runtime);
}

model DeleteFlowRequest {
  flowId?: string(name='FlowId'),
}

model DeleteFlowResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteFlowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteFlowResponseBody(name='body'),
}

async function deleteFlowWithOptions(request: DeleteFlowRequest, runtime: Util.RuntimeOptions): DeleteFlowResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.flowId)) {
    body['FlowId'] = request.flowId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFlow',
    version = '2018-12-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteFlow(request: DeleteFlowRequest): DeleteFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFlowWithOptions(request, runtime);
}

model DisableFlowRequest {
  flowId?: string(name='FlowId'),
}

model DisableFlowResponseBody = {
  flowStatus?: string(name='FlowStatus'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DisableFlowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DisableFlowResponseBody(name='body'),
}

async function disableFlowWithOptions(request: DisableFlowRequest, runtime: Util.RuntimeOptions): DisableFlowResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.flowId)) {
    body['FlowId'] = request.flowId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DisableFlow',
    version = '2018-12-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function disableFlow(request: DisableFlowRequest): DisableFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableFlowWithOptions(request, runtime);
}

model EnableFlowRequest {
  flowId?: string(name='FlowId'),
}

model EnableFlowResponseBody = {
  flowStatus?: string(name='FlowStatus'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model EnableFlowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableFlowResponseBody(name='body'),
}

async function enableFlowWithOptions(request: EnableFlowRequest, runtime: Util.RuntimeOptions): EnableFlowResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.flowId)) {
    body['FlowId'] = request.flowId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'EnableFlow',
    version = '2018-12-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function enableFlow(request: EnableFlowRequest): EnableFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableFlowWithOptions(request, runtime);
}

model GetFlowRequest {
  flowId?: string(name='FlowId'),
}

model GetFlowResponseBody = {
  createTime?: string(name='CreateTime'),
  currentVersionId?: int32(name='CurrentVersionId'),
  definition?: string(name='Definition'),
  flowDescription?: string(name='FlowDescription'),
  flowEditMode?: string(name='FlowEditMode'),
  flowId?: string(name='FlowId'),
  flowName?: string(name='FlowName'),
  flowSource?: string(name='FlowSource'),
  flowStatus?: string(name='FlowStatus'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  templateId?: string(name='TemplateId'),
  updateTime?: string(name='UpdateTime'),
}

model GetFlowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetFlowResponseBody(name='body'),
}

async function getFlowWithOptions(request: GetFlowRequest, runtime: Util.RuntimeOptions): GetFlowResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.flowId)) {
    body['FlowId'] = request.flowId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetFlow',
    version = '2018-12-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getFlow(request: GetFlowRequest): GetFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return getFlowWithOptions(request, runtime);
}

model GetTemplateRequest {
  templateId?: string(name='TemplateId'),
}

model GetTemplateResponseBody = {
  createTime?: string(name='CreateTime'),
  definition?: string(name='Definition'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  templateConnector?: string(name='TemplateConnector'),
  templateCreator?: string(name='TemplateCreator'),
  templateDescription?: string(name='TemplateDescription'),
  templateId?: string(name='TemplateId'),
  templateLocale?: string(name='TemplateLocale'),
  templateName?: string(name='TemplateName'),
  templateOverview?: string(name='TemplateOverview'),
  templateSummary?: string(name='TemplateSummary'),
  templateSummaryEn?: string(name='TemplateSummaryEn'),
  templateTag?: string(name='TemplateTag'),
  templateVersion?: int32(name='TemplateVersion'),
  updateTime?: string(name='UpdateTime'),
}

model GetTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTemplateResponseBody(name='body'),
}

async function getTemplateWithOptions(request: GetTemplateRequest, runtime: Util.RuntimeOptions): GetTemplateResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.templateId)) {
    body['TemplateId'] = request.templateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetTemplate',
    version = '2018-12-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTemplate(request: GetTemplateRequest): GetTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTemplateWithOptions(request, runtime);
}

model GetVersionRequest {
  flowId?: string(name='FlowId'),
  versionId?: string(name='VersionId'),
}

model GetVersionResponseBody = {
  createTime?: string(name='CreateTime'),
  definition?: string(name='Definition'),
  flowId?: string(name='FlowId'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  updateTime?: string(name='UpdateTime'),
  versionDescription?: string(name='VersionDescription'),
  versionId?: string(name='VersionId'),
  versionName?: string(name='VersionName'),
  versionStatus?: string(name='VersionStatus'),
}

model GetVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetVersionResponseBody(name='body'),
}

async function getVersionWithOptions(request: GetVersionRequest, runtime: Util.RuntimeOptions): GetVersionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.flowId)) {
    body['FlowId'] = request.flowId;
  }
  if (!Util.isUnset(request.versionId)) {
    body['VersionId'] = request.versionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetVersion',
    version = '2018-12-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getVersion(request: GetVersionRequest): GetVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVersionWithOptions(request, runtime);
}

model GroupInvokeFlowRequest {
  clientToken?: string(name='ClientToken'),
  data?: string(name='Data'),
  flowId?: string(name='FlowId'),
  groupKey?: string(name='GroupKey'),
  tags?: string(name='Tags'),
  totalCount?: int32(name='TotalCount'),
}

model GroupInvokeFlowResponseBody = {
  currentCount?: int32(name='CurrentCount'),
  groupInvocationId?: string(name='GroupInvocationId'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
  success?: boolean(name='Success'),
}

model GroupInvokeFlowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GroupInvokeFlowResponseBody(name='body'),
}

async function groupInvokeFlowWithOptions(request: GroupInvokeFlowRequest, runtime: Util.RuntimeOptions): GroupInvokeFlowResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.data)) {
    body['Data'] = request.data;
  }
  if (!Util.isUnset(request.flowId)) {
    body['FlowId'] = request.flowId;
  }
  if (!Util.isUnset(request.groupKey)) {
    body['GroupKey'] = request.groupKey;
  }
  if (!Util.isUnset(request.totalCount)) {
    body['TotalCount'] = request.totalCount;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GroupInvokeFlow',
    version = '2018-12-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function groupInvokeFlow(request: GroupInvokeFlowRequest): GroupInvokeFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return groupInvokeFlowWithOptions(request, runtime);
}

model InvokeFlowRequest {
  clientToken?: string(name='ClientToken'),
  data?: string(name='Data'),
  flowId?: string(name='FlowId'),
  parameters?: string(name='Parameters'),
}

model InvokeFlowResponseBody = {
  invocationId?: string(name='InvocationId'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model InvokeFlowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InvokeFlowResponseBody(name='body'),
}

async function invokeFlowWithOptions(request: InvokeFlowRequest, runtime: Util.RuntimeOptions): InvokeFlowResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.data)) {
    body['Data'] = request.data;
  }
  if (!Util.isUnset(request.flowId)) {
    body['FlowId'] = request.flowId;
  }
  if (!Util.isUnset(request.parameters)) {
    body['Parameters'] = request.parameters;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'InvokeFlow',
    version = '2018-12-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function invokeFlow(request: InvokeFlowRequest): InvokeFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return invokeFlowWithOptions(request, runtime);
}

model ListFlowsRequest {
  filter?: string(name='Filter'),
  flowName?: string(name='FlowName'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListFlowsResponseBody = {
  flows?: [ 
    {
      createTime?: string(name='CreateTime'),
      flowDescription?: string(name='FlowDescription'),
      flowEditMode?: string(name='FlowEditMode'),
      flowId?: string(name='FlowId'),
      flowName?: string(name='FlowName'),
      flowSource?: string(name='FlowSource'),
      flowStatus?: string(name='FlowStatus'),
      regionId?: string(name='RegionId'),
      templateId?: string(name='TemplateId'),
      updateTime?: string(name='UpdateTime'),
      versionId?: int32(name='VersionId'),
    }
  ](name='Flows'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListFlowsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListFlowsResponseBody(name='body'),
}

async function listFlowsWithOptions(request: ListFlowsRequest, runtime: Util.RuntimeOptions): ListFlowsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.filter)) {
    body['Filter'] = request.filter;
  }
  if (!Util.isUnset(request.flowName)) {
    body['FlowName'] = request.flowName;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListFlows',
    version = '2018-12-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFlows(request: ListFlowsRequest): ListFlowsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFlowsWithOptions(request, runtime);
}

model ListTagResourcesRequest {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  resourceId?: [ string ](name='ResourceId'),
  resourceType?: string(name='ResourceType'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  tagResources?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='TagResources'),
  totalCount?: int32(name='TotalCount'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.maxResults)) {
    body['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    body['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.resourceId)) {
    body['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    body['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    body['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListTagResources',
    version = '2018-12-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagResourcesWithOptions(request, runtime);
}

model ListTemplatesRequest {
  lang?: string(name='Lang'),
  name?: string(name='Name'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  tag?: string(name='Tag'),
}

model ListTemplatesResponseBody = {
  requestId?: string(name='RequestId'),
  templates?: [ 
    {
      createTime?: string(name='CreateTime'),
      templateConnector?: string(name='TemplateConnector'),
      templateCreator?: string(name='TemplateCreator'),
      templateDescription?: string(name='TemplateDescription'),
      templateId?: string(name='TemplateId'),
      templateLocale?: string(name='TemplateLocale'),
      templateName?: string(name='TemplateName'),
      templateOverview?: string(name='TemplateOverview'),
      templateSummary?: string(name='TemplateSummary'),
      templateSummaryEn?: string(name='TemplateSummaryEn'),
      templateTag?: string(name='TemplateTag'),
      templateVersion?: int32(name='TemplateVersion'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='Templates'),
  totalCount?: int32(name='TotalCount'),
}

model ListTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTemplatesResponseBody(name='body'),
}

async function listTemplatesWithOptions(request: ListTemplatesRequest, runtime: Util.RuntimeOptions): ListTemplatesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.lang)) {
    body['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.tag)) {
    body['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListTemplates',
    version = '2018-12-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTemplates(request: ListTemplatesRequest): ListTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTemplatesWithOptions(request, runtime);
}

model ListVersionsRequest {
  flowId?: string(name='FlowId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListVersionsResponseBody = {
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  versions?: [ 
    {
      createTime?: string(name='CreateTime'),
      flowId?: string(name='FlowId'),
      updateTime?: string(name='UpdateTime'),
      versionId?: string(name='VersionId'),
      versionName?: int32(name='VersionName'),
      versionStatus?: int32(name='VersionStatus'),
    }
  ](name='Versions'),
}

model ListVersionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListVersionsResponseBody(name='body'),
}

async function listVersionsWithOptions(request: ListVersionsRequest, runtime: Util.RuntimeOptions): ListVersionsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.flowId)) {
    body['FlowId'] = request.flowId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListVersions',
    version = '2018-12-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listVersions(request: ListVersionsRequest): ListVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVersionsWithOptions(request, runtime);
}

model TagResourcesRequest {
  resourceId?: [ string ](name='ResourceId'),
  resourceType?: string(name='ResourceType'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResourcesWithOptions(request: TagResourcesRequest, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.resourceId)) {
    body['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    body['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    body['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'TagResources',
    version = '2018-12-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagResourcesWithOptions(request, runtime);
}

model UntagResourcesRequest {
  all?: boolean(name='All'),
  resourceId?: [ string ](name='ResourceId'),
  resourceType?: string(name='ResourceType'),
  tagKey?: [ string ](name='TagKey'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResourcesWithOptions(request: UntagResourcesRequest, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.all)) {
    body['All'] = request.all;
  }
  if (!Util.isUnset(request.resourceId)) {
    body['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    body['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagKey)) {
    body['TagKey'] = request.tagKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UntagResources',
    version = '2018-12-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return untagResourcesWithOptions(request, runtime);
}

model UpdateFlowRequest {
  definition?: string(name='Definition'),
  flowDescription?: string(name='FlowDescription'),
  flowId?: string(name='FlowId'),
  flowName?: string(name='FlowName'),
}

model UpdateFlowResponseBody = {
  currentVersionId?: int32(name='CurrentVersionId'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateFlowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateFlowResponseBody(name='body'),
}

async function updateFlowWithOptions(request: UpdateFlowRequest, runtime: Util.RuntimeOptions): UpdateFlowResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.definition)) {
    body['Definition'] = request.definition;
  }
  if (!Util.isUnset(request.flowDescription)) {
    body['FlowDescription'] = request.flowDescription;
  }
  if (!Util.isUnset(request.flowId)) {
    body['FlowId'] = request.flowId;
  }
  if (!Util.isUnset(request.flowName)) {
    body['FlowName'] = request.flowName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateFlow',
    version = '2018-12-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateFlow(request: UpdateFlowRequest): UpdateFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateFlowWithOptions(request, runtime);
}

