/**
 *
 */
import Util;
import OpenApi;

import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
@endpointMap = {
    cn-beijing = 'ahas.cn-beijing.aliyuncs.com',
    cn-zhangjiakou = 'ahas.cn-zhangjiakou.aliyuncs.com',
    cn-hangzhou = 'ahas.cn-hangzhou.aliyuncs.com',
    cn-shanghai = 'ahas.cn-shanghai.aliyuncs.com',
    cn-shenzhen = 'ahas.cn-shenzhen.aliyuncs.com',
    ap-southeast-1 = 'ahas.ap-southeast-1.aliyuncs.com',
    cn-hongkong = 'ahas.cn-hongkong.aliyuncs.com',
    eu-central-1 = 'ahas.eu-central-1.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('ahas-openapi', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model AddApplicationEmpIdRelationRequest {
  applicationId?: string(name='ApplicationId'),
  empIds?: string(name='EmpIds'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model AddApplicationEmpIdRelationResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model AddApplicationEmpIdRelationResponse = {
  headers: map[string]string(name='headers'),
  body: AddApplicationEmpIdRelationResponseBody(name='body'),
}

async function addApplicationEmpIdRelationWithOptions(request: AddApplicationEmpIdRelationRequest, runtime: Util.RuntimeOptions): AddApplicationEmpIdRelationResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddApplicationEmpIdRelation', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addApplicationEmpIdRelation(request: AddApplicationEmpIdRelationRequest): AddApplicationEmpIdRelationResponse {
  var runtime = new Util.RuntimeOptions{};
  return addApplicationEmpIdRelationWithOptions(request, runtime);
}

model CheckExperimentPermissionForMkRequest {
  empId?: string(name='EmpId'),
  experimentId?: string(name='ExperimentId'),
  namespace?: string(name='Namespace'),
  type?: string(name='Type'),
}

model CheckExperimentPermissionForMkResponseBody = {
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  permission?: boolean(name='Permission'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model CheckExperimentPermissionForMkResponse = {
  headers: map[string]string(name='headers'),
  body: CheckExperimentPermissionForMkResponseBody(name='body'),
}

async function checkExperimentPermissionForMkWithOptions(request: CheckExperimentPermissionForMkRequest, runtime: Util.RuntimeOptions): CheckExperimentPermissionForMkResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CheckExperimentPermissionForMk', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function checkExperimentPermissionForMk(request: CheckExperimentPermissionForMkRequest): CheckExperimentPermissionForMkResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkExperimentPermissionForMkWithOptions(request, runtime);
}

model CheckExperimentRunnableRequest {
  experimentId?: string(name='ExperimentId'),
  nameSpace?: string(name='NameSpace'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model CheckExperimentRunnableResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model CheckExperimentRunnableResponse = {
  headers: map[string]string(name='headers'),
  body: CheckExperimentRunnableResponseBody(name='body'),
}

async function checkExperimentRunnableWithOptions(request: CheckExperimentRunnableRequest, runtime: Util.RuntimeOptions): CheckExperimentRunnableResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CheckExperimentRunnable', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function checkExperimentRunnable(request: CheckExperimentRunnableRequest): CheckExperimentRunnableResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkExperimentRunnableWithOptions(request, runtime);
}

model CreateDegradeRuleRequest {
  namespace?: string(name='Namespace'),
  appName?: string(name='AppName'),
  resource?: string(name='Resource'),
  strategy?: int32(name='Strategy'),
  threshold?: float(name='Threshold'),
  enable?: boolean(name='Enable'),
  recoveryTimeoutMs?: int32(name='RecoveryTimeoutMs'),
  statDurationMs?: int32(name='StatDurationMs'),
  slowRtMs?: int32(name='SlowRtMs'),
  minRequestAmount?: int32(name='MinRequestAmount'),
  halfOpenBaseAmountPerStep?: int32(name='HalfOpenBaseAmountPerStep'),
  halfOpenRecoveryStepNum?: int32(name='HalfOpenRecoveryStepNum'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model CreateDegradeRuleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    slowRtMs?: int32(name='SlowRtMs'),
    halfOpenRecoveryStepNum?: int32(name='HalfOpenRecoveryStepNum'),
    namespace?: string(name='Namespace'),
    statDurationMs?: int32(name='StatDurationMs'),
    ruleId?: long(name='RuleId'),
    strategy?: int32(name='Strategy'),
    resource?: string(name='Resource'),
    appName?: string(name='AppName'),
    halfOpenBaseAmountPerStep?: int32(name='HalfOpenBaseAmountPerStep'),
    recoveryTimeoutMs?: int32(name='RecoveryTimeoutMs'),
    minRequestAmount?: int32(name='MinRequestAmount'),
    threshold?: float(name='Threshold'),
    enable?: boolean(name='Enable'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model CreateDegradeRuleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDegradeRuleResponseBody(name='body'),
}

async function createDegradeRuleWithOptions(request: CreateDegradeRuleRequest, runtime: Util.RuntimeOptions): CreateDegradeRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateDegradeRule', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createDegradeRule(request: CreateDegradeRuleRequest): CreateDegradeRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDegradeRuleWithOptions(request, runtime);
}

model CreateExperimentRequest {
  definition?: string(name='Definition'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  nameSpace?: string(name='NameSpace'),
  ahasRegionId?: string(name='AhasRegionId'),
  tags?: [ string ](name='Tags'),
}

model CreateExperimentResponseBody = {
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  experimentId?: string(name='ExperimentId'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model CreateExperimentResponse = {
  headers: map[string]string(name='headers'),
  body: CreateExperimentResponseBody(name='body'),
}

async function createExperimentWithOptions(request: CreateExperimentRequest, runtime: Util.RuntimeOptions): CreateExperimentResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateExperiment', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createExperiment(request: CreateExperimentRequest): CreateExperimentResponse {
  var runtime = new Util.RuntimeOptions{};
  return createExperimentWithOptions(request, runtime);
}

model CreateFlowRuleRequest {
  namespace?: string(name='Namespace'),
  appName?: string(name='AppName'),
  relationStrategy?: int32(name='RelationStrategy'),
  threshold?: float(name='Threshold'),
  enable?: boolean(name='Enable'),
  resource?: string(name='Resource'),
  limitOrigin?: string(name='LimitOrigin'),
  refResource?: string(name='RefResource'),
  controlBehavior?: int32(name='ControlBehavior'),
  warmUpPeriodSec?: int32(name='WarmUpPeriodSec'),
  maxQueueingTimeMs?: int32(name='MaxQueueingTimeMs'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model CreateFlowRuleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    refResource?: string(name='RefResource'),
    clusterFallbackThreshold?: int32(name='ClusterFallbackThreshold'),
    namespace?: string(name='Namespace'),
    limitOrigin?: string(name='LimitOrigin'),
    statDurationMs?: int32(name='StatDurationMs'),
    clusterThresholdType?: int32(name='ClusterThresholdType'),
    ruleId?: long(name='RuleId'),
    relationStrategy?: int32(name='RelationStrategy'),
    appName?: string(name='AppName'),
    resource?: string(name='Resource'),
    clusterEstimatedMaxQps?: float(name='ClusterEstimatedMaxQps'),
    controlBehavior?: int32(name='ControlBehavior'),
    maxQueueingTimeMs?: int32(name='MaxQueueingTimeMs'),
    clusterFallbackStrategy?: int32(name='ClusterFallbackStrategy'),
    warmUpPeriodSec?: int32(name='WarmUpPeriodSec'),
    clusterMode?: boolean(name='ClusterMode'),
    threshold?: float(name='Threshold'),
    enable?: boolean(name='Enable'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model CreateFlowRuleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFlowRuleResponseBody(name='body'),
}

async function createFlowRuleWithOptions(request: CreateFlowRuleRequest, runtime: Util.RuntimeOptions): CreateFlowRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateFlowRule', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createFlowRule(request: CreateFlowRuleRequest): CreateFlowRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFlowRuleWithOptions(request, runtime);
}

model CreateHotParamItemsRequest {
  ruleId?: long(name='RuleId'),
  items?: string(name='Items'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model CreateHotParamItemsResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    paramIdx?: int32(name='ParamIdx'),
    namespace?: string(name='Namespace'),
    paramFlowItemList?: [ 
      {
        itemValue?: string(name='ItemValue'),
        itemType?: string(name='ItemType'),
        threshold?: float(name='Threshold'),
      }
    ](name='ParamFlowItemList'),
    statDurationSec?: long(name='StatDurationSec'),
    burstCount?: int32(name='BurstCount'),
    ruleId?: long(name='RuleId'),
    resource?: string(name='Resource'),
    appName?: string(name='AppName'),
    maxQueueingTimeMs?: int32(name='MaxQueueingTimeMs'),
    controlBehavior?: int32(name='ControlBehavior'),
    metricType?: int32(name='MetricType'),
    threshold?: float(name='Threshold'),
    enable?: boolean(name='Enable'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model CreateHotParamItemsResponse = {
  headers: map[string]string(name='headers'),
  body: CreateHotParamItemsResponseBody(name='body'),
}

async function createHotParamItemsWithOptions(request: CreateHotParamItemsRequest, runtime: Util.RuntimeOptions): CreateHotParamItemsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateHotParamItems', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createHotParamItems(request: CreateHotParamItemsRequest): CreateHotParamItemsResponse {
  var runtime = new Util.RuntimeOptions{};
  return createHotParamItemsWithOptions(request, runtime);
}

model CreateHotParamRuleRequest {
  namespace?: string(name='Namespace'),
  appName?: string(name='AppName'),
  metricType?: int32(name='MetricType'),
  threshold?: float(name='Threshold'),
  enable?: boolean(name='Enable'),
  resource?: string(name='Resource'),
  paramIdx?: int32(name='ParamIdx'),
  statDurationSec?: long(name='StatDurationSec'),
  controlBehavior?: int32(name='ControlBehavior'),
  burstCount?: int32(name='BurstCount'),
  maxQueueingTimeMs?: int32(name='MaxQueueingTimeMs'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model CreateHotParamRuleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    paramIdx?: int32(name='ParamIdx'),
    namespace?: string(name='Namespace'),
    paramFlowItemList?: [ 
      {
        itemValue?: string(name='ItemValue'),
        itemType?: string(name='ItemType'),
        threshold?: float(name='Threshold'),
      }
    ](name='ParamFlowItemList'),
    statDurationSec?: long(name='StatDurationSec'),
    burstCount?: int32(name='BurstCount'),
    ruleId?: long(name='RuleId'),
    resource?: string(name='Resource'),
    appName?: string(name='AppName'),
    maxQueueingTimeMs?: int32(name='MaxQueueingTimeMs'),
    controlBehavior?: int32(name='ControlBehavior'),
    metricType?: int32(name='MetricType'),
    threshold?: float(name='Threshold'),
    enable?: boolean(name='Enable'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model CreateHotParamRuleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateHotParamRuleResponseBody(name='body'),
}

async function createHotParamRuleWithOptions(request: CreateHotParamRuleRequest, runtime: Util.RuntimeOptions): CreateHotParamRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateHotParamRule', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createHotParamRule(request: CreateHotParamRuleRequest): CreateHotParamRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createHotParamRuleWithOptions(request, runtime);
}

model CreateIsolationRuleRequest {
  namespace?: string(name='Namespace'),
  appName?: string(name='AppName'),
  relationStrategy?: int32(name='RelationStrategy'),
  threshold?: float(name='Threshold'),
  enable?: boolean(name='Enable'),
  resource?: string(name='Resource'),
  limitOrigin?: string(name='LimitOrigin'),
  refResource?: string(name='RefResource'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model CreateIsolationRuleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    relationStrategy?: int32(name='RelationStrategy'),
    resource?: string(name='Resource'),
    appName?: string(name='AppName'),
    refResource?: string(name='RefResource'),
    namespace?: string(name='Namespace'),
    limitOrigin?: string(name='LimitOrigin'),
    threshold?: float(name='Threshold'),
    ruleId?: long(name='RuleId'),
    enable?: boolean(name='Enable'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model CreateIsolationRuleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateIsolationRuleResponseBody(name='body'),
}

async function createIsolationRuleWithOptions(request: CreateIsolationRuleRequest, runtime: Util.RuntimeOptions): CreateIsolationRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateIsolationRule', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createIsolationRule(request: CreateIsolationRuleRequest): CreateIsolationRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createIsolationRuleWithOptions(request, runtime);
}

model CreateSystemRuleRequest {
  namespace?: string(name='Namespace'),
  appName?: string(name='AppName'),
  metricType?: int32(name='MetricType'),
  threshold?: float(name='Threshold'),
  enable?: boolean(name='Enable'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model CreateSystemRuleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    metricType?: int32(name='MetricType'),
    threshold?: float(name='Threshold'),
    ruleId?: long(name='RuleId'),
    enable?: boolean(name='Enable'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model CreateSystemRuleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSystemRuleResponseBody(name='body'),
}

async function createSystemRuleWithOptions(request: CreateSystemRuleRequest, runtime: Util.RuntimeOptions): CreateSystemRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateSystemRule', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createSystemRule(request: CreateSystemRuleRequest): CreateSystemRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSystemRuleWithOptions(request, runtime);
}

model DeleteApplicationEmpIdRelationRequest {
  applicationId?: string(name='ApplicationId'),
  empIds?: string(name='EmpIds'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model DeleteApplicationEmpIdRelationResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DeleteApplicationEmpIdRelationResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteApplicationEmpIdRelationResponseBody(name='body'),
}

async function deleteApplicationEmpIdRelationWithOptions(request: DeleteApplicationEmpIdRelationRequest, runtime: Util.RuntimeOptions): DeleteApplicationEmpIdRelationResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteApplicationEmpIdRelation', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteApplicationEmpIdRelation(request: DeleteApplicationEmpIdRelationRequest): DeleteApplicationEmpIdRelationResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteApplicationEmpIdRelationWithOptions(request, runtime);
}

model DeleteDegradeRuleRequest {
  ruleId?: long(name='RuleId'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model DeleteDegradeRuleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    ruleId?: long(name='RuleId'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DeleteDegradeRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDegradeRuleResponseBody(name='body'),
}

async function deleteDegradeRuleWithOptions(request: DeleteDegradeRuleRequest, runtime: Util.RuntimeOptions): DeleteDegradeRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteDegradeRule', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteDegradeRule(request: DeleteDegradeRuleRequest): DeleteDegradeRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDegradeRuleWithOptions(request, runtime);
}

model DeleteFlowRuleRequest {
  ruleId?: long(name='RuleId'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model DeleteFlowRuleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    ruleId?: long(name='RuleId'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DeleteFlowRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFlowRuleResponseBody(name='body'),
}

async function deleteFlowRuleWithOptions(request: DeleteFlowRuleRequest, runtime: Util.RuntimeOptions): DeleteFlowRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteFlowRule', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteFlowRule(request: DeleteFlowRuleRequest): DeleteFlowRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFlowRuleWithOptions(request, runtime);
}

model DeleteHotParamRuleRequest {
  ruleId?: long(name='RuleId'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model DeleteHotParamRuleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    ruleId?: long(name='RuleId'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DeleteHotParamRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteHotParamRuleResponseBody(name='body'),
}

async function deleteHotParamRuleWithOptions(request: DeleteHotParamRuleRequest, runtime: Util.RuntimeOptions): DeleteHotParamRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteHotParamRule', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteHotParamRule(request: DeleteHotParamRuleRequest): DeleteHotParamRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteHotParamRuleWithOptions(request, runtime);
}

model DeleteIsolationRuleRequest {
  ruleId?: long(name='RuleId'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model DeleteIsolationRuleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    ruleId?: long(name='RuleId'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DeleteIsolationRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteIsolationRuleResponseBody(name='body'),
}

async function deleteIsolationRuleWithOptions(request: DeleteIsolationRuleRequest, runtime: Util.RuntimeOptions): DeleteIsolationRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteIsolationRule', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteIsolationRule(request: DeleteIsolationRuleRequest): DeleteIsolationRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteIsolationRuleWithOptions(request, runtime);
}

model DeleteSystemRuleRequest {
  ruleId?: long(name='RuleId'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model DeleteSystemRuleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    ruleId?: long(name='RuleId'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DeleteSystemRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSystemRuleResponseBody(name='body'),
}

async function deleteSystemRuleWithOptions(request: DeleteSystemRuleRequest, runtime: Util.RuntimeOptions): DeleteSystemRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteSystemRule', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteSystemRule(request: DeleteSystemRuleRequest): DeleteSystemRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSystemRuleWithOptions(request, runtime);
}

model DescribeRegionsRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
}

model DescribeRegionsResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  regions?: [ 
    {
      localName?: string(name='LocalName'),
      regionEndpoint?: string(name='RegionEndpoint'),
      regionId?: string(name='RegionId'),
    }
  ](name='Regions'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeRegions', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(request, runtime);
}

model DisableDegradeRuleRequest {
  ruleId?: long(name='RuleId'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model DisableDegradeRuleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    slowRtMs?: int32(name='SlowRtMs'),
    halfOpenRecoveryStepNum?: int32(name='HalfOpenRecoveryStepNum'),
    namespace?: string(name='Namespace'),
    statDurationMs?: int32(name='StatDurationMs'),
    ruleId?: long(name='RuleId'),
    strategy?: int32(name='Strategy'),
    resource?: string(name='Resource'),
    appName?: string(name='AppName'),
    halfOpenBaseAmountPerStep?: int32(name='HalfOpenBaseAmountPerStep'),
    recoveryTimeoutMs?: int32(name='RecoveryTimeoutMs'),
    minRequestAmount?: int32(name='MinRequestAmount'),
    threshold?: float(name='Threshold'),
    enable?: boolean(name='Enable'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DisableDegradeRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DisableDegradeRuleResponseBody(name='body'),
}

async function disableDegradeRuleWithOptions(request: DisableDegradeRuleRequest, runtime: Util.RuntimeOptions): DisableDegradeRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DisableDegradeRule', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function disableDegradeRule(request: DisableDegradeRuleRequest): DisableDegradeRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableDegradeRuleWithOptions(request, runtime);
}

model DisableFlowRuleRequest {
  ruleId?: long(name='RuleId'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model DisableFlowRuleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    refResource?: string(name='RefResource'),
    clusterFallbackThreshold?: int32(name='ClusterFallbackThreshold'),
    namespace?: string(name='Namespace'),
    limitOrigin?: string(name='LimitOrigin'),
    statDurationMs?: int32(name='StatDurationMs'),
    clusterThresholdType?: int32(name='ClusterThresholdType'),
    ruleId?: long(name='RuleId'),
    relationStrategy?: int32(name='RelationStrategy'),
    appName?: string(name='AppName'),
    resource?: string(name='Resource'),
    maxQueueingTimeMs?: int32(name='MaxQueueingTimeMs'),
    clusterEstimatedMaxQps?: float(name='ClusterEstimatedMaxQps'),
    controlBehavior?: int32(name='ControlBehavior'),
    warmUpPeriodSec?: int32(name='WarmUpPeriodSec'),
    clusterFallbackStrategy?: int32(name='ClusterFallbackStrategy'),
    threshold?: float(name='Threshold'),
    clusterMode?: boolean(name='ClusterMode'),
    enable?: boolean(name='Enable'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DisableFlowRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DisableFlowRuleResponseBody(name='body'),
}

async function disableFlowRuleWithOptions(request: DisableFlowRuleRequest, runtime: Util.RuntimeOptions): DisableFlowRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DisableFlowRule', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function disableFlowRule(request: DisableFlowRuleRequest): DisableFlowRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableFlowRuleWithOptions(request, runtime);
}

model DisableHotParamRuleRequest {
  ruleId?: long(name='RuleId'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model DisableHotParamRuleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    paramIdx?: int32(name='ParamIdx'),
    namespace?: string(name='Namespace'),
    paramFlowItemList?: [ 
      {
        itemValue?: string(name='ItemValue'),
        itemType?: string(name='ItemType'),
        threshold?: float(name='Threshold'),
      }
    ](name='ParamFlowItemList'),
    statDurationSec?: long(name='StatDurationSec'),
    burstCount?: int32(name='BurstCount'),
    ruleId?: long(name='RuleId'),
    resource?: string(name='Resource'),
    appName?: string(name='AppName'),
    maxQueueingTimeMs?: int32(name='MaxQueueingTimeMs'),
    controlBehavior?: int32(name='ControlBehavior'),
    metricType?: int32(name='MetricType'),
    threshold?: float(name='Threshold'),
    enable?: boolean(name='Enable'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DisableHotParamRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DisableHotParamRuleResponseBody(name='body'),
}

async function disableHotParamRuleWithOptions(request: DisableHotParamRuleRequest, runtime: Util.RuntimeOptions): DisableHotParamRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DisableHotParamRule', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function disableHotParamRule(request: DisableHotParamRuleRequest): DisableHotParamRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableHotParamRuleWithOptions(request, runtime);
}

model DisableIsolationRuleRequest {
  ruleId?: long(name='RuleId'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model DisableIsolationRuleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    relationStrategy?: int32(name='RelationStrategy'),
    resource?: string(name='Resource'),
    appName?: string(name='AppName'),
    refResource?: string(name='RefResource'),
    namespace?: string(name='Namespace'),
    limitOrigin?: string(name='LimitOrigin'),
    threshold?: float(name='Threshold'),
    ruleId?: long(name='RuleId'),
    enable?: boolean(name='Enable'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DisableIsolationRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DisableIsolationRuleResponseBody(name='body'),
}

async function disableIsolationRuleWithOptions(request: DisableIsolationRuleRequest, runtime: Util.RuntimeOptions): DisableIsolationRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DisableIsolationRule', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function disableIsolationRule(request: DisableIsolationRuleRequest): DisableIsolationRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableIsolationRuleWithOptions(request, runtime);
}

model DisableSystemRuleRequest {
  ruleId?: long(name='RuleId'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model DisableSystemRuleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    metricType?: int32(name='MetricType'),
    threshold?: float(name='Threshold'),
    ruleId?: long(name='RuleId'),
    enable?: boolean(name='Enable'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DisableSystemRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DisableSystemRuleResponseBody(name='body'),
}

async function disableSystemRuleWithOptions(request: DisableSystemRuleRequest, runtime: Util.RuntimeOptions): DisableSystemRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DisableSystemRule', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function disableSystemRule(request: DisableSystemRuleRequest): DisableSystemRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableSystemRuleWithOptions(request, runtime);
}

model EnableDegradeRuleRequest {
  ruleId?: long(name='RuleId'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model EnableDegradeRuleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    slowRtMs?: int32(name='SlowRtMs'),
    halfOpenRecoveryStepNum?: int32(name='HalfOpenRecoveryStepNum'),
    namespace?: string(name='Namespace'),
    statDurationMs?: int32(name='StatDurationMs'),
    ruleId?: long(name='RuleId'),
    strategy?: int32(name='Strategy'),
    resource?: string(name='Resource'),
    appName?: string(name='AppName'),
    halfOpenBaseAmountPerStep?: int32(name='HalfOpenBaseAmountPerStep'),
    recoveryTimeoutMs?: int32(name='RecoveryTimeoutMs'),
    minRequestAmount?: int32(name='MinRequestAmount'),
    threshold?: float(name='Threshold'),
    enable?: boolean(name='Enable'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model EnableDegradeRuleResponse = {
  headers: map[string]string(name='headers'),
  body: EnableDegradeRuleResponseBody(name='body'),
}

async function enableDegradeRuleWithOptions(request: EnableDegradeRuleRequest, runtime: Util.RuntimeOptions): EnableDegradeRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('EnableDegradeRule', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function enableDegradeRule(request: EnableDegradeRuleRequest): EnableDegradeRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableDegradeRuleWithOptions(request, runtime);
}

model EnableFlowRuleRequest {
  ruleId?: long(name='RuleId'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model EnableFlowRuleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    refResource?: string(name='RefResource'),
    clusterFallbackThreshold?: int32(name='ClusterFallbackThreshold'),
    namespace?: string(name='Namespace'),
    limitOrigin?: string(name='LimitOrigin'),
    statDurationMs?: int32(name='StatDurationMs'),
    clusterThresholdType?: int32(name='ClusterThresholdType'),
    ruleId?: long(name='RuleId'),
    relationStrategy?: int32(name='RelationStrategy'),
    appName?: string(name='AppName'),
    resource?: string(name='Resource'),
    maxQueueingTimeMs?: int32(name='MaxQueueingTimeMs'),
    clusterEstimatedMaxQps?: float(name='ClusterEstimatedMaxQps'),
    controlBehavior?: int32(name='ControlBehavior'),
    warmUpPeriodSec?: int32(name='WarmUpPeriodSec'),
    clusterFallbackStrategy?: int32(name='ClusterFallbackStrategy'),
    threshold?: float(name='Threshold'),
    clusterMode?: boolean(name='ClusterMode'),
    enable?: boolean(name='Enable'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model EnableFlowRuleResponse = {
  headers: map[string]string(name='headers'),
  body: EnableFlowRuleResponseBody(name='body'),
}

async function enableFlowRuleWithOptions(request: EnableFlowRuleRequest, runtime: Util.RuntimeOptions): EnableFlowRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('EnableFlowRule', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function enableFlowRule(request: EnableFlowRuleRequest): EnableFlowRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableFlowRuleWithOptions(request, runtime);
}

model EnableHotParamRuleRequest {
  ruleId?: long(name='RuleId'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model EnableHotParamRuleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    paramIdx?: int32(name='ParamIdx'),
    namespace?: string(name='Namespace'),
    paramFlowItemList?: [ 
      {
        itemValue?: string(name='ItemValue'),
        itemType?: string(name='ItemType'),
        threshold?: float(name='Threshold'),
      }
    ](name='ParamFlowItemList'),
    statDurationSec?: long(name='StatDurationSec'),
    burstCount?: int32(name='BurstCount'),
    ruleId?: long(name='RuleId'),
    resource?: string(name='Resource'),
    appName?: string(name='AppName'),
    maxQueueingTimeMs?: int32(name='MaxQueueingTimeMs'),
    controlBehavior?: int32(name='ControlBehavior'),
    metricType?: int32(name='MetricType'),
    threshold?: float(name='Threshold'),
    enable?: boolean(name='Enable'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model EnableHotParamRuleResponse = {
  headers: map[string]string(name='headers'),
  body: EnableHotParamRuleResponseBody(name='body'),
}

async function enableHotParamRuleWithOptions(request: EnableHotParamRuleRequest, runtime: Util.RuntimeOptions): EnableHotParamRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('EnableHotParamRule', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function enableHotParamRule(request: EnableHotParamRuleRequest): EnableHotParamRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableHotParamRuleWithOptions(request, runtime);
}

model EnableIsolationRuleRequest {
  ruleId?: long(name='RuleId'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model EnableIsolationRuleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    relationStrategy?: int32(name='RelationStrategy'),
    resource?: string(name='Resource'),
    appName?: string(name='AppName'),
    refResource?: string(name='RefResource'),
    namespace?: string(name='Namespace'),
    limitOrigin?: string(name='LimitOrigin'),
    threshold?: float(name='Threshold'),
    ruleId?: long(name='RuleId'),
    enable?: boolean(name='Enable'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model EnableIsolationRuleResponse = {
  headers: map[string]string(name='headers'),
  body: EnableIsolationRuleResponseBody(name='body'),
}

async function enableIsolationRuleWithOptions(request: EnableIsolationRuleRequest, runtime: Util.RuntimeOptions): EnableIsolationRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('EnableIsolationRule', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function enableIsolationRule(request: EnableIsolationRuleRequest): EnableIsolationRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableIsolationRuleWithOptions(request, runtime);
}

model EnableSystemRuleRequest {
  ruleId?: long(name='RuleId'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model EnableSystemRuleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    metricType?: int32(name='MetricType'),
    threshold?: float(name='Threshold'),
    ruleId?: long(name='RuleId'),
    enable?: boolean(name='Enable'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model EnableSystemRuleResponse = {
  headers: map[string]string(name='headers'),
  body: EnableSystemRuleResponseBody(name='body'),
}

async function enableSystemRuleWithOptions(request: EnableSystemRuleRequest, runtime: Util.RuntimeOptions): EnableSystemRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('EnableSystemRule', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function enableSystemRule(request: EnableSystemRuleRequest): EnableSystemRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableSystemRuleWithOptions(request, runtime);
}

model ExecuteExperimentRequest {
  experimentId?: string(name='ExperimentId'),
  nameSpace?: string(name='NameSpace'),
  definition?: string(name='Definition'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model ExecuteExperimentResponseBody = {
  taskId?: string(name='TaskId'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model ExecuteExperimentResponse = {
  headers: map[string]string(name='headers'),
  body: ExecuteExperimentResponseBody(name='body'),
}

async function executeExperimentWithOptions(request: ExecuteExperimentRequest, runtime: Util.RuntimeOptions): ExecuteExperimentResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ExecuteExperiment', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function executeExperiment(request: ExecuteExperimentRequest): ExecuteExperimentResponse {
  var runtime = new Util.RuntimeOptions{};
  return executeExperimentWithOptions(request, runtime);
}

model FinishExperimentTaskRequest {
  experimentTaskId?: string(name='ExperimentTaskId'),
  nameSpace?: string(name='NameSpace'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model FinishExperimentTaskResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model FinishExperimentTaskResponse = {
  headers: map[string]string(name='headers'),
  body: FinishExperimentTaskResponseBody(name='body'),
}

async function finishExperimentTaskWithOptions(request: FinishExperimentTaskRequest, runtime: Util.RuntimeOptions): FinishExperimentTaskResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('FinishExperimentTask', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function finishExperimentTask(request: FinishExperimentTaskRequest): FinishExperimentTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return finishExperimentTaskWithOptions(request, runtime);
}

model GetActivityTaskRequest {
  experimentTaskId?: string(name='ExperimentTaskId'),
  nameSpace?: string(name='NameSpace'),
  activityTaskId?: string(name='ActivityTaskId'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model GetActivityTaskResponseBody = {
  hosts?: [ 
    {
      hostIp?: string(name='HostIp'),
      endTime?: long(name='EndTime'),
      startTime?: long(name='StartTime'),
      data?: string(name='Data'),
      errorMessage?: string(name='ErrorMessage'),
      expId?: string(name='ExpId'),
      result?: string(name='Result'),
      state?: string(name='State'),
      taskId?: string(name='TaskId'),
    }
  ](name='Hosts'),
  phase?: string(name='Phase'),
  endTime?: long(name='EndTime'),
  requestId?: string(name='RequestId'),
  activityName?: string(name='ActivityName'),
  state?: string(name='State'),
  activityId?: string(name='ActivityId'),
  experimentTaskId?: string(name='ExperimentTaskId'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  startTime?: long(name='StartTime'),
  runResult?: string(name='RunResult'),
  success?: boolean(name='Success'),
}

model GetActivityTaskResponse = {
  headers: map[string]string(name='headers'),
  body: GetActivityTaskResponseBody(name='body'),
}

async function getActivityTaskWithOptions(request: GetActivityTaskRequest, runtime: Util.RuntimeOptions): GetActivityTaskResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetActivityTask', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getActivityTask(request: GetActivityTaskRequest): GetActivityTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return getActivityTaskWithOptions(request, runtime);
}

model GetApplicationEmpIdRelationRequest {
  applicationId?: string(name='ApplicationId'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model GetApplicationEmpIdRelationResponseBody = {
  empIds?: [ string ](name='EmpIds'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model GetApplicationEmpIdRelationResponse = {
  headers: map[string]string(name='headers'),
  body: GetApplicationEmpIdRelationResponseBody(name='body'),
}

async function getApplicationEmpIdRelationWithOptions(request: GetApplicationEmpIdRelationRequest, runtime: Util.RuntimeOptions): GetApplicationEmpIdRelationResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetApplicationEmpIdRelation', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getApplicationEmpIdRelation(request: GetApplicationEmpIdRelationRequest): GetApplicationEmpIdRelationResponse {
  var runtime = new Util.RuntimeOptions{};
  return getApplicationEmpIdRelationWithOptions(request, runtime);
}

model GetExperimentMetaRequest {
  experimentId?: string(name='ExperimentId'),
  nameSpace?: string(name='NameSpace'),
}

model GetExperimentMetaResponseBody = {
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  state?: string(name='State'),
  experimentId?: string(name='ExperimentId'),
  createTime?: string(name='CreateTime'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
  tags?: [ string ](name='Tags'),
  name?: string(name='Name'),
}

model GetExperimentMetaResponse = {
  headers: map[string]string(name='headers'),
  body: GetExperimentMetaResponseBody(name='body'),
}

async function getExperimentMetaWithOptions(request: GetExperimentMetaRequest, runtime: Util.RuntimeOptions): GetExperimentMetaResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetExperimentMeta', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getExperimentMeta(request: GetExperimentMetaRequest): GetExperimentMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  return getExperimentMetaWithOptions(request, runtime);
}

model GetExperimentTaskRequest {
  experimentTaskId?: string(name='ExperimentTaskId'),
  nameSpace?: string(name='NameSpace'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model GetExperimentTaskResponseBody = {
  activities?: [ 
    {
      endTime?: long(name='EndTime'),
      startTime?: long(name='StartTime'),
      checkState?: string(name='CheckState'),
      runResult?: string(name='RunResult'),
      state?: string(name='State'),
      activityId?: string(name='ActivityId'),
      phase?: string(name='Phase'),
      activityName?: string(name='ActivityName'),
      experimentTaskId?: string(name='ExperimentTaskId'),
      taskId?: string(name='TaskId'),
    }
  ](name='Activities'),
  taskId?: string(name='TaskId'),
  requestId?: string(name='RequestId'),
  experimentName?: string(name='ExperimentName'),
  state?: string(name='State'),
  experimentId?: string(name='ExperimentId'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  startTime?: long(name='StartTime'),
  success?: boolean(name='Success'),
  result?: string(name='Result'),
}

model GetExperimentTaskResponse = {
  headers: map[string]string(name='headers'),
  body: GetExperimentTaskResponseBody(name='body'),
}

async function getExperimentTaskWithOptions(request: GetExperimentTaskRequest, runtime: Util.RuntimeOptions): GetExperimentTaskResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetExperimentTask', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getExperimentTask(request: GetExperimentTaskRequest): GetExperimentTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return getExperimentTaskWithOptions(request, runtime);
}

model GetHitCountRequest {
  activityTaskId?: string(name='ActivityTaskId'),
  startTime?: long(name='StartTime'),
  endTime?: long(name='EndTime'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model GetHitCountResponseBody = {
  hits?: [ 
    {
      hostIp?: string(name='HostIp'),
      count?: float(name='Count'),
    }
  ](name='Hits'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model GetHitCountResponse = {
  headers: map[string]string(name='headers'),
  body: GetHitCountResponseBody(name='body'),
}

async function getHitCountWithOptions(request: GetHitCountRequest, runtime: Util.RuntimeOptions): GetHitCountResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetHitCount', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getHitCount(request: GetHitCountRequest): GetHitCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return getHitCountWithOptions(request, runtime);
}

model GetLicenseKeyRequest {
  namespace?: string(name='Namespace'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model GetLicenseKeyResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model GetLicenseKeyResponse = {
  headers: map[string]string(name='headers'),
  body: GetLicenseKeyResponseBody(name='body'),
}

async function getLicenseKeyWithOptions(request: GetLicenseKeyRequest, runtime: Util.RuntimeOptions): GetLicenseKeyResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetLicenseKey', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getLicenseKey(request: GetLicenseKeyRequest): GetLicenseKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLicenseKeyWithOptions(request, runtime);
}

model GetMetricsOfAppRequest {
  namespace?: string(name='Namespace'),
  appName?: string(name='AppName'),
  startTime?: long(name='StartTime'),
  endTime?: long(name='EndTime'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model GetMetricsOfAppResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    appName?: string(name='AppName'),
    namespace?: string(name='Namespace'),
    innerMetrics?: [ 
      {
        rtP99?: float(name='RtP99'),
        successQpsAvg?: float(name='SuccessQpsAvg'),
        passedQpsP99?: float(name='PassedQpsP99'),
        rtAvg?: float(name='RtAvg'),
        count?: int32(name='Count'),
        threadStd?: float(name='ThreadStd'),
        passedQpsAvg?: float(name='PassedQpsAvg'),
        exceptionP95?: float(name='ExceptionP95'),
        successQpsMax?: float(name='SuccessQpsMax'),
        rtP95?: float(name='RtP95'),
        blockedQpsMin?: float(name='BlockedQpsMin'),
        blockedQps?: float(name='BlockedQps'),
        timestamp?: long(name='Timestamp'),
        threadP95?: float(name='ThreadP95'),
        rtStd?: float(name='RtStd'),
        passedQpsMin?: float(name='PassedQpsMin'),
        blockedQpsP99?: float(name='BlockedQpsP99'),
        passedQpsMax?: float(name='PassedQpsMax'),
        exceptionMax?: float(name='ExceptionMax'),
        successQps?: float(name='SuccessQps'),
        successQpsP75?: float(name='SuccessQpsP75'),
        threadP75?: float(name='ThreadP75'),
        successQpsStd?: float(name='SuccessQpsStd'),
        exceptionMin?: float(name='ExceptionMin'),
        passedQpsP75?: float(name='PassedQpsP75'),
        passedQps?: float(name='PassedQps'),
        threadMax?: float(name='ThreadMax'),
        successQpsP99?: float(name='SuccessQpsP99'),
        successQpsMin?: float(name='SuccessQpsMin'),
        threadP99?: float(name='ThreadP99'),
        exceptionStd?: float(name='ExceptionStd'),
        blockedQpsP95?: float(name='BlockedQpsP95'),
        thread?: float(name='Thread'),
        threadMin?: float(name='ThreadMin'),
        rtMin?: float(name='RtMin'),
        blockedQpsAvg?: float(name='BlockedQpsAvg'),
        threadAvg?: float(name='ThreadAvg'),
        blockedQpsP75?: float(name='BlockedQpsP75'),
        rtP75?: float(name='RtP75'),
        exceptionP99?: float(name='ExceptionP99'),
        exceptionP75?: float(name='ExceptionP75'),
        successQpsP95?: float(name='SuccessQpsP95'),
        rt?: float(name='Rt'),
        passedQpsP95?: float(name='PassedQpsP95'),
        rtMax?: float(name='RtMax'),
        blockedQpsStd?: float(name='BlockedQpsStd'),
        blockedQpsMax?: float(name='BlockedQpsMax'),
        exception?: float(name='Exception'),
        exceptionAvg?: float(name='ExceptionAvg'),
        passedQpsStd?: float(name='PassedQpsStd'),
      }
    ](name='InnerMetrics'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model GetMetricsOfAppResponse = {
  headers: map[string]string(name='headers'),
  body: GetMetricsOfAppResponseBody(name='body'),
}

async function getMetricsOfAppWithOptions(request: GetMetricsOfAppRequest, runtime: Util.RuntimeOptions): GetMetricsOfAppResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetMetricsOfApp', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getMetricsOfApp(request: GetMetricsOfAppRequest): GetMetricsOfAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetricsOfAppWithOptions(request, runtime);
}

model GetMetricsOfResourceRequest {
  namespace?: string(name='Namespace'),
  appName?: string(name='AppName'),
  resource?: string(name='Resource'),
  startTime?: long(name='StartTime'),
  endTime?: long(name='EndTime'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model GetMetricsOfResourceResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    appName?: string(name='AppName'),
    resource?: string(name='Resource'),
    namespace?: string(name='Namespace'),
    innerMetrics?: [ 
      {
        rtP99?: float(name='RtP99'),
        successQpsAvg?: float(name='SuccessQpsAvg'),
        passedQpsP99?: float(name='PassedQpsP99'),
        rtAvg?: float(name='RtAvg'),
        count?: int32(name='Count'),
        threadStd?: float(name='ThreadStd'),
        passedQpsAvg?: float(name='PassedQpsAvg'),
        exceptionP95?: float(name='ExceptionP95'),
        successQpsMax?: float(name='SuccessQpsMax'),
        rtP95?: float(name='RtP95'),
        blockedQpsMin?: float(name='BlockedQpsMin'),
        blockedQps?: float(name='BlockedQps'),
        timestamp?: long(name='Timestamp'),
        threadP95?: float(name='ThreadP95'),
        rtStd?: float(name='RtStd'),
        passedQpsMin?: float(name='PassedQpsMin'),
        blockedQpsP99?: float(name='BlockedQpsP99'),
        passedQpsMax?: float(name='PassedQpsMax'),
        exceptionMax?: float(name='ExceptionMax'),
        successQps?: float(name='SuccessQps'),
        successQpsP75?: float(name='SuccessQpsP75'),
        threadP75?: float(name='ThreadP75'),
        successQpsStd?: float(name='SuccessQpsStd'),
        exceptionMin?: float(name='ExceptionMin'),
        passedQpsP75?: float(name='PassedQpsP75'),
        passedQps?: float(name='PassedQps'),
        threadMax?: float(name='ThreadMax'),
        successQpsP99?: float(name='SuccessQpsP99'),
        successQpsMin?: float(name='SuccessQpsMin'),
        threadP99?: float(name='ThreadP99'),
        exceptionStd?: float(name='ExceptionStd'),
        blockedQpsP95?: float(name='BlockedQpsP95'),
        thread?: float(name='Thread'),
        threadMin?: float(name='ThreadMin'),
        rtMin?: float(name='RtMin'),
        blockedQpsAvg?: float(name='BlockedQpsAvg'),
        threadAvg?: float(name='ThreadAvg'),
        blockedQpsP75?: float(name='BlockedQpsP75'),
        rtP75?: float(name='RtP75'),
        exceptionP99?: float(name='ExceptionP99'),
        exceptionP75?: float(name='ExceptionP75'),
        successQpsP95?: float(name='SuccessQpsP95'),
        rt?: float(name='Rt'),
        passedQpsP95?: float(name='PassedQpsP95'),
        rtMax?: float(name='RtMax'),
        blockedQpsStd?: float(name='BlockedQpsStd'),
        blockedQpsMax?: float(name='BlockedQpsMax'),
        exception?: float(name='Exception'),
        exceptionAvg?: float(name='ExceptionAvg'),
        passedQpsStd?: float(name='PassedQpsStd'),
      }
    ](name='InnerMetrics'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model GetMetricsOfResourceResponse = {
  headers: map[string]string(name='headers'),
  body: GetMetricsOfResourceResponseBody(name='body'),
}

async function getMetricsOfResourceWithOptions(request: GetMetricsOfResourceRequest, runtime: Util.RuntimeOptions): GetMetricsOfResourceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetMetricsOfResource', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getMetricsOfResource(request: GetMetricsOfResourceRequest): GetMetricsOfResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetricsOfResourceWithOptions(request, runtime);
}

model GetSentinelAppSumMetricRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  namespace?: string(name='Namespace'),
  appName?: string(name='AppName'),
  startTime?: string(name='StartTime'),
  endTime?: string(name='EndTime'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model GetSentinelAppSumMetricResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
  metricData?: {
    appName?: string(name='AppName'),
    passCount?: float(name='PassCount'),
    machineCount?: long(name='MachineCount'),
    avgRt?: float(name='AvgRt'),
    userId?: string(name='UserId'),
    namespace?: string(name='Namespace'),
    totalCount?: float(name='TotalCount'),
    blockCount?: float(name='BlockCount'),
  }(name='MetricData'),
}

model GetSentinelAppSumMetricResponse = {
  headers: map[string]string(name='headers'),
  body: GetSentinelAppSumMetricResponseBody(name='body'),
}

async function getSentinelAppSumMetricWithOptions(request: GetSentinelAppSumMetricRequest, runtime: Util.RuntimeOptions): GetSentinelAppSumMetricResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetSentinelAppSumMetric', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getSentinelAppSumMetric(request: GetSentinelAppSumMetricRequest): GetSentinelAppSumMetricResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSentinelAppSumMetricWithOptions(request, runtime);
}

model GetUserApplicationsRequest {
  namespace?: string(name='Namespace'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model GetUserApplicationsResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  appNameAndIdPairs?: [ 
    {
      appName?: string(name='AppName'),
      appId?: string(name='AppId'),
      scopeType?: int32(name='ScopeType'),
      appType?: int32(name='AppType'),
    }
  ](name='AppNameAndIdPairs'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model GetUserApplicationsResponse = {
  headers: map[string]string(name='headers'),
  body: GetUserApplicationsResponseBody(name='body'),
}

async function getUserApplicationsWithOptions(request: GetUserApplicationsRequest, runtime: Util.RuntimeOptions): GetUserApplicationsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetUserApplications', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getUserApplications(request: GetUserApplicationsRequest): GetUserApplicationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getUserApplicationsWithOptions(request, runtime);
}

model ImportExperimentFromMkRequest {
  definition?: string(name='Definition'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  nameSpace?: string(name='NameSpace'),
  importUserId?: string(name='ImportUserId'),
  tags?: [ string ](name='Tags'),
}

model ImportExperimentFromMkResponseBody = {
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  experimentId?: string(name='ExperimentId'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model ImportExperimentFromMkResponse = {
  headers: map[string]string(name='headers'),
  body: ImportExperimentFromMkResponseBody(name='body'),
}

async function importExperimentFromMkWithOptions(request: ImportExperimentFromMkRequest, runtime: Util.RuntimeOptions): ImportExperimentFromMkResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ImportExperimentFromMk', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function importExperimentFromMk(request: ImportExperimentFromMkRequest): ImportExperimentFromMkResponse {
  var runtime = new Util.RuntimeOptions{};
  return importExperimentFromMkWithOptions(request, runtime);
}

model ListActiveAppsRequest {
  namespace?: string(name='Namespace'),
  appType?: int32(name='AppType'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model ListActiveAppsResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: [ 
    {
      appName?: string(name='AppName'),
      lastHealthPingTime?: long(name='LastHealthPingTime'),
      currentLevel?: int32(name='CurrentLevel'),
      namespace?: string(name='Namespace'),
      appType?: int32(name='AppType'),
      dirtyLevel?: int32(name='DirtyLevel'),
      ahasAppName?: string(name='AhasAppName'),
    }
  ](name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model ListActiveAppsResponse = {
  headers: map[string]string(name='headers'),
  body: ListActiveAppsResponseBody(name='body'),
}

async function listActiveAppsWithOptions(request: ListActiveAppsRequest, runtime: Util.RuntimeOptions): ListActiveAppsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListActiveApps', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listActiveApps(request: ListActiveAppsRequest): ListActiveAppsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listActiveAppsWithOptions(request, runtime);
}

model ListDegradeRulesOfAppRequest {
  namespace?: string(name='Namespace'),
  appName?: string(name='AppName'),
  pageIndex?: int32(name='PageIndex'),
  pageSize?: int32(name='PageSize'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model ListDegradeRulesOfAppResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    pageIndex?: int32(name='PageIndex'),
    datas?: [ 
      {
        slowRtMs?: int32(name='SlowRtMs'),
        halfOpenRecoveryStepNum?: int32(name='HalfOpenRecoveryStepNum'),
        namespace?: string(name='Namespace'),
        statDurationMs?: int32(name='StatDurationMs'),
        ruleId?: long(name='RuleId'),
        strategy?: int32(name='Strategy'),
        resource?: string(name='Resource'),
        appName?: string(name='AppName'),
        halfOpenBaseAmountPerStep?: int32(name='HalfOpenBaseAmountPerStep'),
        recoveryTimeoutMs?: int32(name='RecoveryTimeoutMs'),
        minRequestAmount?: int32(name='MinRequestAmount'),
        threshold?: float(name='Threshold'),
        enable?: boolean(name='Enable'),
      }
    ](name='Datas'),
    totalPage?: int32(name='TotalPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model ListDegradeRulesOfAppResponse = {
  headers: map[string]string(name='headers'),
  body: ListDegradeRulesOfAppResponseBody(name='body'),
}

async function listDegradeRulesOfAppWithOptions(request: ListDegradeRulesOfAppRequest, runtime: Util.RuntimeOptions): ListDegradeRulesOfAppResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListDegradeRulesOfApp', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listDegradeRulesOfApp(request: ListDegradeRulesOfAppRequest): ListDegradeRulesOfAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDegradeRulesOfAppWithOptions(request, runtime);
}

model ListDegradeRulesOfResourceRequest {
  namespace?: string(name='Namespace'),
  appName?: string(name='AppName'),
  resource?: string(name='Resource'),
  pageIndex?: int32(name='PageIndex'),
  pageSize?: int32(name='PageSize'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model ListDegradeRulesOfResourceResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    pageIndex?: int32(name='PageIndex'),
    datas?: [ 
      {
        slowRtMs?: int32(name='SlowRtMs'),
        halfOpenRecoveryStepNum?: int32(name='HalfOpenRecoveryStepNum'),
        namespace?: string(name='Namespace'),
        statDurationMs?: int32(name='StatDurationMs'),
        ruleId?: long(name='RuleId'),
        strategy?: int32(name='Strategy'),
        resource?: string(name='Resource'),
        appName?: string(name='AppName'),
        halfOpenBaseAmountPerStep?: int32(name='HalfOpenBaseAmountPerStep'),
        recoveryTimeoutMs?: int32(name='RecoveryTimeoutMs'),
        minRequestAmount?: int32(name='MinRequestAmount'),
        threshold?: float(name='Threshold'),
        enable?: boolean(name='Enable'),
      }
    ](name='Datas'),
    totalPage?: int32(name='TotalPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model ListDegradeRulesOfResourceResponse = {
  headers: map[string]string(name='headers'),
  body: ListDegradeRulesOfResourceResponseBody(name='body'),
}

async function listDegradeRulesOfResourceWithOptions(request: ListDegradeRulesOfResourceRequest, runtime: Util.RuntimeOptions): ListDegradeRulesOfResourceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListDegradeRulesOfResource', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listDegradeRulesOfResource(request: ListDegradeRulesOfResourceRequest): ListDegradeRulesOfResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDegradeRulesOfResourceWithOptions(request, runtime);
}

model ListExperimentMetasRequest {
  page?: int32(name='Page'),
  nameSpace?: string(name='NameSpace'),
  size?: int32(name='Size'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model ListExperimentMetasResponseBody = {
  pages?: int32(name='Pages'),
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  pageSize?: int32(name='PageSize'),
  currentPage?: int32(name='CurrentPage'),
  content?: [ 
    {
      state?: string(name='State'),
      createTime?: long(name='CreateTime'),
      experimentId?: string(name='ExperimentId'),
      tags?: [ string ](name='Tags'),
      name?: string(name='Name'),
    }
  ](name='Content'),
  total?: int32(name='Total'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model ListExperimentMetasResponse = {
  headers: map[string]string(name='headers'),
  body: ListExperimentMetasResponseBody(name='body'),
}

async function listExperimentMetasWithOptions(request: ListExperimentMetasRequest, runtime: Util.RuntimeOptions): ListExperimentMetasResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListExperimentMetas', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listExperimentMetas(request: ListExperimentMetasRequest): ListExperimentMetasResponse {
  var runtime = new Util.RuntimeOptions{};
  return listExperimentMetasWithOptions(request, runtime);
}

model ListFlowRulesOfAppRequest {
  namespace?: string(name='Namespace'),
  appName?: string(name='AppName'),
  pageIndex?: int32(name='PageIndex'),
  pageSize?: int32(name='PageSize'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model ListFlowRulesOfAppResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    pageIndex?: int32(name='PageIndex'),
    datas?: [ 
      {
        refResource?: string(name='RefResource'),
        clusterFallbackThreshold?: int32(name='ClusterFallbackThreshold'),
        namespace?: string(name='Namespace'),
        limitOrigin?: string(name='LimitOrigin'),
        statDurationMs?: int32(name='StatDurationMs'),
        clusterThresholdType?: int32(name='ClusterThresholdType'),
        ruleId?: long(name='RuleId'),
        relationStrategy?: int32(name='RelationStrategy'),
        appName?: string(name='AppName'),
        resource?: string(name='Resource'),
        clusterEstimatedMaxQps?: float(name='ClusterEstimatedMaxQps'),
        controlBehavior?: int32(name='ControlBehavior'),
        maxQueueingTimeMs?: int32(name='MaxQueueingTimeMs'),
        clusterFallbackStrategy?: int32(name='ClusterFallbackStrategy'),
        warmUpPeriodSec?: int32(name='WarmUpPeriodSec'),
        clusterMode?: boolean(name='ClusterMode'),
        threshold?: float(name='Threshold'),
        enable?: boolean(name='Enable'),
      }
    ](name='Datas'),
    totalPage?: int32(name='TotalPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model ListFlowRulesOfAppResponse = {
  headers: map[string]string(name='headers'),
  body: ListFlowRulesOfAppResponseBody(name='body'),
}

async function listFlowRulesOfAppWithOptions(request: ListFlowRulesOfAppRequest, runtime: Util.RuntimeOptions): ListFlowRulesOfAppResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListFlowRulesOfApp', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listFlowRulesOfApp(request: ListFlowRulesOfAppRequest): ListFlowRulesOfAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFlowRulesOfAppWithOptions(request, runtime);
}

model ListFlowRulesOfResourceRequest {
  namespace?: string(name='Namespace'),
  appName?: string(name='AppName'),
  resource?: string(name='Resource'),
  pageIndex?: int32(name='PageIndex'),
  pageSize?: int32(name='PageSize'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model ListFlowRulesOfResourceResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    pageIndex?: int32(name='PageIndex'),
    datas?: [ 
      {
        refResource?: string(name='RefResource'),
        clusterFallbackThreshold?: int32(name='ClusterFallbackThreshold'),
        namespace?: string(name='Namespace'),
        limitOrigin?: string(name='LimitOrigin'),
        statDurationMs?: int32(name='StatDurationMs'),
        clusterThresholdType?: int32(name='ClusterThresholdType'),
        ruleId?: long(name='RuleId'),
        relationStrategy?: int32(name='RelationStrategy'),
        appName?: string(name='AppName'),
        resource?: string(name='Resource'),
        clusterEstimatedMaxQps?: float(name='ClusterEstimatedMaxQps'),
        controlBehavior?: int32(name='ControlBehavior'),
        maxQueueingTimeMs?: int32(name='MaxQueueingTimeMs'),
        clusterFallbackStrategy?: int32(name='ClusterFallbackStrategy'),
        warmUpPeriodSec?: int32(name='WarmUpPeriodSec'),
        clusterMode?: boolean(name='ClusterMode'),
        threshold?: float(name='Threshold'),
        enable?: boolean(name='Enable'),
      }
    ](name='Datas'),
    totalPage?: int32(name='TotalPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model ListFlowRulesOfResourceResponse = {
  headers: map[string]string(name='headers'),
  body: ListFlowRulesOfResourceResponseBody(name='body'),
}

async function listFlowRulesOfResourceWithOptions(request: ListFlowRulesOfResourceRequest, runtime: Util.RuntimeOptions): ListFlowRulesOfResourceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListFlowRulesOfResource', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listFlowRulesOfResource(request: ListFlowRulesOfResourceRequest): ListFlowRulesOfResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFlowRulesOfResourceWithOptions(request, runtime);
}

model ListHotParamRulesOfAppRequest {
  namespace?: string(name='Namespace'),
  appName?: string(name='AppName'),
  pageIndex?: int32(name='PageIndex'),
  pageSize?: int32(name='PageSize'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model ListHotParamRulesOfAppResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    pageIndex?: int32(name='PageIndex'),
    datas?: [ 
      {
        paramIdx?: int32(name='ParamIdx'),
        namespace?: string(name='Namespace'),
        paramFlowItemList?: [ 
          {
            itemValue?: string(name='ItemValue'),
            itemType?: string(name='ItemType'),
            threshold?: float(name='Threshold'),
          }
        ](name='ParamFlowItemList'),
        statDurationSec?: long(name='StatDurationSec'),
        burstCount?: int32(name='BurstCount'),
        ruleId?: long(name='RuleId'),
        resource?: string(name='Resource'),
        appName?: string(name='AppName'),
        maxQueueingTimeMs?: int32(name='MaxQueueingTimeMs'),
        controlBehavior?: int32(name='ControlBehavior'),
        metricType?: int32(name='MetricType'),
        threshold?: float(name='Threshold'),
        enable?: boolean(name='Enable'),
      }
    ](name='Datas'),
    totalPage?: int32(name='TotalPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model ListHotParamRulesOfAppResponse = {
  headers: map[string]string(name='headers'),
  body: ListHotParamRulesOfAppResponseBody(name='body'),
}

async function listHotParamRulesOfAppWithOptions(request: ListHotParamRulesOfAppRequest, runtime: Util.RuntimeOptions): ListHotParamRulesOfAppResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListHotParamRulesOfApp', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listHotParamRulesOfApp(request: ListHotParamRulesOfAppRequest): ListHotParamRulesOfAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return listHotParamRulesOfAppWithOptions(request, runtime);
}

model ListHotParamRulesOfResourceRequest {
  namespace?: string(name='Namespace'),
  appName?: string(name='AppName'),
  resource?: string(name='Resource'),
  pageIndex?: int32(name='PageIndex'),
  pageSize?: int32(name='PageSize'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model ListHotParamRulesOfResourceResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    pageIndex?: int32(name='PageIndex'),
    datas?: [ 
      {
        paramIdx?: int32(name='ParamIdx'),
        namespace?: string(name='Namespace'),
        paramFlowItemList?: [ 
          {
            itemValue?: string(name='ItemValue'),
            itemType?: string(name='ItemType'),
            threshold?: float(name='Threshold'),
          }
        ](name='ParamFlowItemList'),
        statDurationSec?: long(name='StatDurationSec'),
        burstCount?: int32(name='BurstCount'),
        ruleId?: long(name='RuleId'),
        resource?: string(name='Resource'),
        appName?: string(name='AppName'),
        maxQueueingTimeMs?: int32(name='MaxQueueingTimeMs'),
        controlBehavior?: int32(name='ControlBehavior'),
        metricType?: int32(name='MetricType'),
        threshold?: float(name='Threshold'),
        enable?: boolean(name='Enable'),
      }
    ](name='Datas'),
    totalPage?: int32(name='TotalPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model ListHotParamRulesOfResourceResponse = {
  headers: map[string]string(name='headers'),
  body: ListHotParamRulesOfResourceResponseBody(name='body'),
}

async function listHotParamRulesOfResourceWithOptions(request: ListHotParamRulesOfResourceRequest, runtime: Util.RuntimeOptions): ListHotParamRulesOfResourceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListHotParamRulesOfResource', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listHotParamRulesOfResource(request: ListHotParamRulesOfResourceRequest): ListHotParamRulesOfResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return listHotParamRulesOfResourceWithOptions(request, runtime);
}

model ListIsolationRulesOfAppRequest {
  namespace?: string(name='Namespace'),
  appName?: string(name='AppName'),
  pageIndex?: int32(name='PageIndex'),
  pageSize?: int32(name='PageSize'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model ListIsolationRulesOfAppResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    pageIndex?: int32(name='PageIndex'),
    datas?: [ 
      {
        relationStrategy?: int32(name='RelationStrategy'),
        resource?: string(name='Resource'),
        appName?: string(name='AppName'),
        refResource?: string(name='RefResource'),
        namespace?: string(name='Namespace'),
        limitOrigin?: string(name='LimitOrigin'),
        threshold?: float(name='Threshold'),
        ruleId?: long(name='RuleId'),
        enable?: boolean(name='Enable'),
      }
    ](name='Datas'),
    totalPage?: int32(name='TotalPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model ListIsolationRulesOfAppResponse = {
  headers: map[string]string(name='headers'),
  body: ListIsolationRulesOfAppResponseBody(name='body'),
}

async function listIsolationRulesOfAppWithOptions(request: ListIsolationRulesOfAppRequest, runtime: Util.RuntimeOptions): ListIsolationRulesOfAppResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListIsolationRulesOfApp', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listIsolationRulesOfApp(request: ListIsolationRulesOfAppRequest): ListIsolationRulesOfAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return listIsolationRulesOfAppWithOptions(request, runtime);
}

model ListIsolationRulesOfResourceRequest {
  namespace?: string(name='Namespace'),
  appName?: string(name='AppName'),
  resource?: string(name='Resource'),
  pageIndex?: int32(name='PageIndex'),
  pageSize?: int32(name='PageSize'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model ListIsolationRulesOfResourceResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    pageIndex?: int32(name='PageIndex'),
    datas?: [ 
      {
        relationStrategy?: int32(name='RelationStrategy'),
        resource?: string(name='Resource'),
        appName?: string(name='AppName'),
        refResource?: string(name='RefResource'),
        namespace?: string(name='Namespace'),
        limitOrigin?: string(name='LimitOrigin'),
        threshold?: float(name='Threshold'),
        ruleId?: long(name='RuleId'),
        enable?: boolean(name='Enable'),
      }
    ](name='Datas'),
    totalPage?: int32(name='TotalPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model ListIsolationRulesOfResourceResponse = {
  headers: map[string]string(name='headers'),
  body: ListIsolationRulesOfResourceResponseBody(name='body'),
}

async function listIsolationRulesOfResourceWithOptions(request: ListIsolationRulesOfResourceRequest, runtime: Util.RuntimeOptions): ListIsolationRulesOfResourceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListIsolationRulesOfResource', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listIsolationRulesOfResource(request: ListIsolationRulesOfResourceRequest): ListIsolationRulesOfResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return listIsolationRulesOfResourceWithOptions(request, runtime);
}

model ListSystemRulesRequest {
  namespace?: string(name='Namespace'),
  appName?: string(name='AppName'),
  pageIndex?: int32(name='PageIndex'),
  pageSize?: int32(name='PageSize'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model ListSystemRulesResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    pageIndex?: int32(name='PageIndex'),
    datas?: [ 
      {
        appName?: string(name='AppName'),
        namespace?: string(name='Namespace'),
        metricType?: int32(name='MetricType'),
        threshold?: float(name='Threshold'),
        enable?: boolean(name='Enable'),
        ruleId?: long(name='RuleId'),
      }
    ](name='Datas'),
    totalPage?: int32(name='TotalPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model ListSystemRulesResponse = {
  headers: map[string]string(name='headers'),
  body: ListSystemRulesResponseBody(name='body'),
}

async function listSystemRulesWithOptions(request: ListSystemRulesRequest, runtime: Util.RuntimeOptions): ListSystemRulesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListSystemRules', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listSystemRules(request: ListSystemRulesRequest): ListSystemRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSystemRulesWithOptions(request, runtime);
}

model ModifyDegradeRuleRequest {
  strategy?: int32(name='Strategy'),
  threshold?: float(name='Threshold'),
  ruleId?: long(name='RuleId'),
  recoveryTimeoutMs?: int32(name='RecoveryTimeoutMs'),
  statDurationMs?: int32(name='StatDurationMs'),
  slowRtMs?: int32(name='SlowRtMs'),
  minRequestAmount?: int32(name='MinRequestAmount'),
  halfOpenBaseAmountPerStep?: int32(name='HalfOpenBaseAmountPerStep'),
  halfOpenRecoveryStepNum?: int32(name='HalfOpenRecoveryStepNum'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model ModifyDegradeRuleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    slowRtMs?: int32(name='SlowRtMs'),
    halfOpenRecoveryStepNum?: int32(name='HalfOpenRecoveryStepNum'),
    namespace?: string(name='Namespace'),
    statDurationMs?: int32(name='StatDurationMs'),
    ruleId?: long(name='RuleId'),
    strategy?: int32(name='Strategy'),
    resource?: string(name='Resource'),
    appName?: string(name='AppName'),
    halfOpenBaseAmountPerStep?: int32(name='HalfOpenBaseAmountPerStep'),
    recoveryTimeoutMs?: int32(name='RecoveryTimeoutMs'),
    minRequestAmount?: int32(name='MinRequestAmount'),
    threshold?: float(name='Threshold'),
    enable?: boolean(name='Enable'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model ModifyDegradeRuleResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDegradeRuleResponseBody(name='body'),
}

async function modifyDegradeRuleWithOptions(request: ModifyDegradeRuleRequest, runtime: Util.RuntimeOptions): ModifyDegradeRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyDegradeRule', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyDegradeRule(request: ModifyDegradeRuleRequest): ModifyDegradeRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDegradeRuleWithOptions(request, runtime);
}

model ModifyFlowRuleRequest {
  namespace?: string(name='Namespace'),
  ruleId?: long(name='RuleId'),
  relationStrategy?: int32(name='RelationStrategy'),
  threshold?: float(name='Threshold'),
  limitOrigin?: string(name='LimitOrigin'),
  refResource?: string(name='RefResource'),
  controlBehavior?: string(name='ControlBehavior'),
  warmUpPeriodSec?: int32(name='WarmUpPeriodSec'),
  maxQueueingTimeMs?: int32(name='MaxQueueingTimeMs'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model ModifyFlowRuleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    refResource?: string(name='RefResource'),
    clusterFallbackThreshold?: int32(name='ClusterFallbackThreshold'),
    namespace?: string(name='Namespace'),
    limitOrigin?: string(name='LimitOrigin'),
    statDurationMs?: int32(name='StatDurationMs'),
    clusterThresholdType?: int32(name='ClusterThresholdType'),
    ruleId?: long(name='RuleId'),
    relationStrategy?: int32(name='RelationStrategy'),
    appName?: string(name='AppName'),
    resource?: string(name='Resource'),
    maxQueueingTimeMs?: int32(name='MaxQueueingTimeMs'),
    clusterEstimatedMaxQps?: float(name='ClusterEstimatedMaxQps'),
    controlBehavior?: int32(name='ControlBehavior'),
    warmUpPeriodSec?: int32(name='WarmUpPeriodSec'),
    clusterFallbackStrategy?: int32(name='ClusterFallbackStrategy'),
    threshold?: float(name='Threshold'),
    clusterMode?: boolean(name='ClusterMode'),
    enable?: boolean(name='Enable'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model ModifyFlowRuleResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyFlowRuleResponseBody(name='body'),
}

async function modifyFlowRuleWithOptions(request: ModifyFlowRuleRequest, runtime: Util.RuntimeOptions): ModifyFlowRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyFlowRule', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyFlowRule(request: ModifyFlowRuleRequest): ModifyFlowRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyFlowRuleWithOptions(request, runtime);
}

model ModifyHotParamRuleRequest {
  metricType?: int32(name='MetricType'),
  threshold?: float(name='Threshold'),
  enable?: boolean(name='Enable'),
  ruleId?: long(name='RuleId'),
  paramIdx?: int32(name='ParamIdx'),
  statDurationSec?: long(name='StatDurationSec'),
  controlBehavior?: int32(name='ControlBehavior'),
  burstCount?: int32(name='BurstCount'),
  maxQueueingTimeMs?: int32(name='MaxQueueingTimeMs'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model ModifyHotParamRuleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    paramIdx?: int32(name='ParamIdx'),
    namespace?: string(name='Namespace'),
    paramFlowItemList?: [ 
      {
        itemValue?: string(name='ItemValue'),
        itemType?: string(name='ItemType'),
        threshold?: float(name='Threshold'),
      }
    ](name='ParamFlowItemList'),
    statDurationSec?: long(name='StatDurationSec'),
    burstCount?: int32(name='BurstCount'),
    ruleId?: long(name='RuleId'),
    resource?: string(name='Resource'),
    appName?: string(name='AppName'),
    maxQueueingTimeMs?: int32(name='MaxQueueingTimeMs'),
    controlBehavior?: int32(name='ControlBehavior'),
    metricType?: int32(name='MetricType'),
    threshold?: float(name='Threshold'),
    enable?: boolean(name='Enable'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model ModifyHotParamRuleResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyHotParamRuleResponseBody(name='body'),
}

async function modifyHotParamRuleWithOptions(request: ModifyHotParamRuleRequest, runtime: Util.RuntimeOptions): ModifyHotParamRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyHotParamRule', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyHotParamRule(request: ModifyHotParamRuleRequest): ModifyHotParamRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyHotParamRuleWithOptions(request, runtime);
}

model ModifyIsolationRuleRequest {
  ruleId?: long(name='RuleId'),
  relationStrategy?: int32(name='RelationStrategy'),
  threshold?: float(name='Threshold'),
  limitOrigin?: string(name='LimitOrigin'),
  refResource?: string(name='RefResource'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model ModifyIsolationRuleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    relationStrategy?: int32(name='RelationStrategy'),
    resource?: string(name='Resource'),
    appName?: string(name='AppName'),
    refResource?: string(name='RefResource'),
    namespace?: string(name='Namespace'),
    limitOrigin?: string(name='LimitOrigin'),
    threshold?: float(name='Threshold'),
    ruleId?: long(name='RuleId'),
    enable?: boolean(name='Enable'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model ModifyIsolationRuleResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyIsolationRuleResponseBody(name='body'),
}

async function modifyIsolationRuleWithOptions(request: ModifyIsolationRuleRequest, runtime: Util.RuntimeOptions): ModifyIsolationRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyIsolationRule', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyIsolationRule(request: ModifyIsolationRuleRequest): ModifyIsolationRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyIsolationRuleWithOptions(request, runtime);
}

model ModifySystemRuleRequest {
  threshold?: float(name='Threshold'),
  ruleId?: long(name='RuleId'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model ModifySystemRuleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    metricType?: int32(name='MetricType'),
    threshold?: float(name='Threshold'),
    ruleId?: long(name='RuleId'),
    enable?: boolean(name='Enable'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model ModifySystemRuleResponse = {
  headers: map[string]string(name='headers'),
  body: ModifySystemRuleResponseBody(name='body'),
}

async function modifySystemRuleWithOptions(request: ModifySystemRuleRequest, runtime: Util.RuntimeOptions): ModifySystemRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifySystemRule', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifySystemRule(request: ModifySystemRuleRequest): ModifySystemRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifySystemRuleWithOptions(request, runtime);
}

model OpenAhasServiceRequest {
  ownerId?: long(name='OwnerId'),
}

model OpenAhasServiceResponseBody = {
  requestId?: string(name='RequestId'),
  orderId?: string(name='OrderId'),
}

model OpenAhasServiceResponse = {
  headers: map[string]string(name='headers'),
  body: OpenAhasServiceResponseBody(name='body'),
}

async function openAhasServiceWithOptions(request: OpenAhasServiceRequest, runtime: Util.RuntimeOptions): OpenAhasServiceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('OpenAhasService', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function openAhasService(request: OpenAhasServiceRequest): OpenAhasServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return openAhasServiceWithOptions(request, runtime);
}

model PushExperimentTaskRequest {
  experimentTaskId?: string(name='ExperimentTaskId'),
  nameSpace?: string(name='NameSpace'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model PushExperimentTaskResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model PushExperimentTaskResponse = {
  headers: map[string]string(name='headers'),
  body: PushExperimentTaskResponseBody(name='body'),
}

async function pushExperimentTaskWithOptions(request: PushExperimentTaskRequest, runtime: Util.RuntimeOptions): PushExperimentTaskResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('PushExperimentTask', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function pushExperimentTask(request: PushExperimentTaskRequest): PushExperimentTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return pushExperimentTaskWithOptions(request, runtime);
}

model QueryExperimentsByEmpIdRequest {
  empId?: string(name='EmpId'),
  namespace?: string(name='Namespace'),
}

model QueryExperimentsByEmpIdResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  content?: [ 
    {
      experimentId?: string(name='ExperimentId'),
      namespace?: string(name='Namespace'),
      name?: string(name='Name'),
      regionId?: string(name='RegionId'),
    }
  ](name='Content'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model QueryExperimentsByEmpIdResponse = {
  headers: map[string]string(name='headers'),
  body: QueryExperimentsByEmpIdResponseBody(name='body'),
}

async function queryExperimentsByEmpIdWithOptions(request: QueryExperimentsByEmpIdRequest, runtime: Util.RuntimeOptions): QueryExperimentsByEmpIdResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryExperimentsByEmpId', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryExperimentsByEmpId(request: QueryExperimentsByEmpIdRequest): QueryExperimentsByEmpIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryExperimentsByEmpIdWithOptions(request, runtime);
}

model QueryExperimentSimpleInfoForMkRequest {
  experimentId?: string(name='ExperimentId'),
  namespace?: string(name='Namespace'),
}

model QueryExperimentSimpleInfoForMkResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  check?: [ 
    {
      appCode?: string(name='AppCode'),
      name?: string(name='Name'),
    }
  ](name='Check'),
  prepare?: [ 
    {
      appCode?: string(name='AppCode'),
      name?: string(name='Name'),
    }
  ](name='Prepare'),
  basicInfo?: {
    description?: string(name='Description'),
    state?: string(name='State'),
    experimentId?: string(name='ExperimentId'),
    namespace?: string(name='Namespace'),
    tags?: [ string ](name='Tags'),
    name?: string(name='Name'),
    regionId?: string(name='RegionId'),
  }(name='BasicInfo'),
  attack?: [ 
    {
      appCode?: string(name='AppCode'),
      name?: string(name='Name'),
    }
  ](name='Attack'),
  recover?: [ 
    {
      appCode?: string(name='AppCode'),
      name?: string(name='Name'),
    }
  ](name='Recover'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model QueryExperimentSimpleInfoForMkResponse = {
  headers: map[string]string(name='headers'),
  body: QueryExperimentSimpleInfoForMkResponseBody(name='body'),
}

async function queryExperimentSimpleInfoForMkWithOptions(request: QueryExperimentSimpleInfoForMkRequest, runtime: Util.RuntimeOptions): QueryExperimentSimpleInfoForMkResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryExperimentSimpleInfoForMk', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryExperimentSimpleInfoForMk(request: QueryExperimentSimpleInfoForMkRequest): QueryExperimentSimpleInfoForMkResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryExperimentSimpleInfoForMkWithOptions(request, runtime);
}

model QueryExperimentTaskIdByExpIdRequest {
  namespace?: string(name='Namespace'),
  expId?: string(name='ExpId'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model QueryExperimentTaskIdByExpIdResponseBody = {
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  experimentTaskId?: string(name='ExperimentTaskId'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model QueryExperimentTaskIdByExpIdResponse = {
  headers: map[string]string(name='headers'),
  body: QueryExperimentTaskIdByExpIdResponseBody(name='body'),
}

async function queryExperimentTaskIdByExpIdWithOptions(request: QueryExperimentTaskIdByExpIdRequest, runtime: Util.RuntimeOptions): QueryExperimentTaskIdByExpIdResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryExperimentTaskIdByExpId', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryExperimentTaskIdByExpId(request: QueryExperimentTaskIdByExpIdRequest): QueryExperimentTaskIdByExpIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryExperimentTaskIdByExpIdWithOptions(request, runtime);
}

model SearchApplicationScopesRequest {
  namespace?: string(name='Namespace'),
  page?: int32(name='Page'),
  size?: int32(name='Size'),
  appId?: string(name='AppId'),
  appName?: string(name='AppName'),
  ip?: string(name='Ip'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model SearchApplicationScopesResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  content?: [ 
    {
      status?: int32(name='Status'),
      configurationId?: string(name='ConfigurationId'),
      privateIp?: string(name='PrivateIp'),
      deviceName?: string(name='DeviceName'),
      deviceType?: int32(name='DeviceType'),
      userId?: string(name='UserId'),
      namespace?: string(name='Namespace'),
      appName?: string(name='AppName'),
      groupName?: string(name='GroupName'),
      appId?: long(name='AppId'),
      publicIp?: string(name='PublicIp'),
      hostConfigurationId?: string(name='HostConfigurationId'),
      clusterId?: string(name='ClusterId'),
    }
  ](name='Content'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model SearchApplicationScopesResponse = {
  headers: map[string]string(name='headers'),
  body: SearchApplicationScopesResponseBody(name='body'),
}

async function searchApplicationScopesWithOptions(request: SearchApplicationScopesRequest, runtime: Util.RuntimeOptions): SearchApplicationScopesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SearchApplicationScopes', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function searchApplicationScopes(request: SearchApplicationScopesRequest): SearchApplicationScopesResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchApplicationScopesWithOptions(request, runtime);
}

model SearchUserApplicationsRequest {
  namespace?: string(name='Namespace'),
  page?: int32(name='Page'),
  size?: int32(name='Size'),
  ahasRegionId?: string(name='AhasRegionId'),
}

model SearchUserApplicationsResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  content?: [ 
    {
      appName?: string(name='AppName'),
      appId?: string(name='AppId'),
      appType?: int32(name='AppType'),
    }
  ](name='Content'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model SearchUserApplicationsResponse = {
  headers: map[string]string(name='headers'),
  body: SearchUserApplicationsResponseBody(name='body'),
}

async function searchUserApplicationsWithOptions(request: SearchUserApplicationsRequest, runtime: Util.RuntimeOptions): SearchUserApplicationsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SearchUserApplications', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function searchUserApplications(request: SearchUserApplicationsRequest): SearchUserApplicationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchUserApplicationsWithOptions(request, runtime);
}

model UpdateExperimentRequest {
  definition?: string(name='Definition'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  nameSpace?: string(name='NameSpace'),
  experimentId?: string(name='ExperimentId'),
  ahasRegionId?: string(name='AhasRegionId'),
  tags?: [ string ](name='Tags'),
}

model UpdateExperimentResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model UpdateExperimentResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateExperimentResponseBody(name='body'),
}

async function updateExperimentWithOptions(request: UpdateExperimentRequest, runtime: Util.RuntimeOptions): UpdateExperimentResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateExperiment', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateExperiment(request: UpdateExperimentRequest): UpdateExperimentResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateExperimentWithOptions(request, runtime);
}

model UpdateExperimentBasicInfoRequest {
  experimentId?: string(name='ExperimentId'),
  nameSpace?: string(name='NameSpace'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  ahasRegionId?: string(name='AhasRegionId'),
  tags?: [ string ](name='Tags'),
}

model UpdateExperimentBasicInfoResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model UpdateExperimentBasicInfoResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateExperimentBasicInfoResponseBody(name='body'),
}

async function updateExperimentBasicInfoWithOptions(request: UpdateExperimentBasicInfoRequest, runtime: Util.RuntimeOptions): UpdateExperimentBasicInfoResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateExperimentBasicInfo', '2019-09-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateExperimentBasicInfo(request: UpdateExperimentBasicInfoRequest): UpdateExperimentBasicInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateExperimentBasicInfoWithOptions(request, runtime);
}

