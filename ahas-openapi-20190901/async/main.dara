/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'ahas-openapi';
  @version = '2019-09-01';
  @endpointRule = 'regional';
  @endpointMap = {
    cn-beijing = 'ahas.cn-beijing.aliyuncs.com',
    cn-zhangjiakou = 'ahas.cn-zhangjiakou.aliyuncs.com',
    cn-hangzhou = 'ahas.cn-hangzhou.aliyuncs.com',
    cn-shanghai = 'ahas.cn-shanghai.aliyuncs.com',
    cn-shenzhen = 'ahas.cn-shenzhen.aliyuncs.com',
    ap-southeast-1 = 'ahas.ap-southeast-1.aliyuncs.com',
    cn-hongkong = 'ahas.cn-hongkong.aliyuncs.com',
    eu-central-1 = 'ahas.eu-central-1.aliyuncs.com',
  };
}

function close(): void {
  @handler.close();
}

model CheckExperimentRunnableRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  experimentId: string(name='ExperimentId', position='Query'),
  nameSpace?: string(name='NameSpace', position='Query'),
}

model CheckExperimentRunnableResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CheckExperimentRunnableResponse = {
  headers: map[string]string(name='headers'),
  body: CheckExperimentRunnableResponseBody(name='body'),
}

async function checkExperimentRunnable(request: CheckExperimentRunnableRequest): CheckExperimentRunnableResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CheckExperimentRunnable', 'POST', '/', 'json', false, 'json', request);
}

model CreateDegradeRuleRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  appName: string(name='AppName', position='Query'),
  enable?: boolean(name='Enable', position='Query'),
  halfOpenBaseAmountPerStep?: int32(name='HalfOpenBaseAmountPerStep', position='Query'),
  halfOpenRecoveryStepNum?: int32(name='HalfOpenRecoveryStepNum', position='Query'),
  minRequestAmount?: int32(name='MinRequestAmount', position='Query'),
  namespace: string(name='Namespace', position='Query'),
  recoveryTimeoutMs: int32(name='RecoveryTimeoutMs', position='Query'),
  resource: string(name='Resource', position='Query'),
  slowRtMs?: int32(name='SlowRtMs', position='Query'),
  statDurationMs?: int32(name='StatDurationMs', position='Query'),
  strategy: int32(name='Strategy', position='Query'),
  threshold: float(name='Threshold', position='Query'),
}

model CreateDegradeRuleResponseBody = {
  code?: string(name='Code'),
  data?: {
    appName?: string(name='AppName'),
    enable?: boolean(name='Enable'),
    halfOpenBaseAmountPerStep?: int32(name='HalfOpenBaseAmountPerStep'),
    halfOpenRecoveryStepNum?: int32(name='HalfOpenRecoveryStepNum'),
    minRequestAmount?: int32(name='MinRequestAmount'),
    namespace?: string(name='Namespace'),
    recoveryTimeoutMs?: int32(name='RecoveryTimeoutMs'),
    resource?: string(name='Resource'),
    ruleId?: long(name='RuleId'),
    slowRtMs?: int32(name='SlowRtMs'),
    statDurationMs?: int32(name='StatDurationMs'),
    strategy?: int32(name='Strategy'),
    threshold?: float(name='Threshold'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateDegradeRuleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDegradeRuleResponseBody(name='body'),
}

async function createDegradeRule(request: CreateDegradeRuleRequest): CreateDegradeRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDegradeRule', 'POST', '/', 'json', false, 'json', request);
}

model CreateExperimentRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  definition: string(name='Definition', position='Query'),
  description?: string(name='Description', position='Query'),
  name: string(name='Name', position='Query'),
  nameSpace: string(name='NameSpace', position='Query'),
  tags?: [ string ](name='Tags', position='Query'),
}

model CreateExperimentResponseBody = {
  code?: string(name='Code'),
  experimentId?: string(name='ExperimentId'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateExperimentResponse = {
  headers: map[string]string(name='headers'),
  body: CreateExperimentResponseBody(name='body'),
}

async function createExperiment(request: CreateExperimentRequest): CreateExperimentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateExperiment', 'POST', '/', 'json', false, 'json', request);
}

model CreateFlowRuleRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  appName: string(name='AppName', position='Query'),
  controlBehavior: int32(name='ControlBehavior', position='Query'),
  enable?: boolean(name='Enable', position='Query'),
  limitOrigin?: string(name='LimitOrigin', position='Query'),
  maxQueueingTimeMs?: int32(name='MaxQueueingTimeMs', position='Query'),
  namespace: string(name='Namespace', position='Query'),
  refResource?: string(name='RefResource', position='Query'),
  relationStrategy: int32(name='RelationStrategy', position='Query'),
  resource: string(name='Resource', position='Query'),
  threshold: float(name='Threshold', position='Query'),
  warmUpPeriodSec?: int32(name='WarmUpPeriodSec', position='Query'),
}

model CreateFlowRuleResponseBody = {
  code?: string(name='Code'),
  data?: {
    appName?: string(name='AppName'),
    clusterEstimatedMaxQps?: float(name='ClusterEstimatedMaxQps'),
    clusterFallbackStrategy?: int32(name='ClusterFallbackStrategy'),
    clusterFallbackThreshold?: int32(name='ClusterFallbackThreshold'),
    clusterMode?: boolean(name='ClusterMode'),
    clusterThresholdType?: int32(name='ClusterThresholdType'),
    controlBehavior?: int32(name='ControlBehavior'),
    enable?: boolean(name='Enable'),
    limitOrigin?: string(name='LimitOrigin'),
    maxQueueingTimeMs?: int32(name='MaxQueueingTimeMs'),
    namespace?: string(name='Namespace'),
    refResource?: string(name='RefResource'),
    relationStrategy?: int32(name='RelationStrategy'),
    resource?: string(name='Resource'),
    ruleId?: long(name='RuleId'),
    statDurationMs?: int32(name='StatDurationMs'),
    threshold?: float(name='Threshold'),
    warmUpPeriodSec?: int32(name='WarmUpPeriodSec'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateFlowRuleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFlowRuleResponseBody(name='body'),
}

async function createFlowRule(request: CreateFlowRuleRequest): CreateFlowRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateFlowRule', 'POST', '/', 'json', false, 'json', request);
}

model CreateHotParamItemsRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  items: string(name='Items', position='Query'),
  ruleId: long(name='RuleId', position='Query'),
}

model CreateHotParamItemsResponseBody = {
  code?: string(name='Code'),
  data?: {
    appName?: string(name='AppName'),
    burstCount?: int32(name='BurstCount'),
    controlBehavior?: int32(name='ControlBehavior'),
    enable?: boolean(name='Enable'),
    maxQueueingTimeMs?: int32(name='MaxQueueingTimeMs'),
    metricType?: int32(name='MetricType'),
    namespace?: string(name='Namespace'),
    paramFlowItemList?: [ 
      {
        itemType?: string(name='ItemType'),
        itemValue?: string(name='ItemValue'),
        threshold?: float(name='Threshold'),
      }
    ](name='ParamFlowItemList'),
    paramIdx?: int32(name='ParamIdx'),
    resource?: string(name='Resource'),
    ruleId?: long(name='RuleId'),
    statDurationSec?: long(name='StatDurationSec'),
    threshold?: float(name='Threshold'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateHotParamItemsResponse = {
  headers: map[string]string(name='headers'),
  body: CreateHotParamItemsResponseBody(name='body'),
}

async function createHotParamItems(request: CreateHotParamItemsRequest): CreateHotParamItemsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateHotParamItems', 'POST', '/', 'json', false, 'json', request);
}

model CreateHotParamRuleRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  appName: string(name='AppName', position='Query'),
  burstCount?: int32(name='BurstCount', position='Query'),
  controlBehavior: int32(name='ControlBehavior', position='Query'),
  enable?: boolean(name='Enable', position='Query'),
  maxQueueingTimeMs?: int32(name='MaxQueueingTimeMs', position='Query'),
  metricType: int32(name='MetricType', position='Query'),
  namespace: string(name='Namespace', position='Query'),
  paramIdx: int32(name='ParamIdx', position='Query'),
  resource: string(name='Resource', position='Query'),
  statDurationSec: long(name='StatDurationSec', position='Query'),
  threshold: float(name='Threshold', position='Query'),
}

model CreateHotParamRuleResponseBody = {
  code?: string(name='Code'),
  data?: {
    appName?: string(name='AppName'),
    burstCount?: int32(name='BurstCount'),
    controlBehavior?: int32(name='ControlBehavior'),
    enable?: boolean(name='Enable'),
    maxQueueingTimeMs?: int32(name='MaxQueueingTimeMs'),
    metricType?: int32(name='MetricType'),
    namespace?: string(name='Namespace'),
    paramFlowItemList?: [ 
      {
        itemType?: string(name='ItemType'),
        itemValue?: string(name='ItemValue'),
        threshold?: float(name='Threshold'),
      }
    ](name='ParamFlowItemList'),
    paramIdx?: int32(name='ParamIdx'),
    resource?: string(name='Resource'),
    ruleId?: long(name='RuleId'),
    statDurationSec?: long(name='StatDurationSec'),
    threshold?: float(name='Threshold'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateHotParamRuleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateHotParamRuleResponseBody(name='body'),
}

async function createHotParamRule(request: CreateHotParamRuleRequest): CreateHotParamRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateHotParamRule', 'POST', '/', 'json', false, 'json', request);
}

model CreateIsolationRuleRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  appName: string(name='AppName', position='Query'),
  enable?: boolean(name='Enable', position='Query'),
  limitOrigin?: string(name='LimitOrigin', position='Query'),
  namespace: string(name='Namespace', position='Query'),
  refResource?: string(name='RefResource', position='Query'),
  relationStrategy: int32(name='RelationStrategy', position='Query'),
  resource: string(name='Resource', position='Query'),
  threshold: float(name='Threshold', position='Query'),
}

model CreateIsolationRuleResponseBody = {
  code?: string(name='Code'),
  data?: {
    appName?: string(name='AppName'),
    enable?: boolean(name='Enable'),
    limitOrigin?: string(name='LimitOrigin'),
    namespace?: string(name='Namespace'),
    refResource?: string(name='RefResource'),
    relationStrategy?: int32(name='RelationStrategy'),
    resource?: string(name='Resource'),
    ruleId?: long(name='RuleId'),
    threshold?: float(name='Threshold'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateIsolationRuleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateIsolationRuleResponseBody(name='body'),
}

async function createIsolationRule(request: CreateIsolationRuleRequest): CreateIsolationRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateIsolationRule', 'POST', '/', 'json', false, 'json', request);
}

model CreateSystemRuleRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  appName: string(name='AppName', position='Query'),
  enable?: boolean(name='Enable', position='Query'),
  metricType: int32(name='MetricType', position='Query'),
  namespace: string(name='Namespace', position='Query'),
  threshold: float(name='Threshold', position='Query'),
}

model CreateSystemRuleResponseBody = {
  code?: string(name='Code'),
  data?: {
    enable?: boolean(name='Enable'),
    metricType?: int32(name='MetricType'),
    ruleId?: long(name='RuleId'),
    threshold?: float(name='Threshold'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateSystemRuleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSystemRuleResponseBody(name='body'),
}

async function createSystemRule(request: CreateSystemRuleRequest): CreateSystemRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateSystemRule', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDegradeRuleRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  ruleId: long(name='RuleId', position='Query'),
}

model DeleteDegradeRuleResponseBody = {
  code?: string(name='Code'),
  data?: {
    ruleId?: long(name='RuleId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteDegradeRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDegradeRuleResponseBody(name='body'),
}

async function deleteDegradeRule(request: DeleteDegradeRuleRequest): DeleteDegradeRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDegradeRule', 'POST', '/', 'json', false, 'json', request);
}

model DeleteFlowRuleRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  ruleId: long(name='RuleId', position='Query'),
}

model DeleteFlowRuleResponseBody = {
  code?: string(name='Code'),
  data?: {
    ruleId?: long(name='RuleId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteFlowRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFlowRuleResponseBody(name='body'),
}

async function deleteFlowRule(request: DeleteFlowRuleRequest): DeleteFlowRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteFlowRule', 'POST', '/', 'json', false, 'json', request);
}

model DeleteHotParamRuleRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  ruleId: long(name='RuleId', position='Query'),
}

model DeleteHotParamRuleResponseBody = {
  code?: string(name='Code'),
  data?: {
    ruleId?: long(name='RuleId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteHotParamRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteHotParamRuleResponseBody(name='body'),
}

async function deleteHotParamRule(request: DeleteHotParamRuleRequest): DeleteHotParamRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteHotParamRule', 'POST', '/', 'json', false, 'json', request);
}

model DeleteIsolationRuleRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  ruleId: long(name='RuleId', position='Query'),
}

model DeleteIsolationRuleResponseBody = {
  code?: string(name='Code'),
  data?: {
    ruleId?: long(name='RuleId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteIsolationRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteIsolationRuleResponseBody(name='body'),
}

async function deleteIsolationRule(request: DeleteIsolationRuleRequest): DeleteIsolationRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteIsolationRule', 'POST', '/', 'json', false, 'json', request);
}

model DeleteSystemRuleRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  ruleId: long(name='RuleId', position='Query'),
}

model DeleteSystemRuleResponseBody = {
  code?: string(name='Code'),
  data?: {
    ruleId?: long(name='RuleId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteSystemRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSystemRuleResponseBody(name='body'),
}

async function deleteSystemRule(request: DeleteSystemRuleRequest): DeleteSystemRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteSystemRule', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRegionsRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
}

model DescribeRegionsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  regions?: [ 
    {
      localName?: string(name='LocalName'),
      regionEndpoint?: string(name='RegionEndpoint'),
      regionId?: string(name='RegionId'),
    }
  ](name='Regions'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRegions', 'POST', '/', 'json', false, 'json', request);
}

model DisableDegradeRuleRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  ruleId: long(name='RuleId', position='Query'),
}

model DisableDegradeRuleResponseBody = {
  code?: string(name='Code'),
  data?: {
    appName?: string(name='AppName'),
    enable?: boolean(name='Enable'),
    halfOpenBaseAmountPerStep?: int32(name='HalfOpenBaseAmountPerStep'),
    halfOpenRecoveryStepNum?: int32(name='HalfOpenRecoveryStepNum'),
    minRequestAmount?: int32(name='MinRequestAmount'),
    namespace?: string(name='Namespace'),
    recoveryTimeoutMs?: int32(name='RecoveryTimeoutMs'),
    resource?: string(name='Resource'),
    ruleId?: long(name='RuleId'),
    slowRtMs?: int32(name='SlowRtMs'),
    statDurationMs?: int32(name='StatDurationMs'),
    strategy?: int32(name='Strategy'),
    threshold?: float(name='Threshold'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DisableDegradeRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DisableDegradeRuleResponseBody(name='body'),
}

async function disableDegradeRule(request: DisableDegradeRuleRequest): DisableDegradeRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DisableDegradeRule', 'POST', '/', 'json', false, 'json', request);
}

model DisableFlowRuleRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  ruleId: long(name='RuleId', position='Query'),
}

model DisableFlowRuleResponseBody = {
  code?: string(name='Code'),
  data?: {
    appName?: string(name='AppName'),
    clusterEstimatedMaxQps?: float(name='ClusterEstimatedMaxQps'),
    clusterFallbackStrategy?: int32(name='ClusterFallbackStrategy'),
    clusterFallbackThreshold?: int32(name='ClusterFallbackThreshold'),
    clusterMode?: boolean(name='ClusterMode'),
    clusterThresholdType?: int32(name='ClusterThresholdType'),
    controlBehavior?: int32(name='ControlBehavior'),
    enable?: boolean(name='Enable'),
    limitOrigin?: string(name='LimitOrigin'),
    maxQueueingTimeMs?: int32(name='MaxQueueingTimeMs'),
    namespace?: string(name='Namespace'),
    refResource?: string(name='RefResource'),
    relationStrategy?: int32(name='RelationStrategy'),
    resource?: string(name='Resource'),
    ruleId?: long(name='RuleId'),
    statDurationMs?: int32(name='StatDurationMs'),
    threshold?: float(name='Threshold'),
    warmUpPeriodSec?: int32(name='WarmUpPeriodSec'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DisableFlowRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DisableFlowRuleResponseBody(name='body'),
}

async function disableFlowRule(request: DisableFlowRuleRequest): DisableFlowRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DisableFlowRule', 'POST', '/', 'json', false, 'json', request);
}

model DisableHotParamRuleRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  ruleId: long(name='RuleId', position='Query'),
}

model DisableHotParamRuleResponseBody = {
  code?: string(name='Code'),
  data?: {
    appName?: string(name='AppName'),
    burstCount?: int32(name='BurstCount'),
    controlBehavior?: int32(name='ControlBehavior'),
    enable?: boolean(name='Enable'),
    maxQueueingTimeMs?: int32(name='MaxQueueingTimeMs'),
    metricType?: int32(name='MetricType'),
    namespace?: string(name='Namespace'),
    paramFlowItemList?: [ 
      {
        itemType?: string(name='ItemType'),
        itemValue?: string(name='ItemValue'),
        threshold?: float(name='Threshold'),
      }
    ](name='ParamFlowItemList'),
    paramIdx?: int32(name='ParamIdx'),
    resource?: string(name='Resource'),
    ruleId?: long(name='RuleId'),
    statDurationSec?: long(name='StatDurationSec'),
    threshold?: float(name='Threshold'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DisableHotParamRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DisableHotParamRuleResponseBody(name='body'),
}

async function disableHotParamRule(request: DisableHotParamRuleRequest): DisableHotParamRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DisableHotParamRule', 'POST', '/', 'json', false, 'json', request);
}

model DisableIsolationRuleRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  ruleId: long(name='RuleId', minimum=0, maximum=100000000000000, position='Query'),
}

model DisableIsolationRuleResponseBody = {
  code?: string(name='Code'),
  data?: {
    appName?: string(name='AppName'),
    enable?: boolean(name='Enable'),
    limitOrigin?: string(name='LimitOrigin'),
    namespace?: string(name='Namespace'),
    refResource?: string(name='RefResource'),
    relationStrategy?: int32(name='RelationStrategy'),
    resource?: string(name='Resource'),
    ruleId?: long(name='RuleId'),
    threshold?: float(name='Threshold'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DisableIsolationRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DisableIsolationRuleResponseBody(name='body'),
}

async function disableIsolationRule(request: DisableIsolationRuleRequest): DisableIsolationRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DisableIsolationRule', 'POST', '/', 'json', false, 'json', request);
}

model DisableSystemRuleRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  ruleId: long(name='RuleId', position='Query'),
}

model DisableSystemRuleResponseBody = {
  code?: string(name='Code'),
  data?: {
    enable?: boolean(name='Enable'),
    metricType?: int32(name='MetricType'),
    ruleId?: long(name='RuleId'),
    threshold?: float(name='Threshold'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DisableSystemRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DisableSystemRuleResponseBody(name='body'),
}

async function disableSystemRule(request: DisableSystemRuleRequest): DisableSystemRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DisableSystemRule', 'POST', '/', 'json', false, 'json', request);
}

model EnableDegradeRuleRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  ruleId: long(name='RuleId', position='Query'),
}

model EnableDegradeRuleResponseBody = {
  code?: string(name='Code'),
  data?: {
    appName?: string(name='AppName'),
    enable?: boolean(name='Enable'),
    halfOpenBaseAmountPerStep?: int32(name='HalfOpenBaseAmountPerStep'),
    halfOpenRecoveryStepNum?: int32(name='HalfOpenRecoveryStepNum'),
    minRequestAmount?: int32(name='MinRequestAmount'),
    namespace?: string(name='Namespace'),
    recoveryTimeoutMs?: int32(name='RecoveryTimeoutMs'),
    resource?: string(name='Resource'),
    ruleId?: long(name='RuleId'),
    slowRtMs?: int32(name='SlowRtMs'),
    statDurationMs?: int32(name='StatDurationMs'),
    strategy?: int32(name='Strategy'),
    threshold?: float(name='Threshold'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model EnableDegradeRuleResponse = {
  headers: map[string]string(name='headers'),
  body: EnableDegradeRuleResponseBody(name='body'),
}

async function enableDegradeRule(request: EnableDegradeRuleRequest): EnableDegradeRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EnableDegradeRule', 'POST', '/', 'json', false, 'json', request);
}

model EnableFlowRuleRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  ruleId: long(name='RuleId', position='Query'),
}

model EnableFlowRuleResponseBody = {
  code?: string(name='Code'),
  data?: {
    appName?: string(name='AppName'),
    clusterEstimatedMaxQps?: float(name='ClusterEstimatedMaxQps'),
    clusterFallbackStrategy?: int32(name='ClusterFallbackStrategy'),
    clusterFallbackThreshold?: int32(name='ClusterFallbackThreshold'),
    clusterMode?: boolean(name='ClusterMode'),
    clusterThresholdType?: int32(name='ClusterThresholdType'),
    controlBehavior?: int32(name='ControlBehavior'),
    enable?: boolean(name='Enable'),
    limitOrigin?: string(name='LimitOrigin'),
    maxQueueingTimeMs?: int32(name='MaxQueueingTimeMs'),
    namespace?: string(name='Namespace'),
    refResource?: string(name='RefResource'),
    relationStrategy?: int32(name='RelationStrategy'),
    resource?: string(name='Resource'),
    ruleId?: long(name='RuleId'),
    statDurationMs?: int32(name='StatDurationMs'),
    threshold?: float(name='Threshold'),
    warmUpPeriodSec?: int32(name='WarmUpPeriodSec'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model EnableFlowRuleResponse = {
  headers: map[string]string(name='headers'),
  body: EnableFlowRuleResponseBody(name='body'),
}

async function enableFlowRule(request: EnableFlowRuleRequest): EnableFlowRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EnableFlowRule', 'POST', '/', 'json', false, 'json', request);
}

model EnableHotParamRuleRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  ruleId: long(name='RuleId', position='Query'),
}

model EnableHotParamRuleResponseBody = {
  code?: string(name='Code'),
  data?: {
    appName?: string(name='AppName'),
    burstCount?: int32(name='BurstCount'),
    controlBehavior?: int32(name='ControlBehavior'),
    enable?: boolean(name='Enable'),
    maxQueueingTimeMs?: int32(name='MaxQueueingTimeMs'),
    metricType?: int32(name='MetricType'),
    namespace?: string(name='Namespace'),
    paramFlowItemList?: [ 
      {
        itemType?: string(name='ItemType'),
        itemValue?: string(name='ItemValue'),
        threshold?: float(name='Threshold'),
      }
    ](name='ParamFlowItemList'),
    paramIdx?: int32(name='ParamIdx'),
    resource?: string(name='Resource'),
    ruleId?: long(name='RuleId'),
    statDurationSec?: long(name='StatDurationSec'),
    threshold?: float(name='Threshold'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model EnableHotParamRuleResponse = {
  headers: map[string]string(name='headers'),
  body: EnableHotParamRuleResponseBody(name='body'),
}

async function enableHotParamRule(request: EnableHotParamRuleRequest): EnableHotParamRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EnableHotParamRule', 'POST', '/', 'json', false, 'json', request);
}

model EnableIsolationRuleRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  ruleId: long(name='RuleId', minimum=0, maximum=9223372036854775807, position='Query'),
}

model EnableIsolationRuleResponseBody = {
  code?: string(name='Code'),
  data?: {
    appName?: string(name='AppName'),
    enable?: boolean(name='Enable'),
    limitOrigin?: string(name='LimitOrigin'),
    namespace?: string(name='Namespace'),
    refResource?: string(name='RefResource'),
    relationStrategy?: int32(name='RelationStrategy'),
    resource?: string(name='Resource'),
    ruleId?: long(name='RuleId'),
    threshold?: float(name='Threshold'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model EnableIsolationRuleResponse = {
  headers: map[string]string(name='headers'),
  body: EnableIsolationRuleResponseBody(name='body'),
}

async function enableIsolationRule(request: EnableIsolationRuleRequest): EnableIsolationRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EnableIsolationRule', 'POST', '/', 'json', false, 'json', request);
}

model EnableSystemRuleRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  ruleId: long(name='RuleId', position='Query'),
}

model EnableSystemRuleResponseBody = {
  code?: string(name='Code'),
  data?: {
    enable?: boolean(name='Enable'),
    metricType?: int32(name='MetricType'),
    ruleId?: long(name='RuleId'),
    threshold?: float(name='Threshold'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model EnableSystemRuleResponse = {
  headers: map[string]string(name='headers'),
  body: EnableSystemRuleResponseBody(name='body'),
}

async function enableSystemRule(request: EnableSystemRuleRequest): EnableSystemRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EnableSystemRule', 'POST', '/', 'json', false, 'json', request);
}

model ExecuteExperimentRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  definition?: string(name='Definition', position='Query'),
  experimentId: string(name='ExperimentId', position='Query'),
  nameSpace?: string(name='NameSpace', position='Query'),
}

model ExecuteExperimentResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  taskId?: string(name='TaskId'),
}

model ExecuteExperimentResponse = {
  headers: map[string]string(name='headers'),
  body: ExecuteExperimentResponseBody(name='body'),
}

async function executeExperiment(request: ExecuteExperimentRequest): ExecuteExperimentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ExecuteExperiment', 'POST', '/', 'json', false, 'json', request);
}

model FinishExperimentTaskRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  experimentTaskId: string(name='ExperimentTaskId', position='Query'),
  nameSpace?: string(name='NameSpace', position='Query'),
}

model FinishExperimentTaskResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model FinishExperimentTaskResponse = {
  headers: map[string]string(name='headers'),
  body: FinishExperimentTaskResponseBody(name='body'),
}

async function finishExperimentTask(request: FinishExperimentTaskRequest): FinishExperimentTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'FinishExperimentTask', 'POST', '/', 'json', false, 'json', request);
}

model GetActivityTaskRequest {
  activityTaskId: string(name='ActivityTaskId', position='Query'),
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  experimentTaskId: string(name='ExperimentTaskId', position='Query'),
  nameSpace?: string(name='NameSpace', position='Query'),
}

model GetActivityTaskResponseBody = {
  activityId?: string(name='ActivityId'),
  activityName?: string(name='ActivityName'),
  endTime?: long(name='EndTime'),
  experimentTaskId?: string(name='ExperimentTaskId'),
  hosts?: [ 
    {
      data?: string(name='Data'),
      endTime?: long(name='EndTime'),
      errorMessage?: string(name='ErrorMessage'),
      expId?: string(name='ExpId'),
      hostIp?: string(name='HostIp'),
      result?: string(name='Result'),
      startTime?: long(name='StartTime'),
      state?: string(name='State'),
      taskId?: string(name='TaskId'),
    }
  ](name='Hosts'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  phase?: string(name='Phase'),
  requestId?: string(name='RequestId'),
  runResult?: string(name='RunResult'),
  startTime?: long(name='StartTime'),
  state?: string(name='State'),
  success?: boolean(name='Success'),
}

model GetActivityTaskResponse = {
  headers: map[string]string(name='headers'),
  body: GetActivityTaskResponseBody(name='body'),
}

async function getActivityTask(request: GetActivityTaskRequest): GetActivityTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetActivityTask', 'POST', '/', 'json', false, 'json', request);
}

model GetExperimentMetaRequest {
  experimentId: string(name='ExperimentId', position='Query'),
  nameSpace?: string(name='NameSpace', position='Query'),
}

model GetExperimentMetaResponseBody = {
  code?: string(name='Code'),
  createTime?: string(name='CreateTime'),
  experimentId?: string(name='ExperimentId'),
  message?: string(name='Message'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
  state?: string(name='State'),
  success?: boolean(name='Success'),
  tags?: [ string ](name='Tags'),
}

model GetExperimentMetaResponse = {
  headers: map[string]string(name='headers'),
  body: GetExperimentMetaResponseBody(name='body'),
}

async function getExperimentMeta(request: GetExperimentMetaRequest): GetExperimentMetaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetExperimentMeta', 'POST', '/', 'json', false, 'json', request);
}

model GetExperimentTaskRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  experimentTaskId: string(name='ExperimentTaskId', position='Query'),
  nameSpace?: string(name='NameSpace', position='Query'),
}

model GetExperimentTaskResponseBody = {
  activities?: [ 
    {
      activityId?: string(name='ActivityId'),
      activityName?: string(name='ActivityName'),
      checkState?: string(name='CheckState'),
      endTime?: long(name='EndTime'),
      experimentTaskId?: string(name='ExperimentTaskId'),
      phase?: string(name='Phase'),
      runResult?: string(name='RunResult'),
      startTime?: long(name='StartTime'),
      state?: string(name='State'),
      taskId?: string(name='TaskId'),
    }
  ](name='Activities'),
  experimentId?: string(name='ExperimentId'),
  experimentName?: string(name='ExperimentName'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  namespace?: string(name='Namespace'),
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
  startTime?: long(name='StartTime'),
  state?: string(name='State'),
  success?: boolean(name='Success'),
  taskId?: string(name='TaskId'),
}

model GetExperimentTaskResponse = {
  headers: map[string]string(name='headers'),
  body: GetExperimentTaskResponseBody(name='body'),
}

async function getExperimentTask(request: GetExperimentTaskRequest): GetExperimentTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetExperimentTask', 'POST', '/', 'json', false, 'json', request);
}

model GetLicenseKeyRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  namespace: string(name='Namespace', position='Query'),
}

model GetLicenseKeyResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetLicenseKeyResponse = {
  headers: map[string]string(name='headers'),
  body: GetLicenseKeyResponseBody(name='body'),
}

async function getLicenseKey(request: GetLicenseKeyRequest): GetLicenseKeyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetLicenseKey', 'POST', '/', 'json', false, 'json', request);
}

model GetMetricsOfAppRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  appName: string(name='AppName', position='Query'),
  endTime?: long(name='EndTime', position='Query'),
  namespace: string(name='Namespace', position='Query'),
  startTime?: long(name='StartTime', position='Query'),
}

model GetMetricsOfAppResponseBody = {
  code?: string(name='Code'),
  data?: {
    appName?: string(name='AppName'),
    innerMetrics?: [ 
      {
        blockedQps?: float(name='BlockedQps'),
        blockedQpsAvg?: float(name='BlockedQpsAvg'),
        blockedQpsMax?: float(name='BlockedQpsMax'),
        blockedQpsMin?: float(name='BlockedQpsMin'),
        blockedQpsP75?: float(name='BlockedQpsP75'),
        blockedQpsP95?: float(name='BlockedQpsP95'),
        blockedQpsP99?: float(name='BlockedQpsP99'),
        blockedQpsStd?: float(name='BlockedQpsStd'),
        count?: int32(name='Count'),
        exception?: float(name='Exception'),
        exceptionAvg?: float(name='ExceptionAvg'),
        exceptionMax?: float(name='ExceptionMax'),
        exceptionMin?: float(name='ExceptionMin'),
        exceptionP75?: float(name='ExceptionP75'),
        exceptionP95?: float(name='ExceptionP95'),
        exceptionP99?: float(name='ExceptionP99'),
        exceptionStd?: float(name='ExceptionStd'),
        passedQps?: float(name='PassedQps'),
        passedQpsAvg?: float(name='PassedQpsAvg'),
        passedQpsMax?: float(name='PassedQpsMax'),
        passedQpsMin?: float(name='PassedQpsMin'),
        passedQpsP75?: float(name='PassedQpsP75'),
        passedQpsP95?: float(name='PassedQpsP95'),
        passedQpsP99?: float(name='PassedQpsP99'),
        passedQpsStd?: float(name='PassedQpsStd'),
        rt?: float(name='Rt'),
        rtAvg?: float(name='RtAvg'),
        rtMax?: float(name='RtMax'),
        rtMin?: float(name='RtMin'),
        rtP75?: float(name='RtP75'),
        rtP95?: float(name='RtP95'),
        rtP99?: float(name='RtP99'),
        rtStd?: float(name='RtStd'),
        successQps?: float(name='SuccessQps'),
        successQpsAvg?: float(name='SuccessQpsAvg'),
        successQpsMax?: float(name='SuccessQpsMax'),
        successQpsMin?: float(name='SuccessQpsMin'),
        successQpsP75?: float(name='SuccessQpsP75'),
        successQpsP95?: float(name='SuccessQpsP95'),
        successQpsP99?: float(name='SuccessQpsP99'),
        successQpsStd?: float(name='SuccessQpsStd'),
        thread?: float(name='Thread'),
        threadAvg?: float(name='ThreadAvg'),
        threadMax?: float(name='ThreadMax'),
        threadMin?: float(name='ThreadMin'),
        threadP75?: float(name='ThreadP75'),
        threadP95?: float(name='ThreadP95'),
        threadP99?: float(name='ThreadP99'),
        threadStd?: float(name='ThreadStd'),
        timestamp?: long(name='Timestamp'),
      }
    ](name='InnerMetrics'),
    namespace?: string(name='Namespace'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetMetricsOfAppResponse = {
  headers: map[string]string(name='headers'),
  body: GetMetricsOfAppResponseBody(name='body'),
}

async function getMetricsOfApp(request: GetMetricsOfAppRequest): GetMetricsOfAppResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMetricsOfApp', 'POST', '/', 'json', false, 'json', request);
}

model GetMetricsOfResourceRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  appName: string(name='AppName', position='Query'),
  endTime?: long(name='EndTime', position='Query'),
  namespace: string(name='Namespace', position='Query'),
  resource: string(name='Resource', position='Query'),
  startTime?: long(name='StartTime', position='Query'),
}

model GetMetricsOfResourceResponseBody = {
  code?: string(name='Code'),
  data?: {
    appName?: string(name='AppName'),
    innerMetrics?: [ 
      {
        blockedQps?: float(name='BlockedQps'),
        blockedQpsAvg?: float(name='BlockedQpsAvg'),
        blockedQpsMax?: float(name='BlockedQpsMax'),
        blockedQpsMin?: float(name='BlockedQpsMin'),
        blockedQpsP75?: float(name='BlockedQpsP75'),
        blockedQpsP95?: float(name='BlockedQpsP95'),
        blockedQpsP99?: float(name='BlockedQpsP99'),
        blockedQpsStd?: float(name='BlockedQpsStd'),
        count?: int32(name='Count'),
        exception?: float(name='Exception'),
        exceptionAvg?: float(name='ExceptionAvg'),
        exceptionMax?: float(name='ExceptionMax'),
        exceptionMin?: float(name='ExceptionMin'),
        exceptionP75?: float(name='ExceptionP75'),
        exceptionP95?: float(name='ExceptionP95'),
        exceptionP99?: float(name='ExceptionP99'),
        exceptionStd?: float(name='ExceptionStd'),
        passedQps?: float(name='PassedQps'),
        passedQpsAvg?: float(name='PassedQpsAvg'),
        passedQpsMax?: float(name='PassedQpsMax'),
        passedQpsMin?: float(name='PassedQpsMin'),
        passedQpsP75?: float(name='PassedQpsP75'),
        passedQpsP95?: float(name='PassedQpsP95'),
        passedQpsP99?: float(name='PassedQpsP99'),
        passedQpsStd?: float(name='PassedQpsStd'),
        rt?: float(name='Rt'),
        rtAvg?: float(name='RtAvg'),
        rtMax?: float(name='RtMax'),
        rtMin?: float(name='RtMin'),
        rtP75?: float(name='RtP75'),
        rtP95?: float(name='RtP95'),
        rtP99?: float(name='RtP99'),
        rtStd?: float(name='RtStd'),
        successQps?: float(name='SuccessQps'),
        successQpsAvg?: float(name='SuccessQpsAvg'),
        successQpsMax?: float(name='SuccessQpsMax'),
        successQpsMin?: float(name='SuccessQpsMin'),
        successQpsP75?: float(name='SuccessQpsP75'),
        successQpsP95?: float(name='SuccessQpsP95'),
        successQpsP99?: float(name='SuccessQpsP99'),
        successQpsStd?: float(name='SuccessQpsStd'),
        thread?: float(name='Thread'),
        threadAvg?: float(name='ThreadAvg'),
        threadMax?: float(name='ThreadMax'),
        threadMin?: float(name='ThreadMin'),
        threadP75?: float(name='ThreadP75'),
        threadP95?: float(name='ThreadP95'),
        threadP99?: float(name='ThreadP99'),
        threadStd?: float(name='ThreadStd'),
        timestamp?: long(name='Timestamp'),
      }
    ](name='InnerMetrics'),
    namespace?: string(name='Namespace'),
    resource?: string(name='Resource'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetMetricsOfResourceResponse = {
  headers: map[string]string(name='headers'),
  body: GetMetricsOfResourceResponseBody(name='body'),
}

async function getMetricsOfResource(request: GetMetricsOfResourceRequest): GetMetricsOfResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMetricsOfResource', 'POST', '/', 'json', false, 'json', request);
}

model GetSentinelAppSumMetricRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  appName: string(name='AppName', position='Query'),
  endTime: string(name='EndTime', position='Query'),
  namespace?: string(name='Namespace', position='Query'),
  startTime: string(name='StartTime', position='Query'),
}

model GetSentinelAppSumMetricResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  metricData?: {
    appName?: string(name='AppName'),
    avgRt?: float(name='AvgRt'),
    blockCount?: float(name='BlockCount'),
    machineCount?: long(name='MachineCount'),
    namespace?: string(name='Namespace'),
    passCount?: float(name='PassCount'),
    totalCount?: float(name='TotalCount'),
    userId?: string(name='UserId'),
  }(name='MetricData'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetSentinelAppSumMetricResponse = {
  headers: map[string]string(name='headers'),
  body: GetSentinelAppSumMetricResponseBody(name='body'),
}

async function getSentinelAppSumMetric(request: GetSentinelAppSumMetricRequest): GetSentinelAppSumMetricResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetSentinelAppSumMetric', 'POST', '/', 'json', false, 'json', request);
}

model GetUserApplicationGroupsRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  applicationId: string(name='ApplicationId', position='Query'),
  nameSpace?: string(name='NameSpace', position='Query'),
}

model GetUserApplicationGroupsResponseBody = {
  appGroups?: [ string ](name='AppGroups'),
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetUserApplicationGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: GetUserApplicationGroupsResponseBody(name='body'),
}

async function getUserApplicationGroups(request: GetUserApplicationGroupsRequest): GetUserApplicationGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetUserApplicationGroups', 'POST', '/', 'json', false, 'json', request);
}

model GetUserApplicationsRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  namespace: string(name='Namespace', position='Query'),
}

model GetUserApplicationsResponseBody = {
  appNameAndIdPairs?: [ 
    {
      appId?: string(name='AppId'),
      appName?: string(name='AppName'),
      appType?: int32(name='AppType'),
      scopeType?: int32(name='ScopeType'),
    }
  ](name='AppNameAndIdPairs'),
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetUserApplicationsResponse = {
  headers: map[string]string(name='headers'),
  body: GetUserApplicationsResponseBody(name='body'),
}

async function getUserApplications(request: GetUserApplicationsRequest): GetUserApplicationsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetUserApplications', 'POST', '/', 'json', false, 'json', request);
}

model GetUserWorkspaceRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  namespace?: string(name='Namespace', position='Query'),
}

model GetUserWorkspaceResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  workspaceList?: [ 
    {
      description?: string(name='Description'),
      name?: string(name='Name'),
      type?: int32(name='Type'),
      workspaceId?: string(name='WorkspaceId'),
    }
  ](name='WorkspaceList'),
}

model GetUserWorkspaceResponse = {
  headers: map[string]string(name='headers'),
  body: GetUserWorkspaceResponseBody(name='body'),
}

async function getUserWorkspace(request: GetUserWorkspaceRequest): GetUserWorkspaceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetUserWorkspace', 'POST', '/', 'json', false, 'json', request);
}

model ListActiveAppsRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  appType?: int32(name='AppType', minimum=0, maximum=2147483647, position='Query'),
  namespace: string(name='Namespace', position='Query'),
}

model ListActiveAppsResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      ahasAppName?: string(name='AhasAppName'),
      appName?: string(name='AppName'),
      appType?: int32(name='AppType'),
      currentLevel?: int32(name='CurrentLevel'),
      dirtyLevel?: int32(name='DirtyLevel'),
      lastHealthPingTime?: long(name='LastHealthPingTime'),
      namespace?: string(name='Namespace'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListActiveAppsResponse = {
  headers: map[string]string(name='headers'),
  body: ListActiveAppsResponseBody(name='body'),
}

async function listActiveApps(request: ListActiveAppsRequest): ListActiveAppsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListActiveApps', 'POST', '/', 'json', false, 'json', request);
}

model ListDegradeRulesOfAppRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  appName: string(name='AppName', position='Query'),
  namespace: string(name='Namespace', position='Query'),
  pageIndex?: int32(name='PageIndex', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
}

model ListDegradeRulesOfAppResponseBody = {
  code?: string(name='Code'),
  data?: {
    datas?: [ 
      {
        appName?: string(name='AppName'),
        enable?: boolean(name='Enable'),
        halfOpenBaseAmountPerStep?: int32(name='HalfOpenBaseAmountPerStep'),
        halfOpenRecoveryStepNum?: int32(name='HalfOpenRecoveryStepNum'),
        minRequestAmount?: int32(name='MinRequestAmount'),
        namespace?: string(name='Namespace'),
        recoveryTimeoutMs?: int32(name='RecoveryTimeoutMs'),
        resource?: string(name='Resource'),
        ruleId?: long(name='RuleId'),
        slowRtMs?: int32(name='SlowRtMs'),
        statDurationMs?: int32(name='StatDurationMs'),
        strategy?: int32(name='Strategy'),
        threshold?: float(name='Threshold'),
      }
    ](name='Datas'),
    pageIndex?: int32(name='PageIndex'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    totalPage?: int32(name='TotalPage'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListDegradeRulesOfAppResponse = {
  headers: map[string]string(name='headers'),
  body: ListDegradeRulesOfAppResponseBody(name='body'),
}

async function listDegradeRulesOfApp(request: ListDegradeRulesOfAppRequest): ListDegradeRulesOfAppResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListDegradeRulesOfApp', 'POST', '/', 'json', false, 'json', request);
}

model ListDegradeRulesOfResourceRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  appName: string(name='AppName', position='Query'),
  namespace: string(name='Namespace', position='Query'),
  pageIndex?: int32(name='PageIndex', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  resource: string(name='Resource', position='Query'),
}

model ListDegradeRulesOfResourceResponseBody = {
  code?: string(name='Code'),
  data?: {
    datas?: [ 
      {
        appName?: string(name='AppName'),
        enable?: boolean(name='Enable'),
        halfOpenBaseAmountPerStep?: int32(name='HalfOpenBaseAmountPerStep'),
        halfOpenRecoveryStepNum?: int32(name='HalfOpenRecoveryStepNum'),
        minRequestAmount?: int32(name='MinRequestAmount'),
        namespace?: string(name='Namespace'),
        recoveryTimeoutMs?: int32(name='RecoveryTimeoutMs'),
        resource?: string(name='Resource'),
        ruleId?: long(name='RuleId'),
        slowRtMs?: int32(name='SlowRtMs'),
        statDurationMs?: int32(name='StatDurationMs'),
        strategy?: int32(name='Strategy'),
        threshold?: float(name='Threshold'),
      }
    ](name='Datas'),
    pageIndex?: int32(name='PageIndex'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    totalPage?: int32(name='TotalPage'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListDegradeRulesOfResourceResponse = {
  headers: map[string]string(name='headers'),
  body: ListDegradeRulesOfResourceResponseBody(name='body'),
}

async function listDegradeRulesOfResource(request: ListDegradeRulesOfResourceRequest): ListDegradeRulesOfResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListDegradeRulesOfResource', 'POST', '/', 'json', false, 'json', request);
}

model ListExperimentMetasRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  nameSpace?: string(name='NameSpace', position='Query'),
  page?: int32(name='Page', position='Query'),
  size?: int32(name='Size', position='Query'),
}

model ListExperimentMetasResponseBody = {
  code?: string(name='Code'),
  content?: [ 
    {
      createTime?: long(name='CreateTime'),
      experimentId?: string(name='ExperimentId'),
      name?: string(name='Name'),
      state?: string(name='State'),
      tags?: [ string ](name='Tags'),
    }
  ](name='Content'),
  currentPage?: int32(name='CurrentPage'),
  message?: string(name='Message'),
  pageSize?: int32(name='PageSize'),
  pages?: int32(name='Pages'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model ListExperimentMetasResponse = {
  headers: map[string]string(name='headers'),
  body: ListExperimentMetasResponseBody(name='body'),
}

async function listExperimentMetas(request: ListExperimentMetasRequest): ListExperimentMetasResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListExperimentMetas', 'POST', '/', 'json', false, 'json', request);
}

model ListFlowRulesOfAppRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  appName: string(name='AppName', position='Query'),
  namespace: string(name='Namespace', position='Query'),
  pageIndex?: int32(name='PageIndex', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
}

model ListFlowRulesOfAppResponseBody = {
  code?: string(name='Code'),
  data?: {
    datas?: [ 
      {
        appName?: string(name='AppName'),
        clusterEstimatedMaxQps?: float(name='ClusterEstimatedMaxQps'),
        clusterFallbackStrategy?: int32(name='ClusterFallbackStrategy'),
        clusterFallbackThreshold?: int32(name='ClusterFallbackThreshold'),
        clusterMode?: boolean(name='ClusterMode'),
        clusterThresholdType?: int32(name='ClusterThresholdType'),
        controlBehavior?: int32(name='ControlBehavior'),
        enable?: boolean(name='Enable'),
        limitOrigin?: string(name='LimitOrigin'),
        maxQueueingTimeMs?: int32(name='MaxQueueingTimeMs'),
        namespace?: string(name='Namespace'),
        refResource?: string(name='RefResource'),
        relationStrategy?: int32(name='RelationStrategy'),
        resource?: string(name='Resource'),
        ruleId?: long(name='RuleId'),
        statDurationMs?: int32(name='StatDurationMs'),
        threshold?: float(name='Threshold'),
        warmUpPeriodSec?: int32(name='WarmUpPeriodSec'),
      }
    ](name='Datas'),
    pageIndex?: int32(name='PageIndex'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    totalPage?: int32(name='TotalPage'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListFlowRulesOfAppResponse = {
  headers: map[string]string(name='headers'),
  body: ListFlowRulesOfAppResponseBody(name='body'),
}

async function listFlowRulesOfApp(request: ListFlowRulesOfAppRequest): ListFlowRulesOfAppResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListFlowRulesOfApp', 'POST', '/', 'json', false, 'json', request);
}

model ListFlowRulesOfResourceRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  appName: string(name='AppName', position='Query'),
  namespace: string(name='Namespace', position='Query'),
  pageIndex?: int32(name='PageIndex', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  resource: string(name='Resource', position='Query'),
}

model ListFlowRulesOfResourceResponseBody = {
  code?: string(name='Code'),
  data?: {
    datas?: [ 
      {
        appName?: string(name='AppName'),
        clusterEstimatedMaxQps?: float(name='ClusterEstimatedMaxQps'),
        clusterFallbackStrategy?: int32(name='ClusterFallbackStrategy'),
        clusterFallbackThreshold?: int32(name='ClusterFallbackThreshold'),
        clusterMode?: boolean(name='ClusterMode'),
        clusterThresholdType?: int32(name='ClusterThresholdType'),
        controlBehavior?: int32(name='ControlBehavior'),
        enable?: boolean(name='Enable'),
        limitOrigin?: string(name='LimitOrigin'),
        maxQueueingTimeMs?: int32(name='MaxQueueingTimeMs'),
        namespace?: string(name='Namespace'),
        refResource?: string(name='RefResource'),
        relationStrategy?: int32(name='RelationStrategy'),
        resource?: string(name='Resource'),
        ruleId?: long(name='RuleId'),
        statDurationMs?: int32(name='StatDurationMs'),
        threshold?: float(name='Threshold'),
        warmUpPeriodSec?: int32(name='WarmUpPeriodSec'),
      }
    ](name='Datas'),
    pageIndex?: int32(name='PageIndex'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    totalPage?: int32(name='TotalPage'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListFlowRulesOfResourceResponse = {
  headers: map[string]string(name='headers'),
  body: ListFlowRulesOfResourceResponseBody(name='body'),
}

async function listFlowRulesOfResource(request: ListFlowRulesOfResourceRequest): ListFlowRulesOfResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListFlowRulesOfResource', 'POST', '/', 'json', false, 'json', request);
}

model ListHotParamRulesOfAppRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  appName: string(name='AppName', position='Query'),
  namespace: string(name='Namespace', position='Query'),
  pageIndex?: int32(name='PageIndex', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
}

model ListHotParamRulesOfAppResponseBody = {
  code?: string(name='Code'),
  data?: {
    datas?: [ 
      {
        appName?: string(name='AppName'),
        burstCount?: int32(name='BurstCount'),
        controlBehavior?: int32(name='ControlBehavior'),
        enable?: boolean(name='Enable'),
        maxQueueingTimeMs?: int32(name='MaxQueueingTimeMs'),
        metricType?: int32(name='MetricType'),
        namespace?: string(name='Namespace'),
        paramFlowItemList?: [ 
          {
            itemType?: string(name='ItemType'),
            itemValue?: string(name='ItemValue'),
            threshold?: float(name='Threshold'),
          }
        ](name='ParamFlowItemList'),
        paramIdx?: int32(name='ParamIdx'),
        resource?: string(name='Resource'),
        ruleId?: long(name='RuleId'),
        statDurationSec?: long(name='StatDurationSec'),
        threshold?: float(name='Threshold'),
      }
    ](name='Datas'),
    pageIndex?: int32(name='PageIndex'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    totalPage?: int32(name='TotalPage'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListHotParamRulesOfAppResponse = {
  headers: map[string]string(name='headers'),
  body: ListHotParamRulesOfAppResponseBody(name='body'),
}

async function listHotParamRulesOfApp(request: ListHotParamRulesOfAppRequest): ListHotParamRulesOfAppResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListHotParamRulesOfApp', 'POST', '/', 'json', false, 'json', request);
}

model ListHotParamRulesOfResourceRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  appName: string(name='AppName', position='Query'),
  namespace: string(name='Namespace', position='Query'),
  pageIndex?: int32(name='PageIndex', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  resource: string(name='Resource', position='Query'),
}

model ListHotParamRulesOfResourceResponseBody = {
  code?: string(name='Code'),
  data?: {
    datas?: [ 
      {
        appName?: string(name='AppName'),
        burstCount?: int32(name='BurstCount'),
        controlBehavior?: int32(name='ControlBehavior'),
        enable?: boolean(name='Enable'),
        maxQueueingTimeMs?: int32(name='MaxQueueingTimeMs'),
        metricType?: int32(name='MetricType'),
        namespace?: string(name='Namespace'),
        paramFlowItemList?: [ 
          {
            itemType?: string(name='ItemType'),
            itemValue?: string(name='ItemValue'),
            threshold?: float(name='Threshold'),
          }
        ](name='ParamFlowItemList'),
        paramIdx?: int32(name='ParamIdx'),
        resource?: string(name='Resource'),
        ruleId?: long(name='RuleId'),
        statDurationSec?: long(name='StatDurationSec'),
        threshold?: float(name='Threshold'),
      }
    ](name='Datas'),
    pageIndex?: int32(name='PageIndex'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    totalPage?: int32(name='TotalPage'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListHotParamRulesOfResourceResponse = {
  headers: map[string]string(name='headers'),
  body: ListHotParamRulesOfResourceResponseBody(name='body'),
}

async function listHotParamRulesOfResource(request: ListHotParamRulesOfResourceRequest): ListHotParamRulesOfResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListHotParamRulesOfResource', 'POST', '/', 'json', false, 'json', request);
}

model ListIsolationRulesOfAppRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  appName: string(name='AppName', position='Query'),
  namespace: string(name='Namespace', position='Query'),
  pageIndex?: int32(name='PageIndex', minimum=0, maximum=2147483647, position='Query'),
  pageSize?: int32(name='PageSize', minimum=0, maximum=2147483647, position='Query'),
}

model ListIsolationRulesOfAppResponseBody = {
  code?: string(name='Code'),
  data?: {
    datas?: [ 
      {
        appName?: string(name='AppName'),
        enable?: boolean(name='Enable'),
        limitOrigin?: string(name='LimitOrigin'),
        namespace?: string(name='Namespace'),
        refResource?: string(name='RefResource'),
        relationStrategy?: int32(name='RelationStrategy'),
        resource?: string(name='Resource'),
        ruleId?: long(name='RuleId'),
        threshold?: float(name='Threshold'),
      }
    ](name='Datas'),
    pageIndex?: int32(name='PageIndex'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    totalPage?: int32(name='TotalPage'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListIsolationRulesOfAppResponse = {
  headers: map[string]string(name='headers'),
  body: ListIsolationRulesOfAppResponseBody(name='body'),
}

async function listIsolationRulesOfApp(request: ListIsolationRulesOfAppRequest): ListIsolationRulesOfAppResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListIsolationRulesOfApp', 'POST', '/', 'json', false, 'json', request);
}

model ListIsolationRulesOfResourceRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  appName: string(name='AppName', position='Query'),
  namespace: string(name='Namespace', position='Query'),
  pageIndex?: int32(name='PageIndex', minimum=0, maximum=2147483647, position='Query'),
  pageSize?: int32(name='PageSize', minimum=0, maximum=2147483647, position='Query'),
  resource: string(name='Resource', position='Query'),
}

model ListIsolationRulesOfResourceResponseBody = {
  code?: string(name='Code'),
  data?: {
    datas?: [ 
      {
        appName?: string(name='AppName'),
        enable?: boolean(name='Enable'),
        limitOrigin?: string(name='LimitOrigin'),
        namespace?: string(name='Namespace'),
        refResource?: string(name='RefResource'),
        relationStrategy?: int32(name='RelationStrategy'),
        resource?: string(name='Resource'),
        ruleId?: long(name='RuleId'),
        threshold?: float(name='Threshold'),
      }
    ](name='Datas'),
    pageIndex?: int32(name='PageIndex'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    totalPage?: int32(name='TotalPage'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListIsolationRulesOfResourceResponse = {
  headers: map[string]string(name='headers'),
  body: ListIsolationRulesOfResourceResponseBody(name='body'),
}

async function listIsolationRulesOfResource(request: ListIsolationRulesOfResourceRequest): ListIsolationRulesOfResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListIsolationRulesOfResource', 'POST', '/', 'json', false, 'json', request);
}

model ListSystemRulesRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  appName: string(name='AppName', position='Query'),
  namespace: string(name='Namespace', position='Query'),
  pageIndex?: int32(name='PageIndex', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
}

model ListSystemRulesResponseBody = {
  code?: string(name='Code'),
  data?: {
    datas?: [ 
      {
        appName?: string(name='AppName'),
        enable?: boolean(name='Enable'),
        metricType?: int32(name='MetricType'),
        namespace?: string(name='Namespace'),
        ruleId?: long(name='RuleId'),
        threshold?: float(name='Threshold'),
      }
    ](name='Datas'),
    pageIndex?: int32(name='PageIndex'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    totalPage?: int32(name='TotalPage'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListSystemRulesResponse = {
  headers: map[string]string(name='headers'),
  body: ListSystemRulesResponseBody(name='body'),
}

async function listSystemRules(request: ListSystemRulesRequest): ListSystemRulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListSystemRules', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDegradeRuleRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  halfOpenBaseAmountPerStep?: int32(name='HalfOpenBaseAmountPerStep', position='Query'),
  halfOpenRecoveryStepNum?: int32(name='HalfOpenRecoveryStepNum', position='Query'),
  minRequestAmount?: int32(name='MinRequestAmount', position='Query'),
  recoveryTimeoutMs?: int32(name='RecoveryTimeoutMs', position='Query'),
  ruleId: long(name='RuleId', position='Query'),
  slowRtMs?: int32(name='SlowRtMs', position='Query'),
  statDurationMs?: int32(name='StatDurationMs', position='Query'),
  strategy?: int32(name='Strategy', position='Query'),
  threshold?: float(name='Threshold', position='Query'),
}

model ModifyDegradeRuleResponseBody = {
  code?: string(name='Code'),
  data?: {
    appName?: string(name='AppName'),
    enable?: boolean(name='Enable'),
    halfOpenBaseAmountPerStep?: int32(name='HalfOpenBaseAmountPerStep'),
    halfOpenRecoveryStepNum?: int32(name='HalfOpenRecoveryStepNum'),
    minRequestAmount?: int32(name='MinRequestAmount'),
    namespace?: string(name='Namespace'),
    recoveryTimeoutMs?: int32(name='RecoveryTimeoutMs'),
    resource?: string(name='Resource'),
    ruleId?: long(name='RuleId'),
    slowRtMs?: int32(name='SlowRtMs'),
    statDurationMs?: int32(name='StatDurationMs'),
    strategy?: int32(name='Strategy'),
    threshold?: float(name='Threshold'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ModifyDegradeRuleResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDegradeRuleResponseBody(name='body'),
}

async function modifyDegradeRule(request: ModifyDegradeRuleRequest): ModifyDegradeRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDegradeRule', 'POST', '/', 'json', false, 'json', request);
}

model ModifyFlowRuleRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  controlBehavior?: string(name='ControlBehavior', position='Query'),
  limitOrigin?: string(name='LimitOrigin', position='Query'),
  maxQueueingTimeMs?: int32(name='MaxQueueingTimeMs', position='Query'),
  namespace?: string(name='Namespace', position='Query'),
  refResource?: string(name='RefResource', position='Query'),
  relationStrategy?: int32(name='RelationStrategy', position='Query'),
  ruleId: long(name='RuleId', position='Query'),
  threshold?: float(name='Threshold', position='Query'),
  warmUpPeriodSec?: int32(name='WarmUpPeriodSec', position='Query'),
}

model ModifyFlowRuleResponseBody = {
  code?: string(name='Code'),
  data?: {
    appName?: string(name='AppName'),
    clusterEstimatedMaxQps?: float(name='ClusterEstimatedMaxQps'),
    clusterFallbackStrategy?: int32(name='ClusterFallbackStrategy'),
    clusterFallbackThreshold?: int32(name='ClusterFallbackThreshold'),
    clusterMode?: boolean(name='ClusterMode'),
    clusterThresholdType?: int32(name='ClusterThresholdType'),
    controlBehavior?: int32(name='ControlBehavior'),
    enable?: boolean(name='Enable'),
    limitOrigin?: string(name='LimitOrigin'),
    maxQueueingTimeMs?: int32(name='MaxQueueingTimeMs'),
    namespace?: string(name='Namespace'),
    refResource?: string(name='RefResource'),
    relationStrategy?: int32(name='RelationStrategy'),
    resource?: string(name='Resource'),
    ruleId?: long(name='RuleId'),
    statDurationMs?: int32(name='StatDurationMs'),
    threshold?: float(name='Threshold'),
    warmUpPeriodSec?: int32(name='WarmUpPeriodSec'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ModifyFlowRuleResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyFlowRuleResponseBody(name='body'),
}

async function modifyFlowRule(request: ModifyFlowRuleRequest): ModifyFlowRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyFlowRule', 'POST', '/', 'json', false, 'json', request);
}

model ModifyHotParamRuleRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  burstCount?: int32(name='BurstCount', position='Query'),
  controlBehavior?: int32(name='ControlBehavior', position='Query'),
  enable?: boolean(name='Enable', position='Query'),
  maxQueueingTimeMs?: int32(name='MaxQueueingTimeMs', position='Query'),
  metricType?: int32(name='MetricType', position='Query'),
  paramIdx?: int32(name='ParamIdx', position='Query'),
  ruleId: long(name='RuleId', position='Query'),
  statDurationSec?: long(name='StatDurationSec', position='Query'),
  threshold?: float(name='Threshold', position='Query'),
}

model ModifyHotParamRuleResponseBody = {
  code?: string(name='Code'),
  data?: {
    appName?: string(name='AppName'),
    burstCount?: int32(name='BurstCount'),
    controlBehavior?: int32(name='ControlBehavior'),
    enable?: boolean(name='Enable'),
    maxQueueingTimeMs?: int32(name='MaxQueueingTimeMs'),
    metricType?: int32(name='MetricType'),
    namespace?: string(name='Namespace'),
    paramFlowItemList?: [ 
      {
        itemType?: string(name='ItemType'),
        itemValue?: string(name='ItemValue'),
        threshold?: float(name='Threshold'),
      }
    ](name='ParamFlowItemList'),
    paramIdx?: int32(name='ParamIdx'),
    resource?: string(name='Resource'),
    ruleId?: long(name='RuleId'),
    statDurationSec?: long(name='StatDurationSec'),
    threshold?: float(name='Threshold'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ModifyHotParamRuleResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyHotParamRuleResponseBody(name='body'),
}

async function modifyHotParamRule(request: ModifyHotParamRuleRequest): ModifyHotParamRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyHotParamRule', 'POST', '/', 'json', false, 'json', request);
}

model ModifyIsolationRuleRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  limitOrigin?: string(name='LimitOrigin', position='Query'),
  refResource?: string(name='RefResource', position='Query'),
  relationStrategy?: int32(name='RelationStrategy', position='Query'),
  ruleId: long(name='RuleId', position='Query'),
  threshold?: float(name='Threshold', position='Query'),
}

model ModifyIsolationRuleResponseBody = {
  code?: string(name='Code'),
  data?: {
    appName?: string(name='AppName'),
    enable?: boolean(name='Enable'),
    limitOrigin?: string(name='LimitOrigin'),
    namespace?: string(name='Namespace'),
    refResource?: string(name='RefResource'),
    relationStrategy?: int32(name='RelationStrategy'),
    resource?: string(name='Resource'),
    ruleId?: long(name='RuleId'),
    threshold?: float(name='Threshold'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ModifyIsolationRuleResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyIsolationRuleResponseBody(name='body'),
}

async function modifyIsolationRule(request: ModifyIsolationRuleRequest): ModifyIsolationRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyIsolationRule', 'POST', '/', 'json', false, 'json', request);
}

model ModifySystemRuleRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  ruleId: long(name='RuleId', position='Query'),
  threshold: float(name='Threshold', position='Query'),
}

model ModifySystemRuleResponseBody = {
  code?: string(name='Code'),
  data?: {
    enable?: boolean(name='Enable'),
    metricType?: int32(name='MetricType'),
    ruleId?: long(name='RuleId'),
    threshold?: float(name='Threshold'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ModifySystemRuleResponse = {
  headers: map[string]string(name='headers'),
  body: ModifySystemRuleResponseBody(name='body'),
}

async function modifySystemRule(request: ModifySystemRuleRequest): ModifySystemRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifySystemRule', 'POST', '/', 'json', false, 'json', request);
}

model OpenAhasServiceRequest {
  ownerId?: long(name='OwnerId', position='Query'),
}

model OpenAhasServiceResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model OpenAhasServiceResponse = {
  headers: map[string]string(name='headers'),
  body: OpenAhasServiceResponseBody(name='body'),
}

async function openAhasService(request: OpenAhasServiceRequest): OpenAhasServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OpenAhasService', 'POST', '/', 'json', false, 'json', request);
}

model PageableQueryExperimentTaskByClusterIdRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  clusterId?: string(name='ClusterId', position='Query'),
  includeInvalidHost?: boolean(name='IncludeInvalidHost', position='Query'),
  namespace?: string(name='Namespace', position='Query'),
  page?: int32(name='Page', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  size?: int32(name='Size', position='Query'),
}

model PageableQueryExperimentTaskByClusterIdResponseBody = {
  code?: string(name='Code'),
  currentPage?: int32(name='CurrentPage'),
  experimentTasks?: [ 
    {
      creator?: {
        subUserId?: string(name='SubUserId'),
        userId?: string(name='UserId'),
      }(name='Creator'),
      currentPhase?: string(name='CurrentPhase'),
      endTime?: long(name='EndTime'),
      experimentId?: string(name='ExperimentId'),
      experimentName?: string(name='ExperimentName'),
      extInfo?: {
        schedulerConfig?: {
          cronExpression?: string(name='CronExpression'),
          fixedTime?: string(name='FixedTime'),
        }(name='SchedulerConfig'),
      }(name='ExtInfo'),
      message?: string(name='Message'),
      namespace?: string(name='Namespace'),
      result?: string(name='Result'),
      startTime?: long(name='StartTime'),
      state?: string(name='State'),
      taskId?: string(name='TaskId'),
    }
  ](name='ExperimentTasks'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  pageSize?: int32(name='PageSize'),
  pages?: int32(name='Pages'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model PageableQueryExperimentTaskByClusterIdResponse = {
  headers: map[string]string(name='headers'),
  body: PageableQueryExperimentTaskByClusterIdResponseBody(name='body'),
}

async function pageableQueryExperimentTaskByClusterId(request: PageableQueryExperimentTaskByClusterIdRequest): PageableQueryExperimentTaskByClusterIdResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PageableQueryExperimentTaskByClusterId', 'POST', '/', 'json', false, 'json', request);
}

model PageableQueryExperimentTaskByExperimentIdRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  experimentId?: string(name='ExperimentId', position='Query'),
  namespace?: string(name='Namespace', position='Query'),
  page?: int32(name='Page', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  size?: int32(name='Size', position='Query'),
}

model PageableQueryExperimentTaskByExperimentIdResponseBody = {
  code?: string(name='Code'),
  currentPage?: int32(name='CurrentPage'),
  experimentTasks?: [ 
    {
      creator?: {
        subUserId?: string(name='SubUserId'),
        userId?: string(name='UserId'),
      }(name='Creator'),
      currentPhase?: string(name='CurrentPhase'),
      endTime?: long(name='EndTime'),
      experimentId?: string(name='ExperimentId'),
      experimentName?: string(name='ExperimentName'),
      extInfo?: {
        schedulerConfig?: {
          cronExpression?: string(name='CronExpression'),
          fixedTime?: string(name='FixedTime'),
        }(name='SchedulerConfig'),
      }(name='ExtInfo'),
      message?: string(name='Message'),
      namespace?: string(name='Namespace'),
      result?: string(name='Result'),
      startTime?: long(name='StartTime'),
      state?: string(name='State'),
      taskId?: string(name='TaskId'),
    }
  ](name='ExperimentTasks'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  pageSize?: int32(name='PageSize'),
  pages?: int32(name='Pages'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model PageableQueryExperimentTaskByExperimentIdResponse = {
  headers: map[string]string(name='headers'),
  body: PageableQueryExperimentTaskByExperimentIdResponseBody(name='body'),
}

async function pageableQueryExperimentTaskByExperimentId(request: PageableQueryExperimentTaskByExperimentIdRequest): PageableQueryExperimentTaskByExperimentIdResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PageableQueryExperimentTaskByExperimentId', 'POST', '/', 'json', false, 'json', request);
}

model PageableQueryUserExperimentRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  namespace?: string(name='Namespace', position='Query'),
  page?: int32(name='Page', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  results?: [ string ](name='Results', position='Query'),
  searchKey?: string(name='SearchKey', position='Query'),
  size?: int32(name='Size', position='Query'),
  state?: string(name='State', position='Query'),
  tags?: [ string ](name='Tags', position='Query'),
  workspaceId?: string(name='WorkspaceId', position='Query'),
}

model PageableQueryUserExperimentResponseBody = {
  code?: string(name='Code'),
  currentPage?: int32(name='CurrentPage'),
  experimentList?: [ 
    {
      createTime?: long(name='CreateTime'),
      creator?: string(name='Creator'),
      experimentId?: string(name='ExperimentId'),
      miniApps?: [ string ](name='MiniApps'),
      name?: string(name='Name'),
      permission?: int32(name='Permission'),
      result?: string(name='Result'),
      state?: string(name='State'),
      tags?: [ string ](name='Tags'),
    }
  ](name='ExperimentList'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  pageSize?: int32(name='PageSize'),
  pages?: int32(name='Pages'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model PageableQueryUserExperimentResponse = {
  headers: map[string]string(name='headers'),
  body: PageableQueryUserExperimentResponseBody(name='body'),
}

async function pageableQueryUserExperiment(request: PageableQueryUserExperimentRequest): PageableQueryUserExperimentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PageableQueryUserExperiment', 'POST', '/', 'json', false, 'json', request);
}

model PushExperimentTaskRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  experimentTaskId: string(name='ExperimentTaskId', position='Query'),
  nameSpace?: string(name='NameSpace', position='Query'),
}

model PushExperimentTaskResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PushExperimentTaskResponse = {
  headers: map[string]string(name='headers'),
  body: PushExperimentTaskResponseBody(name='body'),
}

async function pushExperimentTask(request: PushExperimentTaskRequest): PushExperimentTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PushExperimentTask', 'POST', '/', 'json', false, 'json', request);
}

model UpdateExperimentRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  definition?: string(name='Definition', position='Query'),
  description?: string(name='Description', position='Query'),
  experimentId: string(name='ExperimentId', position='Query'),
  name?: string(name='Name', position='Query'),
  nameSpace: string(name='NameSpace', position='Query'),
  tags?: [ string ](name='Tags', position='Query'),
}

model UpdateExperimentResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateExperimentResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateExperimentResponseBody(name='body'),
}

async function updateExperiment(request: UpdateExperimentRequest): UpdateExperimentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateExperiment', 'POST', '/', 'json', false, 'json', request);
}

model UpdateExperimentBasicInfoRequest {
  ahasRegionId?: string(name='AhasRegionId', position='Query'),
  description?: string(name='Description', position='Query'),
  experimentId?: string(name='ExperimentId', position='Query'),
  name?: string(name='Name', position='Query'),
  nameSpace?: string(name='NameSpace', position='Query'),
  tags?: [ string ](name='Tags', position='Query'),
}

model UpdateExperimentBasicInfoResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateExperimentBasicInfoResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateExperimentBasicInfoResponseBody(name='body'),
}

async function updateExperimentBasicInfo(request: UpdateExperimentBasicInfoRequest): UpdateExperimentBasicInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateExperimentBasicInfo', 'POST', '/', 'json', false, 'json', request);
}

