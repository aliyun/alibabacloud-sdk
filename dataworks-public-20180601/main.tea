/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    ap-northeast-1 = 'dataworks.ap-northeast-1.aliyuncs.com',
    ap-south-1 = 'dataworks.ap-south-1.aliyuncs.com',
    ap-southeast-1 = 'dataworks.ap-southeast-1.aliyuncs.com',
    ap-southeast-2 = 'dataworks.ap-southeast-2.aliyuncs.com',
    ap-southeast-3 = 'dataworks.ap-southeast-3.aliyuncs.com',
    ap-southeast-5 = 'dataworks.ap-southeast-5.aliyuncs.com',
    cn-beijing = 'dataworks.cn-beijing.aliyuncs.com',
    cn-chengdu = 'dataworks.cn-chengdu.aliyuncs.com',
    cn-hangzhou = 'dataworks.cn-hangzhou.aliyuncs.com',
    cn-hongkong = 'dataworks.cn-hongkong.aliyuncs.com',
    cn-huhehaote = 'dataworks.aliyuncs.com',
    cn-qingdao = 'dataworks.aliyuncs.com',
    cn-shanghai = 'dataworks.cn-shanghai.aliyuncs.com',
    cn-shenzhen = 'dataworks.cn-shenzhen.aliyuncs.com',
    cn-zhangjiakou = 'dataworks.aliyuncs.com',
    eu-central-1 = 'dataworks.eu-central-1.aliyuncs.com',
    eu-west-1 = 'dataworks.eu-west-1.aliyuncs.com',
    me-east-1 = 'dataworks.me-east-1.aliyuncs.com',
    us-east-1 = 'dataworks.us-east-1.aliyuncs.com',
    us-west-1 = 'dataworks.us-west-1.aliyuncs.com',
    cn-hangzhou-finance = 'dataworks.aliyuncs.com',
    cn-shenzhen-finance-1 = 'dataworks.aliyuncs.com',
    cn-shanghai-finance-1 = 'dataworks.aliyuncs.com',
    cn-north-2-gov-1 = 'dataworks.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('dataworks-public', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model CheckCallbackRequest {
  callbackResultString?: string(name='CallbackResultString'),
}

model CheckCallbackResponseBody = {
  requestId?: string(name='RequestId'),
  returnCode?: string(name='ReturnCode'),
  returnValue?: boolean(name='ReturnValue'),
}

model CheckCallbackResponse = {
  headers: map[string]string(name='headers'),
  body: CheckCallbackResponseBody(name='body'),
}

async function checkCallbackWithOptions(request: CheckCallbackRequest, runtime: Util.RuntimeOptions): CheckCallbackResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.callbackResultString)) {
    body['CallbackResultString'] = request.callbackResultString;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CheckCallback',
    version = '2018-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkCallback(request: CheckCallbackRequest): CheckCallbackResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkCallbackWithOptions(request, runtime);
}

model CreateDISyncAlarmRuleRequest {
  alarmInterval?: int32(name='AlarmInterval'),
  alarmReceivers?: string(name='AlarmReceivers'),
  alarmRobotAtAllEnabled?: boolean(name='AlarmRobotAtAllEnabled'),
  alarmRobotTokens?: string(name='AlarmRobotTokens'),
  criticalAlarmModes?: string(name='CriticalAlarmModes'),
  criticalMetricRule?: string(name='CriticalMetricRule'),
  fileId?: long(name='FileId'),
  metricType?: string(name='MetricType'),
  projectEnv?: string(name='ProjectEnv'),
  projectId?: long(name='ProjectId'),
  ruleDescription?: string(name='RuleDescription'),
  ruleName?: string(name='RuleName'),
  warningAlarmModes?: string(name='WarningAlarmModes'),
  warningMetricRule?: string(name='WarningMetricRule'),
}

model CreateDISyncAlarmRuleResponseBody = {
  requestId?: string(name='RequestId'),
  ruleId?: long(name='RuleId'),
}

model CreateDISyncAlarmRuleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDISyncAlarmRuleResponseBody(name='body'),
}

async function createDISyncAlarmRuleWithOptions(request: CreateDISyncAlarmRuleRequest, runtime: Util.RuntimeOptions): CreateDISyncAlarmRuleResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.alarmInterval)) {
    body['AlarmInterval'] = request.alarmInterval;
  }
  if (!Util.isUnset(request.alarmReceivers)) {
    body['AlarmReceivers'] = request.alarmReceivers;
  }
  if (!Util.isUnset(request.alarmRobotAtAllEnabled)) {
    body['AlarmRobotAtAllEnabled'] = request.alarmRobotAtAllEnabled;
  }
  if (!Util.isUnset(request.alarmRobotTokens)) {
    body['AlarmRobotTokens'] = request.alarmRobotTokens;
  }
  if (!Util.isUnset(request.criticalAlarmModes)) {
    body['CriticalAlarmModes'] = request.criticalAlarmModes;
  }
  if (!Util.isUnset(request.criticalMetricRule)) {
    body['CriticalMetricRule'] = request.criticalMetricRule;
  }
  if (!Util.isUnset(request.fileId)) {
    body['FileId'] = request.fileId;
  }
  if (!Util.isUnset(request.metricType)) {
    body['MetricType'] = request.metricType;
  }
  if (!Util.isUnset(request.projectEnv)) {
    body['ProjectEnv'] = request.projectEnv;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.ruleDescription)) {
    body['RuleDescription'] = request.ruleDescription;
  }
  if (!Util.isUnset(request.ruleName)) {
    body['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.warningAlarmModes)) {
    body['WarningAlarmModes'] = request.warningAlarmModes;
  }
  if (!Util.isUnset(request.warningMetricRule)) {
    body['WarningMetricRule'] = request.warningMetricRule;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDISyncAlarmRule',
    version = '2018-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDISyncAlarmRule(request: CreateDISyncAlarmRuleRequest): CreateDISyncAlarmRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDISyncAlarmRuleWithOptions(request, runtime);
}

model CreateManualDagRequest {
  bizdate?: string(name='Bizdate'),
  dagPara?: string(name='DagPara'),
  flowName?: string(name='FlowName'),
  nodePara?: string(name='NodePara'),
  projectName?: string(name='ProjectName'),
}

model CreateManualDagResponseBody = {
  requestId?: string(name='RequestId'),
  returnCode?: string(name='ReturnCode'),
  returnErrorSolution?: string(name='ReturnErrorSolution'),
  returnMessage?: string(name='ReturnMessage'),
  returnValue?: long(name='ReturnValue'),
}

model CreateManualDagResponse = {
  headers: map[string]string(name='headers'),
  body: CreateManualDagResponseBody(name='body'),
}

async function createManualDagWithOptions(request: CreateManualDagRequest, runtime: Util.RuntimeOptions): CreateManualDagResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizdate)) {
    query['Bizdate'] = request.bizdate;
  }
  if (!Util.isUnset(request.dagPara)) {
    query['DagPara'] = request.dagPara;
  }
  if (!Util.isUnset(request.flowName)) {
    query['FlowName'] = request.flowName;
  }
  if (!Util.isUnset(request.nodePara)) {
    query['NodePara'] = request.nodePara;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateManualDag',
    version = '2018-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createManualDag(request: CreateManualDagRequest): CreateManualDagResponse {
  var runtime = new Util.RuntimeOptions{};
  return createManualDagWithOptions(request, runtime);
}

model CreateRealTimeProcessRequest {
  autoAddTable?: string(name='AutoAddTable'),
  clearBoundVpcs?: boolean(name='ClearBoundVpcs'),
  clientToken?: string(name='ClientToken'),
  concurrent?: int32(name='Concurrent'),
  createDstTableIfNotExist?: boolean(name='CreateDstTableIfNotExist'),
  createResGroup?: boolean(name='CreateResGroup'),
  dataSource?: string(name='DataSource'),
  dataworksVersion?: string(name='DataworksVersion'),
  memory?: float(name='Memory'),
  projectIdentifier?: string(name='ProjectIdentifier'),
  readSetting?: string(name='ReadSetting'),
  resGroupIdentifier?: string(name='ResGroupIdentifier'),
  resourceSpec?: string(name='ResourceSpec'),
  tableRule?: string(name='TableRule'),
  tables?: string(name='Tables'),
  taskMode?: string(name='TaskMode'),
  useExistResGroup?: boolean(name='UseExistResGroup'),
  writeSetting?: string(name='WriteSetting'),
}

model CreateRealTimeProcessResponseBody = {
  code?: int32(name='Code'),
  data?: {
    taskId?: string(name='TaskId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model CreateRealTimeProcessResponse = {
  headers: map[string]string(name='headers'),
  body: CreateRealTimeProcessResponseBody(name='body'),
}

async function createRealTimeProcessWithOptions(request: CreateRealTimeProcessRequest, runtime: Util.RuntimeOptions): CreateRealTimeProcessResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoAddTable)) {
    query['AutoAddTable'] = request.autoAddTable;
  }
  if (!Util.isUnset(request.clearBoundVpcs)) {
    query['ClearBoundVpcs'] = request.clearBoundVpcs;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.concurrent)) {
    query['Concurrent'] = request.concurrent;
  }
  if (!Util.isUnset(request.createDstTableIfNotExist)) {
    query['CreateDstTableIfNotExist'] = request.createDstTableIfNotExist;
  }
  if (!Util.isUnset(request.createResGroup)) {
    query['CreateResGroup'] = request.createResGroup;
  }
  if (!Util.isUnset(request.dataSource)) {
    query['DataSource'] = request.dataSource;
  }
  if (!Util.isUnset(request.dataworksVersion)) {
    query['DataworksVersion'] = request.dataworksVersion;
  }
  if (!Util.isUnset(request.memory)) {
    query['Memory'] = request.memory;
  }
  if (!Util.isUnset(request.projectIdentifier)) {
    query['ProjectIdentifier'] = request.projectIdentifier;
  }
  if (!Util.isUnset(request.readSetting)) {
    query['ReadSetting'] = request.readSetting;
  }
  if (!Util.isUnset(request.resGroupIdentifier)) {
    query['ResGroupIdentifier'] = request.resGroupIdentifier;
  }
  if (!Util.isUnset(request.resourceSpec)) {
    query['ResourceSpec'] = request.resourceSpec;
  }
  if (!Util.isUnset(request.tableRule)) {
    query['TableRule'] = request.tableRule;
  }
  if (!Util.isUnset(request.tables)) {
    query['Tables'] = request.tables;
  }
  if (!Util.isUnset(request.taskMode)) {
    query['TaskMode'] = request.taskMode;
  }
  if (!Util.isUnset(request.useExistResGroup)) {
    query['UseExistResGroup'] = request.useExistResGroup;
  }
  if (!Util.isUnset(request.writeSetting)) {
    query['WriteSetting'] = request.writeSetting;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateRealTimeProcess',
    version = '2018-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createRealTimeProcess(request: CreateRealTimeProcessRequest): CreateRealTimeProcessResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRealTimeProcessWithOptions(request, runtime);
}

model DeleteDISyncAlarmRuleRequest {
  projectId?: long(name='ProjectId'),
  ruleId?: long(name='RuleId'),
}

model DeleteDISyncAlarmRuleResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteDISyncAlarmRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDISyncAlarmRuleResponseBody(name='body'),
}

async function deleteDISyncAlarmRuleWithOptions(request: DeleteDISyncAlarmRuleRequest, runtime: Util.RuntimeOptions): DeleteDISyncAlarmRuleResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.ruleId)) {
    body['RuleId'] = request.ruleId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDISyncAlarmRule',
    version = '2018-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDISyncAlarmRule(request: DeleteDISyncAlarmRuleRequest): DeleteDISyncAlarmRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDISyncAlarmRuleWithOptions(request, runtime);
}

model DeleteDISyncTaskRequest {
  fileId?: long(name='FileId'),
  projectId?: long(name='ProjectId'),
}

model DeleteDISyncTaskResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDISyncTaskResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDISyncTaskResponseBody(name='body'),
}

async function deleteDISyncTaskWithOptions(request: DeleteDISyncTaskRequest, runtime: Util.RuntimeOptions): DeleteDISyncTaskResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.fileId)) {
    body['FileId'] = request.fileId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDISyncTask',
    version = '2018-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDISyncTask(request: DeleteDISyncTaskRequest): DeleteDISyncTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDISyncTaskWithOptions(request, runtime);
}

model DeleteFileRequest {
  fileId?: long(name='FileId'),
  projectId?: long(name='ProjectId'),
  projectIdentifier?: string(name='ProjectIdentifier'),
}

model DeleteFileResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteFileResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFileResponseBody(name='body'),
}

async function deleteFileWithOptions(request: DeleteFileRequest, runtime: Util.RuntimeOptions): DeleteFileResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.fileId)) {
    body['FileId'] = request.fileId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.projectIdentifier)) {
    body['ProjectIdentifier'] = request.projectIdentifier;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFile',
    version = '2018-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteFile(request: DeleteFileRequest): DeleteFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFileWithOptions(request, runtime);
}

model DeployDISyncTaskRequest {
  fileId?: long(name='FileId'),
  projectId?: long(name='ProjectId'),
}

model DeployDISyncTaskResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeployDISyncTaskResponse = {
  headers: map[string]string(name='headers'),
  body: DeployDISyncTaskResponseBody(name='body'),
}

async function deployDISyncTaskWithOptions(request: DeployDISyncTaskRequest, runtime: Util.RuntimeOptions): DeployDISyncTaskResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.fileId)) {
    body['FileId'] = request.fileId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeployDISyncTask',
    version = '2018-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deployDISyncTask(request: DeployDISyncTaskRequest): DeployDISyncTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return deployDISyncTaskWithOptions(request, runtime);
}

model DescribeEmrHiveTableRequest {
  clusterId?: string(name='ClusterId'),
  databaseName?: string(name='DatabaseName'),
  tableName?: string(name='TableName'),
}

model DescribeEmrHiveTableResponseBody = {
  data?: {
    clusterBizId?: string(name='ClusterBizId'),
    clusterBizName?: string(name='ClusterBizName'),
    columns?: [ 
      {
        columnComment?: string(name='ColumnComment'),
        columnName?: string(name='ColumnName'),
        columnPosition?: int32(name='ColumnPosition'),
        columnType?: string(name='ColumnType'),
        comment?: string(name='Comment'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
      }
    ](name='Columns'),
    databaseName?: string(name='DatabaseName'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    inputFormat?: string(name='InputFormat'),
    isCompressed?: boolean(name='IsCompressed'),
    isTemporary?: boolean(name='IsTemporary'),
    lastAccessTime?: string(name='LastAccessTime'),
    lastModifyTime?: string(name='LastModifyTime'),
    location?: string(name='Location'),
    outputFormat?: string(name='OutputFormat'),
    owner?: string(name='Owner'),
    ownerId?: string(name='OwnerId'),
    ownerType?: string(name='OwnerType'),
    partitionKeys?: string(name='PartitionKeys'),
    serializationLib?: string(name='SerializationLib'),
    tableComment?: string(name='TableComment'),
    tableDesc?: string(name='TableDesc'),
    tableName?: string(name='TableName'),
    tableParameters?: string(name='TableParameters'),
    tableSize?: long(name='TableSize'),
    tableType?: string(name='TableType'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
}

model DescribeEmrHiveTableResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEmrHiveTableResponseBody(name='body'),
}

async function describeEmrHiveTableWithOptions(request: DescribeEmrHiveTableRequest, runtime: Util.RuntimeOptions): DescribeEmrHiveTableResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeEmrHiveTable',
    version = '2018-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeEmrHiveTable(request: DescribeEmrHiveTableRequest): DescribeEmrHiveTableResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEmrHiveTableWithOptions(request, runtime);
}

model GetDISyncAlarmRuleRequest {
  projectId?: long(name='ProjectId'),
  ruleId?: long(name='RuleId'),
}

model GetDISyncAlarmRuleResponseBody = {
  alarmRule?: {
    alarmInterval?: int32(name='AlarmInterval'),
    alarmReceivers?: [ string ](name='AlarmReceivers'),
    alarmRobotAtAllEnabled?: boolean(name='AlarmRobotAtAllEnabled'),
    alarmRobotTokens?: [ string ](name='AlarmRobotTokens'),
    criticalAlarmModes?: [ string ](name='CriticalAlarmModes'),
    criticalMetricRule?: {
      duration?: long(name='Duration'),
      threshold?: long(name='Threshold'),
    }(name='CriticalMetricRule'),
    fileId?: long(name='FileId'),
    metricType?: string(name='MetricType'),
    projectEnv?: string(name='ProjectEnv'),
    projectId?: long(name='ProjectId'),
    ruleDescription?: string(name='RuleDescription'),
    ruleEnabled?: boolean(name='RuleEnabled'),
    ruleId?: long(name='RuleId'),
    ruleName?: string(name='RuleName'),
    warningAlarmModes?: [ string ](name='WarningAlarmModes'),
    warningMetricRule?: {
      duration?: long(name='Duration'),
      threshold?: long(name='Threshold'),
    }(name='WarningMetricRule'),
  }(name='AlarmRule'),
  requestId?: string(name='RequestId'),
}

model GetDISyncAlarmRuleResponse = {
  headers: map[string]string(name='headers'),
  body: GetDISyncAlarmRuleResponseBody(name='body'),
}

async function getDISyncAlarmRuleWithOptions(request: GetDISyncAlarmRuleRequest, runtime: Util.RuntimeOptions): GetDISyncAlarmRuleResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.ruleId)) {
    body['RuleId'] = request.ruleId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetDISyncAlarmRule',
    version = '2018-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDISyncAlarmRule(request: GetDISyncAlarmRuleRequest): GetDISyncAlarmRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDISyncAlarmRuleWithOptions(request, runtime);
}

model GetDISyncInstanceInfoRequest {
  fileId?: long(name='FileId'),
  projectId?: long(name='ProjectId'),
}

model GetDISyncInstanceInfoResponseBody = {
  data?: {
    eventTimedelayInMills?: long(name='EventTimedelayInMills'),
    name?: string(name='Name'),
    status?: string(name='Status'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetDISyncInstanceInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetDISyncInstanceInfoResponseBody(name='body'),
}

async function getDISyncInstanceInfoWithOptions(request: GetDISyncInstanceInfoRequest, runtime: Util.RuntimeOptions): GetDISyncInstanceInfoResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.fileId)) {
    body['FileId'] = request.fileId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetDISyncInstanceInfo',
    version = '2018-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDISyncInstanceInfo(request: GetDISyncInstanceInfoRequest): GetDISyncInstanceInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDISyncInstanceInfoWithOptions(request, runtime);
}

model GetDISyncTaskRequest {
  fileId?: long(name='FileId'),
  projectId?: long(name='ProjectId'),
}

model GetDISyncTaskResponseBody = {
  data?: {
    concurrent?: int32(name='Concurrent'),
    dstDatasourceName?: string(name='DstDatasourceName'),
    fileId?: long(name='FileId'),
    fileName?: string(name='FileName'),
    memory?: float(name='Memory'),
    projectId?: long(name='ProjectId'),
    projectIdentifier?: string(name='ProjectIdentifier'),
    resGroupIdentifier?: string(name='ResGroupIdentifier'),
    srcDatasourceName?: string(name='SrcDatasourceName'),
    tableMapping?: [ 
      {
        dstTable?: string(name='DstTable'),
        srcTable?: string(name='SrcTable'),
      }
    ](name='TableMapping'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetDISyncTaskResponse = {
  headers: map[string]string(name='headers'),
  body: GetDISyncTaskResponseBody(name='body'),
}

async function getDISyncTaskWithOptions(request: GetDISyncTaskRequest, runtime: Util.RuntimeOptions): GetDISyncTaskResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.fileId)) {
    body['FileId'] = request.fileId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetDISyncTask',
    version = '2018-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDISyncTask(request: GetDISyncTaskRequest): GetDISyncTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDISyncTaskWithOptions(request, runtime);
}

model GetSwitchValueRequest {
  switchName?: string(name='SwitchName'),
}

model GetSwitchValueResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetSwitchValueResponse = {
  headers: map[string]string(name='headers'),
  body: GetSwitchValueResponseBody(name='body'),
}

async function getSwitchValueWithOptions(request: GetSwitchValueRequest, runtime: Util.RuntimeOptions): GetSwitchValueResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.switchName)) {
    query['SwitchName'] = request.switchName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSwitchValue',
    version = '2018-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSwitchValue(request: GetSwitchValueRequest): GetSwitchValueResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSwitchValueWithOptions(request, runtime);
}

model ListDISyncAlarmRulesRequest {
  fileId?: long(name='FileId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  projectEnv?: string(name='ProjectEnv'),
  projectId?: long(name='ProjectId'),
}

model ListDISyncAlarmRulesResponseBody = {
  alarmRulePageResult?: {
    alarmRules?: [ 
      {
        alarmInterval?: int32(name='AlarmInterval'),
        alarmReceivers?: [ string ](name='AlarmReceivers'),
        alarmRobotAtAllEnabled?: boolean(name='AlarmRobotAtAllEnabled'),
        alarmRobotTokens?: [ string ](name='AlarmRobotTokens'),
        criticalAlarmModes?: [ string ](name='CriticalAlarmModes'),
        criticalMetricRule?: {
          duration?: long(name='Duration'),
          threshold?: long(name='Threshold'),
        }(name='CriticalMetricRule'),
        fileId?: long(name='FileId'),
        metricType?: string(name='MetricType'),
        projectEnv?: string(name='ProjectEnv'),
        projectId?: long(name='ProjectId'),
        ruleDescription?: string(name='RuleDescription'),
        ruleEnabled?: boolean(name='RuleEnabled'),
        ruleId?: long(name='RuleId'),
        ruleName?: string(name='RuleName'),
        warningAlarmModes?: [ string ](name='WarningAlarmModes'),
        warningMetricRule?: {
          duration?: long(name='Duration'),
          threshold?: long(name='Threshold'),
        }(name='WarningMetricRule'),
      }
    ](name='AlarmRules'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='AlarmRulePageResult'),
  requestId?: string(name='RequestId'),
}

model ListDISyncAlarmRulesResponse = {
  headers: map[string]string(name='headers'),
  body: ListDISyncAlarmRulesResponseBody(name='body'),
}

async function listDISyncAlarmRulesWithOptions(request: ListDISyncAlarmRulesRequest, runtime: Util.RuntimeOptions): ListDISyncAlarmRulesResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.fileId)) {
    body['FileId'] = request.fileId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectEnv)) {
    body['ProjectEnv'] = request.projectEnv;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListDISyncAlarmRules',
    version = '2018-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDISyncAlarmRules(request: ListDISyncAlarmRulesRequest): ListDISyncAlarmRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDISyncAlarmRulesWithOptions(request, runtime);
}

model ListEmrHiveAuditLogsRequest {
  clusterId?: string(name='ClusterId'),
  databaseName?: string(name='DatabaseName'),
  endTime?: int32(name='EndTime'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  startTime?: int32(name='StartTime'),
  tableName?: string(name='TableName'),
}

model ListEmrHiveAuditLogsResponseBody = {
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    pagedData?: [ 
      {
        database?: string(name='Database'),
        eventTime?: long(name='EventTime'),
        groups?: [ string ](name='Groups'),
        operation?: string(name='Operation'),
        table?: string(name='Table'),
        user?: string(name='User'),
      }
    ](name='PagedData'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
}

model ListEmrHiveAuditLogsResponse = {
  headers: map[string]string(name='headers'),
  body: ListEmrHiveAuditLogsResponseBody(name='body'),
}

async function listEmrHiveAuditLogsWithOptions(request: ListEmrHiveAuditLogsRequest, runtime: Util.RuntimeOptions): ListEmrHiveAuditLogsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListEmrHiveAuditLogs',
    version = '2018-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listEmrHiveAuditLogs(request: ListEmrHiveAuditLogsRequest): ListEmrHiveAuditLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEmrHiveAuditLogsWithOptions(request, runtime);
}

model ListEmrHiveDatabasesRequest {
  clusterId?: string(name='ClusterId'),
}

model ListEmrHiveDatabasesResponseBody = {
  data?: [ 
    {
      comment?: string(name='Comment'),
      gmtCreate?: long(name='GmtCreate'),
      gmtModified?: long(name='GmtModified'),
      location?: string(name='Location'),
      name?: string(name='Name'),
      owner?: string(name='Owner'),
      ownerId?: string(name='OwnerId'),
      ownerType?: string(name='OwnerType'),
      parameters?: string(name='Parameters'),
      region?: string(name='Region'),
      status?: string(name='Status'),
      type?: string(name='Type'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
}

model ListEmrHiveDatabasesResponse = {
  headers: map[string]string(name='headers'),
  body: ListEmrHiveDatabasesResponseBody(name='body'),
}

async function listEmrHiveDatabasesWithOptions(request: ListEmrHiveDatabasesRequest, runtime: Util.RuntimeOptions): ListEmrHiveDatabasesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListEmrHiveDatabases',
    version = '2018-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listEmrHiveDatabases(request: ListEmrHiveDatabasesRequest): ListEmrHiveDatabasesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEmrHiveDatabasesWithOptions(request, runtime);
}

model ListEmrHiveTablesRequest {
  clusterId?: string(name='ClusterId'),
  databaseName?: string(name='DatabaseName'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListEmrHiveTablesResponseBody = {
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    pagedData?: [ 
      {
        clusterBizId?: string(name='ClusterBizId'),
        clusterBizName?: string(name='ClusterBizName'),
        databaseName?: string(name='DatabaseName'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        inputFormat?: string(name='InputFormat'),
        isCompressed?: boolean(name='IsCompressed'),
        isTemporary?: boolean(name='IsTemporary'),
        lastAccessTime?: string(name='LastAccessTime'),
        lastModifyTime?: string(name='LastModifyTime'),
        location?: string(name='Location'),
        outputFormat?: string(name='OutputFormat'),
        owner?: string(name='Owner'),
        ownerId?: string(name='OwnerId'),
        ownerType?: string(name='OwnerType'),
        partitionKeys?: string(name='PartitionKeys'),
        serializationLib?: string(name='SerializationLib'),
        tableComment?: string(name='TableComment'),
        tableDesc?: string(name='TableDesc'),
        tableName?: string(name='TableName'),
        tableParameters?: string(name='TableParameters'),
        tableType?: string(name='TableType'),
      }
    ](name='PagedData'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
}

model ListEmrHiveTablesResponse = {
  headers: map[string]string(name='headers'),
  body: ListEmrHiveTablesResponseBody(name='body'),
}

async function listEmrHiveTablesWithOptions(request: ListEmrHiveTablesRequest, runtime: Util.RuntimeOptions): ListEmrHiveTablesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListEmrHiveTables',
    version = '2018-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listEmrHiveTables(request: ListEmrHiveTablesRequest): ListEmrHiveTablesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEmrHiveTablesWithOptions(request, runtime);
}

model ListHiveColumnLineagesRequest {
  clusterId?: string(name='ClusterId'),
  columnName?: string(name='ColumnName'),
  databaseName?: string(name='DatabaseName'),
  tableName?: string(name='TableName'),
}

model ListHiveColumnLineagesResponseBody = {
  data?: {
    downstreamLineages?: [ 
      {
        clusterId?: string(name='ClusterId'),
        columnName?: string(name='ColumnName'),
        createTime?: string(name='CreateTime'),
        databaseName?: string(name='DatabaseName'),
        directDownColumnNumber?: int32(name='DirectDownColumnNumber'),
        directDownTableNumber?: int32(name='DirectDownTableNumber'),
        directUpperColumnNumber?: int32(name='DirectUpperColumnNumber'),
        directUpperTableNumber?: int32(name='DirectUpperTableNumber'),
        modifiedTime?: string(name='ModifiedTime'),
        source?: string(name='Source'),
        tableName?: string(name='TableName'),
      }
    ](name='DownstreamLineages'),
    downstreamNumber?: int32(name='DownstreamNumber'),
    upstreamLineages?: [ 
      {
        clusterId?: string(name='ClusterId'),
        columnName?: string(name='ColumnName'),
        createTime?: string(name='CreateTime'),
        databaseName?: string(name='DatabaseName'),
        directDownColumnNumber?: int32(name='DirectDownColumnNumber'),
        directDownTableNumber?: int32(name='DirectDownTableNumber'),
        directUpperColumnNumber?: int32(name='DirectUpperColumnNumber'),
        directUpperTableNumber?: int32(name='DirectUpperTableNumber'),
        modifiedTime?: string(name='ModifiedTime'),
        source?: string(name='Source'),
        tableName?: string(name='TableName'),
      }
    ](name='UpstreamLineages'),
    upstreamNumber?: int32(name='UpstreamNumber'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
}

model ListHiveColumnLineagesResponse = {
  headers: map[string]string(name='headers'),
  body: ListHiveColumnLineagesResponseBody(name='body'),
}

async function listHiveColumnLineagesWithOptions(request: ListHiveColumnLineagesRequest, runtime: Util.RuntimeOptions): ListHiveColumnLineagesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.columnName)) {
    query['ColumnName'] = request.columnName;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListHiveColumnLineages',
    version = '2018-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listHiveColumnLineages(request: ListHiveColumnLineagesRequest): ListHiveColumnLineagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listHiveColumnLineagesWithOptions(request, runtime);
}

model ListHiveTableLineagesRequest {
  clusterId?: string(name='ClusterId'),
  databaseName?: string(name='DatabaseName'),
  tableName?: string(name='TableName'),
}

model ListHiveTableLineagesResponseBody = {
  data?: {
    downstreamLineages?: [ 
      {
        clusterId?: string(name='ClusterId'),
        createTime?: string(name='CreateTime'),
        databaseName?: string(name='DatabaseName'),
        engine?: string(name='Engine'),
        jobId?: string(name='JobId'),
        modifiedTime?: string(name='ModifiedTime'),
        queryText?: string(name='QueryText'),
        source?: string(name='Source'),
        tableName?: string(name='TableName'),
      }
    ](name='DownstreamLineages'),
    downstreamNumber?: int32(name='DownstreamNumber'),
    upstreamLineages?: [ 
      {
        clusterId?: string(name='ClusterId'),
        createTime?: string(name='CreateTime'),
        databaseName?: string(name='DatabaseName'),
        engine?: string(name='Engine'),
        jobId?: string(name='JobId'),
        modifiedTime?: string(name='ModifiedTime'),
        queryText?: string(name='QueryText'),
        source?: string(name='Source'),
        tableName?: string(name='TableName'),
      }
    ](name='UpstreamLineages'),
    upstreamNumber?: int32(name='UpstreamNumber'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
}

model ListHiveTableLineagesResponse = {
  headers: map[string]string(name='headers'),
  body: ListHiveTableLineagesResponseBody(name='body'),
}

async function listHiveTableLineagesWithOptions(request: ListHiveTableLineagesRequest, runtime: Util.RuntimeOptions): ListHiveTableLineagesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListHiveTableLineages',
    version = '2018-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listHiveTableLineages(request: ListHiveTableLineagesRequest): ListHiveTableLineagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listHiveTableLineagesWithOptions(request, runtime);
}

model ListTablePartitionsRequest {
  clusterId?: string(name='ClusterId'),
  databaseName?: string(name='DatabaseName'),
  order?: string(name='Order'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  tableName?: string(name='TableName'),
}

model ListTablePartitionsResponseBody = {
  data?: {
    pageSize?: int32(name='PageSize'),
    pagedData?: [ 
      {
        gmtCreate?: long(name='GmtCreate'),
        gmtModified?: long(name='GmtModified'),
        location?: string(name='Location'),
        partitionComment?: string(name='PartitionComment'),
        partitionName?: string(name='PartitionName'),
        partitionPath?: string(name='PartitionPath'),
        partitionType?: string(name='PartitionType'),
      }
    ](name='PagedData'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
}

model ListTablePartitionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListTablePartitionsResponseBody(name='body'),
}

async function listTablePartitionsWithOptions(request: ListTablePartitionsRequest, runtime: Util.RuntimeOptions): ListTablePartitionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTablePartitions',
    version = '2018-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTablePartitions(request: ListTablePartitionsRequest): ListTablePartitionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTablePartitionsWithOptions(request, runtime);
}

model OpenDataWorksStandardServiceRequest {
  region?: string(name='Region'),
}

model OpenDataWorksStandardServiceResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model OpenDataWorksStandardServiceResponse = {
  headers: map[string]string(name='headers'),
  body: OpenDataWorksStandardServiceResponseBody(name='body'),
}

async function openDataWorksStandardServiceWithOptions(request: OpenDataWorksStandardServiceRequest, runtime: Util.RuntimeOptions): OpenDataWorksStandardServiceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OpenDataWorksStandardService',
    version = '2018-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function openDataWorksStandardService(request: OpenDataWorksStandardServiceRequest): OpenDataWorksStandardServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return openDataWorksStandardServiceWithOptions(request, runtime);
}

model QueryDataImportProcessRequest {
  subUid?: string(name='SubUid'),
}

model QueryDataImportProcessResponseBody = {
  code?: int32(name='Code'),
  data?: {
    taskId?: string(name='TaskId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model QueryDataImportProcessResponse = {
  headers: map[string]string(name='headers'),
  body: QueryDataImportProcessResponseBody(name='body'),
}

async function queryDataImportProcessWithOptions(request: QueryDataImportProcessRequest, runtime: Util.RuntimeOptions): QueryDataImportProcessResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.subUid)) {
    query['SubUid'] = request.subUid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDataImportProcess',
    version = '2018-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryDataImportProcess(request: QueryDataImportProcessRequest): QueryDataImportProcessResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDataImportProcessWithOptions(request, runtime);
}

model QueryDataImportProcessStatusRequest {
  taskId?: string(name='TaskId'),
}

model QueryDataImportProcessStatusResponseBody = {
  code?: int32(name='Code'),
  data?: {
    message?: string(name='Message'),
    projectList?: [ 
      {
        projectId?: string(name='ProjectId'),
        projectIdentifier?: string(name='ProjectIdentifier'),
        projectName?: string(name='ProjectName'),
      }
    ](name='ProjectList'),
    status?: string(name='Status'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model QueryDataImportProcessStatusResponse = {
  headers: map[string]string(name='headers'),
  body: QueryDataImportProcessStatusResponseBody(name='body'),
}

async function queryDataImportProcessStatusWithOptions(request: QueryDataImportProcessStatusRequest, runtime: Util.RuntimeOptions): QueryDataImportProcessStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDataImportProcessStatus',
    version = '2018-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryDataImportProcessStatus(request: QueryDataImportProcessStatusRequest): QueryDataImportProcessStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDataImportProcessStatusWithOptions(request, runtime);
}

model QueryRealTimeProcessStatusRequest {
  taskId?: string(name='TaskId'),
}

model QueryRealTimeProcessStatusResponseBody = {
  code?: int32(name='Code'),
  data?: {
    dataworksOrderId?: string(name='DataworksOrderId'),
    dstDatasourceName?: string(name='DstDatasourceName'),
    fileId?: long(name='FileId'),
    message?: string(name='Message'),
    projectId?: long(name='ProjectId'),
    projectIdentifier?: string(name='ProjectIdentifier'),
    realtimeTaskName?: string(name='RealtimeTaskName'),
    resGroupIdentifier?: string(name='ResGroupIdentifier'),
    resGroupName?: string(name='ResGroupName'),
    resGroupOrderId?: string(name='ResGroupOrderId'),
    srcDatasourceName?: string(name='SrcDatasourceName'),
    status?: string(name='Status'),
    taskId?: string(name='TaskId'),
    taskUrl?: string(name='TaskUrl'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model QueryRealTimeProcessStatusResponse = {
  headers: map[string]string(name='headers'),
  body: QueryRealTimeProcessStatusResponseBody(name='body'),
}

async function queryRealTimeProcessStatusWithOptions(request: QueryRealTimeProcessStatusRequest, runtime: Util.RuntimeOptions): QueryRealTimeProcessStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryRealTimeProcessStatus',
    version = '2018-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryRealTimeProcessStatus(request: QueryRealTimeProcessStatusRequest): QueryRealTimeProcessStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryRealTimeProcessStatusWithOptions(request, runtime);
}

model SearchManualDagNodeInstanceRequest {
  dagId?: long(name='DagId'),
  projectName?: string(name='ProjectName'),
}

model SearchManualDagNodeInstanceResponseBody = {
  data?: {
    nodeInsInfo?: [ 
    {
      beginRunningTime?: string(name='BeginRunningTime'),
      beginWaitResTime?: string(name='BeginWaitResTime'),
      beginWaitTimeTime?: string(name='BeginWaitTimeTime'),
      bizdate?: string(name='Bizdate'),
      createTime?: string(name='CreateTime'),
      dagId?: long(name='DagId'),
      dagType?: int32(name='DagType'),
      finishTime?: string(name='FinishTime'),
      instanceId?: long(name='InstanceId'),
      modifyTime?: string(name='ModifyTime'),
      nodeName?: string(name='NodeName'),
      paraValue?: string(name='ParaValue'),
      status?: int32(name='Status'),
    }
  ](name='NodeInsInfo')
  }(name='Data'),
  errCode?: string(name='ErrCode'),
  errMsg?: string(name='ErrMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SearchManualDagNodeInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: SearchManualDagNodeInstanceResponseBody(name='body'),
}

async function searchManualDagNodeInstanceWithOptions(request: SearchManualDagNodeInstanceRequest, runtime: Util.RuntimeOptions): SearchManualDagNodeInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dagId)) {
    query['DagId'] = request.dagId;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchManualDagNodeInstance',
    version = '2018-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchManualDagNodeInstance(request: SearchManualDagNodeInstanceRequest): SearchManualDagNodeInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchManualDagNodeInstanceWithOptions(request, runtime);
}

model SendTaskMetaCallbackRequest {
  code?: string(name='Code'),
  connectionInfo?: string(name='ConnectionInfo'),
  endTime?: long(name='EndTime'),
  resources?: [ string ](name='Resources'),
  startTime?: long(name='StartTime'),
  subType?: string(name='SubType'),
  taskEnvParam?: string(name='TaskEnvParam'),
  tenantId?: long(name='TenantId'),
  type?: string(name='Type'),
  user?: string(name='User'),
}

model SendTaskMetaCallbackResponseBody = {
  data?: string(name='Data'),
  errMsg?: string(name='ErrMsg'),
  errorCode?: long(name='ErrorCode'),
  requestId?: string(name='RequestId'),
}

model SendTaskMetaCallbackResponse = {
  headers: map[string]string(name='headers'),
  body: SendTaskMetaCallbackResponseBody(name='body'),
}

async function sendTaskMetaCallbackWithOptions(request: SendTaskMetaCallbackRequest, runtime: Util.RuntimeOptions): SendTaskMetaCallbackResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.code)) {
    body['Code'] = request.code;
  }
  if (!Util.isUnset(request.connectionInfo)) {
    body['ConnectionInfo'] = request.connectionInfo;
  }
  if (!Util.isUnset(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.resources)) {
    body['Resources'] = request.resources;
  }
  if (!Util.isUnset(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.subType)) {
    body['SubType'] = request.subType;
  }
  if (!Util.isUnset(request.taskEnvParam)) {
    body['TaskEnvParam'] = request.taskEnvParam;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }
  if (!Util.isUnset(request.user)) {
    body['User'] = request.user;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SendTaskMetaCallback',
    version = '2018-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function sendTaskMetaCallback(request: SendTaskMetaCallbackRequest): SendTaskMetaCallbackResponse {
  var runtime = new Util.RuntimeOptions{};
  return sendTaskMetaCallbackWithOptions(request, runtime);
}

model SetSwitchValueRequest {
  switchName?: string(name='SwitchName'),
  switchValue?: string(name='SwitchValue'),
}

model SetSwitchValueResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model SetSwitchValueResponse = {
  headers: map[string]string(name='headers'),
  body: SetSwitchValueResponseBody(name='body'),
}

async function setSwitchValueWithOptions(request: SetSwitchValueRequest, runtime: Util.RuntimeOptions): SetSwitchValueResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.switchName)) {
    query['SwitchName'] = request.switchName;
  }
  if (!Util.isUnset(request.switchValue)) {
    query['SwitchValue'] = request.switchValue;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetSwitchValue',
    version = '2018-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setSwitchValue(request: SetSwitchValueRequest): SetSwitchValueResponse {
  var runtime = new Util.RuntimeOptions{};
  return setSwitchValueWithOptions(request, runtime);
}

model StartCheckQualityRequest {
  callbackResultString?: string(name='CallbackResultString'),
}

model StartCheckQualityResponseBody = {
  requestId?: string(name='RequestId'),
  returnCode?: string(name='ReturnCode'),
  returnValue?: {
    results?: [ 
      {
        actualExpression?: string(name='ActualExpression'),
        actualResult?: [ 
          {
            actualThreshold?: string(name='ActualThreshold'),
            bizDate?: string(name='BizDate'),
            property?: string(name='Property'),
            result?: string(name='Result'),
            status?: long(name='Status'),
          }
        ](name='ActualResult'),
        bizdate?: string(name='Bizdate'),
        blockType?: long(name='BlockType'),
        checkResult?: long(name='CheckResult'),
        checkerName?: string(name='CheckerName'),
        containStrongRule?: long(name='ContainStrongRule'),
        criticalThreshold?: string(name='CriticalThreshold'),
        dateType?: string(name='DateType'),
        entityName?: string(name='EntityName'),
        externalId?: string(name='ExternalId'),
        externalType?: string(name='ExternalType'),
        finishTime?: string(name='FinishTime'),
        ifFixedCheck?: long(name='IfFixedCheck'),
        matchExpression?: string(name='MatchExpression'),
        methodId?: long(name='MethodId'),
        methodName?: string(name='MethodName'),
        projectName?: string(name='ProjectName'),
        property?: string(name='Property'),
        ruleId?: long(name='RuleId'),
        sampleResult?: [ 
          {
            bizDate?: string(name='BizDate'),
            property?: string(name='Property'),
            result?: string(name='Result'),
            status?: long(name='Status'),
          }
        ](name='SampleResult'),
        taskLevel?: long(name='TaskLevel'),
        taskStatus?: long(name='TaskStatus'),
        trend?: string(name='Trend'),
        warningThreshold?: string(name='WarningThreshold'),
        whereCondition?: string(name='WhereCondition'),
      }
    ](name='Results'),
    success?: boolean(name='Success'),
    taskId?: string(name='TaskId'),
  }(name='ReturnValue'),
}

model StartCheckQualityResponse = {
  headers: map[string]string(name='headers'),
  body: StartCheckQualityResponseBody(name='body'),
}

async function startCheckQualityWithOptions(request: StartCheckQualityRequest, runtime: Util.RuntimeOptions): StartCheckQualityResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.callbackResultString)) {
    body['CallbackResultString'] = request.callbackResultString;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'StartCheckQuality',
    version = '2018-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startCheckQuality(request: StartCheckQualityRequest): StartCheckQualityResponse {
  var runtime = new Util.RuntimeOptions{};
  return startCheckQualityWithOptions(request, runtime);
}

model StartCollectQualityRequest {
  callbackResultString?: string(name='CallbackResultString'),
}

model StartCollectQualityResponseBody = {
  requestId?: string(name='RequestId'),
  returnCode?: string(name='ReturnCode'),
  returnValue?: [ 
    {
      actualExpression?: string(name='ActualExpression'),
      bizDate?: string(name='BizDate'),
      callbackUrl?: string(name='CallbackUrl'),
      connection?: string(name='Connection'),
      entityId?: long(name='EntityId'),
      matchExpression?: string(name='MatchExpression'),
      pluginName?: string(name='PluginName'),
      strongMethodSet?: [ 
        {
          colName?: string(name='ColName'),
          isColRule?: boolean(name='IsColRule'),
          isSqlRule?: boolean(name='IsSqlRule'),
          isStrongRule?: boolean(name='IsStrongRule'),
          methodName?: string(name='MethodName'),
          ruleId?: long(name='RuleId'),
        }
      ](name='StrongMethodSet'),
      tableGuid?: string(name='TableGuid'),
      taskId?: string(name='TaskId'),
      weakMethodSet?: [ 
        {
          colName?: string(name='ColName'),
          isColRule?: boolean(name='IsColRule'),
          isSqlRule?: boolean(name='IsSqlRule'),
          isStrongRule?: boolean(name='IsStrongRule'),
          methodName?: string(name='MethodName'),
          ruleId?: long(name='RuleId'),
        }
      ](name='WeakMethodSet'),
    }
  ](name='ReturnValue'),
}

model StartCollectQualityResponse = {
  headers: map[string]string(name='headers'),
  body: StartCollectQualityResponseBody(name='body'),
}

async function startCollectQualityWithOptions(request: StartCollectQualityRequest, runtime: Util.RuntimeOptions): StartCollectQualityResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.callbackResultString)) {
    body['CallbackResultString'] = request.callbackResultString;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'StartCollectQuality',
    version = '2018-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startCollectQuality(request: StartCollectQualityRequest): StartCollectQualityResponse {
  var runtime = new Util.RuntimeOptions{};
  return startCollectQualityWithOptions(request, runtime);
}

model StartDISyncInstanceRequest {
  fileId?: long(name='FileId'),
  projectId?: long(name='ProjectId'),
  startDateTime?: string(name='StartDateTime'),
  timeZone?: string(name='TimeZone'),
}

model StartDISyncInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model StartDISyncInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: StartDISyncInstanceResponseBody(name='body'),
}

async function startDISyncInstanceWithOptions(request: StartDISyncInstanceRequest, runtime: Util.RuntimeOptions): StartDISyncInstanceResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.fileId)) {
    body['FileId'] = request.fileId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.startDateTime)) {
    body['StartDateTime'] = request.startDateTime;
  }
  if (!Util.isUnset(request.timeZone)) {
    body['TimeZone'] = request.timeZone;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'StartDISyncInstance',
    version = '2018-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startDISyncInstance(request: StartDISyncInstanceRequest): StartDISyncInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return startDISyncInstanceWithOptions(request, runtime);
}

model StartTaskQualityRequest {
  callbackResultString?: string(name='CallbackResultString'),
}

model StartTaskQualityResponseBody = {
  requestId?: string(name='RequestId'),
  returnCode?: string(name='ReturnCode'),
  returnValue?: {
    actualExpression?: string(name='ActualExpression'),
    bizDate?: string(name='BizDate'),
    callbackUrl?: string(name='CallbackUrl'),
    connection?: string(name='Connection'),
    entityId?: long(name='EntityId'),
    matchExpression?: string(name='MatchExpression'),
    pluginName?: string(name='PluginName'),
    statisticsFlag?: long(name='StatisticsFlag'),
    strongMethodSet?: [ 
      {
        colName?: string(name='ColName'),
        isColRule?: boolean(name='IsColRule'),
        isSqlRule?: boolean(name='IsSqlRule'),
        isStrongRule?: boolean(name='IsStrongRule'),
        methodName?: string(name='MethodName'),
        ruleId?: long(name='RuleId'),
      }
    ](name='StrongMethodSet'),
    tableGuid?: string(name='TableGuid'),
    taskId?: string(name='TaskId'),
    triggerFlag?: long(name='TriggerFlag'),
    weakMethodSet?: [ 
      {
        colName?: string(name='ColName'),
        isColRule?: boolean(name='IsColRule'),
        isSqlRule?: boolean(name='IsSqlRule'),
        isStrongRule?: boolean(name='IsStrongRule'),
        methodName?: string(name='MethodName'),
        ruleId?: long(name='RuleId'),
      }
    ](name='WeakMethodSet'),
  }(name='ReturnValue'),
}

model StartTaskQualityResponse = {
  headers: map[string]string(name='headers'),
  body: StartTaskQualityResponseBody(name='body'),
}

async function startTaskQualityWithOptions(request: StartTaskQualityRequest, runtime: Util.RuntimeOptions): StartTaskQualityResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.callbackResultString)) {
    body['CallbackResultString'] = request.callbackResultString;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'StartTaskQuality',
    version = '2018-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startTaskQuality(request: StartTaskQualityRequest): StartTaskQualityResponse {
  var runtime = new Util.RuntimeOptions{};
  return startTaskQualityWithOptions(request, runtime);
}

model StopDISyncInstanceRequest {
  fileId?: long(name='FileId'),
  projectId?: long(name='ProjectId'),
}

model StopDISyncInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model StopDISyncInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: StopDISyncInstanceResponseBody(name='body'),
}

async function stopDISyncInstanceWithOptions(request: StopDISyncInstanceRequest, runtime: Util.RuntimeOptions): StopDISyncInstanceResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.fileId)) {
    body['FileId'] = request.fileId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'StopDISyncInstance',
    version = '2018-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopDISyncInstance(request: StopDISyncInstanceRequest): StopDISyncInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopDISyncInstanceWithOptions(request, runtime);
}

model TerminateDISyncInstanceRequest {
  fileId?: long(name='FileId'),
  projectId?: long(name='ProjectId'),
}

model TerminateDISyncInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model TerminateDISyncInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: TerminateDISyncInstanceResponseBody(name='body'),
}

async function terminateDISyncInstanceWithOptions(request: TerminateDISyncInstanceRequest, runtime: Util.RuntimeOptions): TerminateDISyncInstanceResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.fileId)) {
    body['FileId'] = request.fileId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'TerminateDISyncInstance',
    version = '2018-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function terminateDISyncInstance(request: TerminateDISyncInstanceRequest): TerminateDISyncInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return terminateDISyncInstanceWithOptions(request, runtime);
}

model TriggerDataLoaderResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model TriggerDataLoaderResponse = {
  headers: map[string]string(name='headers'),
  body: TriggerDataLoaderResponseBody(name='body'),
}

async function triggerDataLoaderWithOptions(runtime: Util.RuntimeOptions): TriggerDataLoaderResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'TriggerDataLoader',
    version = '2018-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function triggerDataLoader(): TriggerDataLoaderResponse {
  var runtime = new Util.RuntimeOptions{};
  return triggerDataLoaderWithOptions(runtime);
}

model UpdateDISyncAlarmRuleRequest {
  alarmInterval?: int32(name='AlarmInterval'),
  alarmReceivers?: string(name='AlarmReceivers'),
  alarmRobotAtAllEnabled?: boolean(name='AlarmRobotAtAllEnabled'),
  alarmRobotTokens?: string(name='AlarmRobotTokens'),
  criticalAlarmModes?: string(name='CriticalAlarmModes'),
  criticalMetricRule?: string(name='CriticalMetricRule'),
  metricType?: string(name='MetricType'),
  projectId?: long(name='ProjectId'),
  ruleDescription?: string(name='RuleDescription'),
  ruleEnabled?: boolean(name='RuleEnabled'),
  ruleId?: long(name='RuleId'),
  ruleName?: string(name='RuleName'),
  warningAlarmModes?: string(name='WarningAlarmModes'),
  warningMetricRule?: string(name='WarningMetricRule'),
}

model UpdateDISyncAlarmRuleResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateDISyncAlarmRuleResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateDISyncAlarmRuleResponseBody(name='body'),
}

async function updateDISyncAlarmRuleWithOptions(request: UpdateDISyncAlarmRuleRequest, runtime: Util.RuntimeOptions): UpdateDISyncAlarmRuleResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.alarmInterval)) {
    body['AlarmInterval'] = request.alarmInterval;
  }
  if (!Util.isUnset(request.alarmReceivers)) {
    body['AlarmReceivers'] = request.alarmReceivers;
  }
  if (!Util.isUnset(request.alarmRobotAtAllEnabled)) {
    body['AlarmRobotAtAllEnabled'] = request.alarmRobotAtAllEnabled;
  }
  if (!Util.isUnset(request.alarmRobotTokens)) {
    body['AlarmRobotTokens'] = request.alarmRobotTokens;
  }
  if (!Util.isUnset(request.criticalAlarmModes)) {
    body['CriticalAlarmModes'] = request.criticalAlarmModes;
  }
  if (!Util.isUnset(request.criticalMetricRule)) {
    body['CriticalMetricRule'] = request.criticalMetricRule;
  }
  if (!Util.isUnset(request.metricType)) {
    body['MetricType'] = request.metricType;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.ruleDescription)) {
    body['RuleDescription'] = request.ruleDescription;
  }
  if (!Util.isUnset(request.ruleEnabled)) {
    body['RuleEnabled'] = request.ruleEnabled;
  }
  if (!Util.isUnset(request.ruleId)) {
    body['RuleId'] = request.ruleId;
  }
  if (!Util.isUnset(request.ruleName)) {
    body['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.warningAlarmModes)) {
    body['WarningAlarmModes'] = request.warningAlarmModes;
  }
  if (!Util.isUnset(request.warningMetricRule)) {
    body['WarningMetricRule'] = request.warningMetricRule;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDISyncAlarmRule',
    version = '2018-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDISyncAlarmRule(request: UpdateDISyncAlarmRuleRequest): UpdateDISyncAlarmRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDISyncAlarmRuleWithOptions(request, runtime);
}

model UpdateDISyncTaskRequest {
  concurrent?: int32(name='Concurrent'),
  fileId?: long(name='FileId'),
  memory?: float(name='Memory'),
  projectId?: long(name='ProjectId'),
  resGroupIdentifier?: string(name='ResGroupIdentifier'),
  tableMapping?: [ 
    {
      dstTable?: string(name='DstTable'),
      srcTable?: string(name='SrcTable'),
    }
  ](name='TableMapping'),
}

model UpdateDISyncTaskShrinkRequest {
  concurrent?: int32(name='Concurrent'),
  fileId?: long(name='FileId'),
  memory?: float(name='Memory'),
  projectId?: long(name='ProjectId'),
  resGroupIdentifier?: string(name='ResGroupIdentifier'),
  tableMappingShrink?: string(name='TableMapping'),
}

model UpdateDISyncTaskResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateDISyncTaskResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateDISyncTaskResponseBody(name='body'),
}

async function updateDISyncTaskWithOptions(tmpReq: UpdateDISyncTaskRequest, runtime: Util.RuntimeOptions): UpdateDISyncTaskResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateDISyncTaskShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.tableMapping)) {
    request.tableMappingShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tableMapping, 'TableMapping', 'json');
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.concurrent)) {
    body['Concurrent'] = request.concurrent;
  }
  if (!Util.isUnset(request.fileId)) {
    body['FileId'] = request.fileId;
  }
  if (!Util.isUnset(request.memory)) {
    body['Memory'] = request.memory;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.resGroupIdentifier)) {
    body['ResGroupIdentifier'] = request.resGroupIdentifier;
  }
  if (!Util.isUnset(request.tableMappingShrink)) {
    body['TableMapping'] = request.tableMappingShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDISyncTask',
    version = '2018-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDISyncTask(request: UpdateDISyncTaskRequest): UpdateDISyncTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDISyncTaskWithOptions(request, runtime);
}

